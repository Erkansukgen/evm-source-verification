{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "NFT.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n//   _    _ _   _                __ _\r\n//  | |  (_) | | |              / _(_)\r\n//  | | ___| |_| |_ ___ _ __   | |_ _ _ __   __ _ _ __   ___ ___\r\n//  | |/ / | __| __/ _ \\ '_ \\  |  _| | '_ \\ / _` | '_ \\ / __/ _ \\\r\n//  |   <| | |_| ||  __/ | | |_| | | | | | | (_| | | | | (_|  __/\r\n//  |_|\\_\\_|\\__|\\__\\___|_| |_(_)_| |_|_| |_|\\__,_|_| |_|\\___\\___|\r\n//\r\n//  Kitten NFT by Kitten.Finance\r\n//\r\n//  https://Kitten.Finance\r\n//\r\npragma solidity ^0.8.7;\r\n\r\ninterface IERC20 \r\n{\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721 \r\n{\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    \r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\ncontract KittenNFT is IERC721, IERC721Metadata\r\n{\r\n    address public govAddr;\r\n\r\n    constructor () {\r\n        govAddr = msg.sender;\r\n    }\r\n\r\n    uint64 UINT64_MAX = 2**64-1;\r\n    \r\n    uint public constant MAX_SUPPLY = 420;\r\n    \r\n    uint public constant PRICE_SCALE = (10**6);\r\n    uint64 public constant PRICE_KIF_MIN_SCALED = uint64(1 * (10**17) / PRICE_SCALE); // min price = 0.1 KIF or KIF-LP\r\n\r\n    uint public TRADE_GIFT_DIVIDER = 0; // if 100 then 1/100 = 1% gift\r\n    uint public TRADE_KIF_NEW_BP = 10100; // if 10100 then 1% price growth\r\n\r\n    uint public PRICE_DECAY_TIME_MAX = 7 days;\r\n\r\n    modifier govOnly() {\r\n    \trequire (msg.sender == govAddr, \"!gov\");\r\n    \t_;\r\n    }\r\n    function govTransferAddr(address newAddr) external govOnly {\r\n    \trequire (newAddr != address(0), \"!addr\");\r\n    \tgovAddr = newAddr;\r\n    }\r\n    function govSet_TRADE_GIFT_DIVIDER(uint value) external govOnly {\r\n        require(value >= 0);\r\n        TRADE_GIFT_DIVIDER = value;\r\n    }\r\n    function govSet_TRADE_KIF_NEW_BP(uint value) external govOnly {\r\n        require(value >= 10000);\r\n        TRADE_KIF_NEW_BP = value;\r\n    }\r\n    \r\n    function getTOKENaddr(uint id) public pure returns (address) { // !!! EDIT ME !!!\r\n        if ((id%10!=4) && (id%10!=5))\r\n            return 0x177BA0cac51bFC7eA24BAd39d81dcEFd59d74fAa; // KIF\r\n        return 0x9f11faF42A16D986F7BFd6338F41dB880da6DF39; // KIF-LP\r\n    }\r\n    \r\n    //====================================================================\r\n\r\n    uint constant SHIFT_lastTradeKIF_Scaled = 8;\r\n    uint constant SHIFT_lastTradeTime = 72;\r\n    uint constant SHIFT_priceKIF_willDecay = 104;\r\n    uint constant SHIFT_priceKIF_Scaled = 112;\r\n    uint constant SHIFT_priceETH_Scaled = 176;\r\n\r\n    uint constant MASK_priceETH_Scaled = (2**256-1) - ((2**64-1) << SHIFT_priceETH_Scaled);\r\n\r\n    struct KITTEN {\r\n        address payable owner;\r\n        \r\n        // priceETH_Scaled  priceKIF_Scaled  priceKIF_willDecay  lastTradeTime  lastTradeKIF_Scaled\r\n        //   64 << 176         64 << 112         8 << 104          32 << 72            64 << 8\r\n        uint256 xx;\r\n        // uint64 priceETH_Scaled;        // 0 or UINT256_MAX ==> not for sale\r\n        // uint64 priceKIF_Scaled;\r\n        // uint8  priceKIF_willDecay;     // 0 = fixed, 1 = decaying\r\n        // uint32 lastTradeTime;\r\n        // uint64 lastTradeKIF_Scaled;\r\n\r\n        uint256 magic; // owner can set magic\r\n\r\n        address operator;\r\n    }\r\n    mapping(uint => KITTEN) public kittens;\r\n    \r\n    function name() public pure override returns (string memory) {\r\n        return \"Kitten NFT by Kitten.Finance\";\r\n    }\r\n    function symbol() public pure override returns (string memory) {\r\n        return \"KittenNFT\";\r\n    }\r\n    function tokenURI(uint256 tokenId) public pure override returns (string memory) {\r\n        tokenId = tokenId;\r\n        return \"https://kitten.finance\";\r\n    }\r\n    function totalSupply() public pure returns (uint256) {\r\n        return MAX_SUPPLY;\r\n    }\r\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) { // 0x80ac58cd, 0x5b5e139f\r\n        return (interfaceId == type(IERC721).interfaceId) || (interfaceId == type(IERC721Metadata).interfaceId);\r\n    }\r\n    \r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    \r\n    function balanceOf(address owner) external view override returns (uint256 balance) \r\n    {\r\n        require(owner != address(0), '!zeroAddr');\r\n        return _balances[owner];\r\n    }\r\n    function ownerOf(uint256 tokenId) external view override returns (address owner) \r\n    {\r\n        return kittens[tokenId].owner;\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) external override view returns (address operator) {\r\n        return kittens[tokenId].operator;\r\n    }\r\n    function isApprovedForAll(address owner, address operator) external override view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n    function approve(address to, uint256 tokenId) external override\r\n    {\r\n        KITTEN storage kitten = kittens[tokenId];\r\n        require((msg.sender == kitten.owner) || _operatorApprovals[kitten.owner][msg.sender], '!permission');\r\n        \r\n        kitten.operator = to;\r\n\r\n        emit Approval(kitten.owner, to, tokenId);\r\n    }\r\n    function setApprovalForAll(address operator, bool approved) external override \r\n    {\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n    function isApproved(uint id, address user, address operator) public view returns (bool)\r\n    {\r\n        if (_operatorApprovals[user][operator])\r\n            return true;\r\n        if (kittens[id].operator == operator)\r\n            return true;\r\n        return false;\r\n    }\r\n    \r\n    function _transfer(address from, address to, uint256 tokenId) internal\r\n    {\r\n        require(((tokenId >= 1) && (tokenId <= MAX_SUPPLY)), '!id');\r\n        require(to != address(0), '!zeroAddr');\r\n        require(from != address(0), '!zeroAddr');\r\n        \r\n        KITTEN storage kitten = kittens[tokenId];\r\n        require(from == kitten.owner, '!owner');\r\n        \r\n        if (msg.sender != from) {\r\n            require(isApproved(tokenId, from, msg.sender), '!approval');\r\n        }\r\n        \r\n        _balances[from] -= 1;\r\n        kitten.owner = payable(to);\r\n        kitten.operator = address(0);\r\n        _balances[to] += 1;\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n    function transferFrom(address from, address to, uint256 tokenId) external override {\r\n        _transfer(from, to, tokenId);\r\n    }\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external override {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, \"\"), \"!ERC721Receiver\");\r\n    }\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, data), \"!ERC721Receiver\");\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) \r\n    {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) \r\n    {\r\n        if (isContract(to)) {\r\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"!ERC721Receiver\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }    \r\n\r\n    //====================================================================\r\n    \r\n    event SET_MAGIC(uint indexed id, uint magic);\r\n    \r\n    function Set_Magic(uint id, uint magic) external \r\n    {\r\n        KITTEN storage kitten = kittens[id];\r\n        require(msg.sender == kitten.owner, '!owner');\r\n        require(magic != kitten.magic, '!unchanged');\r\n        \r\n        kitten.magic = magic;\r\n        emit SET_MAGIC(id, magic);\r\n    }\r\n    \r\n    event SET_PRICE_ETH(uint indexed id, uint priceETH);\r\n\r\n    function Set_Price_ETH(uint id, uint priceETH) external \r\n    {\r\n        KITTEN storage kitten = kittens[id];\r\n        require(msg.sender == kitten.owner, '!owner');\r\n        \r\n        require(priceETH > 0, '!price');\r\n        require(priceETH <= UINT64_MAX * PRICE_SCALE, '!priceOverflow');\r\n        \r\n        uint xx = kitten.xx & MASK_priceETH_Scaled;\r\n        kitten.xx = xx | (uint(uint64(priceETH / PRICE_SCALE)) << SHIFT_priceETH_Scaled);\r\n        \r\n        emit SET_PRICE_ETH(id, priceETH);\r\n    }\r\n    \r\n    //====================================================================\r\n\r\n    event BUY_KITTEN(uint indexed id, address indexed origOwner, address indexed newOwner, uint tradeType, uint tradeAmt);\r\n    event SELL_KITTEN(uint indexed id, address indexed origOwner, uint tradeAmt);\r\n\r\n    function Buy_Kitten(uint id, uint tradeType, uint64 amtIn_Scaled, uint magic) external payable \r\n    {\r\n        require((id >= 1) && (id <= MAX_SUPPLY), '!id');\r\n        \r\n        address payable user = payable(msg.sender);\r\n        \r\n        KITTEN storage kitten = kittens[id];\r\n        {\r\n            uint amtTrade = uint(amtIn_Scaled) * PRICE_SCALE;\r\n            {\r\n                uint64 priceETH_Scaled; uint64 priceKIF_Scaled; uint8 priceKIF_willDecay; \r\n                uint32 lastTradeTime; uint64 lastTradeKIF_Scaled;\r\n                {\r\n                    uint xx = kitten.xx;\r\n                    priceETH_Scaled = uint64(xx >> SHIFT_priceETH_Scaled);\r\n                    priceKIF_Scaled = uint64(xx >> SHIFT_priceKIF_Scaled);\r\n                    priceKIF_willDecay = uint8(xx >> SHIFT_priceKIF_willDecay);\r\n                    lastTradeTime = uint32(xx >> SHIFT_lastTradeTime);\r\n                    lastTradeKIF_Scaled = uint64(xx >> SHIFT_lastTradeKIF_Scaled);\r\n                }\r\n                if (tradeType == 0) // buy with ETH\r\n                {\r\n                    require(priceETH_Scaled != 0, '!notForSaleInETH');\r\n                    require((msg.value == amtTrade) && (amtIn_Scaled >= priceETH_Scaled), '!price');\r\n                    \r\n                    if (amtIn_Scaled > priceETH_Scaled) {\r\n                        user.transfer(uint(amtIn_Scaled - priceETH_Scaled) * PRICE_SCALE);\r\n                    }\r\n                    amtTrade = uint(priceETH_Scaled) * PRICE_SCALE;\r\n                } \r\n                else // buy with KIF\r\n                {\r\n                    uint price_Scaled = priceKIF_Scaled;\r\n                    \r\n                    if (priceKIF_willDecay > 0) \r\n                    {\r\n                        uint decayTime = block.timestamp - uint(lastTradeTime);\r\n                        if (decayTime >= PRICE_DECAY_TIME_MAX)\r\n                            price_Scaled = PRICE_KIF_MIN_SCALED;\r\n                        else \r\n                            price_Scaled = price_Scaled * (PRICE_DECAY_TIME_MAX - decayTime) / PRICE_DECAY_TIME_MAX;\r\n                    }\r\n                    \r\n                    if (price_Scaled < PRICE_KIF_MIN_SCALED) {\r\n                        price_Scaled = PRICE_KIF_MIN_SCALED;\r\n                    }\r\n                    require(amtIn_Scaled >= price_Scaled, '!price');\r\n                    \r\n                    IERC20(getTOKENaddr(id)).transferFrom(msg.sender, address(this), amtTrade); // send KIF to contract\r\n                }\r\n                \r\n                if (kitten.owner != address(0)) // pay to last owner\r\n                {\r\n                    if (tradeType == 0) { // buy with ETH -> send ETH to previous owner\r\n                        (kitten.owner).transfer(amtTrade);\r\n                    } \r\n                    else {\r\n                        uint amtOut = uint(lastTradeKIF_Scaled) * PRICE_SCALE;\r\n                        if (TRADE_GIFT_DIVIDER > 0) \r\n                        {   // send gift to last owner\r\n                            uint amtGift = amtTrade / TRADE_GIFT_DIVIDER;\r\n                            amtOut += amtGift;\r\n                            amtTrade -= amtGift;\r\n                        }\r\n                        IERC20(getTOKENaddr(id)).transfer(kitten.owner, amtOut);\r\n                    }\r\n                }\r\n                \r\n                priceETH_Scaled = UINT64_MAX;\r\n                if (tradeType != 0) { // buy with KIF -> set new KIF price\r\n                    priceKIF_Scaled = uint64(amtTrade * TRADE_KIF_NEW_BP / 10000 / PRICE_SCALE);\r\n                    lastTradeKIF_Scaled = uint64(amtTrade / PRICE_SCALE);\r\n                }\r\n                priceKIF_willDecay = 0;\r\n                lastTradeTime = uint32(block.timestamp);\r\n\r\n                kitten.xx = (uint(priceETH_Scaled) << SHIFT_priceETH_Scaled) | (uint(priceKIF_Scaled) << SHIFT_priceKIF_Scaled)\r\n                            | (uint(priceKIF_willDecay) << SHIFT_priceKIF_willDecay) | (uint(lastTradeTime) << SHIFT_lastTradeTime)\r\n                            | (uint(lastTradeKIF_Scaled) << SHIFT_lastTradeKIF_Scaled);\r\n            }\r\n            emit BUY_KITTEN(id, kitten.owner, user, tradeType, amtTrade);\r\n        }\r\n        emit Transfer(kitten.owner, user, id);\r\n\r\n        if (kitten.owner != address(0))\r\n            _balances[kitten.owner] -= 1;\r\n        \r\n        kitten.owner = user;\r\n        kitten.operator = address(0);\r\n        _balances[user] += 1;\r\n        \r\n        if (magic != kitten.magic) {\r\n            kitten.magic = magic;\r\n            emit SET_MAGIC(id, magic);\r\n        }\r\n    }\r\n    \r\n    function Sell_Kitten(uint id) external\r\n    {\r\n        KITTEN storage kitten = kittens[id];\r\n        require(msg.sender == kitten.owner, '!owner');\r\n        \r\n        uint xx = kitten.xx;\r\n        uint64 priceETH_Scaled = uint64(xx >> SHIFT_priceETH_Scaled);\r\n        uint64 priceKIF_Scaled = uint64(xx >> SHIFT_priceKIF_Scaled);\r\n        uint8 priceKIF_willDecay = uint8(xx >> SHIFT_priceKIF_willDecay);\r\n        uint32 lastTradeTime = uint32(xx >> SHIFT_lastTradeTime);\r\n        uint64 lastTradeKIF_Scaled = uint64(xx >> SHIFT_lastTradeKIF_Scaled);\r\n\r\n        uint amtOut = uint(lastTradeKIF_Scaled) * PRICE_SCALE;\r\n        IERC20(getTOKENaddr(id)).transfer(kitten.owner, amtOut);\r\n        \r\n        priceETH_Scaled = UINT64_MAX;\r\n        priceKIF_willDecay = 1;\r\n\r\n        lastTradeTime = uint32(block.timestamp);\r\n        lastTradeKIF_Scaled = 0;\r\n        \r\n        kitten.xx = (uint(priceETH_Scaled) << SHIFT_priceETH_Scaled) | (uint(priceKIF_Scaled) << SHIFT_priceKIF_Scaled)\r\n                    | (uint(priceKIF_willDecay) << SHIFT_priceKIF_willDecay) | (uint(lastTradeTime) << SHIFT_lastTradeTime)\r\n                    | (uint(lastTradeKIF_Scaled) << SHIFT_lastTradeKIF_Scaled);        \r\n        \r\n        emit SELL_KITTEN(id, msg.sender, amtOut);\r\n        emit Transfer(kitten.owner, address(0), id);\r\n        \r\n        _balances[kitten.owner] -= 1;\r\n        \r\n        kitten.owner = payable(address(0));\r\n        kitten.operator = address(0);\r\n    }\r\n}\r\n"
    }
  }
}