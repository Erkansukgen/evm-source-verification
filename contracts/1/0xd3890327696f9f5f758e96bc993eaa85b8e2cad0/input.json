{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/rewarder presale .sol": {
      "content": "pragma solidity ^0.7.0;\n//SPDX-License-Identifier: UNLICENSED\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address who) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function transfer(address to, uint value) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    \n    function unPauseTransferForever() external;\n    function uniswapV2Pair() external returns(address);\n}\ninterface IUNIv2 {\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) \n    external \n    payable \n    returns (uint amountToken, uint amountETH, uint liquidity);\n    \n    function WETH() external pure returns (address);\n\n}\n\ninterface IUnicrypt {\n    event onDeposit(address, uint256, uint256);\n    event onWithdraw(address, uint256);\n    function depositToken(address token, uint256 amount, uint256 unlock_date) external payable; \n    function withdrawToken(address token, uint256 amount) external;\n\n}\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n\ncontract Rewarder_Presale is Context, ReentrancyGuard {\n    using SafeMath for uint;\n    IERC20 public RWD;\n    address public _burnPool = 0x000000000000000000000000000000000000dEaD;\n\n    IUNIv2 constant uniswap =  IUNIv2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV2Factory constant uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n    IUnicrypt constant unicrypt = IUnicrypt(0x17e00383A843A9922bCA3B280C0ADE9f8BA48449);\n    \n    uint public tokensBought;\n    bool public isStopped = false;\n    bool public teamClaimed = false;\n    bool public moonMissionStarted = false;\n    bool public isRefundEnabled = false;\n    bool public presaleStarted = false;\n    bool justTrigger = false;\n    uint constant teamTokens = 50000 ether;\n\n    address payable owner;\n    address payable constant owner1 = 0x3a2E19237CE888cFAf58a828Fc91117B48203Fdb;\n    address payable constant owner2 = 0xE89d168Ac7F31617316Ded2802DE2783974739e8;\n    address payable constant owner3 = 0x276F4dA68cf789DeCe07b0d55844eac51a606541;\n    \n    address public pool;\n    \n    uint256 public liquidityUnlock;\n    \n    uint256 public ethSent;\n    uint256 constant tokensPerETH = 997;\n    uint256 public lockedLiquidityAmount;\n    uint256 public timeToWithdrawTeamTokens;\n    uint256 public refundTime; \n    mapping(address => uint) ethSpent;\n    \n     modifier onlyOwner() {\n        require(msg.sender == owner, \"You are not the owner\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender; \n        liquidityUnlock = block.timestamp.add(180 days);\n        refundTime = block.timestamp.add(7 days);\n    }\n    \n    \n    receive() external payable {\n        \n        buyTokens();\n    }\n    \n    function allowRefunds() external onlyOwner nonReentrant {\n        isRefundEnabled = true;\n        isStopped = true;\n    }\n    \n    function getRefund() external nonReentrant {\n        require(msg.sender == tx.origin);\n        require(!justTrigger);\n        // To get refund it should be enabled by the owner OR 7 days had passed \n        require(isRefundEnabled || block.timestamp >= refundTime,\"Cannot refund\");\n        address payable user = msg.sender;\n        uint256 amount = ethSpent[user];\n        ethSpent[user] = 0;\n        user.transfer(amount);\n    }\n    \n    function lockWithUnicrypt() external onlyOwner  {\n        pool = RWD.uniswapV2Pair();\n        IERC20 liquidityTokens = IERC20(pool);\n        // Lock the whole contract LP balance\n        uint256 liquidityBalance = liquidityTokens.balanceOf(address(this));\n        uint256 timeToLock = liquidityUnlock;\n        liquidityTokens.approve(address(unicrypt), liquidityBalance);\n\n        unicrypt.depositToken{value: 0} (pool, liquidityBalance, timeToLock);\n        lockedLiquidityAmount = lockedLiquidityAmount.add(liquidityBalance);\n    }\n    \n    function withdrawFromUnicrypt(uint256 amount) external onlyOwner {\n        unicrypt.withdrawToken(pool, amount);\n    }\n    \n    function withdrawTeamTokens() external onlyOwner nonReentrant {\n        require(teamClaimed);\n        require(block.timestamp >= timeToWithdrawTeamTokens, \"Cannot withdraw yet\");\n        // 5000 total RWD every 14 days total 50000\n        uint256 tokesToClaim = 5000 ether;\n        uint256 amount = tokesToClaim.div(3); \n        RWD.transfer(owner1, amount);\n        RWD.transfer(owner2, amount);\n        RWD.transfer(owner3, amount);\n        timeToWithdrawTeamTokens = block.timestamp.add(14 days);\n    }\n\n    function setRWD(IERC20 addr) external onlyOwner nonReentrant {\n        require(RWD == IERC20(address(0)), \"You can set the address only once\");\n        RWD = addr;\n    }\n    \n    function startPresale() external onlyOwner { \n        presaleStarted = true;\n    }\n    \n     function pausePresale() external onlyOwner { \n        presaleStarted = false;\n    }\n\n    function buyTokens() public payable nonReentrant {\n        require(msg.sender == tx.origin);\n        require(presaleStarted == true, \"Presale is paused, do not send ETH\");\n        require(RWD != IERC20(address(0)), \"Main contract address not set\");\n        require(!isStopped, \"Presale stopped by contract, do not send ETH\");\n        require(msg.value >= 0.1 ether, \"You sent less than 0.1 ETH\");\n        require(msg.value <= 3 ether, \"You sent more than 3 ETH\");\n        require(ethSent < 200 ether, \"Hard cap reached\");\n        require(msg.value.add(ethSent) <= 200 ether, \"Hardcap will be reached\");\n        require(ethSpent[msg.sender].add(msg.value) <= 3 ether, \"You cannot buy more\");\n        uint256 tokens = msg.value.mul(tokensPerETH);\n        require(RWD.balanceOf(address(this)) >= tokens, \"Not enough tokens in the contract\");\n        ethSpent[msg.sender] = ethSpent[msg.sender].add(msg.value);\n        tokensBought = tokensBought.add(tokens);\n        ethSent = ethSent.add(msg.value);\n        RWD.transfer(msg.sender, tokens);\n    }\n   \n    function userEthSpenttInPresale(address user) external view returns(uint){\n        return ethSpent[user];\n    }\n    \n \n    \n    function claimTeamFeeAndAddLiquidityLETSFUCKINGGOOOO() external onlyOwner  {\n       require(!teamClaimed);\n       uint256 amountETH = address(this).balance.mul(17).div(100); \n       uint256 amountETH2 = address(this).balance.mul(12).div(100); \n       uint256 amountETH3 = address(this).balance.mul(11).div(100); \n       owner1.transfer(amountETH);\n       owner2.transfer(amountETH2);\n       owner3.transfer(amountETH3);\n       teamClaimed = true;\n       \n       addLiquidity();\n    }\n        \n    function addLiquidity() internal {\n        uint256 ETH = address(this).balance;\n        uint256 tokensForUniswap = address(this).balance.mul(939);\n        uint256 tokensToBurn = RWD.balanceOf(address(this)).sub(tokensForUniswap).sub(teamTokens);\n        RWD.unPauseTransferForever();\n        RWD.approve(address(uniswap), tokensForUniswap);\n        uniswap.addLiquidityETH\n        { value: ETH }\n        (\n            address(RWD),\n            tokensForUniswap,\n            tokensForUniswap,\n            ETH,\n            address(this),\n            block.timestamp\n        );\n       \n       if (tokensToBurn > 0){\n           RWD.transfer(_burnPool ,tokensToBurn);\n       }\n       \n       justTrigger = true;\n       \n        if(!isStopped)\n            isStopped = true;\n            \n   }\n    \n    function unlockTokensAfterSixMonhts(address tokenAddress, uint256 tokenAmount) external onlyOwner  {\n        require(block.timestamp >= liquidityUnlock, \"You cannot withdraw yet\");\n        IERC20(tokenAddress).transfer(owner, tokenAmount);\n    }\n\n}\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  }
}