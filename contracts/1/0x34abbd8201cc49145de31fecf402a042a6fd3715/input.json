{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/MFS.sol":{"content":"pragma solidity ^0.6.0;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\n abstract   contract  ERC20Interface {\r\n    function  totalSupply()virtual public  view returns (uint);\r\n    function balanceOf(address tokenOwner) virtual public  view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender)virtual public  view returns (uint remaining);\r\n    function transfer(address to, uint tokens)virtual public  returns (bool success);\r\n    function approve(address spender, uint tokens) virtual public  returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens)virtual public   returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\nabstract contract PETH {\r\n     function GetUserInfo(address user) virtual public view returns (bool ,uint256,address,uint256,uint256,uint256,uint256);\r\n}\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\nabstract  contract  ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public ;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract MFS_Stacking is  Owned {\r\n\r\n    event EVENT_REGISTER(address indexed user);\r\n    event EVENT_STACK(address indexed user, uint period_id, uint tokens);\r\n    event EVENT_RECEIVE(address indexed user, uint period_id,uint tokens);\r\n    event EVENT_UNSTACK(address indexed user, uint period_id, uint tokens);\r\n\r\n    struct  User{\r\n        bool Registered;\r\n        address User_Address;\r\n        address Referer_Address;\r\n        uint Stacking_Amount;\r\n        \r\n        uint256 [8] Token_Amounts;\r\n        uint Stacking_Block_Number_Start;\r\n        uint Stacking_Operation_Block_Stamp;\r\n        uint256 [8] LastUpdatedSumOfWeightedStacking;\r\n        \r\n        \r\n        uint256 [8] Stacking_Amounts;\r\n        uint256 [8] Block_of_Last_Stack;\r\n        \r\n    }\r\n    \r\n    uint256 [8] public m_Block_weight_of_Stack_Options;\r\n    uint256 [8] public m_Block_Span_of_Stack_Options;\r\n    \r\n    using SafeMath for uint;\r\n    //addr for user updater\r\n    address public m_Updater_Address;\r\n    //addr for user relationship\r\n    //address public m_Referer_Info_Address;\r\n    // addr for stacking token\r\n    address public m_Stacking_Address;\r\n    // addr for target token \r\n    address public m_Token_Address;\r\n\r\n    //game's block span\r\n    uint public m_Stacking_Block_Number_Start;\r\n    uint public m_Stacking_Block_Number_Stop;\r\n    \r\n    // total amount of stacking\r\n    uint256 public m_Total_Stacking; \r\n    // total user number\r\n    uint256 public m_User_Count;\r\n\r\n\r\n    uint256 public m_BlockNumOfLastUpdate=0;\r\n    uint256 [8] public m_SumOfWeightedStacking_of_Stack_Options;\r\n \r\n    // indicate whether game is paused true=pause false=play\r\n    bool m_Game_Pause;\r\n    //if user unstacking within a span of blocks take 10% receiving token for fee;  \r\n    uint256 m_Punishment_Span;\r\n    modifier onlyPayloadSize(uint size) {\r\n        require(!(msg.data.length < size + 4));\r\n        _;\r\n    }\r\n    modifier NotGamePause()\r\n    {\r\n        require(m_Game_Pause!=true);\r\n        _;\r\n    }\r\n    modifier OnlyRegistered()\r\n    {\r\n        require(m_User_Map[msg.sender].Registered==true);\r\n        _;\r\n    }\r\n    mapping(address => User) public  m_User_Map;\r\n    constructor() public {\r\n        m_Total_Stacking=1;\r\n        m_Game_Pause=false;\r\n        m_User_Count=1;\r\n        m_Punishment_Span=1;\r\n        m_BlockNumOfLastUpdate=block.number;\r\n        m_Stacking_Block_Number_Start=block.number;\r\n        m_Stacking_Block_Number_Stop=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n        \r\n        for(uint i=0;i<8;i++)\r\n        {\r\n        m_SumOfWeightedStacking_of_Stack_Options[i]=1e18;\r\n        }\r\n    }\r\n\r\n    function Set_Token_Address( address stacking,address token) public onlyOwner{\r\n        m_Stacking_Address=stacking;\r\n        m_Token_Address=token;\r\n    }\r\n \r\n\r\n    function Set_Updater_Address( address addr) public onlyOwner{\r\n        m_Updater_Address=addr;\r\n    }\r\n\r\n    function Set_Punishment_Span( uint span) public onlyOwner{\r\n        m_Punishment_Span=span;\r\n    }\r\n    function Pause( ) public onlyOwner{\r\n       m_Game_Pause=true;\r\n       m_Stacking_Block_Number_Stop=block.number;\r\n    }\r\n    function Resume( ) public onlyOwner{\r\n       m_Game_Pause=false;\r\n       m_Stacking_Block_Number_Stop=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n    }\r\n\r\n    function Start_At(uint block_number) public onlyOwner{\r\n            if(block_number==0)\r\n            {\r\n                uint number = block.number;\r\n                m_Stacking_Block_Number_Start=number;\r\n            }else\r\n            {\r\n                m_Stacking_Block_Number_Start=block_number;\r\n            }\r\n    }\r\n    function Stop_At(uint block_number) public onlyOwner{\r\n            if(block_number==0)\r\n            {\r\n                uint number = block.number;\r\n                 m_Stacking_Block_Number_Stop=number;\r\n            }else\r\n            {\r\n                 m_Stacking_Block_Number_Stop=block_number;\r\n            }\r\n    }\r\n    function Get_User_Info(address user ) public view returns(bool ,address, address, uint,uint)\r\n    {\r\n        return\r\n        (\r\n        m_User_Map[user]. Registered,\r\n        m_User_Map[user]. User_Address,\r\n        m_User_Map[user]. Referer_Address,\r\n        m_User_Map[user]. Stacking_Amount,\r\n        m_User_Map[user]. Stacking_Operation_Block_Stamp\r\n        );\r\n    }\r\n     function Get_User_Stackings(address user ) public view returns(  uint[8] memory)\r\n     {\r\n          return\r\n        (\r\n          m_User_Map[user]. Stacking_Amounts \r\n        );\r\n     }\r\n     \r\n    function Get_User_Block_of_Last_Stack(address user ) public view returns(  uint[8] memory)\r\n     {\r\n          return\r\n        (\r\n          m_User_Map[user]. Block_of_Last_Stack \r\n        );\r\n     }\r\n     \r\n    function Get_Game_Info() public view returns(uint256,uint256,uint256 )\r\n    {\r\n        return(\r\n            m_Total_Stacking,m_User_Count,m_Punishment_Span\r\n        );\r\n    }\r\n    function Do_Registering() public  NotGamePause returns(bool){\r\n        // initialize user data\r\n        Update_Global_Data();\r\n        //require( Referer != address(0),\"REFERER ERROR\");\r\n        require( m_User_Map[msg.sender].Registered==false,\"USER EXIST\");\r\n        m_User_Map[msg.sender].Registered=true;\r\n        m_User_Map[msg.sender].User_Address=msg.sender;\r\n        //m_User_Map[msg.sender].Referer_Address=GetRefererAddress(msg.sender); \r\n        m_User_Map[msg.sender].Stacking_Block_Number_Start= block.number;\r\n        m_User_Map[msg.sender].LastUpdatedSumOfWeightedStacking=m_SumOfWeightedStacking_of_Stack_Options;\r\n        \r\n        for(uint i=0;i<8;i++)\r\n        {\r\n        m_User_Map[msg.sender].Block_of_Last_Stack[i]=block.number;\r\n        }\r\n        emit EVENT_REGISTER(msg.sender);\r\n        return true;\r\n    }\r\n    function Do_Stacking(uint period_id,uint stacking_amount) public OnlyRegistered  NotGamePause returns(bool){\r\n           uint256 exa_amount=0;\r\n           uint256 old_balance= ERC20Interface(m_Stacking_Address).balanceOf(address(this));\r\n            //transfer from user to contract\r\n            bool res=false;\r\n            res=ERC20Interface(m_Stacking_Address).transferFrom(msg.sender, address(this),stacking_amount);\r\n            if(res ==false)\r\n            {\r\n                //if failed revert transaction;\r\n                 revert();\r\n            }\r\n            uint256 new_balance= ERC20Interface(m_Stacking_Address).balanceOf(address(this));\r\n            exa_amount=new_balance.sub(old_balance);\r\n            \r\n            uint256 old_stacking_amount=m_User_Map[msg.sender].Stacking_Amount;\r\n\r\n            // update token value in pass;\r\n            Update_Global_Data();\r\n            Update_User(msg.sender);\r\n            m_User_Map[msg.sender].Stacking_Operation_Block_Stamp=block.number;\r\n            m_User_Map[msg.sender].Block_of_Last_Stack[period_id]=block.number;\r\n            // update user and contract data\r\n            m_Total_Stacking=m_Total_Stacking.add(exa_amount);\r\n            m_User_Map[msg.sender].Stacking_Amount= m_User_Map[msg.sender].Stacking_Amount+exa_amount;        \r\n            m_User_Map[msg.sender].Stacking_Amounts[period_id]= m_User_Map[msg.sender].Stacking_Amounts[period_id]+exa_amount;\r\n          \r\n            if(old_stacking_amount<15e16 && m_User_Map[msg.sender].Stacking_Amount>=15e16  )\r\n            {\r\n                m_User_Count=m_User_Count+1;\r\n            }\r\n\r\n            emit EVENT_STACK(msg.sender,period_id, exa_amount);\r\n            return true;\r\n    }\r\n    function Do_Receiving(uint period_id) public  OnlyRegistered  NotGamePause returns(bool) {\r\n\r\n        Update_Global_Data();\r\n        Update_User(msg.sender);\r\n        bool res=false;\r\n\r\n        res=ERC20Interface(m_Token_Address).transfer(msg.sender,m_User_Map[msg.sender].Token_Amounts[period_id]);\r\n        \r\n        if(res ==false)\r\n        {\r\n            revert();\r\n        }\r\n    \r\n\r\n        emit EVENT_RECEIVE(msg.sender,period_id, m_User_Map[msg.sender].Token_Amounts[period_id]);\r\n        \r\n        m_User_Map[msg.sender].Token_Amounts[period_id]=0;\r\n        return true;\r\n    }\r\n\r\n    function Do_Unstacking(uint period_id ,uint stacking_amount) public  OnlyRegistered   returns(bool)  {\r\n            \r\n            uint bn=block.number;\r\n            uint256 block_span=bn.sub(m_User_Map[msg.sender].Block_of_Last_Stack[period_id]);\r\n            require(block_span>= m_Block_Span_of_Stack_Options[period_id]);\r\n            //check balance\r\n            require( m_User_Map[msg.sender].Stacking_Amounts[period_id]>=stacking_amount);\r\n            \r\n            Update_Global_Data();\r\n            Update_User(msg.sender);\r\n            uint256 old_stacking_amount=m_User_Map[msg.sender].Stacking_Amount;\r\n            bool res=false;\r\n            res=ERC20Interface(m_Stacking_Address).transfer(msg.sender,stacking_amount);\r\n            if(res ==false)\r\n            {\r\n                 revert();\r\n            }\r\n            m_User_Map[msg.sender].Stacking_Amounts[period_id]=m_User_Map[msg.sender].Stacking_Amounts[period_id].sub(stacking_amount);\r\n            m_Total_Stacking=m_Total_Stacking.sub(stacking_amount);\r\n            if(old_stacking_amount>=15e16 && m_User_Map[msg.sender].Stacking_Amount<15e16 )\r\n            {\r\n                m_User_Count=m_User_Count-1;\r\n            }\r\n            emit EVENT_UNSTACK(msg.sender,period_id, stacking_amount);\r\n            return true;\r\n    }\r\n   function Do_Game_Update() public    returns(bool){\r\n        require(msg.sender==m_Updater_Address,\"DISQUALIFIED\");\r\n        Update_Global_Data();\r\n         //Update_User(user,false);\r\n        return true;\r\n    }\r\n    function Do_Update_User(address user) public    returns(bool){\r\n        require(msg.sender==m_Updater_Address,\"DISQUALIFIED\");\r\n        //Update_Global_Data();\r\n        require(m_User_Map[user].Registered==true);\r\n        Update_User(user);\r\n        return true;\r\n    }\r\n    function Update_Global_Data() private\r\n    {\r\n         uint block_num_clamp=block.number;\r\n        if(block_num_clamp>m_Stacking_Block_Number_Stop)\r\n        {\r\n            block_num_clamp=m_Stacking_Block_Number_Stop;\r\n        }\r\n        if(block_num_clamp<m_Stacking_Block_Number_Start)\r\n        {\r\n            block_num_clamp=m_Stacking_Block_Number_Start;\r\n        }\r\n\r\n        uint256 block_span=block_num_clamp-m_BlockNumOfLastUpdate;\r\n        if(block_span==0)\r\n        {\r\n            //m_TotalStackingOfLastUpdate=stacking_amount+m_TotalStackingOfLastUpdate;\r\n        }else{\r\n            uint256 delta=  1;\r\n            for(uint i=0;i<8;i++)\r\n            {\r\n                delta=block_span*m_Block_weight_of_Stack_Options[i];\r\n                m_SumOfWeightedStacking_of_Stack_Options[i]=m_SumOfWeightedStacking_of_Stack_Options[i]+delta;\r\n            }\r\n        }\r\n        m_BlockNumOfLastUpdate=block_num_clamp;\r\n    }\r\n    function Do_Update() public  OnlyRegistered  NotGamePause returns(bool){\r\n        Update_Global_Data();\r\n        Update_User(msg.sender);\r\n        return true;\r\n    }\r\n    function Update_User(address user) private\r\n    {   \r\n        if(m_User_Map[user].Registered==false)\r\n        {\r\n            return;\r\n        }\r\n        uint block_num_clamp=block.number;\r\n        if(block_num_clamp>m_Stacking_Block_Number_Stop)\r\n        {\r\n            block_num_clamp=m_Stacking_Block_Number_Stop;\r\n        }\r\n            m_User_Map[user].User_Address=user;\r\n            //// check user's block number which should be lower than  current number and greater than 0;\r\n            if(m_User_Map[user].Stacking_Block_Number_Start<=m_Stacking_Block_Number_Start)\r\n            {\r\n                m_User_Map[user].Stacking_Block_Number_Start= block_num_clamp;\r\n            }\r\n            if(m_User_Map[user].Stacking_Block_Number_Start> block_num_clamp)\r\n            {\r\n                m_User_Map[user].Stacking_Block_Number_Start= block_num_clamp;\r\n            }\r\n            if(m_User_Map[user].Stacking_Block_Number_Start>= m_Stacking_Block_Number_Stop )\r\n            {\r\n                m_User_Map[user].Stacking_Block_Number_Start=m_Stacking_Block_Number_Stop;\r\n            }\r\n\r\n////BASE///////////////////////////////////////////////////////////////\r\n        \r\n        uint sum_of_quantity=0;\r\n        for (uint i =0;i<8;i++)\r\n        {\r\n            uint quantity=m_SumOfWeightedStacking_of_Stack_Options[i].sub( m_User_Map[user].LastUpdatedSumOfWeightedStacking[i]);\r\n        \r\n            quantity= m_User_Map[user].Stacking_Amounts[i]*quantity/1e18;\r\n            ////Update Token Data////////////////////////////////////////////////////////////\r\n            m_User_Map[user].Token_Amounts[i]= m_User_Map[user].Token_Amounts[i].add(quantity);\r\n        \r\n            sum_of_quantity=sum_of_quantity+quantity;\r\n        }\r\n       \r\n\r\n\r\n////Update Block Number////////////////////////////////////////////////////////////       \r\n        m_User_Map[user].Stacking_Block_Number_Start= block_num_clamp;\r\n////Update LastUpdatedSumOfWeightedStackingReciprocale128////////////////////////////////////////////////////////////       \r\n        m_User_Map[user].LastUpdatedSumOfWeightedStacking= m_SumOfWeightedStacking_of_Stack_Options;\r\n    \r\n    \r\n    }\r\n    \r\n\r\n\r\n    function Take_Token(address token_address,uint token_amount) public onlyOwner{\r\n           ERC20Interface(token_address).transfer(msg.sender,token_amount);\r\n    }\r\n    \r\n    function TakeFee10(uint token_amount) private pure returns (uint) {\r\n            uint res=token_amount;\r\n            res=res*9;\r\n            res=res/10;\r\n            return res;\r\n    }\r\n    function ViewReceiving(address user) public view  returns (uint256[8]memory) {\r\n       ////Get how many blocks between last operation and current block///\r\n        uint block_num_clamp=block.number;\r\n        if(block_num_clamp>m_Stacking_Block_Number_Stop)\r\n        {\r\n            block_num_clamp=m_Stacking_Block_Number_Stop;\r\n        }\r\n        if(block_num_clamp<m_Stacking_Block_Number_Start)\r\n        {\r\n            block_num_clamp=m_Stacking_Block_Number_Start;\r\n        }\r\n\r\n        uint256 block_span=block_num_clamp-m_BlockNumOfLastUpdate;\r\n        uint256 [8] memory t_SumOfWeightedStacking_of_Stack_Options=m_SumOfWeightedStacking_of_Stack_Options;\r\n        if(block_span==0)\r\n        {\r\n            //m_TotalStackingOfLastUpdate=stacking_amount+m_TotalStackingOfLastUpdate;\r\n        }else{\r\n            uint delta=1;\r\n             for(uint i=0;i<8;i++)\r\n            {\r\n                delta=block_span*m_Block_weight_of_Stack_Options[i];\r\n                \r\n                t_SumOfWeightedStacking_of_Stack_Options[i]=t_SumOfWeightedStacking_of_Stack_Options[i]+delta;\r\n            }\r\n            \r\n        }\r\n////BASE///////////////////////////////////////////////////////////////\r\n        \r\n        \r\n        uint256[8] memory t_Token_Amounts=m_User_Map[user].Token_Amounts;\r\n        uint256 sum_of_quantity=0;\r\n        for (uint i =0;i<8;i++)\r\n        {\r\n            uint quantity=t_SumOfWeightedStacking_of_Stack_Options[i].sub( m_User_Map[user].LastUpdatedSumOfWeightedStacking[i]);\r\n            quantity= m_User_Map[user].Stacking_Amounts[i]*quantity/1e18;\r\n            t_Token_Amounts[i]=t_Token_Amounts[i].add(quantity);\r\n            sum_of_quantity=sum_of_quantity+quantity;\r\n        }\r\n /////////////////////////////////////////////////////////////////////////////   \r\n    \r\n        return t_Token_Amounts;\r\n    }\r\n\r\n\r\n\r\n    function Set_Block_Weight(uint period_id, uint256 block_weight)public onlyOwner\r\n    {\r\n        m_Block_weight_of_Stack_Options[period_id]=block_weight;\r\n    }\r\n\r\n    function Set_Period_Span(uint period_id, uint256 block_span)public onlyOwner\r\n    {\r\n        m_Block_Span_of_Stack_Options [period_id]=block_span;\r\n    }\r\n    fallback() external payable {}\r\n    receive() external payable { \r\n   \r\n    }\r\n    function Call_Function(address addr,uint256 value ,bytes memory data) public  onlyOwner {\r\n      addr.call.value(value)(data);\r\n    }\r\n}\r\n"}}}