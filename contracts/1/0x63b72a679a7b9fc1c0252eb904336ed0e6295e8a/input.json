{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CORXLPFarmNEW.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract CORXLPFarm {\r\n    address public owner;\r\n    IERC20 public TKN;\r\n\r\n    struct Stake {\r\n        uint256 amount;\r\n        uint256 debt;\r\n        uint32 started;\r\n    }\r\n\r\n    struct Program {\r\n        IERC20 LPTKN; // LP Token address\r\n        uint256 M; // Multiplier. Default is 10 == 100% APY\r\n        uint256 B; // LP Token wei amount per 1.00 CORX token in that LP\r\n        uint32 start; // program starts since\r\n        uint32 finish; // program finishes at\r\n    }\r\n    uint256 public constant k = 3171; // 10% (base APY unit) APY == x0.000,274 per day = x0.000,000,003,171 per second\r\n\r\n    Program[] public programs;\r\n    mapping(uint256 => mapping(address => Stake)) public stakeOf;\r\n\r\n    event Deposit(address indexed sender, uint256 indexed pid, uint256 amount, uint256 debt);\r\n    event Withdraw(address indexed sender, uint256 indexed pid, uint256 amount, uint256 debt);\r\n    event Harvest(address indexed sender, uint256 indexed pid, uint256 amount);\r\n\r\n    modifier restricted {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function addProgram(IERC20 _LPTKN, uint256 _multiplier, uint256 _baseratio, uint32 _start, uint32 _finish) public restricted {\r\n        programs.push(Program({LPTKN: _LPTKN, M: _multiplier, B: _baseratio, start: _start, finish: _finish}));\r\n    }\r\n\r\n    function getPending(uint256 _pid, address _user, uint32 _to) public view returns (uint256) {\r\n        Program storage _p = programs[_pid];\r\n        Stake storage _s = stakeOf[_pid][_user];\r\n        if (_to > _p.finish) _to = _p.finish;\r\n        return _s.debt + ((_p.M * k * (_to - _s.started) * _s.amount * 2) / (_p.B * 1e4));\r\n    }\r\n\r\n    function getPending(uint256 _pid, address _user) public view returns (uint256) {\r\n        return getPending(_pid, _user, uint32(block.timestamp));\r\n    }\r\n\r\n    function getPending(uint256 _pid) public view returns (uint256) {\r\n        return getPending(_pid, msg.sender);\r\n    }\r\n\r\n    function pLength() public view returns (uint256) {\r\n        return programs.length;\r\n    }\r\n\r\n    function stake(uint256 _pid, uint256 _amount) public {\r\n        Program storage _p = programs[_pid];\r\n        Stake storage _s = stakeOf[_pid][msg.sender];\r\n        require(_s.amount == 0 && _amount > 0 && block.timestamp >=_p.start  && block.timestamp < _p.finish);\r\n        require(_p.LPTKN.transferFrom(msg.sender, address(this), _amount));\r\n        _s.amount = _amount;\r\n        _s.started = uint32(block.timestamp);\r\n        emit Deposit(msg.sender, _pid, _amount, 0);\r\n    }\r\n\r\n    function unstake(uint256 _pid) public {\r\n        Stake storage _s = stakeOf[_pid][msg.sender];\r\n        require(_s.amount > 0);\r\n        programs[_pid].LPTKN.transfer(msg.sender, _s.amount);\r\n        uint256 _toSend = getPending(_pid);\r\n        if (_toSend > 0) {\r\n            TKN.transfer(msg.sender, _toSend);\r\n            emit Harvest(msg.sender, _pid, _toSend);\r\n        }\r\n        emit Withdraw(msg.sender, _pid, _s.amount, 0);\r\n        delete stakeOf[_pid][msg.sender];\r\n    }\r\n\r\n    function increase(uint256 _pid, uint256 _amount) public {\r\n        Program storage _p = programs[_pid];\r\n        Stake storage _s = stakeOf[_pid][msg.sender];\r\n        require(_s.amount > 0 && _amount > 0 && block.timestamp < _p.finish);\r\n        require(_p.LPTKN.transferFrom(msg.sender, address(this), _amount));\r\n        _s.debt = getPending(_pid);\r\n        _s.amount += _amount;\r\n        _s.started = uint32(block.timestamp);\r\n        emit Deposit(msg.sender, _pid, _amount, _s.debt);\r\n    }\r\n\r\n    function decrease(uint256 _pid, uint256 _amount) public {\r\n        Program storage _p = programs[_pid];\r\n        Stake storage _s = stakeOf[_pid][msg.sender];\r\n        require(_s.amount > _amount && _amount > 0 && block.timestamp < _p.finish);\r\n        _p.LPTKN.transfer(msg.sender, _amount);\r\n        _s.debt = getPending(_pid);\r\n        _s.amount -= _amount;\r\n        _s.started = uint32(block.timestamp);\r\n        emit Withdraw(msg.sender, _pid, _amount, _s.debt);\r\n    }\r\n\r\n    function harvest(uint256 _pid) public {\r\n        Stake storage _s = stakeOf[_pid][msg.sender];\r\n        uint256 _toSend = getPending(_pid);\r\n        require(_toSend > 0);\r\n        TKN.transfer(msg.sender, _toSend);\r\n        _s.debt = 0;\r\n        uint32 _f = programs[_pid].finish;\r\n        _s.started = uint32(block.timestamp < _f ? block.timestamp : _f);\r\n        emit Harvest(msg.sender, _pid, _toSend);\r\n    }\r\n\r\n    function harvestAll() public {\r\n        for (uint256 i = 0; i < pLength(); i++) if (getPending(i) > 0) harvest(i);\r\n    }\r\n\r\n    function infoBundle(address _user) public view returns (Program[] memory pp, Stake[] memory ss, uint256[] memory all, uint256[] memory bal) {\r\n        pp = programs;\r\n        uint256 _l = pp.length;\r\n        ss = new Stake[](_l);\r\n        all = new uint256[](_l);\r\n        bal = new uint256[](_l);\r\n        for (uint256 i = 0; i < _l; i++) {\r\n            ss[i] = stakeOf[i][_user];\r\n            all[i] = pp[i].LPTKN.allowance(_user, address(this));\r\n            bal[i] = pp[i].LPTKN.balanceOf(_user);\r\n        }\r\n    }\r\n\r\n    function take(IERC20 _TKN, uint256 _amount) public restricted {\r\n        _TKN.transfer(msg.sender, _amount > 0 ? _amount : _TKN.balanceOf(address(this)));\r\n    }\r\n\r\n    function transferOwnership(address _owner) public restricted {\r\n        owner = _owner;\r\n    }\r\n\r\n    constructor(IERC20 _TKN) {\r\n        owner = msg.sender;\r\n        TKN = _TKN;\r\n    }\r\n}\r\n"}}}