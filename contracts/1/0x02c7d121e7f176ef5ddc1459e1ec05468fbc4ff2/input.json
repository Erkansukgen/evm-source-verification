{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MultiSigWalletWithTimelock.sol": {
      "content": "/**\r\n *Submitted for verification at BscScan.com on 2020-12-07\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2020-11-08\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2020-08-13\r\n*/\r\n\r\npragma solidity 0.5.8;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IUnisavePair {\r\n    function depositAll0() external;  \r\n    function depositAll1() external;\r\n    function depositSome0(uint) external;\r\n    function depositSome1(uint) external;\r\n    function setY0(address) external;\r\n    function setY1(address) external;\r\n    function setFee(uint16) external;    \r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);           \r\n}\r\n\r\ninterface IUnisaveFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ncontract MultiSigWalletWithTimelock {\r\n\r\n    uint256 constant public MAX_OWNER_COUNT = 50;\r\n    address constant public unisave_factory = address(0x32CE36F6eA8d97f9fC19Aab83b9c6D2F52D74470);\r\n    address constant public gainswap_factory = address(0x756627591715d0F1aA285c80E62675e949ED19F5);    \r\n\r\n    uint256 public lockSeconds = 60;\r\n\r\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\r\n    event Revocation(address indexed sender, uint256 indexed transactionId);\r\n    event Submission(uint256 indexed transactionId);\r\n    event Execution(uint256 indexed transactionId);\r\n    event ExecutionFailure(uint256 indexed transactionId);\r\n    event Deposit(address indexed sender, uint256 value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint256 required);\r\n    event UnlockTimeSet(uint256 indexed transactionId, uint256 confirmationTime);\r\n    event LockSecondsChange(uint256 lockSeconds);\r\n\r\n    mapping (uint256 => Transaction) public transactions;\r\n    mapping (uint256 => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    mapping (uint256 => uint256) public unlockTimes;\r\n    \r\n    address[] public owners;\r\n    uint256 public required;\r\n    uint256 public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint256 value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    struct EmergencyCall {\r\n        bytes32 selector;\r\n        uint256 paramsBytesCount;\r\n    }\r\n\r\n    // Functions bypass the time lock process\r\n    EmergencyCall[] public emergencyCalls;\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this))\r\n            revert(\"ONLY_WALLET_ERROR\");\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner])\r\n            revert(\"OWNER_DOES_NOT_EXIST_ERROR\");\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner])\r\n            revert(\"OWNER_EXISTS_ERROR\");\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint256 transactionId) {\r\n        if (transactions[transactionId].destination == address(0))\r\n            revert(\"TRANSACTION_EXISTS_ERROR\");\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint256 transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner])\r\n            revert(\"CONFIRMED_ERROR\");\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint256 transactionId, address owner) {\r\n        if (confirmations[transactionId][owner])\r\n            revert(\"NOT_CONFIRMED_ERROR\");\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint256 transactionId) {\r\n        if (transactions[transactionId].executed)\r\n            revert(\"NOT_EXECUTED_ERROR\");\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == address(0))\r\n            revert(\"NOT_NULL_ERROR\");\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint256 ownerCount, uint256 _required) {\r\n        if (ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0)\r\n            revert(\"VALID_REQUIREMENT_ERROR\");\r\n        _;\r\n    }\r\n\r\n    /** @dev Fallback function allows to deposit ether. */\r\n    function() external payable {\r\n        if (msg.value > 0) {\r\n            emit Deposit(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    /** @dev Contract constructor sets initial owners and required number of confirmations.\r\n      * @param _owners List of initial owners.\r\n      * @param _required Number of required confirmations.\r\n      */\r\n    constructor(address[] memory _owners, uint256 _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n\r\n        // YFII https://github.com/yfii/yvault/blob/master/contracts/standard/v2/config.json\r\n        whiteListVault[0x72Cf258c852Dc485a853370171d46B9D29fD3184] = true; // iUSDT\r\n        whiteListVault[0x3E3db9cc5b540d2794DB3861BE5A4887cF77E48B] = true; // iycrv\r\n        whiteListVault[0x1e0DC67aEa5aA74718822590294230162B5f2064] = true; // idai\r\n        whiteListVault[0x4243f5C8683089b65a9F588B1AE578d5D84bFBC9] = true; // itusd\r\n        whiteListVault[0x23B4dB3a435517fd5f2661a9c5a16f78311201c1] = true; // iusdc        \r\n        whiteListVault[0xa8EA49a9e242fFfBdECc4583551c3BcB111456E6] = true; // ieth\r\n        whiteListVault[0xc46d2fC00554f1f874F37e6e3E828A0AdFEFfbcB] = true; // iBUSD\r\n        whiteListVault[0x26AEdD2205FF8a87AEF2eC9691d77Ce3f40CE6E9] = true; // iHBTC        \r\n\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == address(0)) {\r\n                revert(\"OWNER_ERROR\");\r\n            }\r\n\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n\r\n        owners = _owners;\r\n        required = _required;\r\n\r\n        // initialzie Emergency calls\r\n        emergencyCalls.push(\r\n            EmergencyCall({\r\n                selector: keccak256(abi.encodePacked(\"setMarketBorrowUsability(uint16,bool)\")),\r\n                paramsBytesCount: 64\r\n            })\r\n        );\r\n    }\r\n\r\n    function getEmergencyCallsCount()\r\n        external\r\n        view\r\n        returns (uint256 count)\r\n    {\r\n        return emergencyCalls.length;\r\n    }\r\n\r\n    /** @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n      * @param owner Address of new owner.\r\n      */\r\n    function addOwner(address owner)\r\n        external\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        emit OwnerAddition(owner);\r\n    }\r\n\r\n    /** @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n      * @param owner Address of owner.\r\n      */\r\n    function removeOwner(address owner)\r\n        external\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint256 i = 0; i < owners.length - 1; i++) {\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        }\r\n\r\n        owners.length -= 1;\r\n\r\n        if (required > owners.length) {\r\n            changeRequirement(owners.length);\r\n        }\r\n\r\n        emit OwnerRemoval(owner);\r\n    }\r\n\r\n    /** @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n      * @param owner Address of owner to be replaced.\r\n      * @param owner Address of new owner.\r\n      */\r\n    function replaceOwner(address owner, address newOwner)\r\n        external\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        }\r\n\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        emit OwnerRemoval(owner);\r\n        emit OwnerAddition(newOwner);\r\n    }\r\n\r\n    /** @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n      * @param _required Number of required confirmations.\r\n      */\r\n    function changeRequirement(uint256 _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n    /** @dev Changes the duration of the time lock for transactions.\r\n      * @param _lockSeconds Duration needed after a transaction is confirmed and before it becomes executable, in seconds.\r\n      */\r\n    function changeLockSeconds(uint256 _lockSeconds)\r\n        external\r\n        onlyWallet\r\n    {\r\n        lockSeconds = _lockSeconds;\r\n        emit LockSecondsChange(_lockSeconds);\r\n    }\r\n\r\n    /** @dev Allows an owner to submit and confirm a transaction.\r\n      * @param destination Transaction target address.\r\n      * @param value Transaction ether value.\r\n      * @param data Transaction data payload.\r\n      * @return Returns transaction ID.\r\n      */\r\n    function submitTransaction(address destination, uint256 value, bytes calldata data)\r\n        external\r\n        ownerExists(msg.sender)\r\n        notNull(destination)\r\n        returns (uint256 transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        emit Submission(transactionId);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /** @dev Allows an owner to confirm a transaction.\r\n      * @param transactionId Transaction ID.\r\n      */\r\n    function confirmTransaction(uint256 transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n\r\n        if (isConfirmed(transactionId) && unlockTimes[transactionId] == 0 && !isEmergencyCall(transactionId)) {\r\n            uint256 unlockTime = block.timestamp + lockSeconds;\r\n            unlockTimes[transactionId] = unlockTime;\r\n            emit UnlockTimeSet(transactionId, unlockTime);\r\n        }\r\n    }\r\n\r\n    function isEmergencyCall(uint256 transactionId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes memory data = transactions[transactionId].data;\r\n\r\n        for (uint256 i = 0; i < emergencyCalls.length; i++) {\r\n            EmergencyCall memory emergencyCall = emergencyCalls[i];\r\n\r\n            if (\r\n                data.length == emergencyCall.paramsBytesCount + 4 &&\r\n                data.length >= 4 &&\r\n                emergencyCall.selector[0] == data[0] &&\r\n                emergencyCall.selector[1] == data[1] &&\r\n                emergencyCall.selector[2] == data[2] &&\r\n                emergencyCall.selector[3] == data[3]\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @dev Allows an owner to revoke a confirmation for a transaction.\r\n      * @param transactionId Transaction ID.\r\n      */\r\n    function revokeConfirmation(uint256 transactionId)\r\n        external\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /** @dev Allows anyone to execute a confirmed transaction.\r\n      * @param transactionId Transaction ID.\r\n      */\r\n    function executeTransaction(uint256 transactionId)\r\n        external\r\n        ownerExists(msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        require(\r\n            block.timestamp >= unlockTimes[transactionId],\r\n            \"TRANSACTION_NEED_TO_UNLOCK\"\r\n        );\r\n\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage transaction = transactions[transactionId];\r\n            transaction.executed = true;\r\n            (bool success, ) = transaction.destination.call.value(transaction.value)(transaction.data);\r\n            if (success)\r\n                emit Execution(transactionId);\r\n            else {\r\n                emit ExecutionFailure(transactionId);\r\n                transaction.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Returns the confirmation status of a transaction.\r\n      * @param transactionId Transaction ID.\r\n      * @return Confirmation status.\r\n      */\r\n    function isConfirmed(uint256 transactionId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 count = 0;\r\n\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                count += 1;\r\n            }\r\n\r\n            if (count >= required) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /* Web3 call functions */\r\n\r\n    /** @dev Returns number of confirmations of a transaction.\r\n      * @param transactionId Transaction ID.\r\n      * @return Number of confirmations.\r\n      */\r\n    function getConfirmationCount(uint256 transactionId)\r\n        external\r\n        view\r\n        returns (uint256 count)\r\n    {\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Returns total number of transactions after filers are applied.\r\n      * @param pending Include pending transactions.\r\n      * @param executed Include executed transactions.\r\n      * @return Total number of transactions after filters are applied.\r\n      */\r\n    function getTransactionCount(bool pending, bool executed)\r\n        external\r\n        view\r\n        returns (uint256 count)\r\n    {\r\n        for (uint256 i = 0; i < transactionCount; i++) {\r\n            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev Returns list of owners.\r\n      * @return List of owner addresses.\r\n      */\r\n    function getOwners()\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    /** @dev Returns array with owner addresses, which confirmed transaction.\r\n      * @param transactionId Transaction ID.\r\n      * @return Returns array of owner addresses.\r\n      */\r\n    function getConfirmations(uint256 transactionId)\r\n        external\r\n        view\r\n        returns (address[] memory _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint256 count = 0;\r\n        uint256 i;\r\n\r\n        for (i = 0; i < owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        }\r\n\r\n        _confirmations = new address[](count);\r\n\r\n        for (i = 0; i < count; i++) {\r\n            _confirmations[i] = confirmationsTemp[i];\r\n        }\r\n    }\r\n    \r\n    /* Unisave Routine Maintenance */\r\n    \r\n    mapping (address => bool) public whiteListVault;   \r\n    \r\n    modifier onlyWhiteListVault(address vault) {\r\n        require(whiteListVault[vault], 'only whitelist vault');\r\n        _;\r\n    }\r\n    \r\n    modifier onlyUnisavePair(address pair) {\r\n        address token0 = IUnisavePair(pair).token0();\r\n        address token1 = IUnisavePair(pair).token1();\r\n        require(IUnisaveFactory(unisave_factory).getPair(token0, token1) == pair || IUnisaveFactory(gainswap_factory).getPair(token0, token1) == pair, \"only unisave pair\");\r\n        _;\r\n    }\r\n    \r\n    function depositAll0(address pair) external ownerExists(msg.sender) onlyUnisavePair(pair) {\r\n        IUnisavePair(pair).depositAll0();\r\n    }\r\n    function depositAll1(address pair) external ownerExists(msg.sender) onlyUnisavePair(pair) {\r\n        IUnisavePair(pair).depositAll1();        \r\n    }\r\n    function depositSome0(address pair, uint amount) external ownerExists(msg.sender) onlyUnisavePair(pair) {\r\n        IUnisavePair(pair).depositSome0(amount);\r\n    }\r\n    function depositSome1(address pair, uint amount) external ownerExists(msg.sender) onlyUnisavePair(pair) {\r\n        IUnisavePair(pair).depositSome1(amount);        \r\n    }\r\n    function setY0(address pair, address vault) external ownerExists(msg.sender) onlyWhiteListVault(vault) onlyUnisavePair(pair) {\r\n        IUnisavePair(pair).setY0(vault);     \r\n    }\r\n    function setY1(address pair, address vault) external ownerExists(msg.sender) onlyWhiteListVault(vault) onlyUnisavePair(pair) {\r\n        IUnisavePair(pair).setY1(vault);     \r\n    }\r\n    function setFee(address pair, uint16 _fee) external ownerExists(msg.sender) onlyUnisavePair(pair) {\r\n        IUnisavePair(pair).setFee(_fee);     \r\n    }    \r\n    function addWhiteListVault(address vault) external onlyWallet {\r\n        whiteListVault[vault] = true;\r\n    }\r\n    function removeWhiteListVault(address vault) external onlyWallet {\r\n        whiteListVault[vault] = false;\r\n    }\r\n}"
    }
  }
}