{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/mainmodulev2.sol": {
      "content": "\n// File: contracts/interfaces/IERC1271Wallet.sol\n\npragma solidity ^0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface  IERC1271Wallet {\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n   *   > This function MAY modify Ethereum's state\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\n   * @param _signature  Signature byte array associated with _data\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes calldata _data,\n    bytes calldata _signature)\n    external\n    view\n    returns (bytes4 magicValue);\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n   *   > This function MAY modify Ethereum's state\n   * @param _hash       keccak256 hash that was signed\n   * @param _signature  Signature byte array associated with _data\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes calldata _signature)\n    external\n    view\n    returns (bytes4 magicValue);\n}\n\n// File: contracts/utils/LibBytes.sol\n\n/*\n  Copyright 2018 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n  This is a truncated version of the original LibBytes.sol library from ZeroEx.\n*/\n\npragma solidity ^0.6.6;\n\nlibrary LibBytes {\n  using LibBytes for bytes;\n\n  /***********************************|\n  |        Pop Bytes Functions        |\n  |__________________________________*/\n\n  /**\n   * @dev Pops the last byte off of a byte array by modifying its length.\n   * @param b Byte array that will be modified.\n   * @return result The byte that was popped off.\n   */\n  function popLastByte(bytes memory b)\n    internal\n    pure\n    returns (bytes1 result)\n  {\n    require(\n      b.length > 0,\n      \"LibBytes#popLastByte: GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n    );\n\n    // Store last byte.\n    result = b[b.length - 1];\n\n    assembly {\n      // Decrement length of byte array.\n      let newLen := sub(mload(b), 1)\n      mstore(b, newLen)\n    }\n    return result;\n  }\n\n\n  /***********************************|\n  |        Read Bytes Functions       |\n  |__________________________________*/\n\n  /**\n   * @dev Read firsts uint16 value.\n   * @param data Byte array to be read.\n   * @return a uint16 value of data at index zero.\n   * @return newIndex Updated index after reading the values.\n   */\n  function readFirstUint16(\n    bytes memory data\n  ) internal pure returns (\n    uint16 a,\n    uint256 newIndex\n  ) {\n    assembly {\n      let word := mload(add(32, data))\n      a := shr(240, word)\n      newIndex := 2\n    }\n    require(2 <= data.length, \"LibBytes#readFirstUint16: OUT_OF_BOUNDS\");\n  }\n\n  /**\n   * @dev Reads consecutive bool (8 bits) and uint8 values.\n   * @param data Byte array to be read.\n   * @param index Index in byte array of uint8 and uint8 values.\n   * @return a bool (8 bits) value of data at given index.\n   * @return b uint8 value of data at given index + 8.\n   * @return newIndex Updated index after reading the values.\n   */\n  function readBoolUint8(\n    bytes memory data,\n    uint256 index\n  ) internal pure returns (\n    bool a,\n    uint8 b,\n    uint256 newIndex\n  ) {\n    assembly {\n      let word := mload(add(index, add(32, data)))\n      a := shr(248, word)\n      b := and(shr(240, word), 0xff)\n      newIndex := add(index, 2)\n    }\n    require(newIndex <= data.length, \"LibBytes#readUint8Uint8: OUT_OF_BOUNDS\");\n  }\n\n  /**\n   * @dev Reads an address value from a position in a byte array.\n   * @param data Byte array to be read.\n   * @param index Index in byte array of address value.\n   * @return a address value of data at given index.\n   * @return newIndex Updated index after reading the value.\n   */\n  function readAddress(\n    bytes memory data,\n    uint256 index\n  ) internal pure returns (\n    address a,\n    uint256 newIndex\n  ) {\n    assembly {\n      let word := mload(add(index, add(32, data)))\n      a := and(shr(96, word), 0xffffffffffffffffffffffffffffffffffffffff)\n      newIndex := add(index, 20)\n    }\n    require(newIndex <= data.length, \"LibBytes#readAddress: OUT_OF_BOUNDS\");\n  }\n\n  /**\n   * @dev Reads 66 bytes from a position in a byte array.\n   * @param data Byte array to be read.\n   * @param index Index in byte array of 66 bytes value.\n   * @return a 66 bytes bytes array value of data at given index.\n   * @return newIndex Updated index after reading the value.\n   */\n  function readBytes66(\n    bytes memory data,\n    uint256 index\n  ) internal pure returns (\n    bytes memory a,\n    uint256 newIndex\n  ) {\n    a = new bytes(66);\n    assembly {\n      let offset := add(32, add(data, index))\n      mstore(add(a, 32), mload(offset))\n      mstore(add(a, 64), mload(add(offset, 32)))\n      mstore(add(a, 66), mload(add(offset, 34)))\n      newIndex := add(index, 66)\n    }\n    require(newIndex <= data.length, \"LibBytes#readBytes66: OUT_OF_BOUNDS\");\n  }\n\n  /**\n   * @dev Reads a bytes32 value from a position in a byte array.\n   * @param b Byte array containing a bytes32 value.\n   * @param index Index in byte array of bytes32 value.\n   * @return result bytes32 value from byte array.\n   */\n  function readBytes32(\n    bytes memory b,\n    uint256 index\n  )\n    internal\n    pure\n    returns (bytes32 result)\n  {\n    require(\n      b.length >= index + 32,\n      \"LibBytes#readBytes32: GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n    );\n\n    // Arrays are prefixed by a 256 bit length parameter\n    uint256 pos = index + 32;\n\n    // Read the bytes32 from array memory\n    assembly {\n      result := mload(add(b, pos))\n    }\n    return result;\n  }\n}\n\n// File: contracts/utils/SignatureValidator.sol\n\npragma solidity ^0.6.6;\n\n\n\n\n/**\n * @dev Contains logic for signature validation.\n * Signatures from wallet contracts assume ERC-1271 support (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md)\n * Notes: Methods are strongly inspired by contracts in https://github.com/0xProject/0x-monorepo/blob/development/\n */\ncontract SignatureValidator {\n  using LibBytes for bytes;\n\n  /***********************************|\n  |             Variables             |\n  |__________________________________*/\n\n  // bytes4(keccak256(\"isValidSignature(bytes,bytes)\"))\n  bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\n\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n  bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\n\n  // Allowed signature types.\n  enum SignatureType {\n    Illegal,         // 0x00, default value\n    EIP712,          // 0x01\n    EthSign,         // 0x02\n    NSignatureTypes  // 0x03, number of signature types. Always leave at end.\n  }\n\n  // Encoding of signatures\n  struct Signature {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    SignatureType sigType;\n  }\n\n  /***********************************|\n  |        Signature Functions        |\n  |__________________________________*/\n\n /**\n   * @notice Recover the signer of hash, assuming it's an EOA account\n   * @dev Only for SignatureType.EIP712 and SignatureType.EthSign signatures\n   * @param _hash      Hash that was signed\n   *   encoded as (bytes32 r, bytes32 s, uint8 v, ... , SignatureType sigType)\n   */\n  function recoverSigner(\n    bytes32 _hash,\n    bytes memory _signature\n  ) public pure returns (address signer) {\n    // Pop last byte off of signature byte array.\n    uint8 signatureTypeRaw = uint8(_signature.popLastByte());\n\n    // Extract signature type\n    SignatureType signatureType = SignatureType(signatureTypeRaw);\n\n    // Variables are not scoped in Solidity.\n    uint8 v = uint8(_signature[64]);\n    bytes32 r = _signature.readBytes32(0);\n    bytes32 s = _signature.readBytes32(32);\n\n    // Signature using EIP712\n    if (signatureType == SignatureType.EIP712) {\n      signer = ecrecover(_hash, v, r, s);\n\n    // Signed using web3.eth_sign() or Ethers wallet.signMessage()\n    } else if (signatureType == SignatureType.EthSign) {\n      signer = ecrecover(\n        keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash)),\n        v,\n        r,\n        s\n      );\n\n    } else {\n      // Anything other signature types are illegal (We do not return false because\n      // the signature may actually be valid, just not in a format\n      // that we currently support. In this case returning false\n      // may lead the caller to incorrectly believe that the\n      // signature was invalid.)\n      revert(\"SignatureValidator#isValidSignature: UNSUPPORTED_SIGNATURE_TYPE\");\n    }\n\n    // Prevent signer from being 0x0\n    require(\n      signer != address(0x0),\n      \"SignatureValidator#isValidSignature: INVALID_SIGNER\"\n    );\n\n    return signer;\n  }\n}\n\n// File: contracts/modules/commons/Implementation.sol\n\npragma solidity ^0.6.6;\n\n\n\n/**\n * @dev Allows modules to access the implementation slot\n */\ncontract Implementation {\n  /**\n   * @notice Updates the Wallet implementation\n   * @param _imp New implementation address\n   * @dev The wallet implementation is stored on the storage slot\n   *   defined by the address of the wallet itself\n   *   WARNING updating this value may brick the wallet\n   */\n  function _setImplementation(address _imp) internal {\n    assembly {\n      sstore(address(), _imp)\n    }\n  }\n\n  /**\n   * @notice Returns the Wallet implementation\n   * @return _imp The address of the current Wallet implementation\n   */\n  function _getImplementation() internal view returns (address _imp) {\n    assembly {\n      _imp := sload(address())\n    }\n  }\n}\n\n// File: contracts/modules/commons/interfaces/IModuleAuth.sol\n\npragma solidity ^0.6.6;\n\n\nabstract contract IModuleAuth {\n  /**\n   * @notice Hashed _data to be signed\n   * @param _data Data to be hashed\n   * @return hashed data for this wallet\n   */\n  function _hashData(\n    bytes memory _data\n  ) internal virtual view returns (bytes32);\n\n  /**\n   * @notice Verify if signer is default wallet owner\n   * @param _hash Hashed signed message\n   * @param _signature Encoded signature\n   * @return True is the signature is valid\n   */\n  function _signatureValidation(\n    bytes32 _hash,\n    bytes memory _signature\n  ) internal virtual view returns (bool);\n}\n\n// File: contracts/modules/commons/ModuleAuth.sol\n\npragma solidity ^0.6.6;\n\n\n\n\n\n\n\nabstract contract ModuleAuth is IModuleAuth, SignatureValidator, IERC1271Wallet {\n  using LibBytes for bytes;\n\n  /**\n   * @notice Verify if signer is default wallet owner\n   * @param _hash       Hashed signed message\n   * @param _signature  Array of signatures with signers ordered\n   *                    like the the keys in the multisig configs\n   *\n   * @dev The signature must be solidity packed and contain the total number of owners,\n   *      the threshold, the weigth and either the address or a signature for each owner.\n   *\n   *      Each weight & (address or signature) pair is prefixed by a boolean that signals if such pair\n   *      contains an address or a signature. The aggregated weight of the signatures must surpass the threshold.\n   *\n   *      E.g:\n   *      abi.encodePacked(\n   *        uint8 nSigners, uint16 threshold,\n   *        bool true,  uint8 weight_1, address signer_1,\n   *        bool false, uint8 weight_2, bytes signature_2,\n   *        ...\n   *        bool true,  uint8 weight_5, address signer_5\n   *      )\n   */\n  function _signatureValidation(\n    bytes32 _hash,\n    bytes memory _signature\n  )\n    internal override view returns (bool)\n  {\n    (\n      uint16 threshold,  // required threshold signature\n      uint256 rindex     // read index\n    ) = _signature.readFirstUint16();\n\n    // Start image hash generation\n    bytes32 imageHash = bytes32(uint256(threshold));\n\n    // Acumulated weight of signatures\n    uint256 totalWeight;\n\n    // Iterate until the image is completed\n    while (rindex < _signature.length) {\n      // Read next item type and addrWeight\n      bool isAddr; uint256 addrWeight; address addr;\n      (isAddr, addrWeight, rindex) = _signature.readBoolUint8(rindex);\n\n      if (isAddr) {\n        // Read plain address\n        (addr, rindex) = _signature.readAddress(rindex);\n      } else {\n        // Read single signature and recover signer\n        bytes memory signature;\n        (signature, rindex) = _signature.readBytes66(rindex);\n        addr = recoverSigner(_hash, signature);\n\n        // Acumulate total weight of the signature\n        totalWeight += addrWeight;\n      }\n\n      // Write weight and address to image\n      imageHash = keccak256(abi.encode(imageHash, addrWeight, addr));\n    }\n\n    return totalWeight >= threshold && _isValidImage(imageHash);\n  }\n\n  /**\n   * @notice Validates the signature image\n   * @param _imageHash Hashed image of signature\n   * @return true if the signature image is valid\n   */\n  function _isValidImage(bytes32 _imageHash) internal virtual view returns (bool);\n\n  /**\n   * @notice Will hash _data to be signed (similar to EIP-712)\n   * @param _data Data to be hashed\n   * @return hashed data for this wallet\n   */\n  function _hashData(bytes memory _data) internal override view returns (bytes32) {\n    return keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        address(this),\n        keccak256(_data)\n      )\n    );\n  }\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256(\"isValidSignature(bytes,bytes)\"))\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\n   * @param _signatures Signature byte array associated with _data.\n   *                    Encoded as abi.encode(Signature[], Configs)\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes calldata _data,\n    bytes calldata _signatures\n  ) external override view returns (bytes4) {\n    // Validate signatures\n    if (_signatureValidation(_hashData(_data), _signatures)) {\n      return 0x20c13b0b;\n    }\n  }\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\n   *   > The bytes4 magic value to return when signature is valid is 0x1626ba7e : bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n   * @param _hash       keccak256 hash that was signed\n   * @param _signatures Signature byte array associated with _data.\n   *                    Encoded as abi.encode(Signature[], Configs)\n   * @return magicValue Magic value 0x1626ba7e if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes calldata _signatures\n  ) external override view returns (bytes4) {\n    // Validate signatures\n    if (_signatureValidation(_hash, _signatures)) {\n      return 0x1626ba7e;\n    }\n  }\n}\n\n// File: contracts/Wallet.sol\n\npragma solidity ^0.6.6;\n\n/**\n    Minimal upgradeable proxy implementation, delegates all calls to the address\n    defined by the storage slot matching the wallet address.\n\n    Inspired by EIP-1167 Implementation (https://eips.ethereum.org/EIPS/eip-1167)\n\n    deployed code:\n\n        0x00    0x36         0x36      CALLDATASIZE      cds\n        0x01    0x3d         0x3d      RETURNDATASIZE    0 cds\n        0x02    0x3d         0x3d      RETURNDATASIZE    0 0 cds\n        0x03    0x37         0x37      CALLDATACOPY\n        0x04    0x3d         0x3d      RETURNDATASIZE    0\n        0x05    0x3d         0x3d      RETURNDATASIZE    0 0\n        0x06    0x3d         0x3d      RETURNDATASIZE    0 0 0\n        0x07    0x36         0x36      CALLDATASIZE      cds 0 0 0\n        0x08    0x3d         0x3d      RETURNDATASIZE    0 cds 0 0 0\n        0x09    0x30         0x30      ADDRESS           addr 0 cds 0 0 0\n        0x0A    0x54         0x54      SLOAD             imp 0 cds 0 0 0\n        0x0B    0x5a         0x5a      GAS               gas imp 0 cds 0 0 0\n        0x0C    0xf4         0xf4      DELEGATECALL      suc 0\n        0x0D    0x3d         0x3d      RETURNDATASIZE    rds suc 0\n        0x0E    0x82         0x82      DUP3              0 rds suc 0\n        0x0F    0x80         0x80      DUP1              0 0 rds suc 0\n        0x10    0x3e         0x3e      RETURNDATACOPY    suc 0\n        0x11    0x90         0x90      SWAP1             0 suc\n        0x12    0x3d         0x3d      RETURNDATASIZE    rds 0 suc\n        0x13    0x91         0x91      SWAP2             suc 0 rds\n        0x14    0x60 0x18    0x6018    PUSH1             0x18 suc 0 rds\n    /-- 0x16    0x57         0x57      JUMPI             0 rds\n    |   0x17    0xfd         0xfd      REVERT\n    \\-> 0x18    0x5b         0x5b      JUMPDEST          0 rds\n        0x19    0xf3         0xf3      RETURN\n\n    flat deployed code: 0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n\n    deploy function:\n\n        0x00    0x60 0x3a    0x603a    PUSH1             0x3a\n        0x02    0x60 0x0e    0x600e    PUSH1             0x0e 0x3a\n        0x04    0x3d         0x3d      RETURNDATASIZE    0 0x0e 0x3a\n        0x05    0x39         0x39      CODECOPY\n        0x06    0x60 0x1a    0x601a    PUSH1             0x1a\n        0x08    0x80         0x80      DUP1              0x1a 0x1a\n        0x09    0x51         0x51      MLOAD             imp 0x1a\n        0x0A    0x30         0x30      ADDRESS           addr imp 0x1a\n        0x0B    0x55         0x55      SSTORE            0x1a\n        0x0C    0x3d         0x3d      RETURNDATASIZE    0 0x1a\n        0x0D    0xf3         0xf3      RETURN\n        [...deployed code]\n\n    flat deploy function: 0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n*/\nlibrary Wallet {\n  bytes internal constant creationCode = hex\"603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n}\n\n// File: contracts/modules/commons/ModuleAuthFixed.sol\n\npragma solidity ^0.6.6;\n\n\n\n/**\n *  Implements ModuleAuth by validating the signature image against\n *  the salt used to deploy the contract\n *\n *  This module allows wallets to be deployed with a default configuration\n *  without using any aditional contract storage\n */\nabstract contract ModuleAuthFixed is ModuleAuth {\n  bytes32 public immutable INIT_CODE_HASH;\n  address public immutable FACTORY;\n\n  constructor(address _factory) public {\n    // Build init code hash of the deployed wallets using that module\n    bytes32 initCodeHash = keccak256(abi.encodePacked(Wallet.creationCode, uint256(address(this))));\n\n    INIT_CODE_HASH = initCodeHash;\n    FACTORY = _factory;\n  }\n\n  /**\n   * @notice Validates the signature image with the salt used to deploy the contract\n   * @param _imageHash Hash image of signature\n   * @return true if the signature image is valid\n   */\n  function _isValidImage(bytes32 _imageHash) internal override view returns (bool) {\n    return address(\n      uint256(\n        keccak256(\n          abi.encodePacked(\n            byte(0xff),\n            FACTORY,\n            _imageHash,\n            INIT_CODE_HASH\n          )\n        )\n      )\n    ) == address(this);\n  }\n}\n\n// File: contracts/modules/commons/ModuleBase.sol\n\npragma solidity ^0.6.6;\n\n\n\ncontract ModuleBase {\n  modifier onlySelf() {\n    require(msg.sender == address(this), \"ModuleBase#onlySelf: NOT_AUTHORIZED\");\n    _;\n  }\n\n  function _writeBytes32(bytes32 _key, bytes32 _val) internal {\n    assembly {\n      sstore(_key, _val)\n    }\n  }\n\n  function _readBytes32(bytes32 _key) internal view returns (bytes32 val) {\n    assembly {\n      val := sload(_key)\n    }\n  }\n}\n\n// File: contracts/interfaces/receivers/IERC1155Receiver.sol\n\npragma solidity ^0.6.6;\n\n\ninterface IERC1155Receiver {\n  function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns (bytes4);\n  function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external returns (bytes4);\n}\n\n// File: contracts/interfaces/receivers/IERC721Receiver.sol\n\npragma solidity ^0.6.6;\n\n\ninterface IERC721Receiver {\n  function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4);\n}\n\n// File: contracts/modules/commons/ModuleHooks.sol\n\npragma solidity ^0.6.6;\n\n\n\n\n\n\ncontract ModuleHooks is ModuleBase, IERC1155Receiver, IERC721Receiver {\n  //                       HOOKS_KEY = keccak256(\"org.arcadeum.module.hooks.hooks\");\n  bytes32 private constant HOOKS_KEY = bytes32(0xbe27a319efc8734e89e26ba4bc95f5c788584163b959f03fa04e2d7ab4b9a120);\n\n  /**\n   * @notice Adds a new hook to handle a given function selector\n   * @param _signature Signature function linked to the hook\n   * @param _implementation Hook implementation contract\n   */\n  function addHook(bytes4 _signature, address _implementation) external onlySelf {\n    require(_readHook(_signature) == address(0), \"ModuleHooks#addHook: HOOK_ALREADY_REGISTERED\");\n    _writeHook(_signature, _implementation);\n  }\n\n  /**\n   * @notice Removes a registered hook\n   * @param _signature Signature function linked to the hook\n   */\n  function removeHook(bytes4 _signature) external onlySelf {\n    require(_readHook(_signature) != address(0), \"ModuleHooks#removeHook: HOOK_NOT_REGISTERED\");\n    _writeHook(_signature, address(0));\n  }\n\n  /**\n   * @notice Reads the implementation hook of a signature\n   * @param _signature Signature function\n   * @return The address of the implementation hook, address(0) if none\n  */\n  function _readHook(bytes4 _signature) private view returns (address) {\n    bytes32 key = keccak256(abi.encode(_signature, HOOKS_KEY));\n    return address(uint256(_readBytes32(key)));\n  }\n\n  /**\n   * @notice Writes the implementation hook of a signature\n   * @param _signature Signature function\n   * @param _implementation Hook implementation contract\n  */\n  function _writeHook(bytes4 _signature, address _implementation) private {\n    bytes32 key = keccak256(abi.encode(_signature, HOOKS_KEY));\n    _writeBytes32(key, bytes32(uint256(_implementation)));\n  }\n\n  /**\n   * @notice Handle the receipt of a single ERC1155 token type.\n   * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n   */\n  function onERC1155Received(\n    address,\n    address,\n    uint256,\n    uint256,\n    bytes calldata\n  ) external override returns (bytes4) {\n    return ModuleHooks.onERC1155Received.selector;\n  }\n\n  /**\n   * @notice Handle the receipt of multiple ERC1155 token types.\n   * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n   */\n  function onERC1155BatchReceived(\n    address,\n    address,\n    uint256[] calldata,\n    uint256[] calldata,\n    bytes calldata\n  ) external override returns (bytes4) {\n    return ModuleHooks.onERC1155BatchReceived.selector;\n  }\n\n  /**\n   * @notice Handle the receipt of a single ERC721 token.\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n   */\n  function onERC721Received(address, address, uint256, bytes calldata) external override returns (bytes4) {\n    return ModuleHooks.onERC721Received.selector;\n  }\n\n  /**\n   * @notice Routes fallback calls through hooks\n   */\n  fallback() external payable {\n    address target = _readHook(msg.sig);\n    if (target != address(0)) {\n      (bool success, bytes memory result) = target.delegatecall(msg.data);\n      assembly {\n        if iszero(success)  {\n          revert(add(result, 0x20), mload(result))\n        }\n\n        return(add(result, 0x20), mload(result))\n      }\n    }\n  }\n\n  /**\n   * @notice Allows the wallet to receive ETH\n   */\n  receive() external payable { }\n}\n\n// File: contracts/modules/commons/ModuleCalls.sol\n\npragma solidity ^0.6.6;\n\n\n\n\nabstract contract ModuleCalls is IModuleAuth {\n  // Transaction structure\n  struct Transaction {\n    bool delegateCall;   // Performs delegatecall\n    bool revertOnError;  // Reverts transaction bundle if tx fails\n    uint256 gasLimit;    // Maximum gas to be forwarded\n    address target;      // Address of the contract to call\n    uint256 value;       // Amount of ETH to pass with the call\n    bytes data;          // calldata to pass\n  }\n\n  // Wallet's signature nonce\n  uint256 public nonce = 0;\n\n  // Events\n  event NonceChange(uint256 newNonce);\n  event TxFailed(uint256 _index, bytes _reason);\n\n  /**\n   * @notice Allow wallet owner to execute an action\n   * @param _txs        Transactions to process\n   * @param _nonce      Signature nonce\n   * @param _signature  Encoded signature\n   */\n  function execute(\n    Transaction[] memory _txs,\n    uint256 _nonce,\n    bytes memory _signature\n  )\n    public\n  {\n    // Validate and update nonce\n    _validateNonce(_nonce);\n\n    // Verify that signatures are valid\n    require(\n      _signatureValidation(_hashData(abi.encode(_nonce, _txs)), _signature),\n      \"MainModule#_signatureValidation: INVALID_SIGNATURE\"\n    );\n\n    // Execute transaction\n    for (uint256 i = 0; i < _txs.length; i++) {\n      Transaction memory transaction = _txs[i];\n\n      bool success;\n      bytes memory result;\n\n      if (transaction.delegateCall) {\n        (success, result) = transaction.target.delegatecall{\n          gas: transaction.gasLimit\n        }(transaction.data);\n      } else {\n        (success, result) = transaction.target.call{\n          value: transaction.value,\n          gas: transaction.gasLimit\n        }(transaction.data);\n      }\n\n      if (!success) _revertBytes(transaction, i, result);\n    }\n  }\n\n  /**\n   * @notice Verify if a nonce is valid\n   * @param _nonce Nonce to validate\n   * @dev A valid nonce must be above the last one used\n   *   with a maximum delta of 100\n   */\n  function _validateNonce(uint256 _nonce) private {\n    // Retrieve current nonce for this wallet\n    uint256 current_nonce = nonce; // Lowest valid nonce for signer\n\n    // Verify if nonce is valid\n    require(\n      (_nonce >= current_nonce) && (_nonce < (current_nonce + 100)),\n      \"MainModule#_auth: INVALID_NONCE\"\n    );\n\n    // Update signature nonce\n    nonce = _nonce + 1;\n    emit NonceChange(_nonce + 1);\n  }\n\n  /**\n   * @notice Logs a failed transaction, reverts if the transaction is not optional\n   * @param _tx      Transaction that is reverting\n   * @param _index   Index of transaction in batch\n   * @param _reason  Encoded revert message\n   */\n  function _revertBytes(Transaction memory _tx, uint256 _index, bytes memory _reason) internal {\n    if (_tx.revertOnError) {\n      assembly { revert(add(_reason, 0x20), mload(_reason)) }\n    } else {\n      emit TxFailed(_index, _reason);\n    }\n  }\n}\n\n// File: contracts/utils/LibAddress.sol\n\npragma solidity ^0.6.6;\n\n\nlibrary LibAddress {\n  function isContract(address account) internal view returns (bool) {\n    uint256 csize;\n    // solhint-disable-next-line no-inline-assembly\n    assembly { csize := extcodesize(account) }\n    return csize != 0;\n  }\n}\n\n// File: contracts/modules/commons/ModuleUpdate.sol\n\npragma solidity ^0.6.6;\n\n\n\n\n\n\ncontract ModuleUpdate is ModuleBase, Implementation {\n  using LibAddress for address;\n\n  /**\n   * @notice Updates the implementation of the base wallet\n   * @param _implementation New main module implementation\n   * @dev WARNING Updating the implementation can brick the wallet\n   */\n  function updateImplementation(address _implementation) external onlySelf {\n    require(_implementation.isContract(), \"ModuleUpdate#updateImplementation: INVALID_IMPLEMENTATION\");\n    _setImplementation(_implementation);\n  }\n}\n\n// File: contracts/modules/commons/ModuleCreator.sol\n\npragma solidity ^0.6.6;\n\n\n\n\ncontract ModuleCreator is ModuleBase {\n  event CreatedContract(address _contract);\n\n  /**\n   * @notice Creates a contract forwarding eth value\n   * @param _code Creation code of the contract\n   * @return addr The address of the created contract\n   */\n  function createContract(bytes memory _code) public payable onlySelf returns (address addr) {\n    assembly { addr := create(callvalue(), add(_code, 32), mload(_code)) }\n    emit CreatedContract(addr);\n  }\n}\n\n// File: contracts/modules/MainModule.sol\n\npragma solidity ^0.6.6;\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Contains the core functionality arcadeum wallets will inherit.\n */\ncontract MainModule is\n  ModuleAuthFixed,\n  ModuleUpdate,\n  ModuleHooks,\n  ModuleCalls,\n  ModuleCreator\n{\n  constructor(\n    address _factory\n  ) public ModuleAuthFixed(\n    _factory\n  ) { }\n}\n"
    }
  }
}