{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/multisend/addressesBalance.sol": {
      "content": "pragma solidity 0.6.3;\n\n// SPDX-License-Identifier: MIT\n\ncontract Token {\n    function transfer(address _to, uint256 _value) public returns (bool success) {}\n    function balanceOf(address account) public view returns (uint256){}\n}\n\ncontract AddressesBalance {\n    \n    address public owner;\n    constructor() public {\n        owner = msg.sender;\n    }\n  \n    function getBalances(address[] memory _addresses) public view returns (uint256[5000] memory _balances){\n        for (uint8 n = 0; n < _addresses.length; n++) {\n            _balances[n] = (_addresses[n]).balance;\n        }\n        return _balances;\n    }\n    \n    function getTokenBalances(Token _token, address[] memory _addresses) public view returns (uint256[5000] memory _balances){\n        for (uint8 n = 0; n < _addresses.length; n++) {\n            _balances[n] = _token.balanceOf(_addresses[n]);\n        }\n        return _balances;\n    }\n    \n    function getTotalBalance(address[] memory _addresses) public view returns (uint256 _balances){\n        uint256 total = 0;\n        for (uint8 n = 0; n < _addresses.length; n++) {\n            total += (_addresses[n]).balance;\n        }\n        return total;\n    }\n    \n    function withdrawETH() public {\n        require(msg.sender == owner);\n        address factory = address(this);\n        address payable _to = msg.sender;\n        _to.transfer(factory.balance);\n    }\n    \n    function withdrawToken(address _token) public {\n        require(msg.sender == owner);\n        address factory = address(this);\n        Token token = Token(_token);\n        token.transfer(msg.sender, token.balanceOf(factory));\n    }\n    \n    function destroy() public {\n        require(msg.sender == owner);\n        selfdestruct(msg.sender);\n    }\n}"
    }
  }
}