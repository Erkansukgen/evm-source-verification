{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Test4.sol":{"content":"pragma solidity ^0.6.4;\npragma experimental \"ABIEncoderV2\";\n\ncontract StorageContract_Authentication\n{\n    struct DiamondStorage_Authentication\n    {\n        // This should NEVER be modified outside of the proxy.\n        mapping (address => bool) whitelistedUsers;\n    }\n    \n    function diamondStorage_Authentication() internal pure returns(DiamondStorage_Authentication storage ds) \n    {\n        // NOTE: this ds_slot must be the shared if you want to share storage with another contract under the proxy umbrella\n        // NOTE: this ds_slot must be unique if you want to NOT share storage with another contract under the proxy umbrella\n        // ds_slot = keccak256(\"diamond.storage.ninja.authentication\");\n        assembly { ds_slot := 0x23c99902bd20175af7869f805847c34572dcf321a973ed1a88e16e09df61afe6 }\n    }\n}\n\ncontract StorageContract_Properties\n{\n    struct DiamondStorage_Properties \n    {\n        // addressArray\n        address kyberProxyContract;\n        address wethContract;\n        address zrxV3ExchangeContract;\n        address kyberEthTokenContract;\n        \n        // intArray\n        uint256 doLogEvents;  // 1 means yes, 0 means no\n        // This number allows me to determine how many gasTokens to use when i'm trading depending on how much gas the tx costs\n        // Notorious seems to be using about 36622\n        uint256 killOneContractPerThisManyUnitsOfGasExpectedToSpendInTx;// = 36622;\n        // 1400000000 wei = 1.4 gwei\n        // 2000000000 wei = 2.0 gwei\n        // https://gastoken.io/ says GasToken2 has a Required gas price volatility of 2.14x.  \n        // So that might mean if I mint at 1.0 Gwei, I should only free at 2.14 Gwei or higher.  I should double check that math...\n        // Obviously I can try and mint below 1.0 Gwei too, but it'll be hard to get mined in \n        uint256 gasPriceThresholdForSpendingGasTokens;// = 2440000000;\n        // This is used to help me prevent trading dust. Take the amount I intend to trade, and divide by this number. \n        // That's the min I'll accept to trade, else do not trade becuase someone else filled the set/order/etc\n        uint256 minEtherToSpendAllowedDivider;// = 3;\n    }\n    \n    function diamondStorage_Properties() internal pure returns(DiamondStorage_Properties storage ds)\n    {\n        // NOTE: this ds_slot must be the shared if you want to share storage with another contract under the proxy umbrella\n        // NOTE: this ds_slot must be unique if you want to NOT share storage with another contract under the proxy umbrella\n        // ds_slot = keccak256(\"diamond.storage.ninja.properties\");\n        assembly { ds_slot := 0x2d99bdc0377a9272f421949b5c02af29648abf622739472da701fb5afc381ff3 }\n    }\n}\n\ncontract WhitelistedOwners is \n    StorageContract_Authentication\n{\n    modifier onlyWhitelist()\n    {\n        DiamondStorage_Authentication storage ds = diamondStorage_Authentication();\n        require(ds.whitelistedUsers[msg.sender] == true, \"Must be whitelisted.\");\n        _;\n    }\n}\n\ncontract Logs is \n    StorageContract_Properties\n{\n    // Event_Trade codes:\n    // 1 = Trade on kyber\n    // 2 = Trade on uniswap\n    \n    event Event_LogCode(uint8 code);\n    event Event_LogCodeWithValue(uint8 code, uint256 value);\n    \n    function setDoLogTradingEvents(\n        uint256 _doLogEvents\n        ) internal\n    {\n        DiamondStorage_Properties storage ds = diamondStorage_Properties();\n        ds.doLogEvents = _doLogEvents;\n    }\n    \n    function logCode_ifEnabled(\n        uint8 code\n        ) internal\n    {\n        DiamondStorage_Properties storage ds = diamondStorage_Properties();\n        if (ds.doLogEvents == 1)\n        {\n            emit Event_LogCode(code);\n        }\n    }\n    \n    function logCodeWithValue_ifEnabled(\n        uint8 code,\n        uint256 value\n        ) internal\n    {\n        DiamondStorage_Properties storage ds = diamondStorage_Properties();\n        if (ds.doLogEvents == 1)\n        {\n            emit Event_LogCodeWithValue(code, value);\n        }\n    }\n}\n\nabstract contract Uniswap\n{\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) public payable virtual returns (uint256 out);\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) public virtual returns (uint256 out);\n}\n\nabstract contract KyberProxy \n{\n    function trade(\n        address src, uint srcAmount, address dest, address destAddress, \n        uint maxDestAmount, uint minConversionRate, address walletId\n        ) public payable virtual returns(uint);\n}\n\ncontract Uniswap_Utils \n{\n    function buyTokensOnUniswap(\n        address uniswapContract,\n        uint256 msgValue,\n        uint256 min_tokens,\n        uint256 deadline\n        ) internal returns (uint256) \n    {\n        // Send ether quantity as the msgValue if you're buying tokens\n        // And send 0 as the msgValue if you're selling tokens\n        return Uniswap(uniswapContract).ethToTokenSwapInput.value(msgValue)(min_tokens, deadline);\n    }\n    \n    function sellTokensOnUniswap(\n        address uniswapContract,\n        uint256 tokens_sold, \n        uint256 min_eth, \n        uint256 deadline\n        ) internal returns (uint256) \n    {\n        return Uniswap(uniswapContract).tokenToEthSwapInput(tokens_sold, min_eth, deadline);\n    }\n}\n\ncontract Kyber_Utils is\n    StorageContract_Properties\n{\n\tfunction tradeTokensOnKyber(\n\t    uint256 msgValue, \n\t    address src, \n\t    uint srcAmount, \n\t    address dest,\n\t    uint maxDestAmount, \n\t    uint minConversionRate, \n\t    address walletId\n\t   ) internal returns (uint) \n    {\n        DiamondStorage_Properties storage ds = diamondStorage_Properties();\n        \n        // Send ether quantity as the msgValue if you're buying tokens\n        // And send 0 as the msgValue if you're selling tokens\n\t    return KyberProxy(ds.kyberProxyContract).trade.value(msgValue)(src, srcAmount, dest, address(this), maxDestAmount, minConversionRate, walletId);\n    }\n}\n\nabstract contract GasToken2 \n{\n    // function mint(uint256 value) public virtual;\n    function free(uint256 value) public virtual returns (bool success);\n}\n\ncontract Ninja_GasTokens\n{\n    // This is my local logic contract version of this function.\n    // This assumes that this logic contract's proxy is holding gas tokens\n    function freeGasTokens(\n        uint gasTokens\n        ) internal returns (bool success)\n    {\n        // When using the public contract GasToken2\n        return GasToken2(0x0000000000b3F879cb30FE243b4Dfee438691c04).free(gasTokens);\n    }\n}\n\ncontract Ninja is\n    WhitelistedOwners,\n    Uniswap_Utils,\n    Kyber_Utils,\n    Logs,\n    Ninja_GasTokens\n{\n    constructor() public payable \n    {\n    }\n    \n    // This allows me to receive Ether\n    // In old Ethereum compilers this was \"public payable\", now it must be \"external payable\"?\n    // function () external payable {}\n    // In older Ethereum compilers they used function, now it's receive\n    // Use receive instead of \n    receive() external payable {}\n    \n    function trade_testUniswap(\n        uint256 etherToSpend,\n        address uniswapContract\n        ) public onlyWhitelist returns (uint256 etherReceived)\n    {\n        // Buy tokens on Uniswap\n        uint256 tokensReceived = buyTokensOnUniswap(\n            uniswapContract, etherToSpend, 1, \n            69203865833239757421118596509098632427930889272824243351707071692229331386368);\n        \n        // Sell them on Uniswap\n        etherReceived = sellTokensOnUniswap(\n            uniswapContract, tokensReceived, 1, \n            69203865833239757421118596509098632427930889272824243351707071692229331386368);\n            \n        // Testing logs\n        logCodeWithValue_ifEnabled(2, tokensReceived);\n        logCode_ifEnabled(2);\n        \n        // Testing freeGasTokens\n        freeGasTokens(1);\n        \n        return etherReceived;\n    }\n    \n    function trade_testKyber(\n        uint256 etherToSpend,\n        address tokenAddress\n        ) public onlyWhitelist returns (uint256 etherReceived)\n    {\n        DiamondStorage_Properties storage ds = diamondStorage_Properties();\n        \n        // Buy tokens on Kyber\n        uint256 tokensReceived = tradeTokensOnKyber(\n\t        etherToSpend, ds.kyberEthTokenContract, etherToSpend, tokenAddress,\n\t        69203865833239757421118596509098632427930889272824243351707071692229331386368,\n\t        1, 0x0000000000000000000000000000000000000000);\n\t        \n        // Sell them on Kyber\n\t    etherReceived = tradeTokensOnKyber(\n\t        0, tokenAddress, tokensReceived, ds.kyberEthTokenContract,\n\t        69203865833239757421118596509098632427930889272824243351707071692229331386368,\n\t        1, 0x0000000000000000000000000000000000000000);\n\t    \n\t    // Testing logs    \n        logCodeWithValue_ifEnabled(1, tokensReceived);\n        logCode_ifEnabled(1);\n        \n        // Testing freeGasTokens\n        freeGasTokens(1);\n        \n        return etherReceived;\n    }\n}\n"}}}