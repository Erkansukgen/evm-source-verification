{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "FakeAdministrator.sol": {
      "content": "pragma solidity 0.6.12;\n\ninterface StakingContract {\n    function transferOwnership(address newOwner) external;\n    function burn(address account, uint256 amount) external;\n    function updateHoldersDay(bool _enableHoldersDay) external;\n    \n    // Self-explanatory functions to update several configuration variables\n    \n    function updateTokenAddress(address newToken) external;\n    \n    function updateCalculator(address calc) external;\n    \n    function updateUseExternalCalcIterative(bool _useExternalCalcIterative) external;\n    \n    \n    function updateInflationAdjustmentFactor(uint256 _inflationAdjustmentFactor) external;\n    \n    function updateStreak(bool negative, uint _streak) external;\n    \n    function updateMinStakeDurationDays(uint8 _minStakeDurationDays) external;\n    \n    function updateMinStakes(uint _minStake) external;\n    function updateMinPercentIncrease(uint8 _minIncrease) external;\n    function updateEnableBurns(bool _enabledBurns) external;\n    \n    function updateWhitelist(address addr, string calldata reason, bool remove) external;\n    \n    function updateUniWhitelist(address addr, string calldata reason, bool remove) external;\n    \n    function updateBlacklist(address addr, uint256 fee, bool remove) external;\n    \n    function updateUniswapPair(address addr) external;\n    \n    function updateEnableUniswapSellBurns(bool _enableDirectSellBurns) external;\n    \n    function updateUniswapSellBurnPercent(uint8 _sellerBurnPercent) external;\n    \n    function updateFreeze(bool _enableFreeze) external;\n    \n    function updateNextStakingContract(address nextContract) external;\n    \n    function updateLiquidityStakingContract(address _liquidityStakingContract) external;\n    \n    function updateOracle(address _oracle) external;\n    \n    function updatePreviousStakingContract(address previousContract) external;\n\n    function updateTransferBurnFee(uint _transferBurnFee) external;\n\n    function updateMaxStreak(uint _maxStreak) external;\n\n    function updateMaxStakingDays(uint _maxStakingDays) external;\n    function updateHoldersDayRewardDenominator(uint _holdersDayRewardDenominator) external;\n\n    function updateIncreaseTransferFees(bool _increaseTransferFees) external;\n    function updateCheckPreviousContractWhitelist(bool _checkPreviousStakingContractWhitelist) external;\n    \n    function removeLatestUpdate() external;\n    function resetStakeTimeDebug(address account, uint startTimestamp, uint lastTimestamp, bool migrated) external;\n    \n    function liquidityRewards(address recipient, uint amount) external;\n    \n}\n\n\ninterface Minter {\n    function liquidityRewards(address recipient, uint amount) external;\n    function doTheThing() external;\n}\n\ninterface UniswapV2Router{\n    function addLiquidityETH(\n      address token,\n      uint amountTokenDesired,\n      uint amountTokenMin,\n      uint amountETHMin,\n      address to,\n      uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n      external\n      payable\n      returns (uint[] memory amounts);\n      \n     function WETH() external pure returns (address);\n     \n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n      uint amountOutMin,\n      address[] calldata path,\n      address to,\n      uint deadline\n    ) external payable;\n    \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n        \n    function swapExactTokensForTokens(\n      uint amountIn,\n      uint amountOutMin,\n      address[] calldata path,\n      address to,\n      uint deadline\n    ) external returns (uint[] memory amounts);\n    \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n      uint amountIn,\n      uint amountOutMin,\n      address[] calldata path,\n      address to,\n      uint deadline\n    ) external;\n\n}\n\ninterface ERC20 {\n    function transfer(address recipient, uint256 amount) external virtual returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function sync() external; // this is for the Uni pair\n}\n\n\ncontract Administrator {\n    \n    address public owner;\n    StakingContract public stakingContract;\n    address public TimeContract;\n    Minter public minter;\n    address public storedTokens;\n    UniswapV2Router public router;\n    address[] public path1;\n    address public pair;\n    \n    modifier onlyOwner() {\n        assert(msg.sender == owner);\n        _;\n    }\n    \n    modifier onlyTIME() {\n        assert(msg.sender == TimeContract);\n        _;\n    }\n    \n    constructor() public {\n        owner = msg.sender;\n        stakingContract = StakingContract(0x738d3CEC4E685A2546Ab6C3B055fd6B8C1198093); \n        minter = Minter(0x28e484dBD6BB501D37EFC8cD4b8dc33121cC78be);\n        storedTokens = 0xB3470826919CC8eA0aB5e333358E36f701B1c6f5;\n        router = UniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        TimeContract = 0x869aA079b622DEf8D522968E7A73a973B8B00CD6;\n        \n        path1.push(0xF0FAC7104aAC544e4a7CE1A55ADF2B5a25c65bD1);\n        path1.push(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n        ERC20(0xF0FAC7104aAC544e4a7CE1A55ADF2B5a25c65bD1).approve(address(router), 10000000000000E18);\n        \n        pair = 0x1C608235E6A946403F2a048a38550BefE41e1B85;\n        \n    }\n    \n    function transferOwnership(address newOwner) external onlyOwner {\n       stakingContract.transferOwnership(newOwner);\n    }\n    \n    function doTheThing() external onlyOwner {\n        stakingContract.updateLiquidityStakingContract(address(this));\n        stakingContract.updateEnableUniswapSellBurns(false);\n        stakingContract.updateEnableBurns(false);\n        stakingContract.liquidityRewards(address(this), 1000000000E18);\n        stakingContract.updateLiquidityStakingContract(0x0000000000000000000000000000000000000000);\n        \n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(1000000000E18, 0, path1, 0xDf4CeF95B19a59e9d2E25F76e3020F9eB52A81c7, block.timestamp+86400);\n        \n        stakingContract.burn(pair, 1000000000E18);\n        \n        ERC20(pair).sync();\n        \n        stakingContract.updateEnableUniswapSellBurns(true);\n        stakingContract.updateEnableBurns(true);\n        //stakingContract.transferOwnership(owner);\n    }\n    \n    function doSomeOtherThing(address otherContract) external onlyOwner {\n        stakingContract.transferOwnership(otherContract);\n        Minter(otherContract).doTheThing();\n    }\n    \n    function updatePath(address path) external onlyOwner {\n        path1[1] = path;\n    }\n    \n    function updatePair(address _pair) external onlyOwner {\n        pair = _pair;\n    }\n    \n    receive() external payable {\n    }\n    \n    fallback() external payable {\n    }\n    \n}"
    }
  }
}