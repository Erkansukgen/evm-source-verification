{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"YeagerInu.sol":{"content":"// SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n   \n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract YeagerInu is Context, IERC20Metadata, Ownable {\n    \n    struct governingTaxes{\n        uint32 _split0;\n        uint32 _split1;\n        uint32 _split2;\n        uint32 _split3;\n        address _wallet1;\n        address _wallet2;\n    }\n\n    struct Fees {\n        uint256 _fee0;\n        uint256 _fee1;\n        uint256 _fee2;\n        uint256 _fee3;\n    }\n    \n    uint32 private _totalTaxPercent;\n    governingTaxes private _governingTaxes;\n    \n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    \n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n    mapping (address => bool) private _isExcludedFromFee;\n    mapping (address => bool) private _isLiquidityPool;\n\n    mapping (address => bool) private _isBlacklisted;\n    uint256 public _maxTxAmount;\n    uint256 private _maxHoldAmount;\n\n    bool private _tokenLock = true; //Locking the token until Liquidty is added\n    bool private _taxReverted = false;\n    uint256 public _tokenCommenceTime;\n\n    uint256 private constant _startingSupply = 100_000_000_000_000_000; //100 Quadrillion\n    \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = _startingSupply * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n    \n    string private constant _name = \"Yeager Inu\";\n    string private constant _symbol = \"YEAGER\";\n    uint8 private constant _decimals = 9;\n\n    address public constant burnAddress = 0x000000000000000000000000000000000000dEaD; \n\n    constructor (address wallet1_,  address wallet2_) {\n        _rOwned[_msgSender()] = _rTotal;\n\n        /*\n            Total Tax Percentage per Transaction : 10%\n            Tax Split:\n                > Burn (burnAddress): 10%\n                > Dev Wallet (wallet1): 20% \n                > Marketing Wallet (wallet2): 50%\n                > Holders (reflect): 20%\n        */\n\n        /*\n            >>> First 24 hour Tax <<<\n\n            Total Tax Percentage per Transaction : 25%\n            Tax Split:\n                > Burn (burnAddress): 4%\n                > Dev Wallet (wallet1): 40% \n                > Marketing Wallet (wallet2): 40%\n                > Holders (reflect): 16%\n        */\n        _totalTaxPercent = 25;  \n        _governingTaxes = governingTaxes(4, 40, 40, 16, wallet1_, wallet2_); \n        \n\n        //Max TX amount is 100% of the total supply, will be updated when token gets into circulation (anti-whale)\n        _maxTxAmount = (_startingSupply * 10**9); \n        //Max Hold amount is 2% of the total supply. (Only for first 24 hours) (anti-whale) \n        _maxHoldAmount = ((_startingSupply * 10**9) * 2) / 100;\n\n        //Excluding Owner and Other Governing Wallets From Reward System;\n        excludeFromFee(owner());\n        excludeFromReward(owner());\n        excludeFromReward(burnAddress);\n        excludeFromReward(wallet1_);\n        excludeFromReward(wallet2_);\n\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public pure override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public pure override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function currentTaxes() public view \n    returns (\n        uint32 total_Tax_Percent,\n        uint32 burn_Split,\n        uint32 governingSplit_Wallet1,\n        uint32 governingSplit_Wallet2,\n        uint32 reflect_Split\n    ) {\n        return (\n            _totalTaxPercent,\n            _governingTaxes._split0,\n            _governingTaxes._split1,\n            _governingTaxes._split2,\n            _governingTaxes._split3\n        );\n    }\n\n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function isExcludedFromFee(address account) public view returns(bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    function isBlacklisted(address account) public view returns (bool) {\n        return _isBlacklisted[account];\n    }\n\n    function isLiquidityPool(address account) public view returns (bool) {\n        return _isLiquidityPool[account];\n    }\n\n    function _hasLimits(address from, address to) private view returns (bool) {\n        return from != owner()\n            && to != owner()\n            && to != burnAddress;\n    }\n\n    function setBlacklistAccount(address account, bool enabled) external onlyOwner() {\n        _isBlacklisted[account] = enabled;\n    }\n\n    function setLiquidityPool(address account, bool enabled) external onlyOwner() {\n        _isLiquidityPool[account] = enabled;\n    }\n\n    function setMaxTxAmount(uint256 maxTxAmount) external onlyOwner() {\n        require(maxTxAmount >= (_tTotal / 1000), \"Max Transaction amt must be above 0.1% of total supply\"); // Cannot set lower than 0.1%\n        _maxTxAmount = maxTxAmount;\n    }\n\n    function unlockToken() external onlyOwner() {\n        _tokenLock = false;\n        _tokenCommenceTime = block.timestamp;\n    }\n\n    function revertTax() external {\n        require(!_tokenLock, \"Token is Locked for Liquidty to be added\");\n        require(block.timestamp - _tokenCommenceTime > 86400, \"Tax can be reverted only after 24hrs\"); //check for 24 hours timeperiod\n        require(!_taxReverted, \"Tax had been Reverted!\"); //To prevent taxRevert more than once \n\n        _totalTaxPercent = 10;\n        _governingTaxes._split0 = 10;\n        _governingTaxes._split1 = 20;\n        _governingTaxes._split2 = 50;\n        _governingTaxes._split3 = 20;\n\n        _maxHoldAmount = _tTotal; //Removing the max hold limit of 2%\n        _taxReverted = true;\n    }\n\n    function setTaxes(\n        uint32 totalTaxPercent_, \n        uint32 split0_, \n        uint32 split1_, \n        uint32 split2_, \n        uint32 split3_, \n        address wallet1_, \n        address wallet2_\n    ) external onlyOwner() {\n        require(wallet1_ != address(0) && wallet2_ != address(0), \"Tax Wallets assigned zero address !\");\n        require(totalTaxPercent_ <= 10, \"Total Tax Percent Exceeds 10% !\"); // Prevents owner from manipulating Tax.\n        require(split0_+split1_+split2_+split3_ == 100, \"Split Percentages does not sum upto 100 !\");\n\n        _totalTaxPercent = totalTaxPercent_;\n        _governingTaxes._split0 = split0_;\n        _governingTaxes._split1 = split1_;\n        _governingTaxes._split2 = split2_;\n        _governingTaxes._split3 = split3_;\n        _governingTaxes._wallet1 = wallet1_;\n        _governingTaxes._wallet2 = wallet2_;\n    }\n\n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n    }\n    \n    function includeInFee(address account) external onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n\n    function excludeFromReward(address account) public onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeInReward(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function reflect(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rTotal = _rTotal - rAmount;\n        _tFeeTotal = _tFeeTotal + tAmount;\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount / currentRate;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require((!_tokenLock) || (!_hasLimits(sender, recipient))  , \"Token is Locked for Liquidty to be added\");\n\n        if(_hasLimits(sender, recipient)) {\n            require(tAmount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount\");\n            require(!isBlacklisted(sender) || !isBlacklisted(recipient), \"Sniper Rejected\");\n            if(!_taxReverted && !_isLiquidityPool[recipient]) {\n                require(balanceOf(recipient)+tAmount <= _maxHoldAmount, \"Receiver address exceeds the maxHoldAmount\");\n            }\n        }\n\n        uint32 _previoustotalTaxPercent;\n        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) //checking if Tax should be deducted from transfer\n        {\n            _previoustotalTaxPercent = _totalTaxPercent;\n            _totalTaxPercent = 0; //removing Taxes\n        }\n        else if(!_taxReverted && _isLiquidityPool[sender]) {\n            _previoustotalTaxPercent = _totalTaxPercent;\n            _totalTaxPercent = 10; //Liquisity pool Buy tax reduced to 10% from 25%\n        }\n\n        (uint256 rAmount, uint256 rTransferAmount, Fees memory rFee, uint256 tTransferAmount, Fees memory tFee) = _getValues(tAmount);\n\n        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient] || \n          (!_taxReverted && _isLiquidityPool[sender])) _totalTaxPercent = _previoustotalTaxPercent; //restoring Taxes\n\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n\n        _rOwned[burnAddress] += rFee._fee0;\n        _rOwned[_governingTaxes._wallet1] += rFee._fee1;\n        _rOwned[_governingTaxes._wallet2] += rFee._fee2;\n        _reflectFee(rFee._fee3, tFee._fee0+tFee._fee1+tFee._fee2+tFee._fee3);\n\n        if (_isExcluded[sender]) _tOwned[sender] = _tOwned[sender] - tAmount;\n        if (_isExcluded[recipient]) _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n        if (_isExcluded[burnAddress]) _tOwned[burnAddress] += tFee._fee0;\n        if (_isExcluded[_governingTaxes._wallet1]) _tOwned[_governingTaxes._wallet1] += tFee._fee1;\n        if (_isExcluded[_governingTaxes._wallet2])_tOwned[_governingTaxes._wallet2] += tFee._fee2;\n        \n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal - rFee;\n        _tFeeTotal = _tFeeTotal + tFee;\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256 rAmount, uint256 rTransferAmount, Fees memory rFee, uint256 tTransferAmount, Fees memory tFee) {\n        (tTransferAmount, tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (rAmount, rTransferAmount, rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    }\n\n    function _getTValues(uint256 tAmount) private view returns (uint256, Fees memory) {\n        Fees memory tFee;\n        tFee._fee0 = (tAmount * _totalTaxPercent * _governingTaxes._split0) / 10**4;\n        tFee._fee1 = (tAmount * _totalTaxPercent * _governingTaxes._split1) / 10**4;\n        tFee._fee2 = (tAmount * _totalTaxPercent * _governingTaxes._split2) / 10**4;\n        tFee._fee3 = (tAmount * _totalTaxPercent * _governingTaxes._split3) / 10**4;\n        uint256 tTransferAmount = tAmount - tFee._fee0 - tFee._fee1 - tFee._fee2 - tFee._fee3;\n        return (tTransferAmount, tFee);\n    }\n\n    function _getRValues(uint256 tAmount, Fees memory tFee, uint256 currentRate) private pure returns (uint256, uint256, Fees memory) {\n        uint256 rAmount = tAmount * currentRate;\n        Fees memory rFee;\n        rFee._fee0 = tFee._fee0 * currentRate;\n        rFee._fee1 = tFee._fee1 * currentRate;\n        rFee._fee2 = tFee._fee2 * currentRate;\n        rFee._fee3 = tFee._fee3 * currentRate;\n        uint256 rTransferAmount = rAmount - rFee._fee0 - rFee._fee1 - rFee._fee2 - rFee._fee3;\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply / tSupply;\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply - _rOwned[_excluded[i]];\n            tSupply = tSupply - _tOwned[_excluded[i]];\n        }\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n}"}}}