{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1024
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/net_token.sol": {
      "content": "/* \n(c) 2020 Network DAO Token\nDeveloped by @cryptocreater\n*/\n\npragma solidity 0.6.6;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\ncontract ERC20 is IERC20 {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        require(_allowances[sender][msg.sender] >= amount, \"Increase allowance to zero amount\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        require(addedValue > 0, \"Increase allowance to zero amount\");\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        require(_allowances[msg.sender][spender] >= subtractedValue, \"Decreased allowance below zero\");\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        require(amount > 0, \"Zero amount transfer\");\n        require(_balances[sender] >= amount, \"Transfer amount exceeds balance\");\n        if(fn_tokenTransfer(sender, recipient, amount)) transfer_(sender, recipient, amount);\n    }\n    function transfer_(address sender, address recipient, uint256 amount) private {\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n    }    \n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"Mint to the zero address\");\n        require(amount > 0, \"Zero amount mint\");\n        _totalSupply += amount;\n        _balances[account] += amount;\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"Burn from the zero address\");\n        require(_balances[account] >= amount, \"Burn amount exceeds balance\");\n        require(_totalSupply >= amount, \"Burn amount exceeds total supply\");\n        _balances[account] -= amount;\n        _totalSupply -= amount;\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n        _allowances[owner][spender] = amount;\n    }\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n    function fn_tokenTransfer(address from, address to, uint256 amount) internal virtual returns (bool) { }\n}\ncontract ERC20DecimalsMock is ERC20 {\n    constructor (string memory name, string memory symbol, uint8 decimals) public ERC20(name, symbol) {\n        _setupDecimals(decimals);\n    }\n}\ncontract Network is ERC20DecimalsMock(\"Network\", \"NET\", 18) {\n    address private smart;\n    struct User {\n        address referrer;\n        uint256 purchase;\n        uint256 withdraw;\n        uint256 reward;\n        uint256 missed;\n        uint256 depth;\n    }\n    uint256 public raisup = 1e20;\n    mapping(address => User) public users;\n    constructor() public {\n        smart = address(this);\n        users[msg.sender].referrer = smart;\n        users[smart].referrer = smart;\n    }\n    function fn_tokenTransfer(address _from, address _to, uint256 _amount) internal override returns (bool) {\n        if(_to != smart) {\n            if(users[_to].referrer == address(0)) users[_to].referrer = _from;\n            return true;\n        } else {\n            uint256 _value = _amount * smart.balance / totalSupply();\n            _burn(_from, _amount);\n            users[_from].withdraw += _value;\n            payable(_from).transfer(_value);\n            return false;\n        }\n    }\n    receive() payable external {\n        require(users[msg.sender].referrer != address(0), \"Account is not activated\");\n        require(msg.value > 0, \"Zero amount of Ethers\");\n        address _referrer = users[msg.sender].referrer;\n        uint256 _cap = smart.balance - msg.value;\n        uint256 _purchase = _cap > 0 ? msg.value * totalSupply() / _cap : msg.value;\n        uint256 _profit = fn_checkout(msg.sender, _referrer, _purchase);\n        if(raisup > 0) fn_raisup(_profit);\n    }\n    function fn_checkout(address _account, address _referrer, uint256 _purchase) private returns (uint256) {        \n        uint256 _payout = _purchase * 7 / 10;\n        uint256 _profit = _purchase - _payout;\n        uint256 _reward = _profit / 2;\n        uint256 _minimum = 625 * 1e14;\n        _mint(_account, _payout);\n        users[_account].purchase += msg.value;\n        for(uint256 _level = 0; _level < 10; _level++) {\n            uint256 balance_ = balanceOf(_referrer);\n            if(_referrer != smart ) {\n                if(balance_ >= _minimum) {\n                    if(balance_ > _purchase) {\n                        _mint(_referrer, _reward);\n                        _profit -= _reward;\n                        users[_referrer].reward += _reward;\n                    } else {\n                        uint256 _reward_ = _reward * balance_ / _purchase;\n                        uint256 _reduced = _reward - _reward_;\n                        users[_referrer].missed += _reduced;\n                        users[_referrer].reward += _reward_;\n                        _mint(_referrer, _reward_);\n                        _profit -= _reward_;\n                    }\n                } else {\n                    users[_referrer].missed += _reward;\n                }\n            } else {\n                _level = 10;\n            }\n            if(_level >= users[_referrer].depth) users[_referrer].depth = _level + 1;\n            _minimum *= 2;\n            _reward /= 2;\n            _referrer = users[_referrer].referrer;\n        }\n        return _profit;\n    }\n    function fn_raisup(uint256 _amount) private {\n        if(_amount > 0) _mint(smart, _amount);\n        if(totalSupply() >= raisup) {\n            raisup = 0;\n            _burn(smart, balanceOf(smart));\n        }\n    }\n    function burn(uint256 _value) external {\n        _burn(msg.sender, _value);\n    }\n    function rate() external view returns (uint256) {\n        return totalSupply() > 0 && smart.balance > 0 ? smart.balance * 1e6 / totalSupply() : 1e6;\n    }\n    function cap() external view returns (uint256) {\n        return smart.balance > 0 ? smart.balance : 0;\n    }\n}"
    }
  }
}