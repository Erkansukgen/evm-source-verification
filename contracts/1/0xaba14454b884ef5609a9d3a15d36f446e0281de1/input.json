{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Signer.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ncontract mainnetSigner{\n\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function getOwner() public view returns(address){\n        return owner;\n    }\n\n    function setOwner(address _owner) public{\n        require(msg.sender == owner,\"can only be called by owner\");\n        owner = _owner;\n    }\n\n    /**\n   * @notice Verifies that the signer is the owner of the signing contract.\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes calldata _signature\n  ) external view returns (bytes4) {\n    // Validate signatures\n    if (recoverSigner(_hash, _signature) == owner) {\n      return 0x1626ba7e;\n    } else {\n      return 0xffffffff;\n    }\n  }\n\n /**\n   * @notice Recover the signer of hash, assuming it's an EOA account\n   * @dev Only for EthSign signatures\n   * @param _ethSignedMessageHash       Hash of message that was signed\n   * @param _signature  Signature encoded as (bytes32 r, bytes32 s, uint8 v)\n   */\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\n        public\n        pure\n        returns (address)\n    {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        public\n        pure\n        returns (\n            bytes32 r,\n            bytes32 s,\n            uint8 v\n        )\n    {\n        require(sig.length == 65, \"invalid signature length\");\n\n        assembly {\n            /*\n            First 32 bytes stores the length of the signature\n\n            add(sig, 32) = pointer of sig + 32\n            effectively, skips first 32 bytes of signature\n\n            mload(p) loads next 32 bytes starting at the memory address p into memory\n            */\n\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // implicitly return (r, s, v)\n    }\n}"
    }
  }
}