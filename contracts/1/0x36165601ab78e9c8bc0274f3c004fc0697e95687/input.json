{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Token.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.4.22 <0.7.0;\n\ninterface TokenInterface {\n    function invest(address investor) payable external returns(bool);\n    function win(address investor, uint _tokens) external returns(bool);\n}\n\nabstract contract ERC20Interface {\n    function totalSupply() public virtual view returns (uint);\n    function balanceOf(address tokenOwner) public virtual view returns (uint balance);\n    function transfer(address to, uint tokens) public virtual returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n}\n\ncontract Token is ERC20Interface {\n    string public name = \"DEVILSDRAGON\";\n    string public symbol = \"DDGN\";\n    uint public decimals = 18;\n    uint tokenPrice = 0.001 ether;\n\n    uint public supply;\n\n    address public founder;\n    address public team;\n    address public reserved;\n    address public ecosystem;\n    address public dev_team;\n    address public crowdsale;\n    address public developer;\n\n    address public manager;\n    address payable public deposit;\n    address public cinema;\n\n    mapping(address => uint) public balances;\n\n    modifier isManager(){\n        require(msg.sender == manager, 'Caller is not manager');\n        _;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Invest(address investor, uint value, uint tokens);\n\n    constructor(address payable _deposit, address _founder, address _team, address _reserved, address _ecosystem, address _dev_team, address _crowdsale, address _developer) public {\n        manager = msg.sender;\n        supply = 180000000 * (10 ** decimals);\n        founder = _founder;\n        deposit = _deposit;\n        balances[founder] = supply * 59 / 100; // 59%\n        team = _team;\n        balances[team] = supply * 9 / 100; // 9%\n        reserved = _reserved;\n        balances[reserved] = supply * 3 / 50; // 6%\n        ecosystem = _ecosystem;\n        balances[ecosystem] = supply * 9 / 50; // 18%\n        dev_team = _dev_team;\n        balances[dev_team] = supply / 50; // 2%\n        crowdsale = _crowdsale;\n        balances[crowdsale] = supply / 20; // 5%\n        developer = _developer;\n        balances[developer] = supply / 100; // 1%\n    }\n\n    receive() payable external {\n        invest(msg.sender);\n    }\n\n    function changeDeposit(address payable newDeposit) public isManager {\n        deposit = newDeposit;\n    }\n\n    function changeManager(address newManager) public isManager {\n        manager = newManager;\n    }\n\n    function totalSupply() public view override returns (uint) {\n        return supply;\n    }\n\n    function balanceOf(address tokenOwner) public view override returns (uint balance) {\n         return balances[tokenOwner];\n    }\n\n    function transfer(address to, uint tokens) public virtual override returns (bool success) {\n         require(balances[msg.sender] >= tokens && tokens > 0);\n\n         balances[to] += tokens;\n         balances[msg.sender] -= tokens;\n         emit Transfer(msg.sender, to, tokens);\n         return true;\n     }\n\n    function invest(address investor) payable public returns(bool) {\n        uint tokens = msg.value / tokenPrice * (10 ** decimals);\n        require(balances[founder] >= tokens && tokens > 0, 'No tokens left');\n\n        //add tokens to investor balance from founder balance\n        balances[investor] += tokens;\n        balances[founder] -= tokens;\n\n        deposit.transfer(msg.value); //transfer eth to the deposit address\n\n        //emit event\n        emit Invest(investor, msg.value, tokens);\n\n        return true;\n    }\n\n    function changeCinema(address _cinema) public isManager {\n        cinema = _cinema;\n    }\n\n    function win(address investor, uint _tokens) public returns(bool) {\n        require(msg.sender == cinema, 'Wrong sender');\n        uint tokens = _tokens * (10 ** decimals);\n        require(balances[founder] >= tokens && tokens > 0, 'No tokens left');\n\n        //add tokens to investor balance from founder balance\n        balances[investor] += tokens;\n        balances[founder] -= tokens;\n\n        //emit event\n        emit Transfer(founder, investor, tokens);\n\n        return true;\n    }\n}"}}}