{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/test.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface Minereum {\n  function Payment (  ) payable external;  \n}\n\ninterface BazarSwap {\n  function getWeiPriceUnitTokenList (address seller, address tokenAddress) external view returns (uint);  \n}\n\ncontract MinereumLuckyDraw\n{\n\tMinereum public mne;\n\tuint public stakeHoldersfee = 50;\n\tuint public percentWin = 80;\n\tuint public mnefee = 0;\n\tuint public ethfee = 15000000000000000;\n\tuint public totalSentToStakeHolders = 0;\n\tuint public totalPaidOut = 0;\n\tuint public ticketsSold = 0;\n\tuint public ticketsPlayed = 0;\n\taddress public owner = 0x0000000000000000000000000000000000000000;\t\n\tuint public maxNumber = 10001;\n\tuint public systemNumber = 3223;\n\t\n\tuint public blockInterval = 3;\n\tuint public midBlock = 2;\n\tuint public maxBlock = 256;\n\t\n\t//winners from past contracts\n\tuint public winnersCount = 0;\n\tuint public winnersEthCount = 0;\n\t\n\taddress[] public winners;\n\tuint[] public winnersTickets;\n\tuint[] public winnersETH;\n\tuint[] public winnersTimestamp;\n\t\n\tuint bazarSwapCount = 0;\n\tbool bazarSwapActive = true;\n\tBazarSwap bazar;\n\t\n\tmapping (address => mapping (address => bool)) public bazarSwapClaimed;\n\n\tmapping (address => uint256) public playerBlock;\n\tmapping (address => uint256) public playerTickets;\n\t\n\tevent Numbers(address indexed from, uint[] n, string m);\n\t\n\tconstructor() public\n\t{\n\t\tmne = Minereum(0x426CA1eA2406c07d75Db9585F22781c096e3d0E0);\n\t\tbazar = BazarSwap(0xb3cD2Bf2DC3D92E5647953314561d10a9B7CF473);\n\t\towner = msg.sender;\n\t\t//data from old contract\n\t\tticketsPlayed = 405;\n\t\tticketsSold = 510;\n\t\ttotalSentToStakeHolders = 3727500000000000000;\n\t}\n\t\n\treceive() external payable { }\n\t\n\tfunction LuckyDraw() public\n    {\n        require(msg.sender == tx.origin);\n\t\t\n\t\tif (block.number >= playerBlock[msg.sender] + maxBlock) //256\n\t\t{\n\t\t\tuint[] memory empty = new uint[](0);\t\n\t\t\temit Numbers(address(this), empty, \"Your tickets expired or are invalid. Try Again.\");\n\t\t\tplayerBlock[msg.sender] = 0;\n\t\t\tplayerTickets[msg.sender] = 0;\t\t\t\n\t\t}\t\t\n\t\telse if (block.number > playerBlock[msg.sender] + blockInterval)\n\t\t{\n\t\t\tbool win = false;\n\n\t\t\tuint[] memory numbers = new uint[](playerTickets[msg.sender]);\t\t\n\t\t\t\n\t\t\tuint i = 0;\n\t\t\twhile (i < playerTickets[msg.sender])\n\t\t\t{\n\t\t\t\tnumbers[i] = uint256(uint256(keccak256(abi.encodePacked(blockhash(playerBlock[msg.sender] + midBlock), i)))%maxNumber);\n\t\t\t\tif (numbers[i] == systemNumber)\n\t\t\t\t\twin = true;\n\t\t\t\ti++;\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tticketsPlayed += playerTickets[msg.sender];\n\t\t\t\n\t\t\t\n\t\t\tif (win)\n\t\t\t{\n\t\t\t\taddress payable add = payable(msg.sender);\n\t\t\t\tuint contractBalance = address(this).balance;\n\t\t\t\tuint winAmount = contractBalance * percentWin / 100;\n\t\t\t\tuint totalToPay = winAmount;\n\t\t\t\tif (!add.send(totalToPay)) revert('Error While Executing Payment.');\n\t\t\t\ttotalPaidOut += totalToPay;\n\t\t\t\t\n\t\t\t\twinnersCount++;\n\t\t\t\twinnersEthCount += totalToPay;\n\t\t\t\temit Numbers(address(this), numbers, \"YOU WON!\");\n\t\t\t\t\n\t\t\t\twinners.push(msg.sender);\n\t\t\t\twinnersTickets.push(playerTickets[msg.sender]);\n\t\t\t\twinnersETH.push(totalToPay);\n\t\t\t\twinnersTimestamp.push(block.timestamp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\temit Numbers(address(this), numbers, \"Your numbers don't match the System Number! Try Again.\");\n\t\t\t}\n\t\t\t\n\t\t\tplayerBlock[msg.sender] = 0;\n\t\t\tplayerTickets[msg.sender] = 0;\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert('Players must wait 3 blocks');\n\t\t}\n    }\n\t\n\tfunction BuyTickets(uint256 _max) public payable\n    {\n\t\trequire(msg.sender == tx.origin);\n\t\t\n\t\tif (_max == 0) revert('value is 0');\n\t\t\n\t\tif (playerBlock[msg.sender] == 0)\n\t\t{\t\n\t\t\tticketsSold += _max;\t\t\t\n\t\t\tuint totalEthfee = ethfee * _max;\n\t\t\t\n\t\t\tplayerBlock[msg.sender] = block.number;\n\t\t\tplayerTickets[msg.sender] = _max;\t\t\t\n\t\t\t\n\t\t\tif (msg.value < totalEthfee) revert('Not enough ETH.');\n\t\t\tmne.Payment{value:msg.value}();\n\t\t\ttotalSentToStakeHolders += msg.value;\t\t\t\n\t\t}\n\t\telse \n\t\t{\n\t\t\trevert('You must play the tickets first');\n\t\t}\n    }\n\t\n\tfunction ClaimBazarSwapTickets(address tokenAddress) public\n    {\n\t\trequire(msg.sender == tx.origin);\n\t\t\n\t\tif (playerBlock[msg.sender] == 0)\n\t\t{\t\n\t\t\tif (!bazarSwapClaimed[msg.sender][tokenAddress])\n\t\t\t{\n\t\t\t\tif (bazarSwapActive)\n\t\t\t\t{\n\t\t\t\t\tif (bazar.getWeiPriceUnitTokenList(msg.sender, tokenAddress) == 0) revert('Token not set for sale');\n\t\t\t\t\tplayerBlock[msg.sender] = block.number;\n\t\t\t\t\tplayerTickets[msg.sender] = 1;\t\n\t\t\t\t\tbazarSwapClaimed[msg.sender][tokenAddress] = true;\n\t\t\t\t\tbazarSwapCount++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trevert('Bazarswap Claim Not Active');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trevert('Ticket already claimed');\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\trevert('You must play the tickets you have first');\n\t\t}\n    }\t\n\t\n\tfunction GetBazarSwapClaimed(address _address, address _token) public view returns (bool)\n\t{\n\t\treturn bazarSwapClaimed[_address][_token];\n\t}\n\t\n\tfunction transferFundsOut() public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\taddress payable add = payable(msg.sender);\n\t\t\tuint contractBalance = address(this).balance;\n\t\t\tif (!add.send(contractBalance)) revert('Error While Executing Payment.');\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updateFees(uint _stakeHoldersfee, uint _mnefee, uint _ethfee, uint _blockInterval, bool _bazarSwapActive, uint _maxBlock, uint _midBlock) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tstakeHoldersfee = _stakeHoldersfee;\n\t\t\tmnefee = _mnefee;\n\t\t\tethfee = _ethfee;\n\t\t\tblockInterval = _blockInterval;\n\t\t\tbazarSwapActive = _bazarSwapActive;\n\t\t\tmaxBlock = _maxBlock;\n\t\t\tmidBlock = _midBlock;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updateSystemNumber(uint _systemNumber) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tsystemNumber = _systemNumber;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updateMaxNumber(uint _maxNumber) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tmaxNumber = _maxNumber;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updatePercentWin(uint _percentWin) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tpercentWin = _percentWin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\t\n\t\n\tfunction updateMNEContract(address _mneAddress) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tmne = Minereum(_mneAddress);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updateBazarContract(address _address) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tbazar = BazarSwap(_address);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\t\n\t\n\tfunction WinnersLength() public view returns (uint256) { return winners.length; }\t\n\tfunction GetPlayerBlock(address _address) public view returns (uint256) { return playerBlock[_address]; }\n\tfunction GetPlayerTickets(address _address) public view returns (uint256) { return playerTickets[_address]; }\n}"}}}