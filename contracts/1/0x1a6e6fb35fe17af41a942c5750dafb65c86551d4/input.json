{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/GatewayAuction.sol": {
      "content": "/**\n * Contract: Gateway Auction\n * Author  : FRENCH-ICO.com ®\n * Website : www.french-ico.com\n * Version : 1.1\n * SPDX-License-Identifier: UNLICENSED\n */\n\npragma solidity ^0.6.12;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\";\nimport \"./OwnablePayable.sol\";\nimport \"./GatewayTimestamp.sol\";\n\nabstract contract GatewayAuction is OwnablePayable, GatewayTimestamp {\n\n    using SafeMath for uint256;\n    \n    uint public bidsCount; // Counter of all the bids done\n    uint public successFees = 5; // Percentage of fees sent to FRENCHICO at the end of a successful auction\n\n    /**\n     * Informations about the auctions\n     */\n    struct auction {\n        uint startTime;                       // Auction start time\n        uint endTime;                         // Auction end time\n        uint startPrice;                      // Auction start price\n        uint endPrice;                        // Auction end price (instant sell price)\n        uint topBid;                          // Top bid\n        uint bidsCount;                       // Number of bids executed\n        address payable seller;               // Address of the seller\n        address payable topBidder;            // Address of the top bidder\n    }\n    mapping(uint => auction) public auctions;\n\n    event NewAuction(uint _tokenId, uint _startPrice, uint _endPrice);\n    event NewBid(uint _tokenId, address indexed _bidder);\n    event AuctionClosed(uint _tokenId, address indexed _topBidder, uint _topBid, bool _success);\n\n    /**\n     * Create an auction\n     *\n     * @param _seller Seller\n     * @param _tokenId Token ID\n     * @param _startPrice Bid start price\n     * @param _endPrice Bid end price\n     * @param _startTime Bid start time\n     * @param _endTime Bid end time\n     * @param _currency Currency used to contribute\n     */\n    function createAuction(address payable _seller, uint _tokenId, uint _startPrice, uint _endPrice, uint _startTime, uint _endTime, address _currency) internal returns(bool) {\n        require (_startPrice <= _endPrice, \"start price has to be less or equal than the end price\");\n        require (_startTime < _endTime, \"start time has to be less than the end time\");\n\n        timestamp.transferFrom(_seller, address(this), _tokenId); // Token is locked in this smart contract during the auction\n        auctions[_tokenId].startPrice = _startPrice;\n        auctions[_tokenId].endPrice = _endPrice;\n        auctions[_tokenId].startTime = _startTime;\n        auctions[_tokenId].endTime = _endTime;\n        auctions[_tokenId].topBid = 0;\n        auctions[_tokenId].topBidder = _seller;\n        auctions[_tokenId].seller = _seller;\n        auctions[_tokenId].bidsCount = 0;\n\n        emit NewAuction(_tokenId, _startPrice, _endPrice);\n        return true;\n    }\n\n    /**\n     * Bid\n     *\n     * @param _tokenId Token ID\n     */\n    function bid(uint _tokenId) external payable {\n        require(now >= auctions[_tokenId].startTime, \"auction not started\");\n        require(now <= auctions[_tokenId].endTime, \"auction finished\");\n        require(msg.sender != auctions[_tokenId].seller, \"seller can not bid\");\n        require(msg.value >= auctions[_tokenId].startPrice && msg.value > auctions[_tokenId].topBid, \"bid too low\");\n\n        if (auctions[_tokenId].topBid != 0) {\n            auctions[_tokenId].topBidder.transfer(auctions[_tokenId].topBid); // Refund the previous bidder\n        }\n        auctions[_tokenId].topBidder = msg.sender;\n        auctions[_tokenId].topBid = msg.value;\n        auctions[_tokenId].bidsCount++;\n        if (msg.value >= auctions[_tokenId].endPrice) {\n            // End price reached\n            _closeAuction(_tokenId);\n        }\n        bidsCount++;\n\n        emit NewBid(_tokenId, msg.sender);\n    }\n\n    /**\n     * Close the auction\n     *\n     * @param _tokenId Token ID\n     */\n    function closeAuction(uint _tokenId) external {\n        require (now > auctions[_tokenId].endTime, \"auction is not finished\");\n    \n        _closeAuction(_tokenId);\n    }\n\n    /**\n     * Close the auction\n     *\n     * @param _tokenId Token ID\n     */\n    function _closeAuction(uint _tokenId) internal {\n        uint finalPrice = auctions[_tokenId].topBid;\n        bool success = false;\n\n        if (auctions[_tokenId].topBid != 0) {\n            auctions[_tokenId].seller.transfer(finalPrice.mul(100 - successFees).div(100)); // Transfer funds (ETH) to the seller\n            _owner.transfer(finalPrice.mul(successFees).div(100)); // Transfer fees to the contract owner (French ICO)\n            timestamp.setLastPrice(_tokenId, finalPrice);\n            success = true;\n        }\n\ttimestamp.transferFrom(address(this), auctions[_tokenId].topBidder, _tokenId); // Transfer the token to the top bidder (or return it to the seller if the auction failed)\n    \n        emit AuctionClosed(_tokenId, auctions[_tokenId].topBidder, finalPrice, success);\n    }\n    \n}\n"
    },
    "browser/GatewayERC721.sol": {
      "content": "/**\n * Contract: Gateway ERC721\n * Author  : FRENCH-ICO.com ®\n * Website : www.french-ico.com\n * Version : 1.1\n * SPDX-License-Identifier: UNLICENSED\n */\n\npragma solidity ^0.6.12;\n\nimport \"./IFrenchIcoCorporate.sol\";\nimport \"./OwnablePayable.sol\";\nimport \"./GatewayTimestamp.sol\";\nimport \"./GatewayAuction.sol\";\nimport \"./String.sol\";\n\ncontract GatewayERC721 is OwnablePayable, GatewayTimestamp, GatewayAuction {\n\n    // Roles\n    uint constant ROLE_NOT_REGISTERED = 0;\n    uint constant ROLE_ANGEL = 1;\n    uint constant ROLE_ANGEL_PREMIUM = 2;\n    uint constant ROLE_ANGEL_PREMIUM_PRO = 3;\n\n    IFrenchIcoCorporate public corporate;\n\n    /**\n     * Prices to pay to create a certificate\n     */\n    struct Price {\n        uint publicPrice; // Normal price if the creator is anonymous (in wei)\n        uint memberPrice; // Special price if the creator is a FrenchICO member (in wei)\n    }\n    Price public price;\n\n    /**\n     * Constructor\n     *\n     * @param corporateAddress Corporate address\n     * @param ERC721Address ERC721 token address\n     */\n    constructor(address corporateAddress, address ERC721Address) GatewayTimestamp(ERC721Address) public {\n        corporate = IFrenchIcoCorporate(corporateAddress);\n        price.publicPrice = 0;\n        price.memberPrice = 0;\n    }\n\n    /**\n     * Set the corporate address\n     *\n     * @param _corporate Corporate address\n     */\n    function setCorporate(address _corporate) external onlyOwner {\n        corporate = IFrenchIcoCorporate(_corporate);\n    }\n\n    /**\n     * Set the prices\n     *\n     * @param _publicPrice Price for the anonymous user (in wei)\n     * @param _memberPrice Price for the member user (in wei)\n     */\n    function setPrices(uint _publicPrice, uint _memberPrice) external onlyOwner {\n        price.publicPrice = _publicPrice;\n        price.memberPrice = _memberPrice;\n    }\n    \n    /**\n     * Create a new certificate from an anonymous user\n     *\n     * @param _DNA DNA of the document to record\n     * @param _description Message initiated by the creator. This message can't be modified.\n     * @return Token ID\n     */\n    function newCertificate(string memory _DNA, string memory _description) public override payable returns(uint) {\n        uint priceToPay = _calculateCertificatePrice();\n        require(msg.value == priceToPay, \"wrong price to emit a certificate\");\n        \n        uint tokenId = super.newCertificate(_DNA, _description);\n        \n        _owner.transfer(msg.value);\n        \n        return tokenId;\n    }\n\n    /**\n     * Get the price to pay according to the user\n     *\n     */\n    function _calculateCertificatePrice() internal view returns(uint){\n        uint priceToPay;\n        \n        uint role = corporate.getRole(msg.sender);\n        if (role == ROLE_ANGEL || role == ROLE_ANGEL_PREMIUM || role == ROLE_ANGEL_PREMIUM_PRO) {\n            priceToPay = price.memberPrice;\n        } else {\n            priceToPay = price.publicPrice;\n        }\n        return priceToPay;\n    }\n\n    /**\n     * Do an action delegated by the timestamp\n     *\n     * @param _sender Sender\n     * @param _tokenId Token ID\n     * @param _action Action to execute by the gateway\n     * @param _int1 Integer data 1\n     * @param _int2 Integer data 2\n     * @param _int3 Integer data 3\n     * @param _int4 Integer data 4\n     * @param _address1 Address data 1\n     * @param _address2 Address data 2\n     * @param _string1 String data 1\n     * @param _string2 String data 2\n     */\n    function doAction(address payable _sender, uint _tokenId, string memory _action, uint _int1, uint _int2, uint _int3, uint _int4, address _address1, address _address2, string memory _string1, string memory _string2) external payable returns(bool) {\n        require (msg.sender == address(timestamp), \"has to be executed by the timestamp smart contract\");\n        \n        if ( String.compareStringsByBytes(_action, 'create_auction')) {\n            return createAuction(_sender, _tokenId, _int1, _int2, _int3, _int4, _address1);\n        }\n        \n        return false;\n    }\n    \n}\n"
    },
    "browser/GatewayTimestamp.sol": {
      "content": "/**\n * Contract: Gateway Timestamp\n * Author  : FRENCH-ICO.com ®\n * Website : www.french-ico.com\n * Version : 1.1\n * SPDX-License-Identifier: UNLICENSED\n */\n\npragma solidity ^0.6.12;\n\nimport \"./IFrenchIcoERC721Timestamp.sol\";\n\nabstract contract GatewayTimestamp {\n\n    IFrenchIcoERC721Timestamp public timestamp;\n\n    /**\n     * Constructor\n     *\n     * @param _address ERC721 token address\n     */\n    constructor(address _address) public {\n        timestamp = IFrenchIcoERC721Timestamp(address(_address));\n    }\n    \n    /**\n     * Create a new certificate from an anonymous user\n     *\n     * @param _DNA DNA of the document to record\n     * @param _description Message initiated by the creator. This message can't be modified.\n     * @return Always true\n     */\n    function newCertificate(string memory _DNA, string memory _description) public virtual payable returns(uint) {\n        uint tokenId = timestamp.newCertificate(msg.sender, _DNA, _description);\n    \n        return tokenId;\n    }\n}\n"
    },
    "browser/IFrenchIcoCorporate.sol": {
      "content": "/**\n * Interface: IFrenchIcoCorporate\n * Author   : FRENCH-ICO.com ®\n * Website  : www.french-ico.com\n * Version  : 13.0\n * SPDX-License-Identifier: UNLICENSED\n */\n\npragma solidity ^0.6.12;\n\ninterface IFrenchIcoCorporate {\n    function isGeneralPaused() external view returns (bool);\n    function getRole(address _addr) external view returns (uint);\n    function getWalletFrenchICO() external view returns (address payable);\n    function getMaxAmountAngel() external view returns (uint);\n    function getMaxAmountAngelPremium() external view returns (uint);\n    function getMaxAmountAllowedInPeriod1(address _addr) external view returns (uint);\n    function getCountryCode(address _addr) external view returns (string memory);\n}\n"
    },
    "browser/IFrenchIcoERC721Timestamp.sol": {
      "content": "/**\n * Interface: IFrenchIcoERC721Timestamp\n * Author   : FRENCH-ICO.com ®\n * Website  : www.french-ico.com\n * Version  : 1.1\n * SPDX-License-Identifier: UNLICENSED\n */\n\npragma solidity ^0.6.12;\n\ninterface IFrenchIcoERC721Timestamp {\n    \n   function transferFrom(address _from, address _to, uint _tokenId) external;\n   function setLastPrice(uint _tokenId, uint _newLastPrice) external returns(bool);\n   function newCertificate(address _creator, string memory _DNA, string memory _description) external returns(uint);\n}\n"
    },
    "browser/OwnablePayable.sol": {
      "content": "/**\n * Contract: OwnablePayable\n * Author  : FRENCH-ICO.com ®\n * Website : www.french-ico.com\n * Version : 13.0\n * SPDX-License-Identifier: UNLICENSED\n */\n\npragma solidity ^0.6.12;\n\n/**\n * @title OwnablePayable\n * The OwnablePayable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\nabstract contract OwnablePayable {\n    address payable public _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * The OwnablePayable constructor sets the original `owner` of the contract\n     * to the sender account\n     */\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n\n    /**\n     * Throws if called by any account other than the owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, 'Only owner');\n        _;\n    }\n\n    /**\n     * Allows the current owner to transfer control of the contract to a newOwner\n     *\n     * @param newOwner The address to transfer ownership to\n     */\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * Transfers control of the contract to a newOwner\n     *\n     * @param newOwner The address to transfer ownership to\n     */\n    function _transferOwnership(address payable newOwner) internal {\n        require(newOwner != address(0), 'Not transferable to nobody');\n        _owner = newOwner;\n        emit OwnershipTransferred(_owner, newOwner);\n    }\n}\n"
    },
    "browser/String.sol": {
      "content": "/**\n * Library : String\n * Author  : FRENCH-ICO.com ®\n * Website : www.french-ico.com\n * Version : 1.1\n * SPDX-License-Identifier: UNLICENSED\n */\n\npragma solidity ^0.6.12;\n\n/**\n * @title Math\n * @dev Math operations\n */\nlibrary String {\n    \n    /**\n     * Compare two strings\n     *\n     * @param s1 String 1\n     * @param s2 String 2\n     */\n    function compareStringsByBytes(string memory s1, string memory s2) internal pure returns(bool) {\n        return (keccak256(abi.encodePacked((s1))) == keccak256(abi.encodePacked((s2))));\n    }\n    \n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  }
}