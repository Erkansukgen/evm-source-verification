{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Lime.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\ncontract Lime{\r\n\r\n    mapping (address => Details) private details;\r\n    mapping(address => uint256) public balance;\r\n    mapping(string => address) public shortcodes;\r\n    \r\n    struct Details{\r\n        mapping(address => uint256) allowed;\r\n        address who_referred_user;\r\n        uint referral_count;\r\n        bool banned_spender;\r\n        uint total_fees_paid;\r\n        uint gross_outgoing_ever;\r\n        uint gross_incoming_ever;\r\n        uint commissions;\r\n    }\r\n    \r\n    address payable private minter;\r\n    //address payable private reserve;\r\n    uint256 reserve_balance;\r\n    address payable private new_address;\r\n    address payable private superAdmin;\r\n    mapping(address => bool) private admins;\r\n    \r\n    uint[] PIP_FEE = [325, 300, 285, 265, 225, 200, 175, 100, 75, 55, 25, 20, 19, 18, 17, 16, 15];\r\n    uint private MAX_PIPS_ALLOWED = 725;\r\n    uint private levels = 20;\r\n    string public name_of_currency = \"Lime\";\r\n    string public symbol_of_currency = \"LME\";\r\n    uint8 public currency_sub_units = 18;\r\n    \r\n    uint public consumption_value;\r\n    uint public total_ever_minted;\r\n    uint private total_ever_paid;\r\n    uint256 public total_supply;\r\n    \r\n    bool private extra_credit = true;\r\n    \r\n    uint p1 = 1e15;//vote price\r\n    uint p2 = 1e14;//social shortcode price\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n    constructor() public{\r\n        minter = msg.sender;\r\n        new_address = minter;\r\n        consumption_value = 1e16;\r\n    }\r\n    \r\n    receive() external payable{\r\n        msg.sender.transfer(msg.value);\r\n    }\r\n    \r\n    fallback() external payable { \r\n        msg.sender.transfer(msg.value);\r\n    }\r\n    \r\n    modifier permissionedAccess(){\r\n        assert(msg.sender == minter);\r\n        _;\r\n    }\r\n    \r\n    modifier superAdminAccess(){\r\n        assert( (msg.sender == minter) || (msg.sender == superAdmin) );\r\n        _;\r\n    }\r\n    \r\n    modifier adminAccess(){\r\n        assert( (msg.sender == minter) || (msg.sender == superAdmin) || admins[msg.sender] );\r\n        _;\r\n    }\r\n    \r\n    function setP1(uint a)public{\r\n        p1 = a;\r\n    }\r\n    \r\n    function setP2(uint a) public{\r\n        p2 = a;\r\n    }\r\n    \r\n    function getP1() public view returns(uint){\r\n        return p1;\r\n    }\r\n    \r\n    function getP2() public view returns(uint){\r\n        return p2;\r\n    }\r\n\r\nfunction getInfo(address user_1) adminAccess view public returns(uint, uint, uint, uint){\r\n        Details memory det = details[user_1];\r\n        return (det.total_fees_paid, det.gross_outgoing_ever, det.gross_incoming_ever, det.commissions);\r\n    }\r\n    \r\nfunction buyMint() public payable{\r\n        uint to_minter = div(mul(PIP_FEE[get_fee_index(msg.sender)], msg.value), 10000);\r\n        uint paid = sub(msg.value, to_minter);\r\n        //address(this).transfer(paid);\r\n        uint to_mint = mul(paid, 1e20);\r\n        uint denom = mul(105, consumption_value);\r\n        to_mint = div(to_mint, denom);\r\n        //uint to_mint = paid*(1e20/(105*consumption_value));//paid/(200*consumption_value);//(10000*paid*100) / (consumption_value*200*100);\r\n        total_ever_minted = add(total_ever_minted, to_mint);\r\n        total_ever_paid = add(total_ever_paid, paid);\r\n        total_supply = add(total_supply, to_mint);\r\n        uint e = address(this).balance;\r\n        e = mul(e, 1e18);\r\n        consumption_value = div(e, total_supply);\r\n        balance[msg.sender] = add(balance[msg.sender], to_mint);\r\n        emit Transfer(address(0), msg.sender, to_mint);\r\n        minter.transfer(to_minter);\r\n    }\r\n    \r\n    function consume(address payable send_to, uint amount) public{\r\n        assert(balance[msg.sender] >= amount);\r\n        uint cost;\r\n        uint a ; uint b;\r\n        (a, b) = getRating(msg.sender);\r\n        uint score = a/b;\r\n        if(score/universal_average < 1){\r\n            //0 if less than One\r\n            uint fee = 1000000 - score;//max fee = 1%\r\n            cost = fee * amount;\r\n            cost = fee/100000000;\r\n        }\r\n        uint val = (amount-cost)*(address(this).balance)/total_supply;//(amount * consumption_value)/100;\r\n        total_supply = total_supply - amount;\r\n        balance[msg.sender] = sub(balance[msg.sender], amount);\r\n        send_to.transfer(val);\r\n    }\r\n    \r\n    function getConsumptionValue() public view returns(uint256 a, uint256 b){\r\n        return (address(this).balance, total_supply);\r\n    }\r\n    \r\n    function mint(address to, uint256 amount) permissionedAccess public{\r\n        new_mint(to, amount);\r\n    }\r\n    \r\n    function new_mint(address account, uint256 amount) permissionedAccess private{\r\n        assert(account != address(0));\r\n        //uint final_amount = mul(amount, currency_sub_units);\r\n        total_supply = add(total_supply, amount);\r\n        balance[account] = add(balance[account], amount);//final_amount\r\n        emit Transfer(address(0), account, amount);//final_amount\r\n    }\r\n    \r\n    /**\r\n    * @dev Get the name of the currency.\r\n    */\r\n    function name() public view returns (string memory){\r\n        return name_of_currency;\r\n    }\r\n    \r\n    function setName(string memory new_name) superAdminAccess public{\r\n        name_of_currency = new_name;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get the currency symbol.\r\n     */\r\n     \r\n    function symbol() public view returns (string memory){\r\n        return symbol_of_currency;\r\n    }\r\n    \r\n    function setSymbol(string memory new_symbol) superAdminAccess public{\r\n        symbol_of_currency = new_symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8){\r\n        return currency_sub_units;\r\n    }\r\n\r\n    /**\r\n    * @dev Total number of currency units in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return total_supply;\r\n    }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return balance[owner];\r\n  }\r\n  \r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of currency units on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of currency units to be spent.\r\n   */\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    assert(spender != address(0));\r\n    if(details[spender].banned_spender){\r\n        if(details[msg.sender].allowed[spender] > 0){\r\n            details[msg.sender].allowed[spender] = 0;\r\n        }\r\n        return false;\r\n    }\r\n    details[msg.sender].allowed[spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n  \r\n   /**\r\n   * @dev Function to check the amount of currency units that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of currency units still available for the spender.\r\n   */\r\n  function allowance(address owner, address spender) public view returns (uint256){\r\n    return details[owner].allowed[spender];\r\n  }\r\n  \r\n    /**\r\n   * @dev Increase the amount of currency units that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of currency units to increase the allowance by.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool){\r\n    assert(spender != address(0));\r\n    assert(!details[spender].banned_spender);\r\n    details[msg.sender].allowed[spender] = add(details[msg.sender].allowed[spender], addedValue);\r\n    emit Approval(msg.sender, spender, details[msg.sender].allowed[spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of currency units that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of currency units to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool){\r\n    assert(spender != address(0));\r\n    if(details[spender].banned_spender){\r\n        details[msg.sender].allowed[spender] = 0;\r\n        return true;\r\n    }\r\n    if( subtractedValue <= details[msg.sender].allowed[spender] ){\r\n        details[msg.sender].allowed[spender] = sub(details[msg.sender].allowed[spender], subtractedValue);\r\n    }else{\r\n        details[msg.sender].allowed[spender] = 0;\r\n    }\r\n    emit Approval(msg.sender, spender, details[msg.sender].allowed[spender]);\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    return transferFrom(msg.sender, to, value);\r\n  }\r\n  \r\n  function transferShortCode(string memory to, uint256 value) public returns(bool){\r\n    require(bytes(to).length < 25, \"Check social address.\");\r\n    if(shortcodes[to] != address(0)){\r\n        return transferFrom(msg.sender, shortcodes[to], value);\r\n    }else{\r\n        return false;\r\n    }\r\n  }\r\n  \r\n  function transferEth(address payable to) public payable returns (bool){\r\n      to.transfer(msg.value);\r\n      return true;\r\n  }\r\n  \r\n  function transferFromShortCode(address from, string memory to, uint256 value) public returns (bool){\r\n      if(shortcodes[to] != address(0)){\r\n        return transferFrom(from, shortcodes[to], value);\r\n      }else{\r\n        return false; \r\n      }\r\n  }\r\n  \r\n    /**\r\n   * @dev Transfer currency units from one address to another\r\n   * @param from address The address which you want to send currency units from\r\n   * @param to address The address which you want to transfer to\r\n   * @param value uint256 the amount of currency units to be transferred\r\n   */\r\n  function transferFrom(address from, address to, uint256 value) public returns(bool){\r\n    assert(value <= balance[from]);//, \"From balance is insufficient to cover this transaction.\");\r\n    assert((msg.sender == from)||(!details[msg.sender].banned_spender));//, \"Must have authorization from owner to transfer from balance.\");\r\n    assert(to != address(0));\r\n    \r\n    if(msg.sender != from){\r\n        assert(value <= details[from].allowed[msg.sender]);//, \"Spender is not authorized to spend that much.\");\r\n        details[from].allowed[msg.sender] = sub(details[from].allowed[msg.sender], value);\r\n    }\r\n    \r\n    if(value == 0){\r\n        emit Transfer(from, to, 0);\r\n        return true;\r\n    }\r\n    \r\n    uint final_value;\r\n    uint cost;\r\n    cost = div(mul(PIP_FEE[get_fee_index(to)], value), 10000);\r\n    final_value = sub(value, cost);\r\n    \r\n    balance[from] = sub(balance[from], value);\r\n    balance[to] = add(balance[to], final_value);\r\n    \r\n    emit Transfer(from, to, value);\r\n    \r\n    details[to].total_fees_paid = add(details[to].total_fees_paid, cost);\r\n    details[from].gross_outgoing_ever = add(details[from].gross_outgoing_ever, value);\r\n    details[to].gross_incoming_ever = add(details[to].gross_incoming_ever, value);\r\n    \r\n    uint reserve_amount = div(cost, 2);\r\n    uint minter_amount = reserve_amount;\r\n    uint point = div(cost, 100);\r\n    \r\n    minter_amount += point;\r\n    reserve_amount -= point;\r\n    \r\n    balance[minter] = add(balance[minter], minter_amount);\r\n    //balance[reserve] = add(balance[reserve], reserve_amount);\r\n    reserve_balance = add(reserve_balance, reserve_amount);\r\n    details[minter].gross_incoming_ever = add(details[minter].gross_incoming_ever, minter_amount);\r\n    //details[reserve].gross_incoming_ever = add(details[reserve].gross_incoming_ever, reserve_amount);\r\n    emit Transfer(to, minter, minter_amount);\r\n    //emit Transfer(to, reserve, reserve_amount);\r\n    \r\n    reward(reserve_amount, point, to);\r\n    \r\n    return true;\r\n  }\r\n  \r\n  function update(address payable updated_address) permissionedAccess public{\r\n      assert(msg.sender == minter);\r\n      new_address = updated_address;\r\n  }\r\n  \r\n  function confirm_new_address() public{\r\n      assert(msg.sender == new_address);\r\n      minter = new_address;\r\n  }\r\n\r\n  function change_pip_fee(uint pips, uint8 index) superAdminAccess public{\r\n      assert(pips < MAX_PIPS_ALLOWED);\r\n      PIP_FEE[index] = pips;\r\n  }\r\n  \r\n  function set_extra_credit(bool value) superAdminAccess public{\r\n      extra_credit = value;\r\n  }\r\n  \r\n  function set_levels(uint _levels) permissionedAccess public{\r\n      levels = _levels;\r\n  }\r\n  \r\n  function ban_spender(address spender, bool value) adminAccess public{\r\n      details[spender].banned_spender = value;\r\n  }\r\n  \r\n  function approveSuperAdmin(address payable _superAdmin) permissionedAccess public{\r\n      superAdmin = _superAdmin;\r\n  }\r\n  \r\n  function approveAdmin(address new_admin, bool approved) superAdminAccess public{\r\n      admins[new_admin] = approved;\r\n  }\r\n  \r\n  function registerReference(address reference_to_add) public{\r\n      assert(reference_to_add != address(0));\r\n      address referrer = details[msg.sender].who_referred_user;\r\n      if(details[referrer].referral_count > 0){\r\n          if(referrer != reference_to_add){\r\n              details[referrer].referral_count -= 1;\r\n          }else{\r\n              return;\r\n          }\r\n      }\r\n      details[msg.sender].who_referred_user = reference_to_add;\r\n      details[reference_to_add].referral_count += 1;\r\n  }\r\n  \r\n  function registerreferenceShortCode(string memory reference_to_add) public{\r\n      assert(bytes(reference_to_add).length <= 25);\r\n      registerReference(shortcodes[reference_to_add]);\r\n  }\r\n  \r\n  function who_referred_user(address user) public view returns(address){\r\n      return details[user].who_referred_user;\r\n  }\r\n  \r\n    function reward(uint split, uint bonus, address addr) private{\r\n        address next;\r\n        uint extra = 0;\r\n        for(uint i = 0; i < levels; i++){\r\n            next = details[addr].who_referred_user;\r\n            if((next == address(0)) || (next == msg.sender)){\r\n                safePay(minter, split);\r\n                return;\r\n            }\r\n            else{\r\n                addr = next;\r\n            }\r\n            split = div(split, 2);\r\n            if(split > 0){\r\n                if(extra_credit){\r\n                    if(i == 2 || i == 4 || i == 8 || i == 16){\r\n                        if(details[next].referral_count > 10){\r\n                            bonus = div(bonus, 2);\r\n                            extra = bonus;\r\n                        }\r\n                    }\r\n                }\r\n                safePay(next, add(split, extra) );\r\n                extra = 0;\r\n            }else{\r\n                return;\r\n            }\r\n        }\r\n        safePay(minter, add(split, extra));\r\n    }\r\n    \r\n    function safePay(address payee, uint256 amount) private{\r\n        if(reserve_balance < amount){\r\n            return;\r\n        }\r\n        reserve_balance = sub(reserve_balance, amount);\r\n        balance[payee] = add(balance[payee], amount);\r\n        emit Transfer(address(0), payee, amount);\r\n        \r\n        //details[reserve].gross_outgoing_ever = add(details[reserve].gross_outgoing_ever, amount);\r\n        details[payee].gross_incoming_ever = add(details[payee].gross_incoming_ever, amount);\r\n        details[payee].commissions = add(details[payee].commissions, amount);\r\n    }\r\n\r\n    function get_fee_index(address payer) private view returns (uint8){\r\n        uint8 index = 0;\r\n        if(details[payer].who_referred_user != address(0)){\r\n            if(details[payer].who_referred_user != payer){\r\n                index += 1;\r\n            }\r\n        }\r\n        uint wa = ratings[payer].weighted_average;\r\n        if(wa > universal_average){\r\n            index += 1;\r\n            if(wa > 800000){\r\n                index += 1;\r\n                if(wa > 900000){\r\n                    index += 1;\r\n                    if(wa > 980000){\r\n                        index += 1;\r\n                        if(wa >= 997000){\r\n                            index += 2;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        uint rc = details[payer].referral_count;\r\n        if(rc > 0){\r\n            index += 1;\r\n            if(extra_credit){\r\n                if(rc > 5){\r\n                    index += 1;\r\n                    if(rc > 10){\r\n                        index += 1;\r\n                        if(rc > 20){\r\n                            index += 1;\r\n                            if(rc > 50){\r\n                                index += 1;\r\n                                if(rc > 100){\r\n                                    index += 1;\r\n                                    if(rc > 250){\r\n                                        index += 1;\r\n                                        if(rc > 500){\r\n                                            index += 1;\r\n                                            if(rc > 1000){\r\n                                                index += 1;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n  \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function addShortCode(string memory shortcode) public returns(bool){\r\n        assert(bytes(shortcode).length <= 25);\r\n        assert(balance[msg.sender] >= p2);\r\n        balance[msg.sender] = balance[msg.sender] - p2;\r\n        balance[minter] = balance[minter] + p2;\r\n        if(shortcodes[shortcode] == address(0)){\r\n            shortcodes[shortcode] = msg.sender;\r\n            return true;\r\n        }\r\n            return false;\r\n    }\r\n    \r\n    function whoOwns(string memory shortcode) public view returns(address){\r\n        return shortcodes[shortcode];\r\n    }\r\n    /* transfer_to address(0) to erase */\r\n    function transferOwnership(string memory shortcode, address transfer_to) public{\r\n        assert(shortcodes[shortcode] == msg.sender);\r\n        shortcodes[shortcode] = transfer_to;\r\n    }\r\n    \r\n    uint universal_average = 1000000;//divide by 10000 to get percent value\r\n    uint u_num;\r\n    uint u_den;\r\n    \r\n    mapping(address => Votes) ratings;\r\n    \r\n    struct Votes{\r\n        uint voted_by;\r\n        uint weighted_average;\r\n        uint numerator;\r\n        uint denominator;\r\n        mapping(address => bool) voted_already;\r\n    }\r\n\r\n    function vote(address user, uint rating) public{\r\n        assert(balance[msg.sender] >= p1);\r\n        assert(rating <= 1000000);\r\n        if(ratings[user].voted_already[msg.sender]){\r\n            return;\r\n        }else{\r\n            ratings[user].voted_already[msg.sender] = true;\r\n            balance[msg.sender] = balance[msg.sender] - p1;\r\n            balance[minter] = balance[minter] + p1;\r\n            if(ratings[msg.sender].voted_by == 0){\r\n                ratings[msg.sender].voted_by = 1;\r\n                ratings[msg.sender].weighted_average = universal_average;\r\n                ratings[msg.sender].numerator = 1;\r\n                ratings[msg.sender].denominator = 1;\r\n            }\r\n            uint add_to_numerator = ratings[msg.sender].weighted_average * ratings[msg.sender].voted_by * rating;\r\n            uint add_to_denominator = ratings[msg.sender].weighted_average * ratings[msg.sender].voted_by;//must be > 0\r\n            ratings[user].numerator = ratings[user].numerator + add_to_numerator;\r\n            ratings[user].denominator = ratings[user].denominator + add_to_denominator;\r\n            ratings[user].weighted_average = ratings[user].numerator / ratings[user].denominator;\r\n            ratings[user].voted_by = ratings[user].voted_by + 1;\r\n            u_num = u_num + ratings[user].numerator;\r\n            u_den = u_den + ratings[user].denominator;\r\n            universal_average = u_num / u_den;\r\n        }\r\n    }\r\n    \r\n    function getRating(address user) public view returns(uint a, uint b){\r\n        if(ratings[user].voted_by > 0){\r\n            return (ratings[user].weighted_average, ratings[user].voted_by);\r\n        }else{\r\n            return (0, 0);\r\n        }\r\n    }\r\n\r\n}"}}}