{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/1_Storage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n        } else if (signature.length == 64) {\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let vs := mload(add(signature, 0x40))\n                r := mload(add(signature, 0x20))\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                v := add(shr(255, vs), 27)\n            }\n        } else {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n* Contract to facilitate buying, selling of NFTs\n*/\ncontract Exchange is Ownable {\n\n    address payable private _platformWallet;\n\n    address public _wethContract; // Contract address of Ethereum: wETH, Polygon: wMatic, BSC: wBNB\n\n    uint256 constant PERCENTAGE_DIVISOR = 100000;  // 1000 * 100, 1000 to get percentage and 100 to get fraction\n\n    uint256 public constant MAX_PAYEES = 10;\n\n    enum AssetType { ERC20, ERC721, ERC1155 }\n\n    enum OrderType { Buy, Sell, Offer, AuctionOffer, Auction } // 0 - buy, 1 - sell, 2 - offer, 3 - auction offer, 4 - auction\n\n    // cancelled or finalized orders by hash, to mitigate replay attacks\n    mapping(bytes32 => bool) public cancelledOrFinalized;\n\n    // order details\n    struct Order {\n        OrderType orderType;\n        address tokenAddress;\n        AssetType assetType;\n        uint256 tokenId;\n        uint256 tokenQuantity;\n        uint256 price;\n        address maker;\n        address taker; // null for offer\n\n        // royalty & fees\n        uint256 royaltyPercentage; // decimal 3 digits\n        address payable royaltyRecipient;\n        uint256 platformFees; // decimal 3 digits\n        uint256 storeFees; // decimal 3 digits\n        address payable storeWallet;\n\n        // payee info\n        address payable[MAX_PAYEES] payees;\n        uint256[MAX_PAYEES] payeePercentage;\n        uint256 payeeCount;\n        \n        uint256 expiresAt; // unix timestamp\n        bytes32 nonce;\n\n        // needed in case of auction offers. This is signature of auction data to which this offer belongs\n        bytes auctionSignature;\n\n        // reserve price for auction\n        uint256 reservePrice;\n        uint256 startsAt; // for Dutch auction, unix timestamp\n    }\n\n    event OrderCancelled(Order order);\n\n    event Sale(Order order, uint256 platformFeesValue, uint256 storeFeesValue, uint256 royaltyFees);\n\n    event AuctionSale(Order auctionOrder, Order offerOrder, uint256 platformFeesValue, uint256 storeFeesValue, uint256 royaltyFees);\n\n    constructor(address payable platformWallet, address wethContract) {\n\n        _platformWallet = platformWallet;\n        _wethContract = wethContract;\n    }\n\n\n    function getPlatformWallet() public view virtual returns (address) {\n        return _platformWallet;\n    }\n\n\n    function setPlatformWallet(address payable platformWallet) public virtual onlyOwner {\n\n        require(platformWallet != address(0), \"Ex: Platform wallet address cannot be zero address\");\n        _platformWallet = platformWallet;\n    }\n\n\n    function getWethContract() public view virtual returns (address) {\n        return _wethContract;\n    }\n\n\n    function setWethContract(address wethContract) public virtual onlyOwner {\n\n        require(wethContract != address(0), \"Ex: wETH contract address cannot be zero address\");\n        _wethContract = wethContract;\n    }\n\n\n    function isOrderCancelledOrFinalized(Order memory order) public view virtual returns (bool) {\n\n        return cancelledOrFinalized[calculateOrderHash(order)];\n    }\n\n\n    function cancelOrder (Order memory order, bytes memory signature) public virtual {\n\n        // hash sale order details\n        bytes32 hash = calculateOrderHash(order);\n\n        // check if order is already filled or cancelled\n        require(!cancelledOrFinalized[hash], \"Ex: Order is already filled or cancelled\");\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(hash);\n\n        address signer = ECDSA.recover(messageHash, signature);\n\n        // check if sender is authorized to cancel order\n        require(_msgSender() == signer, \"Ex: Sender is not authorised to cancel order\");\n      \n        // mark order as cancelled\n        cancelledOrFinalized[hash] = true;\n\n        // Log cancel event\n        emit OrderCancelled(order);\n    }\n\n\n    function buyDirect(Order memory order, bytes memory signature) public virtual payable {\n\n        // overwrite taker to caller address\n        order.taker = _msgSender();\n            \n        buy(order, signature);\n    }\n\n\n    function buyOnBehalf(Order memory order, bytes memory signature) public virtual payable {\n\n        buy(order, signature);\n    }\n\n\n    function buy(Order memory order, bytes memory signature) internal virtual {\n\n        require(order.assetType == AssetType.ERC721 || order.assetType == AssetType.ERC1155, \n            \"Ex: Asset type not supported\");\n\n        require(order.orderType == OrderType.Sell, \"Ex: Order type should be 1 (Sell)\");\n\n        require(msg.value == order.price, \"Ex: Not enough ether sent to buy NFT\");\n\n        //require(order.royaltyPercentage >= 0 && order.royaltyPercentage <= 50000, \"Ex: royaltyPercentage is not valid. Valid Range(0% - 50%): 0 - 50000\");\n\n        require(order.royaltyPercentage == 0 || order.royaltyRecipient != address(0), \"Ex: royaltyRecipient cannot be zero if royaltyPercentage is set\");\n\n        require(order.payeeCount <= MAX_PAYEES, \"Ex: Payee count cannot be > 10\");\n\n        // make sure total commission is not more than 100%\n        require(order.royaltyPercentage + order.platformFees + order.storeFees < 100000, \"Ex: Royalty + Total Commission should be < 100%\");\n\n        // hash sale order details\n        bytes32 hash = calculateOrderHash(order);\n\n        // check if order is already filled or cancelled\n        require(!cancelledOrFinalized[hash], \"Ex: Order is already filled or cancelled\");\n\n        // mark order as filled\n        cancelledOrFinalized[hash] = true;\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(hash);\n\n        address signer = ECDSA.recover(messageHash, signature);\n\n        require(signer == order.maker, \"Ex: Sale order does not belong to this maker\");\n\n        if (order.assetType == AssetType.ERC721) {\n\n            IERC721 erc721 = IERC721(order.tokenAddress);\n\n            require(signer == erc721.ownerOf(order.tokenId), \"Ex: Not a valid Sale Order\");\n\n            erc721.safeTransferFrom(signer, order.taker, order.tokenId);\n        }\n        else if(order.assetType == AssetType.ERC1155) {\n\n            IERC1155 erc1155 = IERC1155(order.tokenAddress);\n\n            require(erc1155.balanceOf(signer, order.tokenId) >= order.tokenQuantity, \"Ex: Not a valid Sale Order\");\n\n            erc1155.safeTransferFrom(signer, order.taker, order.tokenId, order.tokenQuantity, '');\n        }\n\n        // calculate Platform fees\n        uint256 platformFeesValue = order.price * order.platformFees / PERCENTAGE_DIVISOR;\n\n        // transfer platform fees\n        if(platformFeesValue > 0) {\n            _platformWallet.transfer(platformFeesValue);\n        }\n\n        // calculate Store fees\n        uint256 storeFeesValue = order.price * order.storeFees / PERCENTAGE_DIVISOR;\n\n        // transfer store fees\n        if(storeFeesValue > 0) {\n            order.storeWallet.transfer(storeFeesValue);\n        }\n\n        // calculate royalty\n        uint256 royaltyValue = order.price * order.royaltyPercentage / PERCENTAGE_DIVISOR;\n\n        // transfer royalty\n        if(royaltyValue > 0) {\n            order.royaltyRecipient.transfer(royaltyValue);\n        }\n\n        // net sale procceds remaining\n        uint saleProceeds = order.price - platformFeesValue - storeFeesValue - royaltyValue;\n\n        uint totalPayeePercentage = 0;\n\n        // transfer sale proceeds\n        for(uint256 i = 0; i < order.payeeCount; i++) {\n\n            totalPayeePercentage += order.payeePercentage[i];\n\n            // Payee % sum < 100 or if it is last payee it should be exactly 100\n            require(totalPayeePercentage < 100000 || (i == order.payeeCount - 1 && totalPayeePercentage == 100000),\n                \"Ex: Payee % sum should be == 100000 (100%)\");\n\n            uint payAmount = saleProceeds * order.payeePercentage[i] / PERCENTAGE_DIVISOR;\n\n            if(payAmount > 0) {\n                order.payees[i].transfer(payAmount);\n            }\n        }\n\n        emit Sale(order, platformFeesValue, storeFeesValue, royaltyValue);\n    }\n\n\n    function acceptOfferDirect(Order memory order, bytes memory signature) public virtual payable {\n\n        // overwrite taker to caller address\n        order.taker = _msgSender();\n            \n        acceptOffer(order, signature);\n    }\n\n\n    function acceptOffer(Order memory order, bytes memory signature) internal virtual {\n\n        require(order.assetType == AssetType.ERC721 || order.assetType == AssetType.ERC1155, \n            \"Ex: Asset type not supported\");\n\n        require(order.orderType == OrderType.Offer, \"Ex: Order type should be 2 (Offer)\");\n\n        require(order.expiresAt > block.timestamp, \"Ex: Offer has expired\");\n\n        IERC20 weth = IERC20(_wethContract);\n\n        require(weth.balanceOf(order.maker) >= order.price, \"Ex: Not enough WETH to buy NFT\");\n\n        //require(order.royaltyPercentage >= 0 && order.royaltyPercentage <= 50000, \"Ex: royaltyPercentage is not valid. Valid Range(0% - 50%): 0 - 50000\");\n\n        require(order.royaltyPercentage == 0 || order.royaltyRecipient != address(0), \"Ex: royaltyRecipient cannot be zero if royaltyPercentage is set\");\n\n        require(order.payeeCount <= MAX_PAYEES, \"Ex: Payee count cannot be > 10\");\n\n        // make sure total commission is not more than 100%\n        require(order.royaltyPercentage + order.platformFees + order.storeFees < 100000, \"Ex: Royalty + Total Commission should be < 100%\");\n\n        // hash sale order details\n        bytes32 hash = calculateOrderHash(order);\n\n        // check if order/offer is already filled/accepted or cancelled\n        require(!cancelledOrFinalized[hash], \"Ex: Offer is already accepted or cancelled\");\n\n        // mark order/offer as filled/accepted\n        cancelledOrFinalized[hash] = true;\n\n        bytes32 messageHash = ECDSA.toEthSignedMessageHash(hash);\n\n        address signer = ECDSA.recover(messageHash, signature);\n\n        require(signer == order.maker, \"Ex: Sale offer does not belong to this maker\");\n\n        if (order.assetType == AssetType.ERC721) {\n\n            IERC721 erc721 = IERC721(order.tokenAddress);\n\n            require(order.taker == erc721.ownerOf(order.tokenId), \"Ex: Not a valid Offer\");\n\n            // transfer from taker to maker because order is an offer\n            erc721.safeTransferFrom(order.taker, order.maker, order.tokenId);\n        }\n        else if(order.assetType == AssetType.ERC1155) {\n\n            IERC1155 erc1155 = IERC1155(order.tokenAddress);\n\n            require(erc1155.balanceOf(order.taker, order.tokenId) >= order.tokenQuantity, \"Ex: Not a valid Offer\");\n\n            // transfer from taker to maker because order is an offer\n            erc1155.safeTransferFrom(order.taker, order.maker, order.tokenId, order.tokenQuantity, '');\n        }\n\n        // calculate Platform fees\n        uint256 platformFeesValue = order.price * order.platformFees / PERCENTAGE_DIVISOR;\n\n        // transfer platform fees\n        if(platformFeesValue > 0) {\n            weth.transferFrom(order.maker, _platformWallet, platformFeesValue);\n        }\n\n        // calculate Store fees\n        uint256 storeFeesValue = order.price * order.storeFees / PERCENTAGE_DIVISOR;\n\n        // transfer store fees\n        if(storeFeesValue > 0) {\n            weth.transferFrom(order.maker, order.storeWallet, storeFeesValue);\n        }\n\n        // calculate royalty\n        uint256 royaltyValue = order.price * order.royaltyPercentage / PERCENTAGE_DIVISOR;\n\n        // transfer royalty\n        if(royaltyValue > 0) {\n            weth.transferFrom(order.maker, order.royaltyRecipient, royaltyValue);\n        }\n\n        // net sale procceds remaining\n        uint saleProceeds = order.price - platformFeesValue - storeFeesValue - royaltyValue;\n\n        uint totalPayeePercentage = 0;\n\n        // transfer sale proceeds\n        for(uint256 i = 0; i < order.payeeCount; i++) {\n\n            totalPayeePercentage += order.payeePercentage[i];\n\n            // Payee % sum < 100 or if it is last payee it should be exactly 100\n            require(totalPayeePercentage < 100000 || (i == order.payeeCount - 1 && totalPayeePercentage == 100000),\n                \"Ex: Payee % sum should be == 100000 (100%)\");\n\n            uint payAmount = saleProceeds * order.payeePercentage[i] / PERCENTAGE_DIVISOR;\n\n            if(payAmount > 0) {\n                weth.transferFrom(order.maker, order.payees[i], payAmount);\n            }\n        }\n\n        emit Sale(order, platformFeesValue, storeFeesValue, royaltyValue);\n    }\n\n\n    function acceptAuctionOffer(Order memory auctionOrder, Order memory offerOrder, bytes memory OfferSignature) public virtual {\n\n        require(auctionOrder.assetType == AssetType.ERC721 || auctionOrder.assetType == AssetType.ERC1155, \n            \"Ex: Asset type not supported\");\n\n        require(auctionOrder.orderType == OrderType.Auction, \"Ex: Auction order type should be 4 (Auction)\");\n\n        require(offerOrder.orderType == OrderType.AuctionOffer, \"Ex: Offer Order type should be 3 (Auction Offer)\");\n\n        require(offerOrder.expiresAt > block.timestamp, \"Ex: Offer has expired\");\n\n        require(_msgSender() == auctionOrder.maker || offerOrder.price >= auctionOrder.reservePrice, \n            \"Ex: Only auctioneer can accept offer below reserve price\");\n\n        IERC20 weth = IERC20(_wethContract);\n\n        require(weth.balanceOf(offerOrder.maker) >= offerOrder.price, \"Ex: Not enough WETH to buy NFT\");\n\n        //require(auctionOrder.royaltyPercentage >= 0 && auctionOrder.royaltyPercentage <= 50000, \"Ex: royaltyPercentage is not valid. Valid Range(0% - 50%): 0 - 50000\");\n\n        require(auctionOrder.royaltyPercentage == 0 || auctionOrder.royaltyRecipient != address(0), \"Ex: royaltyRecipient cannot be zero if royaltyPercentage is set\");\n\n        require(auctionOrder.payeeCount <= MAX_PAYEES, \"Ex: Payee count cannot be > 10\");\n\n        // make sure total commission is not more than 100%\n        require(auctionOrder.royaltyPercentage + auctionOrder.platformFees + auctionOrder.storeFees < 100000, \"Ex: Royalty + Total Commission should be < 100%\");\n\n        // hash auction order details\n        bytes32 auctionHash = calculateOrderHash(auctionOrder);\n\n        // check if auction is already filled/accepted or cancelled\n        require(!cancelledOrFinalized[auctionHash], \"Ex: Auction is already fulfilled or cancelled\");\n\n        // hash offer order details\n        bytes32 offerHash = calculateOrderHash(offerOrder);\n\n        // check if offer is already filled/accepted or cancelled\n        require(!cancelledOrFinalized[offerHash], \"Ex: Offer is already accepted or cancelled\");\n\n        // mark auction as filled/accepted\n        cancelledOrFinalized[auctionHash] = true;\n\n        // mark offer as filled/accepted\n        cancelledOrFinalized[offerHash] = true;\n\n        bytes32 auctionMessageHash = ECDSA.toEthSignedMessageHash(auctionHash);\n\n        address auctionSigner = ECDSA.recover(auctionMessageHash, offerOrder.auctionSignature);\n\n        require(auctionSigner == auctionOrder.maker, \"Ex: Offer does not belong to this Auction\");\n\n        bytes32 offerMessageHash = ECDSA.toEthSignedMessageHash(offerHash);\n\n        address offerSigner = ECDSA.recover(offerMessageHash, OfferSignature);\n\n        require(offerSigner == offerOrder.maker, \"Ex: Offer does not belong to this maker\");\n\n        if (auctionOrder.assetType == AssetType.ERC721) {\n\n            IERC721 erc721 = IERC721(auctionOrder.tokenAddress);\n\n            require(auctionOrder.maker == erc721.ownerOf(auctionOrder.tokenId), \"Ex: Not a valid Auction\");\n\n            // transfer from auction maker to offer maker\n            erc721.safeTransferFrom(auctionOrder.maker, offerOrder.maker, auctionOrder.tokenId);\n        }\n        else if(auctionOrder.assetType == AssetType.ERC1155) {\n\n            IERC1155 erc1155 = IERC1155(auctionOrder.tokenAddress);\n\n            require(erc1155.balanceOf(auctionOrder.maker, auctionOrder.tokenId) >= auctionOrder.tokenQuantity, \"Ex: Not a valid Auction\");\n\n            // transfer from auction maker to offer maker\n            erc1155.safeTransferFrom(auctionOrder.maker, offerOrder.maker, auctionOrder.tokenId, auctionOrder.tokenQuantity, '');\n        }\n\n        distributeRevenue(auctionOrder, offerOrder, weth);\n    }\n\n\n    function distributeRevenue(Order memory auctionOrder, Order memory offerOrder, IERC20 weth) internal virtual {\n        \n        // calculate Platform fees\n        uint256 platformFeesValue = offerOrder.price * auctionOrder.platformFees / PERCENTAGE_DIVISOR;\n\n        // transfer platform fees\n        if(platformFeesValue > 0) {\n            weth.transferFrom(offerOrder.maker, _platformWallet, platformFeesValue);\n        }\n\n        // calculate Store fees\n        uint256 storeFeesValue = offerOrder.price * auctionOrder.storeFees / PERCENTAGE_DIVISOR;\n\n        // transfer store fees\n        if(storeFeesValue > 0) {\n            weth.transferFrom(offerOrder.maker, auctionOrder.storeWallet, storeFeesValue);\n        }\n\n        // calculate royalty\n        uint256 royaltyValue = offerOrder.price * auctionOrder.royaltyPercentage / PERCENTAGE_DIVISOR;\n\n        // transfer royalty\n        if(royaltyValue > 0) {\n            weth.transferFrom(offerOrder.maker, auctionOrder.royaltyRecipient, royaltyValue);\n        }\n\n        // net sale procceds remaining\n        uint saleProceeds = offerOrder.price - platformFeesValue - storeFeesValue - royaltyValue;\n\n        uint totalPayeePercentage = 0;\n\n        // transfer sale proceeds\n        for(uint256 i = 0; i < auctionOrder.payeeCount; i++) {\n\n            totalPayeePercentage += auctionOrder.payeePercentage[i];\n\n            // Payee % sum < 100 or if it is last payee it should be exactly 100\n            require(totalPayeePercentage < 100000 || (i == auctionOrder.payeeCount - 1 && totalPayeePercentage == 100000),\n                \"Ex: Payee % sum should be == 100000 (100%)\");\n\n            uint payAmount = saleProceeds * auctionOrder.payeePercentage[i] / PERCENTAGE_DIVISOR;\n\n            if(payAmount > 0) {\n                weth.transferFrom(offerOrder.maker, auctionOrder.payees[i], payAmount);\n            }\n        }\n\n        emit AuctionSale(auctionOrder, offerOrder, platformFeesValue, storeFeesValue, royaltyValue);\n    }\n    \n\n    function calculateOrderHash(Order memory order) internal view virtual returns (bytes32) {\n\n        if(order.orderType == OrderType.AuctionOffer) {\n            return keccak256(abi.encodePacked(uint256(order.orderType), order.price, \n            order.expiresAt, order.nonce, order.auctionSignature));\n        }\n\n        // hash sale order details\n        bytes32 hash1 = keccak256(abi.encodePacked(uint256(order.orderType), order.tokenAddress, \n            uint256(order.assetType), order.tokenId, order.tokenQuantity, order.price, order.royaltyPercentage, \n            order.royaltyRecipient, order.nonce));\n\n        bytes32 hash2;\n\n        if(order.orderType == OrderType.Sell) {\n            hash2 = keccak256(abi.encodePacked(\n                order.platformFees, order.storeFees, order.storeWallet,\n                order.payees, order.payeePercentage, order.payeeCount,\n                order.expiresAt));\n        }\n        else if(order.orderType == OrderType.Offer) {\n            hash2 = keccak256(abi.encodePacked(\n                order.platformFees, order.storeFees, order.storeWallet,\n                order.expiresAt));\n        }\n        else if(order.orderType == OrderType.Auction) {\n            hash2 = keccak256(abi.encodePacked(\n                order.platformFees, order.storeFees, order.storeWallet,\n                order.payees, order.payeePercentage, order.payeeCount,\n                order.expiresAt, order.reservePrice, order.startsAt));\n        }\n\n        // combine hashes\n        return keccak256(abi.encodePacked(hash1 , hash2));\n    }\n    \n}"}}}