{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/mUSDC.sol": {
      "content": "pragma solidity ^0.8.4;\r\n//SPDX-License-Identifier: MIT\r\n\r\n\r\nabstract contract ERC20 {\r\n    function balanceOf(address _owner) virtual public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _amount) virtual public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) virtual public returns (bool success); \r\n}\r\n\r\n\r\ninterface StoreInterface {\r\n    function getExtensionStake(uint _option) external view returns(uint256, address);\r\n    function getExtensionCollateral(uint _option) external view returns(uint256, address);\r\n    function updateCollateral(uint256 _amount, uint256 _option) external;\r\n}\r\n\r\n\r\ninterface StoreExtension {\r\n    function processPayment(address _customer, uint256 _tokenID, uint256 _amount) external;\r\n}\r\n\r\n\r\ninterface StoreHubInterface {\r\n    function initBalance(address _store) external;\r\n    function withdraw(address _to) external;\r\n}\r\n\r\n\r\ninterface StoreProxy {\r\n    function init(address _owner, address usdtHub, address daiHub) external;\r\n}\r\n\r\n\r\ncontract StoreHub {\r\n    event CollateralTransfer(address indexed store, address to, uint256 amount, uint256 rate, bool didTrade);\r\n    event CollateralReliefUpdated(address indexed store, uint256 amount, uint256 rate, bool didAdd);\r\n    event StoreCreated(address indexed store, address owner, uint256 creationDate); \r\n    event AtokenTransfer(address indexed store, address to, uint256 amount);\r\n    event ExtensionUpdated(address indexed store, address extension);\r\n    event OwnerUpdated(address indexed store, address newOwner);\r\n    event StakeUpdated(address indexed store, uint256 stake);\r\n    \r\n    ERC20 public usdcContract;\r\n    address public usdtStoreHub;\r\n    address public daiStoreHub;\r\n    address public storeImplementation;\r\n    uint256 public totalSupply;\r\n    \r\n    mapping(address => bool) public isValidStore;\r\n    mapping(address => uint256) public storeBalance;\r\n    \r\n    function deployStore() external {\r\n        address newStore;\r\n        bytes20 targetBytes = bytes20(storeImplementation);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            newStore := create(0, clone, 0x37)\r\n        }\r\n        StoreProxy(newStore).init(msg.sender, usdtStoreHub, daiStoreHub);\r\n        isValidStore[newStore] = true;\r\n        storeBalance[newStore] = 1;\r\n        StoreHubInterface(usdtStoreHub).initBalance(newStore);\r\n        StoreHubInterface(daiStoreHub).initBalance(newStore);\r\n        emit StoreCreated(newStore, msg.sender, block.timestamp);\r\n    }\r\n    \r\n    function withdraw(uint256 _collateral) external {\r\n        require(isValidStore[msg.sender] == true);\r\n        uint256 balance = storeBalance[msg.sender] - 1;\r\n        storeBalance[msg.sender] = 1;\r\n        totalSupply += _collateral;\r\n        usdcContract.transfer(msg.sender, balance);\r\n        emit CollateralTransfer(address(0), msg.sender, _collateral, 0, false);\r\n    }\r\n    \r\n    function callEvent(\r\n        address _value1,\r\n        uint256 _value2, \r\n        uint256 _value3, \r\n        bool _value4,\r\n        uint _option\r\n    ) external {\r\n        require(isValidStore[msg.sender] == true);\r\n        \r\n        if(_option == 0) {\r\n            emit StakeUpdated(msg.sender, _value2);\r\n        }\r\n        else if(_option == 1) {\r\n            emit CollateralReliefUpdated(msg.sender, _value2, _value3, _value4);\r\n        }\r\n        else if(_option == 2) {\r\n            emit CollateralTransfer(msg.sender, _value1, _value2, _value3, _value4);\r\n        }\r\n        else if(_option == 3) {\r\n            emit AtokenTransfer(msg.sender, _value1, _value2);\r\n        }\r\n        else if(_option == 4) {\r\n            emit ExtensionUpdated(msg.sender, _value1);\r\n        }\r\n        else {\r\n            emit OwnerUpdated(msg.sender, _value1);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract mUSDC is StoreHub {\r\n    \r\n    string public name = \"Malus USDC Token\";\r\n    string public symbol = \"mUSDC\";\r\n    uint public decimals = 6;\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n    \r\n    mapping(address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    constructor(address _usdcContract, address _usdtStoreHub, address _daiStoreHub, address _implementation) {\r\n        usdcContract = ERC20(_usdcContract);\r\n        usdtStoreHub = _usdtStoreHub;\r\n        daiStoreHub = _daiStoreHub;\r\n        storeImplementation = _implementation;\r\n    }\r\n    \r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _amount) public returns (bool success) {\r\n        require(balances[msg.sender] >= _amount);\r\n        \r\n        if(isValidStore[_to] == true) {\r\n            StoreInterface store = StoreInterface(_to);\r\n            burn(store, msg.sender, 0, _amount); \r\n            return true;\r\n        }\r\n        \r\n        balances[_to] += _amount;\r\n        balances[msg.sender] -= _amount;\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\r\n        require(balances[_from] >= _amount);\r\n        \r\n        if(isValidStore[_to] == true) {\r\n            StoreInterface store = StoreInterface(_to);\r\n            burn(store, _from, 0, _amount); \r\n            return true;\r\n        }\r\n        \r\n        if (_from != msg.sender && allowed[_from][msg.sender] < (2**256 - 1)) {\r\n            require(allowed[_from][msg.sender] >= _amount);\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        \r\n        balances[_to] += _amount;\r\n        balances[_from] -= _amount;\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n   \r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    function mint(StoreInterface _store, uint256 _tokenID, uint256 _amount) external {\r\n        (uint256 stake, address extensionAddress) = _store.getExtensionStake(0);\r\n        uint256 cashbackAmount = ((_amount * 700) / 10000);\r\n        uint256 prevStoreBalance = (storeBalance[address(_store)] += _amount) - _amount;\r\n        require(cashbackAmount >= 1);\r\n        require((stake - (((prevStoreBalance - 1) * 700) / 10000)) >= cashbackAmount); \r\n        balances[msg.sender] += cashbackAmount;\r\n        usdcContract.transferFrom(msg.sender, address(this), _amount);\r\n        \r\n        if(extensionAddress != address(0)) {\r\n            StoreExtension(extensionAddress).processPayment(msg.sender, _tokenID, _amount);\r\n        }\r\n        emit Transfer(address(_store), msg.sender, cashbackAmount);\r\n    }\r\n    \r\n    function burn(StoreInterface _store, address _from, uint256 _tokenID, uint256 _amount) public {\r\n        (uint256 collateral, address extensionAddress) = _store.getExtensionCollateral(0);\r\n        require(isValidStore[address(_store)] == true);\r\n        require(collateral >= _amount);\r\n        require(balances[_from] >= _amount);\r\n        \r\n        if (_from != msg.sender && allowed[_from][msg.sender] < (2**256 - 1)) {\r\n            require(allowed[_from][msg.sender] >= _amount);\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        \r\n        _store.updateCollateral(_amount, 0);\r\n        balances[_from] -= _amount; \r\n        totalSupply -= _amount;\r\n        \r\n        if(extensionAddress != address(0)) {\r\n            StoreExtension(extensionAddress).processPayment(msg.sender, _tokenID, _amount);\r\n        }\r\n        emit Transfer(msg.sender, address(_store), _amount);\r\n    }\r\n}\r\n"
    }
  }
}