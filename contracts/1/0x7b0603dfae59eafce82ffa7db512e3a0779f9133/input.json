{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "balancerInterface.sol": {
      "content": "pragma solidity >=0.7.5;\npragma abicoder v2;\nimport './libraries/BytesLib.sol';\nimport './interfaces/IBPool.sol';\ncontract balancerInterface {\n    \n    // function uniswap (address tokenIn, address tokenOut, uint amountIn,bytes calldata data) public returns (uint amountOut) {\n    function swap (bytes calldata data) public  {\n        \n        //data:[address(20) pairAdd, ]\n        address tokenIn=BytesLib.toAddress(data,0);\n        address tokenOut=BytesLib.toAddress(data,20);\n        uint amountIn=BytesLib.toUint(data,40);\n        address pairAdd=BytesLib.toAddress(data,72);\n        //some tokens dont fllow erc20 standard!\n        tokenIn.call(abi.encodeWithSelector(0x095ea7b3, pairAdd, amountIn));\n        IBPool bpool= IBPool(pairAdd);\n        bpool.swapExactAmountIn(tokenIn,amountIn,tokenOut,0,0x1000000000000000000000);\n        \n    }\n}\n\n    // function swapExactAmountIn(\n    //     address tokenIn,\n    //     uint tokenAmountIn,\n    //     address tokenOut,\n    //     uint minAmountOut,\n    //     uint maxPrice\n    // ) external returns (uint tokenAmountOut, uint spotPriceAfter);"
    },
    "interfaces/IBPool.sol": {
      "content": "pragma solidity >=0.7.5;\npragma abicoder v2;\n\ninterface IBPool {\n\n    function isPublicSwap() external view returns (bool);\n    function isFinalized() external view returns (bool);\n    function isBound(address t) external view returns (bool);\n    function getNumTokens() external view returns (uint);\n    function getCurrentTokens() external view returns (address[] memory tokens);\n    function getFinalTokens() external view returns (address[] memory tokens);\n    function getDenormalizedWeight(address token) external view returns (uint);\n    function getTotalDenormalizedWeight() external view returns (uint);\n    function getNormalizedWeight(address token) external view returns (uint);\n    function getBalance(address token) external view returns (uint);\n    function getSwapFee() external view returns (uint);\n    function getController() external view returns (address);\n\n    function setSwapFee(uint swapFee) external;\n    function setController(address manager) external;\n    function setPublicSwap(bool public_) external;\n    function finalize() external;\n    function bind(address token, uint balance, uint denorm) external;\n    function rebind(address token, uint balance, uint denorm) external;\n    function unbind(address token) external;\n    function gulp(address token) external;\n\n    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint spotPrice);\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint spotPrice);\n\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;   \n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n\n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        uint minPoolAmountOut\n    ) external returns (uint poolAmountOut);\n\n    function joinswapPoolAmountOut(\n        address tokenIn,\n        uint poolAmountOut,\n        uint maxAmountIn\n    ) external returns (uint tokenAmountIn);\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint poolAmountIn,\n        uint minAmountOut\n    ) external returns (uint tokenAmountOut);\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPoolAmountIn\n    ) external returns (uint poolAmountIn);\n\n    function totalSupply() external view returns (uint);\n    function balanceOf(address whom) external view returns (uint);\n    function allowance(address src, address dst) external view returns (uint);\n\n    function approve(address dst, uint amt) external returns (bool);\n    function transfer(address dst, uint amt) external returns (bool);\n    function transferFrom(\n        address src, address dst, uint amt\n    ) external returns (bool);\n\n    function calcSpotPrice(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint swapFee\n    ) external pure returns (uint spotPrice);\n\n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    ) external pure returns (uint tokenAmountOut);\n\n    function calcInGivenOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountOut,\n        uint swapFee\n    ) external pure returns (uint tokenAmountIn);\n\n    function calcPoolOutGivenSingleIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountIn,\n        uint swapFee\n    ) external pure returns (uint poolAmountOut);\n\n    function calcSingleInGivenPoolOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountOut,\n        uint swapFee\n    ) external pure returns (uint tokenAmountIn);\n\n    function calcSingleOutGivenPoolIn(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint poolAmountIn,\n        uint swapFee\n    ) external pure returns (uint tokenAmountOut);\n\n    function calcPoolInGivenSingleOut(\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint poolSupply,\n        uint totalWeight,\n        uint tokenAmountOut,\n        uint swapFee\n    ) external pure returns (uint poolAmountIn);\n\n}"
    },
    "libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gon?alo SÃ¡ <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\nlibrary BytesLib {\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, 'slice_overflow');\r\n        require(_start + _length >= _start, 'slice_overflow');\r\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    //zero out the 32 bytes slice we are about to return\r\n                    //we need to do it because Solidity does not garbage collect\r\n                    mstore(tempBytes, 0)\r\n\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_start + 20 >= _start, 'toAddress_overflow');\r\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n    \r\n    function toUint(bytes memory bs, uint start)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(bs.length >= start + 32, \"slicing out of range\");\r\n        uint x;\r\n        assembly {\r\n            x := mload(add(bs, add(0x20, start)))\r\n        }\r\n        return x;\r\n    }\r\n\r\n\r\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\r\n        require(_start + 3 >= _start, 'toUint24_overflow');\r\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}"
    }
  }
}