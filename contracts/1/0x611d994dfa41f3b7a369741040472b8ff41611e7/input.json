{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1300000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}"
    },
    "contracts/SwapperContract.sol": {
      "content": "pragma solidity ^0.8.7;\r\n\r\nimport './AggregatorV3Interface.sol';\r\n\r\ncontract SwapperContract {\r\n  struct PackInfo {\r\n    uint price;\r\n    uint8 maxPerAddress;\r\n  }\r\n  \r\n  address owner;\r\n  AggregatorV3Interface internal priceFeed;\r\n  mapping (string => PackInfo) public packIdToInfo;\r\n  address withdrawalAddress;\r\n  mapping (address => mapping(string => uint8)) public buyers;\r\n  \r\n  event IncomingTransaction(string memo, string packId, uint value, uint priceInEther, uint8 packsAmount, uint8 userTotalPacks);\r\n  \r\n  constructor(address _withdrawalAddress, address _refAddress) public {\r\n    owner = msg.sender;\r\n    withdrawalAddress = _withdrawalAddress;\r\n    // Main - 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\r\n    // Kovan - 0x9326BFA02ADD2366b30bacB125260Af641031331\r\n    // Rinkeby - 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\r\n    priceFeed = AggregatorV3Interface(_refAddress);\r\n  }\r\n  \r\n  function buy(string calldata _memo, string calldata _packId, uint8 _packsAmount) public payable {\r\n    require(packIdToInfo[_packId].price > 0, \"Wrong pack id\");\r\n    require(\r\n      (_packsAmount <= packIdToInfo[_packId].maxPerAddress && _packsAmount > 0) && \r\n      buyers[msg.sender][_packId] + _packsAmount <= packIdToInfo[_packId].maxPerAddress, \r\n      \"Wrong packs amount\"\r\n    );\r\n    uint priceInEther = packPriceInEther(_packId);\r\n    require(msg.value >= (priceInEther - priceInEther / 100) * _packsAmount, \"Not enough value\");\r\n    \r\n    buyers[msg.sender][_packId] = buyers[msg.sender][_packId] > 0 ? buyers[msg.sender][_packId] + _packsAmount : _packsAmount;\r\n    emit IncomingTransaction(_memo, _packId, msg.value, priceInEther, _packsAmount, buyers[msg.sender][_packId]);\r\n  }\r\n  \r\n  function packPriceInEther(string calldata packId) public view returns(uint price) {\r\n    uint packPrice = packIdToInfo[packId].price;\r\n    (,int ethRate,,,) = priceFeed.latestRoundData();\r\n    price = packPrice * 1e18 / uint(ethRate) * 10**priceFeed.decimals();\r\n  }\r\n  \r\n  function addPack(string calldata _id, uint _price, uint8 _maxPerAddress) public onlyOwner {\r\n    packIdToInfo[_id] = PackInfo(_price, _maxPerAddress);\r\n  }\r\n  \r\n  function withdraw() public onlyOwner {\r\n    (bool sent,) = withdrawalAddress.call{value: address(this).balance}(\"\");\r\n    require(sent, \"Failed to send Ether\");\r\n  }\r\n  \r\n  modifier onlyOwner() {\r\n    require (owner == msg.sender, \"Caller is not owner\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n\r\n"
    }
  }
}