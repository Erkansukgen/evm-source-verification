{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MirrorAllocatedEditionsFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.10;\r\n\r\n/**\r\n * @title MirrorProxy\r\n * @author MirrorXYZ\r\n * The MirrorProxy contract is used to deploy minimal proxies.\r\n */\r\ncontract MirrorProxy {\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\r\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @notice Initializes a proxy by delegating logic to the implementation,\r\n     * and reverts if the call is not successful. Stores implementation logic.\r\n     * @param implementation - the implementation holds the logic for all proxies\r\n     * @param initializationData - initialization call\r\n     */\r\n    constructor(address implementation, bytes memory initializationData) {\r\n        // Delegatecall into the implementation, supplying initialization calldata.\r\n        (bool ok, ) = implementation.delegatecall(initializationData);\r\n\r\n        // Revert and include revert data if delegatecall to implementation reverts.\r\n        if (!ok) {\r\n            assembly {\r\n                returndatacopy(0, 0, returndatasize())\r\n                revert(0, returndatasize())\r\n            }\r\n        }\r\n\r\n        assembly {\r\n            sstore(_IMPLEMENTATION_SLOT, implementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice When any function is called on this contract, we delegate to\r\n     * the logic contract stored in the implementation storage slot.\r\n     */\r\n    fallback() external payable {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(\r\n                gas(),\r\n                sload(_IMPLEMENTATION_SLOT),\r\n                ptr,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 {\r\n                revert(ptr, size)\r\n            }\r\n            default {\r\n                return(ptr, size)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IOwnableEvents {\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n}\r\n\r\ninterface IMirrorAllocatedEditionsFactory {\r\n    function deploy(\r\n        IMirrorAllocatedEditionsLogic.NFTMetadata memory metadata,\r\n        address operator_,\r\n        address payable fundingRecipient_,\r\n        address payable royaltyRecipient_,\r\n        uint256 royaltyPercentage_,\r\n        uint256 price,\r\n        bool list,\r\n        bool open,\r\n        uint256 feePercentage\r\n    ) external returns (address proxy);\r\n}\r\n\r\ninterface IMirrorAllocatedEditionsFactoryEvents {\r\n    event EditionsProxyDeployed(address proxy, address operator, address logic);\r\n}\r\n\r\ninterface IMirrorAllocatedEditionsLogic {\r\n    event RoyaltyChange(\r\n        address indexed oldRoyaltyRecipient,\r\n        uint256 oldRoyaltyPercentage,\r\n        address indexed newRoyaltyRecipient,\r\n        uint256 newRoyaltyPercentage\r\n    );\r\n\r\n    struct NFTMetadata {\r\n        string name;\r\n        string symbol;\r\n        string baseURI;\r\n        bytes32 contentHash;\r\n        uint256 quantity;\r\n    }\r\n\r\n    function initialize(\r\n        NFTMetadata memory metadata,\r\n        address operator_,\r\n        address payable fundingRecipient_,\r\n        address payable royaltyRecipient_,\r\n        uint256 royaltyPercentage_,\r\n        uint256 price,\r\n        bool list,\r\n        bool open,\r\n        uint256 feePercentage\r\n    ) external;\r\n\r\n    function setRoyaltyInfo(\r\n        address payable royaltyRecipient_,\r\n        uint256 royaltyPercentage_\r\n    ) external;\r\n}\r\n\r\ninterface IMirrorOpenSaleV0Events {\r\n    event RegisteredSale(\r\n        bytes32 h,\r\n        address indexed token,\r\n        uint256 startTokenId,\r\n        uint256 endTokenId,\r\n        address indexed operator,\r\n        address indexed recipient,\r\n        uint256 price,\r\n        bool open,\r\n        uint256 feePercentage\r\n    );\r\n\r\n    event Purchase(\r\n        bytes32 h,\r\n        address indexed token,\r\n        uint256 tokenId,\r\n        address indexed buyer,\r\n        address indexed recipient\r\n    );\r\n\r\n    event Withdraw(\r\n        bytes32 h,\r\n        uint256 amount,\r\n        uint256 fee,\r\n        address indexed recipient\r\n    );\r\n\r\n    event OpenSale(bytes32 h);\r\n\r\n    event CloseSale(bytes32 h);\r\n}\r\n\r\ninterface IERC2309 {\r\n    event ConsecutiveTransfer(\r\n        uint256 indexed fromTokenId,\r\n        uint256 toTokenId,\r\n        address indexed fromAddress,\r\n        address indexed toAddress\r\n    );\r\n}\r\n\r\ninterface IERC721Events {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n}\r\n\r\n/**\r\n * @title MirrorAllocatedEditionsFactory\r\n * @author MirrorXYZ\r\n * The MirrorAllocatedEditionsFactory contract is used to deploy edition proxies.\r\n */\r\ncontract MirrorAllocatedEditionsFactory is\r\n    IMirrorAllocatedEditionsFactory,\r\n    IMirrorAllocatedEditionsFactoryEvents,\r\n    IMirrorOpenSaleV0Events,\r\n    IERC2309,\r\n    IOwnableEvents,\r\n    IERC721Events\r\n{\r\n    /// @notice Address that holds the tributary registry for Mirror treasury\r\n    address public immutable tributaryRegistry;\r\n\r\n    /// @notice Address that holds the logic for editions\r\n    address public logic;\r\n\r\n    constructor(address tributaryRegistry_, address logic_) {\r\n        tributaryRegistry = tributaryRegistry_;\r\n        logic = logic_;\r\n    }\r\n\r\n    // ======== Deploy function =========\r\n\r\n    /// @notice Deploy an editions proxy\r\n    function deploy(\r\n        IMirrorAllocatedEditionsLogic.NFTMetadata memory metadata,\r\n        address operator_,\r\n        address payable fundingRecipient_,\r\n        address payable royaltyRecipient_,\r\n        uint256 royaltyPercentage_,\r\n        uint256 price,\r\n        bool list,\r\n        bool open,\r\n        uint256 feePercentage\r\n    ) external override returns (address proxy) {\r\n        bytes memory initializationData = abi.encodeWithSelector(\r\n            IMirrorAllocatedEditionsLogic.initialize.selector,\r\n            metadata,\r\n            operator_,\r\n            fundingRecipient_,\r\n            royaltyRecipient_,\r\n            royaltyPercentage_,\r\n            price,\r\n            list,\r\n            open,\r\n            feePercentage\r\n        );\r\n\r\n        proxy = address(\r\n            new MirrorProxy{\r\n                salt: keccak256(\r\n                    abi.encode(\r\n                        operator_,\r\n                        metadata.name,\r\n                        metadata.symbol,\r\n                        metadata.baseURI\r\n                    )\r\n                )\r\n            }(logic, initializationData)\r\n        );\r\n\r\n        emit EditionsProxyDeployed(proxy, operator_, logic);\r\n    }\r\n}"
    }
  }
}