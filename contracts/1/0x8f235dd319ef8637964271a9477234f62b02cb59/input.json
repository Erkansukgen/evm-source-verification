{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AutoLineJob.sol": {
      "content": "// hevm: flattened sources of src/AutoLineJob.sol\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity =0.8.9 >=0.8.0;\r\n\r\n////// src/interfaces/IJob.sol\r\n// Copyright (C) 2021 Dai Foundation\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n/* pragma solidity >=0.8.0; */\r\n\r\n/// @title Maker Keeper Network Job\r\n/// @notice A job represents an independant unit of work that can be done by a keeper\r\ninterface IJob {\r\n\r\n    /// @notice Executes this unit of work\r\n    /// @dev Should revert iff workable() returns canWork of false\r\n    /// @param network The name of the external keeper network\r\n    /// @param args Custom arguments supplied to the job, should be copied from workable response\r\n    function work(bytes32 network, bytes calldata args) external;\r\n\r\n    /// @notice Ask this job if it has a unit of work available\r\n    /// @dev This should never revert, only return false if nothing is available\r\n    /// @dev This should normally be a view, but sometimes that's not possible\r\n    /// @param network The name of the external keeper network\r\n    /// @return canWork Returns true if a unit of work is available\r\n    /// @return args The custom arguments to be provided to work() or an error string if canWork is false\r\n    function workable(bytes32 network) external returns (bool canWork, bytes memory args);\r\n\r\n}\r\n\r\n////// src/AutoLineJob.sol\r\n// Copyright (C) 2021 Dai Foundation\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n/* pragma solidity 0.8.9; */\r\n\r\n/* import {IJob} from \"./interfaces/IJob.sol\"; */\r\n\r\ninterface SequencerLike_2 {\r\n    function isMaster(bytes32 network) external view returns (bool);\r\n}\r\n\r\ninterface IlkRegistryLike_1 {\r\n    function list() external view returns (bytes32[] memory);\r\n}\r\n\r\ninterface AutoLineLike_1 {\r\n    function vat() external view returns (address);\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint48, uint48, uint48);\r\n    function exec(bytes32) external returns (uint256);\r\n}\r\n\r\ninterface VatLike_2 {\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\r\n}\r\n\r\n/// @title Trigger autoline updates based on thresholds\r\ncontract AutoLineJob is IJob {\r\n\r\n    uint256 constant internal BPS = 10 ** 4;\r\n    \r\n    SequencerLike_2 public immutable sequencer;\r\n    IlkRegistryLike_1 public immutable ilkRegistry;\r\n    AutoLineLike_1 public immutable autoline;\r\n    VatLike_2 public immutable vat;\r\n    uint256 public immutable thi;                       // % above the previously exec'ed debt level\r\n    uint256 public immutable tlo;                       // % below the previously exec'ed debt level\r\n\r\n    // --- Errors ---\r\n    error NotMaster(bytes32 network);\r\n    error OutsideThreshold(uint256 line, uint256 nextLine);\r\n\r\n    constructor(address _sequencer, address _ilkRegistry, address _autoline, uint256 _thi, uint256 _tlo) {\r\n        sequencer = SequencerLike_2(_sequencer);\r\n        ilkRegistry = IlkRegistryLike_1(_ilkRegistry);\r\n        autoline = AutoLineLike_1(_autoline);\r\n        vat = VatLike_2(autoline.vat());\r\n        thi = _thi;\r\n        tlo = _tlo;\r\n    }\r\n\r\n    function work(bytes32 network, bytes calldata args) external override {\r\n        if (!sequencer.isMaster(network)) revert NotMaster(network);\r\n        \r\n        bytes32 ilk = abi.decode(args, (bytes32));\r\n\r\n        (,,, uint256 line,) = vat.ilks(ilk);\r\n        uint256 nextLine = autoline.exec(ilk);\r\n\r\n        // Execution is not enough\r\n        // We need to be over the threshold amounts\r\n        (uint256 maxLine, uint256 gap,,,) = autoline.ilks(ilk);\r\n        if (\r\n            nextLine != maxLine &&\r\n            nextLine < line + gap * thi / BPS &&\r\n            nextLine + gap * tlo / BPS > line\r\n        ) revert OutsideThreshold(line, nextLine);\r\n    }\r\n\r\n    function workable(bytes32 network) external view override returns (bool, bytes memory) {\r\n        if (!sequencer.isMaster(network)) return (false, bytes(\"Network is not master\"));\r\n        \r\n        bytes32[] memory ilks = ilkRegistry.list();\r\n        for (uint256 i = 0; i < ilks.length; i++) {\r\n            bytes32 ilk = ilks[i];\r\n\r\n            (uint256 Art, uint256 rate,, uint256 line,) = vat.ilks(ilk);\r\n            uint256 debt = Art * rate;\r\n            (uint256 maxLine, uint256 gap, uint48 ttl, uint48 last, uint48 lastInc) = autoline.ilks(ilk);\r\n            uint256 nextLine = debt + gap;\r\n            if (nextLine > maxLine) nextLine = maxLine;\r\n\r\n            // Check autoline rules\r\n            if (maxLine == 0) continue;                     // Ilk is not enabled\r\n            if (last == block.number) continue;             // Already triggered this block\r\n            if (line == nextLine ||                         // No change in line\r\n                nextLine > line &&                          // Increase in line\r\n                block.timestamp < lastInc + ttl) continue;  // TTL hasn't expired\r\n\r\n            // Check if current debt level is inside our do-nothing range\r\n            // Re-arranged to remove any subtraction (and thus underflow)\r\n            // Exception if we are at the maxLine\r\n            if (\r\n                nextLine != maxLine &&\r\n                nextLine < line + gap * thi / BPS &&\r\n                nextLine + gap * tlo / BPS > line\r\n            ) continue;\r\n\r\n            // Good to adjust!\r\n            return (true, abi.encode(ilk));\r\n        }\r\n\r\n        return (false, bytes(\"No ilks ready\"));\r\n    }\r\n\r\n}"
    }
  }
}