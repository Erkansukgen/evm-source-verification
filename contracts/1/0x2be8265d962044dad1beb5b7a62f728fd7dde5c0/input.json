{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/ANV_NFT_AUCTION_ADVANCED.sol":{"content":"\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\npragma solidity ^0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\npragma solidity ^0.8.0;\n\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n\npragma solidity ^0.8.0;\n\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address payable newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n\npragma solidity ^0.8.0;\n\ncontract AuctionRepository {\n    \n    // Array with all auctions\n    Auction[] public auctions;\n\n    // Mapping from auction index to user bids\n    mapping(uint256 => Bid[]) public auctionBids;\n\n    // Mapping from owner to a list of owned auctions\n    mapping(address => uint[]) public auctionOwner;\n\n    // Bid struct to hold bidder and amount\n    struct Bid {\n        address from;\n        uint256 amount;\n    }\n\n    // Auction struct which holds all the required info\n    struct Auction {\n        uint256 startPrice;\n        address nftContract;\n        uint256 tokenId;\n        address owner;\n        bool active;\n        bool finalized;\n    }\n\n    IERC20 public erc20Token;\n    \n    mapping (address => mapping (uint256 => uint)) public auctionIdByTokenIdMap;\n\n    constructor ( IERC20 _erc20Token) public {\n        erc20Token = _erc20Token;\n    }\n    /**\n    * @dev Guarantees msg.sender is owner of the given auction\n    * @param _auctionId uint ID of the auction to validate its ownership belongs to msg.sender\n    */\n    modifier isOwner(uint _auctionId) {\n        require(auctions[_auctionId].owner == msg.sender);\n        _;\n    }\n\n\n    // /**\n    // * @dev Disallow payments to this contract directly\n    // */\n    // function() public{\n    //     revert();\n    // }\n\n    /**\n    * @dev Gets the length of auctions\n    * @return uint representing the auction count\n    */\n    function getCount() public view returns(uint) {\n        return auctions.length;\n    }\n\n    /**\n    * @dev Gets the bid counts of a given auction\n    * @param _auctionId uint ID of the auction\n    */\n    function getBidsCount(uint _auctionId) public view returns(uint) {\n        return auctionBids[_auctionId].length;\n    }\n\n    /**\n    * @dev Gets an array of owned auctions\n    * @param _owner address of the auction owner\n    */\n    function getAuctionsOf(address _owner) public view returns( uint[] memory) {\n        uint[] memory ownedAuctions = auctionOwner[_owner];\n        return ownedAuctions;\n    }\n\n    /**\n    * @dev Gets an array of owned auctions\n    * @param _auctionId uint of the auction owner\n    * @return amount uint256, address of last bidder\n    */\n    function getCurrentBid(uint _auctionId) public view returns(uint256) {\n        uint bidsLength = auctionBids[_auctionId].length;\n        // if there are bids refund the last bid\n        if( bidsLength > 0 ) {\n            Bid memory lastBid = auctionBids[_auctionId][bidsLength - 1];\n            return (lastBid.amount);\n        }\n        return 0;\n    }\n\n    /**\n    * @dev Gets the total number of auctions owned by an address\n    * @param _owner address of the owner\n    * @return uint total number of auctions\n    */\n    function getAuctionsCountOfOwner(address _owner) public view returns(uint) {\n        return auctionOwner[_owner].length;\n    }\n\n\n    function getAuctionIdByTokenId(address nftContract, uint256 _tokenId) public view returns(uint) {\n        return auctionIdByTokenIdMap[nftContract][_tokenId];\n    }\n    \n   \n    function getAuctionById(uint _auctionId) public view returns(\n        uint256 startPrice,\n        address nftContract,\n        uint256 tokenId,\n        address owner,\n        bool active,\n        bool finalized) {\n\n        Auction memory auc = auctions[_auctionId];\n        return (\n            auc.startPrice, \n            auc.nftContract, \n            auc.tokenId, \n            auc.owner, \n            auc.active, \n            auc.finalized);\n    }\n    \n\n    function createAuction(address _nftContract, uint256 _tokenId , uint256 _startPrice) public  {\n        uint auctionId = auctions.length;\n        Auction memory newAuction;\n        newAuction.startPrice = _startPrice;\n        newAuction.nftContract = _nftContract;\n        newAuction.tokenId = _tokenId;\n        newAuction.owner = msg.sender;\n        newAuction.active = true;\n        newAuction.finalized = false;\n        \n        auctions.push(newAuction);        \n        auctionOwner[msg.sender].push(auctionId);\n        \n        auctionIdByTokenIdMap[_nftContract][_tokenId] = auctionId;\n        \n        emit AuctionCreated(msg.sender, auctionId);\n   \n    }\n\n\n    /**\n    * @dev Cancels an ongoing auction by the owner\n    * @dev Deed is transfered back to the auction owner\n    * @dev Bidder is refunded with the initial amount\n    * @param _auctionId uint ID of the created auction\n    */\n    function cancelAuction(uint _auctionId) internal {\n        Auction memory myAuction = auctions[_auctionId];\n        uint bidsLength = auctionBids[_auctionId].length;\n\n        // if there are bids refund the last bid\n        if( bidsLength > 0 ) {\n            Bid memory lastBid = auctionBids[_auctionId][bidsLength - 1];\n\n            require(\n                IERC20(erc20Token).transfer(lastBid.from, lastBid.amount),\n                \"Refund token transfer error.\"\n            );\n        }\n\n        // approve and transfer from this contract to auction owner\n        // IERC721(erc721Token).safeTransferFrom(myAuction.owner , lastBid.from , myAuction.tokenId);\n        \n        auctions[_auctionId].active = false;\n        emit AuctionCanceled(msg.sender, _auctionId);\n    }\n\n    /**\n    * @dev Finalized an ended auction\n    * @dev The auction should be ended, and there should be at least one bid\n    * @dev On success Deed is transfered to bidder and auction owner gets the amount\n    * @param _auctionId uint ID of the created auction\n    */\n    function finalizeAuction(uint _auctionId) public {\n        Auction memory myAuction = auctions[_auctionId];\n        uint bidsLength = auctionBids[_auctionId].length;\n\n        // if there are no bids cancel\n        if(bidsLength == 0) {\n            cancelAuction(_auctionId);\n        } else {\n\n            // 2. the money goes to the auction owner\n            Bid memory lastBid = auctionBids[_auctionId][bidsLength - 1];\n\n            require(\n                IERC20(erc20Token).transfer(myAuction.owner, lastBid.amount),\n                \"Refund token transfer error.\"\n            );\n        \n\n            // approve and transfer from this contract to the bid winner \n            IERC721(myAuction.nftContract).safeTransferFrom(myAuction.owner , lastBid.from , myAuction.tokenId);\n            \n            auctions[_auctionId].active = false;\n            auctions[_auctionId].finalized = true;\n            emit AuctionFinalized(msg.sender, _auctionId);\n        }\n    }\n\n    /**\n    * @dev Bidder sends bid on an auction\n    * @dev Auction should be active and not ended\n    * @dev Refund previous bidder if a new bid is valid and placed.\n    * @param _auctionId uint ID of the created auction\n    */\n    function bidOnAuction(uint _auctionId , uint256 anvAmount) public payable {\n        uint256 ethAmountSent = msg.value;\n\n        // owner can't bid on their auctions\n        Auction memory myAuction = auctions[_auctionId];\n        require(myAuction.owner != msg.sender , \"Owner can not bid on their auctions\");\n\n        // get bid length\n        uint bidsLength = auctionBids[_auctionId].length;\n        // \n        uint256 lastStartPrice = myAuction.startPrice;\n        Bid memory lastBid;\n\n        // there are previous bids\n        if( bidsLength > 0 ) {\n            lastBid = auctionBids[_auctionId][bidsLength - 1];\n            lastStartPrice = lastBid.amount;\n        }\n\n        // check if amount is greater than previous amount  \n        require (erc20Token.balanceOf(msg.sender) > anvAmount , \"Lack of balance ERC20\");\n        \n        require (anvAmount > lastStartPrice , \"Lack of balance with lastBidAmount\");\n\n        // refund the last bidder\n        if( bidsLength > 0 ) {\n            require(\n                IERC20(erc20Token).transfer(lastBid.from, lastBid.amount),\n                \"Refund token transfer error.\"\n            );\n        }\n\n        // insert bid\n         require(\n                IERC20(erc20Token).transferFrom(msg.sender, address(this), anvAmount),\n                \"Refund token transfer error.\"\n            );\n        \n        \n        Bid memory newBid;\n        newBid.from = msg.sender;\n        newBid.amount = anvAmount;\n        auctionBids[_auctionId].push(newBid);\n        emit BidSuccess(msg.sender, _auctionId);\n    }\n\n    event BidSuccess(address _from, uint _auctionId);\n\n    // AuctionCreated is fired when an auction is created\n    event AuctionCreated(address _owner, uint _auctionId);\n\n    // AuctionCanceled is fired when an auction is canceled\n    event AuctionCanceled(address _owner, uint _auctionId);\n\n    // AuctionFinalized is fired when an auction is finalized\n    event AuctionFinalized(address _owner, uint _auctionId);\n}"}}}