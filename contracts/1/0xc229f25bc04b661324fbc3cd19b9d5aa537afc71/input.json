{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Untitled.sol": {
      "content": "pragma solidity ^0.6.1;\n\ninterface MinereumContract {\n  function transfer(address _to, uint256 _value) external;\n}\n\ninterface External1 {\n  function mintNewCoins(uint256 _amount) external;\n  function setStakingOwner() external;\n}\n\ninterface Genesis {\n\tfunction balanceOf ( address _address ) external view returns ( uint256 balance );\n\tfunction isAnyGenesisAddress ( address _address ) external view returns ( bool success );\n\tfunction isGenesisAddressLevel1 ( address _address ) external view returns ( bool success );\n\tfunction isGenesisAddressLevel2 ( address _address ) external view returns ( bool success );\n\tfunction isGenesisAddressLevel3 ( address _address ) external view returns ( bool success );\n}\n\ninterface PublicCalls {\n\tfunction stakeBalances ( address ) external view returns ( uint256 );\n}\n\ncontract MinereumStaking\n{\n\t\nuint256[] public mnePerDay;\nuint256[] public maxInterestRate;\n\naddress[] public participatedAddress;\naddress[] public bonusAddress;\naddress[] public AllowPayoutToOtherAddress;\n\nmapping (address => uint256[]) public daysParticipated;\nmapping (address => uint256[]) public mneSentPerDay;\nmapping (address => uint256[]) public Bonus;\nmapping (address => uint256[]) public BonusDay;\nmapping (address => address[]) public BonusFrom;\nmapping (address => uint256[]) public BonusAmount;\nmapping (address => uint256) public AddressBonus;\nmapping (address => bool[]) public StakingPaid;\nmapping (address => bool) public BonusPaid;\nmapping (address => bool) public AllowOtherStakingPayoutAddress;\nuint256 public startDate = 1590334259;\nuint256 public overallMNEStaking = 0;\nuint256 public overallBonus = 0;\nuint256 public referralRate = 15;\nuint256 public referrerRateNormal = 30;\nuint256 public referrerRateLevel2 = 40;\nuint256 public referrerRateLevel3 = 50;\nuint256 public referrerRateShare = 60;\nuint256 public newStakingCoins;\nuint256 public newBonusCoins;\nuint256 public paidStakingCoins;\nMinereumContract public mneContract;\nExternal1 public external1;\nGenesis public gn;\nPublicCalls public pc;\naddress public updaterAddress = 0x0000000000000000000000000000000000000000;\nbool public blockPayouts = false;\nbool public blockStaking = false;\n\nconstructor() public\n{\n\tsetUpdater();\n\tmneContract = MinereumContract(0x426CA1eA2406c07d75Db9585F22781c096e3d0E0);\n\t//external1 = External1(0x0000000000000000000000000000000000000000);\n\t//external1.setStakingOwner();\n\tgn = Genesis(0xa6be27538A28114Fe03EB7ADE9AdfE53164f2a4c);\n\tpc = PublicCalls(0x90E340e2d11E6Eb1D99E34D122D6fE0fEF3213fd);\n}\n\nfunction updateStartDate(uint _startDate) public\n{\n\tif (msg.sender == updaterAddress)\n\t{\n\t\tstartDate = _startDate;\t\t\n\t}\n\telse\n\t{\n\t\trevert();\n\t}\n}\n\nfunction updateVars(bool _blockPayouts, bool _blockStaking, uint256 _referralRate, uint256 _referrerRateNormal, uint256 _referrerRateLevel2, uint256 _referrerRateLevel3, uint256 _referrerRateShare) public\n{\n\tif (msg.sender == updaterAddress)\n\t{\n\t\tblockPayouts = _blockPayouts;\n\t\tblockStaking = _blockStaking;\n\t\treferralRate = _referralRate;\n\t\treferrerRateNormal = _referrerRateNormal;\n\t\treferrerRateLevel2 = _referrerRateLevel2;\n\t\treferrerRateLevel3 = _referrerRateLevel3;\n\t\treferrerRateShare = _referrerRateShare;\n\t}\n\telse\n\t{\n\t\trevert();\n\t}\n}\nfunction setUpdater() public {if (updaterAddress == 0x0000000000000000000000000000000000000000) updaterAddress = msg.sender; else revert();}\nfunction updateExternal1(address _address) public {if (tx.origin == updaterAddress) {external1 = External1(_address); external1.setStakingOwner(); } else revert();}\nfunction updateGenesis(address _address) public {if (tx.origin == updaterAddress) {gn = Genesis(_address); } else revert();}\nfunction updatePublicCalls(address _address) public {if (tx.origin == updaterAddress) {pc = PublicCalls(_address); } else revert();}\nfunction updateMneContract(address _address) public {if (tx.origin == updaterAddress) {mneContract = MinereumContract(_address); } else revert();}\n\nfunction daysParticipatedGet(address _address) public view returns (uint256[] memory) { return daysParticipated[_address]; }\nfunction mneSentPerDayGet(address _address) public view returns (uint256[] memory) { return mneSentPerDay[_address]; }\nfunction BonusGet(address _address) public view returns (uint256[] memory) { return Bonus[_address]; }\nfunction BonusDayGet(address _address) public view returns (uint256[] memory) { return BonusDay[_address]; }\nfunction BonusFromGet(address _address) public view returns (address[] memory) { return BonusFrom[_address]; }\nfunction BonusAmountGet(address _address) public view returns (uint256[] memory) { return BonusAmount[_address]; }\nfunction AddressBonusGet(address _address) public view returns (uint256) { return AddressBonus[_address]; }\nfunction StakingPaidGet(address _address) public view returns (bool[] memory) { return StakingPaid[_address]; }\nfunction BonusPaidGet(address _address) public view returns (bool) { return BonusPaid[_address]; }\n\nfunction daysParticipatedGetAt(address _address, uint i) public view returns (uint256) { return daysParticipated[_address][i]; }\nfunction mneSentPerDayGetAt(address _address, uint i) public view returns (uint256) { return mneSentPerDay[_address][i]; }\nfunction BonusGetAt(address _address, uint i) public view returns (uint256) { return Bonus[_address][i]; }\nfunction BonusDayGetAt(address _address, uint i) public view returns (uint256) { return BonusDay[_address][i]; }\nfunction BonusFromGetAt(address _address, uint i) public view returns (address) { return BonusFrom[_address][i]; }\nfunction BonusAmountGetAt(address _address, uint i) public view returns (uint256) { return BonusAmount[_address][i]; }\nfunction StakingPaidGetAt(address _address, uint i) public view returns (bool) { return StakingPaid[_address][i]; }\n\nfunction daysParticipatedLength(address _address) public view returns (uint256) { return daysParticipated[_address].length; }\nfunction mneSentPerDayLength(address _address) public view returns (uint256) { return mneSentPerDay[_address].length; }\nfunction BonusLength(address _address) public view returns (uint256) { return Bonus[_address].length; }\nfunction BonusDayLength(address _address) public view returns (uint256) { return BonusDay[_address].length; }\nfunction BonusFromLength(address _address) public view returns (uint256) { return BonusFrom[_address].length; }\nfunction BonusAmountLength(address _address) public view returns (uint256) { return BonusAmount[_address].length; }\nfunction StakingPaidLength(address _address) public view returns (uint256) { return StakingPaid[_address].length; }\nfunction mnePerDayLength() public view returns (uint256) { return mnePerDay.length; }\nfunction maxInterestRateLength() public view returns (uint256) { return maxInterestRate.length; }\nfunction participatedAddressLength() public view returns (uint256) { return participatedAddress.length; }\nfunction bonusAddressLength() public view returns (uint256) { return bonusAddress.length; }\n\nfunction GetCurrentDay() public view returns (uint256)\n{\n\treturn (block.timestamp - startDate) / 86400;\n}\n\nfunction FillMaxInterestRate() public\n{\n\tif (maxInterestRate.length > 0) revert();\n\tuint i = 1;\n\tuint init = 1000;\n\tmaxInterestRate.push(init);\n\twhile (i < 365)\n\t{\n\t\tmaxInterestRate.push(maxInterestRate[i-1] * 99 / 100);\n\t\ti++;\n\t}\n}\n\nfunction AllowStakingPayoutToOtherAddress(bool value) public\n{\n\tAllowPayoutToOtherAddress.push(msg.sender);\n\tAllowOtherStakingPayoutAddress[msg.sender] = value;\t\n}\n\nfunction TransferAllFundsOut(address _address) public\n{\t\t\n\tif (msg.sender == updaterAddress)\n\t{\n\t\tmneContract.transfer(_address, gn.balanceOf(address(this))); //in case of migration to another contract\t\n\t}\n\telse\n\t{\n\t\trevert();\n\t}\n}\n\t\nfunction startStaking(address _sender, uint256 _amountToStake, address[] memory _addressList, uint256[] memory uintList) public {\n\tif (blockStaking) revert('not active'); //in case of migration to another contract\n\t\n\tif (msg.sender != address(mneContract)) revert();\n\t\n\tif (_sender == _addressList[0]) revert('invalid referal');\n\t\n\tif (startDate > block.timestamp) revert('invalid time');\n\t\n\tuint currentPeriod = (block.timestamp - startDate) / 86400;\n\t\n\tif (currentPeriod > 364) revert('invalid period');\n\t\n\tif (mnePerDay.length < currentPeriod + 1)\n\t{\n\t\twhile (mnePerDay.length < currentPeriod + 1)\n\t\t\tmnePerDay.push(0);\n\t}\n\tmnePerDay[currentPeriod] += _amountToStake;\n\t\n\tif (daysParticipated[_sender].length > 0)\n\t{\n\t    if (daysParticipated[_sender][daysParticipated[_sender].length -1] == currentPeriod)\n\t    {\n\t        mneSentPerDay[_sender][daysParticipated[_sender].length -1] += _amountToStake;\n\t    }\n\t    else\n\t    {\n\t        daysParticipated[_sender].push(currentPeriod);\n    \t    mneSentPerDay[_sender].push(_amountToStake);\n    \t    StakingPaid[_sender].push(false);       \n\t    }\n\t}\n\telse\n\t{\n\t    participatedAddress.push(_sender);\n\t    daysParticipated[_sender].push(currentPeriod);\n\t    mneSentPerDay[_sender].push(_amountToStake);\n\t    StakingPaid[_sender].push(false);   \n\t}\n\t\n\toverallMNEStaking += _amountToStake;\n\t\n\tif (_addressList.length > 0)\n\t{\n\t\tuint bonusAmountReferral = _amountToStake * referralRate / 100;\t\n\n\t\tuint referrerRateFinal;\n\t\t\n\t\tif (pc.stakeBalances(_addressList[0]) > 0)\n\t\t\treferrerRateFinal = referrerRateShare;\n\t\telse if (!gn.isAnyGenesisAddress(_addressList[0]))\n\t\t\treferrerRateFinal = referrerRateNormal;\n\t\telse if (gn.isGenesisAddressLevel1(_addressList[0]))\t\t\n\t\t\treferrerRateFinal = referrerRateNormal;\n\t\telse if (gn.isGenesisAddressLevel2(_addressList[0]))\t\t\n\t\t\treferrerRateFinal = referrerRateLevel2;\n\t\telse if (gn.isGenesisAddressLevel3(_addressList[0]))\t\t\n\t\t\treferrerRateFinal = referrerRateLevel3;\n\t\t\n\t\tuint bonusAmountReferrer = _amountToStake * referrerRateFinal / 100;\n\t\t\n\t\tBonusDay[_sender].push(currentPeriod);\n\t\tBonusFrom[_sender].push(_addressList[0]);\n\t\tBonusAmount[_sender].push(bonusAmountReferral);\n\t\tBonusPaid[_sender] = false;\n\t\t\n\t\tif (AddressBonus[_sender] == 0)\n\t\t\tbonusAddress.push(_sender);\n\t\t\n\t\tAddressBonus[_sender] += bonusAmountReferral;\n\t\t\n\t\tBonusDay[_addressList[0]].push(currentPeriod);\n\t\tBonusFrom[_addressList[0]].push(_sender);\n\t\tBonusAmount[_addressList[0]].push(bonusAmountReferrer);\n\t\tBonusPaid[_addressList[0]] = false;\n\t\t\n\t\tif (AddressBonus[_addressList[0]] == 0)\n\t\t\tbonusAddress.push(_addressList[0]);\n\t\n\t\tAddressBonus[_addressList[0]] += bonusAmountReferrer;\n\t\t\n\t\toverallBonus += bonusAmountReferral + bonusAmountReferrer;\n\t}\t\n}\n\nfunction PayoutStaking(uint i, address _address) public {\n\tif (blockPayouts) revert('payouts blocked'); //in case of migration to another contract\n\t\n\tif (daysParticipated[msg.sender].length == 0) revert('No Staking');\n\t\n\tif (block.timestamp >= startDate + (daysParticipated[msg.sender][0] * 86400) + 31556926)\n\t{\n\t\tif (StakingPaid[msg.sender][i]) revert('Stake already paid');\n\t\t\n\t\tuint interestRateToPay = mneSentPerDay[msg.sender][i] * maxInterestRate[daysParticipated[msg.sender][i]] * 1000000000000000 / mnePerDay[daysParticipated[msg.sender][i]];\n\t\tuint coinsToMint = mneSentPerDay[msg.sender][i] * interestRateToPay / 1000000000000000 / 100;\n\t\tuint amountToPay = mneSentPerDay[msg.sender][i] + coinsToMint;\n\t\t\n\t\texternal1.mintNewCoins(coinsToMint);\n\t\t\n\t\tif (_address != 0x0000000000000000000000000000000000000000 && AllowOtherStakingPayoutAddress[msg.sender])\t\t\t\n\t\t\tmneContract.transfer(_address, amountToPay);\n\t\telse\n\t\t\tmneContract.transfer(msg.sender, amountToPay);\n\t\t\n\t\tnewStakingCoins += coinsToMint;\n\t\tpaidStakingCoins += amountToPay;\n\t\tStakingPaid[msg.sender][i] = true;\n\t}\n\telse\n\t{\n\t\trevert('Payout Date Not Valid');\n\t}\n}\n\nfunction AmountToPayStaking(address _address, bool _checkID, uint i) public view returns (uint256)\n{\n\tif (_checkID)\n\t{\n\t\tuint interestRateToPay = mneSentPerDay[_address][i] * maxInterestRate[daysParticipated[_address][i]] * 1000000000000000 / mnePerDay[daysParticipated[_address][i]];\n\t\tuint coinsToMint = mneSentPerDay[_address][i] * interestRateToPay / 1000000000000000 / 100;\n\t\tuint amountToPay = mneSentPerDay[_address][i] + coinsToMint;\n\t\treturn amountToPay;\n\t}\n\telse\n\t{\n\t\tuint j = 0;\n\t\tuint finalAmount = 0;\n\t\twhile (j < mneSentPerDay[_address].length)\n\t\t{\n\t\t\tif (!StakingPaid[_address][j])\n\t\t\t{\n\t\t\t\tuint interestRateToPay = mneSentPerDay[_address][j] * maxInterestRate[daysParticipated[_address][j]] * 1000000000000000 / mnePerDay[daysParticipated[_address][j]];\n\t\t\t\tuint coinsToMint = mneSentPerDay[_address][j] * interestRateToPay / 1000000000000000 / 100;\n\t\t\t\tuint amountToPay = mneSentPerDay[_address][j] + coinsToMint;\n\t\t\t\tfinalAmount += amountToPay;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\treturn finalAmount;\n\t}\t\n}\n\nfunction AmountToPayBonus(address _address) public view returns (uint256)\n{\n\tif (BonusPaid[_address])\n\t\treturn 0;\n\telse\n\t\treturn AddressBonus[_address];\n}\n\nfunction DateStakingPayoutPossible(address _address) public view returns (uint256)\n{\n\tif (daysParticipated[_address].length == 0)\n\t\treturn 0;\n\telse\n\t\treturn startDate + (daysParticipated[_address][0] * 86400) + 31556926;\n}\n\nfunction DateBonusPayoutPossible(address _address) public view returns (uint256)\n{\n\tif (BonusDay[_address].length == 0)\n\t\treturn 0;\n\telse\n\t\treturn startDate + (BonusDay[_address][0] * 86400) + 31556926;\n}\n\nfunction PayoutBonus(address _address) public {\n\tif (blockPayouts) revert('payouts blocked'); //in case of migration to another contract\n\t\n\tif (BonusDay[msg.sender].length == 0) revert('No Bonus');\n\t\n\tif (block.timestamp >= startDate + (BonusDay[msg.sender][0] * 86400) + 31556926)\n\t{\n\t\tif (BonusPaid[msg.sender]) revert('Bonus already paid');\n\t\t\n\t\texternal1.mintNewCoins(AddressBonus[msg.sender]);\n\t\t\n\t\tif (_address != 0x0000000000000000000000000000000000000000 && AllowOtherStakingPayoutAddress[msg.sender])\t\t\t\n\t\t\tmneContract.transfer(_address, AddressBonus[msg.sender]);\n\t\telse\n\t\t\tmneContract.transfer(msg.sender, AddressBonus[msg.sender]);\n\t\t\n\t\tnewBonusCoins += AddressBonus[msg.sender];\n\t\tBonusPaid[msg.sender] = true;\n\t}\n\telse\n\t{\n\t\trevert('Payout Date Not Valid');\n\t}\n}\n}"
    }
  }
}