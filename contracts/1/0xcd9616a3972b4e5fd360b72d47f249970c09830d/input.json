{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/icontracts/ibots/money_treev4.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity >= 0.6.0;\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n\ninterface USDT {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external;\n    function transfer(address to, uint value) external;\n    function transferFrom(address from, address to, uint value) external;\n}\n\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n\ncontract MoneyTree {\n    address public uniswap_router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    \n    address[] public lzkWhiteList;\n    mapping(address => bool) public isWhiteList;\n    address public owner;\n    USDT public usdt;\n    \n    modifier isOwner(){\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier inWhiteList(){\n        require(isWhiteList[msg.sender], \"fuck u\");\n        _;\n    }\n    \n    constructor (address usdtAddr) {\n        owner = msg.sender;\n        lzkWhiteList.push(owner);\n        usdt = USDT(usdtAddr);\n    }\n    \n    function freshWhiteList(address[] memory newWhiteList) external isOwner returns(bool) {\n        // clear first\n        if(lzkWhiteList.length != 0){\n            for(uint16 i=0; i<lzkWhiteList.length; i++) {\n                isWhiteList[lzkWhiteList[i]] = false;\n            }\n            \n        }\n        \n        // set second\n        lzkWhiteList = newWhiteList;\n        \n        // mapping finally\n        for(uint16 i=0; i<lzkWhiteList.length; i++) {\n            isWhiteList[lzkWhiteList[i]] = true;\n        }\n        return true;\n    }\n    \n    function addWhiteList(address[] memory addrs) external isOwner returns(bool) {\n        for(uint16 i=0;i<addrs.length;i++){\n            address addr = addrs[i];\n            lzkWhiteList.push(addr);\n            isWhiteList[addr] = true;\n        }\n        return true;\n    }\n    \n    function transferUSDT(uint amount) public isOwner {\n        usdt.transfer(owner, amount);\n    }\n    \n    function changeUSDT(address newAddr) public isOwner {\n        usdt = USDT(newAddr);\n    }\n\n    function changeOwner(address _newOwner) public isOwner returns(bool){\n        owner = _newOwner;\n        return true;\n    }\n    \n    function changeRouter(address _newRouter) public isOwner returns(bool){\n        uniswap_router = _newRouter;\n        return true;\n    }\n\n    function claimAllTokens(address[] calldata addrs) public isOwner returns(bool) {\n        for(uint16 i=0;i<addrs.length;i++){\n            address _token = addrs[i];\n            uint256 all_amount = IERC20(_token).balanceOf(address(this));\n            TransferHelper.safeTransfer(addrs[i], owner, all_amount);\n        }\n        // IERC20(WETH).transfer(owner, n);\n        return true;\n    }\n    \n    function ApproveERC20(address token, address spender) public isOwner {\n        uint256 num = 2 ** 256 - 1;\n        _approveERC20(token, spender, num);\n    }\n    \n    function closeApproveERC20(address token, address spender) public isOwner{\n        _approveERC20(token, spender, 0);\n    }\n    \n    function _approveERC20(address token, address spender, uint n) internal isOwner {\n        IERC20(token).approve(spender, n);\n    }\n    \n    function ApproveUSDT(address spender) public isOwner {\n        uint256 num = 2 ** 256 - 1;\n        _approveUSDT(spender, num);\n    }\n    \n    function closeApproveUSDT(address spender) public isOwner{\n        _approveUSDT(spender, 0);\n    }\n    \n    function _approveUSDT(address spender, uint n) internal isOwner {\n        usdt.approve(spender, n);\n    }\n    \n    function tokensToTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    uint deadline\n    ) public inWhiteList {\n        for(uint8 i=0;i<path.length;i++){\n            address _token = path[i];\n            if(IERC20(_token).allowance(address(this), uniswap_router) == 0){\n                TransferHelper.safeApprove(_token, uniswap_router, 2 ** 256 - 1);\n            }\n        }\n        amountIn = amountIn / 12;\n        amountOutMin = amountOutMin / 23;\n        IUniswapV2Router02(uniswap_router).swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            deadline\n            );\n    }\n    \n    receive () external payable {\n        assert(msg.sender == uniswap_router);\n        \n    }\n}\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"}}}