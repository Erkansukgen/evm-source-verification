{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DecodeCheckpointSignerList.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract DecodeCheckpointSignerList {\n    \n    // Slice specified number of bytes from arbitrary length byte array, starting from certain index\n    function slice(bytes memory payload, uint256 start, uint256 length) internal pure returns (bytes memory) {\n\n        require(length + 31 >= length, \"slice_overflow\");\n        require(start + length >= start, \"slice_overflow\");\n        require(payload.length >= start + length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n\n            switch iszero(length)\n            case 0 {\n                tempBytes := mload(0x40)\n\n                let lengthmod := and(length, 31)\n\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(add(add(payload, lengthmod), mul(0x20, iszero(lengthmod))), start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, length)\n\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            default {\n                tempBytes := mload(0x40)\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n\n        }\n\n        return tempBytes;\n        \n    }\n    \n    // Given input data for transaction invoking `submitHeaderBlock(bytes data, bytes sigs)`\n    // attempts to extract out data & signature fields\n    //\n    // Note: Function signature is also included in `payload` i.e. first 4 bytes, which will be\n    // stripped out ðŸ‘‡\n    function decodeIntoDataAndSignature(bytes calldata payload) internal pure returns (bytes memory, bytes memory) {\n\n        return abi.decode(slice(payload, 4, payload.length - 4), (bytes, bytes));\n\n    }\n    \n    // Given ðŸ‘† function call for extracting `data` from transaction input data\n    // has succeeded, votehash can be computed, which was signed by these check point signers\n    function computeVoteHash(bytes memory payload) internal pure returns (bytes32) {\n\n        return keccak256(abi.encodePacked(hex\"01\", payload));\n\n    }\n    \n    // Passing transaction input data of `submitHeaderBlock(bytes data, bytes sigs)` function\n    // call, it attempts to figure out what are those signers who signer this checkpoint\n    //\n    // Note: Sending checkpoint from Matic Network ( L2 ) to Ethereum Network ( L1 )\n    // is nothing but calling `submitHeaderBlock(bytes data, bytes sigs)`, defined\n    // in RootChain contract, deployed on Ethereum Network, with proper arguments, by some validator.\n    //\n    // RootChain :\n    //      0x2890bA17EfE978480615e330ecB65333b880928e [ Goerli ]\n    //      0x86E4Dc95c7FBdBf52e33D563BbDB00823894C287 [ Ethereum Mainnet ]\n    function decode(bytes calldata payload) external pure returns (address[] memory) {\n        \n        (bytes memory data, bytes memory sigs) = decodeIntoDataAndSignature(payload);\n        bytes32 voteHash = computeVoteHash(data);\n\n        address[] memory signers = new address[](sigs.length / 65);\n        uint256 count = 0;\n      \n        for(uint256 i = 0; i < sigs.length; i += 65) {\n  \n            bytes memory sig = slice(sigs, i, 65);\n          \n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n          \n            assembly {\n              \n                r := mload(add(sig, 32))\n                s := mload(add(sig, 64))\n                v := and(mload(add(sig, 65)), 255)\n\n            }\n\n            if (v < 27) v += 27;\n\n            signers[count++] = ecrecover(voteHash, v, r, s);\n\n        }\n      \n        return signers;\n\n    }\n\n}\n"}}}