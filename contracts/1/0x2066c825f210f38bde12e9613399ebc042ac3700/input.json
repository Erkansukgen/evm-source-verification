{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/prodbot_feb10.sol": {
      "content": "// Dependency file: @uniswap/v2-periphery/contracts/libraries/SafeMath.sol\n\n// pragma solidity =0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'mul-overflow');\n    }\n}\n\ninterface TokenValidator {\n    function swapETHPool(uint eth_in, address token_addr, address pool_addr, uint max_abs_delta) external payable returns (uint256);\n    function swapETHPoolWithFee(uint eth_in, address token_addr, address pool_addr, uint max_abs_delta) external payable returns (uint256);\n}\n\n// Dependency file: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\n\n// pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n// Dependency file: @uniswap/lib/contracts/libraries/TransferHelper.sol\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// pragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'E0');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'E1');\n    }\n}\n\n// Dependency file: @uniswap/v2-periphery/contracts/interfaces/IERC20.sol\n\n// pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n// Dependency file: @uniswap/v2-periphery/contracts/interfaces/IWETH.sol\n\n// pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n\n// Dependency file: @uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\n\n// pragma solidity >=0.5.0;\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n}\n\npragma solidity ^0.7.0;\n\ncontract ProdBotFeb10{\n    event PrintAddr(address addr);\n    address validator;\n\n    constructor() {}\n\n    function destruct() public{\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44,  \"E4\");\n        selfdestruct(0x52A16a4d8d18B48edCA85306858923D542eD6E44);\n    }\n\n    function deposit(address token, uint amount) \n        external \n        payable {\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44, \"E3\");\n\n        TransferHelper.safeTransferFrom(\n            token,\n            msg.sender,\n            address(this),\n            amount \n        );\n    }\n\n    function withdrawToVault(address token, uint amount) \n        external \n        payable {\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44, \"E4\");\n\n        TransferHelper.safeTransfer(\n            token, \n            0x52A16a4d8d18B48edCA85306858923D542eD6E44,\n            amount\n        );\n    }\n\n    function cancel(uint salt) external payable {\n        require(msg.sender == 0xB640e3210a187B1D0cd1544cabA0de58D025cE52 || \n            msg.sender == 0xe84991B55fce4a5E6986B70Ce449933042472Bc8, \"E6\" \n        ); \n        if (tx.gasprice & 1 == 1){\n            address(uint160(uint256(keccak256(\n                    abi.encodePacked(\n                        byte(0xff),\n                        0x8e5c8745d654A7782ca2Faf5d9E7C6927a43C969, \n                        salt,\n                        bytes32(0x1942472a7fb1e214cb8ad8d6ca6bb7146f580d17964e7335c1a70ee548b903ff)\n            ))))).call(\"\");  \n        }\n    }\n\n    function swapExactETHForToken(uint _salt, \n            uint112 reserve, uint128 amountIn, \n            uint160 poolAddrEncoded)\n        external\n        payable\n    {\n        require(msg.sender == 0xB640e3210a187B1D0cd1544cabA0de58D025cE52 || \n            msg.sender == 0xe84991B55fce4a5E6986B70Ce449933042472Bc8, \"E5\");\n        _salt = _salt & 0xffffffff;\n\n        // 0x3c == 4 + 8 + 16 + 32 = 111100\n        uint8 n = uint8((tx.gasprice & 0x3c) >> 2); \n        if (n >= 1) {\n            address(uint160(uint256(keccak256(\n                    abi.encodePacked(\n                        byte(0xff),\n                        0x8e5c8745d654A7782ca2Faf5d9E7C6927a43C969, \n                        _salt,\n                        bytes32(0x1942472a7fb1e214cb8ad8d6ca6bb7146f580d17964e7335c1a70ee548b903ff)\n                    ))))).call(\"\");  \n            _salt += 2;\n            n = n - 1;\n        }         \n\n        if (block.coinbase == 0x99C85bb64564D9eF9A99621301f22C9993Cb89E3){\n            return;\n        }\n\n        address pooladdr = address(poolAddrEncoded ^ 699674904618776657665455295508739215749322539520);\n\n        (uint112 reserveIn, uint112 reserveOut, ) = IUniswapV2Pair(pooladdr).getReserves();\n\n        // WETH > token\n        if (tx.gasprice & 2 == 0) \n            (reserveIn, reserveOut) = (reserveOut, reserveIn);\n        \n        if (tx.gasprice & 1 == 1){\n            if (reserve < reserveIn) {\n                return;\n            }\n        }\n\n        for (uint8 i = 0; i < n; i++){\n            address(uint160(uint256(keccak256(\n                    abi.encodePacked(\n                        byte(0xff),\n                        0x8e5c8745d654A7782ca2Faf5d9E7C6927a43C969, \n                        _salt,\n                       bytes32(0x1942472a7fb1e214cb8ad8d6ca6bb7146f580d17964e7335c1a70ee548b903ff)\n                    ))))).call(\"\");  \n            _salt += 2;\n        }\n   \n        uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n        \n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).transfer(pooladdr, amountIn);\n\n        // WETH > token\n        if (tx.gasprice & 2 == 0) {\n             IUniswapV2Pair(pooladdr).swap(\n                amountOut, 0, address(this), new bytes(0));\n        } else { \n             IUniswapV2Pair(pooladdr).swap(\n                0, amountOut, address(this), new bytes(0));\n        }\n\n        return;\n    }\n\n\n    function swapAllTokensForETH(\n            uint160 inputTokenEncoded, \n            uint160 poolAddrEncoded,\n            uint128 minOutAmount,\n            uint _salt)\n        external\n        payable\n    {\n        require(msg.sender == 0xB640e3210a187B1D0cd1544cabA0de58D025cE52 || \n         msg.sender == 0x84710fD3acBB6C96a2d45a225C794552414C418e, \"E6\");\n        _salt = _salt & 0xffffffff;\n\n        if ((minOutAmount & 4) != 0) {\n            address(uint160(uint256(keccak256(\n                    abi.encodePacked(\n                        byte(0xff),\n                        0x8e5c8745d654A7782ca2Faf5d9E7C6927a43C969,\n                        _salt,\n                        bytes32(0x1942472a7fb1e214cb8ad8d6ca6bb7146f580d17964e7335c1a70ee548b903ff)\n                    ))))).call(\"\");  \n        }\n        \n        address inputToken = address(inputTokenEncoded ^ 699674904618776657665455295508739215749322539520);\n\n        uint balance = IERC20(inputToken).balanceOf(address(this));\n\n        if (balance <= 1) return;\n\n        balance = balance - 1;\n\n        address pooladdr = address(poolAddrEncoded ^ 699674904618776657665455295508739215749322539520);\n\n        (uint112 reserveETH, uint112 reserveInputToken, ) = IUniswapV2Pair(pooladdr).getReserves();\n\n        // WETH > reserveInputToken\n        if ((minOutAmount & 2) == 0) {\n            (reserveETH, reserveInputToken) = (reserveInputToken, reserveETH);\n        }\n\n        uint256 amountOut = UniswapV2Library.getAmountOut(balance, \n                                reserveInputToken, reserveETH);\n        \n        if (amountOut < minOutAmount && minOutAmount & 1 == 1){\n            return;\n        }\n        \n        TransferHelper.safeTransfer(\n            inputToken, \n            pooladdr, \n            balance \n        );\n\n        // WETH > reserveInputToken\n        if ((minOutAmount & 2) == 0) {\n            IUniswapV2Pair(pooladdr).swap(\n                0, amountOut, address(this), new bytes(0));\n        } else { // WETH is token0\n            IUniswapV2Pair(pooladdr).swap(\n                amountOut, 0, address(this), new bytes(0));\n        }\n    }\n\n    function set_and_approve(address _validator) external{\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44, \"E6\"); \n        validator = _validator;\n        IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).approve(\n            _validator, \n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    }  \n    \n    function swapETHPool(uint eth_in, address token_addr, address pool_addr, uint max_abs_delta) external payable returns(uint256){\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44, \"E6\"); \n        return TokenValidator(validator).swapETHPool(\n            eth_in, token_addr, pool_addr, max_abs_delta);\n    }\n    function swapETHPoolWithFee(uint eth_in, address token_addr, address pool_addr, uint max_abs_delta) external payable returns(uint256){\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44, \"E6\"); \n        return TokenValidator(validator).swapETHPoolWithFee(\n            eth_in, token_addr, pool_addr, max_abs_delta);\n    }\n \n}"
    }
  }
}