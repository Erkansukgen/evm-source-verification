{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/TrustAuction.sol":{"content":"\n// Dependency file: @openzeppelin/contracts/GSN/Context.sol\npragma experimental ABIEncoderV2;\n//  \n\n// pragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// Dependency file: @openzeppelin/contracts/utils/Address.sol\n\n//  \n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [// importANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * // importANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// Dependency file: @openzeppelin/contracts/utils/Pausable.sol\n\n//  \n\n\n// import \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n// Dependency file: @openzeppelin/contracts/access/Ownable.sol\n\n//  \n\n\n// import \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// Dependency file: @openzeppelin/contracts/math/SafeMath.sol\n\n//  \n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract SponsorWhitelistControl {\n  /*** Query Functions ***/\n  /**\n    * @dev get gas sponsor address of specific contract\n    * @param contractAddr The address of the sponsored contract\n    */\n  function getSponsorForGas(address contractAddr) public view returns (address) {}\n\n  /**\n    * @dev get current Sponsored Balance for gas\n    * @param contractAddr The address of the sponsored contract\n    */\n  function getSponsoredBalanceForGas(address contractAddr) public view returns (uint) {}\n\n  /**\n    * @dev get current Sponsored Gas fee upper bound\n    * @param contractAddr The address of the sponsored contract\n    */\n  function getSponsoredGasFeeUpperBound(address contractAddr) public view returns (uint) {}\n\n  /**\n    * @dev get collateral sponsor address\n    * @param contractAddr The address of the sponsored contract\n    */\n  function getSponsorForCollateral(address contractAddr) public view returns (address) {}\n\n  /**\n    * @dev get current Sponsored Balance for collateral\n    * @param contractAddr The address of the sponsored contract\n    */\n  function getSponsoredBalanceForCollateral(address contractAddr) public view returns (uint) {}\n\n  /**\n    * @dev check if a user is in a contract's whitelist\n    * @param contractAddr The address of the sponsored contract\n    * @param user The address of contract user\n    */\n  function isWhitelisted(address contractAddr, address user) public view returns (bool) {}\n\n  /**\n    * @dev check if all users are in a contract's whitelist\n    * @param contractAddr The address of the sponsored contract\n    */\n  function isAllWhitelisted(address contractAddr) public view returns (bool) {}\n\n  /*** for contract admin only **/\n  /**\n    * @dev contract admin add user to whitelist\n    * @param contractAddr The address of the sponsored contract\n    * @param addresses The user address array\n    */\n  function addPrivilegeByAdmin(address contractAddr, address[] memory addresses) public {}\n\n  /**\n    * @dev contract admin remove user from whitelist\n    * @param contractAddr The address of the sponsored contract\n    * @param addresses The user address array\n    */\n  function removePrivilegeByAdmin(address contractAddr, address[] memory addresses) public {}\n\n  // ------------------------------------------------------------------------\n  // Someone will sponsor the gas cost for contract `contractAddr` with an\n  // `upper_bound` for a single transaction.\n  // ------------------------------------------------------------------------\n  function setSponsorForGas(address contractAddr, uint upperBound) public payable {}\n\n  // ------------------------------------------------------------------------\n  // Someone will sponsor the storage collateral for contract `contractAddr`.\n  // ------------------------------------------------------------------------\n  function setSponsorForCollateral(address contractAddr) public payable {}\n\n  // ------------------------------------------------------------------------\n  // Add commission privilege for address `user` to some contract.\n  // ------------------------------------------------------------------------\n  function addPrivilege(address[] memory) public {}\n\n  // ------------------------------------------------------------------------\n  // Remove commission privilege for address `user` from some contract.\n  // ------------------------------------------------------------------------\n  function removePrivilege(address[] memory) public {}\n}\n //  \n\n// import \"@openzeppelin/contracts/math/SafeMath.sol\";\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\n// import \"@openzeppelin/contracts/utils/Pausable.sol\";\n// import \"@openzeppelin/contracts/utils/Address.sol\";\n\ninterface ERC20Interface {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address from) external view returns (uint256);\n    function transferFrom(address from, address to, uint tokens) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    //function approve(address spender, uint256 amount) external returns (bool);\n}\n\ninterface ERC721Interface {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function supportsInterface(bytes4) external view returns (bool);\n}\n\ninterface ERC721Verifiable is ERC721Interface {\n    function verifyFingerprint(uint256, bytes memory) external view returns (bool);\n}\n\n\ncontract TrustAuction is Pausable, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    event AuctionCreated(\n        uint256 id,\n        address indexed seller,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        uint256 price,\n        uint256 expiresAt,\n        bytes fingerprint\n    );\n\n    event AuctionBidded(\n        uint256 id,\n        address seller,\n        address indexed bidder,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        uint256 price,\n        uint256 expiresAt\n    );\n\n    event AuctionFilled(\n        uint256 id,\n        address seller,\n        address indexed bidder,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        uint256 price,\n        uint256 expiresAt\n    );\n\n    event AuctionClosed(\n        uint256 id,\n        address indexed seller,\n        address indexed tokenAddress,\n        uint256 indexed tokenId,\n        uint256 price,\n        uint256 expiresAt,\n        bytes fingerprint\n    );\n\n    event ChangedOwnerCutPerMillion(uint256 _ownerCutPerMillion);\n\n    uint256 public constant MAX_BID_DURATION = 182 days;\n    //uint256 public constant MIN_BID_DURATION = 1 minutes;\n    uint256 public constant MIN_BID_DURATION = 1 seconds;\n    uint256 public constant ONE_MILLION = 1000000;\n    bytes4 public constant ERC721_Interface = 0x80ac58cd;\n    bytes4 public constant ERC721_Received = 0x150b7a02;\n    bytes4 public constant ERC721Composable_ValidateFingerprint = 0x8f9f4b63;\n\n    uint256 public ownerCutPerMillion = 10000;\n\n    //SponsorWhitelistControl constant private SPONSOR = SponsorWhitelistControl(address(0x0888000000000000000000000000000000000001));\n\n\n    // usdt\n    ERC20Interface public usdtToken;\n\n    struct Auction {\n        // auction id\n        uint256 id;\n        // seller \n        address seller;\n        // highest bidder\n        address bidder;\n        // ERC721 address\n        address tokenAddress;\n        // ERC721 token id\n        uint256 tokenId;\n        // price of the current bid, in wei\n        uint256 price;\n        // time when this auction end\n        uint256 expiresAt;\n\n        AuctionStatus status;\n        // Fingerprint for composable\n        bytes fingerprint;\n    }\n\n    enum AuctionStatus {\n        Live,\n        Filled,\n        Closed\n    }\n\n\n    // ERC721 address => global auction id\n    mapping(address => uint256) public globalAuctionId;\n    // ERC721 address => token id => index\n    mapping(address => mapping(uint256 => uint256)) auctionIndex;\n    // ERC721 address => index => auction\n    mapping(address => mapping(uint256 => Auction)) globalAuction;\n\n    // ERC721 address => tokenid => auction id\n    mapping(address => mapping(uint256 => uint256)) public auctionId;\n    // ERC721 address => token id => auction flag\n    mapping(address => mapping(uint256 => bool)) private hasAuction;\n    // ERC721 address => token id => auction\n    mapping(address => mapping(uint256 => Auction)) private auctionByTokenId;\n    // ERC721 address => auction id => auction\n    mapping(address => mapping(uint256 => Auction)) private auctionByAuctionId;\n\n    // token address => token id => owner \n    mapping(address => mapping(uint256 => address)) ownerByTokenId;\n\n    // user created auction\n    // ERC721 address => user address => uint256\n    mapping(address => mapping(address => uint256)) auctionCreatedCount;\n    // user address => auctionCreatedIndex to globalAuctionId\n    mapping(address => mapping(uint256 => uint256)) indexToGlobalAuctionId;\n\n\n    //user bided auction\n    // ERC721 address => user address => uint256\n    mapping(address => mapping(address => uint256)) auctionBiddedCount;\n    // user address => auctionBiddedIndex to globalAuctionId\n    mapping(address => mapping(uint256 => uint256)) indexBiddedToGlobalAuctionId;\n    // user address => auction id => bool\n    mapping(address => mapping(uint256 => bool)) auctionIsBidded;\n\n    /*\n    function addPrivilege(address account) public payable {\n        address[] memory a = new address[](1);\n        a[0] = account;\n        SPONSOR.addPrivilege(a);\n    }\n\n    function removePrivilege(address account) public payable {\n        address[] memory a = new address[](1);\n        a[0] = account;\n        SPONSOR.removePrivilege(a);\n    }*/\n\n    /**\n     *  @dev Get the amount of the user created auctions\n     *  @param _tokenAddress  - address of the ERC721 token\n     *  @param _who - the user address\n    */\n    function getUserCreateAuctionCount(address _tokenAddress, address _who) public view  returns (uint256) {\n        return auctionCreatedCount[_tokenAddress][_who];\n    }\n    \n    function getUserCreateAuctionByPage(\n        address _tokenAddress,\n        address _who,\n        uint256 _pageIndex,\n        uint256 _pageSize\n        ) public view returns (Auction[] memory) {\n            \n        uint256 from = auctionCreatedCount[_tokenAddress][_who] - (_pageIndex - 1) * _pageSize;\n        uint256 end = 0;\n        if (auctionCreatedCount[_tokenAddress][_who] >= _pageIndex * _pageSize) {\n            end = auctionCreatedCount[_tokenAddress][_who] - _pageIndex * _pageSize + 1;\n        } else {\n            end = 1;\n        }\n        \n        uint256 _count = from - end + 1;\n        \n        Auction[] memory auctions = new Auction[](_count);\n        \n        for (uint256 i = 0; i < _count; i++) {\n            uint256 _index = indexToGlobalAuctionId[_who][from - i];\n            Auction memory auction = globalAuction[_tokenAddress][_index];\n            \n            auctions[i] = auction;\n        }\n        \n        return auctions;\n    }\n\n\n    function getUserBiddedAuctionCount(address _tokenAddress, address _who) public view returns(uint256) {\n        return auctionBiddedCount[_tokenAddress][_who];\n    }\n    \n    function getUserBiddedAuctionByPage(\n        address _tokenAddress,\n        address _who,\n        uint256 _pageIndex,\n        uint256 _pageSize\n        ) public view returns (Auction[] memory) {\n            \n        uint256 from = auctionBiddedCount[_tokenAddress][_who] - (_pageIndex - 1) * _pageSize;\n        uint256 end = 0;\n        if (auctionBiddedCount[_tokenAddress][_who] >= _pageIndex * _pageSize) {\n            end = auctionBiddedCount[_tokenAddress][_who] - _pageIndex * _pageSize + 1;\n        } else {\n            end = 1;\n        }\n        \n        uint256 _count = from - end + 1;\n        \n        Auction[] memory auctions = new Auction[](_count);\n        \n        for (uint256 i = 0; i < _count; i++) {\n            uint256 _index = indexBiddedToGlobalAuctionId[_who][from - i];\n            Auction memory auction = globalAuction[_tokenAddress][_index];\n            \n            auctions[i] = auction;\n        }\n        \n        return auctions;\n    }\n\n\n    modifier onlyCreator(address _tokenAddress, uint256 _tokenId) {\n        require(ownerByTokenId[_tokenAddress][_tokenId] == msg.sender, \"Ownable: caller is not the creator\");\n        _;\n    }\n\n    // cUSDT 0x8b8689c7f3014a4d86e4d1d0daaf74a47f5e0f27\n    constructor(address _usdtToken) Ownable() Pausable() public {\n        usdtToken = ERC20Interface(_usdtToken);\n\n        //addPrivilege(address(0x0));\n    }\n\n\n    function createAuction(\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _price,\n        uint256 _duration\n    ) public {\n        _createAuction(_tokenAddress, _tokenId, _price, _duration, \"\");\n    }\n\n    function createAuction(\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _price,\n        uint256 _duration,\n        bytes memory _fingerprint\n    ) public {\n        _createAuction(_tokenAddress, _tokenId, _price, _duration, _fingerprint);\n    }\n\n    function _createAuction(\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _price,\n        uint256 _duration,\n        bytes memory _fingerprint\n    ) private whenNotPaused() {\n        _requireERC721(_tokenAddress);\n        _requireComposableERC721(_tokenAddress, _tokenId, _fingerprint);\n\n        require(_price > 0, \"Price should be bigger than 0\");\n        require(_duration >= MIN_BID_DURATION \n            && _duration <= MAX_BID_DURATION, \"The bid duration error\");\n        require(!hasAuction[_tokenAddress][_tokenId]);\n\n        //uint256 _auctionId = auctionId[_tokenAddress][_tokenId];  // ? bug\n        uint256 _auctionId = globalAuctionId[_tokenAddress];\n\n        Auction memory auction = Auction({\n            id: _auctionId,\n            seller: msg.sender,\n            bidder: address(0),\n            tokenAddress: _tokenAddress,\n            tokenId: _tokenId,\n            price: _price,\n            expiresAt: block.timestamp.add(_duration),\n            status: AuctionStatus.Live,\n            fingerprint: _fingerprint\n        });\n\n        //auctionByTokenId[_tokenAddress][_tokenId] = auction;\n        //auctionByAuctionId[_tokenAddress][_auctionId] = auction;\n\n        auctionId[_tokenAddress][_tokenId]++;\n\n        hasAuction[_tokenAddress][_tokenId] = true;\n\n        ownerByTokenId[_tokenAddress][_tokenId] = msg.sender;\n        _stake(_tokenAddress, _tokenId);  //deposit in\n\n        // add global data reference\n        uint256 index = globalAuctionId[_tokenAddress];\n        globalAuction[_tokenAddress][index] = auction;\n\n        auctionIndex[_tokenAddress][_tokenId] = globalAuctionId[_tokenAddress];\n\n\n        //for user record\n        uint256 countIndex = auctionCreatedCount[_tokenAddress][msg.sender];\n        auctionCreatedCount[_tokenAddress][msg.sender] = countIndex + 1;\n        \n        indexToGlobalAuctionId[msg.sender][countIndex + 1] = _auctionId;\n\n\n        globalAuctionId[_tokenAddress]++;\n\n\n\n        emit AuctionCreated(\n            _auctionId,\n            msg.sender,\n            _tokenAddress,\n            _tokenId,\n            _price,\n            _duration,\n            _fingerprint\n        );\n    }\n\n    /**\n     *  @dev Get the global index of all auctions\n     *  @param _tokenAddress  - address of the ERC721 token\n     *  @param _tokenId - the token id of a ERC721 token\n    */\n    function getAuctionIndex(address _tokenAddress, uint256 _tokenId) public view returns (uint256) {\n        return auctionIndex[_tokenAddress][_tokenId];\n    }\n\n    function getAuctionCount(address _tokenAddress) public view returns (uint256) {\n        return globalAuctionId[_tokenAddress];\n    }\n\n    function getAuctionByPage(address _tokenAddress, uint256 _pageIndex, uint256 _pageSize) public view \n        returns (Auction[] memory) \n    {\n        uint256 _index = globalAuctionId[_tokenAddress] - (_pageIndex - 1) * _pageSize - 1;\n        uint256 _end = 0;\n        if (globalAuctionId[_tokenAddress] >= _pageIndex * _pageSize) {\n            _end = globalAuctionId[_tokenAddress] - _pageIndex * _pageSize;\n        } else {\n            _end = 0;\n        }\n        uint256 _count = _index - _end + 1;\n\n        Auction[] memory auctions = new Auction[](_count);\n\n        for (uint256 i = 0; i < _count; i++) {\n            Auction memory auction = globalAuction[_tokenAddress][_index - i];\n\n            auctions[i] = auction;\n        }\n\n        return auctions;\n    }\n    \n\n    function getAuctionByIndex(address _tokenAddress, uint256 _index) public view \n        returns (\n            uint256 id,\n            address seller,\n            address bidder,\n            address tokenAddress,\n            uint256 tokenId,\n            uint256 price,\n            AuctionStatus status,\n            uint256 expiresAt\n        )\n    {\n        require(_index < globalAuctionId[_tokenAddress], 'auction index error');\n        Auction memory auction = globalAuction[_tokenAddress][_index];\n        return (\n            auction.id,\n            auction.seller,\n            auction.bidder,\n            auction.tokenAddress,\n            auction.tokenId,\n            auction.price,\n            auction.status,\n            auction.expiresAt\n        );\n    }\n\n    function getAuctionByTokenId(address _tokenAddress, uint256 _tokenId) public view \n        returns (\n            uint256 id,\n            address seller,\n            address bidder,\n            address tokenAddress,\n            uint256 tokenId,\n            uint256 price,\n            AuctionStatus status,\n            uint256 expiresAt\n        )\n    {\n        uint256 _index = auctionIndex[_tokenAddress][_tokenId];\n        Auction memory auction = globalAuction[_tokenAddress][_index];\n        return (\n            auction.id,\n            auction.seller,\n            auction.bidder,\n            auction.tokenAddress,\n            auction.tokenId,\n            auction.price,\n            auction.status,\n            auction.expiresAt\n        );\n    }\n\n    function getAuctionByAuctionId(address _tokenAddress, uint256 _auctionId) public view \n        returns (\n            uint256 id,\n            address seller,\n            address bidder,\n            address tokenAddress,\n            uint256 tokenId,\n            uint256 price,\n            uint256 expiresAt\n        )\n    {\n        Auction memory auction = globalAuction[_tokenAddress][_auctionId];\n        return (\n            auction.id,\n            auction.seller,\n            auction.bidder,\n            auction.tokenAddress,\n            auction.tokenId,\n            auction.price,\n            auction.expiresAt\n        );\n    }\n\n\n    function bidAuction(address _tokenAddress, uint256 _tokenId, uint256 _price) public {\n        //Auction memory auction = auctionByTokenId[_tokenAddress][_tokenId];\n        uint256 _auctionIndex = auctionIndex[_tokenAddress][_tokenId];\n        Auction memory auction = globalAuction[_tokenAddress][_auctionIndex];\n\n        require(_price > auction.price, 'BidAuction: price should be big than current price');\n        require(block.timestamp < auction.expiresAt);\n\n        //_requireBidderBalance(msg.sender, _price);\n        if (auction.bidder != address(0x0)) {\n\n            require(usdtToken.transfer(auction.bidder, auction.price),\n                \"Refund USDT to previous bidder failed\"\n            );\n        }\n\n        require(usdtToken.transferFrom(msg.sender, address(this), _price),\n            \"Transfering USDT to auction contract failed\"\n        );\n\n        // update price and high bidder\n        auction.price = _price;\n        auction.bidder = msg.sender;\n\n        uint256 index = auctionIndex[_tokenAddress][_tokenId];\n        globalAuction[_tokenAddress][index] = auction;\n\n        //auctionByTokenId[_tokenAddress][_tokenId] = auction;\n        //auctionByAuctionId[_tokenAddress][auction.id] = auction;\n\n\n        //update bidded info\n        if (!auctionIsBidded[msg.sender][auction.id]) {\n            uint256 _index = auctionBiddedCount[_tokenAddress][msg.sender];\n            auctionBiddedCount[_tokenAddress][msg.sender] = _index + 1;\n            indexBiddedToGlobalAuctionId[msg.sender][_index + 1] = auction.id;\n\n            auctionIsBidded[msg.sender][auction.id] = true;\n        }\n\n\n        emit AuctionBidded(\n            auction.id,\n            auction.seller,\n            msg.sender,\n            auction.tokenAddress,\n            auction.tokenId,\n            _price,\n            auction.expiresAt\n        );\n    }\n\n    function finishAuction(address _tokenAddress, uint256 _tokenId) public {\n        //Auction memory auction = auctionByTokenId[_tokenAddress][_tokenId];\n        uint256 _auctionIndex = auctionIndex[_tokenAddress][_tokenId];\n        Auction memory auction = globalAuction[_tokenAddress][_auctionIndex];\n\n        require(auction.expiresAt < block.timestamp);\n        require(auction.bidder == msg.sender, \"FinishAuction: you are not the highest bidder\");\n\n        //_requireBidderBalance(msg.sender, auction.price);\n\n        uint256 saleShareAmount = 0;\n        if (ownerCutPerMillion > 0) {\n            saleShareAmount = auction.price.mul(ownerCutPerMillion).div(ONE_MILLION);\n\n            require(usdtToken.transfer(owner(), saleShareAmount),\n                \"Transfering the cut to the bid contract owner failed\"\n            );\n        }\n\n        require(usdtToken.transfer(auction.seller, auction.price.sub(saleShareAmount)),\n            \"Transfering USDT to owner failed\"\n        );\n\n        ERC721Interface(_tokenAddress).transferFrom(address(this), msg.sender, _tokenId);\n\n        auction.status = AuctionStatus.Filled;\n        auctionByAuctionId[_tokenAddress][auction.id] = auction;\n\n        uint256 index = auctionIndex[_tokenAddress][_tokenId];\n        globalAuction[_tokenAddress][index] = auction;\n\n\n        hasAuction[_tokenAddress][_tokenId] = false;\n        //delete auctionByTokenId[_tokenAddress][_tokenId];\n        //delete ownerByTokenId[_tokenAddress][_tokenId];    // clear the owner\n\n        emit AuctionFilled(\n            auction.id,\n            auction.seller,\n            auction.bidder,\n            _tokenAddress,\n            _tokenId,\n            auction.price,\n            auction.expiresAt\n        );\n    }\n\n    /**\n    */\n    function closeAuction(address _tokenAddress, uint256 _tokenId)\n        public whenNotPaused() {\n        \n        require(ownerByTokenId[_tokenAddress][_tokenId] == msg.sender);\n        //Auction memory auction = auctionByTokenId[_tokenAddress][_tokenId];\n        uint256 _auctionIndex = auctionIndex[_tokenAddress][_tokenId];\n        Auction memory auction = globalAuction[_tokenAddress][_auctionIndex];\n\n        //require(auction.expiresAt < block.timestamp);\n        require(auction.seller == msg.sender, \"CloseAuction: you are not the seller\");\n        \n        //auction.status = AuctionStatus.Closed;\n        //auctionByAuctionId[_tokenAddress][auction.id] = auction;\n\n        hasAuction[_tokenAddress][_tokenId] = false;\n        //delete auctionByTokenId[_tokenAddress][_tokenId];\n        //delete ownerByTokenId[_tokenAddress][_tokenId];    // clear the owner\n\n        uint256 index = auctionIndex[_tokenAddress][_tokenId];\n\n        \n        if (auction.bidder != address(0x0)) {\n            uint256 saleShareAmount = 0;\n            if (ownerCutPerMillion > 0) {\n                saleShareAmount = auction.price.mul(ownerCutPerMillion).div(ONE_MILLION);\n\n\n                require(usdtToken.transfer(owner(), saleShareAmount),\n                    \"Transfering the cut to the bid contract owner failed\"\n                );\n            }\n\n            require(usdtToken.transfer(auction.seller, auction.price.sub(saleShareAmount)),\n                \"Transfering USDT to owner failed\"\n            );\n\n            auction.status = AuctionStatus.Filled;\n\n            ERC721Interface(_tokenAddress).transferFrom(address(this), auction.bidder, _tokenId);\n        } else {\n            auction.status = AuctionStatus.Closed;\n\n            _widthdraw(_tokenAddress, _tokenId);\n        }\n        \n        auctionByAuctionId[_tokenAddress][auction.id] = auction;\n        globalAuction[_tokenAddress][index] = auction;\n\n        emit AuctionClosed(\n            auction.id,\n            auction.seller,\n            auction.tokenAddress,\n            auction.tokenId,\n            auction.price,\n            auction.expiresAt,\n            auction.fingerprint\n        );\n    }\n\n    /**\n    * @dev Sets the share cut for the owner of the contract that's\n    * charged to the seller on a successful sale\n    * @param _ownerCutPerMillion - Share amount, from 0 to 999,999\n    */\n    function setOwnerCutPerMillion(uint256 _ownerCutPerMillion) external onlyOwner {\n        require(_ownerCutPerMillion < ONE_MILLION, \"The owner cut should be between 0 and 999,999\");\n\n        ownerCutPerMillion = _ownerCutPerMillion;\n        emit ChangedOwnerCutPerMillion(ownerCutPerMillion);\n    }\n\n\n    // get a owner of a tokenid bid\n    function getOwnerByTokenId(address _tokenAddress, uint256 _tokenId) public view returns (address) {\n        return ownerByTokenId[_tokenAddress][_tokenId];\n    }\n\n\n\n    function _stake(address _tokenAddress, uint256 _tokenId) internal {\n        ERC721Interface(_tokenAddress).transferFrom(msg.sender, address(this), _tokenId);\n        ownerByTokenId[_tokenAddress][_tokenId] = msg.sender;\n    }\n\n    function _widthdraw(address _tokenAddress, uint256 _tokenId) internal {\n        ERC721Interface(_tokenAddress).transferFrom(address(this), msg.sender, _tokenId);\n        delete ownerByTokenId[_tokenAddress][_tokenId];\n    }\n\n    /**\n    * @dev Check if the token has a valid ERC721 implementation\n    * @param _tokenAddress - address of the token\n    */\n    function _requireERC721(address _tokenAddress) internal view {\n        require(_tokenAddress.isContract(), \"Token should be a contract\");\n\n        ERC721Interface token = ERC721Interface(_tokenAddress);\n        require(\n            token.supportsInterface(ERC721_Interface),\n            \"Token has an invalid ERC721 implementation\"\n        );\n    }\n\n    /**\n    * @dev Check if the token has a valid Composable ERC721 implementation\n    * And its fingerprint is valid\n    * @param _tokenAddress - address of the token\n    * @param _tokenId - uint256 of the index\n    * @param _fingerprint - bytes of the fingerprint\n    */\n    function _requireComposableERC721(\n        address _tokenAddress,\n        uint256 _tokenId,\n        bytes memory _fingerprint\n    )\n        internal\n        view\n    {\n        ERC721Verifiable composableToken = ERC721Verifiable(_tokenAddress);\n        if (composableToken.supportsInterface(ERC721Composable_ValidateFingerprint)) {\n            require(\n                composableToken.verifyFingerprint(_tokenId, _fingerprint),\n                \"Token fingerprint is not valid\"\n            );\n        }\n    }\n\n    /**\n    * @dev Check if the bidder has balance and the contract has enough allowance\n    * to use bidder USDT on his belhalf\n    * @param _bidder - address of bidder\n    * @param _amount - uint256 of amount\n    */\n    function _requireBidderBalance(address _bidder, uint256 _amount) internal view {\n        require(\n            usdtToken.balanceOf(_bidder) >= _amount,\n            \"Insufficient funds\"\n        );\n        require(\n            usdtToken.allowance(_bidder, address(this)) >= _amount, \n            \"The contract is not authorized to use USDT on bidder behalf\"\n        );        \n    }\n\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"}}}