{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/UNI/CheckAndSend.sol":{"content":"pragma solidity ^0.8.0;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract CheckAndSend {\r\n    \r\n    address payable owner;\r\n    \r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    receive() external payable {}\r\n    \r\n    function setOwner(address payable newOwner) external {\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function withdraw(uint256 amount) external {\r\n        require(msg.sender == owner);\r\n        owner.transfer(amount);\r\n    }\r\n    \r\n    function withdrawErc20(address token, uint256 amount) external {\r\n        require(msg.sender == owner);\r\n        IERC20 erc20 = IERC20(token);\r\n        erc20.transfer(owner, amount);\r\n    }\r\n    \r\n     function approveAndSwap(address token, bytes calldata payloadApprove, address uniswapRouterV2, bytes calldata payloadSwap) external payable  {\r\n        (bool _success, bytes memory _response) = token.call(payloadApprove);\r\n        string memory _revertMsg = _getRevertMsg(_response);\r\n        require(_success, _revertMsg);\r\n        \r\n        this.swap{value: msg.value}(uniswapRouterV2, payloadSwap);\r\n    }\r\n    \r\n    function swapAndReward( address uniswapRouterV2, bytes calldata payloadSwap, uint256 investedAmount, uint256 minerReward, uint256 prevBalance) external payable  {\r\n        this.swap{value: msg.value}(uniswapRouterV2, payloadSwap);\r\n        uint256 currentBalance = address(this).balance;\r\n        \r\n        require(currentBalance - investedAmount - minerReward > prevBalance, \"Sandwich not worth\");\r\n        block.coinbase.transfer(minerReward);\r\n    }\r\n\r\n    function swap( address uniswapRouterV2, bytes calldata payloadSwap) external payable  {\r\n        (bool _success, bytes memory _response) = uniswapRouterV2.call{value: msg.value}(payloadSwap);\r\n        string memory _revertMsg = _getRevertMsg(_response);\r\n        require(_success, _revertMsg);\r\n    }\r\n    \r\n    function _getRevertMsg(bytes memory _res) internal pure returns (string memory) {\r\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\r\n        if (_res.length < 68) return 'Transaction reverted silently';\r\n        return abi.decode(_res, (string)); // All that remains is the revert string\r\n    }\r\n    \r\n}"}}}