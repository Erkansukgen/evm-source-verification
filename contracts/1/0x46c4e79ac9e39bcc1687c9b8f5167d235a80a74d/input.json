{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/WrapperFlattened.sol":{"content":"\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.15;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/GSN/Context.sol\n\npragma solidity ^0.5.15;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n\npragma solidity ^0.5.15;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/interfaces/ExchangeWrapper.sol\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.15;\n\n\n/**\n * @title ExchangeWrapper\n * @author dYdX\n *\n * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\n * with other smart contracts through a common interface.\n */\ninterface ExchangeWrapper {\n\n    // ============ Public Functions ============\n\n    /**\n     * Exchange some amount of takerToken for makerToken.\n     *\n     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\n     *                              cannot always be trusted as it is set at the discretion of the\n     *                              msg.sender)\n     * @param  receiver             Address to set allowance on once the trade has completed\n     * @param  makerToken           Address of makerToken, the token to receive\n     * @param  takerToken           Address of takerToken, the token to pay\n     * @param  requestedFillAmount  Amount of takerToken being paid\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n     * @return                      The amount of makerToken received\n     */\n    function exchange(\n        address tradeOriginator,\n        address receiver,\n        address makerToken,\n        address takerToken,\n        uint256 requestedFillAmount,\n        bytes calldata orderData\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n     * than desiredMakerToken\n     *\n     * @param  makerToken         Address of makerToken, the token to receive\n     * @param  takerToken         Address of takerToken, the token to pay\n     * @param  desiredMakerToken  Amount of makerToken requested\n     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\n     * @return                    Amount of takerToken the needed to complete the transaction\n     */\n    function getExchangeCost(\n        address makerToken,\n        address takerToken,\n        uint256 desiredMakerToken,\n        bytes calldata orderData\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// File: contracts/lib/MathHelpers.sol\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.15;\n\n\n\n/**\n * @title MathHelpers\n * @author dYdX\n *\n * This library helps with common math functions in Solidity\n */\nlibrary MathHelpers {\n    using SafeMath for uint256;\n\n    /**\n     * Calculates partial value given a numerator and denominator.\n     *\n     * @param  numerator    Numerator\n     * @param  denominator  Denominator\n     * @param  target       Value to calculate partial of\n     * @return              target * numerator / denominator\n     */\n    function getPartialAmount(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return numerator.mul(target).div(denominator);\n    }\n\n    /**\n     * Calculates partial value given a numerator and denominator, rounded up.\n     *\n     * @param  numerator    Numerator\n     * @param  denominator  Denominator\n     * @param  target       Value to calculate partial of\n     * @return              Rounded-up result of target * numerator / denominator\n     */\n    function getPartialAmountRoundedUp(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return divisionRoundedUp(numerator.mul(target), denominator);\n    }\n\n    /**\n     * Calculates division given a numerator and denominator, rounded up.\n     *\n     * @param  numerator    Numerator.\n     * @param  denominator  Denominator.\n     * @return              Rounded-up result of numerator / denominator\n     */\n    function divisionRoundedUp(\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        assert(denominator != 0); // coverage-enable-line\n        if (numerator == 0) {\n            return 0;\n        }\n        return numerator.sub(1).div(denominator).add(1);\n    }\n\n    /**\n     * Calculates and returns the maximum value for a uint256 in solidity\n     *\n     * @return  The maximum value for uint256\n     */\n    function maxUint256(\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return 2 ** 256 - 1;\n    }\n\n    /**\n     * Calculates and returns the maximum value for a uint256 in solidity\n     *\n     * @return  The maximum value for uint256\n     */\n    function maxUint32(\n    )\n        internal\n        pure\n        returns (uint32)\n    {\n        return 2 ** 32 - 1;\n    }\n\n    /**\n     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\n     *\n     * @param  n  The uint256 to get the number of bits in\n     * @return    The number of bits in n\n     */\n    function getNumBits(\n        uint256 n\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 first = 0;\n        uint256 last = 256;\n        while (first < last) {\n            uint256 check = (first + last) / 2;\n            if ((n >> check) == 0) {\n                last = check;\n            } else {\n                first = check + 1;\n            }\n        }\n        assert(first <= 256);\n        return first;\n    }\n}\n\n// File: contracts/lib/GeneralERC20.sol\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.15;\n\n\n/**\n * @title GeneralERC20\n * @author dYdX\n *\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n * that we dont automatically revert when calling non-compliant tokens that have no return value for\n * transfer(), transferFrom(), or approve().\n */\ninterface GeneralERC20 {\n    function totalSupply(\n    )\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(\n        address who\n    )\n        external\n        view\n        returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    function transfer(\n        address to,\n        uint256 value\n    )\n        external;\n\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external;\n\n    function approve(\n        address spender,\n        uint256 value\n    )\n        external;\n}\n\n// File: contracts/lib/TokenInteract.sol\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.15;\n\n\n\n/**\n * @title TokenInteract\n * @author dYdX\n *\n * This library contains basic functions for interacting with ERC20 tokens\n */\nlibrary TokenInteract {\n    function balanceOf(\n        address token,\n        address owner\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return GeneralERC20(token).balanceOf(owner);\n    }\n\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return GeneralERC20(token).allowance(owner, spender);\n    }\n\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        GeneralERC20(token).approve(spender, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#approve: Approval failed\"\n        );\n    }\n\n    function transfer(\n        address token,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        address from = address(this);\n        if (\n            amount == 0\n            || from == to\n        ) {\n            return;\n        }\n\n        GeneralERC20(token).transfer(to, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#transfer: Transfer failed\"\n        );\n    }\n\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        if (\n            amount == 0\n            || from == to\n        ) {\n            return;\n        }\n\n        GeneralERC20(token).transferFrom(from, to, amount);\n\n        require(\n            checkSuccess(),\n            \"TokenInteract#transferFrom: TransferFrom failed\"\n        );\n    }\n\n    // ============ Private Helper-Functions ============\n\n    /**\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n     * function returned 0 bytes or 32 bytes that are not all-zero.\n     */\n    function checkSuccess(\n    )\n        private\n        pure\n        returns (bool)\n    {\n        uint256 returnValue = 0;\n\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            // check number of bytes returned from last function call\n            switch returndatasize\n\n            // no bytes returned: assume success\n            case 0x0 {\n                returnValue := 1\n            }\n\n            // 32 bytes returned: check if non-zero\n            case 0x20 {\n                // copy 32 bytes into scratch space\n                returndatacopy(0x0, 0x0, 0x20)\n\n                // load those bytes into returnValue\n                returnValue := mload(0x0)\n            }\n\n            // not sure what was returned: dont mark as success\n            default { }\n        }\n\n        return returnValue != 0;\n    }\n}\n\n// File: contracts/lib/AdvancedTokenInteract.sol\n\n/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.15;\n\n\n\n\n/**\n * @title AdvancedTokenInteract\n * @author dYdX\n *\n * This library contains advanced functions for interacting with ERC20 tokens\n */\nlibrary AdvancedTokenInteract {\n    using TokenInteract for address;\n\n    /**\n     * Checks if the spender has some amount of allowance. If it doesn't, then set allowance at\n     * the maximum value.\n     *\n     * @param  token    Address of the ERC20 token\n     * @param  spender  Argument of the allowance function\n     * @param  amount   The minimum amount of allownce the the spender should be guaranteed\n     */\n    function ensureAllowance(\n        address token,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        if (token.allowance(address(this), spender) < amount) {\n            token.approve(spender, MathHelpers.maxUint256());\n        }\n    }\n}\n\n// File: contracts/interfaces/UniswapFactoryInterface.sol\n\npragma solidity 0.5.15;\n\ninterface IUniFactory {\n    // Create Exchange\n    function createExchange(\n        address token\n    )\n        external\n        returns (address exchange);\n    // Get Exchange and Token Info\n    function getExchange(\n        address token\n    )\n        external\n        view\n        returns (address exchange);\n    function getToken(\n        address exchange\n    )\n        external\n        view\n        returns (address token);\n    function getTokenWithId(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (address token);\n    // Never use\n    function initializeFactory(\n        address template\n    )\n        external;\n}\n\n// File: contracts/interfaces/UniswapExchangeInterface.sol\n\npragma solidity 0.5.15;\n\ninterface IUni {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress()\n        external\n        view\n        returns (address token);\n\n    // Address of Uniswap Factory\n    function factoryAddress()\n        external\n        view\n        returns (address factory);\n\n    // Provide Liquidity\n    function addLiquidity(\n        uint256 min_liquidity,\n        uint256 max_tokens,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256);\n\n    function removeLiquidity(\n        uint256 amount,\n        uint256 min_eth,\n        uint256 min_tokens,\n        uint256 deadline\n    )\n        external\n        returns (uint256, uint256);\n\n    // Get Prices\n    function getEthToTokenInputPrice(\n        uint256 eth_sold\n    )\n        external\n        view\n        returns (uint256 tokens_bought);\n\n    function getEthToTokenOutputPrice(\n        uint256 tokens_bought\n    )\n        external\n        view\n        returns (uint256 eth_sold);\n\n    function getTokenToEthInputPrice(\n        uint256 tokens_sold\n    )\n        external\n        view\n        returns (uint256 eth_bought);\n\n    function getTokenToEthOutputPrice(\n        uint256 eth_bought\n    )\n        external\n        view\n        returns (uint256 tokens_sold);\n\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(\n        uint256 min_tokens,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256  tokens_bought);\n\n    function ethToTokenTransferInput(\n        uint256 min_tokens,\n        uint256 deadline,\n        address recipient\n    )\n        external\n        payable\n        returns (uint256  tokens_bought);\n\n    function ethToTokenSwapOutput(\n        uint256 tokens_bought,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256  eth_sold);\n\n    function ethToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 deadline,\n        address recipient\n    )\n        external\n        payable\n        returns (uint256  eth_sold);\n\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline\n    )\n        external\n        returns (uint256  eth_bought);\n\n    function tokenToEthTransferInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline, address recipient\n    )\n        external\n        returns (uint256  eth_bought);\n\n    function tokenToEthSwapOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline\n    )\n        external\n        returns (uint256  tokens_sold);\n\n    function tokenToEthTransferOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline,\n        address recipient\n    )\n        external\n        returns (uint256  tokens_sold);\n\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address token_addr\n    )\n        external\n        returns (uint256  tokens_bought);\n\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    )\n        external\n        returns (uint256  tokens_bought);\n\n    function tokenToTokenSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address token_addr\n    )\n        external\n        returns (uint256  tokens_sold);\n\n    function tokenToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    )\n        external returns (uint256  tokens_sold);\n\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address exchange_addr\n    )\n        external\n        returns (uint256  tokens_bought);\n\n    function tokenToExchangeTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    )\n        external\n        returns (uint256  tokens_bought);\n\n    function tokenToExchangeSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address exchange_addr\n    )\n        external\n        returns (uint256  tokens_sold);\n\n    function tokenToExchangeTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    )\n        external\n        returns (uint256  tokens_sold);\n}\n\n// File: contracts/lib/Require.sol\n\n/*\n    Copyright 2019 Topo Co.\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    See bottom of file for modifications to original work by dYdX Trading Inc.\n*/\n\npragma solidity 0.5.15;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title Require\n * @author dYdX\n *\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\n */\nlibrary Require {\n\n    // ============ Constants ============\n\n    uint256 constant ASCII_ZERO = 48; // '0'\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\n    bytes2 constant COLON = 0x3a20; // ': '\n    bytes2 constant COMMA = 0x2c20; // ', '\n    bytes2 constant LPAREN = 0x203c; // ' <'\n    byte constant RPAREN = 0x3e; // '>'\n    uint256 constant FOUR_BIT_MASK = 0xf;\n\n    // ============ Library Functions ============\n\n    function checkSuccess(\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        uint256 returnValue = 0;\n\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            // check number of bytes returned from last function call\n            switch returndatasize\n\n            // no bytes returned: assume success\n            case 0x0 {\n                returnValue := 1\n            }\n\n            // 32 bytes returned: check if non-zero\n            case 0x20 {\n                // copy 32 bytes into scratch space\n                returndatacopy(0x0, 0x0, 0x20)\n\n                // load those bytes into returnValue\n                returnValue := mload(0x0)\n            }\n\n            // not sure what was returned: don't mark as success\n            default { }\n        }\n\n        return returnValue != 0;\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason)\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        uint256 payloadA\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA,\n        address payloadB\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bytes32 payloadA,\n        bytes32 payloadB\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        uint256 payloadA,\n        uint256 payloadB\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bool payloadA,\n        uint256 payloadB\n    )\n        internal\n        pure\n    {\n        uint256 num;\n        if (payloadA) {\n          num = 1;\n        } else {\n          num = 0;\n        }\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(num),\n                        COMMA,\n                        stringify(payloadB),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bool payloadA,\n        bool payloadB,\n        bool payloadC\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bool payloadA,\n        bool payloadB,\n        bool payloadC,\n        bool payloadD\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        COMMA,\n                        stringify(payloadD),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n    /* function that(\n        bool must,\n        bool payloadA,\n        bool payloadB,\n        bool payloadC,\n        uint256 payloadD,\n        uint256 payloadE,\n        uint256 payloadF\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(\"\"),\n                        COLON,\n                        stringifyTruncated(\"BP\"),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        COMMA,\n                        stringify(payloadD),\n                        COMMA,\n                        stringify(payloadE),\n                        COMMA,\n                        stringify(payloadF),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    } */\n\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bool payloadA,\n        uint256 payloadB,\n        uint256 payloadC\n    )\n        internal\n        pure\n    {\n        uint256 num;\n        if (payloadA) {\n          num = 1;\n        } else {\n          num = 0;\n        }\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(num),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bool payloadA,\n        uint256 payloadB,\n        bool payloadC,\n        uint256 payloadD\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        COMMA,\n                        stringify(payloadD),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bool payloadA,\n        uint256 payloadB,\n        uint256 payloadC,\n        uint256 payloadD\n    )\n        internal\n        pure\n    {\n        uint256 num;\n        if (payloadA) {\n          num = 1;\n        } else {\n          num = 0;\n        }\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(num),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        COMMA,\n                        stringify(payloadD),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bool payloadA\n    )\n        internal\n        pure\n    {\n        uint256 num;\n        if (payloadA) {\n          num = 1;\n        } else {\n          num = 0;\n        }\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(num),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA,\n        uint256 payloadB\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA,\n        uint256 payloadB,\n        uint256 payloadC\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA,\n        address payloadB,\n        uint256 payloadC\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bytes32 payloadA\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bytes32 payloadA,\n        uint256 payloadB,\n        uint256 payloadC\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        uint256 payloadA,\n        uint256 payloadB,\n        uint256 payloadC\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA,\n        uint256 payloadB,\n        uint256 payloadC,\n        uint256 payloadD\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        COMMA,\n                        stringify(payloadD),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA,\n        address payloadB,\n        uint256 payloadC,\n        uint256 payloadD\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        COMMA,\n                        stringify(payloadD),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        uint256 payloadA,\n        uint256 payloadB,\n        uint256 payloadC,\n        uint256 payloadD\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        COMMA,\n                        stringify(payloadD),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    // ============ Private Functions ============\n\n    function stringifyTruncated(\n        bytes32 input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        // put the input bytes into the result\n        bytes memory result = abi.encodePacked(input);\n\n        // determine the length of the input by finding the location of the last non-zero byte\n        for (uint256 i = 32; i > 0; ) {\n            // reverse-for-loops with unsigned integer\n            /* solium-disable-next-line security/no-modify-for-iter-var */\n            i--;\n\n            // find the last non-zero byte in order to determine the length\n            if (result[i] != 0) {\n                uint256 length = i + 1;\n\n                /* solium-disable-next-line security/no-inline-assembly */\n                assembly {\n                    mstore(result, length) // r.length = length;\n                }\n\n                return result;\n            }\n        }\n\n        // all bytes are zero\n        return new bytes(0);\n    }\n\n    function stringify(\n        uint256 input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        if (input == 0) {\n            return \"0\";\n        }\n\n        // get the final string length\n        uint256 j = input;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n\n        // allocate the string\n        bytes memory bstr = new bytes(length);\n\n        // populate the string starting with the least-significant character\n        j = input;\n        for (uint256 i = length; i > 0; ) {\n            // reverse-for-loops with unsigned integer\n            /* solium-disable-next-line security/no-modify-for-iter-var */\n            i--;\n\n            // take last decimal digit\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\n\n            // remove the last decimal digit\n            j /= 10;\n        }\n\n        return bstr;\n    }\n\n    function stringify(\n        bool input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        uint256 num;\n        if (input) {\n          num = 1;\n        } else{\n          num = 0;\n        }\n        return stringify(num);\n    }\n\n    /* function stringify(\n        uint128 input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        return stringify(uint256(input));\n    } */\n\n    function stringify(\n        address input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        uint256 z = uint256(input);\n\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\n        bytes memory result = new bytes(42);\n\n        // populate the result with \"0x\"\n        result[0] = byte(uint8(ASCII_ZERO));\n        result[1] = byte(uint8(ASCII_LOWER_EX));\n\n        // for each byte (starting from the lowest byte), populate the result with two characters\n        for (uint256 i = 0; i < 20; i++) {\n            // each byte takes two characters\n            uint256 shift = i * 2;\n\n            // populate the least-significant character\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\n            z = z >> 4;\n\n            // populate the most-significant character\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\n            z = z >> 4;\n        }\n\n        return result;\n    }\n\n    function stringify(\n        bytes32 input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        uint256 z = uint256(input);\n\n        // bytes32 are \"0x\" followed by 32 bytes of data which take up 2 characters each\n        bytes memory result = new bytes(66);\n\n        // populate the result with \"0x\"\n        result[0] = byte(uint8(ASCII_ZERO));\n        result[1] = byte(uint8(ASCII_LOWER_EX));\n\n        // for each byte (starting from the lowest byte), populate the result with two characters\n        for (uint256 i = 0; i < 32; i++) {\n            // each byte takes two characters\n            uint256 shift = i * 2;\n\n            // populate the least-significant character\n            result[65 - shift] = char(z & FOUR_BIT_MASK);\n            z = z >> 4;\n\n            // populate the most-significant character\n            result[64 - shift] = char(z & FOUR_BIT_MASK);\n            z = z >> 4;\n        }\n\n        return result;\n    }\n\n    function char(\n        uint256 input\n    )\n        private\n        pure\n        returns (byte)\n    {\n        // return ASCII digit (0-9)\n        if (input < 10) {\n            return byte(uint8(input + ASCII_ZERO));\n        }\n\n        // return ASCII letter (a-f)\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\n    }\n}\n\n// File: contracts/interfaces/IErc20.sol\n\npragma solidity 0.5.15;\n\n\n/**\n * @title IErc20\n * @author dYdX\n *\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\n * that we don't automatically revert when calling non-compliant tokens that have no return value for\n * transfer(), transferFrom(), or approve().\n */\ninterface IErc20 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function totalSupply(\n    )\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(\n        address who\n    )\n        external\n        view\n        returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    )\n        external\n        view\n        returns (uint256);\n\n    function transfer(\n        address to,\n        uint256 value\n    )\n        external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external;\n\n    function approve(\n        address spender,\n        uint256 value\n    )\n        external;\n\n    function name()\n        external\n        view\n        returns (string memory);\n\n    function symbol()\n        external\n        view\n        returns (string memory);\n\n    function decimals()\n        external\n        view\n        returns (uint8);\n}\n\n// File: contracts/lib/Token.sol\n\npragma solidity 0.5.15;\n\n\n\n/**\n * @title Token\n * @author dYdX\n *\n * This library contains basic functions for interacting with ERC20 tokens. Modified to work with\n * tokens that don't adhere strictly to the ERC20 standard (for example tokens that don't return a\n * boolean value on success).\n */\nlibrary Token {\n\n    // ============ Constants ============\n\n    bytes32 constant FILE = \"\";\n\n    // ============ Library Functions ============\n\n    function balanceOf(\n        address token,\n        address owner\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return IErc20(token).balanceOf(owner);\n    }\n\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return IErc20(token).allowance(owner, spender);\n    }\n\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        IErc20(token).approve(spender, amount);\n\n        Require.that(\n            Require.checkSuccess(),\n            FILE,\n            \"0\"\n        );\n    }\n\n    function approveMax(\n        address token,\n        address spender\n    )\n        internal\n    {\n        approve(\n            token,\n            spender,\n            uint256(-1)\n        );\n    }\n\n    function transfer(\n        address token,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        IErc20(token).transfer(to, amount);\n\n        Require.that(\n            Require.checkSuccess(),\n            FILE,\n            \"1\"\n        );\n    }\n\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        IErc20(token).transferFrom(from, to, amount);\n\n        Require.that(\n            Require.checkSuccess(),\n            FILE,\n            \"2\"\n        );\n    }\n\n}\n\n// File: contracts/UniswapDyDxExchangeWrapper.sol\n\npragma solidity 0.5.15;\n\n\n\n\n\n\n\n\n\n\ninterface WETH9 {\n  function deposit() external payable;\n  function withdraw(uint wad) external;\n}\n\ncontract UniswapDydxExchangeWrapper is\n    Ownable,\n    ExchangeWrapper\n{\n    using SafeMath for uint256;\n    using AdvancedTokenInteract for address;\n\n\n    // ============ State Variables ============\n\n    address public UNISWAP_FACTORY;\n    address public WETH;\n\n\n    // ============ Constructor ===============\n    constructor(address _uniswapFactory, address _wethToken) public {\n        UNISWAP_FACTORY = _uniswapFactory;\n        WETH = _wethToken;\n    }\n\n    //============== Fallback ==================\n    function ()\n      external\n      payable\n    {\n      // need to be payable so that we can get tokens back from WETH9\n    }\n\n    // ============= Structs ===================\n\n    struct SwapInput {\n        address mainToken;\n        uint256 tokensSold;\n        uint256 minTokensBought;\n        address outToken;\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * Exchange some amount of takerToken for makerToken.\n     *\n     * @param  receiver             Address to set allowance on once the trade has completed\n     * @param  makerToken           Address of makerToken, the token to receive\n     * @param  takerToken           Address of takerToken, the token to pay\n     * @param  requestedFillAmount  Amount of takerToken being paid\n     * @param  orderData             Arbitrary bytes data for any information to pass to the exchange\n     * @return                      The amount of makerToken received\n     */\n    function exchange(\n        address tradeOriginator,\n        address receiver,\n        address makerToken,\n        address takerToken,\n        uint256 requestedFillAmount,\n        bytes calldata orderData\n    )\n        external\n        returns (uint256)\n    {\n        // use uniswap\n        uint256 deadline = now + (60 * 15);\n\n        if (takerToken == WETH) {\n\n            // unwrap weth\n            WETH9(WETH).withdraw(requestedFillAmount);\n\n            // get exchange address\n            address exchangeAddress = IUniFactory(UNISWAP_FACTORY).getExchange(makerToken);\n\n            // exchange\n            uint256 boughtTokens = IUni(exchangeAddress).ethToTokenSwapInput.value(requestedFillAmount)(0, deadline);\n\n            // approve\n            AdvancedTokenInteract.ensureAllowance(makerToken, receiver, boughtTokens);\n\n            // return token amount bought\n            return boughtTokens;\n        } else if (makerToken == WETH) {\n\n            // get exchange address\n            address exchangeAddress = IUniFactory(UNISWAP_FACTORY).getExchange(takerToken);\n            // approve\n            AdvancedTokenInteract.ensureAllowance(takerToken, exchangeAddress, requestedFillAmount);\n\n            // swap taker token for eth\n            uint256 eth_bought = IUni(exchangeAddress).tokenToEthSwapInput(requestedFillAmount, 0, deadline);\n\n            // wrap eth => WETH\n            WETH9(WETH).deposit.value(eth_bought)();\n\n            // approve receiver (dydx margin solo)\n            AdvancedTokenInteract.ensureAllowance(makerToken, receiver, eth_bought);\n\n            // return bought eth amount\n            return eth_bought;\n        } else {\n            // token => token\n            // should probably use curve here\n\n            SwapInput memory inputs = SwapInput({\n              mainToken: takerToken,\n              tokensSold: requestedFillAmount,\n              minTokensBought: 1,\n              outToken: makerToken\n            });\n\n            // get exchange address\n            address exchangeAddress = IUniFactory(UNISWAP_FACTORY).getExchange(inputs.mainToken);\n            // approve exchange\n            AdvancedTokenInteract.ensureAllowance(inputs.mainToken, exchangeAddress, requestedFillAmount);\n\n            uint256 minEthBought = 1; // intermediary not really needed\n\n            // swap\n            uint256 boughtTokens = IUni(exchangeAddress).tokenToTokenSwapInput(\n                inputs.tokensSold,\n                inputs.minTokensBought,\n                minEthBought,\n                deadline,\n                inputs.outToken\n            );\n\n            // approve\n            AdvancedTokenInteract.ensureAllowance(makerToken, receiver, boughtTokens);\n\n            // return token bought amount\n            return boughtTokens;\n        }\n    }\n\n    /**\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\n     * than desiredMakerToken\n     *\n     * @param  makerToken         Address of makerToken, the token to receive\n     * @param  takerToken         Address of takerToken, the token to pay\n     * @param  desiredMakerToken  Amount of makerToken requested\n     * @param  orderData           Arbitrary bytes data for any information to pass to the exchange\n     * @return                    Amount of takerToken the needed to complete the transaction\n     */\n    function getExchangeCost(\n        address makerToken,\n        address takerToken,\n        uint256 desiredMakerToken,\n        bytes calldata orderData\n    )\n        external\n        view\n        returns (uint256)\n    {\n        if (takerToken == WETH){\n          // unwrap and trade, dont dual trade.\n          // selling eth => token\n          address out_exchange = IUniFactory(UNISWAP_FACTORY).getExchange(makerToken);\n          // return needed ETH amount\n          return IUni(out_exchange).getEthToTokenOutputPrice(desiredMakerToken);\n        } else if (makerToken == WETH) {\n          // selling token => eth\n          address in_exchange = IUniFactory(UNISWAP_FACTORY).getExchange(takerToken);\n          // return needed token amount\n          return IUni(in_exchange).getTokenToEthOutputPrice(desiredMakerToken);\n        } else {\n          // true token => token\n          // should probably use curve here\n          // use uniswap\n          // ETH reserve size of the input ERC20 exchange\n          // ERC20 reserve size of the input ERC20 exchange\n          // ETH reserve size of the output ERC20 exchange\n          // ERC20 reserve size of the output ERC20 exchange\n          // Amount sold (input) or amount bought (output)\n          address in_exchange = IUniFactory(UNISWAP_FACTORY).getExchange(takerToken);\n          address out_exchange = IUniFactory(UNISWAP_FACTORY).getExchange(makerToken);\n          // out exchange_addr\n\n          uint256 eth_bought = IUni(out_exchange).getEthToTokenOutputPrice(desiredMakerToken);\n          // eth needed to be bought\n\n          uint256 taker_token_reserve = Token.balanceOf(takerToken, in_exchange);\n          // in token reserve\n          uint256 taker_eth_reserve = in_exchange.balance;\n\n          ////////////\n          // getOutputPrice(eth_bought, taker_token_reserve, taker_eth_reserve)\n          // eth_bought => output_amount\n          // taker_token_reserve => input_reserve\n          // taker_eth_reserve => output_reserve\n          uint256 numerator = taker_token_reserve * eth_bought * 1000;\n          uint256 denominator = (taker_eth_reserve - eth_bought) * 997;\n          return numerator / denominator + 1;\n        }\n    }\n\n     /**\n     * Get amount of makerToken to be received for a certain amount of takerTokens.\n\n     *\n     * @param  makerToken          Address of makerToken, the token to receive\n     * @param  takerToken          Address of takerToken, the token to pay\n     * @param  desiredTakerAmount  Amount of takerToken required to be sold\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\n     * @return                     Amount of makerToken to receive\n     */\n\n    function getExchangeCostSell(\n        address makerToken,\n        address takerToken,\n        uint256 desiredTakerAmount,\n        bytes calldata orderData\n    )\n        external\n        view\n        returns (uint256)\n    {\n        // use uniswap\n        // ETH reserve size of the input ERC20 exchange\n        // ERC20 reserve size of the input ERC20 exchange\n\n        // Amount sold (input) or amount bought (output)\n        if (takerToken == WETH){\n          // unwrap and trade, dont dual trade.\n          // selling eth => token\n          address out_exchange = IUniFactory(UNISWAP_FACTORY).getExchange(makerToken);\n          return IUni(out_exchange).getEthToTokenInputPrice(desiredTakerAmount);\n        } else if (makerToken == WETH) {\n          // selling token => eth\n          address in_exchange = IUniFactory(UNISWAP_FACTORY).getExchange(takerToken);\n          return IUni(in_exchange).getTokenToEthInputPrice(desiredTakerAmount);\n        } else {\n          // true token => token\n          // should probably use curve here\n          address in_exchange = IUniFactory(UNISWAP_FACTORY).getExchange(takerToken);\n          address out_exchange = IUniFactory(UNISWAP_FACTORY).getExchange(makerToken);\n          uint256 eth_bought = IUni(in_exchange).getTokenToEthInputPrice(desiredTakerAmount);\n          uint256 maker_token_reserve = Token.balanceOf(makerToken, out_exchange);\n          uint256 maker_eth_reserve = out_exchange.balance;\n          uint256 numerator = maker_token_reserve * eth_bought * 1000;\n          uint256 denominator = (maker_eth_reserve - eth_bought) * 997;\n          return  numerator / denominator + 1;\n        }\n    }\n\n    function suicideMe()\n      public\n      onlyOwner\n    {\n      uint256 wethBalance = Token.balanceOf(WETH, address(this));\n      if (wethBalance > 0) {\n        WETH9(WETH).withdraw(wethBalance);\n      }\n      selfdestruct(address(uint160(owner())));\n    }\n\n}\n"}}}