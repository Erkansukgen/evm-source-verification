{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ddd.sol":{"content":"pragma solidity 0.7.1;\n//  mainnet 0x2a1c5eafc10aa9fb4080d9841a117ecbcfa847f1\n// kyber https://developer.kyber.network/docs/API_ABI-KyberNetworkProxy/\n// balancer https://soliditydeveloper.com/balancer\n\n// example 0x906681829b1b89b4d5b4907dc64de5db1d367311\n// https://kovan.etherscan.io/address/0x906681829b1b89b4d5b4907dc64de5db1d367311#writeContract\n// getSwapFee\n// getspotprice\n// approve ->\n// swapExactAmountIn tokenaddress tokenamountin tokenoutaddress minamountout maxprice\n// getBalance tokenaddress\n\n\nimport \"https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Pair.sol\";\n\n/**\n * import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\n*/\n\n\n\n\n\ninterface ERC20 {\n    function approve(address _spender, uint _value)  external returns (bool success);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function balanceOf(address tokenOwner) external  returns (uint balance);\n    function deposit() external payable;\n    function withdraw(uint) external;\n    function allowance(address, address) external returns (uint);\n\n}\n\n\ncontract BalancerUniSushi {\n \n\n\n  address WETH_Address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    \n    address  internal  owner1 = 0x8cb8E8508c686105bf34B0bAFC5E7Eb4BE40860B;\n    address  internal  owner2 = 0x60e2CB9C426500058b936981c547C3640C8A4752;\n    address  internal  owner3 = 0x90d1aeA7d7D7A38d8bF445308651FD4aa132d6b3;\n    address  internal  owner4 = 0x6211dB72f3A8d4B23856A32Caa523CbA3Fcc01dc;\n    address  internal  owner5 = 0xaDb3aD87bDad5413B70dd725c0BFF86B8a89a2C2;\n    address  internal  owner6 = 0x7958B6447E6B8AAa5515CE3AA4D8d50b0595395e;\n    address  internal  owner7 = 0x9355af7C24F792CE9A8c7d2f4954BEcF33B4cd7d;\n    address  internal  owner8 = 0x11565fBA6Da098c82ABfF5e05cecDfD22B15d2F7;\n    address  internal  owner9 = 0xEd9b85F3EF94b6FBDf73BF999B327543842283B9;\n    address  internal  owner10 = 0x703fdad1d0AfCF7EeEB3176D6546F1A90fAfAD40;\n\n\n\n\n\nconstructor() { \n    \n}\n\nmodifier onlyOwner() {\n    if(owner1 == msg.sender || owner2 == msg.sender || owner3 == msg.sender || owner4 == msg.sender || owner5 == msg.sender || owner6 == msg.sender || owner7 == msg.sender || owner8 == msg.sender || owner9 == msg.sender || owner10 == msg.sender) _;\n}\n\n\n\n  function withdrawETHAndTokens() public onlyOwner{\n        ERC20 WETH = ERC20(WETH_Address);\n        uint wethBalance = WETH.balanceOf(address(this));\n\n    if (wethBalance > 0) {\n        // refund leftover ETH\n      WETH.transfer( msg.sender, WETH.balanceOf(address(this)));\n\n    }\n\n       // WETH.transfer( msg.sender, WETH.balanceOf(address(this)));\n    msg.sender.send(address(this).balance);\n    }\n\n    function withdrawExactETH(uint Am) public onlyOwner {\n    msg.sender.send(Am);\n    }\n\n  \n\n    function withdrawExactToken(address me) public onlyOwner {\n    ERC20 SendMe = ERC20(me);\n\n\n    SendMe.transfer( msg.sender, SendMe.balanceOf(address(this)));\n        //require(success, \"ERR_ETH_FAILED\");\n    \n       // WETH.transfer( msg.sender, WETH.balanceOf(address(this)));\n    }\n\n   function withdrawExactTokenWithAm(address me, uint Am) public onlyOwner {\n\n     ERC20 SendMe = ERC20(me);\n\n\n     SendMe.transfer( msg.sender, Am);\n        //require(success, \"ERR_ETH_FAILED\");\n    \n       // WETH.transfer( msg.sender, WETH.balanceOf(address(this)));\n    }\n\n\n   \n\n\n\n\n    // refund leftover ETH to user\n //   (bool success,) = msg.sender.call{ value: address(this).balance }(\"\");\n //   require(success, \"refund failed\");\n  \n   \n   // uint256 currentTokenBalance = WETH.balanceOf(address(this));\n   // WETH.transfer(msg.sender, currentTokenBalance);\n  \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n   \n   \n     bytes data = new bytes(0) ;\n   \n \n   \n    function doswapone(uint256 amin, address token,  uint256 amout, address pair) public onlyOwner {\n        IUniswapV2Pair ipair = IUniswapV2Pair(pair);\n        ERC20 itoken = ERC20(token);\n       \n        itoken.approve(address(this),amin);\n         \n        itoken.transferFrom(address(this),pair,amin);\n        ipair.swap(amout,0,address(this),data);\n     \n    }\n\n    function doswaponenoapprove(uint256 amin, address token,  uint256 amout, address pair) public onlyOwner {\n        IUniswapV2Pair ipair = IUniswapV2Pair(pair);\n        ERC20 itoken = ERC20(token);         \n        itoken.transferFrom(address(this),pair,amin);\n        ipair.swap(amout,0,address(this),data);\n     \n    }\n\n\n\n\n    function doswapzero(uint256 amin, address token,   uint256 amout, address pair) public onlyOwner {\n        IUniswapV2Pair ipair = IUniswapV2Pair(pair);\n        ERC20 itoken = ERC20(token);\n       \n      \n        itoken.approve(address(this),amin);\n\n        itoken.transferFrom(address(this),pair,amin);\n        ipair.swap(0,amout,address(this),data);\n//   IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n //               amount0Out, amount1Out, to, new bytes(0)\n\n        \n    }\n\n \n \n \n \n \n\n    function doswapzeroall(address token,   uint256 amout, address pair) public onlyOwner {\n        IUniswapV2Pair ipair = IUniswapV2Pair(pair);\n        ERC20 itoken = ERC20(token);\n        uint MyBalance = itoken.balanceOf(address(this));\n\n      \n        itoken.approve(address(this),MyBalance);\n\n        itoken.transferFrom(address(this),pair,MyBalance);\n        ipair.swap(0,amout,address(this),data);\n//   IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n //               amount0Out, amount1Out, to, new bytes(0)\n\n        \n    }\n\n \n \n \n \n     function doswaponeall(address token,  uint256 amout, address pair) public onlyOwner {\n        IUniswapV2Pair ipair = IUniswapV2Pair(pair);\n        ERC20 itoken = ERC20(token);\n        uint MyBalance = itoken.balanceOf(address(this));\n\n        itoken.approve(address(this),MyBalance);\n         \n        itoken.transferFrom(address(this),pair,MyBalance);\n        ipair.swap(amout,0,address(this),data);\n     \n    }\n \n \n \n \n \n \n \n \n  \n  \n\n // function getEstimatedETHforDAI(uint daiAmount) public view returns (uint[] memory) {\n //   return uniswapRouter.getAmountsIn(daiAmount, getPathForTokens(uniswapRouter.WETH(),uniswapRouter.WETH()));\n // }\n\n\n  // important to receive ETH\n  receive() external payable {}\n}"},"https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Pair.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"}}}