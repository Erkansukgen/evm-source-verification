{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/router.sol": {
      "content": "/*\nPlease note, there are 3 native components to this token design. Token, Router, and Core. \nEach component is deployed separately as an external contract.\n\nThis is the main code of a mutable token contract.\nThe Router component is the mutable part and it can be re-routed should there be any code updates.\nAny other contract is also external and it must be additionally registered and routed within the native components.\nThe main idea of this design was to follow the adjusted Proxy and the MVC design patterns.\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity = 0.7 .4;\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns(address payable) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns(bytes memory) {\n    this;\n    return msg.data;\n  }\n}\n\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  function owner() public view returns(address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\ninterface IERC20 {\n  function currentCoreContract() external view returns(address routerAddress);\n\n  function currentTokenContract() external view returns(address routerAddress);\n\n  function getExternalContractAddress(string memory contractName) external view returns(address routerAddress);\n\n  function callRouter(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\n\n  function _callRouter(string memory route, address[3] memory addressArr, uint[3] memory uintArr) external returns(bool success);\n\n  function extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\n\n  function _extrenalRouterCall(string memory route, address[3] memory addressArr, uint[3] memory uintArr) external returns(bool success);\n\n}\n\nabstract contract Core {\n\n  // native core functions\n\n  function transfer(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n  function approve(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n  function increaseAllowance(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n  function decreaseAllowance(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n  function transferFrom(address[3] memory addressArr, uint[3] memory uintArr) external virtual returns(bool success);\n\n  //non-native core functions\n\n  function mint(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n  function burn(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n  function updateTotalSupply(uint[2] memory uintArr) external virtual returns(bool success);\n\n  function updateCurrentSupply(uint[2] memory uintArr) external virtual returns(bool success);\n\n  function updateJointSupply(uint[2] memory uintArr) external virtual returns(bool success);\n\n}\n\nabstract contract Token {\n  function allowance(address owner, address spender) external view virtual returns(uint256 data);\n}\n\n//============================================================================================\n// MAIN CONTRACT \n//============================================================================================\n\ncontract Router is Ownable, IERC20 {\n\n  uint lastBlock = block.number;\n  address public tokenContract;\n  address public coreContract;\n\n  Core private core;\n  Token private token;\n\n  mapping(string => address) public externalContracts; //for non-native functions\n\n  //============== NATIVE FUNCTIONS START HERE ==================================================\n  //These functions should never change when introducing a new version of a router.\n  //Router is expected to constantly change, and the code should be written under \n  //the \"NON-CORE FUNCTIONS TO BE CODED BELOW\".\n\n  function equals(string memory a, string memory b) internal view virtual returns(bool isEqual) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n\n  function currentTokenContract() override external view virtual returns(address routerAddress) {\n    return tokenContract;\n  }\n\n  function currentCoreContract() override external view virtual returns(address routerAddress) {\n    return coreContract;\n  }\n\n  function getExternalContractAddress(string memory contractName) override external view virtual returns(address routerAddress) {\n    return externalContracts[contractName];\n  }\n\n  //function is not needed if token address is hard-coded in a constructor\n  function setNewTokenContract(address newTokenAddress) onlyOwner public virtual returns(bool success) {\n    tokenContract = newTokenAddress;\n    token = Token(tokenContract);\n    return true;\n  }\n\n  function setNewCoreContract(address newCoreAddress) onlyOwner public virtual returns(bool success) {\n    coreContract = newCoreAddress;\n    core = Core(coreContract);\n    return true;\n  }\n\n  function setNewExternalContract(string memory contractName, address newContractAddress) onlyOwner public virtual returns(bool success) {\n    externalContracts[contractName] = newContractAddress;\n    return true;\n  }\n\n  function callRouter(string memory route, address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success) {\n    require(msg.sender == tokenContract, \"router:callRouter:token contract not registered\");\n\n    require(block.number > lastBlock, \"router: Too many transactions, please wait 12-20 seconds\");\n\n    if (equals(route, \"transfer\")) {\n      require(core.transfer(addressArr, uintArr), \"router:callRouter:transfer\");\n    } else if (equals(route, \"approve\")) {\n      require(core.approve(addressArr, uintArr), \"router:callRouter:approve\");\n    } else if (equals(route, \"increaseAllowance\")) {\n      require(core.increaseAllowance(addressArr, uintArr), \"router:callRouter:increaseAllowance\");\n    } else if (equals(route, \"decreaseAllowance\")) {\n      require(core.decreaseAllowance(addressArr, uintArr), \"router:callRouter:decreaseAllowance\");\n    }\n\n    lastBlock = block.number;\n    return true;\n  }\n\n  function _callRouter(string memory route, address[3] memory addressArr, uint[3] memory uintArr) override external virtual returns(bool success) {\n\n    require(msg.sender == tokenContract, \"at: router.sol | contract: Router | function: _callRouter | message: Must be called by the registered Token contract\");\n    require(block.number > lastBlock, \"router: Too many transactions, please wait 12-20 seconds\");\n\n    if (equals(route, \"transferFrom\")) {\n      require(core.transferFrom(addressArr, uintArr), \"router:_callRouter:transferFrom\");\n    }\n\n    lastBlock = block.number;\n    return true;\n  }\n\n  //============== NATIVE FUNCTIONS END HERE ==================================================\n\n  //=============== NON-NATIVE ROUTES TO BE CODED BELOW =======================================\n  // This code is a subject to a change, should we decide to alter anything.\n  // We can also design another external router, possibilities are infinite.\n\n  function extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success) {\n\n    require(block.number > lastBlock, \"router: Too many transactions, please wait 12-20 seconds\");\n\n    require(externalContracts[route] == msg.sender, \"at: router.sol | contract: Router | function: extrenalRouterCall | message: Must be called by the registered external contract\");\n\n    //WARNING! This kind of a design exposes a danger with old contracts, if linked, to execute the functions. Must be properly maintained.\n    //also, we must be careful about the substrings  not to mess up the function calls\n    if (substringOf(route, \"mint\")) {\n      require(core.mint(addressArr, uintArr));\n    } else if (substringOf(route, \"burn\")) {\n      require(core.burn(addressArr, uintArr), \"router:extrenalRouterCall:burn\");\n    } else if (substringOf(route, \"updateTotalSupply\")) {\n      require(core.updateTotalSupply(uintArr), \"router:extrenalRouterCall:updateTotalSupply\");\n    } else if (substringOf(route, \"updateCurrentSupply\")) {\n      require(core.updateCurrentSupply(uintArr), \"router:extrenalRouterCall:updateCurrentSupply\");\n    } else if (substringOf(route, \"updateJointSupply\")) {\n      require(core.updateJointSupply(uintArr), \"router:extrenalRouterCall:updateJointSupply\");\n    } else if (substringOf(route, \"transfer\")) {\n      require(core.transfer(addressArr, uintArr), \"router:extrenalRouterCall:transfer\");\n    } else if (substringOf(route, \"approve\")) {\n      require(core.approve(addressArr, uintArr), \"router:extrenalRouterCall:approve\");\n    } else if (substringOf(route, \"increaseAllowance\")) {\n      require(core.increaseAllowance(addressArr, uintArr), \"router:extrenalRouterCall:increaseAllowance\");\n    } else if (substringOf(route, \"decreaseAllowance\")) {\n      require(core.decreaseAllowance(addressArr, uintArr), \"router:extrenalRouterCall:decreaseAllowance\");\n    }\n\n    lastBlock = block.number;\n\n    return true;\n  }\n\n  function _extrenalRouterCall(string memory route, address[3] memory addressArr, uint[3] memory uintArr) override external virtual returns(bool success) {\n\n    require(block.number > lastBlock, \"router: Too many transactions, please wait 12-20 seconds\");\n\n    require(externalContracts[route] == msg.sender, \"at: router.sol | contract: Router | function: _extrenalRouterCall | message: Must be called by the registered external contract\");\n\n    //WARNING! This kind of a design exposes a danger with old contracts, if linked, to execute the functions. Must be properly maintained.\n    //also, we must be careful about the substrings  not to mess up the function calls\n    if (substringOf(route, \"transferFrom\")) {\n      require(core.transferFrom(addressArr, uintArr), \"router:_extrenalRouterCall:transferFrom\");\n    }\n\n    lastBlock = block.number;\n\n    return true;\n  }\n\n  //string comparison used to generalize the functions called by multiple contracts\n  function substringOf(string memory _haystack, string memory _needle) public pure returns(bool t) {\n    bytes memory h = bytes(_haystack);\n    bytes memory n = bytes(_needle);\n    if (h.length < 1 || n.length < 1 || (n.length > h.length))\n      return false;\n    else if (h.length > (2 ** 128 - 1))\n      return false;\n    else {\n      uint subindex = 0;\n      for (uint i = 0; i < h.length; i++) {\n        if (h[i] == n[0]) {\n          subindex = 1;\n          while (subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) {\n            subindex++;\n          }\n          if (subindex == n.length)\n            return true;\n        }\n      }\n      return false;\n    }\n  }\n}"
    }
  }
}