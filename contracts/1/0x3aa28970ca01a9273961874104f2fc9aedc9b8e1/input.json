{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/profits-v1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20Token {\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n}\n\ninterface IERC721 {\n\n    function setPaymentDate(uint256 _asset) external;\n    function getTokenDetails(uint256 index) external view returns (uint128 lastvalue, uint32 aType, uint32 customDetails, uint32 lastTx, uint32 lastPayment);\n    function polkaCitizens() external view returns(uint256 _citizens);\n    function assetsByType(uint256 _assetType) external view returns (uint64 maxAmount, uint64 mintedAmount, uint128 baseValue);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n}\n\ncontract Ownable {\n\n    address private owner;\n    \n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}\n\ncontract PolkaProfitContract is Ownable {\n    event Datediff(uint _lasttx, uint _timestamp);\n    bool public paused;\n    \n    struct paymentByType {\n        uint256 weeklyPayment;\n        uint256 variantFactor; \n        uint256 basePriceFactor;\n    }\n    \n    mapping (address => bool) public blackListed;\n    mapping (uint256 => paymentByType) public paymentAmount;\n    address public nftAddress = 0x57E9a39aE8eC404C08f88740A9e6E306f50c937f;\n    address public tokenAddress = 0xaA8330FB2B4D5D07ABFE7A72262752a8505C6B37;\n    address public walletAddress = 0xdA595384d33CE4aFb69E8Da6490B6123DF33ee68;\n    \n    constructor() {\n        fillPayments(1,    60000000000000000000, 10, 15000000000000);\n        fillPayments(2,   135000000000000000000, 10, 30000000000000);\n        fillPayments(3,   375000000000000000000, 10, 75000000000000);\n        fillPayments(4,   550000000000000000000, 10, 100000000000000);\n        fillPayments(5,   937500000000000000000, 10, 150000000000000);\n        fillPayments(6,  8250000000000000000000, 10, 750000000000000);\n        fillPayments(7,  6500000000000000000000, 10, 655000000000000);\n        fillPayments(8,  3000000000000000000000, 20, 400000000000000);\n        fillPayments(9, 10800000000000000000000, 50, 900000000000000);\n        fillPayments(10, 5225000000000000000000, 30, 550000000000000);\n        fillPayments(11,13125000000000000000000, 20, 1050000000000000);\n        fillPayments(12, 4500000000000000000000, 10, 500000000000000);\n        fillPayments(13, 1500000000000000000000, 10, 225000000000000);\n        fillPayments(14, 2100000000000000000000, 15, 300000000000000);\n        fillPayments(15, 3750000000000000000000, 10, 450000000000000);\n    }\n    \n    function fillPayments(uint256 _assetId, uint256 _weeklyPayment, uint256 _variantFactor, uint256 _basePriceFactor) private {\n        paymentAmount[_assetId].weeklyPayment = _weeklyPayment;\n        paymentAmount[_assetId].variantFactor = _variantFactor;\n        paymentAmount[_assetId].basePriceFactor = _basePriceFactor;\n    }\n    \n    function claimProfit(uint256 _assetId) public returns (bool success) {\n        require(paused == false, \"Contract is paused\");\n        IERC721 nft = IERC721(nftAddress);\n        address assetOwner = nft.ownerOf(_assetId);\n        require(assetOwner == msg.sender, \"Only asset owner can claim profits\");\n        require(blackListed[assetOwner] == false, \"This address cannot claim profits\");\n        (uint256 totalPayment, uint256 lastPayment) = calcProfit(_assetId);\n        require (totalPayment > 0, \"You need to wait at least 1 week to claim\");\n        nft.setPaymentDate(_assetId);\n        IERC20Token token = IERC20Token(tokenAddress);\n        require(token.transferFrom(walletAddress, assetOwner, totalPayment), \"ERC20 transfer fail\");\n        emit Datediff(lastPayment, block.timestamp);\n        return true;\n    }\n    \n    function calcProfit(uint256 _assetId) public view returns (uint256 _profit, uint256 _lastPayment) {\n        IERC721 nft = IERC721(nftAddress);\n        ( , uint32 assetType,,, uint32 lastPayment ) = nft.getTokenDetails(_assetId);\n        uint256 timeFrame = block.timestamp - lastPayment;\n        if (timeFrame < (1 weeks)) {\n            return (0, lastPayment);\n        } else {\n            uint256 weekCount = timeFrame/(1 weeks);\n            uint256 daysCount = timeFrame/(1 days);\n            uint256 variantCount;\n            if (assetType == 8 || assetType == 15) {\n                variantCount = countTaxis();\n            } else {\n                variantCount = nft.polkaCitizens();\n            }\n            uint256 totalPayment;\n            paymentByType memory thisPayment = paymentAmount[uint256(assetType)];\n            uint256 dailyProfit = ((thisPayment.basePriceFactor*(variantCount*thisPayment.variantFactor))/30)*daysCount;\n            totalPayment = ((weekCount * thisPayment.weeklyPayment) + dailyProfit);\n            return (totalPayment, lastPayment);    \n        }\n\n    }\n    \n    function calcTotalEarnings(uint256 _assetId) public view returns (uint256 _profit, uint256 _lastPayment) {\n        IERC721 nft = IERC721(nftAddress);\n        ( , uint32 assetType,, uint32 lastTransfer, ) = nft.getTokenDetails(_assetId);\n        uint256 timeFrame = block.timestamp - lastTransfer;\n        if (timeFrame < (1 weeks)) {\n            return (0, lastTransfer);\n        } else {\n            uint256 weekCount = timeFrame/(1 weeks);\n            uint256 daysCount = timeFrame/(1 days);\n            uint256 variantCount;\n            if (assetType == 8 || assetType == 15) {\n                variantCount = countTaxis();\n            } else {\n                variantCount = nft.polkaCitizens();\n            }\n            uint256 totalPayment;\n            paymentByType memory thisPayment = paymentAmount[uint256(assetType)];\n            uint256 dailyProfit = ((thisPayment.basePriceFactor*(variantCount*thisPayment.variantFactor))/30)*daysCount;\n            totalPayment = ((weekCount * thisPayment.weeklyPayment) + dailyProfit);\n            return (totalPayment, lastTransfer);    \n        }\n\n    }\n    \n    function countTaxis() private view returns (uint256 taxis) {\n        uint256 taxiCount = 0;\n        uint64 assetMinted;\n        IERC721 nft = IERC721(nftAddress);\n        (, assetMinted,) = nft.assetsByType(1);\n        taxiCount += uint256(assetMinted);\n        (, assetMinted,) = nft.assetsByType(2);\n        taxiCount += uint256(assetMinted);\n        (, assetMinted,) = nft.assetsByType(3);\n        taxiCount += uint256(assetMinted);\n        (, assetMinted,) = nft.assetsByType(4);\n        taxiCount += assetMinted;\n        (, assetMinted,) = nft.assetsByType(5);\n        taxiCount += uint256(assetMinted);\n        return taxiCount;\n    }\n\n    \n    function pauseContract(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n    \n    function blackList(address _wallet, bool _blacklist) public onlyOwner {\n        blackListed[_wallet] = _blacklist;\n    }\n\n    \n}\n"
    }
  }
}