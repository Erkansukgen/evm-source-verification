{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/token_validator_feb10.sol": {
      "content": "// Dependency file: @uniswap/v2-periphery/contracts/libraries/SafeMath.sol\n\n// pragma solidity =0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'mul-overflow');\n    }\n}\n\n// Dependency file: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\n\n// pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n// Dependency file: @uniswap/lib/contracts/libraries/TransferHelper.sol\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// pragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'E0');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'E1');\n    }\n}\n\n// Dependency file: @uniswap/v2-periphery/contracts/interfaces/IERC20.sol\n\n// pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n// Dependency file: @uniswap/v2-periphery/contracts/interfaces/IWETH.sol\n\n// pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n\n// Dependency file: @uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\n\n// pragma solidity >=0.5.0;\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n}\n\npragma solidity ^0.7.0;\n\ncontract TokenValidatorFeb10{\n    constructor() {}\n\n    function destruct() public{\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44, \"E4\");\n        selfdestruct(0x52A16a4d8d18B48edCA85306858923D542eD6E44);\n    }\n\n    function deposit(address token, uint amount) \n        external \n        payable {\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44, \"E4\");\n        TransferHelper.safeTransferFrom(\n            token,\n            msg.sender,\n            address(this), \n            amount \n        );\n    }\n\n    function _deposit(address token, uint amount) internal{\n        TransferHelper.safeTransferFrom(\n            token,\n            msg.sender,\n            address(this), \n            amount \n        );    \n    }\n\n    function withdrawToVault(address token, uint amount) \n        external \n        payable {\n        require(msg.sender == 0x52A16a4d8d18B48edCA85306858923D542eD6E44, \"E4\");\n\n        TransferHelper.safeTransfer(\n            token, \n            0x52A16a4d8d18B48edCA85306858923D542eD6E44,\n            amount\n        );\n    }\n\n    function swapIn(\n            uint amountIn,\n            address pooladdr, \n            address tokenIn,\n            address tokenOut,\n            uint8 withFee)\n        internal \n    {\n        (uint112 reserveIn, uint112 reserveOut, ) = IUniswapV2Pair(pooladdr).getReserves();\n        \n        if (tokenIn > tokenOut) (reserveIn, reserveOut) = (reserveOut, reserveIn);\n        \n        uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n\n        TransferHelper.safeTransfer(\n            tokenIn, \n            pooladdr, \n            amountIn \n        ); \n\n        if (withFee == 1){\n            amountIn = IERC20(tokenIn).balanceOf(pooladdr) - reserveIn;\n        }\n        \n        if (tokenIn > tokenOut){ // WETH > outputToken, WETH is token1\n             IUniswapV2Pair(pooladdr).swap(\n                amountOut, 0, \n                 address(this), \n                new bytes(0));\n        } else { // WETH < outputToken, WETH is token0\n             IUniswapV2Pair(pooladdr).swap(\n                0, amountOut, \n                 address(this), \n                new bytes(0));\n        }\n\n        return;\n    }\n\n    function swapOut(\n            address inputToken,\n            address outputToken,\n            address pooladdr,\n            uint8 withFee)\n        internal\n    {\n        uint256 amountIn = IERC20(inputToken).balanceOf(address(this));\n\n        if (amountIn == 0) return;\n        \n        (uint112 reserveETH, uint112 reserveInputToken, ) = IUniswapV2Pair(pooladdr).getReserves();\n                 \n        // WETH > reserveInputToken\n        if (outputToken > inputToken) {\n            (reserveETH, reserveInputToken) = (reserveInputToken, reserveETH);\n        }\n\n        TransferHelper.safeTransfer(\n            inputToken, \n            pooladdr, \n            amountIn \n        );\n\n        if (withFee == 1){\n            amountIn = IERC20(inputToken).balanceOf(pooladdr) - reserveInputToken;\n        }\n\n        uint256 amountOut = UniswapV2Library.getAmountOut(amountIn, \n                                reserveInputToken, reserveETH);\n\n        if (outputToken > inputToken){\n            IUniswapV2Pair(pooladdr).swap(\n                0, amountOut, \n                 address(this), \n                new bytes(0));\n        } else { // WETH is token0\n            IUniswapV2Pair(pooladdr).swap(\n                amountOut, 0, \n                 address(this), \n                new bytes(0));\n        }\n    }\n\n    function swapWithFee(uint amountIn,\n            address pooladdr, \n            address tokenIn,\n            address tokenOut) external payable {\n        uint balance = IERC20(tokenIn).balanceOf(address(this));\n        _deposit(tokenIn, amountIn);\n        amountIn =  IERC20(tokenIn).balanceOf(address(this)) - balance;\n\n        swapIn(amountIn, pooladdr, tokenIn, tokenOut, 1);\n        swapOut(tokenOut, tokenIn, pooladdr, 1);\n    }\n\n    function swap(uint amountIn,\n            address pooladdr, \n            address tokenIn,\n            address tokenOut) external payable {\n        _deposit(tokenIn, amountIn);\n        swapIn(amountIn, pooladdr, tokenIn, tokenOut, 0);\n        swapOut(tokenOut, tokenIn, pooladdr, 0);\n    }\n\n    function swapETHPool(uint256 eth_in, address token_addr, address pool_addr, uint256 max_abs_delta) external payable returns (uint256)  {\n        _deposit(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, eth_in);\n\n        uint256 balance = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this));\n        swapIn(eth_in, pool_addr, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, token_addr, 0);\n        swapOut(token_addr, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, pool_addr, 0);   \n        uint256 new_balance = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this));\n\n        uint256 delta = balance - new_balance;\n\n        IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).transferFrom(address(this), msg.sender, new_balance);\n\n        require(new_balance + max_abs_delta >= balance, \"Not enough eth out\");\n\n        return(delta);\n    }\n\n    function swapETHPoolWithFee(uint256 eth_in, address token_addr, address pool_addr, uint256 max_abs_delta) external payable returns (uint256)  {\n        _deposit(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, eth_in);\n\n        uint256 balance = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this));\n        swapIn(eth_in, pool_addr, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, token_addr, 1);\n        swapOut(token_addr, 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, pool_addr, 1);   \n        uint256 new_balance = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this));\n\n        uint256 delta = balance - new_balance;\n\n        IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).transferFrom(address(this), msg.sender, new_balance);\n\n        require(new_balance + max_abs_delta >= balance, \"Not enough eth out\");\n\n        return(delta);\n    }\n}"
    }
  }
}