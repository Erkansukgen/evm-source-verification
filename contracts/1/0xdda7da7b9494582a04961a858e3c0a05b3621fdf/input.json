{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/Logic.sol":{"content":"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\n\nstruct Action {\n    ActionType actionType;\n    bytes32 protocolName;\n    uint256 adapterIndex;\n    address[] tokens;\n    uint256[] amounts;\n    AmountType[] amountTypes;\n    bytes data;\n}\n\n\nstruct Approval {\n    address token;\n    uint256 amount;\n    AmountType amountType;\n    uint256 nonce;\n}\n\n\nenum ActionType { None, Deposit, Withdraw }\n\n\nenum AmountType { None, Relative, Absolute }\n\n\n/**\n * @title Protocol adapter interface.\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract ProtocolAdapter {\n\n    /**\n     * @dev MUST return \"Asset\" or \"Debt\".\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function adapterType() external pure virtual returns (bytes32);\n\n    /**\n     * @dev MUST return token type (default is \"ERC20\").\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function tokenType() external pure virtual returns (bytes32);\n\n    /**\n     * @dev MUST return amount of the given token locked on the protocol by the given account.\n     */\n    function getBalance(address token, address account) public view virtual returns (uint256);\n}\n\n\n/**\n * @title Base contract for interactive protocol adapters.\n * @dev deposit() and withdraw() functions MUST be implemented\n * as well as all the functions from ProtocolAdapter interface.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract InteractiveAdapter is ProtocolAdapter {\n\n    uint256 internal constant RELATIVE_AMOUNT_BASE = 1e18;\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /**\n     * @dev The function must deposit assets to the protocol.\n     * @return MUST return assets to be sent back to the `msg.sender`.\n     */\n    function deposit(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory data\n    )\n        public\n        payable\n        virtual\n        returns (address[] memory);\n\n    /**\n     * @dev The function must withdraw assets from the protocol.\n     * @return MUST return assets to be sent back to the `msg.sender`.\n     */\n    function withdraw(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory data\n    )\n        public\n        payable\n        virtual\n        returns (address[] memory);\n\n    function getAbsoluteAmountDeposit(\n        address token,\n        uint256 amount,\n        AmountType amountType\n    )\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (amountType == AmountType.Relative) {\n            require(amount <= RELATIVE_AMOUNT_BASE, \"L: wrong relative value!\");\n\n            uint256 totalAmount;\n            if (token == ETH) {\n                totalAmount = address(this).balance;\n            } else {\n                totalAmount = ERC20(token).balanceOf(address(this));\n            }\n\n            if (amount == RELATIVE_AMOUNT_BASE) {\n                return totalAmount;\n            } else {\n                return totalAmount * amount / RELATIVE_AMOUNT_BASE; // TODO overflow check\n            }\n        } else {\n            return amount;\n        }\n    }\n\n    function getAbsoluteAmountWithdraw(\n        address token,\n        uint256 amount,\n        AmountType amountType\n    )\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (amountType == AmountType.Relative) {\n            require(amount <= RELATIVE_AMOUNT_BASE, \"L: wrong relative value!\");\n\n            if (amount == RELATIVE_AMOUNT_BASE) {\n                return getBalance(token, address(this));\n            } else {\n                return getBalance(token, address(this)) * amount / RELATIVE_AMOUNT_BASE; // TODO overflow check\n            }\n        } else {\n            return amount;\n        }\n    }\n}\n\n\ninterface ERC20 {\n    function approve(address, uint256) external returns (bool);\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n}\n\n\ncontract SignatureVerifier {\n    mapping (address => uint256) public nonces;\n\n    bytes32 public immutable domainSeparator = keccak256(\n        abi.encode(\n            DOMAIN_SEPARATOR_TYPEHASH,\n            address(this)\n        )\n    );\n\n    // 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f\n    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH = keccak256(\n        abi.encodePacked(\n            \"EIP712Domain(\",\n            \"address verifyingContract\",\n            \")\"\n        )\n    );\n\n    bytes32 public constant APPROVAL_TYPEHASH = keccak256(\n        abi.encodePacked(\n            \"Approval(\",\n            \"address token,\",\n            \"uint256 amount,\",\n            \"uint8 amountType,\",\n            \"uint256 nonce\",\n            \")\"\n        )\n    );\n\n    /// @return Hash to be signed by assets supplier.\n    function hashApproval(\n        Approval memory approval\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 approvalHash = keccak256(\n            abi.encode(\n                APPROVAL_TYPEHASH,\n                approval.token,\n                approval.amount,\n                approval.amountType,\n                approval.nonce\n            )\n        );\n\n        return keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x01),\n                domainSeparator,\n                approvalHash\n            )\n        );\n    }\n\n    function getUserFromSignatures(\n        Approval[] memory approvals,\n        bytes[] memory signatures\n    )\n        internal\n        returns (address payable)\n    {\n        address initialSigner = getUserFromSignature(approvals[0], signatures[0]);\n        require(nonces[initialSigner] == approvals[0].nonce, \"SV: wrong nonce!\");\n\n        address signer;\n        for (uint256 i = 1; i < approvals.length; i++) {\n            signer = getUserFromSignature(approvals[i], signatures[i]);\n            require(initialSigner == signer, \"SV: wrong sig!\");\n            require(nonces[signer] == approvals[i].nonce, \"SV: wrong nonce!\");\n        }\n\n        nonces[initialSigner]++;\n        return payable(initialSigner);\n    }\n\n    function getUserFromSignature(\n        Approval memory approval,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address)\n    {\n        require(signature.length == 65, \"SV: wrong sig length!\");\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // solhint-disable-next-line no-inline-assembly\n        // solium-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return ecrecover(\n            hashApproval(approval),\n            v,\n            r,\n            s\n        );\n    }\n}\n\n\nabstract contract Ownable {\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"O: onlyOwner function!\");\n        _;\n    }\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @notice Initializes owner variable with msg.sender address.\n     */\n    constructor() internal {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @notice Transfers ownership to the desired address.\n     * The function is callable only by the owner.\n     */\n    function transferOwnership(address _owner) external onlyOwner {\n        require(_owner != address(0), \"O: new owner is the zero address!\");\n        emit OwnershipTransferred(owner, _owner);\n        owner = _owner;\n    }\n}\n\n\ninterface AdapterRegistry {\n    function getProtocolAdapters(bytes32) external view returns (address[] memory);\n}\n\n\ncontract TokenSpender is Ownable {\n    using SafeERC20 for ERC20;\n\n    uint256 internal constant RELATIVE_AMOUNT_BASE = 1e18;\n\n    function issueTokens(\n        Approval[] calldata approvals,\n        address user\n    )\n        external\n        onlyOwner\n        returns (address[] memory)\n    {\n        uint256 length = approvals.length;\n        address[] memory assetsToBeWithdrawn = new address[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            Approval memory approval = approvals[i];\n            address token = approval.token;\n\n            assetsToBeWithdrawn[i] = token;\n            uint256 absoluteAmount = getAbsoluteAmount(approval, user);\n            ERC20(token).safeTransferFrom(user, msg.sender, absoluteAmount, \"TS!\");\n        }\n\n        return assetsToBeWithdrawn;\n    }\n\n    function getAbsoluteAmount(\n        Approval memory approval,\n        address user\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        address token = approval.token;\n        AmountType amountType = approval.amountType;\n        uint256 amount = approval.amount;\n\n        require(amountType != AmountType.None, \"TS: wrong amount type!\");\n\n        if (amountType == AmountType.Relative) {\n            require(amount <= RELATIVE_AMOUNT_BASE, \"TS: wrong relative value!\");\n            if (amount == RELATIVE_AMOUNT_BASE) {\n                return ERC20(token).balanceOf(user);\n            } else {\n                return ERC20(token).balanceOf(user) * amount / RELATIVE_AMOUNT_BASE;\n            }\n        } else {\n            return amount;\n        }\n    }\n}\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract\n * returns false). Tokens that return no value (and instead revert or throw on failure)\n * are also supported, non-reverting calls are assumed to be successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.transfer.selector,\n                to,\n                value\n            ),\n            \"transfer\",\n            location\n        );\n    }\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.transferFrom.selector,\n                from,\n                to,\n                value\n            ),\n            \"transferFrom\",\n            location\n        );\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address spender,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: wrong approve call\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                value\n            ),\n            \"approve\",\n            location\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\n     * relaxing the requirement on the return value: the return value is optional\n     * (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param location Location of the call (for debug).\n     */\n    function callOptionalReturn(\n        ERC20 token,\n        bytes memory data,\n        string memory functionName,\n        string memory location\n    )\n        private\n    {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\n        // mechanism, since we're implementing it ourselves.\n\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\n        //  1. The call itself is made, and success asserted\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(\n            success,\n            string(\n                abi.encodePacked(\n                    \"SafeERC20: \",\n                    functionName,\n                    \" failed in \",\n                    location\n                )\n            )\n        );\n\n        if (returndata.length > 0) { // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: false returned\");\n        }\n    }\n}\n\n\n/**\n * @title Main contract executing actions.\n */\ncontract Logic is SignatureVerifier, Ownable {\n    using SafeERC20 for ERC20;\n\n    TokenSpender public tokenSpender;\n    AdapterRegistry public adapterRegistry;\n\n    event ExecutedAction(uint256 index);\n\n    constructor(\n        address _adapterRegistry\n    )\n        public\n    {\n        tokenSpender = new TokenSpender();\n        adapterRegistry = AdapterRegistry(_adapterRegistry);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    function returnLostTokens(\n        ERC20 token\n    )\n        external\n        onlyOwner\n    {\n        token.safeTransfer(msg.sender, token.balanceOf(address(this)), \"L![1]\");\n\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance > 0) {\n            msg.sender.transfer(ethBalance);\n        }\n    }\n\n    /**\n     * @notice Execute actions on signer's behalf.\n     * @param actions Array with actions.\n     * @param approvals Array with tokens approvals for the actions.\n     * @param signatures Array with signatures for the approvals.\n     */\n     function executeActions(\n         Action[] memory actions,\n         Approval[] memory approvals,\n         bytes[] memory signatures\n     )\n         public\n         payable\n     {\n         executeActions(actions, approvals, getUserFromSignatures(approvals, signatures));\n     }\n\n    /**\n     * @notice Execute actions on `msg.sender`'s behalf.\n     * @param actions Array with actions.\n     * @param approvals Array with tokens approvals for the actions.\n     */\n    function executeActions(\n        Action[] memory actions,\n        Approval[] memory approvals\n    )\n        public\n        payable\n    {\n        executeActions(actions, approvals, msg.sender);\n    }\n\n    /**\n     * @notice Execute actions on `user`'s behalf.\n     * @param actions Array with actions.\n     * @param approvals Array with tokens approvals for the actions.\n     */\n    function executeActions(\n        Action[] memory actions,\n        Approval[] memory approvals,\n        address payable user\n    )\n        internal\n    {\n        address[][] memory tokensToBeWithdrawn = new address[][](actions.length + 1);\n\n        tokensToBeWithdrawn[actions.length] = tokenSpender.issueTokens(approvals, user);\n\n        for (uint256 i = 0; i < actions.length; i++) {\n            tokensToBeWithdrawn[i] = callInteractiveAdapter(actions[i]);\n            emit ExecutedAction(i);\n        }\n\n        returnTokens(tokensToBeWithdrawn, user);\n    }\n\n    function callInteractiveAdapter(\n        Action memory action\n    )\n        internal\n        returns (address[] memory)\n    {\n        require(action.actionType != ActionType.None, \"L: wrong action type!\");\n        require(action.amounts.length == action.amountTypes.length, \"L: inconsistent arrays![1]\");\n        require(action.amounts.length == action.tokens.length, \"L: inconsistent arrays![2]\");\n        address[] memory adapters = adapterRegistry.getProtocolAdapters(action.protocolName);\n        require(action.adapterIndex <= adapters.length, \"L: wrong index!\");\n        address adapter = adapters[action.adapterIndex];\n\n        bytes4 selector;\n        if (action.actionType == ActionType.Deposit) {\n            selector = InteractiveAdapter(adapter).deposit.selector;\n        } else {\n            selector = InteractiveAdapter(adapter).withdraw.selector;\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = adapter.delegatecall(\n            abi.encodeWithSelector(\n                selector,\n                action.tokens,\n                action.amounts,\n                action.amountTypes,\n                action.data\n            )\n        );\n\n        // assembly revert opcode is used here as `returnData`\n        // is already bytes array generated by the callee's revert()\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            if eq(success, 0) { revert(add(returnData, 32), returndatasize()) }\n        }\n\n        address[] memory tokensToBeWithdrawn = abi.decode(returnData, (address[]));\n\n        return tokensToBeWithdrawn;\n    }\n\n    function returnTokens(\n        address[][] memory tokensToBeWithdrawn,\n        address payable user\n    )\n        internal\n    {\n        ERC20 token;\n\n        for (uint256 i = 0; i < tokensToBeWithdrawn.length; i++) {\n            for (uint256 j = 0; j < tokensToBeWithdrawn[i].length; j++) {\n                token = ERC20(tokensToBeWithdrawn[i][j]);\n                token.safeTransfer(user, token.balanceOf(address(this)), \"L!\");\n            }\n        }\n\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance > 0) {\n            user.transfer(ethBalance);\n        }\n    }\n}\n"}}}