{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"JustAPI.sol":{"content":"// SPDX-License-Identifier: MIT License\npragma solidity >=0.5.16 <0.7.0;\npragma experimental ABIEncoderV2;\n\ninterface ITRC20 {\n    function symbol() external pure returns(string memory);\n    function name() external pure returns(string memory);\n    function balanceOf(address owner) external pure returns(uint256);\n    function totalSupply() external view returns(uint256);\n}\n\ninterface IFactory {\n    function allPairs(uint256) external view returns(address pair);\n    function allPairsLength() external view returns(uint256);\n    function getTokensByPair(address) external view returns (address, address);\n}\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x + y) >= x, 'Router SafeMath: ds-math-add-overflow');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x - y) <= x, 'Router SafeMath: ds-math-sub-underflow');\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'Router SafeMath: ds-math-mul-overflow');\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x / y) > 0, 'Router SafeMath: ds-math-div-overflow');\n    }\n    function div0(uint256 x, uint256 y) internal pure returns(uint256) {\n        require(y > 0);\n        uint256 z = x / y;\n        if (z < 0) {\n            z = 0;\n        }\n        return z;\n    }\n}\n\ncontract JMSwapAPI {\n    using SafeMath for uint256;\n\n    address private factory;\n\n    constructor(address _factory) public {\n        factory = _factory;\n    }\n\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function toString(address account) internal pure returns(string memory) {\n        return toString(abi.encodePacked(account));\n    }\n    \n    function toString(bytes memory data) internal pure returns(string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint i = 0; i < data.length; i++) {\n            str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];\n            str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n    \n\n    function getAllPairsBalances(uint256 maxItems, uint256 page) external view returns (string[] memory) {\n        uint256 allPairsLength = IFactory(factory).allPairsLength();\n\n        uint256 counter = 0;\n\n        uint256 index = maxItems.mul(page).sub(maxItems);\n        if (allPairsLength == 0 || index > allPairsLength - 1) {\n            string[] memory ret = new string[](0);\n            return ret;\n        }\n        string[] memory st = new string[](maxItems);\n\n        for(uint256 i = index; i < maxItems.mul(page); i++){\n            if (i < allPairsLength) {\n                address pair = IFactory(factory).allPairs(i);\n                (address tokenA, address tokenB) = IFactory(factory).getTokensByPair(pair);\n                uint256 balanceA = ITRC20(tokenA).balanceOf(pair);\n                uint256 balanceB = ITRC20(tokenB).balanceOf(pair);\n                if(balanceA > 0 && balanceB > 0){\n                    string memory balA = uint2str(balanceA);\n                    string memory balB = uint2str(balanceB);\n                    st[counter] = string(abi.encodePacked('{\"A\":{\"s\":\"',ITRC20(tokenA).symbol(),'\",\"n\":\"',ITRC20(tokenA).name(),'\",\"b\":',balA,'},\"B\":{\"s\":\"',ITRC20(tokenB).symbol(),'\",\"n\":\"',ITRC20(tokenB).name(),'\",\"b\":',balB,'}}'));\n                    counter++;\n                } \n            }\n        }\n        \n        return st;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return IFactory(factory).allPairsLength();\n    }\n\n    function getUserLPbyPair(address pair, address user) external view returns (string memory) {\n        uint256 userLP = ITRC20(pair).balanceOf(user);\n        string memory a;\n        if(userLP > 0) {\n            uint256 totalLP = ITRC20(pair).totalSupply();\n            //uint256 userPercent = (userLP.mul(100000000000000000000)).div0(totalLP);\n            (address tokenA, address tokenB) = IFactory(factory).getTokensByPair(pair);\n            uint256 balA = ITRC20(tokenA).balanceOf(pair);\n            uint256 balB = ITRC20(tokenB).balanceOf(pair);\n            balA = (userLP.mul(balA)).div0(totalLP);\n            balB = (userLP.mul(balB)).div0(totalLP);\n            //string memory up = uint2str(userPercent);\n            string memory tl = uint2str(totalLP);\n            string memory ul = uint2str(userLP);\n            string memory v1 = uint2str(balA);\n            string memory v2 = uint2str(balB);\n            string memory addr = toString(pair);\n            a = string(abi.encodePacked('{\"a\":\"',addr,'\",\"s1\":\"',ITRC20(tokenA).symbol(),'\",\"s2\":\"',ITRC20(tokenB).symbol(),'\",\"tl\":',tl,',\"ul\":',ul,',\"v1\":',v1,',\"v2\":',v2,'}'));\n        }\n        return a;\n    }\n\n    function getUserLP(address user, uint256 maxItems, uint256 page) external view returns (string[] memory) {\n        require(user != address(0), 'API: NOT_A_VALID_USER');\n\n        uint256 numPairs = this.allPairsLength();\n        uint256 index = maxItems.mul(page).sub(maxItems);\n        if (numPairs == 0 || index > numPairs - 1) {\n            string[] memory ret = new string[](0);\n            return ret;\n        }\n\n        string[] memory st = new string[](maxItems);\n        uint256 counter = 0;\n        \n        for(uint256 i = index; i < maxItems.mul(page); i++){\n            if (i < numPairs) {\n                address pair = IFactory(factory).allPairs(i);\n\n                string memory res = this.getUserLPbyPair(pair, user);\n                if(bytes(res).length > 0){\n                    st[counter] = res;\n                    counter++;\n                }\n            }\n        }\n        \n\n        return st;\n    }\n\n    function getAllPairSymbols(uint256 maxItems, uint256 page) external view returns (string[] memory) {\n        uint256 numPairs = IFactory(factory).allPairsLength();\n\n        uint256 index = maxItems.mul(page).sub(maxItems);\n        if (numPairs == 0 || index > numPairs - 1) {\n            string[] memory ret = new string[](0);\n            return ret;\n        }\n        string[] memory st = new string[](maxItems);\n        uint256 counter = 0;\n        \n        for(uint256 i = index; i < maxItems.mul(page); i++){\n            if (i < numPairs) {\n                address pair = IFactory(factory).allPairs(i);\n                (address tokenA, address tokenB) = IFactory(factory).getTokensByPair(pair);\n                st[counter] = string(abi.encodePacked(ITRC20(tokenA).symbol(), \"-\", ITRC20(tokenB).symbol()));\n                counter++;\n            }\n        }\n        \n        return st;\n    }\n    \n\n}"}}}