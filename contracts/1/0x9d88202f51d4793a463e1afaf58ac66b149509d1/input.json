{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/BlockchainYou.sol": {
      "content": "pragma solidity >=0.4.22 <0.7.0;\n\ncontract BlockchainYou {\n    address private swaniaAdrress;\n    \n    enum PROFILE {\n        ADMIN,\n        MANUFACTURER,\n        LABORATORY\n    }\n    \n    struct User {\n        bytes32 userHash;\n        bytes32 userHashUpdate;\n        bytes32 userHashFroze;\n        PROFILE userType;\n        Partner userPartner;\n        bool isActive;\n    }\n    User[] users;\n    mapping(bytes32 => bool) public usersWhitelisted;\n    \n    struct Partner {\n        address partnerAddress;\n        bytes32 partnerHash;\n        bytes32 partnerHashUpdate;\n        bytes32 partnerHashFroze;\n        PROFILE partnerCategory;\n        bool isActive;\n    }\n    Partner[] partners;\n    mapping(address => bool) public partnersWhitelisted;\n\n    struct Product {\n        address productAddress;\n        bytes32 productHash;\n        bytes32 productHashUpdate;\n        bytes32 productHashDelete;\n        address productAdmin;\n        address[] productManufacturer;\n        address[] productLaboratory;\n        bool isActive;\n    }\n    Product[] products;\n    mapping(address => bool) public productsValidated;\n\n    struct Batch {\n        bytes32 batchHash;\n        bytes32 batchHashUpdateAnalysisReport;\n        bytes32 batchHashUpdateTestReport;\n        address batchManufacturer;\n        address batchLaboratory;\n        bool isActive;\n    }\n    Batch[] batches;\n    mapping(address => Batch) public productBatches;\n    \n    // events\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n\n    event NewPartnerCreatedWithSuccess(address indexed _creator, address indexed _partnerAddress, bytes32 _partnerHash, uint8 _partnerCategory, bool _isActive);\n    event PartnerUpdatedWithSuccess(address indexed _creator, address indexed _partnerAddress, bytes32 _partnerHash, bytes32 _partnerHashUpdate, bool _isActive);\n    event PartnerFrozenWithSuccess(address indexed _creator, address indexed _partnerAddress, bytes32 _partnerHash, bytes32 _partnerHashFroze, bool _isActive);\n    \n    event NewUserCreatedWithSuccess(address indexed _creator, bytes32 _userHash, uint8 _userType, bool _isActive);\n    event UserUpdatedWithSuccess(address indexed _creator, bytes32 _userHash, bytes32 _userHashUpdate, bool _isActive);\n    event UserFrozenWithSuccess(address indexed _creator, bytes32 _userHash, bytes32 _userHashDelete, bool _isActive);\n    \n    event ProductCreatedWithSuccess(address indexed _creator, address indexed _productAddress, bytes32 _productHash, bool _isActive);\n    event ProductUpdatedWithSuccess(address indexed _creator, address indexed _productAddress, bytes32 _productHash, bytes32 _productHashUpdate, bool _isActive);\n    event ProductFrozenWithSuccess(address indexed _creator, address indexed _productAddress, bytes32 _productHash, bytes32 _productHashDelete, bool _isActive);\n    \n    event NewProductBatchCreatedWithSuccess(address indexed _creator, address indexed _productAddress, bytes32 _productHash, bytes32 _batchHash, bool _isActive);\n    event ValidatedBatchUpdatedWithSuccess(address indexed _creator, address indexed _productAddress, bytes32 _productHash, bytes32 _batchHash, bytes32 _batchHashUpdate, bool _isActive);\n    \n    // modifiers\n    modifier onlySwania() {\n        require(msg.sender == swaniaAdrress, \"Caller is not Swania\");\n        _;\n    }\n\n    modifier onlyPartnerWhitelisted(address _partnerAddress) {\n        require(partnersWhitelisted[_partnerAddress]==true, \"Partner Not Whitelisted !\");\n        _;\n    }\n    modifier onlyUserWhitelisted(bytes32 _userHash) {\n        require(usersWhitelisted[_userHash]==true, \"User Not Whitelisted !\");\n        _;\n    }\n\n    modifier onlyProductAndPartnerValidated(address _productAddress, bytes32 _productHash, address _partnerAddress) {\n        require(isProductExist(_productAddress, _productHash) && isPartnerExistAndValidated(_partnerAddress), \"Product And Manufacturer Partner Not Validated !\");\n        _;\n    }\n\n    modifier onlyNewBatch(address _productAddress, bytes32 _productHash, bytes32 _batchHash, address _partnerAddress) {\n        require(!isBatchExist(_batchHash) && isProductAndManufacturerPartnerValidated(_productAddress, _productHash, _partnerAddress), \"Existing Batch!\");\n        _;\n    }\n\n    modifier onlyValidedBatchForManufacturer(address _productAddress, bytes32 _productHash, bytes32 _batchHash, address _partnerAddress) {\n        require(isBatchExist(_batchHash) && isProductAndManufacturerPartnerValidated(_productAddress, _productHash, _partnerAddress), \"Batch not available for Manufacturer\");\n        _;\n    }\n    \n    modifier onlyValidedBatchForLaboratory(address _productAddress, bytes32 _productHash, bytes32 _batchHash, address _partnerAddress) {\n        require(isBatchExist(_batchHash) && isProductAndLaboratoryPartnerValidated(_productAddress, _productHash, _partnerAddress), \"Batch not available for Laboratory\");\n        _;\n    }\n\n    constructor() public {\n        swaniaAdrress = msg.sender;\n        Partner memory swania;\n        swania.partnerAddress = swaniaAdrress;\n        swania.isActive = true;\n        partners.push(swania);\n        emit OwnerSet(address(0), swaniaAdrress);\n    }\n    \n    function isPartnerExist(bytes32 _partnerHash)\n        private\n        view returns(bool) {\n        \n        for(uint indexPartner = 0; indexPartner < partners.length; indexPartner++) {\n            if(partners[indexPartner].partnerHash == _partnerHash) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isUserExist(bytes32 _userHash)\n        private\n        view returns(bool) {\n        \n        for(uint indexUser = 0; indexUser < users.length; indexUser++) {\n            if(users[indexUser].userHash == _userHash) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isProductExist(address _productAddress, bytes32 _productHash)\n        private\n        view returns(bool) {\n        \n        for(uint indexProduct = 0; indexProduct < products.length; indexProduct++) {\n            if(products[indexProduct].productAddress == _productAddress && products[indexProduct].productHash == _productHash) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    function isPartnerExistAndValidated(address _partnerAddress)\n        private\n        onlyPartnerWhitelisted(_partnerAddress)\n        view\n        returns(bool) {\n        for(uint indexPartner = 0; indexPartner < partners.length; indexPartner++) {\n            if(partners[indexPartner].partnerAddress == _partnerAddress) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isProductAndManufacturerPartnerValidated(address _productAddress, bytes32 _productHash, address _partnerAddress)\n        private\n        onlyProductAndPartnerValidated(_productAddress, _productHash, _partnerAddress)\n        view\n        returns(bool){\n\n        for(uint indexProduct = 0; indexProduct < products.length; indexProduct++) {\n            if(products[indexProduct].productAddress == _productAddress &&\n                products[indexProduct].productHash == _productHash) {\n                \n                for(uint indexManu = 0; indexManu < products[indexProduct].productManufacturer.length; indexManu++) {\n                    if (products[indexProduct].productManufacturer[indexManu] == _partnerAddress) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    function isProductAndLaboratoryPartnerValidated(address _productAddress, bytes32 _productHash, address _partnerAddress)\n        private\n        onlyProductAndPartnerValidated(_productAddress, _productHash, _partnerAddress)\n        view\n        returns(bool){\n\n        for(uint indexProduct = 0; indexProduct < products.length; indexProduct++) {\n            if(products[indexProduct].productAddress == _productAddress &&\n                products[indexProduct].productHash == _productHash) {\n                \n                for(uint indexLabo = 0; indexLabo < products[indexProduct].productLaboratory.length; indexLabo++) {\n                    if (products[indexProduct].productLaboratory[indexLabo] == _partnerAddress) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    function isBatchExist(bytes32 _batchHash)\n        private\n        view returns(bool) {\n        \n        for(uint indexBatch = 0; indexBatch < batches.length; indexBatch++) {\n            if(batches[indexBatch].batchHash == _batchHash) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function changeOwner(address _newOwner)\n        public\n        onlySwania {\n        \n        swaniaAdrress = _newOwner;\n        emit OwnerSet(swaniaAdrress, _newOwner);\n    }\n    \n    function getOwner()\n        external\n        view\n        returns (address) {\n        \n        return swaniaAdrress;\n    }\n\n    function registerPartner(bytes32 _partnerHash, uint8 _partnerCategory, address _partnerAddress)\n        public\n        onlySwania\n        returns(bool) {\n        \n        require(!isPartnerExist(_partnerHash));\n\n        Partner memory partner;\n        partner.partnerAddress = _partnerAddress;\n        partner.partnerHash = _partnerHash;\n        partner.partnerCategory = getProfile(_partnerCategory);\n        partner.isActive = true;\n        \n        partnersWhitelisted[partner.partnerAddress] = true;\n        \n        partners.push(partner);\n\n        emit NewPartnerCreatedWithSuccess(msg.sender, _partnerAddress, _partnerHash, _partnerCategory, true);\n        \n        return true;\n    }\n\n    function updatePartner(address _partnerAddress, bytes32 _partnerHash, bytes32 _partnerHashUpdate)\n        public\n        onlyPartnerWhitelisted(_partnerAddress)\n        returns(bool) {\n            \n        require(isPartnerExist(_partnerHash));\n\n        for(uint indexPartner = 0; indexPartner < partners.length; indexPartner++) {\n            if(partners[indexPartner].partnerHash == _partnerHash) {\n                partners[indexPartner].partnerHashUpdate = _partnerHashUpdate;\n                emit PartnerUpdatedWithSuccess(msg.sender, _partnerAddress, _partnerHash, _partnerHashUpdate, true);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function frozePartner(address _partnerAddress, bytes32 _partnerHash, bytes32 _partnerHashFroze)\n        public\n        onlySwania\n        returns(bool){\n        \n        require(isPartnerExist(_partnerHash));\n        \n        for(uint indexPartner = 0; indexPartner < partners.length; indexPartner++) {\n            if(partners[indexPartner].partnerHash == _partnerHash) {\n                partners[indexPartner].partnerHashFroze = _partnerHashFroze;\n                partners[indexPartner].isActive = false;\n                partnersWhitelisted[_partnerAddress] = false;\n                emit PartnerFrozenWithSuccess(msg.sender, _partnerAddress, _partnerHash, _partnerHashFroze, false);\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function registerUser(bytes32 _userHash, uint8 _userType)\n        public\n        returns(bool) {\n            \n        require(!isUserExist(_userHash));\n        \n        User memory user;\n        user.userHash = _userHash;\n        user.userType = getProfile(_userType);\n        user.isActive = true;\n\n        usersWhitelisted[user.userHash] = true;\n        \n        users.push(user);\n        \n        emit NewUserCreatedWithSuccess(msg.sender, _userHash, _userType, true);\n        \n        return true;\n    }\n    \n    function updateUser(bytes32 _userHash, bytes32 _userHashUpdate)\n        public\n        onlyUserWhitelisted(_userHash)\n        returns(bool) {\n        \n        require(isUserExist(_userHash));\n\n        for(uint indexUser = 0; indexUser < users.length; indexUser++) {\n            if(users[indexUser].userHash == _userHash) {\n                users[indexUser].userHashUpdate = _userHashUpdate;\n                emit UserUpdatedWithSuccess(msg.sender, _userHash, _userHashUpdate, true);\n                return true;\n            }\n        }\n        \n        return false;\n    }\n\n    function frozeUser(bytes32 _userHash, bytes32 _userHashFroze)\n        public\n        onlySwania\n        returns(bool) {\n            \n        require(isUserExist(_userHash));\n        \n        for(uint indexUser = 0; indexUser < users.length; indexUser++) {\n            if(users[indexUser].userHash == _userHash) {\n                users[indexUser].userHashFroze = _userHashFroze;\n                users[indexUser].isActive = false;\n                usersWhitelisted[_userHash] = false;\n                emit UserFrozenWithSuccess(msg.sender, _userHash, _userHashFroze, false);\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    function getProfile(uint8 _profile) private pure returns(PROFILE) {\n        if(_profile == 0) return PROFILE.ADMIN;\n        if(_profile == 1) return PROFILE.MANUFACTURER;\n        if(_profile == 2) return PROFILE.LABORATORY;\n    }\n\n    function createProduct(address _productAddress, bytes32 _productHash, address _productAdmin, address[] memory _productManufacturer, address[] memory _productLaboratory)\n        public\n        onlySwania\n        returns(bool){\n        require(!isProductExist(_productAddress, _productHash) && msg.sender == _productAdmin);\n\n        Product memory product;\n        product.productAddress = _productAddress;\n        product.productHash = _productHash;\n        product.productAdmin = msg.sender;\n        product.productManufacturer = _productManufacturer;\n        product.productLaboratory = _productLaboratory;\n        product.isActive = true;\n        productsValidated[product.productAddress] = true;\n        products.push(product);\n        emit ProductCreatedWithSuccess(msg.sender, _productAddress, _productHash, true);\n        return true;\n    }\n\n    function updateProduct(address _productAddress, bytes32 _productHash, bytes32 _productHashUpdate, address _productAdmin)\n        public\n        onlySwania\n        returns(bool){\n        \n        require(isProductExist(_productAddress, _productHash) && msg.sender == _productAdmin);\n\n        for(uint indexProduct = 0; indexProduct < products.length; indexProduct++) {\n            if(products[indexProduct].productAddress == _productAddress &&\n                products[indexProduct].productHash == _productHash &&\n                products[indexProduct].productAdmin == _productAdmin) {\n\n                products[indexProduct].productHashUpdate = _productHashUpdate;\n                emit ProductUpdatedWithSuccess(msg.sender, _productAddress, _productHash, _productHashUpdate, true);\n                return true;\n            }\n        }\n\n        return false;\n    }\n    \n    function createBatchForProduct(address _productAddress, bytes32 _productHash, bytes32 _batchHash, address _partnerAddress)\n        public\n        onlyNewBatch(_productAddress, _productHash, _batchHash, _partnerAddress)\n        returns(bool){\n\n        Batch memory batch;\n        batch.batchHash = _batchHash;\n        batch.batchManufacturer = _partnerAddress;\n        batch.isActive = true;\n        batches.push(batch);\n        emit NewProductBatchCreatedWithSuccess(msg.sender, _productAddress, _productHash, _batchHash, true);\n        return true;\n    }\n\n    function updateProductBatchByAddingBatchAnalysisReport(address _productAddress, bytes32 _productHash, bytes32 _batchHash, bytes32 _batchHashUpdateAnalysisReport, address _partnerAddress)\n        public\n        onlyValidedBatchForManufacturer(_productAddress, _productHash, _batchHash, _partnerAddress)\n        returns(bool){\n        \n        for(uint indexBatch = 0; indexBatch < batches.length; indexBatch++) {\n            if(batches[indexBatch].batchHash == _batchHash &&\n                msg.sender == _partnerAddress &&\n                batches[indexBatch].batchManufacturer == msg.sender) {\n\n                batches[indexBatch].batchHashUpdateAnalysisReport = _batchHashUpdateAnalysisReport;\n                batches[indexBatch].isActive = true;\n\n                emit ValidatedBatchUpdatedWithSuccess(msg.sender, _productAddress, _productHash, _batchHash, _batchHashUpdateAnalysisReport, true);\n                return true;\n            }\n        }\n\n        return false;\n\n    }\n\n    function updateProductBatchByAddingBatchTestAnalysisReport(address _productAddress, bytes32 _productHash, bytes32 _batchHash, bytes32 _batchHashUpdateTestReport, address _partnerAddress)\n        public\n        onlyValidedBatchForLaboratory(_productAddress, _productHash, _batchHash, _partnerAddress)\n        returns(bool){\n        \n        for(uint indexBatch = 0; indexBatch < batches.length; indexBatch++) {\n            if(batches[indexBatch].batchHash == _batchHash &&\n                msg.sender == _partnerAddress &&\n                batches[indexBatch].batchLaboratory == msg.sender) {\n\n                batches[indexBatch].batchHashUpdateTestReport = _batchHashUpdateTestReport;\n                batches[indexBatch].isActive = true;\n\n                emit ValidatedBatchUpdatedWithSuccess(msg.sender, _productAddress, _productHash, _batchHash, _batchHashUpdateTestReport, true);\n                return true;\n            }\n        }\n\n        return false;\n\n    }\n\n    function frozeProduct(address _productAddress, bytes32 _productHash, bytes32 _productHashDelete, address _productAdmin)\n        public\n        onlySwania\n        returns(bool){\n        \n        require(isProductExist(_productAddress, _productHash) && msg.sender == _productAdmin);\n\n        for(uint indexProduct = 0; indexProduct < products.length; indexProduct++) {\n            if(products[indexProduct].productAddress == _productAddress &&\n                products[indexProduct].productHash == _productHash &&\n                products[indexProduct].productAdmin == _productAdmin) {\n\n                products[indexProduct].productHashDelete = _productHashDelete;\n                products[indexProduct].isActive = true;\n                productsValidated[_productAddress] = true;\n                emit ProductFrozenWithSuccess(msg.sender, _productAddress, _productHash, _productHashDelete, true);\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"
    }
  }
}