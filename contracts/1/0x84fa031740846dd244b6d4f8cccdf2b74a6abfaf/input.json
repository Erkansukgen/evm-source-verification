{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"hongcoinutilInfo.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.8.9;\n// interface IPancakeRouter {\n//     function factory() external pure returns (address);\n//     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n//     function swapExactETHForTokensSupportingFeeOnTransferTokens(\n//         uint amountOutMin,\n//         address[] calldata path,\n//         address to,\n//         uint deadline\n//     ) external payable;\n//     function swapExactBNBForTokensSupportingFeeOnTransferTokens(\n//         uint256 amountOutMin,\n//         address[] calldata path,\n//         address to,\n//         uint256 deadline\n//     ) external payable;\n//     function swapExactETHForTokens(\n//         uint256 amountOutMin,\n//         address[] calldata path,\n//         address to,\n//         uint256 deadline\n//     ) external payable returns (uint256[] memory amounts);\n//    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n//         uint amountIn,\n//         uint amountOutMin,\n//         address[] calldata path,\n//         address to,\n//         uint deadline\n//     ) external;\n//    function swapExactTokensForTokens(\n//         uint256 amountIn,\n//         uint256 amountOutMin,\n//         address[] calldata path,\n//         address to,\n//         uint256 deadline\n//     ) external returns (uint256[] memory amounts); \n// }\n// interface IPancakeFactory {\n//     function getPair(address tokenA, address tokenB) external view returns (address pair);\n// }\n\n// interface IPancakePair {\n//    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n// }\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint);\n    function decimals() external view returns (uint8);\n    // function balanceOf(address owner) external view returns (uint);\n    // function allowance(address owner, address spender) external view returns (uint);\n    // function approve(address spender, uint value) external returns (bool);\n    // function transfer(address to, uint value) external returns (bool);\n    // function transferFrom(address from, address to, uint value) external returns (bool);\n    // function _maxTxAmount() external view returns (uint);\n    // function maxTxAmount() external view returns (uint);\n    function owner() external view returns(address);\n    function getOwner() external view returns(address);\n   function Owner() external view returns(address);\n}\n\ncontract HongCoinUtil{\n   \n//     function _buySupport(address router,address[] memory path,address to,uint256 minOut) internal {\n//         if(address(router)==address(0x789c11212EaCA5312d4aa6d63148613e658CcFAd)){  //burger\n//              IPancakeRouter(router).swapExactETHForTokens{value:msg.value}(minOut,path,to,block.timestamp);\n//         }\n//         //babery jul\n//         else if(address(router) ==address(0xCDe540d7eAFE93aC5fE6233Bee57E1270D3E330F)||address(router) ==address(0xbd67d157502A23309Db761c41965600c2Ec788b2)){  \n//              IPancakeRouter(router).swapExactBNBForTokensSupportingFeeOnTransferTokens{value:msg.value}(minOut,path,to,block.timestamp);\n           \n//         }else {\n//              IPancakeRouter(router).swapExactETHForTokensSupportingFeeOnTransferTokens{value:msg.value}(minOut,path,to,block.timestamp);\n//         }\n//     }\n    \n//    function _sellSupport(uint256 amountIn,address router,address to,address[] memory path,uint256 minOut) internal {\n        \n//         if(address(router)==address(0x789c11212EaCA5312d4aa6d63148613e658CcFAd)){  //burger\n//              IPancakeRouter(router).swapExactTokensForTokens(amountIn,minOut,path,to,block.timestamp);\n//         } \n//         else {\n//              IPancakeRouter(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn,minOut,path,to,block.timestamp);\n//         }\n//     }\n    \n//       //*******************\n//     // buy and sell tax\n    \n//      function getBuyValue(uint256 value,address router,address[] memory path,address[] memory sellpath) public view returns(uint256 buyvalue){\n//          uint256[] memory amountsbuy = IPancakeRouter(router).getAmountsOut(value,path);\n//          uint256 amountOut = amountsbuy[amountsbuy.length-1];\n//          uint256 txlimit = amountOut;\n//          address token = sellpath[0];\n//          try IERC20(token)._maxTxAmount() returns (uint limit){\n//              txlimit = limit;\n//          }catch{\n//              try  IERC20(token).maxTxAmount() returns (uint limit2){\n//                  txlimit = limit2;\n//              }catch{}\n//          }\n//          if(txlimit<amountOut){\n//              uint256[] memory amountSell =  IPancakeRouter(router).getAmountsOut(txlimit,sellpath);\n//              buyvalue = amountSell[amountSell.length-1];\n//          }else{\n//              buyvalue = value;\n//          }\n         \n//      }\n    \n//     //*************\n//     // test tax\n//   function testTaxAndndValue(address router,address[] memory path,address[] memory sellpath) external payable returns(uint256 buytax,uint256 selltax,uint256 buyvalue)\n//     {\n//         buyvalue = getBuyValue(msg.value,router,path,sellpath);\n//         //Tax\n//         uint256[] memory amountsbuy = IPancakeRouter(router).getAmountsOut(buyvalue,path);\n//         uint256  buyBefore = amountsbuy[amountsbuy.length-1];\n//         uint256 balanceBefore = IERC20(sellpath[0]).balanceOf(address(this));\n//         _buySupport(router,path,address(this),1);\n//         uint256 balanceAfter = IERC20(sellpath[0]).balanceOf(address(this));\n//         uint256 buyAfter = balanceAfter-balanceBefore;\n//         buytax = (buyBefore-buyAfter)*100 / buyBefore;\n        \n//         uint256[] memory amountssell = IPancakeRouter(router).getAmountsOut(buyAfter,sellpath);\n//         uint256 sellBefore = amountssell[amountssell.length-1];\n//         uint256 bnbBefore = IERC20(path[0]).balanceOf(address(this));\n//         IERC20(sellpath[0]).approve(router,0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n//         _sellSupport(buyAfter,router,address(this),sellpath,1);\n//         uint256 bnbAfter = IERC20(path[0]).balanceOf(address(this));\n//         uint256 sellAfter = bnbAfter-bnbBefore;\n//         selltax = (sellBefore-sellAfter)*100 / sellBefore;\n//     }\n    \n    \n     function getTokenInfo(address token) public view returns(uint256 totalSupply,address owner,string memory name,string memory symbol,uint8 decimals){\n         owner = 0x0000000000000000000000000000000000000001;\n         totalSupply  =  IERC20(token).totalSupply();\n         decimals  =  IERC20(token).decimals();\n         name  =  IERC20(token).name();\n         symbol  =  IERC20(token).symbol();\n         try IERC20(token).owner() returns(address o1){\n             owner = o1;\n         }\n         catch{\n             try IERC20(token).getOwner() returns(address o2){\n                 owner = o2;\n             }catch{\n                 try IERC20(token).Owner() returns(address o3){\n                 owner = o3;\n             }catch{\n                 \n             }\n             }\n         }\n      }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}}}