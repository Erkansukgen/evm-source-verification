{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/test.sol": {
      "content": "pragma solidity 0.6.12;\ninterface IKIP7 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address, uint256) external returns (bool);\n    function allowance(address, address) external view returns (uint);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface Bank {\n    function totalBNB() external view returns (uint amount);\n    function deposit() external payable;\n    function withdraw(uint share) external;\n}\n\ninterface ABC {\n    function bankAddress() external view returns (address);\n}\n\ninterface IWBNB is IKIP7 {\n    function deposit() external payable;\n    function withdraw(uint256 wad) external;\n}\n\ncontract Test {\n    function abc(address payable a) public payable {\n        a.transfer(msg.value);\n    }\n}\n\n\ncontract ABCD {\n    address public bank = 0x3bB5f6285c312fc7E1877244103036ebBEda193d;\n    address public wbnb = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    uint public bal = 0;\n    \n    function deposit(uint256 _wantAmt)\n        public\n        returns (uint256)\n    {\n        IKIP7(wbnb).transferFrom(\n            address(msg.sender),\n            address(this),\n            _wantAmt\n        );\n        \n        _unwrapBNB(_wantAmt);\n\n        uint before = _stakedWantTokens();\n        Bank(bank).deposit{value: _wantAmt}();\n        uint diff = _stakedWantTokens() - before;\n\n        bal = bal + diff;\n\n        return diff;\n    }\n    \n    function _stakedWantTokens() public view returns (uint256) {\n        IKIP7 _token = IKIP7(bank);\n        uint _totalBNB = Bank(bank).totalBNB();\n        return (_token.balanceOf(address(this)) * _totalBNB) / _token.totalSupply();\n    }\n    \n    function _unwrapBNB(uint256 _amount) internal {\n        uint256 wbnbBal = IKIP7(wbnb).balanceOf(address(this));\n        if (wbnbBal >= _amount) {\n            IWBNB(wbnb).withdraw(_amount);\n        }\n    }\n    \n    receive () external payable {}\n}\n\n\n\ncontract A {\n    bytes4 public constant SELECTOR = bytes4(keccak256(bytes('decimals()')));\n    \n    event Test(bool res, uint decimals);\n    function safeCall(address token) public {\n        (bool res, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR));\n        \n        uint8 decimals = 0;\n        if(res && isContract(token)) decimals = abi.decode(data, (uint8));\n        \n        emit Test(res, decimals);\n    }\n    \n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    \n    function qwer(bytes32 a) public pure returns (uint){\n        return a.length;\n    }\n    \n    event QWER(bytes32 a);\n    function reqw(bytes32 a) public {\n        require(a != 0);\n        emit QWER(a);\n    }\n}"
    }
  }
}