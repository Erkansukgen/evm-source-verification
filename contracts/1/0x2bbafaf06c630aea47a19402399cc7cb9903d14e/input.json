{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ElectronicSignature.sol":{"content":"pragma solidity >=0.5.10 <0.7.0;\n\ncontract ElectronicSignature {\n    address public electronicSignatureOwner;\n    string  private electronicSignatureHash;\n    string  public electronicSignatureGraphicHash;\n    string  public electronicSignaturePersonalName;\n    string  public electronicSignatureDocumentNumber;\n    \n    modifier onlySignatureOwner { \n        require(msg.sender == electronicSignatureOwner);\n        _;\n    }\n    \n    constructor (address _electronicSignatureOwner, string memory _electronicSignatureHash, string memory _electronicSignatureGraphicHash, string memory _electronicSignaturePersonalName, string memory _electronicSignatureDocumentNumber) public {\n        electronicSignatureOwner = _electronicSignatureOwner;\n        electronicSignatureHash = _electronicSignatureHash;\n        electronicSignatureGraphicHash =  _electronicSignatureGraphicHash;\n        electronicSignaturePersonalName = _electronicSignaturePersonalName;\n        electronicSignatureDocumentNumber = _electronicSignatureDocumentNumber;\n    }\n    \n    function getElectronicSignatureHash() public view onlySignatureOwner returns (string memory _electronicSignatureHash) {\n        return electronicSignatureHash;\n    }\n    \n    function verifyElectronicSignatureAuthenticity(bytes32 h, uint8 v, bytes32 r, bytes32 s) public pure returns (address _verifiedAddress) {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        \n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, h));\n        _verifiedAddress = ecrecover(prefixedHash, v, r, s);\n    }\n}"}}}