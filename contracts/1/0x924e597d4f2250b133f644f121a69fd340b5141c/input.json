{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "buyAndSellDelegeta.sol": {
      "content": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function getDenormalizedWeight(address) external returns (uint256);\n    function getSpotPrice(address,address) external returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n}\n\ncontract buysellDelegate{\n    \n    address OWNER;\n    address addrBalancerTrade = 0x33d7E8C1d4933518F291B5dFC375Eb44A812Cb2A;\n    address addrPoke = 0x46ef1a3071ae1276E4c58a89b1198399380382f7;\n    address addrStableCoin = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address addrShitCoin = 0x4104b135DBC9609Fc1A9490E61369036497660c8;\n    address startContract = 0x2E0561e87Bb1C29D7E6259e163b03b7Ab93E2987;\n    \n    constructor() {\n    OWNER = (msg.sender);\n    // IERC20 tokenInIERC20 = IERC20(addrStableCoin);\n    // tokenInIERC20.approve(addrBalancerTrade, 1e60);\n    // tokenInIERC20 = IERC20(addrShitCoin);\n    // tokenInIERC20.approve(addrBalancerTrade, 1e60);\n    }\n    modifier onlyOwner() {\n        require(tx.origin == OWNER, \"caller is not the owner!\");\n        _;\n    }\n\n    function sellPokeBuy(address to,uint256 _weight) public onlyOwner{\n        uint256 weight = IERC20(addrPoke).getDenormalizedWeight(addrStableCoin);\n        require(_weight == weight, \"Weight changed.\");\n        uint256 balanceOld = IERC20(addrShitCoin).balanceOf(address(OWNER));\n        addrBalancerTrade.delegatecall(abi.encodeWithSignature(\"swapExactAmountIn(address,uint256,address,uint256,uint256)\",addrShitCoin,balanceOld,addrStableCoin, 0 ,100000000000000000000000000000000)); //sell\n        poke();\n        buy();\n        uint256 balanceNew = IERC20(addrShitCoin).balanceOf(address(OWNER));\n        require(balanceNew > balanceOld, \"balanceNew < balanceOld\");\n\n        \n    }\n    \n    function pokeBuy(uint maxPrice) public onlyOwner {\n        uint256 price = IERC20(addrBalancerTrade).getSpotPrice(addrStableCoin,addrShitCoin);\n        require(maxPrice > price, \"Bad Price.\"); \n        poke();\n        buy();\n    }\n    \n    function sell(uint minPrice) public onlyOwner {\n        uint256 price = IERC20(addrBalancerTrade).getSpotPrice(addrStableCoin,addrShitCoin);\n        require(minPrice < price, \"Bad Price.\"); \n        uint256 balance = IERC20(addrShitCoin).balanceOf(address(OWNER));\n        addrBalancerTrade.delegatecall(abi.encodeWithSignature(\"swapExactAmountIn(address,uint256,address,uint256,uint256)\",addrShitCoin,balance,addrStableCoin, 0 ,100000000000000000000000000000000));\n    }\n  \n    function poke() public onlyOwner {\n        addrPoke.call(abi.encodeWithSignature(\"pokeWeights()\"));\n    } \n    \n    function buy() public onlyOwner {\n        uint256 balance = IERC20(addrStableCoin).balanceOf(address(OWNER));\n        addrBalancerTrade.delegatecall(abi.encodeWithSignature(\"swapExactAmountIn(address,uint256,address,uint256,uint256)\",addrStableCoin,balance,addrShitCoin, 0, 100000000000000000000000000000000));\n    }\n    \n    function startAndBuy() public onlyOwner {\n        startContract.call(abi.encodeWithSignature(\"startPool()\"));\n        uint256 balanceStable = IERC20(addrStableCoin).balanceOf(address(OWNER));\n        addrBalancerTrade.delegatecall(abi.encodeWithSignature(\"swapExactAmountIn(address,uint256,address,uint256,uint256)\",addrStableCoin,balanceStable,addrShitCoin, 1, 100000000000000000000000000000000));\n    }\n///////////////////////// APPROVE //////////////////////////////\n\n    function approveSet() public onlyOwner {\n        IERC20 tokenInIERC20 = IERC20(addrStableCoin);\n        tokenInIERC20.approve(addrBalancerTrade, 1e60);\n        tokenInIERC20 = IERC20(addrShitCoin);\n        tokenInIERC20.approve(addrBalancerTrade, 1e60);\n    }\n\n//////////////    SET ALL ////////////////////////////////\n\n    function setALL(address _addrStableCoin,address _addrShitCoin,address _addrPoke,address _addrBalancerTrade,address _startContract) public onlyOwner{\n        addrStableCoin = _addrStableCoin;\n        addrShitCoin = _addrShitCoin;\n        addrPoke = _addrPoke;\n        addrBalancerTrade = _addrBalancerTrade;\n        startContract = _startContract;\n        approveSet();\n    }\n\n    \n///////////////////////////////////    WITHDRAW        ///////////////////////////\n\n    function withdrawToken(address _tokenAddress) public onlyOwner {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        IERC20(_tokenAddress).transfer(OWNER, balance);\n    }\n\n    function withdrawEther() public onlyOwner {\n        address self = address(this); \n        uint256 balance = self.balance;\n        payable(OWNER).transfer(balance);\n    }\n\n    fallback () external payable  {}\n\n}"
    }
  }
}