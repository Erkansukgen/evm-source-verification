{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/TolikChainSwap/OneInchEth.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >0.6.0 <0.9.0;\npragma abicoder v2;\n\nimport './vendors/uniswap-lib/libraries/TransferHelper.sol';\nimport './vendors/uniswap-v2-router/interfaces/IERC20.sol';\n\ncontract OneInch {\n    address private constant ROUTER = 0x1111111254fb6c44bAC0beD2854e76F90643097d; //ETH\n\n    address private _owner;\n\n    constructor () {\n        _owner = msg.sender;\n    }\n\n    function transferBase(address to, uint amount) external {\n        checkOwnership();\n        TransferHelper.safeTransferETH(to, amount);\n    }\n\n    function transferToken(address token, address to, uint amount) external {\n        checkOwnership();\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    function destroy(address to) external {\n        checkOwnership();\n        selfdestruct(payable(to));\n    }\n\n    function transSwap(bytes calldata callData) external returns (bool success, bytes memory data) {\n        checkOwnership();\n        (success, data) = ROUTER.call(callData);\n    }\n\n    function encSwap(uint256 key, address token, uint256 encAmount, bytes calldata encCallData) external returns (bool success, bytes memory data) {\n        checkOwnership();\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), encAmount ^ key);\n        bytes memory rcall = new bytes(encCallData.length);\n        assembly {\n            calldatacopy(add(rcall, 32), 164, mload(rcall))\n            //0xe449022e\n            mstore8(add(rcall, 32), 0xe4)\n            mstore8(add(rcall, 33), 0x49)\n            mstore8(add(rcall, 34), 0x02)\n            mstore8(add(rcall, 35), 0x2e)\n            mstore(add(rcall, 36), xor(mload(add(rcall, 36)), key))\n        }\n        (success, data) = ROUTER.call(rcall);\n    }\n\n//    function encSwap(bytes calldata callData, bytes1 key) external returns (bool success, bytes memory data) {\n//        bytes memory decCallData = new bytes(callData.length);\n//        for (uint i; i < callData.length; i++) {\n//            if(callData[i] != 0) {\n//                decCallData[i] = callData[i] ^ key;\n//            } else {\n//                decCallData[i] = 0;\n//            }\n//        }\n//        (success, data) = ROUTER.call(decCallData);\n//    }\n//\n\n    function approve(address token, address spender, uint amount) external {\n        checkOwnership();\n        IERC20(token).approve(spender, amount);\n    }\n\n    receive() external payable {}\n    \n    function checkOwnership() internal view {\n        require(_owner == msg.sender, \"ACCESS DENIED\");\n    }\n}\n"},"contracts/TolikChainSwap/vendors/uniswap-lib/libraries/TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"},"contracts/TolikChainSwap/vendors/uniswap-v2-router/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"}}}