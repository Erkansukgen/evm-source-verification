{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/StakeRewardRefill.sol":{"content":"pragma solidity ^0.6.7;\n\nabstract contract ERC20Events {\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n}\n\nabstract contract ERC20 is ERC20Events {\n    function totalSupply() virtual public view returns (uint);\n    function balanceOf(address guy) virtual public view returns (uint);\n    function allowance(address src, address guy) virtual public view returns (uint);\n\n    function approve(address guy, uint wad) virtual public returns (bool);\n    function transfer(address dst, uint wad) virtual public returns (bool);\n    function transferFrom(\n        address src, address dst, uint wad\n    ) virtual public returns (bool);\n}\n\ncontract StakeRewardRefill {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"StakeRewardRefill/account-not-authorized\");\n        _;\n    }\n\n    /**\n    * @notice Checks whether msg.sender can refill\n    **/\n    modifier canRefill {\n        require(either(openRefill == 1, authorizedAccounts[msg.sender] == 1), \"StakeRewardRefill/cannot-refill\");\n        _;\n    }\n\n    // --- Variables ---\n    // Last timestamp for a refill\n    uint256 public lastRefillTime;\n    // The delay between two consecutive refills\n    uint256 public refillDelay;\n    // The amount to send per refill\n    uint256 public refillAmount;\n    // Whether anyone can refill or only authed accounts\n    uint256 public openRefill;\n\n    // The address that receives tokens\n    address public refillDestination;\n\n    // The token used as reward\n    ERC20   public rewardToken;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(\n      bytes32 parameter,\n      address addr\n    );\n    event ModifyParameters(\n      bytes32 parameter,\n      uint256 val\n    );\n    event Refill(address refillDestination, uint256 amountToTransfer);\n\n    constructor(\n      address rewardToken_,\n      address refillDestination_,\n      uint256 openRefill_,\n      uint256 refillDelay_,\n      uint256 refillAmount_\n    ) public {\n        require(rewardToken_ != address(0), \"StakeRewardRefill/null-reward-token\");\n        require(refillDestination_ != address(0), \"StakeRewardRefill/null-refill-destination\");\n        require(refillDelay_ > 0, \"StakeRewardRefill/null-refill-delay\");\n        require(refillAmount_ > 0, \"StakeRewardRefill/null-refill-amount\");\n        require(openRefill_ <= 1, \"StakeRewardRefill/invalid-open-refill\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        openRefill        = openRefill_;\n        refillDelay       = refillDelay_;\n        refillAmount      = refillAmount_;\n        lastRefillTime    = now;\n\n        rewardToken       = ERC20(rewardToken_);\n        refillDestination = refillDestination_;\n\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"openRefill\", openRefill);\n        emit ModifyParameters(\"refillDestination\", refillDestination);\n        emit ModifyParameters(\"refillDelay\", refillDelay);\n        emit ModifyParameters(\"refillAmount\", refillAmount);\n    }\n\n    // --- Boolean Logic ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Math ---\n    function subtract(uint x, uint y) public pure returns (uint z) {\n        z = x - y;\n        require(z <= x, \"uint-uint-sub-underflow\");\n    }\n    function multiply(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\n    }\n\n    // --- Administration ---\n    /**\n    * @notice Modify an address parameter\n    * @param parameter The parameter name\n    * @param data The new parameter value\n    **/\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"StakeRewardRefill/null-address\");\n\n        if (parameter == \"refillDestination\") {\n          refillDestination = data;\n        } else revert(\"StakeRewardRefill/modify-unrecognized-param\");\n    }\n    /**\n    * @notice Modify a uint256 parameter\n    * @param parameter The parameter name\n    * @param data The new parameter value\n    **/\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"openRefill\") {\n          require(data <= 1, \"StakeRewardRefill/invalid-open-refill\");\n          openRefill = data;\n        } else if (parameter == \"lastRefillTime\") {\n          require(data >= lastRefillTime, \"StakeRewardRefill/invalid-refill-time\");\n          lastRefillTime = data;\n        } else if (parameter == \"refillDelay\") {\n          require(data > 0, \"StakeRewardRefill/null-refill-delay\");\n          refillDelay = data;\n        } else if (parameter == \"refillAmount\") {\n          require(data > 0, \"StakeRewardRefill/null-refill-amount\");\n          refillAmount = data;\n        }\n        else revert(\"StakeRewardRefill/modify-unrecognized-param\");\n    }\n    /**\n    * @notice Transfer tokens to a custom address\n    * @param dst Transfer destination\n    * @param amount Amount of tokens to transfer\n    **/\n    function transferTokenOut(address dst, uint256 amount) external isAuthorized {\n        require(dst != address(0), \"StakeRewardRefill/null-dst\");\n        require(amount > 0, \"StakeRewardRefill/null-amount\");\n\n        rewardToken.transfer(dst, amount);\n    }\n\n    // --- Core Logic ---\n    /**\n    * @notice Send tokens to refillDestination\n    * @dev This function can only be called if msg.sender passes canRefill checks\n    **/\n    function refill() external canRefill {\n        uint256 delay = subtract(now, lastRefillTime);\n        require(delay >= refillDelay, \"StakeRewardRefill/wait-more\");\n\n        // Update the last refill time\n        lastRefillTime = subtract(now, delay % refillDelay);\n\n        // Send tokens\n        uint256 amountToTransfer = multiply(delay / refillDelay, refillAmount);\n        rewardToken.transfer(refillDestination, amountToTransfer);\n\n        emit Refill(refillDestination, amountToTransfer);\n    }\n}"}}}