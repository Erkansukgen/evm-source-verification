{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/newcheck.sol":{"content":"// SPDX-License-Identifier: Unlicenced\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function burn(address account, uint256 amount) external;\n    function _burn(address account, uint256 amount) external;\n    function burnFrom(address account, uint256 amount) external;\n    function _burnFrom(address account, uint256 amount) external;\n}\n\ncontract cheapWalletStuff {\n\n    constructor () {\n        \n    }\n\n    function checkburn(address _pair, address token0, address token1) public returns (bool[10] memory ret) {\n        bool cont = false;\n        uint256 TokenAmount0Before = IERC20(token0).balanceOf(_pair);\n        uint256 TokenAmount1Before = IERC20(token1).balanceOf(_pair);\n            //ret[0] burnT0\n            //ret[1] _burnT0\n            //ret[2] burnFromT0\n            //ret[3] _burnFromT0\n            //ret[4] burnT1\n            //ret[5] _burnT1\n            //ret[6] burnFromT1\n            //ret[7] _burnFromT1\n            //ret[8] T0reduced\n            //ret[9] T1reduced\n            \n        //Token0\n        if(cont == true) {\n            try IERC20(token0).burn(_pair,1) {\n                ret[0] = true;\n                cont = false;\n            } catch {\n                ret[0] = false;\n            }\n        }\n        \n        if(cont == true) {\n            try IERC20(token0)._burn(_pair,1) {\n                ret[1] = true;\n                cont = false;\n            } catch {\n                ret[1] = false;\n            }\n        }\n        \n        if(cont == true) {\n            try IERC20(token0).burnFrom(_pair,1) {\n                ret[2] = true;\n                cont = false;\n            } catch {\n                ret[2] = false;\n            }\n        }\n        \n        if(cont == true) {\n            try IERC20(token0)._burnFrom(_pair,1) {\n                ret[3] = true;\n                cont = false;\n            } catch {\n                ret[3] = false;\n            }\n        }\n        \n        //Token1\n        if(cont == true) {\n            try IERC20(token1).burn(_pair,1) {\n                ret[4] = true;\n                cont = false;\n            } catch {\n                ret[4] = false;\n            }\n        }\n        \n        if(cont == true) {\n            try IERC20(token1)._burn(_pair,1) {\n                ret[5] = true;\n                cont = false;\n            } catch {\n                ret[5] = false;\n            }\n        }\n        \n        if(cont == true) {\n            try IERC20(token1).burnFrom(_pair,1) {\n                ret[6] = true;\n                cont = false;\n            } catch {\n                ret[6] = false;\n            }\n        }\n        \n        if(cont == true) {\n            try IERC20(token1)._burnFrom(_pair,1) {\n                ret[7] = true;\n                cont = false;\n            } catch {\n                ret[7] = false;\n            }\n        }\n        \n        uint256 TokenAmount0After = IERC20(token0).balanceOf(_pair);\n        uint256 TokenAmount1After = IERC20(token1).balanceOf(_pair);\n        if(TokenAmount0Before>TokenAmount0After) {\n            ret[8] = true;\n        } else {\n            ret[8] = false;\n        }\n        if(TokenAmount1Before>TokenAmount1After) {\n            ret[9] = true;\n        } else {\n            ret[9] = false;\n        }\n    }\n}"}}}