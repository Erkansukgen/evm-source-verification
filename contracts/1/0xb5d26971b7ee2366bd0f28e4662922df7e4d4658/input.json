{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/SwapFactory.sol": {
      "content": "// SPDX-License-Identifier: No License (None)\npragma solidity ^0.8.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IValidator {\n    // returns rate (with 18 decimals) = Token B price / Token A price\n    function getRate(address tokenA, address tokenB) external returns (uint256);\n    // returns: user balance, native (foreign for us) encoded balance, foreign (native for us) encoded balance\n    function checkBalances(address factory, address[] calldata user) external returns(uint256);\n    // returns: user balance\n    function checkBalance(address factory, address user) external returns(uint256);\n    // returns: oracle fee\n    function getOracleFee(uint256 req) external returns(uint256);  //req: 1 - cancel, 2 - claim, returns: value\n}\n\ninterface IReimbursement {\n    // returns fee percentage with 2 decimals\n    function getLicenseeFee(address vault, address projectContract) external view returns(uint256);\n    // returns fee receiver address or address(0) if need to refund fee to user.\n    function requestReimbursement(address user, uint256 feeAmount, address vault) external returns(address);\n}\n\ninterface ISPImplementation {\n    function initialize(\n        address _owner,     // contract owner\n        address _nativeToken, // native token that will be send to SmartSwap\n        address _foreignToken, // foreign token that has to be received from SmartSwap (on foreign chain)\n        address _nativeTokenReceiver, // address on Binance to deposit native token\n        address _foreignTokenReceiver, // address on Binance to deposit foreign token\n        uint256 _feeAmountLimit // limit of amount that System withdraw for fee reimbursement\n    )   external;\n    function owner() external returns(address);\n}\n\ninterface IAuction {\n    function contributeFromSmartSwap(address payable user) external payable returns (bool);\n    function contributeFromSmartSwap(address token, uint256 amount, address user) external returns (bool);\n}\n\nabstract contract Ownable {\n    address internal _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n/*  we use proxy, so owner will be set in initialize() function\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n*/\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ncontract SmartSwap is Ownable {\n\n    struct Cancel {\n        uint64 pairID; // pair ID\n        address sender; // user who has to receive canceled amount\n        uint256 amount; // amount of token user want to cancel from order\n        //uint128 foreignBalance; // amount of token already swapped (on other chain)\n    }\n\n    struct Claim {\n        uint64 pairID;     // pair ID\n        address sender;     // address who send tokens to swap\n        address receiver;   // address who has to receive swapped amount\n        uint64 claimID;     // uniq claim ID\n        bool isInvestment;  // is claim to contributeFromSmartSwap\n        uint128 amount;     // amount of foreign tokens user want to swap\n        uint128 currentRate;\n        uint256 foreignBalance;  //[0] foreignBalance, [1] foreignSpent, [2] nativeSpent, [3] nativeRate\n    }\n\n    struct Pair {\n        address tokenA;\n        address tokenB;        \n    }\n\n    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 1 - BNB, 2 - ETH, 3 - BTC\n    uint256 constant NOMINATOR = 10**18;\n    uint256 constant MAX_AMOUNT = 2**128;\n\n    address public foreignFactory;\n    address payable public validator;\n    uint256 public rateDiffLimit;   // allowed difference (in percent) between LP provided rate and Oracle rate.\n    mapping(address => bool) public isSystem;  // system address mey change fee amount\n    address public auction; // auction address\n    address public contractSmart;  // the reimbursement contract address\n    mapping (address => uint256) licenseeFee;  // NOT USED. the licensee may set personal fee (in percent wih 2 decimals). It have to compensate this fee with own tokens.\n    mapping (address => address) licenseeCompensator;    // NOT USED. licensee contract which will compensate fee with tokens\n \n    mapping(address => bool) public isExchange;         // is Exchange address\n    mapping(address => bool) public isExcludedSender;   // address excluded from receiving SMART token as fee compensation\n\n    // fees\n    uint256 public swapGasReimbursement;      // percentage of swap Gas Reimbursement by SMART tokens\n    uint256 public companyFeeReimbursement;   // percentage of company Fee Reimbursement by SMART tokens\n    uint256 public cancelGasReimbursement;    // percentage of cancel Gas Reimbursement by SMART tokens\n    uint256 public companyFee; // the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\n    uint256 public processingFee; // the fee in base coin, to compensate Gas when back-end call claimTokenBehalf()\n    address public feeReceiver; // address which receive the fee (by default is validator)\n    uint256 private collectedFees; // amount of collected fee (starts from 1 to avoid additional gas usage)\n\n    mapping(address => uint256) public decimals;   // token address => token decimals\n    uint256 public pairIDCounter;\n    mapping(uint256 => Pair) public getPairByID;\n    mapping(address => mapping(address => uint256)) public getPairID;    // tokenA => tokenB => pair ID or 0 if not exist\n    mapping(uint256 => uint256) public totalSupply;    // pairID => totalSupply amount of tokenA on the pair\n\n    // hashAddress = address(keccak256(tokenA, tokenB, sender, receiver))\n    mapping(address => uint256) private _balanceOf;       // hashAddress => amount of tokenA\n    mapping(address => Cancel) public cancelRequest;    // hashAddress => amount of tokenA to cancel\n    mapping(address => Claim) public claimRequest;      // hashAddress => amount of tokenA to swap\n\n    mapping(address => bool) public isLiquidityProvider;    // list of Liquidity Providers\n    uint256 claimIdCounter;    // counter of claim requests\n    address public reimbursementVault;  //company vault address in reimbursement contract\n    address public SPImplementation;  // address of swap provider contract implementation\n    uint256 public companySPFee; // the fee (in percent wih 2 decimals) that received by company from Swap provider. 30 - means 0.3%\n    uint256 collectedProcessingFee;\n\n// ============================ Events ============================\n\n    event PairAdded(address indexed tokenA, address indexed tokenB, uint256 indexed pairID);\n    event PairRemoved(address indexed tokenA, address indexed tokenB, uint256 indexed pairID);\n    event SwapRequest(\n        address indexed tokenA,\n        address indexed tokenB,\n        address indexed sender,\n        address receiver,\n        uint256 amountA,\n        bool isInvestment,\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\n        uint128 limitPice   // Do not match user if token A price less this limit\n    );\n    event CancelRequest(address indexed hashAddress, uint256 amount);\n    event CancelApprove(address indexed hashAddress, uint256 amount);\n    event ClaimRequest(address indexed hashAddress, uint64 claimID, uint256 amount, bool isInvestment);\n    event ClaimApprove(address indexed hashAddress, uint64 claimID, uint256 nativeAmount, uint256 foreignAmount, bool isInvestment);\n    event ExchangeInvestETH(address indexed exchange, address indexed whom, uint256 value);\n    event SetSystem(address indexed system, bool active);\n    event AddSwapProvider(address swapProvider, address spContract);\n    event PartialClaim(uint256 rest, uint256 totalSupply, uint256 nativeAmount);\n\n    /**\n    * @dev Throws if called by any account other than the system.\n    */\n    modifier onlySystem() {\n        require(isSystem[msg.sender] || isLiquidityProvider[msg.sender] || owner() == msg.sender, \"Caller is not the system\");\n        _;\n    }\n\n\n    // run only once from proxy\n    function initialize(address newOwner) external {\n        require(newOwner != address(0) && _owner == address(0)); // run only once\n        _owner = newOwner;\n        emit OwnershipTransferred(address(0), msg.sender);\n        rateDiffLimit = 5;   // allowed difference (in percent) between LP provided rate and Oracle rate.\n        swapGasReimbursement = 100;      // percentage of swap Gas Reimbursement by SMART tokens\n        companyFeeReimbursement = 100;   // percentage of company Fee Reimbursement by SMART tokens\n        cancelGasReimbursement = 100;    // percentage of cancel Gas Reimbursement by SMART tokens\n        companyFee = 0; // the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\n        collectedFees = 1; // amount of collected fee (starts from 1 to avoid additional gas usage)\n    }\n\n    // get amount of collected fees that can be claimed\n    function getColletedFees() external view returns (uint256) {\n        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\n        return collectedFees - 1;\n    }\n\n    // get amount of collected fees that can be claimed\n    function getProcessingFees() external view returns (uint256) {\n        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\n        return collectedProcessingFee - 1;\n    }\n\n    function claimProcessingFees() external onlySystem returns (uint256 processingFeeAmount) {\n        processingFeeAmount = collectedProcessingFee - 1;\n        collectedProcessingFee = 1;\n        TransferHelper.safeTransferETH(msg.sender, processingFeeAmount);\n    }\n\n    // claim fees by feeReceiver\n    function claimFee() external returns (uint256 feeAmount)\n    {\n        require(msg.sender == feeReceiver);\n        feeAmount = collectedFees - 1;\n        collectedFees = 1;\n        TransferHelper.safeTransferETH(msg.sender, feeAmount);\n    }\n\n    function balanceOf(address hashAddress) external view returns(uint256) {\n        return _balanceOf[hashAddress];\n    }\n\n    // return balance for swap\n    function getBalance(\n        address tokenA,\n        address tokenB, \n        address sender,\n        address receiver\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _balanceOf[_getHashAddress(tokenA, tokenB, sender, receiver)];\n    }\n\n    function getHashAddress(\n        address tokenA,\n        address tokenB, \n        address sender,\n        address receiver\n    )\n        external\n        pure\n        returns (address)\n    {\n        return _getHashAddress(tokenA, tokenB, sender, receiver);\n    }\n\n    //user should approve tokens transfer before calling this function.\n    //if no licensee set it to address(0)\n    function swap(\n        address tokenA, // token that user send to swap ( address(1) for BNB, address(2) for ETH)\n        address tokenB, // token that user want to receive ( address(1) for BNB, address(2) for ETH)\n        address receiver,   // address that will receive tokens on other chain (user's wallet address)\n        uint256 amountA,    // amount of tokens user sends to swap\n        address licensee,   // for now, = address(0)\n        bool isInvestment,  // for now, = false\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled. For now, = 0\n        uint128 limitPice,   // Do not match user if token A price less this limit. For now, = 0\n        uint256 fee          // company + licensee fee amount\n    )\n        external\n        payable\n        returns (bool)\n    {\n        _transferFee(tokenA, amountA, fee, msg.sender, licensee);\n        _swap(tokenA, tokenB, msg.sender, receiver, amountA, isInvestment, minimumAmountToClaim, limitPice);\n        return true;\n    }\n\n    function cancel(\n        address tokenA,\n        address tokenB, \n        address receiver,\n        uint256 amountA    //amount of tokenA to cancel\n    )\n        external\n        payable\n        returns (bool)\n    {\n        _cancel(tokenA, tokenB, msg.sender, receiver, amountA);\n        return true;\n    }\n\n    function cancelBehalf(\n        address tokenA,\n        address tokenB,\n        address sender,\n        address receiver,\n        uint256 amountA    //amount of tokenA to cancel\n    )\n        external\n        onlySystem\n        returns (bool)\n    {\n        _cancel(tokenA, tokenB, sender, receiver, amountA);\n        return true;\n    }\n\n    function claimTokenBehalf(\n        address tokenA, // foreignToken\n        address tokenB, // nativeToken\n        address sender,\n        address receiver,\n        bool isInvestment,\n        uint128 amountA,    //amount of tokenA that has to be swapped\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\n        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\n    )        \n        external\n        onlySystem\n        returns (bool) \n    {\n        _claimTokenBehalf(tokenA, tokenB, sender, receiver, isInvestment, amountA, currentRate, foreignBalance);\n        return true;\n    }\n\n    // add swap provider who will provide liquidity for swap (using centralized exchange)\n    function addSwapProvider(\n        address _nativeToken, // native token that will be send to SmartSwap\n        address _foreignToken, // foreign token that has to be received from SmartSwap (on foreign chain)\n        address _nativeTokenReceiver, // address on Binance to deposit native token\n        address _foreignTokenReceiver, // address on Binance to deposit foreign token\n        uint256 _feeAmountLimit // limit of amount that System may withdraw for fee reimbursement\n    )\n        external\n        returns (address spContract)\n    {\n        spContract = clone(SPImplementation);\n        ISPImplementation(spContract).initialize(\n            msg.sender,\n            _nativeToken,\n            _foreignToken,\n            _nativeTokenReceiver,\n            _foreignTokenReceiver,\n            _feeAmountLimit\n        );\n        isLiquidityProvider[spContract] = true;\n        emit AddSwapProvider(msg.sender, spContract);\n    }\n\n    function balanceCallback(address hashAddress, uint256 foreignBalance) external returns(bool) {\n        require (validator == msg.sender, \"Not validator\");\n        _cancelApprove(hashAddress, foreignBalance);\n        return true;\n    }\n\n    function balancesCallback(\n        address hashAddress, \n        uint256 foreignBalance, // total user's tokens balance on foreign chain\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\n        uint256 nativeEncoded   // (nativeRate, nativeSpent) = _decode(nativeEncoded)\n    ) \n        external \n        returns(bool) \n    {\n        require (validator == msg.sender, \"Not validator\");\n        _claimBehalfApprove(hashAddress, foreignBalance, foreignSpent, nativeEncoded);\n        return true;\n    }\n\n    // get system variables for debugging \n    function getPairVars(uint256 pairID) external view returns (uint256 native, uint256 foreign, uint256 foreignRate) {\n        address nativeHash = _getHashAddress(getPairByID[pairID].tokenA, getPairByID[pairID].tokenB, address(0), address(0));\n        address foreignHash = _getHashAddress(getPairByID[pairID].tokenB, getPairByID[pairID].tokenA, address(0), address(0));\n        // native - amount of native tokens that swapped from available foreign\n        native = _balanceOf[nativeHash];\n        // foreign = total foreign tokens already swapped\n        // foreignRate = rate (native price / foreign price) of available foreign tokens on other chain\n        (foreignRate, foreign) = _decode(_balanceOf[foreignHash]);\n        // Example: assume system vars = 0, rate of prices ETH/BNB = 2 (or BNB/ETH = 0.5)\n        // on ETH chain: \n        // 1. claim ETH for 60 BNB == 60 * 0.5 = 30 ETH, \n        // set: foreign = 60 BNB, foreignRate = 0.5 BNB/ETH prices (already swapped BNB)\n        //\n        // on BSC chain:\n        // 2. claim BNB for 20 ETH, assume new rate of prices ETH/BNB = 4 (or BNB/ETH = 0.25)\n        // get from ETH chain foreign(ETH) = 60 BNB, foreignRate(ETH) = 0.5 BNB/ETH prices\n        // available amount of already swapped BNB = 60 BNB (foreign from ETH) - 0 BNB (native) = 60 BNB with rate 0.5 BNB/ETH\n        // claimed BNB amount = 20 ETH / 0.5 BNB/ETH = 40 BNB (we use rate of already swapped BNB)\n        // set: native = 40 BNB (we use BNB that was already swapped on step 1)\n        //\n        // 3. New claim BNB for 30 ETH, assume new rate of prices ETH/BNB = 4 (or BNB/ETH = 0.25)\n        // get from ETH chain foreign(ETH) = 60 BNB, foreignRate(ETH) = 0.5 BNB/ETH prices\n        // available amount of already swapped BNB = 60 BNB (foreign from ETH) - 40 BNB (native) = 20 BNB with rate 0.5 BNB/ETH\n        // 20 BNB * 0.5 = 10 ETH (we claimed 20 BNB for 10 ETH with already swapped rate)\n        // set: native = 40 BNB + 20 BNB = 60 BNB (we use all BNB that was already swapped on step 1)\n        // claimed rest BNB amount for (30-10) ETH = 20 ETH / 0.25 BNB/ETH = 80 BNB (we use new rate)\n        // set: foreign = 20 ETH, foreignRate = 0.25 BNB/ETH prices (already swapped ETH)\n    }\n// ================== For Jointer Auction =========================================================================\n\n    // ETH side\n    // function for invest ETH from from exchange on user behalf\n    function contributeWithEtherBehalf(address payable _whom) external payable returns (bool) {\n        require(isExchange[msg.sender], \"Not an Exchange address\");\n        address tokenA = address(2);    // ETH (native coin)\n        address tokenB = address(1);    // BNB (foreign coin)\n        uint256 amount = msg.value - processingFee; // charge processing fee\n        amount = amount * 10000 / (10000 + companyFee); // charge company fee\n        uint256 fee = msg.value - (amount + processingFee); // company fee\n        emit ExchangeInvestETH(msg.sender, _whom, msg.value);\n        _transferFee(tokenA, amount, fee, _whom, address(0));    // no licensee\n        _swap(tokenA, tokenB, _whom, auction, amount, true,0,0);\n        return true;\n    }\n\n    // BSC side\n    // tokenB - foreign token address or address(1) for ETH\n    // amountB - amount of foreign tokens or ETH\n    function claimInvestmentBehalf(\n        address tokenB, // foreignToken\n        address user, \n        uint128 amountB,    //amount of tokenB that has to be swapped\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / Native coin price\n        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\n    ) \n        external \n        onlySystem \n        returns (bool) \n    {\n        address tokenA = address(1);    // BNB (native coin)\n        _claimTokenBehalf(tokenB, tokenA, user, auction, true, amountB, currentRate, foreignBalance);\n        return true;\n    }\n    \n    // reimburse user for SP payment\n    function reimburse(address user, uint256 amount) external onlySystem {\n        address reimbursementContract = contractSmart;\n        if (reimbursementContract != address(0) && amount !=0) {\n            IReimbursement(reimbursementContract).requestReimbursement(user, amount, reimbursementVault);\n        }\n    }\n// ================= END For Jointer Auction ===========================================================================\n\n// ============================ Restricted functions ============================\n\n    // set processing fee - amount that have to be paid on other chain to claimTokenBehalf.\n    // Set in amount of native coins (BNB or ETH)\n    function setProcessingFee(uint256 _fee) external onlySystem returns(bool) {\n        processingFee = _fee;\n        return true;\n    }\n/*\n    // set licensee compensator contract address, if this address is address(0) - remove licensee.\n    // compensator contract has to compensate the fee by other tokens.\n    // licensee fee in percent with 2 decimals. I.e. 10 = 0.1%\n    function setLicensee(address _licensee, address _compensator, uint256 _fee) external onlySystem returns(bool) {\n        licenseeCompensator[_licensee] = _compensator;\n        require(_fee < 10000, \"too big fee\");    // fee should be less then 100%\n        licenseeFee[_licensee] = _fee;\n        emit SetLicensee(_licensee, _compensator);\n        return true;\n    }\n\n    // set licensee fee in percent with 2 decimals. I.e. 10 = 0.1%\n    function setLicenseeFee(uint256 _fee) external returns(bool) {\n        require(licenseeCompensator[msg.sender] != address(0), \"licensee is not registered\");\n        require(_fee < 10000, \"too big fee\");    // fee should be less then 100%\n        licenseeFee[msg.sender] = _fee;\n        return true;\n    }\n*/\n// ============================ Owner's functions ============================\n\n    //allowed difference in rate between Oracle and provided by company. in percent without decimals (5 = 5%)\n    function setRateDiffLimit(uint256 _rateDiffLimit) external onlyOwner returns(bool) {\n        require(_rateDiffLimit < 100, \"too big limit\");    // fee should be less then 100%\n        rateDiffLimit = _rateDiffLimit;\n        return true;\n    }\n\n    //the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\n    function setCompanyFee(uint256 _fee) external onlyOwner returns(bool) {\n        require(_fee < 10000, \"too big fee\");    // fee should be less then 100%\n        companyFee = _fee;\n        return true;\n    }\n\n    //the fee (in percent wih 2 decimals) that received by company from Swap provider. 30 - means 0.3%\n    function setCompanySPFee(uint256 _fee) external onlyOwner returns(bool) {\n        require(_fee < 10000, \"too big fee\");    // fee should be less then 100%\n        companySPFee = _fee;\n        return true;\n    }\n\n    // Reimbursement Percentage without decimals: 100 = 100%\n    function setReimbursementPercentage (uint256 id, uint256 _fee) external onlyOwner returns(bool) {\n        if (id == 1) swapGasReimbursement = _fee;      // percentage of swap Gas Reimbursement by SMART tokens\n        else if (id == 2) cancelGasReimbursement = _fee;    // percentage of cancel Gas Reimbursement by SMART tokens\n        else if (id == 3) companyFeeReimbursement = _fee;   // percentage of company Fee Reimbursement by SMART tokens\n        return true;\n    }\n\n    function setSystem(address _system, bool _active) external onlyOwner returns(bool) {\n        isSystem[_system] = _active;\n        emit SetSystem(_system, _active);\n        return true;\n    }\n\n    function setValidator(address payable _validator) external onlyOwner returns(bool) {\n        validator = _validator;\n        return true;\n    }\n\n    function setForeignFactory(address _addr) external onlyOwner returns(bool) {\n        foreignFactory = _addr;\n        return true;\n    }\n\n    function setFeeReceiver(address _addr) external onlyOwner returns(bool) {\n        feeReceiver = _addr;\n        return true;\n    }\n\n    function setReimbursementContractAndVault(address reimbursement, address vault) external onlyOwner returns(bool) {\n        contractSmart = reimbursement;\n        reimbursementVault = vault;\n        return true;\n    }\n\n    function setAuction(address _addr) external onlyOwner returns(bool) {\n        auction = _addr;\n        return true;\n    }\n\n    // for ETH side only\n    function changeExchangeAddress(address _which,bool _bool) external onlyOwner returns(bool){\n        isExchange[_which] = _bool;\n        return true;\n    }\n    \n    function changeExcludedAddress(address _which,bool _bool) external onlyOwner returns(bool){\n        isExcludedSender[_which] = _bool;\n        return true;\n    }\n\n    function createPair(address tokenA, uint256 decimalsA, address tokenB, uint256 decimalsB) public onlyOwner returns (uint256) {\n        require(getPairID[tokenA][tokenB] == 0, \"Pair exist\");\n        uint256 pairID = ++pairIDCounter;\n        getPairID[tokenA][tokenB] = pairID;\n        getPairByID[pairID] = Pair(tokenA, tokenB);\n        if (decimals[tokenA] == 0) decimals[tokenA] = decimalsA;\n        if (decimals[tokenB] == 0) decimals[tokenB] = decimalsB;\n        return pairID;\n    }\n\n    function setSPImplementation(address _SPImplementation) external onlyOwner {\n        require(_SPImplementation != address(0));\n        SPImplementation = _SPImplementation;\n    }\n\n// ============================ Internal functions ============================\n    function _swap(\n        address tokenA, // nativeToken\n        address tokenB, // foreignToken\n        address sender,\n        address receiver,\n        uint256 amountA,\n        bool isInvestment,\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\n        uint128 limitPice   // Do not match user if token A price less this limit\n    )\n        internal\n    {\n        uint256 pairID = getPairID[tokenA][tokenB];\n        require(pairID != 0, \"Pair not exist\");\n        if (tokenA > NATIVE_COINS) {\n            TransferHelper.safeTransferFrom(tokenA, sender, address(this), amountA);\n        }\n        // (amount >= msg.value) is checking when pay fee in the function transferFee()\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\n        _balanceOf[hashAddress] += amountA;\n        totalSupply[pairID] += amountA;\n        emit SwapRequest(tokenA, tokenB, sender, receiver, amountA, isInvestment, minimumAmountToClaim, limitPice);\n    }\n\n    function _cancel(\n        address tokenA, // nativeToken\n        address tokenB, // foreignToken\n        address sender,\n        address receiver,\n        uint256 amountA    //amount of tokenA to cancel\n        //uint128 foreignBalance // amount of tokenA swapped by hashAddress (get by server-side)\n    )\n        internal\n    {\n        if(!isSystem[msg.sender]) { // process fee if caller is not System\n            require(msg.value >= IValidator(validator).getOracleFee(1), \"Insufficient fee\");    // check oracle fee for Cancel request\n            collectedFees += msg.value;\n            if(contractSmart != address(0) && !isExcludedSender[sender]) {\n                uint256 feeAmount = (msg.value + 60000*tx.gasprice) * cancelGasReimbursement / 100;\n                if (feeAmount != 0)\n                    IReimbursement(contractSmart).requestReimbursement(sender, feeAmount, reimbursementVault);\n            }\n        }\n\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\n        uint256 pairID = getPairID[tokenA][tokenB];\n        require(pairID != 0, \"Pair not exist\");\n        if (cancelRequest[hashAddress].amount == 0) {  // new cancel request\n            uint256 balance = _balanceOf[hashAddress];\n            require(balance >= amountA && amountA != 0, \"Wrong amount\");\n            totalSupply[pairID] = totalSupply[pairID] - amountA;\n            _balanceOf[hashAddress] = balance - amountA;\n        } else {\n            revert(\"There is pending cancel request\");\n        }\n        cancelRequest[hashAddress] = Cancel(uint64(pairID), sender, amountA);\n        // request Oracle for fulfilled amount from hashAddress\n        IValidator(validator).checkBalance(foreignFactory, hashAddress);\n        emit CancelRequest(hashAddress, amountA);\n        //emit CancelRequest(tokenA, tokenB, sender, receiver, amountA);\n    }\n\n    function _cancelApprove(address hashAddress, uint256 foreignBalance) internal {\n        Cancel memory c = cancelRequest[hashAddress];\n        delete cancelRequest[hashAddress];\n        //require(c.foreignBalance == foreignBalance, \"Oracle error\");\n        uint256 balance = _balanceOf[hashAddress];\n        uint256 amount = uint256(c.amount);\n        uint256 pairID = uint256(c.pairID);\n        if (foreignBalance <= balance) {\n            //approved - transfer token to its sender\n            _transfer(getPairByID[pairID].tokenA, c.sender, amount);\n        } else {\n            //disapproved\n            balance += amount;\n            _balanceOf[hashAddress] = balance;\n            totalSupply[pairID] += amount;\n            amount = 0;\n        }\n        emit CancelApprove(hashAddress, amount);\n    }\n\n    function _claimTokenBehalf(\n        address tokenA, // foreignToken\n        address tokenB, // nativeToken\n        address sender,\n        address receiver,\n        bool isInvestment,\n        uint128 amountA,    //amount of tokenA that has to be swapped\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\n        uint256 foreignBalance  // total tokens amount sent bu user to pair on other chain\n        // [1] foreignSpent, [2] nativeSpent, [3] nativeRate\n    )\n        internal\n    {\n        uint256 pairID = getPairID[tokenB][tokenA]; // getPairID[nativeToken][foreignToken]\n        require(pairID != 0, \"Pair not exist\");\n        // check rate\n        uint256 diffRate;\n        uint256 oracleRate = IValidator(validator).getRate(tokenB, tokenA);\n        if (uint256(currentRate) < oracleRate) {\n            diffRate = 100 - (uint256(currentRate) * 100 / oracleRate);\n        } else {\n            diffRate = 100 - (oracleRate * 100 / uint256(currentRate));\n        }\n        require(diffRate <= rateDiffLimit, \"Wrong rate\");\n\n        uint64 claimID;\n        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\n        if (claimRequest[hashAddress].amount == 0) {  // new claim request\n            _balanceOf[hashAddress] += uint256(amountA); // total swapped amount of foreign token\n            claimID = uint64(++claimIdCounter);\n        } else { // repeat claim request in case oracle issues.\n            claimID = claimRequest[hashAddress].claimID;\n            if (amountA == 0) {    // cancel claim request\n                emit ClaimApprove(hashAddress, claimID, 0, 0, claimRequest[hashAddress].isInvestment);\n                _balanceOf[hashAddress] = _balanceOf[hashAddress] - claimRequest[hashAddress].amount;\n                delete claimRequest[hashAddress];\n                return;\n            }\n            amountA = claimRequest[hashAddress].amount;\n        }\n        address[] memory users = new address[](3);\n        users[0] = hashAddress;\n        users[1] = _getHashAddress(tokenA, tokenB, address(0), address(0)); // Native hash address on foreign chain\n        users[2] = _getHashAddress(tokenB, tokenA, address(0), address(0)); // Foreign hash address on foreign chain\n        claimRequest[hashAddress] = Claim(uint64(pairID), sender, receiver, claimID, isInvestment, amountA, currentRate, foreignBalance);\n        IValidator(validator).checkBalances(foreignFactory, users);\n        emit ClaimRequest(hashAddress, claimID, amountA, isInvestment);\n        //emit ClaimRequest(tokenA, tokenB, sender, receiver, amountA);\n    }\n\n    // Approve or disapprove claim request.\n    function _claimBehalfApprove(\n        address hashAddress, \n        uint256 foreignBalance, // total user's tokens balance on foreign chain\n        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\n        uint256 nativeEncoded   // (nativeSpent, nativeRate) = _decode(nativeEncoded)\n    ) \n        internal \n    {\n        Claim memory c = claimRequest[hashAddress];\n        delete claimRequest[hashAddress];\n        //address hashSwap = _getHashAddress(getPairByID[c.pairID].tokenB, getPairByID[c.pairID].tokenA, c.sender, c.receiver);\n        uint256 balance = _balanceOf[hashAddress];   // swapped amount of foreign tokens (include current claim amount)\n        uint256 amount = uint256(c.amount);     // amount of foreign token to swap\n        require (amount != 0, \"No active claim request\");\n        require(foreignBalance == c.foreignBalance, \"Oracle error\");\n\n        uint256 nativeAmount;\n        uint256 rest;\n        if (foreignBalance >= balance) {\n            //approve, user deposited not less foreign tokens then want to swap\n            uint256 pairID = uint256(c.pairID);\n            (uint256 nativeRate, uint256 nativeSpent) = _decode(nativeEncoded);\n            (nativeAmount, rest) = _calculateAmount(\n                pairID,\n                amount, \n                uint256(c.currentRate),\n                foreignSpent,\n                nativeSpent,\n                nativeRate\n            );\n            if (rest != 0) {\n                _balanceOf[hashAddress] = balance - rest;    // not all amount swapped\n                amount = amount - rest;     // swapped amount\n            }\n            require(totalSupply[pairID] >= nativeAmount, \"Not enough Total Supply\");   // may be commented\n            totalSupply[pairID] = totalSupply[pairID] - nativeAmount;\n            if (c.isInvestment)\n                _contributeFromSmartSwap(getPairByID[pairID].tokenA, c.receiver, c.sender, nativeAmount);\n            else\n                _transfer(getPairByID[pairID].tokenA, c.receiver, nativeAmount);\n        } else {\n            //disapprove, discard claim\n            _balanceOf[hashAddress] = balance - amount;\n            amount = 0;\n        }\n        emit ClaimApprove(hashAddress, c.claimID, nativeAmount, amount, c.isInvestment);\n    }\n\n    // use structure to avoid stack too deep\n    struct CalcVariables {\n        // 18 decimals nominator with decimals converter: \n        // Foreign = Native * Rate(18) / nominatorNativeToForeign\n        uint256 nominatorForeignToNative; // 10**(18 + foreign decimals - native decimals)\n        uint256 nominatorNativeToForeign; // 10**(18 + native decimals - foreign decimals)\n        uint256 localNative;        // already swapped Native tokens = _balanceOf[hashNative]\n        uint256 localForeign;       // already swapped Foreign tokens = decoded _balanceOf[hashForeign]\n        uint256 localForeignRate;   // Foreign token price / Native token price = decoded _balanceOf[hashForeign]\n        address hashNative;         // _getHashAddress(tokenA, tokenB, address(0), address(0));\n        address hashForeign;        // _getHashAddress(tokenB, tokenA, address(0), address(0));\n    }\n\n    function _calculateAmount(\n        uint256 pairID,\n        uint256 foreignAmount,\n        uint256 rate,    // Foreign token price / Native token price = (Native amount / Foreign amount)\n        uint256 foreignSpent,   // already swapped Foreign tokens (got from foreign contract)\n        uint256 nativeSpent,    // already swapped Native tokens (got from foreign contract)\n        uint256 nativeRate  // Native token price / Foreign token price. I.e. on BSC side: BNB price / ETH price = 0.2\n    )\n        internal\n        returns(uint256 nativeAmount, uint256 rest)\n    {\n        CalcVariables memory vars;\n        {\n            address tokenA = getPairByID[pairID].tokenA;\n            address tokenB = getPairByID[pairID].tokenB;\n            uint256 nativeDecimals = decimals[tokenA];\n            uint256 foreignDecimals = decimals[tokenB];\n            vars.nominatorForeignToNative = 10**(18+foreignDecimals-nativeDecimals);\n            vars.nominatorNativeToForeign = 10**(18+nativeDecimals-foreignDecimals);\n            vars.hashNative = _getHashAddress(tokenA, tokenB, address(0), address(0));\n            vars.hashForeign = _getHashAddress(tokenB, tokenA, address(0), address(0));\n            vars.localNative = _balanceOf[vars.hashNative];\n            (vars.localForeignRate, vars.localForeign) = _decode(_balanceOf[vars.hashForeign]);\n        }\n\n        // step 1. Check is it enough unspent native tokens\n        {\n            require(nativeSpent >= vars.localNative, \"NativeSpent balance higher then remote\");\n            uint256 nativeAvailable = nativeSpent - vars.localNative;\n            // nativeAvailable - amount ready to spend native tokens\n            // nativeRate = Native token price / Foreign token price. I.e. on BSC side BNB price / ETH price = 0.2\n            if (nativeAvailable != 0) {\n                // ?\n                uint256 requireAmount = foreignAmount * vars.nominatorNativeToForeign / nativeRate;\n                if (requireAmount <= nativeAvailable) {\n                    nativeAmount = requireAmount;   // use already swapped tokens\n                    foreignAmount = 0;\n                }\n                else {\n                    nativeAmount = nativeAvailable;\n                    foreignAmount = (requireAmount - nativeAvailable) * nativeRate / vars.nominatorNativeToForeign;\n                }\n                _balanceOf[vars.hashNative] += nativeAmount;\n            }\n        }\n        require(totalSupply[pairID] >= nativeAmount,\"ERR: Not enough Total Supply\");\n        // step 2. recalculate rate for swapped tokens\n        if (foreignAmount != 0) {\n            // i.e. on BSC side: rate = ETH price / BNB price = 5\n            uint256 requireAmount = foreignAmount * rate / vars.nominatorForeignToNative;\n            if (totalSupply[pairID] < nativeAmount + requireAmount) {\n                requireAmount = totalSupply[pairID] - nativeAmount;\n                rest = foreignAmount - (requireAmount * vars.nominatorForeignToNative / rate);\n                foreignAmount = foreignAmount - rest;\n                emit PartialClaim(rest, totalSupply[pairID], nativeAmount);\n            }\n            nativeAmount = nativeAmount + requireAmount;\n            require(vars.localForeign >= foreignSpent, \"ForeignSpent balance higher then local\");\n            uint256 foreignAvailable = vars.localForeign - foreignSpent;\n            // vars.localForeignRate, foreignAvailable - rate and amount swapped foreign tokens\n            if (foreignAvailable != 0) { // recalculate avarage rate (native amount / foreign amount)\n                rate = ((foreignAvailable * vars.localForeignRate) + (requireAmount * vars.nominatorForeignToNative)) / (foreignAvailable + foreignAmount);\n            }\n            _balanceOf[vars.hashForeign] = _encode(rate, vars.localForeign + foreignAmount);\n        }\n    }\n\n    // transfer fee to receiver and request SMART token as compensation.\n    // tokenA - token that user send\n    // amount - amount of tokens that user send\n    // user - address of user\n    function _transferFee(address tokenA, uint256 amount, uint256 fee, address user, address licensee) internal {\n        uint256 txGas = gasleft();\n        uint256 feeAmount = msg.value;\n        uint256 companyFeeAmount; // company fee\n        uint256 _companyFee;\n        if (isLiquidityProvider[msg.sender]) {\n            _companyFee = companySPFee;\n            user = ISPImplementation(msg.sender).owner();\n        } else {\n            _companyFee = companyFee;\n        }\n\n        if (tokenA < NATIVE_COINS) {\n            require(feeAmount >= amount, \"Insuficiant value\");   // if native coin, then feeAmount = msg.value - swap amount\n            feeAmount -= amount;\n            companyFeeAmount = amount * _companyFee / 10000;    // company fee\n        }\n        require(feeAmount >= processingFee + fee && fee >= companyFeeAmount, \"Insufficient processing fee\");\n        if (contractSmart == address(0)) {\n            collectedProcessingFee += feeAmount;\n            return;    // return if no reimbursement contract \n        }\n        uint256 _processingFee = feeAmount - fee;\n\n        uint256 licenseeFeeAmount;\n        if (licensee != address(0)) {\n            uint256 licenseeFeeRate = IReimbursement(contractSmart).getLicenseeFee(licensee, address(this));\n            if (licenseeFeeRate != 0 && fee != 0) {\n                if (tokenA < NATIVE_COINS) {\n                    licenseeFeeAmount = amount * licenseeFeeRate / 10000;\n                } else {\n                    licenseeFeeAmount = (fee * licenseeFeeRate)/(licenseeFeeRate + _companyFee);\n                    companyFeeAmount = fee - licenseeFeeAmount;\n                }\n            }\n        }\n        if (fee >= companyFeeAmount + licenseeFeeAmount) {\n            companyFeeAmount = fee - licenseeFeeAmount;\n        } else {\n            revert(\"Insuficiant fee\");\n        }\n\n        if (licenseeFeeAmount != 0) {\n            address licenseeFeeTo = IReimbursement(contractSmart).requestReimbursement(user, licenseeFeeAmount, licensee);\n            if (licenseeFeeTo == address(0)) {\n                TransferHelper.safeTransferETH(user, licenseeFeeAmount);    // refund to user\n            } else {\n                TransferHelper.safeTransferETH(licenseeFeeTo, licenseeFeeAmount); // transfer to fee receiver\n            }\n        }\n\n        collectedFees += companyFeeAmount;\n        collectedProcessingFee += _processingFee;\n        if(!isExcludedSender[user]) {\n            txGas -= gasleft(); // get gas amount that was spent on Licensee fee\n            feeAmount = (companyFeeAmount * companyFeeReimbursement + (_processingFee + (txGas + 73000)*tx.gasprice) * swapGasReimbursement) / 100;\n            if (feeAmount != 0)\n                IReimbursement(contractSmart).requestReimbursement(user, feeAmount, reimbursementVault);\n        }\n    }\n    \n    // contribute from SmartSwap on user behalf\n    function _contributeFromSmartSwap(address token, address to, address user, uint256 value) internal {\n        if (token < NATIVE_COINS) {\n            IAuction(to).contributeFromSmartSwap{value: value}(payable(user));\n        } else {\n            IERC20(token).approve(to, value);\n            IAuction(to).contributeFromSmartSwap(token, value, user);\n        }\n    }\n\n    // call appropriate transfer function\n    function _transfer(address token, address to, uint256 value) internal {\n        if (token < NATIVE_COINS) \n            TransferHelper.safeTransferETH(to, value);\n        else\n            TransferHelper.safeTransfer(token, to, value);\n    }\n\n    // encode 64 bits of rate (decimal = 9). and 192 bits of amount \n    // into uint256 where high 64 bits is rate and low 192 bit is amount\n    // rate = foreign token price / native token price\n    function _encode(uint256 rate, uint256 amount) internal pure returns(uint256 encodedBalance) {\n        require(amount < MAX_AMOUNT, \"Amount overflow\");\n        require(rate < MAX_AMOUNT, \"Rate overflow\");\n        encodedBalance = rate * MAX_AMOUNT + amount;\n    }\n\n    // decode from uint256 where high 64 bits is rate and low 192 bit is amount\n    // rate = foreign token price / native token price\n    function _decode(uint256 encodedBalance) internal pure returns(uint256 rate, uint256 amount) {\n        rate = encodedBalance / MAX_AMOUNT;\n        amount = uint128(encodedBalance);\n    }\n    \n    function _getHashAddress(\n        address tokenA,\n        address tokenB, \n        address sender,\n        address receiver\n    )\n        internal\n        pure\n        returns (address)\n    {\n        return address(uint160(uint256(keccak256(abi.encodePacked(tokenA, tokenB, sender, receiver)))));\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behavior of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n    \n    \n    /*// ============================= START for TEST only =============================================================\n    function reset(uint pairID) external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n        collectedFees = 1;\n        address tokenA = getPairByID[pairID].tokenA;\n        if (tokenA > NATIVE_COINS) {\n            uint balance = IERC20(tokenA).balanceOf(address(this));\n            TransferHelper.safeTransfer(tokenA, msg.sender, balance);\n        }\n        address nativeHash = _getHashAddress(tokenA, getPairByID[pairID].tokenB, address(0), address(0));\n        address foreignHash = _getHashAddress(getPairByID[pairID].tokenB, tokenA, address(0), address(0));\n        _balanceOf[nativeHash] = 0;\n        _balanceOf[foreignHash] = 0;\n        totalSupply[pairID] = 0;\n        \n    }\n    function clearBalances(uint pairID, address[] calldata users) external onlyOwner {\n        address tokenA = getPairByID[pairID].tokenA;\n        address tokenB = getPairByID[pairID].tokenB;\n        for (uint i = 0; i < users.length; i++) {\n            _balanceOf[users[i]] = 0;\n            delete claimRequest[users[i]];\n            address hashAddress = _getHashAddress(tokenA, tokenB, users[i], users[i]);\n            _balanceOf[hashAddress] = 0;\n            delete claimRequest[hashAddress];\n            hashAddress = _getHashAddress(tokenB, tokenA, users[i], users[i]);\n            _balanceOf[hashAddress] = 0;\n            delete claimRequest[hashAddress];\n        }\n    }\n    */// =============================== END for TEST only =============================================================\n}\n"
    }
  }
}