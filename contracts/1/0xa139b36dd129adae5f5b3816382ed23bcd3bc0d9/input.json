{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1024},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/net_token.sol":{"content":"/* \n(c) 2020 Network Token\nPowered by PROOF CAPITAL GROUP\nDeveloped by @cryptocreater\n*/\n\npragma solidity 0.6.6;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\ncontract ERC20 is IERC20 {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }    \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        require(_allowances[sender][msg.sender] >= amount, \"Increase allowance to zero amount\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        require(addedValue > 0, \"Increase allowance to zero amount\");\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        require(_allowances[msg.sender][spender] >= subtractedValue, \"Decreased allowance below zero\");\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n        require(amount > 0, \"Zero amount transfer\");\n        require(_balances[sender] >= amount, \"Transfer amount exceeds balance\");\n        uint256 _value = fn_tokenTransfer(sender, recipient, amount);\n        if(_value > 0) {\n            _burn(sender, amount);\n            payable(sender).transfer(_value);\n        } else {\n            _balances[sender] -= amount;\n            _balances[recipient] += amount;\n        }\n    }\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"Mint to the zero address\");\n        require(amount > 0, \"Zero amount mint\");\n        _totalSupply += amount;\n        _balances[account] += amount;\n    }\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"Burn from the zero address\");\n        require(_balances[account] >= amount, \"Burn amount exceeds balance\");\n        require(_totalSupply >= amount, \"Burn amount exceeds total supply\");\n        _balances[account] -= amount;\n        _totalSupply -= amount;\n    }\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n        _allowances[owner][spender] = amount;\n    }\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n    function fn_tokenTransfer(address from, address to, uint256 amount) internal virtual returns (uint256) { }\n}\ncontract ERC20DecimalsMock is ERC20 {\n    constructor (string memory name, string memory symbol, uint8 decimals) public ERC20(name, symbol) {\n        _setupDecimals(decimals);\n    }\n}\ncontract Network is ERC20DecimalsMock(\"Network\", \"NET\", 18) {\n    address public smart;\n    mapping(address => address) public referrers;\n    uint256 public raisup = 1e20;\n    constructor() public {\n        smart = address(this);\n        referrers[msg.sender] = smart;\n        referrers[smart] = smart;\n    }\n    function fn_tokenTransfer(address _from, address _to, uint256 _amount) internal override returns (uint256) {\n        if(_to == smart) {\n            return _amount * smart.balance / totalSupply();\n        } else {\n            if(referrers[_to] == address(0)) referrers[_to] = _from;\n            return 0;\n        }\n    }\n    receive() payable external {\n        require(referrers[msg.sender] != address(0), \"Account is not activated\");\n        require(msg.value > 0, \"Zero amount of Ethers\");\n        address _referrer = referrers[msg.sender];\n        uint256 _cap = smart.balance - msg.value;\n        uint256 _purchase = _cap > 0 ? msg.value * totalSupply() / _cap : msg.value;\n        fn_checkout(msg.sender, _referrer, _purchase);\n    }\n    function fn_checkout(address _account, address _referrer, uint256 _purchase) private {\n        uint256 _payout = _purchase * 7 / 10;\n        uint256 _profit = _purchase - _payout;\n        uint256 _reward = _profit / 2;\n        uint256 _minimum = 625 * 1e14;\n        _mint(_account, _payout);\n        for(uint256 _level = 0; _level < 10; _level++) {\n            if(_referrer != smart ) {\n                if(balanceOf(_referrer) >= _minimum) {\n                    uint256 _reward_ = balanceOf(_referrer) > _purchase ? _reward : _reward * balanceOf(_referrer) / _purchase;\n                    _profit -= _reward_;\n                    _mint(_referrer, _reward_);\n                }\n            } else {\n                _level = 10;\n            }\n            _minimum *= 2;\n            _reward /= 2;\n            _referrer = referrers[_referrer];\n        }\n        if(raisup > 0) {\n            if(_profit > 0) _mint(smart, _profit);\n            if(totalSupply() >= raisup) {\n                raisup = 0;\n                _burn(smart, balanceOf(smart));\n            }\n        }\n    }\n    function burn(uint256 _value) external {\n        _burn(msg.sender, _value);\n    }\n    function rate() external view returns (uint256) {\n        return totalSupply() > 0 && smart.balance > 0 ? smart.balance * 1e6 / totalSupply() : 1e6;\n    }\n    function cap() external view returns (uint256) {\n        return smart.balance > 0 ? smart.balance : 0;\n    }\n}"}}}