{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "/home/konstantinovv/source/pollen/investment-fund-dao/contracts/StakeholdersWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n\ninterface IERC20Min {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n// It distributes ERC-20 tokens from its balance to stakeholders\ncontract StakeholdersWallet {\n\n    struct StakeHolder {\n        address wallet;\n        uint32 stake;\n    }\n\n    // Reserved storage space for possible proxies' use\n    uint256[100] __gap;\n\n    // Sum of stakes scaled by 1e4\n    uint256 public stakesSum;\n\n    // Mapping from stakeholder ID (index starting from 1) to stakeholder data\n    mapping(uint256 => StakeHolder) public stakeholders;\n    uint public numOfStakes;\n\n    bool private _notEntered;\n\n    event Stakeholder(uint256 indexed id, address wellet, uint256 stake);\n    event WalletUpdate(uint256 id, address newWallet);\n    event Distributed(uint256 indexed id, address token, uint256 amount);\n\n    constructor (StakeHolder[] memory _stakeholders) public\n    {\n        _notEntered = true;\n\n        // To minimize 'out of gas' risk on distributions\n        require(_stakeholders.length <= 20, \"too many stakeholders\");\n\n        for (uint i = 0 ; i < _stakeholders.length; i++) {\n            _revertZeroAddress(_stakeholders[i].wallet);\n            require(\n                _stakeholders[i].stake != 0 && _stakeholders[i].stake < 2**32,\n                \"invalid stake\"\n            );\n\n            stakeholders[i + 1] = _stakeholders[i];\n\n            // can't overflow (no safeMath needed)\n            numOfStakes = numOfStakes + 1;\n            stakesSum = stakesSum + _stakeholders[i].stake;\n\n            emit Stakeholder(i + 1, _stakeholders[i].wallet, _stakeholders[i].stake);\n        }\n    }\n\n    // Distribute this contract balance between stakeholders (anyone can call)\n    function distribute(IERC20Min token) external {\n        require(_notEntered, \"reentrant call\");\n        _notEntered = false;\n\n        _revertZeroAddress(address(token));\n        require(stakesSum != 0, \"no stakes to distribute between\");\n\n        uint256 balance = token.balanceOf(address(this));\n        // division by zero impossible\n        uint256 scaledShare = _mul(balance, 1e4) / stakesSum;\n\n        require(scaledShare != 0, \"nothing to distribute\");\n\n        for (uint256 i = 1; i <= numOfStakes; i++) {\n            StakeHolder memory holder = stakeholders[i];\n\n            uint256 amount = _mul(scaledShare, holder.stake) / 1e4;\n            _safeTransfer(token, holder.wallet, amount);\n\n            emit Distributed(i, address(token), amount);\n        }\n\n        _notEntered = true;\n    }\n\n    // Update wallet address of a stakeholder (only the stakeholder may call)\n    function updateWallet(uint stakeholderID, address newWallet) external {\n        require(stakeholders[stakeholderID].wallet == msg.sender, \"unauthorized\");\n        _revertZeroAddress(newWallet);\n        stakeholders[stakeholderID].wallet = newWallet;\n        emit WalletUpdate(stakeholderID, newWallet);\n    }\n\n    // Borrowed from SafeERC20 by @openzeppelin\n    function _safeTransfer(IERC20Min token, address to, uint256 value) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: operation did not succeed\"\n            );\n        }\n    }\n\n    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        if (a == 0) return 0;\n        c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n    }\n\n    function _revertZeroAddress(address _address) private pure {\n        require(_address != address(0), \"zero address\");\n    }\n}\n"
    }
  }
}