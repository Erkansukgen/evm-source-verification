{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":10000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Arb.sol":{"content":"// pragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n// SPDX-License-Identifier: MIT\n\ninterface IFreeFromUpTo {\n    function freeFromUpTo(address from, uint256 value) external returns(uint256 freed);\n    function freeUpTo(uint256 value) external returns(uint256 freed);\n}\n\ninterface IBuyMaxAndFree {\n    function buyMaxAndFree(uint256 deadline) external payable returns(uint256);\n    function buyAndFree(uint256 amount, uint256 deadline, address payable refundTo) external payable returns(uint256);\n    function buyAndFree22457070633(uint256 amount) external payable;\n}\n\ninterface IUniswapV2Pair {\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ninterface IGST2 {\n    function balanceOf(address who) external view returns (uint256);\n\n    function free(uint256 value) external returns (bool success);\n\n    function freeUpTo(uint256 value) external returns (uint256 freed);\n\n    function freeFrom(address from, uint256 value) external returns (bool success);\n\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n}\n\ninterface Uniswap {\n    function swapExactTokensForTokens(\n      uint amountIn,\n      uint amountOutMin,\n      address[] calldata path,\n      address to,\n      uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\ncontract Arb {\n    address payable owner = payable(msg.sender);\n    modifier onlyOwner() {\n        require(payable(msg.sender) == owner);\n        _;\n    }\n\n    // https://github.com/emilianobonassi/gas-saver/blob/master/ChiGasSaver.sol\n    modifier saveGas() {\n        // address(this)\n        address payable sponsor = payable(msg.sender);\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n\n        IFreeFromUpTo chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n        chi.freeFromUpTo(sponsor, (gasSpent + 14154) / 41947);\n    }\n\n    constructor() public {\n        owner = payable(msg.sender); \n    }\n\n    function deposit(uint256 amount) payable public {\n        require(msg.value == amount);\n        // nothing else to do!\n    }\n    \n    function withdraw() onlyOwner public {\n        owner.transfer(address(this).balance);\n    }\n\n    struct ExpectedAmounts {\n        address exchange;\n        uint reserve0;\n        // uint reserve1;\n        uint amount0;\n        uint amount1;\n    }\n\n    function fastSwapOne(uint blockNumber, uint amountIn, address fromErc20Address, ExpectedAmounts calldata expectedAmounts, uint coinbaseTransfer) external {\n        require(payable(msg.sender) == owner);\n        // note, ganache by default uses a block number ~10 higher?\n        // which is different than mainnet where this will be the actual block being mined\n        require(block.number == blockNumber, \"e1\");\n\n        (bool success, bytes memory data) = expectedAmounts.exchange.staticcall(abi.encodeWithSelector(0x0902f1ac));\n        require(success, 'could not get reserves');\n        (uint reserve0 ) = abi.decode(data, (uint));\n         require(reserve0 == expectedAmounts.reserve0, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n\n        bytes memory emptyBytes;\n\n        (success,) = fromErc20Address.call(abi.encodeWithSelector(0xa9059cbb, expectedAmounts.exchange, amountIn));\n        require(\n            success,\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n\n        if (coinbaseTransfer > 0) {\n            block.coinbase.transfer(coinbaseTransfer);\n        }\n\n        IUniswapV2Pair(expectedAmounts.exchange).swap(\n            expectedAmounts.amount0,\n            expectedAmounts.amount1,\n            address(this),\n            emptyBytes\n        );\n    }\n\n    function fastSwapOneChi(uint blockNumber, uint amountIn, address fromErc20Address, ExpectedAmounts calldata expectedAmounts, uint gasDecr, uint coinbaseTransfer) external {\n        require(payable(msg.sender) == owner);\n        // note, ganache by default uses a block number ~10 higher?\n        // which is different than mainnet where this will be the actual block being mined\n        require(block.number == blockNumber, \"e1\");\n\n        uint256 gasStart = gasleft();\n\n        (bool success, bytes memory data) = expectedAmounts.exchange.staticcall(abi.encodeWithSelector(0x0902f1ac));\n        require(success, 'could not get reserves');\n        (uint reserve0 ) = abi.decode(data, (uint));\n         require(reserve0 == expectedAmounts.reserve0, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n\n        bytes memory emptyBytes;\n\n        (success,) = fromErc20Address.call(abi.encodeWithSelector(0xa9059cbb, expectedAmounts.exchange, amountIn));\n        require(\n            success,\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n\n        IUniswapV2Pair(expectedAmounts.exchange).swap(\n            expectedAmounts.amount0,\n            expectedAmounts.amount1,\n            address(this),\n            emptyBytes\n        );\n\n        if (coinbaseTransfer > 0) {\n            block.coinbase.transfer(coinbaseTransfer);\n        }\n\n        uint gasTokens = (21000 + gasStart - gasleft() + 16 * msg.data.length + 14154) / 41947;\n        0x0000000000004946c0e9F43F4Dee607b0eF1fA1c.call(abi.encodeWithSelector(0x6366b936, gasTokens-gasDecr));\n    }\n\n    function fastSwapOneGst2(uint blockNumber, uint amountIn, address fromErc20Address, ExpectedAmounts calldata expectedAmounts, uint gasDecr) external {\n        require(payable(msg.sender) == owner);\n        // note, ganache by default uses a block number ~10 higher?\n        // which is different than mainnet where this will be the actual block being mined\n        require(block.number == blockNumber, \"e1\");\n\n        uint256 gasStart = gasleft();\n\n        (bool success, bytes memory data) = expectedAmounts.exchange.staticcall(abi.encodeWithSelector(0x0902f1ac));\n        require(success, 'could not get reserves');\n        (uint reserve0 ) = abi.decode(data, (uint));\n         require(reserve0 == expectedAmounts.reserve0, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n\n        bytes memory emptyBytes;\n\n        (success,) = fromErc20Address.call(abi.encodeWithSelector(0xa9059cbb, expectedAmounts.exchange, amountIn));\n        require(\n            success,\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n\n        IUniswapV2Pair(expectedAmounts.exchange).swap(\n            expectedAmounts.amount0,\n            expectedAmounts.amount1,\n            address(this),\n            emptyBytes\n        );\n\n        uint256 tokens = ((gasStart - gasleft()) + 14154)/((24000*2)-6870);\n        // require(false, uint2str(tokens));\n        IGST2(0x0000000000b3F879cb30FE243b4Dfee438691c04).freeUpTo(tokens-gasDecr);\n    }\n\n    // function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n    //     if (_i == 0) {\n    //         return \"0\";\n    //     }\n    //     uint j = _i;\n    //     uint len;\n    //     while (j != 0) {\n    //         len++;\n    //         j /= 10;\n    //     }\n    //     bytes memory bstr = new bytes(len);\n    //     uint k = len;\n    //     while (_i != 0) {\n    //         k = k-1;\n    //         uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n    //         bytes1 b1 = bytes1(temp);\n    //         bstr[k] = b1;\n    //         _i /= 10;\n    //     }\n    //     return string(bstr);\n    // }\n\n    function fastSwap(uint blockNumber, uint amountIn, ExpectedAmounts[] calldata expectedAmounts) external {\n        require(payable(msg.sender) == owner);\n        // note, ganache by default uses a block number ~10 higher?\n        // which is different than mainnet where this will be the actual block being mined\n        require(block.number == blockNumber, \"e1\");\n\n        // verify reserves\n        for (uint i = 0; i < expectedAmounts.length; i++) {\n            // (uint reserve0, uint reserve1,) = IUniswapV2Pair(expectedAmounts[i].exchange).getReserves();\n            // require(reserve0 == expectedAmounts[i].reserve0, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n            // require(reserve1 == expectedAmounts[i].reserve1, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n            (bool success, bytes memory data) = expectedAmounts[i].exchange.staticcall(abi.encodeWithSelector(0x0902f1ac));\n            require(success, 'could not get reserves');\n            (uint reserve0 ) = abi.decode(data, (uint));\n             require(reserve0 == expectedAmounts[i].reserve0, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        }\n\n        // transfer money from this contract\n        // https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\n        // (bool success, bytes memory data) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2.call(abi.encodeWithSelector(0xa9059cbb, expectedAmounts[0].exchange, amountIn));\n        // require(\n        //     success && (data.length == 0 || abi.decode(data, (bool))),\n        //     'TransferHelper::safeTransfer: transfer failed'\n        // );\n        (bool success,) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2.call(abi.encodeWithSelector(0xa9059cbb, expectedAmounts[0].exchange, amountIn));\n        require(\n            success,\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n\n        // saves 232802-232362, 440 gas\n        bytes memory emptyBytes;\n\n        // not calling expectedAmounts.length twice saves ~100 gas\n        uint lastIdx = expectedAmounts.length - 1;\n\n        for (uint i=0; i < lastIdx; i++) {\n            IUniswapV2Pair(expectedAmounts[i].exchange).swap(\n                expectedAmounts[i].amount0,\n                expectedAmounts[i].amount1,\n                expectedAmounts[i+1].exchange,\n                emptyBytes\n            );\n            // calling the ABI directly like this saves ~250 gas\n            // expectedAmounts[i].exchange.call(abi.encodeWithSelector(\n            //     0x022c0d9f,\n            //     expectedAmounts[i].amount0,\n            //     expectedAmounts[i].amount1,\n            //     expectedAmounts[i+1].exchange,\n            //     emptyBytes\n            // ));\n        }\n\n        // saves gas to call the last one outside of the loop\n        IUniswapV2Pair(expectedAmounts[lastIdx].exchange).swap(\n            expectedAmounts[lastIdx].amount0,\n            expectedAmounts[lastIdx].amount1,\n            address(this),\n            emptyBytes\n        );\n        //  expectedAmounts[lastIdx].exchange.call(abi.encodeWithSelector(\n        //     0x022c0d9f,\n        //     expectedAmounts[lastIdx].amount0,\n        //     expectedAmounts[lastIdx].amount1,\n        //     address(this),\n        //     emptyBytes\n        // ));\n    }\n\n    // transfer money from owner (this uses a lot more gas, e.g. 245k instead of 232k, and 199k instead of 189k when using gas token)\n    // (bool success, bytes memory data) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2.call(abi.encodeWithSelector(0x23b872dd, owner, expectedAmounts[0].exchange, amountIn));\n    // require(\n    //     success && (data.length == 0 || abi.decode(data, (bool))),\n    //     'TransferHelper::transferFrom: transferFrom failed'\n    // );\n\n    // thsi is a copy and paste of the code from fastSwap with gas token code around it\n    function fastSwapChi(uint blockNumber, uint amountIn, ExpectedAmounts[] calldata expectedAmounts, uint gasDecr, uint coinbaseTransfer) payable external {\n        require(payable(msg.sender) == owner);\n        // note, ganache by default uses a block number ~10 higher?\n        // which is different than mainnet where this will be the actual block being mined\n        require(block.number == blockNumber, \"e1\");\n\n        uint256 gasStart = gasleft();\n\n        // verify reserves\n        for (uint i = 0; i < expectedAmounts.length; i++) {\n            (bool success, bytes memory data) = expectedAmounts[i].exchange.staticcall(abi.encodeWithSelector(0x0902f1ac));\n            require(success, 'could not get reserves');\n            (uint reserve0 ) = abi.decode(data, (uint));\n             require(reserve0 == expectedAmounts[i].reserve0, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        }\n\n\n        (bool success,) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2.call(abi.encodeWithSelector(0xa9059cbb, expectedAmounts[0].exchange, amountIn));\n        require(\n            success,\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n\n        bytes memory emptyBytes;\n\n        uint lastIdx = expectedAmounts.length - 1;\n\n        for (uint i=0; i < lastIdx; i++) {\n            // calling the ABI directly like this saves ~250 gas\n            expectedAmounts[i].exchange.call(abi.encodeWithSelector(\n                0x022c0d9f,\n                expectedAmounts[i].amount0,\n                expectedAmounts[i].amount1,\n                expectedAmounts[i+1].exchange,\n                emptyBytes\n            ));\n        }\n\n        // saves gas to call the last one outside of the loop\n        IUniswapV2Pair(expectedAmounts[lastIdx].exchange).swap(\n            expectedAmounts[lastIdx].amount0,\n            expectedAmounts[lastIdx].amount1,\n            address(this),\n            emptyBytes\n        );\n\n        if (coinbaseTransfer > 0) {\n            block.coinbase.transfer(coinbaseTransfer);\n        }\n\n        // chi token\n        // uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        // IFreeFromUpTo chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n        // gasTokensUsed = (gasSpent + 14154) / 41947;\n        // chi.freeUpTo(gasTokensUsed);\n        uint gasTokens = (21000 + gasStart - gasleft() + 16 * msg.data.length + 14154) / 41947;\n        0x0000000000004946c0e9F43F4Dee607b0eF1fA1c.call(abi.encodeWithSelector(0x6366b936, gasTokens-gasDecr));\n    }\n\n    // this is a copy and paste of the code from fastSwap with gas token code around it\n    function fastSwapGst2(uint blockNumber, uint amountIn, ExpectedAmounts[] calldata expectedAmounts, uint gasDecr, uint coinbaseTransfer) payable external {\n        require(payable(msg.sender) == owner);\n        // note, ganache by default uses a block number ~10 higher?\n        // which is different than mainnet where this will be the actual block being mined\n        require(block.number == blockNumber, \"e1\");\n\n        uint256 gasStart = gasleft();\n\n        // verify reserves\n        for (uint i = 0; i < expectedAmounts.length; i++) {\n            (bool success, bytes memory data) = expectedAmounts[i].exchange.staticcall(abi.encodeWithSelector(0x0902f1ac));\n            require(success, 'could not get reserves');\n            (uint reserve0 ) = abi.decode(data, (uint));\n             require(reserve0 == expectedAmounts[i].reserve0, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        }\n\n\n        (bool success,) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2.call(abi.encodeWithSelector(0xa9059cbb, expectedAmounts[0].exchange, amountIn));\n        require(\n            success,\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n\n        bytes memory emptyBytes;\n\n        uint lastIdx = expectedAmounts.length - 1;\n\n        for (uint i=0; i < lastIdx; i++) {\n            // calling the ABI directly like this saves ~250 gas\n            expectedAmounts[i].exchange.call(abi.encodeWithSelector(\n                0x022c0d9f,\n                expectedAmounts[i].amount0,\n                expectedAmounts[i].amount1,\n                expectedAmounts[i+1].exchange,\n                emptyBytes\n            ));\n        }\n\n        // saves gas to call the last one outside of the loop\n        IUniswapV2Pair(expectedAmounts[lastIdx].exchange).swap(\n            expectedAmounts[lastIdx].amount0,\n            expectedAmounts[lastIdx].amount1,\n            address(this),\n            emptyBytes\n        );\n\n        if (coinbaseTransfer > 0) {\n            block.coinbase.transfer(coinbaseTransfer);\n        }\n\n        // gst token\n        // uint256 tokens = gasStart.sub(\n        //                     gasleft()\n        //                  ).add(14154).div(\n        //                     uint256(24000).mul(2).sub(6870)\n        //                  );\n        uint256 tokens = ((gasStart - gasleft()) + 14154)/((24000*2)-6870);\n        // require(false, uint2str(tokens));\n        IGST2(0x0000000000b3F879cb30FE243b4Dfee438691c04).freeUpTo(tokens-gasDecr);\n    }\n\n    // this is a copy and paste of the code from fastSwap with gas token code around it\n    function fastSwapLgt(uint blockNumber, uint amountIn, ExpectedAmounts[] calldata expectedAmounts, uint amountEthForLgt, uint gasDecr, uint coinbaseTransfer) payable external {\n        require(payable(msg.sender) == owner);\n        require(block.number >= blockNumber, \"e1\");\n\n        uint256 gasStart = gasleft();\n\n        // verify reserves\n        for (uint i = 0; i < expectedAmounts.length; i++) {\n            (bool success, bytes memory data) = expectedAmounts[i].exchange.staticcall(abi.encodeWithSelector(0x0902f1ac));\n            require(success, 'could not get reserves');\n            (uint reserve0 ) = abi.decode(data, (uint));\n             require(reserve0 == expectedAmounts[i].reserve0, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        }\n\n\n        (bool success,) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2.call(abi.encodeWithSelector(0xa9059cbb, expectedAmounts[0].exchange, amountIn));\n        require(\n            success,\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n\n        bytes memory emptyBytes;\n\n        uint lastIdx = expectedAmounts.length - 1;\n\n        for (uint i=0; i < lastIdx; i++) {\n            // calling the ABI directly like this saves ~250 gas\n            expectedAmounts[i].exchange.call(abi.encodeWithSelector(\n                0x022c0d9f,\n                expectedAmounts[i].amount0,\n                expectedAmounts[i].amount1,\n                expectedAmounts[i+1].exchange,\n                emptyBytes\n            ));\n        }\n\n        // saves gas to call the last one outside of the loop\n        IUniswapV2Pair(expectedAmounts[lastIdx].exchange).swap(\n            expectedAmounts[lastIdx].amount0,\n            expectedAmounts[lastIdx].amount1,\n            address(this),\n            emptyBytes\n        );\n\n        if (coinbaseTransfer > 0) {\n            block.coinbase.transfer(coinbaseTransfer);\n        }\n\n        // lgt token\n        // 0x000000000000C1CB11D5c062901F32D06248CE48.call{value: 300000000000000000}(abi.encodeWithSignature('buyMaxAndFree(uint256)', now+10));\n        // IBuyMaxAndFree(0x000000000000C1CB11D5c062901F32D06248CE48).buyMaxAndFree{value: 200000000000000000}(now);\n        // 0x000000000000C1CB11D5c062901F32D06248CE48.call{value: 4000000000000000}(abi.encodeWithSignature('buyAndFree(uint256,uint256,address)', 6, now, address(this)));\n        // require(false,uint2str((gasStart - gasleft() + 55000) / 41300));\n        \n        // this uses 3% more gas, but in theory should be way easier to use since it does not require\n        // the amount owed to be computed... but it doesn't refund money (or at least i dont think it does).\n        // 0x000000000000C1CB11D5c062901F32D06248CE48.call{value: amountEthForLgt}(abi.encodeWithSignature('buyAndFree(uint256,uint256,address)', (gasStart - gasleft() + 55000) / 41300, now, this));\n\n        // this is 3% gas savings, but more complicated because it requires us to pass the price we want to pay in\n        uint gasTokens = (gasStart - gasleft() + 55000) / 41300;\n        0x000000000000C1CB11D5c062901F32D06248CE48.call{value: amountEthForLgt}(abi.encodeWithSignature('buyAndFree22457070633(uint256)', gasTokens - gasDecr));\n    }\n\n    // function reset() external payable {\n    //     0x000000000000C1CB11D5c062901F32D06248CE48.call{value: msg.value}(abi.encodeWithSignature('buyAndFree22457070633(uint256)', 1));\n    // }\n\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    function batch(Call[] memory calls) onlyOwner saveGas public returns (bytes[] memory returnData) {\n        returnData = new bytes[](calls.length);\n        for(uint8 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory data) = calls[i].to.call{value:calls[i].value}(calls[i].data);\n            // (bool success, bytes memory data) = calls[i].to.call.value(calls[i].value)(calls[i].data);\n            require(success, string(data));\n            returnData[i] = data;\n        }\n    }\n}"}}}