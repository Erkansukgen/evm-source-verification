{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DPPFactory.sol":{"content":"// File: contracts/lib/InitializableOwnable.sol\n\n/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Ownable\n * @author DODO Breeder\n *\n * @notice Ownership related functions\n */\ncontract InitializableOwnable {\n    address public _OWNER_;\n    address public _NEW_OWNER_;\n    bool internal _INITIALIZED_;\n\n    // ============ Events ============\n\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // ============ Modifiers ============\n\n    modifier notInitialized() {\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\n        _;\n    }\n\n    // ============ Functions ============\n\n    function initOwner(address newOwner) public notInitialized {\n        _INITIALIZED_ = true;\n        _OWNER_ = newOwner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n        _NEW_OWNER_ = newOwner;\n    }\n\n    function claimOwnership() public {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n\n// File: contracts/lib/CloneFactory.sol\n\n\ninterface ICloneFactory {\n    function clone(address prototype) external returns (address proxy);\n}\n\n// introduction of proxy mode design: https://docs.openzeppelin.com/upgrades/2.8/\n// minimum implementation of transparent proxy: https://eips.ethereum.org/EIPS/eip-1167\n\ncontract CloneFactory is ICloneFactory {\n    function clone(address prototype) external override returns (address proxy) {\n        bytes20 targetBytes = bytes20(prototype);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            proxy := create(0, clone, 0x37)\n        }\n        return proxy;\n    }\n}\n\n// File: contracts/lib/FeeRateModel.sol\n\n\ninterface IFeeRateImpl {\n    function getFeeRate(address pool, address trader) external view returns (uint256);\n}\n\ninterface IFeeRateModel {\n    function getFeeRate(address trader) external view returns (uint256);\n}\n\ncontract FeeRateModel is InitializableOwnable {\n    address public feeRateImpl;\n\n    function setFeeProxy(address _feeRateImpl) public onlyOwner {\n        feeRateImpl = _feeRateImpl;\n    }\n    \n    function getFeeRate(address trader) external view returns (uint256) {\n        if(feeRateImpl == address(0))\n            return 0;\n        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender,trader);\n    }\n}\n\n// File: contracts/DODOPrivatePool/intf/IDPP.sol\n\n\ninterface IDPP {\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        bool isOpenTWAP\n    ) external;\n\n    function _MT_FEE_RATE_MODEL_() external returns (address);\n\n    //=========== admin ==========\n    function ratioSync() external;\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external;\n\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    //========== advanced ========\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n}\n\n// File: contracts/DODOPrivatePool/intf/IDPPAdmin.sol\n\n\ninterface IDPPAdmin {\n    function init(address owner, address dpp,address operator, address dodoSmartApprove) external;\n}\n\n// File: contracts/Factory/DPPFactory.sol\n\n\n/**\n * @title DODO PrivatePool Factory\n * @author DODO Breeder\n *\n * @notice Create And Register DPP Pools \n */\ncontract DPPFactory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public _DEFAULT_MAINTAINER_;\n    address public _DPP_TEMPLATE_;\n    address public _DPP_ADMIN_TEMPLATE_;\n\n    mapping (address => bool) public isAdminListed;\n\n    // ============ Registry ============\n\n    // base -> quote -> DPP address list\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\n    // creator -> DPP address list\n    mapping(address => address[]) public _USER_REGISTRY_;\n\n    // ============ Events ============\n\n    event NewDPP(\n        address baseToken,\n        address quoteToken,\n        address creator,\n        address dpp\n    );\n\n    event RemoveDPP(address dpp);\n\n    event addAdmin(address admin);\n    event removeAdmin(address admin);\n\n    constructor(\n        address cloneFactory,\n        address dppTemplate,\n        address dppAdminTemplate,\n        address defaultMaintainer,\n        address defaultMtFeeRateModel,\n        address dodoApproveProxy\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _DPP_TEMPLATE_ = dppTemplate;\n        _DPP_ADMIN_TEMPLATE_ = dppAdminTemplate;\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    // ============ Functions ============\n\n    function createDODOPrivatePool() external returns (address newPrivatePool) {\n        newPrivatePool = ICloneFactory(_CLONE_FACTORY_).clone(_DPP_TEMPLATE_);\n    }\n\n    function initDODOPrivatePool(\n        address dppAddress,\n        address creator,\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 k,\n        uint256 i,\n        bool isOpenTwap\n    ) external {\n        require(isAdminListed[msg.sender], \"ACCESS_DENIED\");\n        {\n            address _dppAddress = dppAddress;\n            address adminModel = _createDPPAdminModel(\n                creator,\n                _dppAddress,\n                creator,\n                _DODO_APPROVE_PROXY_\n            );\n            IDPP(_dppAddress).init(\n                adminModel,\n                _DEFAULT_MAINTAINER_,\n                baseToken,\n                quoteToken,\n                lpFeeRate,\n                _DEFAULT_MT_FEE_RATE_MODEL_,\n                k,\n                i,\n                isOpenTwap\n            );\n        }\n\n        _REGISTRY_[baseToken][quoteToken].push(dppAddress);\n        _USER_REGISTRY_[creator].push(dppAddress);\n        emit NewDPP(baseToken, quoteToken, creator, dppAddress);\n    }\n\n    function _createDPPAdminModel(\n        address owner,\n        address dpp,\n        address operator,\n        address dodoApproveProxy\n    ) internal returns (address adminModel) {\n        adminModel = ICloneFactory(_CLONE_FACTORY_).clone(_DPP_ADMIN_TEMPLATE_);\n        IDPPAdmin(adminModel).init(owner, dpp, operator, dodoApproveProxy);\n    }\n\n    // ============ Admin Operation Functions ============\n    \n    function updateAdminTemplate(address _newDPPAdminTemplate) external onlyOwner {\n        _DPP_ADMIN_TEMPLATE_ = _newDPPAdminTemplate;\n    }\n\n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\n    }\n\n    function updateDppTemplate(address _newDPPTemplate) external onlyOwner {\n        _DPP_TEMPLATE_ = _newDPPTemplate;\n    }\n\n    function addAdminList (address contractAddr) external onlyOwner {\n        isAdminListed[contractAddr] = true;\n        emit addAdmin(contractAddr);\n    }\n\n    function removeAdminList (address contractAddr) external onlyOwner {\n        isAdminListed[contractAddr] = false;\n        emit removeAdmin(contractAddr);\n    }\n\n    function addPoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        _REGISTRY_[baseToken][quoteToken].push(pool);\n        _USER_REGISTRY_[creator].push(pool);\n        emit NewDPP(baseToken, quoteToken, creator, pool);\n    }\n\n    function batchAddPoolByAdmin(\n        address[] memory creators,\n        address[] memory baseTokens, \n        address[] memory quoteTokens,\n        address[] memory pools\n    ) external onlyOwner {\n        require(creators.length == baseTokens.length,\"PARAMS_INVALID\");\n        require(creators.length == quoteTokens.length,\"PARAMS_INVALID\");\n        require(creators.length == pools.length,\"PARAMS_INVALID\");\n        for(uint256 i = 0; i < creators.length; i++) {\n            address creator = creators[i];\n            address baseToken = baseTokens[i];\n            address quoteToken = quoteTokens[i];\n            address pool = pools[i];\n            \n            _REGISTRY_[baseToken][quoteToken].push(pool);\n            _USER_REGISTRY_[creator].push(pool);\n            emit NewDPP(baseToken, quoteToken, creator, pool);\n        }\n    }\n\n    function removePoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\n        for (uint256 i = 0; i < registryList.length; i++) {\n            if (registryList[i] == pool) {\n                registryList[i] = registryList[registryList.length - 1];\n                break;\n            }\n        }\n        _REGISTRY_[baseToken][quoteToken] = registryList;\n        _REGISTRY_[baseToken][quoteToken].pop();\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\n            if (userRegistryList[i] == pool) {\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\n                break;\n            }\n        }\n        _USER_REGISTRY_[creator] = userRegistryList;\n        _USER_REGISTRY_[creator].pop();\n        emit RemoveDPP(pool);\n    }\n\n    // ============ View Functions ============\n\n    function getDODOPool(address baseToken, address quoteToken)\n        external\n        view\n        returns (address[] memory pools)\n    {\n        return _REGISTRY_[baseToken][quoteToken];\n    }\n\n    function getDODOPoolBidirection(address token0, address token1)\n        external\n        view\n        returns (address[] memory baseToken0Pool, address[] memory baseToken1Pool)\n    {\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\n    }\n\n    function getDODOPoolByUser(address user) \n        external\n        view\n        returns (address[] memory pools)\n    {\n        return _USER_REGISTRY_[user];\n    }\n}\n"}}}