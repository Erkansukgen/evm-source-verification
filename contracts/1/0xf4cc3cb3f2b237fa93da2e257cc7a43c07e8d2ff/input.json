{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/AGVPublicSale.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.9;\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract AGVPublicSale {\r\n\r\n    address public owner;\r\n    address private AGV_address;\r\n    uint256 private tokenGenerateTime;\r\n    uint256 private vestingDuration;      // In months\r\n    uint256 private vestingTimeStartFrom;  //  Claim cannot start before vestingTimeStart from \r\n    uint256 public totalInvestment;\r\n    uint256 public totalRelease;\r\n    uint256 public tgePercentage;\r\n    uint256 public claimPercentage;\r\n    \r\n    struct PublicInvestors {\r\n        uint256 lockedAgv;        //  Locked balance\r\n        uint256 releasedAgv;       // relesed balance\r\n        uint256 previousClaimTime;\r\n        uint256 claimCounter;\r\n        bool isTokenGenerated;\r\n        uint256 balance;     // remaining balance\r\n    }\r\n\r\n    mapping(address => PublicInvestors) public investors;\r\n    \r\n    event AddInvestor(address indexed investor, uint indexed amount);\r\n    event Claim(address indexed sender, address indexed investor, uint indexed amount);\r\n    \r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    \r\n    constructor() {\r\n        tokenGenerateTime = 1640217600; // 23 Dec 2021\r\n        vestingTimeStartFrom = 1643587200; // 31 Jan 2022\r\n        vestingDuration = 6;\r\n        tgePercentage = 20;\r\n        claimPercentage = 1333;\r\n        owner = _msgSender();\r\n        AGV_address = 0xf4F618Eff5eF36Cde2FCa4FBD86554c62Fb1382B;\r\n    }\r\n    \r\n    modifier isValidAddress(address _address ){\r\n        require(_address != address(0),\"Address cannot be empty\");\r\n        _;\r\n    }\r\n    \r\n    modifier isInvestorExist(){\r\n        require(investors[_msgSender()].lockedAgv != 0,\" Invalid investor. \");\r\n        _;\r\n    }\r\n    \r\n    modifier isValidAmount(uint256 _amount){\r\n        require(_amount != 0,\" Amount not found. \");\r\n        _;\r\n    }\r\n    \r\n    modifier isValidDate(uint256 _date){\r\n        require(_date != 0,\" Date is not valid. \");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(owner == _msgSender() , \"Only owner access\");\r\n        _;\r\n    }\r\n    \r\n    function isTokenGenerateEventStarted() public view returns(bool){\r\n        if(block.timestamp > tokenGenerateTime)\r\n            return true;       // if date is after TGE time\r\n        else\r\n            return false;      // if date is before TGE time\r\n    }\r\n    \r\n    function isVestingTimeStarted() public view returns(bool){\r\n        if(block.timestamp > vestingTimeStartFrom)\r\n            return true;       // vesting Time started\r\n        else\r\n            return false;      // or not\r\n    }\r\n    \r\n    function modifyVestingDuration(uint256 _month) public onlyOwner {\r\n        bool isVestingTimeStart = isVestingTimeStarted();\r\n        require(isVestingTimeStart == false,\" Vesting duration cannot be changed when vesting period started.\");\r\n        vestingDuration = _month;\r\n    }\r\n    \r\n    function modifyVestingTimeStartFrom(uint256 _date) public onlyOwner isValidDate(_date) {\r\n        bool isVestingTimeStart = isVestingTimeStarted();\r\n        require(isVestingTimeStart == false,\" Vesting time cannot be changed when vesting period started.\");\r\n        require(_date >= tokenGenerateTime, \"Vesting time cannot start before token generate event.\");\r\n        vestingTimeStartFrom = _date;\r\n    }\r\n    \r\n    function modifyTokenGenerateTime(uint256 _date) public onlyOwner isValidDate(_date) {\r\n        bool isTokenGenerateStarted = isTokenGenerateEventStarted();\r\n        require(isTokenGenerateStarted == false,\"Token generate time cannot be changed when token generate event started.\");\r\n        require(_date <= vestingTimeStartFrom, \"Token generate event time must be less than vesting time.\");\r\n        tokenGenerateTime = _date;\r\n    }\r\n\r\n    function withdrawAgv(address _address, uint256 _amount) public onlyOwner isValidAmount(_amount) {\r\n        uint256 contractBalance = IERC20(AGV_address).balanceOf(address(this));\r\n        require(contractBalance >= _amount,\" Insufficient AGV token balance.\");\r\n        transferAGV(_address,_amount);\r\n    }\r\n    \r\n     function decreaseInvestorAllowance(address _address, uint256 _amount) public onlyOwner isValidAddress(_address) isValidAmount(_amount) {\r\n        require(_amount < investors[_address].balance,\"Not enough token\");\r\n        investors[_address].lockedAgv -= _amount;\r\n        investors[_address].balance -= _amount;\r\n        totalInvestment -= _amount;\r\n    }\r\n    \r\n    function changeAgvAddress(address _address) external onlyOwner isValidAddress(_address) {\r\n        AGV_address = _address;\r\n    }\r\n    \r\n    function transferOwnership(address _address) external onlyOwner isValidAddress(_address){\r\n        owner = _address;\r\n    }\r\n    \r\n    function getTokenGenerateTime() public view returns (uint256){\r\n        return tokenGenerateTime;\r\n    }\r\n    function getVestingTime() public view returns (uint256){\r\n        return vestingTimeStartFrom;\r\n    }\r\n    \r\n    function getInvestor(address _address) public view returns (uint256 lockedAgv, uint256 releasedAgv, uint256 balance, uint256 totalClaim, uint256 previousClaimTime, bool tokenGenerated){\r\n        if(investors[_address].lockedAgv != 0){\r\n            return (\r\n                investors[_address].lockedAgv,\r\n                investors[_address].releasedAgv,\r\n                investors[_address].balance,\r\n                investors[_address].claimCounter,\r\n                investors[_address].previousClaimTime,\r\n                investors[_address].isTokenGenerated\r\n            );\r\n        } else {\r\n            return (0,0,0,0,0,false);\r\n        }\r\n    }\r\n    \r\n    function isEligibleForClaim() public view isInvestorExist returns(bool _res){\r\n        bool isTokenGenerateStarted = isTokenGenerateEventStarted();\r\n        bool isVestingTime = isVestingTimeStarted();\r\n        if(isTokenGenerateStarted == true){\r\n            if(isVestingTime == true){\r\n                if(investors[_msgSender()].releasedAgv < investors[_msgSender()].lockedAgv){\r\n                    if(investors[_msgSender()].claimCounter < vestingDuration){\r\n                        if(investors[_msgSender()].previousClaimTime != 0){\r\n                            if(block.timestamp > investors[_msgSender()].previousClaimTime + 30*24*60*60) return true;\r\n                            // if(block.timestamp > investors[_msgSender()].previousClaimTime + 3*60) return true;\r\n                            else return false;\r\n                        } else {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }      \r\n            } \r\n        }\r\n        return false;\r\n    }\r\n\r\n    function addInvestors(address[] calldata _addresses,uint256[] calldata _amounts) onlyOwner external {\r\n        uint256 investments;\r\n        for(uint i = 0 ; i < _addresses.length ; i ++ ){\r\n            if(investors[_addresses[i]].lockedAgv != 0){\r\n                investors[_addresses[i]].lockedAgv += _amounts[i];\r\n                investors[_addresses[i]].balance += _amounts[i];\r\n            } else {\r\n                investors[_addresses[i]] = PublicInvestors ({\r\n                    lockedAgv:_amounts[i],\r\n                    releasedAgv:0,\r\n                    previousClaimTime:0,\r\n                    claimCounter:0,\r\n                    isTokenGenerated:false,\r\n                    balance:_amounts[i]\r\n                });\r\n            }\r\n            investments += _amounts[i];\r\n        }\r\n        totalInvestment += investments;\r\n    }\r\n    \r\n    function addInvestor(address _address, uint256 _amount) external onlyOwner isValidAddress(_address) isValidAmount(_amount) {\r\n        totalInvestment += _amount;\r\n        if(investors[_address].lockedAgv != 0){\r\n            investors[_address].lockedAgv += _amount;\r\n            investors[_address].balance += _amount;\r\n        } else {\r\n            investors[_address] = PublicInvestors ({\r\n                lockedAgv:_amount,\r\n                releasedAgv:0,\r\n                previousClaimTime:0,\r\n                claimCounter:0,\r\n                isTokenGenerated:false,\r\n                balance:_amount\r\n            });\r\n            emit AddInvestor(_address,_amount);\r\n        }\r\n    }\r\n    \r\n    function transferAGV(address _receiver, uint256 _amount) internal returns(bool _res){\r\n        bool responce = IERC20(AGV_address).transfer(_receiver,_amount);\r\n        return responce;\r\n    }\r\n    \r\n    function generateToken() external isInvestorExist {\r\n        bool isTokenGenerateStarted = isTokenGenerateEventStarted();\r\n        address _address = _msgSender();\r\n        \r\n        require(isTokenGenerateStarted == true,\"Token generate event not started.\");\r\n        \r\n        require(investors[_address].isTokenGenerated == false,\"Token already generated.\");\r\n        \r\n        uint256 _amount = (investors[_address].lockedAgv * tgePercentage)/100;\r\n        \r\n        uint256 contractBalance = IERC20(AGV_address).balanceOf(address(this));\r\n        require(contractBalance >= _amount,\" Insufficient AGV token balance.\");\r\n        \r\n        transferAGV(_address,_amount);\r\n        totalRelease += _amount;\r\n        \r\n        investors[_address].releasedAgv += _amount;\r\n        investors[_address].balance = investors[_address].lockedAgv - investors[_address].releasedAgv;\r\n        investors[_address].isTokenGenerated = true;\r\n    }\r\n    \r\n    function claimAgv() external isInvestorExist {\r\n        \r\n        bool isVestingTimeStart = isVestingTimeStarted();\r\n        require(isVestingTimeStart == true,\"Claim cannot be started before the vesting time started.\");\r\n        \r\n        bool isEligible = isEligibleForClaim();\r\n        require(isEligible == true,\"Not eligible for claim.\");\r\n        \r\n        uint256 contractBalance = IERC20(AGV_address).balanceOf(address(this));\r\n        \r\n        address _address = _msgSender();\r\n        \r\n        uint256 _transferAmount  = ( investors[_address].lockedAgv*claimPercentage)/10000;\r\n        \r\n        require(contractBalance >= _transferAmount,\" Insufficient AGV token balance.\");\r\n        require(investors[_address].isTokenGenerated == true,\"Token not generated.\");\r\n        \r\n        if(investors[_address].claimCounter == vestingDuration-1){\r\n            _transferAmount = investors[_address].balance;\r\n        }\r\n       \r\n        transferAGV(_address,_transferAmount);\r\n        investors[_address].previousClaimTime = block.timestamp;\r\n        investors[_address].releasedAgv += _transferAmount;\r\n        investors[_address].claimCounter++;\r\n        investors[_address].balance = investors[_address].lockedAgv - investors[_address].releasedAgv; \r\n        totalRelease += _transferAmount;\r\n       \r\n        emit Claim(address(this),_address,_transferAmount);\r\n       \r\n    }\r\n    \r\n    function withdrawToken(address _tokenAddress, uint256 _amount) public onlyOwner {\r\n        IERC20(_tokenAddress).transfer(owner,_amount);\r\n    }\r\n\r\n    function withdrawEth(uint256 _amount) public onlyOwner {\r\n        address payable payableOwner = payable(owner);\r\n        payableOwner.transfer(_amount);\r\n    }\r\n\r\n    \r\n}"}}}