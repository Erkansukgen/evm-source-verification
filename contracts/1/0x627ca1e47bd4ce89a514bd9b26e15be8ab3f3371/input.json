{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ArkaneTokenDetective.sol":{"content":"/**\n* Copyright (C) 2020 Arkane BV (https://kbopub.economie.fgov.be/kbopub/toonondernemingps.html?lang=en&ondernemingsnummer=704738355)\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n* SPDX-License-Identifier: Apache-2.0\n*\n*/\n\npragma solidity >=0.7.5;\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint supply);\n}\n\ninterface ERC721 {\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\ninterface ERC165 {\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n\ncontract ContractProxy {\n\n    function checkErc721Approval(address contractAddress) public view returns (bool) {\n        return ERC721(contractAddress).isApprovedForAll(contractAddress, contractAddress);\n    }\n\n    function checkErc20Supply(address contractAddress) public view returns (uint) {\n        return ERC20(contractAddress).totalSupply();\n    }\n\n}\n\ncontract SupportsInterface {\n\n    function supportsInterface(address contractAddress, bytes4[] calldata interfaceIds) external view returns (bool[] memory) {\n        bool[] memory result = new bool[](interfaceIds.length);\n        for (uint i = 0; i < interfaceIds.length; i++) {\n            ERC165 erc165 = ERC165(contractAddress);\n            result[i] = erc165.supportsInterface(interfaceIds[i]);\n        }\n        return result;\n    }\n}\n\ncontract ArkaneTokenDetective {\n\n    enum TOKEN_TYPE {UNKNOWN, IGNORED, ERC_20, ERC_721, ERC_1155}\n\n    SupportsInterface public supportsInterfaceContract;\n\n    bytes4[] public erc721InterfaceIds;\n    bytes4[] public erc1155InterfaceIds;\n    ContractProxy internal contractProxy;\n\n    constructor(bytes4[] memory _erc721InterfaceIds, bytes4[] memory _erc1155InterfaceIds) {\n        erc721InterfaceIds = _erc721InterfaceIds;\n        erc1155InterfaceIds = _erc1155InterfaceIds;\n        contractProxy = new ContractProxy();\n        supportsInterfaceContract = new SupportsInterface();\n\n    }\n\n    function determineType(address contractAddress) public view returns (TOKEN_TYPE tokenType) {\n        bool[] memory erc1155Results = supportsInterface(contractAddress, erc1155InterfaceIds);\n        for (uint i = 0; i < erc1155Results.length; i++) {\n            if (erc1155Results[i] == true) return TOKEN_TYPE.ERC_1155;\n        }\n        bool[] memory erc721Results = supportsInterface(contractAddress, erc721InterfaceIds);\n        for (uint i = 0; i < erc721Results.length; i++) {\n            if (erc721Results[i] == true) return TOKEN_TYPE.ERC_721;\n        }\n        //check isApprovedForAll function, it must be erc721\n        //if has getBalance, it probably is ERC20\n\n        try contractProxy.checkErc20Supply(contractAddress) returns (uint res) {\n            res;\n            return TOKEN_TYPE.ERC_20;\n        }\n        catch Error(string memory /*reason*/) {}\n        catch (bytes memory /*lowLevelData*/) {}\n\n        try contractProxy.checkErc721Approval(contractAddress) returns (bool res) {\n            res;\n            return TOKEN_TYPE.ERC_721;\n        }\n        catch Error(string memory /*reason*/) {}\n        catch (bytes memory /*lowLevelData*/) {}\n\n        return TOKEN_TYPE.UNKNOWN;\n    }\n\n    function supportsInterface(address contractAddress, bytes4[] memory interfaceIds) public view returns (bool[] memory) {\n        try supportsInterfaceContract.supportsInterface(contractAddress, interfaceIds) returns (bool[] memory res) {\n            return res;\n        }\n        catch Error(string memory /*reason*/) {}\n        catch (bytes memory /*lowLevelData*/) {}\n\n        bool[] memory result = new bool[](interfaceIds.length);\n        for (uint i = 0; i < interfaceIds.length; i++) {\n            result[i] = false;\n        }\n        return result;\n    }\n\n}\n"}}}