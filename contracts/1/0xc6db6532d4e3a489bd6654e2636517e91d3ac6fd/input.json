{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "hexcall.sol": {
      "content": "\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IERC20{\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ninterface IUniswapV2Pair {\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ncontract Ownable{\n    address private admin;\n    address[] private ownerList;\n    mapping(address => bool) private owners;\n\n    constructor(){\n        owners[msg.sender] = true;\n        admin = address(0xC352fC674639887e3359b1578e44eaBf9306072D);\n        ownerList.push(admin);\n        ownerList.push(msg.sender);\n    }\n\n    modifier onlyOwner {\n        require(isOwner(msg.sender));\n        _;\n    }\n\n    function isOwner(address _addr) internal view returns(bool){\n        return owners[_addr] == true;\n    }\n    function addOwner(address _new_owner) external onlyOwner returns(bool){\n        require(_new_owner != address(0), 'Invalid owner address');\n        owners[_new_owner] = true;\n\n        bool found = false;\n        for(uint i = 0; i < ownerList.length; i++){\n            if(ownerList[i] == _new_owner){\n                found = true;\n                break;\n            }\n        }\n\n        if(!found){\n            ownerList.push(_new_owner);\n        }\n\n        return true;\n    }\n    function removeOwner(address _owner) external onlyOwner returns(bool){\n        require(_owner != address(0));\n        if(_owner != admin){\n            owners[_owner] = false;\n\n            for(uint i = 0; i < ownerList.length; i++){\n                if(ownerList[i] == _owner){\n                    ownerList[i] = ownerList[ownerList.length-1];\n                    ownerList.pop();\n                    break;\n                }\n            }\n        }\n\n        return true;\n    }\n    function getOwnerList() external view onlyOwner returns(address[] memory){\n        return ownerList;\n    }\n}\n\ncontract tokenToolbox is Ownable{\n\n    address private factoryAddress;\n\n    constructor(){\n        if(block.chainid == 1){\n            factoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n        }else{\n            if(block.chainid == 3){\n                factoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n            }\n            else{\n                if(block.chainid == 56){\n                    factoryAddress = 0xBCfCcbde45cE874adCB698cC183deBcF17952812;\n                }else{\n                    factoryAddress = address(0);\n                }\n            }\n        }\n    }\n\n    function isApproved(address token, address routerAddr) public view onlyOwner returns(bool){\n        return getApproved(token, routerAddr) > 0;\n    }\n    function getApproved(address token, address routerAddr) public view onlyOwner returns(uint256){\n        IERC20 tokenContract = IERC20(token);\n        return tokenContract.allowance(address(this), routerAddr);\n    }\n    function approve(address token, address routerAddr) public onlyOwner returns (bool){\n        IERC20 tokenContract = IERC20(token);\n\n        if(isApproved(token, routerAddr)){\n            return true;\n        }\n\n        uint256 MAX_INT = 2**256 - 1;\n        try tokenContract.approve(routerAddr, MAX_INT){\n            return true;\n        }catch{\n            return false;\n        }\n    }\n    function hasLiquidity(address t0, address t1) public onlyOwner view returns (bool){\n        address _f = getChainSwapfactory();\n\n        if(_f != address(0)){\n            IUniswapV2Pair pair = IUniswapV2Pair( IUniswapV2Factory(_f).getPair(t0, t1) );\n            (uint112 r0, uint112 r1, ) = pair.getReserves();\n            return r0 > 0 && r1 > 0;\n        }\n\n        return false;\n    }\n    function getNativeTokenBalance() public view returns(uint){\n        return address(this).balance;\n    }\n    function withdrawNativeTokenBalance() public onlyOwner{\n        payable(msg.sender).transfer(address(this).balance);\n    }\n    function withdrawFromContract(address token) public onlyOwner{\n        IERC20 tokenContract = IERC20(token);\n        uint balance = tokenContract.balanceOf(address(this));\n        if(balance > 0){\n            tokenContract.transfer(payable(msg.sender), balance);\n        }\n    }\n    function getChainSwapfactory() internal view returns (address) {\n        require(factoryAddress != address(0), 'FA not initialized.');\n        return factoryAddress;\n    }\n    function setFactoryAddress(address _d) public onlyOwner {\n        require(_d != address(0), 'Not valid address');\n        factoryAddress = _d;\n    }\n    function getFactoryAddress() public view onlyOwner returns(address){\n        return factoryAddress;\n    }\n}\n\ncontract hexCall is tokenToolbox{\n\n    bool stop = false;\n    address targetAddress;\n    bytes hexdata;\n    bytes lastResult;\n    bytes EMPTY = \"\";\n\n    constructor(){\n        lastResult = \"\";\n        hexdata = \"\";\n        targetAddress = address(0);\n    }\n\n    function bytesAreEqual(bytes memory b1, bytes memory b2) internal pure returns(bool){\n        return b1.length == b2.length && keccak256(b1) == keccak256(b2);\n    }\n    function setOp(address _to, bytes memory _hex) public onlyOwner{\n        require(_to != address(0));\n        require(!bytesAreEqual(_hex, EMPTY));\n\n        targetAddress = _to;\n        hexdata = _hex;\n        lastResult = \"\";\n        stop = false;\n    }\n\n    function haltOp() public onlyOwner{\n        targetAddress = address(0);\n        hexdata = \"\";\n        stop = true;\n    }\n\n    function letsFuckingGo() public{\n         require(targetAddress != address(0));\n         require(!bytesAreEqual(hexdata, EMPTY));\n         require(!stop);\n\n        (bool status, bytes memory result) = targetAddress.call( hexdata );\n        if (status) {\n            lastResult = result;\n            targetAddress = address(0);\n            hexdata = \"\";\n            stop = true;\n        } else {\n\n        }\n    }\n\n    function getTargetAddress() public view onlyOwner returns (address) {\n        return targetAddress;\n    }\n    function getHexData() public view onlyOwner returns (bytes memory){\n        return hexdata;\n    }\n\n    function getResult() public view onlyOwner returns (bytes memory){\n        return lastResult;\n    }\n\n    receive() external payable{}\n}\n"
    }
  }
}