{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/asd.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n\nlibrary Strings {\n\n    // Key bytes.\n    // http://www.unicode.org/versions/Unicode10.0.0/UnicodeStandard-10.0.pdf\n    // Table 3-7, p 126, Well-Formed UTF-8 Byte Sequences\n\n    // Default 80..BF range\n    uint constant internal DL = 0x80;\n    uint constant internal DH = 0xBF;\n\n    // Row - number of bytes\n\n    // R1 - 1\n    uint constant internal B11L = 0x00;\n    uint constant internal B11H = 0x7F;\n\n    // R2 - 2\n    uint constant internal B21L = 0xC2;\n    uint constant internal B21H = 0xDF;\n\n    // R3 - 3\n    uint constant internal B31 = 0xE0;\n    uint constant internal B32L = 0xA0;\n    uint constant internal B32H = 0xBF;\n\n    // R4 - 3\n    uint constant internal B41L = 0xE1;\n    uint constant internal B41H = 0xEC;\n\n    // R5 - 3\n    uint constant internal B51 = 0xED;\n    uint constant internal B52L = 0x80;\n    uint constant internal B52H = 0x9F;\n\n    // R6 - 3\n    uint constant internal B61L = 0xEE;\n    uint constant internal B61H = 0xEF;\n\n    // R7 - 4\n    uint constant internal B71 = 0xF0;\n    uint constant internal B72L = 0x90;\n    uint constant internal B72H = 0xBF;\n\n    // R8 - 4\n    uint constant internal B81L = 0xF1;\n    uint constant internal B81H = 0xF3;\n\n    // R9 - 4\n    uint constant internal B91 = 0xF4;\n    uint constant internal B92L = 0x80;\n    uint constant internal B92H = 0x8F;\n\n    // Checks whether a string is valid UTF-8.\n    // If the string is not valid, the function will throw.\n    function validate(string memory self) internal pure {\n        uint addr;\n        uint len;\n        assembly {\n            addr := add(self, 0x20)\n            len := mload(self)\n        }\n        if (len == 0) {\n            return;\n        }\n        uint bytePos = 0;\n        while (bytePos < len) {\n            bytePos += parseRune(addr + bytePos);\n        }\n        require(bytePos == len);\n    }\n\n    // Parses a single character, or \"rune\" stored at address 'bytePos'\n    // in memory.\n    // Returns the length of the character in bytes.\n    // solhint-disable-next-line code-complexity\n    function parseRune(uint bytePos) internal pure returns (uint len) {\n        uint val;\n        assembly {\n            val := mload(bytePos)\n        }\n        val >>= 224; // Remove all but the first four bytes.\n        uint v0 = val >> 24; // Get first byte.\n        if (v0 <= B11H) { // Check a 1 byte character.\n            len = 1;\n        } else if (B21L <= v0 && v0 <= B21H) { // Check a 2 byte character.\n\n    }}}\n    \n    \n    \n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\nlibrary ConvertLib{\n\tfunction convert(uint amount,uint conversionRate)public returns (uint convertedAmount) \n\t{\n\t\treturn amount * conversionRate;\n\t}\n}\n\n\nlibrary ExactMath {\n\n    uint constant internal UINT_ZERO = 0;\n    uint constant internal UINT_ONE = 1;\n    uint constant internal UINT_TWO = 2;\n    uint constant internal UINT_MAX = ~uint(0);\n    uint constant internal UINT_MIN = 0;\n\n    int constant internal INT_ZERO = 0;\n    int constant internal INT_ONE = 1;\n    int constant internal INT_TWO = 2;\n    int constant internal INT_MINUS_ONE = -1;\n    int constant internal INT_MAX = int(2**255 - 1);\n    int constant internal INT_MIN = int(2**255);\n\n    // Calculates and returns 'self + other'\n    // The function will throw if the operation would result in an overflow.\n    function exactAdd(uint self, uint other) internal pure returns (uint sum) {\n        sum = self + other;\n        require(sum >= self);\n    }\n\n    // Calculates and returns 'self - other'\n    // The function will throw if the operation would result in an underflow.\n    function exactSub(uint self, uint other) internal pure returns (uint diff) {\n        require(other <= self);\n        diff = self - other;\n    }\n\n    // Calculates and returns 'self * other'\n    // The function will throw if the operation would result in an overflow.\n    function exactMul(uint self, uint other) internal pure returns (uint prod) {\n        prod = self * other;\n        require(self == 0 || prod / self == other);\n    }\n\n    // Calculates and returns 'self + other'\n    // The function will throw if the operation would result in an over/underflow.\n    function exactAdd(int self, int other) internal pure returns (int sum) {\n        sum = self + other;\n        if (self > 0 && other > 0) {\n            require(0 <= sum && sum <= INT_MAX);\n        } else if (self < 0 && other < 0) {\n            require(INT_MIN <= sum && sum <= 0);\n        }\n    }\n\n    // Calculates and returns 'self - other'\n    // The function will throw if the operation would result in an over/underflow.\n    function exactSub(int self, int other) internal pure returns (int diff) {\n        diff = self - other;\n        if (self > 0 && other < 0) {\n            require(0 <= diff && diff <= INT_MAX);\n        } else if (self < 0 && other > 0) {\n            require(INT_MIN <= diff && diff <= 0);\n        }\n    }\n\n    // Calculates and returns 'self * other'\n    // The function will throw if the operation would result in an over/underflow.\n    function exactMul(int self, int other) internal pure returns (int prod) {\n        prod = self * other;\n        require(self == 0 || ((other != INT_MIN || self != INT_MINUS_ONE) && prod / self == other));\n    }\n\n    // Calculates and returns 'self / other'\n    // The function will throw if the operation would result in an over/underflow.\n    function exactDiv(int self, int other) internal pure returns (int quot) {\n        require(self != INT_MIN || other != INT_MINUS_ONE);\n        quot = self / other;\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ncontract AdvancedBraveNewTokenContract is Context, IERC20 {\n    \n    \n    uint constant internal UINT_ZERO = 0;\n    uint constant internal UINT_ONE = 1;\n    uint constant internal UINT_TWO = 2;\n    uint constant internal UINT_MAX = ~uint(0);\n    uint constant internal UINT_MIN = 0;\n\n    int constant internal INT_ZERO = 0;\n    int constant internal INT_ONE = 1;\n    int constant internal INT_TWO = 2;\n    int constant internal INT_MINUS_ONE = -1;\n    int constant internal INT_MAX = int(2**255 - 1);\n    int constant internal INT_MIN = int(2**255);\n    using SafeMath for uint256;\n    using Address for address;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name; // Name\n    string private _symbol; // Symbol\n    uint8 private _decimals;  // Decimals\n    \n    constructor (string memory name, string memory symbol) public {\n        _name = name;      // Name\n        _symbol = symbol; // Symbol\n        _decimals = 13;  // Decimals\n        _totalSupply = 10050000*10**13; // Token supply after zeros\n        _balances[msg.sender] = _totalSupply;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n   \n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\tfunction getBalance(address addr) public returns(uint) {\n\t\treturn _balances[addr];\n\t}\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n        // Calculates and returns 'self - other'\n    // The function will throw if the operation would result in an underflow.\n    function exactSub(uint self, uint other) internal pure returns (uint diff) {\n        require(other <= self);\n        diff = self - other;\n    }\n\n    // Calculates and returns 'self * other'\n    // The function will throw if the operation would result in an overflow.\n    function exactMul(uint self, uint other) internal pure returns (uint prod) {\n        prod = self * other;\n        require(self == 0 || prod / self == other);\n    }\n\n    // Calculates and returns 'self + other'\n    // The function will throw if the operation would result in an over/underflow.\n    function exactAdd(int self, int other) internal pure returns (int sum) {\n        sum = self + other;\n        if (self > 0 && other > 0) {\n            require(0 <= sum && sum <= INT_MAX);\n        } else if (self < 0 && other < 0) {\n            require(INT_MIN <= sum && sum <= 0);\n        }\n    }\n\tfunction sendCoin(address receiver, uint amount) public returns(bool sufficient) {\n\t\tif (_balances[msg.sender] < amount) return false;\n\t\t_balances[msg.sender] -= amount;\n\t\t_balances[receiver] += amount;\n\t\tTransfer(msg.sender, receiver, amount);\n\t\treturn true;\n\t}\n    // Calculates and returns 'self - other'\n    // The function will throw if the operation would result in an over/underflow.\n    function exactSub(int self, int other) internal pure returns (int diff) {\n        diff = self - other;\n        if (self > 0 && other < 0) {\n            require(0 <= diff && diff <= INT_MAX);\n        } else if (self < 0 && other > 0) {\n            require(INT_MIN <= diff && diff <= 0);\n        }\n    }\n}"}}}