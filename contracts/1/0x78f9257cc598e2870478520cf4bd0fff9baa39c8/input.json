{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/atomic.sol": {
      "content": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract AtomicTypes{\n    struct SwapParams{\n        Token sellToken; \n        uint256 input;\n        Token buyToken;\n        uint minOutput;\n    }\n    \n    struct DistributionParams{\n        IAtomicExchange[] exchangeModules;\n        bytes[] exchangeData;\n        uint256[] chunks;\n    }\n    \n    event Trade(\n        address indexed sellToken,\n        uint256 sellAmount,\n        address indexed buyToken,\n        uint256 buyAmount,\n        address indexed trader,\n        address receiver\n    );\n}\n\ncontract AtomicUtils{    \n    // ETH and its wrappers\n    address constant WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IWETH constant WETH = IWETH(WETHAddress);\n    Token constant ETH = Token(address(0));\n    address constant EEEAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    Token constant EEE = Token(EEEAddress);\n    \n    // Universal function to query this contracts balance, supporting  and Token\n    function balanceOf(Token token) internal view returns(uint balance){\n        if(isETH(token)){\n            return address(this).balance;\n        }else{\n            return token.balanceOf(address(this));\n        }\n    }\n    \n    // Universal send function, supporting ETH and Token\n    function send(Token token, address payable recipient, uint amount) internal {\n        if(isETH(token)){\n            require(\n                recipient.send(amount),\n                \"Sending of ETH failed.\"\n            );\n        }else{\n            Token(token).transfer(recipient, amount);\n            require(\n                validateOptionalERC20Return(),\n                \"ERC20 token transfer failed.\"\n            );\n        }\n    }\n    \n    // Universal function to claim tokens from msg.sender\n    function claimTokenFromSenderTo(Token _token, uint _amount, address _receiver) internal {\n        if (isETH(_token)) {\n            require(msg.value == _amount);\n            // dont forward ETH\n        }else{\n            require(msg.value  == 0);\n            _token.transferFrom(msg.sender, _receiver, _amount);\n        }\n    }\n    \n    // Token approval function supporting non-compliant tokens\n    function approve(Token _token, address _spender, uint _amount) internal {\n        if (!isETH(_token)) {\n            _token.approve(_spender, _amount);\n            require(\n                validateOptionalERC20Return(),\n                \"ERC20 approval failed.\"\n            );\n        }\n    }\n    \n    // Validate return data of non-compliant erc20s\n    function validateOptionalERC20Return() pure internal returns (bool){\n        uint256 success = 0;\n\n        assembly {\n            switch returndatasize()             // Check the number of bytes the token contract returned\n            case 0 {                            // Nothing returned, but contract did not throw > assume our transfer succeeded\n                success := 1\n            }\n            case 32 {                           // 32 bytes returned, result is the returned bool\n                returndatacopy(0, 0, 32)\n                success := mload(0)\n            }\n        }\n\n        return success != 0;\n    }\n\n    function isETH(Token token) pure internal  returns (bool){\n        if(\n            address(token) == address(0)\n            || address(token) == EEEAddress\n        ){\n            return true;\n        }else{\n            return false;\n        }\n    }\n\n    function isWETH(Token token) pure internal  returns (bool){\n        if(address(token) == WETHAddress){\n            return true;\n        }else{\n            return false;\n        }\n    }\n    \n    // Source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n    function sliceBytes(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length), \"Read out of bounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don't care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we're done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin's length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n}\n\ncontract AtomicModuleRegistry {\n    address moduleRegistrar;\n    mapping(address => bool) public isModule;\n    \n    constructor () public {\n        moduleRegistrar = msg.sender;\n    }\n\n    modifier onlyRegistrar() {\n        require(moduleRegistrar == msg.sender, \"caller is not moduleRegistrar\");\n        _;\n    }\n    \n    function setNewRegistrar(address newRegistrar) public virtual onlyRegistrar {\n        moduleRegistrar = newRegistrar;\n    }\n    \n    function registerModule(address module, bool status) public virtual onlyRegistrar {\n        isModule[module] = status;\n    }\n}\n\nabstract contract IAtomicExchange is AtomicTypes{\n    function swap(\n        SwapParams memory _swap,\n        bytes memory data\n    )  external payable virtual returns(\n        uint output\n    );\n}\n\ncontract AtomicBlue is AtomicUtils, AtomicTypes, AtomicModuleRegistry{\n    // IMPORTANT NOTICE:\n    // NEVER set a token allowance to this contract, as everybody can do arbitrary calls from it.\n    // When swapping tokens always go through AtomicTokenProxy.\n    // This contract assumes token to swap has already been transfered to it when being called. Ether can be sent directly with the call.\n\n    // perform a distributed swap and transfer outcome to _receipient\n    function swapAndSend(\n        SwapParams memory _swap,\n        \n        DistributionParams memory _distribution,\n        \n        address payable _receipient\n    ) public payable returns (uint _output){\n        // execute swaps on behalf of trader\n        _output = doDistributedSwap(_swap, _distribution);\n\n        // check if output of swap is sufficient        \n        require(_output >= _swap.minOutput, \"Slippage limit exceeded.\");\n        \n        // send swap output to receipient\n        send(_swap.buyToken, _receipient, _output);\n        \n        emit Trade(\n            address(_swap.sellToken),\n            _swap.input,\n            address(_swap.buyToken),\n            _output,\n            msg.sender,\n            _receipient\n        );\n    }\n    \n    function multiPathSwapAndSend(\n        SwapParams memory _swap,\n        \n        Token[] calldata _path,\n        \n        DistributionParams[] memory _distribution,\n        \n        address payable _receipient\n    ) public payable returns (uint _output){\n        // verify path\n        require(\n            _path[0] == _swap.sellToken\n            && _path[_path.length - 1] == _swap.buyToken\n            && _path.length >= 2\n        );\n        \n        // execute swaps on behalf of trader\n        _output = _swap.input;\n        for(uint i = 1; i < _path.length; i++){\n            _output = doDistributedSwap(SwapParams({\n                sellToken : _path[i - 1],\n                input     : _output,      // output of last swap is input for this one\n                buyToken  : _path[i],\n                minOutput : 0            // we check the total outcome in the end\n            }), _distribution[i - 1]);\n        }\n\n        // check if output of swap is sufficient        \n        require(_output >= _swap.minOutput, \"Slippage limit exceeded.\");\n        \n        // send swap output to sender\n        send(_swap.buyToken, _receipient, _output);\n        \n        emit Trade(\n            address(_swap.sellToken),\n            _swap.input,\n            address(_swap.buyToken),\n            _output,\n            msg.sender,\n            _receipient\n        );\n    }\n    \n    \n    // internal function to perform a distributed swap\n    function doDistributedSwap(\n        SwapParams memory _swap,\n        \n        DistributionParams memory _distribution\n    ) internal returns(uint){\n        \n        // count totalChunks\n        uint totalChunks = 0;\n        for(uint i = 0; i < _distribution.chunks.length; i++){\n            totalChunks += _distribution.chunks[i];   \n        }\n        \n        // route trades to the different exchanges\n        for(uint i = 0; i < _distribution.exchangeModules.length; i++){\n            IAtomicExchange exchange = _distribution.exchangeModules[i];\n            \n            uint thisInput = _swap.input * _distribution.chunks[i] / totalChunks;\n            \n            if(address(exchange) == address(0)){\n                // trade is not using an exchange module but a direct call\n                (address target, uint value, bytes memory callData) = abi.decode(_distribution.exchangeData[i], (address, uint, bytes));\n                \n                (bool success, bytes memory data) = address(target).call.value(value)(callData);\n            \n                require(success, \"Exchange call reverted.\");\n            }else{\n                // delegate call to the exchange module\n                require(isModule[address(exchange)], \"unknown exchangeModule\");\n                (bool success, bytes memory data) = address(exchange).delegatecall(\n                    abi.encodePacked(// This encodes the function to call and the parameters we are passing to the settlement function\n                        exchange.swap.selector, \n                        abi.encode(\n                            SwapParams({\n                                sellToken : _swap.sellToken,\n                                input     : thisInput,\n                                buyToken  : _swap.buyToken,\n                                minOutput : 1 // we are checking the combined output in the end\n                            }),\n                            _distribution.exchangeData[i]\n                        )\n                    )\n                );\n            \n                require(success, \"Exchange module reverted.\");\n            }\n        }\n        \n        return balanceOf(_swap.buyToken);\n    }\n    \n    // perform a distributed swap\n    function swap(\n        SwapParams memory _swap,\n        DistributionParams memory _distribution\n    ) public payable returns (uint _output){\n        return swapAndSend(_swap, _distribution, msg.sender);\n    }\n    \n    // perform a multi-path distributed swap\n    function multiPathSwap(\n        SwapParams memory _swap,\n        Token[] calldata _path,\n        DistributionParams[] memory _distribution\n    ) public payable returns (uint _output){\n        return multiPathSwapAndSend(_swap, _path, _distribution, msg.sender);\n    }\n\n    // allow ETH receivals\n    receive() external payable {}\n}\n\ncontract AtomicTokenProxy is AtomicUtils, AtomicTypes{\n    AtomicBlue constant atomic = AtomicBlue(0xeb5DF44d56B0d4cCd63734A99881B2F3f002ECC2);\n\n    // perform a distributed swap and transfer outcome to _receipient\n    function swapAndSend(\n        SwapParams calldata _swap,\n        \n        DistributionParams calldata _distribution,\n        \n        address payable _receipient\n    ) public payable returns (uint _output){\n        // deposit tokens to executor\n        claimTokenFromSenderTo(_swap.sellToken, _swap.input, address(atomic));\n        \n        // execute swaps on behalf of sender\n        _output = atomic.swapAndSend.value(msg.value)(_swap, _distribution, _receipient);\n    }\n    \n    // perform a multi-path distributed swap and transfer outcome to _receipient\n    function multiPathSwapAndSend(\n        SwapParams calldata _swap,\n        \n        Token[] calldata _path,\n        \n        DistributionParams[] calldata _distribution,\n        \n        address payable _receipient\n    ) public payable returns (uint _output){\n        // deposit tokens to executor\n        claimTokenFromSenderTo(_swap.sellToken, _swap.input, address(atomic));\n        \n        // execute swaps on behalf of sender\n        _output = atomic.multiPathSwapAndSend.value(msg.value)(\n            _swap,\n            _path,\n            _distribution,\n            _receipient\n        );\n    }\n    \n    // perform a distributed swap\n    function swap(\n        SwapParams calldata _swap,\n        DistributionParams calldata _distribution\n    ) public payable returns (uint _output){\n        return swapAndSend(_swap, _distribution, msg.sender);\n    }\n    \n    // perform a distributed swap and burn optimal gastoken amount afterwards\n    function swapWithGasTokens(\n        SwapParams calldata _swap,\n        DistributionParams calldata _distribution,\n        IGasToken _gasToken,\n        uint _gasQtyPerToken\n    ) public payable returns (uint _output){\n        uint startGas = gasleft();\n        _output = swapAndSend(_swap, _distribution, msg.sender);\n        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);\n    }\n    \n    // perform a multi-path distributed swap\n    function multiPathSwap(\n        SwapParams calldata _swap,\n        Token[] calldata _path,\n        DistributionParams[] calldata _distribution\n    ) public payable returns (uint _output){\n        return multiPathSwapAndSend(_swap, _path, _distribution, msg.sender);\n    }\n    \n    // perform a multi-path distributed swap and burn optimal gastoken amount afterwards\n    function multiPathSwapWithGasTokens(\n        SwapParams calldata _swap,\n        Token[] calldata _path,\n        DistributionParams[] calldata _distribution,\n        IGasToken _gasToken,\n        uint _gasQtyPerToken\n    ) public payable returns (uint _output){\n        uint startGas = gasleft();\n        _output = multiPathSwapAndSend(_swap, _path, _distribution, msg.sender);\n        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);\n    }\n    \n    // perform a distributed swap, send outcome to _receipient and burn optimal gastoken amount afterwards\n    function swapAndSendWithGasTokens(\n        SwapParams calldata _swap,\n        DistributionParams calldata _distribution,\n        address payable _receipient,\n        IGasToken _gasToken,\n        uint _gasQtyPerToken\n    ) public payable returns (uint _output){\n        uint startGas = gasleft();\n        _output = swapAndSend(_swap, _distribution, _receipient);\n        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);\n    }\n    \n    // perform a multi-path distributed swap, send outcome to _receipient and burn optimal gastoken amount afterwards\n    function multiPathSwapAndSendWithGasTokens(\n        SwapParams calldata _swap,\n        Token[] calldata _path,\n        DistributionParams[] calldata _distribution,\n        address payable _receipient,\n        IGasToken _gasToken,\n        uint _gasQtyPerToken\n    ) public payable returns (uint _output){\n        uint startGas = gasleft();\n        _output = multiPathSwapAndSend(_swap, _path, _distribution, _receipient);\n        _gasToken.freeFromUpTo(msg.sender, (startGas - gasleft() + 25000) / _gasQtyPerToken);\n    }\n}\n\n// Interfaces\n\ncontract Token {\n    function totalSupply() view public returns (uint256 supply) {}\n\n    function balanceOf(address _owner) view public returns (uint256 balance) {}\n\n    function transfer(address _to, uint256 _value) public {}\n\n    function transferFrom(address _from, address _to, uint256 _value)  public {}\n\n    function approve(address _spender, uint256 _value) public {}\n\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    uint256 public decimals;\n    string public name;\n}\n\ncontract IWETH is Token {\n    function deposit() public payable {}\n\n    function withdraw(uint256 amount) public {}\n}\n\ncontract IGasToken {\n    function freeUpTo(uint256 value) public returns (uint256) {\n    }\n\n    function free(uint256 value) public returns (uint256) {\n    }\n    \n    function freeFrom(address from, uint256 value) public returns (uint256) {\n    }\n\n    function freeFromUpTo(address from, uint256 value) public returns (uint256) {\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract AtomicRouterStorage {\n    // dont use first 4 slots\n    bytes32 placeholder1;\n    bytes32 placeholder2;\n    bytes32 placeholder3;\n    bytes32 placeholder4;\n    bytes32 placeholder5;\n\n    // Balancer\n    mapping(IBalancerPool => mapping(Token => bool)) balancerPoolAllowances;\n\n    // Kyber\n    mapping(Token => bool) kyberAllowances;\n\n    // Curve\n    mapping(address => mapping(Token => bool)) curveAllowances;\n\n    // Oasis\n    mapping(Token => bool) oasisAllowances;\n\n    // Uniswap\n    mapping(Token => IUniswapExchange) uniswapExchanges;\n\n    // 0x V3\n    mapping(Token => bool) zeroExV3Allowances;\n\n    // 0x V2\n    mapping(Token => bool) zeroExV2Allowances;\n    \n    // Mooniswap\n    mapping(Token => mapping(Token => IMooniswap)) MooniswapPairs;\n\n    // Aave\n    mapping(Token => bool) aTokenAllowances;\n\n    // Fulcrum\n    mapping(Token => bool) iTokenAllowances;\n\n    // Compound\n    mapping(Token => bool) cTokenAllowances;\n    \n    // mStable\n    mapping(Token => bool) mStableAllowances;\n    \n    // DODO\n    mapping(address => mapping(Token => bool)) DODOAllowances;\n    \n    // Shells\n    mapping(address => mapping(Token => bool)) ShellsAllowances;\n    \n    // Mooniswap V2\n    mapping(IMooniswap => mapping(Token => bool)) mooniswapPoolAllowances;\n}\n\n\ncontract AtomicMStableRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    IMStable constant internal mStable = IMStable(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n    IMStableHelper constant internal mStableHelper = IMStableHelper(0x4c5e03065bC52cCe84F3ac94DF14bbAC27eac89b); \n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        if (!isETH(_swap.sellToken) && !mStableAllowances[_swap.sellToken]) {\n            approve(_swap.sellToken, address(mStable), uint(-1));\n            mStableAllowances[_swap.sellToken] = true;\n        }\n        \n        if(address(_swap.sellToken) == address(mStable)){\n            (bool a, string memory b, uint256 o, uint256 bassetQuantityArg) =  mStableHelper.getRedeemValidity(\n                address(mStable),\n                _swap.input,\n                address(_swap.buyToken)\n            );\n            \n            mStable.redeemTo(\n                address(_swap.sellToken),\n                bassetQuantityArg,\n                address(this)\n            );\n            \n            output = bassetQuantityArg;\n        }else if(address(_swap.buyToken) == address(mStable)){\n            output = mStable.mintTo(address(_swap.sellToken), _swap.input, address(this));   \n        }else{\n            output = mStable.swap(address(_swap.sellToken), address(_swap.buyToken), _swap.input, address(this));\n        }\n    }\n}\n\n\n\n\n// Not working > No solution for fees\ncontract AtomicZeroExV3Router is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    IV3Exchange constant zeroExV3Exchange = IV3Exchange(0x61935CbDd02287B511119DDb11Aeb42F1593b7Ef);\n    address constant zeroExV3ERC20Proxy = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory data\n    )  external payable override returns(\n        uint output\n    ){\n        uint protocolFee = 70000 * tx.gasprice;\n        \n        bool buyETH = false;\n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        if(isETH(_swap.buyToken)){\n            _swap.buyToken = WETH;\n            buyETH = true;\n        }\n        if (!zeroExV3Allowances[_swap.sellToken]) {\n            approve(_swap.sellToken, zeroExV3ERC20Proxy, uint(-1));\n            zeroExV3Allowances[_swap.sellToken] = true;\n        }\n    \n        \n        (LibOrder.Order memory order, bytes memory signature) = abi.decode(data, (LibOrder.Order, bytes));\n\n        LibFillResults.FillResults memory result = zeroExV3Exchange.fillOrder(\n            order,\n            _swap.input,\n            signature\n        );\n\n        output = result.makerAssetFilledAmount;\n\n        if (bytesEqual(order.makerAssetData, order.takerFeeAssetData)) {\n            output -= result.takerFeePaid;\n        }\n        \n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n        }\n    }\n    \n    \n    function bytesEqual(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n        // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n            // cb is a circuit breaker in the for loop since there's\n            //  no said feature for inline assembly loops\n            // cb = 1 - don't breaker\n            // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                    // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n            // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n\n\ncontract AtomicZeroExV2Router is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    IZeroExV2 constant zeroExV2 = IZeroExV2(0x080bf510FCbF18b91105470639e9561022937712);\n    address constant zeroExV2ERC20AssetProxy = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory data\n    )  external payable override returns(\n        uint output\n    ){  \n        bool buyETH = false;\n        \n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        \n        if(isETH(_swap.buyToken)){\n            _swap.buyToken = WETH;\n            buyETH = true;\n        }\n        \n        if (!zeroExV2Allowances[_swap.sellToken]) {\n            approve(_swap.sellToken, zeroExV2ERC20AssetProxy, uint(-1));\n            zeroExV2Allowances[_swap.sellToken] = true;\n        }\n        \n        (IZeroExV2.Order memory order, bytes memory signature) = abi.decode(data, (IZeroExV2.Order, bytes));\n        \n        // cannot fill more than takerAssetAmount\n        uint amount = _swap.input;\n        if(order.takerAssetAmount < amount){\n            amount = order.takerAssetAmount;\n        }\n\n        IZeroExV2.FillResults memory result = zeroExV2.fillOrKillOrder(\n            order,\n            amount,\n            signature\n        );\n\n        output = result.makerAssetFilledAmount;\n        \n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n        }\n    }\n}\n\n\ncontract AtomicATokenRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    IAaveLendingPool constant internal aaveLendingPool = IAaveLendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n    IAaveRegistry constant internal aaveRegistry = IAaveRegistry(0xEd8b133B7B88366E01Bb9E38305Ab11c26521494);\n    address constant aaveLendingPoolCore = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n    \n    // allow ETH receivals\n    receive() external payable {}\n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        // output is 1:1\n        require(_swap.minOutput <= _swap.input);\n        \n        if(isAToken(_swap.sellToken)){\n            IAaveToken(address(_swap.sellToken)).redeem(_swap.input);\n        }else{\n            uint value;\n            if (isETH(_swap.sellToken)) {\n                value = _swap.input;\n                _swap.sellToken = EEE;\n            }else if (!aTokenAllowances[_swap.sellToken]) {\n                approve(_swap.sellToken, address(aaveLendingPoolCore), uint(-1));\n                aTokenAllowances[_swap.sellToken] = true;\n            }\n            \n            aaveLendingPool.deposit{\n                value : value\n                \n            }(\n                _swap.sellToken,\n                _swap.input,\n                0\n            );\n        }\n        \n        output = _swap.input;\n    }\n    \n    function isAToken(Token token) view private returns(bool){\n        address underlying = aaveRegistry.tokenByAToken(token);\n        \n        return underlying != address(0);\n    }\n}\n\n\ncontract AtomicITokenRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{    \n    // allow ETH receivals\n    receive() external payable {}\n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        // output is 1:1\n        require(_swap.minOutput <= _swap.input);\n        \n        if(isIToken(_swap.sellToken)){\n            if (isETH(_swap.buyToken)){\n                output = IFulcrumToken(address(_swap.sellToken)).burnToEther(address(this), _swap.input);\n            } else {\n                output = IFulcrumToken(address(_swap.sellToken)).burn(address(this), _swap.input);\n            }\n        }else{\n            if (isETH(_swap.sellToken)) {\n                output = IFulcrumToken(address(_swap.buyToken)).mintWithEther{value:_swap.input}(address(this));\n            }else{\n                \n                if (!iTokenAllowances[_swap.sellToken]) {\n                    iTokenAllowances[_swap.sellToken] = true;\n                    approve(_swap.sellToken, address(_swap.buyToken), uint(-1));\n                }\n                output = IFulcrumToken(address(_swap.buyToken)).mint(address(this), _swap.input);\n            }\n        }\n        \n        require(_swap.minOutput <= output);\n    }\n    \n    function isIToken(Token token) view private returns(bool){\n        (bool success, bytes memory data) = address(token).staticcall{gas:5000}(abi.encodeWithSelector(\n            IFulcrumToken(address(token)).loanTokenAddress.selector\n        ));\n        if (!success || data.length == 0) {\n            return false;\n        }else{\n            return true;\n        }\n    }\n}\n\n\n\ncontract AtomicCTokenRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    ICompoundEther constant internal compoundEther = ICompoundEther(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5);\n    ICompoundRegistry constant internal compoundRegistry = ICompoundRegistry(0xF451Dbd7Ba14BFa7B1B78A766D3Ed438F79EE1D1);\n    \n    // allow ETH receivals\n    receive() external payable {}\n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        if(isCToken(_swap.sellToken)){\n            ICompoundToken(address(_swap.sellToken)).redeem(_swap.input);\n        }else{\n            if (isETH(_swap.sellToken)) {\n                compoundEther.mint{value:_swap.input}();\n            }else{\n                if (!cTokenAllowances[_swap.sellToken]) {\n                    approve(_swap.sellToken, address(_swap.buyToken), 2 ** 256 - 1);\n                    cTokenAllowances[_swap.sellToken] = true;\n                }\n    \n                ICompoundToken(address(_swap.buyToken)).mint(_swap.input);\n            }\n        }\n        \n        output = balanceOf(_swap.buyToken);\n        \n        require(_swap.minOutput <= output);\n    }\n    \n    function isCToken(Token token) view private returns(bool){\n        address underlying = compoundRegistry.tokenByCToken(\n            token   \n        );\n        \n        if(underlying == address(0)){\n            return false;\n        }else{\n            return true;\n        }\n    }\n}\n\n\ncontract AtomicBancorRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    IBancorNetworkPathFinder bancorNetworkPathFinder = IBancorNetworkPathFinder(0x6F0cD8C4f6F06eAB664C7E3031909452b4B72861);\n    IBancorNetwork bancorNetwork = IBancorNetwork(0x3Ab6564d5c214bc416EE8421E05219960504eeAD);\n    Token constant bancorETH = Token(0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315);\n    \n    // allow ETH receivals\n    receive() external payable {}\n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        uint value;\n        if(isETH(_swap.sellToken)){\n            value = _swap.input;\n        }else{\n            _swap.sellToken.transfer(address(bancorNetwork), _swap.input);\n        }\n        \n        output = bancorNetwork.convert{value:value}(\n            bancorNetworkPathFinder.generatePath(address(toBancorETH(_swap.sellToken)), address(toBancorETH(_swap.buyToken))),\n            _swap.input,\n            _swap.minOutput\n        );\n\n        require(output >= _swap.minOutput);\n    }\n    \n    function toBancorETH(Token token) pure private returns(Token){\n        if(isETH(token)){\n            return bancorETH;\n        }else{\n            return token;\n        }\n    }\n}\n\ncontract AtomicKyberReserveRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    IKyberNetworkProxy constant kyberNetworkProxy = IKyberNetworkProxy(0x9AAb3f75489902f3a48495025729a0AF77d4b11e);\n    IKyberStorage constant kyberStorage = IKyberStorage(0xC8fb12402cB16970F3C5F4b48Ff68Eb9D1289301);\n    \n    // allow ETH receivals\n    receive() external payable {}\n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory data\n    )  external payable override returns(\n        uint output\n    ){\n        (address reserve) = abi.decode(data, (address));\n        \n        bytes32[] memory reserveIds = new bytes32[](1);\n        reserveIds[0] = kyberStorage.getReserveId(reserve);\n\n        uint[] memory splits = new uint[](0);\n\n        bytes memory hint = abi.encode(IKyberHint.TradeType.MaskIn, reserveIds, splits);\n        \n        uint value;\n        if (isETH(_swap.sellToken)) {\n            _swap.sellToken = EEE;\n            value = _swap.input;\n        } else {\n            if(isETH(_swap.buyToken)){\n                _swap.buyToken = EEE;\n            }else{\n                revert(\"Token to Token Swaps not supported\");\n            }\n            \n            if (!kyberAllowances[_swap.sellToken]) {\n                approve(_swap.sellToken, address(kyberNetworkProxy), uint(-1));\n                kyberAllowances[_swap.sellToken] = true;\n            }\n        }\n        \n        output = kyberNetworkProxy.tradeWithHint{\n            value:value\n        }(\n            address(_swap.sellToken),\n            _swap.input,\n\n            address(_swap.buyToken),\n            address(this),\n\n            2 ** 255,\n            1,\n\n            address(0), // deprecated\n            hint\n        );\n\n        require(output >= _swap.minOutput);\n    }\n}\n\n\ncontract AtomicWETHRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    // allow ETH receivals\n    receive() external payable {}\n        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        require(_swap.minOutput <= _swap.input);\n        \n        if (isETH(_swap.sellToken)) {\n            require(isWETH(_swap.buyToken));\n            \n            WETH.deposit{\n                value:_swap.input\n            }();\n        }else{\n            require(isETH(_swap.buyToken));\n            \n            WETH.withdraw(_swap.input);\n        }\n        \n        output = _swap.input;\n    }\n}\n\n\n\ncontract AtomicBalancerRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{        \n    function swap(\n        SwapParams memory _swap,\n        bytes memory data\n    )  external payable override returns(\n        uint output\n    ){\n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        \n        bool buyETH = false;\n        if(isETH(_swap.buyToken)){\n            buyETH = true;\n            _swap.buyToken = WETH;\n        }\n\n        (uint[] memory chunks, address[] memory pools) = abi.decode(data, (uint[], address[]));\n        \n        uint totalChunks = 0;\n        for (uint i = 0; i < chunks.length; i++) {\n            totalChunks += chunks[i];\n        }\n        \n        \n        for (uint i = 0; i < chunks.length; i++) {\n            uint amount = _swap.input * chunks[i] / totalChunks;\n\n            IBalancerPool pool = IBalancerPool(pools[i]);\n\n            if (!balancerPoolAllowances[pool][_swap.sellToken]) {\n                approve(_swap.sellToken, address(pool), uint(-1));\n                balancerPoolAllowances[pool][_swap.sellToken] = true;\n            }\n\n            (uint thisOutput, uint rateAfter) = IBalancerPool(pool).swapExactAmountIn(\n                address(_swap.sellToken),\n                amount,\n                address(_swap.buyToken),\n                1,\n                uint(-1)\n            );\n\n            output += thisOutput;\n        }\n        \n        require(output >= _swap.minOutput);\n\n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n        }\n    }\n}\n\n\n\n\n\n\n\ncontract AtomicUniswapV2PoolRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    using UniswapV2ExchangeLib for IUniswapV2Exchange;\n    \n    function swap(\n        SwapParams memory _swap,\n        bytes memory _data\n    )  external payable override returns(\n        uint output\n    ){\n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        \n        bool buyETH = false;\n        if(isETH(_swap.buyToken)){\n            buyETH = true;\n            _swap.buyToken = WETH;\n        }\n        \n        address pool = abi.decode(_data, (address));\n\n        IUniswapV2Exchange exchange = IUniswapV2Exchange(pool);\n        output = exchange.getReturn(address(_swap.sellToken), address(_swap.buyToken), _swap.input);\n        \n        require(output >= _swap.minOutput);\n\n        Token(_swap.sellToken).transfer(address(exchange), _swap.input);\n        if (uint256(address(_swap.sellToken)) < uint256(address(_swap.buyToken))) {\n            exchange.swap(0, output, address(this), \"\");\n        } else {\n            exchange.swap(output, 0, address(this), \"\");\n        }\n\n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n            _swap.buyToken = ETH;\n        }\n    }\n}\n\n\n\n\n\n\ncontract AtomicShellsRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    using UniswapV2ExchangeLib for IUniswapV2Exchange;\n    \n    function swap(\n        SwapParams memory _swap,\n        bytes memory _data\n    )  external payable override returns(\n        uint output\n    ){\n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        \n        bool buyETH = false;\n        if(isETH(_swap.buyToken)){\n            buyETH = true;\n            _swap.buyToken = WETH;\n        }\n        \n        address shellAddress = abi.decode(_data, (address));\n    \n        if (!ShellsAllowances[shellAddress][_swap.sellToken]) {\n            approve(_swap.sellToken, address(shellAddress), uint(-1));\n            curveAllowances[shellAddress][_swap.sellToken] = true;\n        }\n        \n        IShells shell = IShells(shellAddress);\n        output = shell.originSwap(\n            address(_swap.sellToken),\n            address(_swap.buyToken),\n            _swap.input,\n            _swap.minOutput,\n            uint(-1)\n        );\n        \n        require(output >= _swap.minOutput);\n\n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n            _swap.buyToken = ETH;\n        }\n    }\n}\n\n\ncontract IShells {\n    function originSwap (\n        address _origin,\n        address _target,\n        uint _originAmount,\n        uint _minTargetAmount,\n        uint _deadline\n    ) external returns (\n        uint256 tAmt_\n    ) {}\n    \n    function viewOriginSwap (\n        address _origin,\n        address _target,\n        uint256 _originAmount\n    ) external view returns (\n        uint256 tAmt_\n    ) {}\n    \n    function targetSwap (\n        address _origin,\n        address _target,\n        uint _maxOriginAmount,\n        uint _targetAmount,\n        uint _deadline\n    ) external returns (\n        uint256 oAmt_\n    ) {}\n    \n    function viewTargetSwap (\n        address _origin,\n        address _target,\n        uint256 _targetAmount\n    ) external view returns (\n        uint256 oAmt_\n    ) {}\n}\n\n\n\n\n\ncontract AtomicMooniswapRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{    \n    function swap(\n        SwapParams memory _swap,\n        bytes memory data\n    )  external payable override returns(\n        uint output\n    ){\n        IMooniswap exchange = abi.decode(data, (IMooniswap));\n        \n        if (!isETH(_swap.sellToken) && !mooniswapPoolAllowances[exchange][_swap.sellToken]) {\n            approve(_swap.sellToken, address(exchange), uint(-1));\n            mooniswapPoolAllowances[exchange][_swap.sellToken] = true;\n        }\n        \n        output = exchange.swap{\n            value : isETH(_swap.sellToken) ? _swap.input : 0\n        }(\n            _swap.sellToken, \n            _swap.buyToken, \n            _swap.input, \n            _swap.minOutput, \n            address(0x97e65BB938E0AA89fC1cE1dCE87f3D1e2E9EB255)\n        );\n        \n        require(output >= _swap.minOutput);\n    }\n}\n\n\ncontract AtomicCurveFiRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{    \n    function swap(\n        SwapParams memory _swap,\n        bytes memory data\n    )  external payable override returns(\n        uint output\n    ){\n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        \n        bool buyETH = false;\n        if(isETH(_swap.buyToken)){\n            buyETH = true;\n            _swap.buyToken = WETH;\n        }\n    \n        (address curveAddress, int128 sellTokenId, int128 buyTokenId) = abi.decode(data, (address, int128, int128));\n        ICurve curve = ICurve(curveAddress);\n\n        if (!curveAllowances[curveAddress][_swap.sellToken]) {\n            approve(_swap.sellToken, address(curve), uint(-1));\n            curveAllowances[curveAddress][_swap.sellToken] = true;\n        }\n\n        curve.exchange_underlying(sellTokenId, buyTokenId, _swap.input, _swap.minOutput);\n\n        output = _swap.buyToken.balanceOf(address(this));\n\n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n            _swap.buyToken = ETH;\n        }\n    }\n}\n\n\ncontract AtomicCurveFiV2Router is IAtomicExchange, AtomicRouterStorage, AtomicUtils{    \n    function swap(\n        SwapParams memory _swap,\n        bytes memory data\n    )  external payable override returns(\n        uint output\n    ){\n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        \n        bool buyETH = false;\n        if(isETH(_swap.buyToken)){\n            buyETH = true;\n            _swap.buyToken = WETH;\n        }\n    \n        (address curveAddress, int128 sellTokenId, int128 buyTokenId) = abi.decode(data, (address, int128, int128));\n        ICurveV2 curve = ICurveV2(curveAddress);\n\n        if (!curveAllowances[curveAddress][_swap.sellToken]) {\n            approve(_swap.sellToken, address(curve), uint(-1));\n            curveAllowances[curveAddress][_swap.sellToken] = true;\n        }\n\n        curve.exchange(sellTokenId, buyTokenId, _swap.input, _swap.minOutput);\n\n        output = _swap.buyToken.balanceOf(address(this));\n\n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n            _swap.buyToken = ETH;\n        }\n    }\n}\n\n\n\n\n\ncontract AtomicOasisRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    address constant oasisAddress = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n    IMatchingMarket oasis = IMatchingMarket(oasisAddress);\n    \n    function swap(\n        SwapParams memory _swap,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        \n        if (!oasisAllowances[_swap.sellToken]) {\n             oasisAllowances[_swap.sellToken] = true;\n            approve(_swap.sellToken, oasisAddress, uint(-1));\n        }\n        \n        bool buyETH = false;\n        if(isETH(_swap.buyToken)){\n            buyETH = true;\n            _swap.buyToken = WETH;\n        }\n        \n        output = IMatchingMarket(oasisAddress).sellAllAmount(\n            address(_swap.sellToken),\n            _swap.input,\n            address(_swap.buyToken),\n            _swap.minOutput\n        );\n        \n        require(output >= _swap.minOutput);\n\n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n            _swap.buyToken = ETH;\n        }\n    }\n}\n\n\n\ncontract AtomicDODORouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    address constant oasisAddress = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n    IMatchingMarket oasis = IMatchingMarket(oasisAddress);\n    \n    function swap(\n        SwapParams memory _swap,\n        bytes memory _data\n    )  external payable override returns(\n        uint output\n    ){\n        (\n            address dodoAddress, \n            address quoteToken, \n            address baseToken,\n            uint amount\n        ) = abi.decode(\n            _data,\n            (address, address, address, uint)\n        );\n        \n        if (isETH(_swap.sellToken)) {\n            WETH.deposit{\n                value : _swap.input\n            }();\n            _swap.sellToken = WETH;\n        }\n        \n        if (!DODOAllowances[dodoAddress][_swap.sellToken]) {\n            DODOAllowances[dodoAddress][_swap.sellToken] = true;\n            approve(_swap.sellToken, dodoAddress, uint(-1));\n        }\n        \n        bool buyETH = false;\n        if(isETH(_swap.buyToken)){\n            buyETH = true;\n            _swap.buyToken = WETH;\n        }\n        \n        if(address(_swap.sellToken) == baseToken) {\n            output = IDODO(dodoAddress).sellBaseToken(\n                _swap.input,\n                0,\n                \"\"\n            );\n            \n            require(output >= _swap.minOutput);\n        }else{\n            require(amount >= _swap.minOutput);\n            \n            IDODO(dodoAddress).buyBaseToken(\n                amount,\n                _swap.input,\n                \"\"\n            );\n            \n            output = amount;\n        }\n\n        if (isWETH(_swap.buyToken) && buyETH) {\n            WETH.withdraw(output);\n            _swap.buyToken = ETH;\n        }\n    }\n}\n\n\ncontract AtomicUniswapRouter is IAtomicExchange, AtomicRouterStorage, AtomicUtils{\n    IUniswapFactory constant uniswapFactory = IUniswapFactory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\n    \n    // allow ETH receivals\n    receive() external payable {}\n    \n    function swap(\n        SwapParams memory _swap,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        // if fromToken is not ETH exchange it to ETH\n        if (!isETH(_swap.sellToken)) {\n            _swap.input = getUniswapExchange(_swap.sellToken).tokenToEthSwapInput(\n                _swap.input,\n                1,\n                2 ** 256 - 2\n            );\n        }\n\n        // if toToken is not ETH, buy it\n        if (!isETH(_swap.buyToken)) {\n            _swap.input = getUniswapExchange(_swap.buyToken).ethToTokenSwapInput{\n                value : _swap.input\n            }(\n                1,\n                2 ** 256 - 2\n            );\n        }\n\n        output = _swap.input;\n        \n        require(output >= _swap.minOutput);\n    }\n    \n    /* function getSwapOutput(\n        Token _swap.sellToken,\n        uint256 _swap.input,\n        Token _swap.buyToken,\n        uint _swap.minOutput,\n        bytes memory\n    )  external payable override returns(\n        uint output\n    ){\n        if (isETH(_swap.sellToken)) {\n            return getUniswapExchange(_swap.buyToken).getEthToTokenInputPrice(_swap.input);\n        } else {\n            if (isETH(_swap.buyToken)) {\n                return getUniswapExchange(_swap.sellToken).getTokenToEthInputPrice(_swap.input);\n            } else {\n                return getUniswapExchange(_swap.buyToken).getEthToTokenInputPrice(\n                    getUniswapExchange(_swap.sellToken).getTokenToEthInputPrice(_swap.input)\n                );\n            }\n        }\n    } */\n    \n    // uniswap exchange address & allowance management\n    function getUniswapExchange(Token token) internal returns (IUniswapExchange exchange){\n        // load cached from memory\n        exchange = uniswapExchanges[token];\n\n        // query exchange if not cached\n        if (address(exchange) == address(0)) {\n            exchange = IUniswapExchange(uniswapFactory.getExchange(address(token)));\n            uniswapExchanges[token] = exchange;\n\n            // grant allowance to uniswap exchange\n            approve(token, address(exchange), uint(-1));\n        }\n    }\n}\n\n\n// Interfaces:\n\n\n\n\ninterface IMooniswapRegistry {\n    function pools(Token token1, Token token2) external view returns(IMooniswap);\n    function isPool(address addr) external view returns(bool);\n}\n\n\ninterface IMooniswap {\n    function fee() external view returns (uint256);\n\n    function tokens(uint256 i) external view returns (Token);\n\n    function deposit(uint256[] calldata amounts, uint256[] calldata minAmounts) external payable returns(uint256 fairSupply);\n\n    function withdraw(uint256 amount, uint256[] calldata minReturns) external;\n\n    function getBalanceForAddition(Token token) external view returns(uint256);\n\n    function getBalanceForRemoval(Token token) external view returns(uint256);\n\n    function getReturn(\n        Token fromToken,\n        Token destToken,\n        uint256 amount\n    )\n        external\n        view\n        returns(uint256 returnAmount);\n\n    function swap(\n        Token fromToken,\n        Token destToken,\n        uint256 amount,\n        uint256 minReturn,\n        address referral\n    )\n        external\n        payable\n        returns(uint256 returnAmount);\n}\n\ncontract IDODO {\n    function buyBaseToken(\n        uint256 amount,\n        uint256 maxPayQuote,\n        bytes calldata data\n    ) external returns (uint256 payQuote) {}\n\n    function sellBaseToken(\n        uint256 amount,\n        uint256 minReceiveQuote,\n        bytes calldata data\n    ) external returns (uint256 receiveQuote) {}\n    \n    function querySellBaseToken(uint256 amount) external view returns (uint256 receiveQuote) {}\n\n    function queryBuyBaseToken(uint256 amount) external view returns (uint256 payQuote) {}\n}\n\nabstract contract IFulcrumToken is Token {\n    function tokenPrice() external virtual view returns (uint256);\n\n    function loanTokenAddress() external virtual view returns (address);\n\n    function mintWithEther(address receiver) external virtual payable returns (uint256 mintAmount);\n\n    function mint(address receiver, uint256 depositAmount) external virtual returns (uint256 mintAmount);\n\n    function burnToEther(address receiver, uint256 burnAmount)\n        external virtual\n        returns (uint256 loanAmountPaid);\n\n    function burn(address receiver, uint256 burnAmount) external virtual returns (uint256 loanAmountPaid);\n}\n\n\n\n\n\n\nabstract contract IMStable {\n    /**\n     * @param _input        bAsset to deposit\n     * @param _output       Asset to receive - bAsset or mAsset(this)\n     * @param _quantity     Units of input bAsset to swap\n     * @return valid        Bool to signify that swap is current valid\n     * @return reason       If swap is invalid, this is the reason\n     * @return output       Units of _output asset the trade would return\n     */\n    function getSwapOutput(\n        address _input,\n        address _output,\n        uint256 _quantity\n    )\n        external\n        view\n        virtual\n        returns (bool, string memory, uint256 output);\n        \n    /**\n     * @param _input        bAsset to deposit\n     * @param _output       Asset to receive - either a bAsset or mAsset(this)\n     * @param _quantity     Units of input bAsset to swap\n     * @param _recipient    Address to credit output asset\n     * @return output       Units of output asset returned\n     */\n    function swap(\n        address _input,\n        address _output,\n        uint256 _quantity,\n        address _recipient\n    )\n        external\n        virtual\n        returns (uint256 output);\n        \n        \n    function redeem(\n        address _bAsset,\n        uint256 _bAssetQuantity\n    )\n        external\n        virtual\n        returns (uint256 massetRedeemed);\n        \n    \n    function redeemTo(\n        address _bAsset,\n        uint256 _bAssetQuantity,\n        address _recipient\n    )\n        external\n        virtual\n        returns (uint256 massetRedeemed);\n        \n        \n    \n    function mint(\n        address _bAsset,\n        uint256 _bAssetQuantity\n    )\n        external\n        virtual\n        returns (uint256 massetMinted);\n        \n    \n    function mintTo(\n        address _bAsset,\n        uint256 _bAssetQuantity,\n        address _recipient\n    )\n        external\n        virtual\n        returns (uint256 massetMinted);\n        \n        \n        \n}\n\nabstract contract  IMStableHelper{\n        function getRedeemValidity(\n        address _mAsset,\n        uint256 _mAssetQuantity,\n        address _outputBasset\n    )\n        public\n        view virtual\n        returns (\n            bool,\n            string memory,\n            uint256 output,\n            uint256 bassetQuantityArg\n        );\n}\n\n\n\n\n\n\n\nabstract contract ICompoundRegistry {\n    function tokenByCToken(Token cToken) virtual external view returns(address);\n    function cTokenByToken(Token token) virtual external view returns(address);\n}\n\nabstract contract ICompoundEther is Token {\n    function mint() virtual external payable;\n\n    function redeem(uint256 redeemTokens) virtual external returns (uint256);\n}\n\nabstract contract ICompoundToken is Token {\n    function underlying() virtual external view returns (address);\n\n    function exchangeRateStored() virtual external view returns (uint256);\n\n    function mint(uint256 mintAmount) virtual external returns (uint256);\n\n    function redeem(uint256 redeemTokens) virtual external returns (uint256);\n}\n\n\n\n\n\n\nabstract contract IAaveToken is Token {\n    function underlyingAssetAddress() virtual external view returns (address);\n\n    function redeem(uint256 amount) virtual external;\n}\n\ninterface IAaveLendingPool {\n    function core() external view returns (address);\n\n    function deposit(Token token, uint256 amount, uint16 refCode) external payable;\n}\n\nabstract contract IAaveRegistry {\n    function tokenByAToken(Token aToken) virtual external view returns(address);\n    function aTokenByToken(Token token) virtual external view returns(address);\n}\n\n\n\n\n\n\ncontract IBancorNetworkPathFinder {\n    /**\n        * @dev generates and returns the conversion path between a given token pair in the Bancor Network\n        *\n        * @param _sourceToken address of the source token\n        * @param _targetToken address of the target token\n        *\n        * @return path from the source token to the target token\n    */\n    function generatePath(address _sourceToken, address _targetToken) public view returns (address[] memory) {\n    }\n}\n\nabstract contract IBancorNetwork {\n    function convertFor(address[] memory _path, uint256 _amount, uint256 _minReturn, address _for) public payable virtual returns (uint256);\n\n    function getReturnByPath(address[] memory _path, uint256 _amount) public view returns (uint256, uint256) {}\n\n    function convertForPrioritized3(\n        address[] memory _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        uint256 _customVal,\n        uint256 _block,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public payable virtual returns (uint256);\n\n    // deprecated, backward compatibility\n    function convertForPrioritized2(\n        address[] memory _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        uint256 _block,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public payable virtual returns (uint256);\n\n    // deprecated, backward compatibility\n    function convertForPrioritized(\n        address[] memory _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _for,\n        uint256 _block,\n        uint256 _nonce,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public payable virtual returns (uint256);\n\n\n    function claimAndConvert(address[] calldata path, uint256 amount, uint256 minReturn)\n    external virtual\n    returns (uint256);\n\n    function convert(address[] calldata path, uint256 amount, uint256 minReturn)\n    external virtual\n    payable\n    returns (uint256);\n}\n\n\n\n\n\n\n\ninterface IKyberHint {\n    enum TradeType {BestOfAll, MaskIn, MaskOut, Split}\n    enum HintErrors {\n        NoError, // Hint is valid\n        NonEmptyDataError, // reserveIDs and splits must be empty for BestOfAll hint\n        ReserveIdDupError, // duplicate reserveID found\n        ReserveIdEmptyError, // reserveIDs array is empty for MaskIn and Split trade type\n        ReserveIdSplitsError, // reserveIDs and splitBpsValues arrays do not have the same length\n        ReserveIdSequenceError, // reserveID sequence in array is not in increasing order\n        ReserveIdNotFound, // reserveID isn't registered or doesn't exist\n        SplitsNotEmptyError, // splitBpsValues is not empty for MaskIn or MaskOut trade type\n        TokenListedError, // reserveID not listed for the token\n        TotalBPSError // total BPS for Split trade type is not 10000 (100%)\n    }\n\n    function buildTokenToEthHint(\n        address tokenSrc,\n        TradeType tokenToEthType,\n        bytes32[] calldata tokenToEthReserveIds,\n        uint256[] calldata tokenToEthSplits\n    ) external view returns (bytes memory hint);\n\n    function buildEthToTokenHint(\n        address tokenDest,\n        TradeType ethToTokenType,\n        bytes32[] calldata ethToTokenReserveIds,\n        uint256[] calldata ethToTokenSplits\n    ) external view returns (bytes memory hint);\n\n    function buildTokenToTokenHint(\n        address tokenSrc,\n        TradeType tokenToEthType,\n        bytes32[] calldata tokenToEthReserveIds,\n        uint256[] calldata tokenToEthSplits,\n        address tokenDest,\n        TradeType ethToTokenType,\n        bytes32[] calldata ethToTokenReserveIds,\n        uint256[] calldata ethToTokenSplits\n    ) external view returns (bytes memory hint);\n\n    function parseTokenToEthHint(address tokenSrc, bytes calldata hint)\n        external\n        view\n        returns (\n            TradeType tokenToEthType,\n            bytes32[] memory tokenToEthReserveIds,\n            address[] memory tokenToEthAddresses,\n            uint256[] memory tokenToEthSplits\n        );\n\n    function parseEthToTokenHint(address tokenDest, bytes calldata hint)\n        external\n        view\n        returns (\n            TradeType ethToTokenType,\n            bytes32[] memory ethToTokenReserveIds,\n            address[] memory ethToTokenAddresses,\n            uint256[] memory ethToTokenSplits\n        );\n\n    function parseTokenToTokenHint(address tokenSrc, address tokenDest, bytes calldata hint)\n        external\n        view\n        returns (\n            TradeType tokenToEthType,\n            bytes32[] memory tokenToEthReserveIds,\n            address[] memory tokenToEthAddresses,\n            uint256[] memory tokenToEthSplits,\n            TradeType ethToTokenType,\n            bytes32[] memory ethToTokenReserveIds,\n            address[] memory ethToTokenAddresses,\n            uint256[] memory ethToTokenSplits\n        );\n}\n\nabstract contract IKyberNetworkProxy {\n\n    /// @dev makes a trade between src and dest token and send dest tokens to msg sender\n    /// @param src Src token\n    /// @param srcAmount amount of src tokens\n    /// @param dest Destination token\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\n    /// @return amount of actual dest tokens\n    function swapTokenToToken(\n        address src,\n        uint srcAmount,\n        address dest,\n        uint minConversionRate\n    )\n    public\n    returns (uint)\n    {}\n\n    /// @dev makes a trade from Ether to token. Sends token to msg sender\n    /// @param token Destination token\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\n    /// @return amount of actual dest tokens\n    function swapEtherToToken(address token, uint minConversionRate) public payable returns (uint) {}\n    /// @dev makes a trade from token to Ether, sends Ether to msg sender\n    /// @param token Src token\n    /// @param srcAmount amount of src tokens\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\n    /// @return amount of actual dest tokens\n    function swapTokenToEther(address token, uint srcAmount, uint minConversionRate) public returns (uint) {}\n\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\n    /// @param src Src token\n    /// @param srcAmount amount of src tokens\n    /// @param dest Destination token\n    /// @param destAddress Address to send tokens to\n    /// @param maxDestAmount A limit on the amount of dest tokens\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\n    /// @param walletId is the wallet ID to send part of the fees\n    /// @param hint will give hints for the trade.\n    /// @return amount of actual dest tokens\n    function tradeWithHint(\n        address src,\n        uint srcAmount,\n        address dest,\n        address destAddress,\n        uint maxDestAmount,\n        uint minConversionRate,\n        address walletId,\n        bytes memory hint\n    )\n    public\n    payable\n    returns (uint)\n    {}\n\n\n    function getExpectedRate(address src, address dest, uint srcQty) public view virtual\n    returns (uint expectedRate, uint slippageRate);\n}\n\ninterface IKyberStorage {\n    enum ReserveType {NONE, FPR, APR, BRIDGE, UTILITY, CUSTOM, ORDERBOOK, LAST}\n\n    function addKyberProxy(address kyberProxy, uint256 maxApprovedProxies)\n        external;\n\n    function removeKyberProxy(address kyberProxy) external;\n\n    function setContracts(address _kyberFeeHandler, address _kyberMatchingEngine) external;\n\n    function setKyberDaoContract(address _kyberDao) external;\n\n    function getReserveId(address reserve) external view returns (bytes32 reserveId);\n\n    function getReserveIdsFromAddresses(address[] calldata reserveAddresses)\n        external\n        view\n        returns (bytes32[] memory reserveIds);\n\n    function getReserveAddressesFromIds(bytes32[] calldata reserveIds)\n        external\n        view\n        returns (address[] memory reserveAddresses);\n\n    function getReserveIdsPerTokenSrc(address token)\n        external\n        view\n        returns (bytes32[] memory reserveIds);\n\n    function getReserveAddressesPerTokenSrc(address token, uint256 startIndex, uint256 endIndex)\n        external\n        view\n        returns (address[] memory reserveAddresses);\n\n    function getReserveIdsPerTokenDest(address token)\n        external\n        view\n        returns (bytes32[] memory reserveIds);\n\n    function getReserveAddressesByReserveId(bytes32 reserveId)\n        external\n        view\n        returns (address[] memory reserveAddresses);\n\n    function getRebateWalletsFromIds(bytes32[] calldata reserveIds)\n        external\n        view\n        returns (address[] memory rebateWallets);\n\n    function getKyberProxies() external view returns (address[] memory);\n\n    function getReserveDetailsByAddress(address reserve)\n        external\n        view\n        returns (\n            bytes32 reserveId,\n            address rebateWallet,\n            ReserveType resType,\n            bool isFeeAccountedFlag,\n            bool isEntitledRebateFlag\n        );\n\n    function getReserveDetailsById(bytes32 reserveId)\n        external\n        view\n        returns (\n            address reserveAddress,\n            address rebateWallet,\n            ReserveType resType,\n            bool isFeeAccountedFlag,\n            bool isEntitledRebateFlag\n        );\n\n    function getFeeAccountedData(bytes32[] calldata reserveIds)\n        external\n        view\n        returns (bool[] memory feeAccountedArr);\n\n    function getEntitledRebateData(bytes32[] calldata reserveIds)\n        external\n        view\n        returns (bool[] memory entitledRebateArr);\n\n    function getReservesData(bytes32[] calldata reserveIds, address src, address dest)\n        external\n        view\n        returns (\n            bool areAllReservesListed,\n            bool[] memory feeAccountedArr,\n            bool[] memory entitledRebateArr,\n            address[] memory reserveAddresses);\n\n    function isKyberProxyAdded() external view returns (bool);\n}\n\n\n\n\n\n\n\ninterface ICurveV2 {\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\n\n    function exchange(int128 i, int128 j, uint256 dx, uint256 minDy) external;\n}\n\n\n\n\ninterface ICurve {\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\n\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 minDy) external;\n}\n\n\n\ninterface  IUniswapFactory  {\n    // Create Exchange\n    function createExchange(address token) external returns (address exchange);\n    // Get Exchange and Token Info\n    function getExchange(address token) external view returns (address exchange);\n\n    function getToken(address exchange) external view returns (address token);\n\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\n    // Never use\n    function initializeFactory(address template) external;\n}\n\ninterface IUniswapExchange {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256 tokens_bought);\n\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256 tokens_bought);\n\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256 eth_sold);\n\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256 eth_sold);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256 eth_bought);\n\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256 eth_bought);\n\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256 tokens_sold);\n\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256 tokens_sold);\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256 tokens_bought);\n\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256 tokens_bought);\n\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256 tokens_sold);\n\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256 tokens_sold);\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256 tokens_bought);\n\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256 tokens_bought);\n\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256 tokens_sold);\n\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256 tokens_sold);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n    // Never use\n    function setup(address token_addr) external;\n}\n\n\n\n\ncontract IBalancerPool {\n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    )\n    public pure\n    returns (uint tokenAmountOut)\n    {}\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    )\n    external\n    returns (uint tokenAmountOut, uint spotPriceAfter)\n    {}\n\n    function getDenormalizedWeight(address token)\n    external view\n    returns (uint){}\n\n    function getBalance(address token)\n    external view\n    returns (uint)\n    {}\n\n    function getSwapFee()\n    external view\n    returns (uint)\n    {}\n}\n\n\n\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IUniswapV2Exchange {\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\nlibrary UniswapV2ExchangeLib {\n    using SafeMath for uint256;\n\n    function getReturn(\n        IUniswapV2Exchange exchange,\n        address fromToken,\n        address toToken,\n        uint amountIn\n    ) internal view returns (uint256) {\n        uint256 reserveIn = Token(fromToken).balanceOf(address(exchange));\n        uint256 reserveOut = Token(toToken).balanceOf(address(exchange));\n\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        return (denominator == 0) ? 0 : numerator.div(denominator);\n    }\n}\n\n\n\n\n\n\ncontract IMatchingMarket {\n    function sellAllAmount(address pay_gem, uint pay_amt, address buy_gem, uint min_fill_amount) public returns (uint fill_amt){}\n\n    function buyAllAmount(address buy_gem, uint buy_amt, address pay_gem, uint max_fill_amount) public returns (uint fill_amt){}\n\n    function getBuyAmount(address buy_gem, address pay_gem, uint pay_amt) public view returns (uint fill_amt) {}\n\n    function getPayAmount(address pay_gem, address buy_gem, uint buy_amt) public view returns (uint fill_amt) {}\n}\n\n\n\n\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// 0x\n\ncontract IZeroExV2{\n    \n    \n    struct Order {\n        address makerAddress;           // Address that created the order.      \n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          \n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      \n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        \n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        \n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          \n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     \n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n    }\n    \n    struct FillResults {\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\n        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\n    }\n    \n    function fillOrKillOrder(\n        Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public virtual\n        returns (FillResults memory fillResults){}\n}\n\n\n\n\n\n\nabstract contract IV3Exchange {\n\n    // Fill event is emitted whenever an order is filled.\n    event Fill(\n        address indexed makerAddress, // Address that created the order.\n        address indexed feeRecipientAddress, // Address that received fees.\n        bytes makerAssetData, // Encoded data specific to makerAsset.\n        bytes takerAssetData, // Encoded data specific to takerAsset.\n        bytes makerFeeAssetData, // Encoded data specific to makerFeeAsset.\n        bytes takerFeeAssetData, // Encoded data specific to takerFeeAsset.\n        bytes32 indexed orderHash, // EIP712 hash of order (see LibOrder.getTypedDataHash).\n        address takerAddress, // Address that filled the order.\n        address senderAddress, // Address that called the Exchange contract (msg.sender).\n        uint256 makerAssetFilledAmount, // Amount of makerAsset sold by maker and bought by taker.\n        uint256 takerAssetFilledAmount, // Amount of takerAsset sold by taker and bought by maker.\n        uint256 makerFeePaid, // Amount of makerFeeAssetData paid to feeRecipient by maker.\n        uint256 takerFeePaid, // Amount of takerFeeAssetData paid to feeRecipient by taker.\n        uint256 protocolFeePaid               // Amount of eth or weth paid to the staking contract.\n    );\n\n    // Cancel event is emitted whenever an individual order is cancelled.\n    event Cancel(\n        address indexed makerAddress, // Address that created the order.\n        address indexed feeRecipientAddress, // Address that would have recieved fees if order was filled.\n        bytes makerAssetData, // Encoded data specific to makerAsset.\n        bytes takerAssetData, // Encoded data specific to takerAsset.\n        address senderAddress, // Address that called the Exchange contract (msg.sender).\n        bytes32 indexed orderHash             // EIP712 hash of order (see LibOrder.getTypedDataHash).\n    );\n\n    // CancelUpTo event is emitted whenever `cancelOrdersUpTo` is executed succesfully.\n    event CancelUpTo(\n        address indexed makerAddress, // Orders cancelled must have been created by this address.\n        address indexed orderSenderAddress, // Orders cancelled must have a `senderAddress` equal to this address.\n        uint256 orderEpoch                    // Orders with specified makerAddress and senderAddress with a salt less than this value are considered cancelled.\n    );\n\n    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\n    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\n    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\n    external virtual\n    payable;\n\n    /// @dev Fills the input order.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    function fillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n    external virtual\n    payable\n    returns (LibFillResults.FillResults memory fillResults);\n\n    /// @dev After calling, the order can not be filled anymore.\n    /// @param order Order struct containing order specifications.\n    function cancelOrder(LibOrder.Order memory order)\n    external virtual\n    payable;\n\n    /// @dev Gets information about an order: status, hash, and amount filled.\n    /// @param order Order to gather information on.\n    function getOrderInfo(LibOrder.Order memory order)\n    external virtual\n    view\n    returns (LibOrder.OrderInfo memory orderInfo);\n}\n\n\nlibrary LibFillResults {\n\n    using LibSafeMath for uint256;\n\n    struct BatchMatchedFillResults {\n        FillResults[] left;              // Fill results for left orders\n        FillResults[] right;             // Fill results for right orders\n        uint256 profitInLeftMakerAsset;  // Profit taken from left makers\n        uint256 profitInRightMakerAsset; // Profit taken from right makers\n    }\n\n    struct FillResults {\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n        uint256 makerFeePaid;            // Total amount of fees paid by maker(s) to feeRecipient(s).\n        uint256 takerFeePaid;            // Total amount of fees paid by taker to feeRecipients(s).\n        uint256 protocolFeePaid;         // Total amount of fees paid by taker to the staking contract.\n    }\n\n    struct MatchedFillResults {\n        FillResults left;                // Amounts filled and fees paid of left order.\n        FillResults right;               // Amounts filled and fees paid of right order.\n        uint256 profitInLeftMakerAsset;  // Profit taken from the left maker\n        uint256 profitInRightMakerAsset; // Profit taken from the right maker\n    }\n\n    /// @dev Calculates amounts filled and fees paid by maker and taker.\n    /// @param order to be filled.\n    /// @param takerAssetFilledAmount Amount of takerAsset that will be filled.\n    /// @param protocolFeeMultiplier The current protocol fee of the exchange contract.\n    /// @param gasPrice The gasprice of the transaction. This is provided so that the function call can continue\n    ///        to be pure rather than view.\n    /// @return fillResults Amounts filled and fees paid by maker and taker.\n    function calculateFillResults(\n        LibOrder.Order memory order,\n        uint256 takerAssetFilledAmount,\n        uint256 protocolFeeMultiplier,\n        uint256 gasPrice\n    )\n    internal\n    pure\n    returns (FillResults memory fillResults)\n    {\n        // Compute proportional transfer amounts\n        fillResults.takerAssetFilledAmount = takerAssetFilledAmount;\n        fillResults.makerAssetFilledAmount = LibMath.safeGetPartialAmountFloor(\n            takerAssetFilledAmount,\n            order.takerAssetAmount,\n            order.makerAssetAmount\n        );\n        fillResults.makerFeePaid = LibMath.safeGetPartialAmountFloor(\n            takerAssetFilledAmount,\n            order.takerAssetAmount,\n            order.makerFee\n        );\n        fillResults.takerFeePaid = LibMath.safeGetPartialAmountFloor(\n            takerAssetFilledAmount,\n            order.takerAssetAmount,\n            order.takerFee\n        );\n\n        // Compute the protocol fee that should be paid for a single fill.\n        fillResults.protocolFeePaid = gasPrice.safeMul(protocolFeeMultiplier);\n\n        return fillResults;\n    }\n\n    /// @dev Calculates fill amounts for the matched orders.\n    ///      Each order is filled at their respective price point. However, the calculations are\n    ///      carried out as though the orders are both being filled at the right order's price point.\n    ///      The profit made by the leftOrder order goes to the taker (who matched the two orders).\n    /// @param leftOrder First order to match.\n    /// @param rightOrder Second order to match.\n    /// @param leftOrderTakerAssetFilledAmount Amount of left order already filled.\n    /// @param rightOrderTakerAssetFilledAmount Amount of right order already filled.\n    /// @param protocolFeeMultiplier The current protocol fee of the exchange contract.\n    /// @param gasPrice The gasprice of the transaction. This is provided so that the function call can continue\n    ///        to be pure rather than view.\n    /// @param shouldMaximallyFillOrders A value that indicates whether or not this calculation should use\n    ///                                  the maximal fill order matching strategy.\n    /// @param matchedFillResults Amounts to fill and fees to pay by maker and taker of matched orders.\n    function calculateMatchedFillResults(\n        LibOrder.Order memory leftOrder,\n        LibOrder.Order memory rightOrder,\n        uint256 leftOrderTakerAssetFilledAmount,\n        uint256 rightOrderTakerAssetFilledAmount,\n        uint256 protocolFeeMultiplier,\n        uint256 gasPrice,\n        bool shouldMaximallyFillOrders\n    )\n    internal\n    pure\n    returns (MatchedFillResults memory matchedFillResults)\n    {\n        // Derive maker asset amounts for left & right orders, given store taker assert amounts\n        uint256 leftTakerAssetAmountRemaining = leftOrder.takerAssetAmount.safeSub(leftOrderTakerAssetFilledAmount);\n        uint256 leftMakerAssetAmountRemaining = LibMath.safeGetPartialAmountFloor(\n            leftOrder.makerAssetAmount,\n            leftOrder.takerAssetAmount,\n            leftTakerAssetAmountRemaining\n        );\n        uint256 rightTakerAssetAmountRemaining = rightOrder.takerAssetAmount.safeSub(rightOrderTakerAssetFilledAmount);\n        uint256 rightMakerAssetAmountRemaining = LibMath.safeGetPartialAmountFloor(\n            rightOrder.makerAssetAmount,\n            rightOrder.takerAssetAmount,\n            rightTakerAssetAmountRemaining\n        );\n\n        // Maximally fill the orders and pay out profits to the matcher in one or both of the maker assets.\n        if (shouldMaximallyFillOrders) {\n            matchedFillResults = _calculateMatchedFillResultsWithMaximalFill(\n                leftOrder,\n                rightOrder,\n                leftMakerAssetAmountRemaining,\n                leftTakerAssetAmountRemaining,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        } else {\n            matchedFillResults = _calculateMatchedFillResults(\n                leftOrder,\n                rightOrder,\n                leftMakerAssetAmountRemaining,\n                leftTakerAssetAmountRemaining,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        }\n\n        // Compute fees for left order\n        matchedFillResults.left.makerFeePaid = LibMath.safeGetPartialAmountFloor(\n            matchedFillResults.left.makerAssetFilledAmount,\n            leftOrder.makerAssetAmount,\n            leftOrder.makerFee\n        );\n        matchedFillResults.left.takerFeePaid = LibMath.safeGetPartialAmountFloor(\n            matchedFillResults.left.takerAssetFilledAmount,\n            leftOrder.takerAssetAmount,\n            leftOrder.takerFee\n        );\n\n        // Compute fees for right order\n        matchedFillResults.right.makerFeePaid = LibMath.safeGetPartialAmountFloor(\n            matchedFillResults.right.makerAssetFilledAmount,\n            rightOrder.makerAssetAmount,\n            rightOrder.makerFee\n        );\n        matchedFillResults.right.takerFeePaid = LibMath.safeGetPartialAmountFloor(\n            matchedFillResults.right.takerAssetFilledAmount,\n            rightOrder.takerAssetAmount,\n            rightOrder.takerFee\n        );\n\n        // Compute the protocol fee that should be paid for a single fill. In this\n        // case this should be made the protocol fee for both the left and right orders.\n        uint256 protocolFee = gasPrice.safeMul(protocolFeeMultiplier);\n        matchedFillResults.left.protocolFeePaid = protocolFee;\n        matchedFillResults.right.protocolFeePaid = protocolFee;\n\n        // Return fill results\n        return matchedFillResults;\n    }\n\n    /// @dev Adds properties of both FillResults instances.\n    /// @param fillResults1 The first FillResults.\n    /// @param fillResults2 The second FillResults.\n    function addFillResults(\n        FillResults memory fillResults1,\n        FillResults memory fillResults2\n    )\n    internal\n    pure\n    returns (FillResults memory totalFillResults)\n    {\n        totalFillResults.makerAssetFilledAmount = fillResults1.makerAssetFilledAmount.safeAdd(fillResults2.makerAssetFilledAmount);\n        totalFillResults.takerAssetFilledAmount = fillResults1.takerAssetFilledAmount.safeAdd(fillResults2.takerAssetFilledAmount);\n        totalFillResults.makerFeePaid = fillResults1.makerFeePaid.safeAdd(fillResults2.makerFeePaid);\n        totalFillResults.takerFeePaid = fillResults1.takerFeePaid.safeAdd(fillResults2.takerFeePaid);\n        totalFillResults.protocolFeePaid = fillResults1.protocolFeePaid.safeAdd(fillResults2.protocolFeePaid);\n\n        return totalFillResults;\n    }\n\n    /// @dev Calculates part of the matched fill results for a given situation using the fill strategy that only\n    ///      awards profit denominated in the left maker asset.\n    /// @param leftOrder The left order in the order matching situation.\n    /// @param rightOrder The right order in the order matching situation.\n    /// @param leftMakerAssetAmountRemaining The amount of the left order maker asset that can still be filled.\n    /// @param leftTakerAssetAmountRemaining The amount of the left order taker asset that can still be filled.\n    /// @param rightMakerAssetAmountRemaining The amount of the right order maker asset that can still be filled.\n    /// @param rightTakerAssetAmountRemaining The amount of the right order taker asset that can still be filled.\n    function _calculateMatchedFillResults(\n        LibOrder.Order memory leftOrder,\n        LibOrder.Order memory rightOrder,\n        uint256 leftMakerAssetAmountRemaining,\n        uint256 leftTakerAssetAmountRemaining,\n        uint256 rightMakerAssetAmountRemaining,\n        uint256 rightTakerAssetAmountRemaining\n    )\n    private\n    pure\n    returns (MatchedFillResults memory matchedFillResults)\n    {\n        // Calculate fill results for maker and taker assets: at least one order will be fully filled.\n        // The maximum amount the left maker can buy is `leftTakerAssetAmountRemaining`\n        // The maximum amount the right maker can sell is `rightMakerAssetAmountRemaining`\n        // We have two distinct cases for calculating the fill results:\n        // Case 1.\n        //   If the left maker can buy more than the right maker can sell, then only the right order is fully filled.\n        //   If the left maker can buy exactly what the right maker can sell, then both orders are fully filled.\n        // Case 2.\n        //   If the left maker cannot buy more than the right maker can sell, then only the left order is fully filled.\n        // Case 3.\n        //   If the left maker can buy exactly as much as the right maker can sell, then both orders are fully filled.\n        if (leftTakerAssetAmountRemaining > rightMakerAssetAmountRemaining) {\n            // Case 1: Right order is fully filled\n            matchedFillResults = _calculateCompleteRightFill(\n                leftOrder,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        } else if (leftTakerAssetAmountRemaining < rightMakerAssetAmountRemaining) {\n            // Case 2: Left order is fully filled\n            matchedFillResults.left.makerAssetFilledAmount = leftMakerAssetAmountRemaining;\n            matchedFillResults.left.takerAssetFilledAmount = leftTakerAssetAmountRemaining;\n            matchedFillResults.right.makerAssetFilledAmount = leftTakerAssetAmountRemaining;\n            // Round up to ensure the maker's exchange rate does not exceed the price specified by the order.\n            // We favor the maker when the exchange rate must be rounded.\n            matchedFillResults.right.takerAssetFilledAmount = LibMath.safeGetPartialAmountCeil(\n                rightOrder.takerAssetAmount,\n                rightOrder.makerAssetAmount,\n                leftTakerAssetAmountRemaining // matchedFillResults.right.makerAssetFilledAmount\n            );\n        } else {\n            // leftTakerAssetAmountRemaining == rightMakerAssetAmountRemaining\n            // Case 3: Both orders are fully filled. Technically, this could be captured by the above cases, but\n            //         this calculation will be more precise since it does not include rounding.\n            matchedFillResults = _calculateCompleteFillBoth(\n                leftMakerAssetAmountRemaining,\n                leftTakerAssetAmountRemaining,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        }\n\n        // Calculate amount given to taker\n        matchedFillResults.profitInLeftMakerAsset = matchedFillResults.left.makerAssetFilledAmount.safeSub(\n            matchedFillResults.right.takerAssetFilledAmount\n        );\n\n        return matchedFillResults;\n    }\n\n    /// @dev Calculates part of the matched fill results for a given situation using the maximal fill order matching\n    ///      strategy.\n    /// @param leftOrder The left order in the order matching situation.\n    /// @param rightOrder The right order in the order matching situation.\n    /// @param leftMakerAssetAmountRemaining The amount of the left order maker asset that can still be filled.\n    /// @param leftTakerAssetAmountRemaining The amount of the left order taker asset that can still be filled.\n    /// @param rightMakerAssetAmountRemaining The amount of the right order maker asset that can still be filled.\n    /// @param rightTakerAssetAmountRemaining The amount of the right order taker asset that can still be filled.\n    function _calculateMatchedFillResultsWithMaximalFill(\n        LibOrder.Order memory leftOrder,\n        LibOrder.Order memory rightOrder,\n        uint256 leftMakerAssetAmountRemaining,\n        uint256 leftTakerAssetAmountRemaining,\n        uint256 rightMakerAssetAmountRemaining,\n        uint256 rightTakerAssetAmountRemaining\n    )\n    private\n    pure\n    returns (MatchedFillResults memory matchedFillResults)\n    {\n        // If a maker asset is greater than the opposite taker asset, than there will be a spread denominated in that maker asset.\n        bool doesLeftMakerAssetProfitExist = leftMakerAssetAmountRemaining > rightTakerAssetAmountRemaining;\n        bool doesRightMakerAssetProfitExist = rightMakerAssetAmountRemaining > leftTakerAssetAmountRemaining;\n\n        // Calculate the maximum fill results for the maker and taker assets. At least one of the orders will be fully filled.\n        //\n        // The maximum that the left maker can possibly buy is the amount that the right order can sell.\n        // The maximum that the right maker can possibly buy is the amount that the left order can sell.\n        //\n        // If the left order is fully filled, profit will be paid out in the left maker asset. If the right order is fully filled,\n        // the profit will be out in the right maker asset.\n        //\n        // There are three cases to consider:\n        // Case 1.\n        //   If the left maker can buy more than the right maker can sell, then only the right order is fully filled.\n        // Case 2.\n        //   If the right maker can buy more than the left maker can sell, then only the right order is fully filled.\n        // Case 3.\n        //   If the right maker can sell the max of what the left maker can buy and the left maker can sell the max of\n        //   what the right maker can buy, then both orders are fully filled.\n        if (leftTakerAssetAmountRemaining > rightMakerAssetAmountRemaining) {\n            // Case 1: Right order is fully filled with the profit paid in the left makerAsset\n            matchedFillResults = _calculateCompleteRightFill(\n                leftOrder,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        } else if (rightTakerAssetAmountRemaining > leftMakerAssetAmountRemaining) {\n            // Case 2: Left order is fully filled with the profit paid in the right makerAsset.\n            matchedFillResults.left.makerAssetFilledAmount = leftMakerAssetAmountRemaining;\n            matchedFillResults.left.takerAssetFilledAmount = leftTakerAssetAmountRemaining;\n            // Round down to ensure the right maker's exchange rate does not exceed the price specified by the order.\n            // We favor the right maker when the exchange rate must be rounded and the profit is being paid in the\n            // right maker asset.\n            matchedFillResults.right.makerAssetFilledAmount = LibMath.safeGetPartialAmountFloor(\n                rightOrder.makerAssetAmount,\n                rightOrder.takerAssetAmount,\n                leftMakerAssetAmountRemaining\n            );\n            matchedFillResults.right.takerAssetFilledAmount = leftMakerAssetAmountRemaining;\n        } else {\n            // Case 3: The right and left orders are fully filled\n            matchedFillResults = _calculateCompleteFillBoth(\n                leftMakerAssetAmountRemaining,\n                leftTakerAssetAmountRemaining,\n                rightMakerAssetAmountRemaining,\n                rightTakerAssetAmountRemaining\n            );\n        }\n\n        // Calculate amount given to taker in the left order's maker asset if the left spread will be part of the profit.\n        if (doesLeftMakerAssetProfitExist) {\n            matchedFillResults.profitInLeftMakerAsset = matchedFillResults.left.makerAssetFilledAmount.safeSub(\n                matchedFillResults.right.takerAssetFilledAmount\n            );\n        }\n\n        // Calculate amount given to taker in the right order's maker asset if the right spread will be part of the profit.\n        if (doesRightMakerAssetProfitExist) {\n            matchedFillResults.profitInRightMakerAsset = matchedFillResults.right.makerAssetFilledAmount.safeSub(\n                matchedFillResults.left.takerAssetFilledAmount\n            );\n        }\n\n        return matchedFillResults;\n    }\n\n    /// @dev Calculates the fill results for the maker and taker in the order matching and writes the results\n    ///      to the fillResults that are being collected on the order. Both orders will be fully filled in this\n    ///      case.\n    /// @param leftMakerAssetAmountRemaining The amount of the left maker asset that is remaining to be filled.\n    /// @param leftTakerAssetAmountRemaining The amount of the left taker asset that is remaining to be filled.\n    /// @param rightMakerAssetAmountRemaining The amount of the right maker asset that is remaining to be filled.\n    /// @param rightTakerAssetAmountRemaining The amount of the right taker asset that is remaining to be filled.\n    function _calculateCompleteFillBoth(\n        uint256 leftMakerAssetAmountRemaining,\n        uint256 leftTakerAssetAmountRemaining,\n        uint256 rightMakerAssetAmountRemaining,\n        uint256 rightTakerAssetAmountRemaining\n    )\n    private\n    pure\n    returns (MatchedFillResults memory matchedFillResults)\n    {\n        // Calculate the fully filled results for both orders.\n        matchedFillResults.left.makerAssetFilledAmount = leftMakerAssetAmountRemaining;\n        matchedFillResults.left.takerAssetFilledAmount = leftTakerAssetAmountRemaining;\n        matchedFillResults.right.makerAssetFilledAmount = rightMakerAssetAmountRemaining;\n        matchedFillResults.right.takerAssetFilledAmount = rightTakerAssetAmountRemaining;\n\n        return matchedFillResults;\n    }\n\n    /// @dev Calculates the fill results for the maker and taker in the order matching and writes the results\n    ///      to the fillResults that are being collected on the order.\n    /// @param leftOrder The left order that is being maximally filled. All of the information about fill amounts\n    ///                  can be derived from this order and the right asset remaining fields.\n    /// @param rightMakerAssetAmountRemaining The amount of the right maker asset that is remaining to be filled.\n    /// @param rightTakerAssetAmountRemaining The amount of the right taker asset that is remaining to be filled.\n    function _calculateCompleteRightFill(\n        LibOrder.Order memory leftOrder,\n        uint256 rightMakerAssetAmountRemaining,\n        uint256 rightTakerAssetAmountRemaining\n    )\n    private\n    pure\n    returns (MatchedFillResults memory matchedFillResults)\n    {\n        matchedFillResults.right.makerAssetFilledAmount = rightMakerAssetAmountRemaining;\n        matchedFillResults.right.takerAssetFilledAmount = rightTakerAssetAmountRemaining;\n        matchedFillResults.left.takerAssetFilledAmount = rightMakerAssetAmountRemaining;\n        // Round down to ensure the left maker's exchange rate does not exceed the price specified by the order.\n        // We favor the left maker when the exchange rate must be rounded and the profit is being paid in the\n        // left maker asset.\n        matchedFillResults.left.makerAssetFilledAmount = LibMath.safeGetPartialAmountFloor(\n            leftOrder.makerAssetAmount,\n            leftOrder.takerAssetAmount,\n            rightMakerAssetAmountRemaining\n        );\n\n        return matchedFillResults;\n    }\n}\n\nlibrary LibOrder {\n\n    using LibOrder for Order;\n\n    // Hash for the EIP712 Order Schema:\n    // keccak256(abi.encodePacked(\n    //     \"Order(\",\n    //     \"address makerAddress,\",\n    //     \"address takerAddress,\",\n    //     \"address feeRecipientAddress,\",\n    //     \"address senderAddress,\",\n    //     \"uint256 makerAssetAmount,\",\n    //     \"uint256 takerAssetAmount,\",\n    //     \"uint256 makerFee,\",\n    //     \"uint256 takerFee,\",\n    //     \"uint256 expirationTimeSeconds,\",\n    //     \"uint256 salt,\",\n    //     \"bytes makerAssetData,\",\n    //     \"bytes takerAssetData,\",\n    //     \"bytes makerFeeAssetData,\",\n    //     \"bytes takerFeeAssetData\",\n    //     \")\"\n    // ))\n    bytes32 constant internal _EIP712_ORDER_SCHEMA_HASH =\n    0xf80322eb8376aafb64eadf8f0d7623f22130fd9491a221e902b713cb984a7534;\n\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n    // An order's status is unaffected by external factors, like account balances.\n    enum OrderStatus {\n        INVALID, // Default value\n        INVALID_MAKER_ASSET_AMOUNT, // Order does not have a valid maker asset amount\n        INVALID_TAKER_ASSET_AMOUNT, // Order does not have a valid taker asset amount\n        FILLABLE, // Order is fillable\n        EXPIRED, // Order has already expired\n        FULLY_FILLED, // Order is fully filled\n        CANCELLED                    // Order has been cancelled\n    }\n\n    // solhint-disable max-line-length\n    /// @dev Canonical order structure.\n    struct Order {\n        address makerAddress;           // Address that created the order.\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n        uint256 makerFee;               // Fee paid to feeRecipient by maker when order is filled.\n        uint256 takerFee;               // Fee paid to feeRecipient by taker when order is filled.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The leading bytes4 references the id of the asset proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The leading bytes4 references the id of the asset proxy.\n        bytes makerFeeAssetData;        // Encoded data that can be decoded by a specified proxy contract when transferring makerFeeAsset. The leading bytes4 references the id of the asset proxy.\n        bytes takerFeeAssetData;        // Encoded data that can be decoded by a specified proxy contract when transferring takerFeeAsset. The leading bytes4 references the id of the asset proxy.\n    }\n    // solhint-enable max-line-length\n\n    /// @dev Order information returned by `getOrderInfo()`.\n    struct OrderInfo {\n        OrderStatus orderStatus;                    // Status that describes order's validity and fillability.\n        bytes32 orderHash;                    // EIP712 typed data hash of the order (see LibOrder.getTypedDataHash).\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n    }\n\n\n\n    /// @dev Calculates EIP712 hash of the order struct.\n    /// @param order The order structure.\n    function getStructHash(Order memory order)\n    internal\n    pure\n    returns (bytes32 result)\n    {\n        bytes32 schemaHash = _EIP712_ORDER_SCHEMA_HASH;\n        bytes memory makerAssetData = order.makerAssetData;\n        bytes memory takerAssetData = order.takerAssetData;\n        bytes memory makerFeeAssetData = order.makerFeeAssetData;\n        bytes memory takerFeeAssetData = order.takerFeeAssetData;\n\n        // Assembly for more efficiently computing:\n        // keccak256(abi.encodePacked(\n        //     EIP712_ORDER_SCHEMA_HASH,\n        //     uint256(order.makerAddress),\n        //     uint256(order.takerAddress),\n        //     uint256(order.feeRecipientAddress),\n        //     uint256(order.senderAddress),\n        //     order.makerAssetAmount,\n        //     order.takerAssetAmount,\n        //     order.makerFee,\n        //     order.takerFee,\n        //     order.expirationTimeSeconds,\n        //     order.salt,\n        //     keccak256(order.makerAssetData),\n        //     keccak256(order.takerAssetData),\n        //     keccak256(order.makerFeeAssetData),\n        //     keccak256(order.takerFeeAssetData)\n        // ));\n\n        assembly {\n        // Assert order offset (this is an internal error that should never be triggered)\n            if lt(order, 32) {\n                invalid()\n            }\n\n        // Calculate memory addresses that will be swapped out before hashing\n            let pos1 := sub(order, 32)\n            let pos2 := add(order, 320)\n            let pos3 := add(order, 352)\n            let pos4 := add(order, 384)\n            let pos5 := add(order, 416)\n\n        // Backup\n            let temp1 := mload(pos1)\n            let temp2 := mload(pos2)\n            let temp3 := mload(pos3)\n            let temp4 := mload(pos4)\n            let temp5 := mload(pos5)\n\n        // Hash in place\n            mstore(pos1, schemaHash)\n            mstore(pos2, keccak256(add(makerAssetData, 32), mload(makerAssetData)))        // store hash of makerAssetData\n            mstore(pos3, keccak256(add(takerAssetData, 32), mload(takerAssetData)))        // store hash of takerAssetData\n            mstore(pos4, keccak256(add(makerFeeAssetData, 32), mload(makerFeeAssetData)))  // store hash of makerFeeAssetData\n            mstore(pos5, keccak256(add(takerFeeAssetData, 32), mload(takerFeeAssetData)))  // store hash of takerFeeAssetData\n            result := keccak256(pos1, 480)\n\n        // Restore\n            mstore(pos1, temp1)\n            mstore(pos2, temp2)\n            mstore(pos3, temp3)\n            mstore(pos4, temp4)\n            mstore(pos5, temp5)\n        }\n        return result;\n    }\n}\n\n\nlibrary LibSafeMath {\n\n    function safeMul(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        if (c / a != b) {\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n                    LibSafeMathRichErrors.BinOpErrorCodes.MULTIPLICATION_OVERFLOW,\n                    a,\n                    b\n                ));\n        }\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        if (b == 0) {\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n                    LibSafeMathRichErrors.BinOpErrorCodes.DIVISION_BY_ZERO,\n                    a,\n                    b\n                ));\n        }\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        if (b > a) {\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n                    LibSafeMathRichErrors.BinOpErrorCodes.SUBTRACTION_UNDERFLOW,\n                    a,\n                    b\n                ));\n        }\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 c = a + b;\n        if (c < a) {\n            LibRichErrors.rrevert(LibSafeMathRichErrors.Uint256BinOpError(\n                    LibSafeMathRichErrors.BinOpErrorCodes.ADDITION_OVERFLOW,\n                    a,\n                    b\n                ));\n        }\n        return c;\n    }\n\n    function max256(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n}\n\n\nlibrary LibMath {\n\n    using LibSafeMath for uint256;\n\n    /// @dev Calculates partial value given a numerator and denominator rounded down.\n    ///      Reverts if rounding error is >= 0.1%\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to calculate partial of.\n    function safeGetPartialAmountFloor(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n    internal\n    pure\n    returns (uint256 partialAmount)\n    {\n        if (isRoundingErrorFloor(\n                numerator,\n                denominator,\n                target\n            )) {\n            LibRichErrors.rrevert(LibMathRichErrors.RoundingError(\n                    numerator,\n                    denominator,\n                    target\n                ));\n        }\n\n        partialAmount = numerator.safeMul(target).safeDiv(denominator);\n        return partialAmount;\n    }\n\n    /// @dev Calculates partial value given a numerator and denominator rounded down.\n    ///      Reverts if rounding error is >= 0.1%\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to calculate partial of.\n    function safeGetPartialAmountCeil(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n    internal\n    pure\n    returns (uint256 partialAmount)\n    {\n        if (isRoundingErrorCeil(\n                numerator,\n                denominator,\n                target\n            )) {\n            LibRichErrors.rrevert(LibMathRichErrors.RoundingError(\n                    numerator,\n                    denominator,\n                    target\n                ));\n        }\n\n        // safeDiv computes `floor(a / b)`. We use the identity (a, b integer):\n        //       ceil(a / b) = floor((a + b - 1) / b)\n        // To implement `ceil(a / b)` using safeDiv.\n        partialAmount = numerator.safeMul(target)\n        .safeAdd(denominator.safeSub(1))\n        .safeDiv(denominator);\n\n        return partialAmount;\n    }\n\n    /// @dev Calculates partial value given a numerator and denominator rounded down.\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to calculate partial of.\n    function getPartialAmountFloor(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n    internal\n    pure\n    returns (uint256 partialAmount)\n    {\n        partialAmount = numerator.safeMul(target).safeDiv(denominator);\n        return partialAmount;\n    }\n\n    /// @dev Calculates partial value given a numerator and denominator rounded down.\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to calculate partial of.\n    function getPartialAmountCeil(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n    internal\n    pure\n    returns (uint256 partialAmount)\n    {\n        // safeDiv computes `floor(a / b)`. We use the identity (a, b integer):\n        //       ceil(a / b) = floor((a + b - 1) / b)\n        // To implement `ceil(a / b)` using safeDiv.\n        partialAmount = numerator.safeMul(target)\n        .safeAdd(denominator.safeSub(1))\n        .safeDiv(denominator);\n\n        return partialAmount;\n    }\n\n    /// @dev Checks if rounding error >= 0.1% when rounding down.\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to multiply with numerator/denominator.\n    function isRoundingErrorFloor(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n    internal\n    pure\n    returns (bool isError)\n    {\n        if (denominator == 0) {\n            LibRichErrors.rrevert(LibMathRichErrors.DivisionByZeroError());\n        }\n\n        // The absolute rounding error is the difference between the rounded\n        // value and the ideal value. The relative rounding error is the\n        // absolute rounding error divided by the absolute value of the\n        // ideal value. This is undefined when the ideal value is zero.\n        //\n        // The ideal value is `numerator * target / denominator`.\n        // Let's call `numerator * target % denominator` the remainder.\n        // The absolute error is `remainder / denominator`.\n        //\n        // When the ideal value is zero, we require the absolute error to\n        // be zero. Fortunately, this is always the case. The ideal value is\n        // zero iff `numerator == 0` and/or `target == 0`. In this case the\n        // remainder and absolute error are also zero.\n        if (target == 0 || numerator == 0) {\n            return false;\n        }\n\n        // Otherwise, we want the relative rounding error to be strictly\n        // less than 0.1%.\n        // The relative error is `remainder / (numerator * target)`.\n        // We want the relative error less than 1 / 1000:\n        //        remainder / (numerator * denominator)  <  1 / 1000\n        // or equivalently:\n        //        1000 * remainder  <  numerator * target\n        // so we have a rounding error iff:\n        //        1000 * remainder  >=  numerator * target\n        uint256 remainder = mulmod(\n            target,\n            numerator,\n            denominator\n        );\n        isError = remainder.safeMul(1000) >= numerator.safeMul(target);\n        return isError;\n    }\n\n    /// @dev Checks if rounding error >= 0.1% when rounding up.\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to multiply with numerator/denominator.\n    function isRoundingErrorCeil(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n    internal\n    pure\n    returns (bool isError)\n    {\n        if (denominator == 0) {\n            LibRichErrors.rrevert(LibMathRichErrors.DivisionByZeroError());\n        }\n\n        // See the comments in `isRoundingError`.\n        if (target == 0 || numerator == 0) {\n            // When either is zero, the ideal value and rounded value are zero\n            // and there is no rounding error. (Although the relative error\n            // is undefined.)\n            return false;\n        }\n        // Compute remainder as before\n        uint256 remainder = mulmod(\n            target,\n            numerator,\n            denominator\n        );\n        remainder = denominator.safeSub(remainder) % denominator;\n        isError = remainder.safeMul(1000) >= numerator.safeMul(target);\n        return isError;\n    }\n}\n\n\nlibrary LibRichErrors {\n\n    // bytes4(keccak256(\"Error(string)\"))\n    bytes4 internal constant STANDARD_ERROR_SELECTOR =\n    0x08c379a0;\n\n    // solhint-disable func-name-mixedcase\n    /// @dev ABI encode a standard, string revert error payload.\n    ///      This is the same payload that would be included by a `revert(string)`\n    ///      solidity statement. It has the function signature `Error(string)`.\n    /// @param message The error string.\n    /// @return The ABI encoded error.\n    function StandardError(\n        string memory message\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            STANDARD_ERROR_SELECTOR,\n            bytes(message)\n        );\n    }\n    // solhint-enable func-name-mixedcase\n\n    /// @dev Reverts an encoded rich revert reason `errorData`.\n    /// @param errorData ABI encoded error data.\n    function rrevert(bytes memory errorData)\n    internal\n    pure\n    {\n        assembly {\n            revert(add(errorData, 0x20), mload(errorData))\n        }\n    }\n}\n\n\nlibrary LibSafeMathRichErrors {\n\n    // bytes4(keccak256(\"Uint256BinOpError(uint8,uint256,uint256)\"))\n    bytes4 internal constant UINT256_BINOP_ERROR_SELECTOR =\n    0xe946c1bb;\n\n    // bytes4(keccak256(\"Uint256DowncastError(uint8,uint256)\"))\n    bytes4 internal constant UINT256_DOWNCAST_ERROR_SELECTOR =\n    0xc996af7b;\n\n    enum BinOpErrorCodes {\n        ADDITION_OVERFLOW,\n        MULTIPLICATION_OVERFLOW,\n        SUBTRACTION_UNDERFLOW,\n        DIVISION_BY_ZERO\n    }\n\n    enum DowncastErrorCodes {\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT32,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT64,\n        VALUE_TOO_LARGE_TO_DOWNCAST_TO_UINT96\n    }\n\n    // solhint-disable func-name-mixedcase\n    function Uint256BinOpError(\n        BinOpErrorCodes errorCode,\n        uint256 a,\n        uint256 b\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            UINT256_BINOP_ERROR_SELECTOR,\n            errorCode,\n            a,\n            b\n        );\n    }\n\n    function Uint256DowncastError(\n        DowncastErrorCodes errorCode,\n        uint256 a\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            UINT256_DOWNCAST_ERROR_SELECTOR,\n            errorCode,\n            a\n        );\n    }\n}\n\n\nlibrary LibMathRichErrors {\n\n    // bytes4(keccak256(\"DivisionByZeroError()\"))\n    bytes internal constant DIVISION_BY_ZERO_ERROR =\n    hex\"a791837c\";\n\n    // bytes4(keccak256(\"RoundingError(uint256,uint256,uint256)\"))\n    bytes4 internal constant ROUNDING_ERROR_SELECTOR =\n    0x339f3de2;\n\n    // solhint-disable func-name-mixedcase\n    function DivisionByZeroError()\n    internal\n    pure\n    returns (bytes memory)\n    {\n        return DIVISION_BY_ZERO_ERROR;\n    }\n\n    function RoundingError(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        return abi.encodeWithSelector(\n            ROUNDING_ERROR_SELECTOR,\n            numerator,\n            denominator,\n            target\n        );\n    }\n}"
    }
  }
}