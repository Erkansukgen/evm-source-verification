{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/TradeBot.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface IERC20Token {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n  function allPairs(uint) external view returns (address pair);\r\n  function allPairsLength() external view returns (uint);\r\n\r\n  function feeTo() external view returns (address);\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n    address indexed sender,\r\n    uint amount0In,\r\n    uint amount1In,\r\n    uint amount0Out,\r\n    uint amount1Out,\r\n    address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n\r\n  function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n  function WETH() external view returns (address);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint amountADesired,\r\n    uint amountBDesired,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountA, uint amountB, uint liquidity);\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint amountTokenDesired,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint liquidity,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETH(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint liquidity,\r\n    uint amountAMin,\r\n    uint amountBMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountA, uint amountB);\r\n  function removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint liquidity,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline,\r\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n  ) external returns (uint amountToken, uint amountETH);\r\n  function swapExactTokensForTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapTokensForExactTokens(\r\n    uint amountOut,\r\n    uint amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n}\r\n\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() external view returns(uint);\r\n    function getUserCapInWei(address user) external view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\r\n    function enabled() external view returns(bool);\r\n    function info(bytes32 id) external view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,\r\n        uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\r\n}\r\n\r\ninterface IBancorNetwork {\r\n    function convert2(\r\n        IERC20Token[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external payable returns (uint256);\r\n\r\n    function claimAndConvert2(\r\n        IERC20Token[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external returns (uint256);\r\n\r\n    function convertFor2(\r\n        IERC20Token[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external payable returns (uint256);\r\n\r\n    function claimAndConvertFor2(\r\n        IERC20Token[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external returns (uint256);\r\n}\r\n\r\ninterface IContractRegistry {\r\n    function addressOf(bytes32 _contractName) external view returns (address);\r\n}\r\n\r\ninterface BancorNetworkPathFinder {\r\n    function generatePath(address _sourceToken, address _targetToken) external view returns (address[] memory);\r\n}\r\n\r\ncontract TradeBot {\r\n  /*\r\n    Constants\r\n  */\r\n  address private constant  UNISWAP_ROUTER_ADDRESS  = 0xcDbE04934d89e97a24BCc07c3562DC8CF17d8167; // Rinkeby\r\n  address private constant  UNISWAP_FACTORY_ADDRESS = 0xe2f197885abe8ec7c866cFf76605FD06d4576218; // Rinkeby\r\n  address private constant  KYBER_PROXY_ADDRESS     = 0xF77eC7Ed5f5B9a5aee4cfa6FFCaC6A4C315BaC76; // Rinkeby\r\n  address private constant  BANCOR_REGISTRY_ADDRESS = 0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4; // Ropsten \r\n  address private constant  ETH_KYBER_ADDRESS       = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n  address private constant  ETH_BANCOR_ADDRESS      = 0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315; // Ropsten\r\n  bytes32 private constant  BANCOR_NETWORK          = \"BancorNetwork\";\r\n  bytes32 private constant  BANCOR_NETWORK_FINDER   = \"BancorNetworkPathFinder\";\r\n  uint    private constant  TOKEN_18_DECIMALS       = (10**18);\r\n  \r\n  /*\r\n    Members\r\n  */\r\n  address                    private immutable owner;\r\n  // IUniswapV2Factory          private immutable uniswapFactory;\r\n  // IUniswapV2Router01         private immutable uniswapRouter;\r\n  // KyberNetworkProxyInterface private immutable kyberProxy;\r\n  IBancorNetwork             private immutable bancorNetwork;\r\n  address[] public bancorPath;\r\n\r\n  /*\r\n    Events\r\n  */\r\n  event Log(string log);\r\n  event Log(address log);\r\n  event UniswapTrade(uint inputAmount, uint outputAmount);\r\n\r\n  /*\r\n    Modifiers\r\n  */\r\n  modifier onlyOwner() {\r\n    require (\r\n      msg.sender == owner,\r\n      \"Only owner can call this function.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /*\r\n    Constructors\r\n  */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n    // uniswapFactory = IUniswapV2Factory(UNISWAP_FACTORY_ADDRESS);\r\n    // uniswapRouter = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS);\r\n    // kyberProxy = KyberNetworkProxyInterface(KYBER_PROXY_ADDRESS);\r\n\r\n    IContractRegistry bancorRegistry = IContractRegistry(BANCOR_REGISTRY_ADDRESS);\r\n    bancorNetwork = IBancorNetwork(bancorRegistry.addressOf(BANCOR_NETWORK));\r\n  }\r\n\r\n  /*\r\n    Bancor Methods\r\n  */\r\n  function getPathBancor(address tokenAddress) public onlyOwner {\r\n    // Find the network path to use in trade\r\n    IContractRegistry bancorRegistry = IContractRegistry(BANCOR_REGISTRY_ADDRESS);\r\n    BancorNetworkPathFinder pathFinder = BancorNetworkPathFinder(bancorRegistry.addressOf(BANCOR_NETWORK_FINDER));\r\n    //address[] memory path = pathFinder.generatePath(ETH_BANCOR_ADDRESS, tokenAddress);\r\n    bancorPath = pathFinder.generatePath(ETH_BANCOR_ADDRESS, tokenAddress);\r\n    // Convert path to ERC20 path\r\n    IERC20Token[] memory erc20Path;\r\n    for (uint i = 0; i < bancorPath.length; i++) {\r\n      erc20Path[i] = IERC20Token(bancorPath[i]);\r\n      emit Log(bancorPath[i]);\r\n    }\r\n  }\r\n\r\n  function swapEthForTokenBancor(address tokenAddress, uint ethAmount) public onlyOwner {\r\n    // Verify we have enough funds\r\n    require(ethAmount * TOKEN_18_DECIMALS <= address(this).balance, \"Not enough Eth in contract to perform swap.\");\r\n\r\n    // Find the network path to use in trade\r\n    IContractRegistry bancorRegistry = IContractRegistry(BANCOR_REGISTRY_ADDRESS);\r\n    BancorNetworkPathFinder pathFinder = BancorNetworkPathFinder(bancorRegistry.addressOf(BANCOR_NETWORK_FINDER));\r\n    address[] memory path = pathFinder.generatePath(ETH_BANCOR_ADDRESS, tokenAddress);\r\n\r\n    // Convert path to ERC20 path\r\n    IERC20Token[] memory erc20Path;\r\n    for (uint i = 0; i < path.length; i++) {\r\n      erc20Path[i] = IERC20Token(path[i]);\r\n    }\r\n\r\n    // Make the call\r\n    bancorNetwork.convert2{ value: ethAmount * TOKEN_18_DECIMALS }(erc20Path, ethAmount * TOKEN_18_DECIMALS, 0, address(0), 0);\r\n  }\r\n\r\n  /*\r\n    Uniswap methods\r\n  */\r\n  // function swapEthForTokenUniswap(address tokenAddress, uint ethAmount) public onlyOwner {\r\n  //   // Verify we have enough funds\r\n  //   require(ethAmount * TOKEN_18_DECIMALS <= address(this).balance, \"Not enough Eth in contract to perform swap.\");\r\n\r\n  //   // Build arguments for uniswap router call\r\n  //   address[] memory path = new address[](2);\r\n  //   path[0] = uniswapRouter.WETH();\r\n  //   path[1] = tokenAddress;\r\n\r\n  //   // Make the call and log the results\r\n  //   uint[] memory result = uniswapRouter.swapExactETHForTokens{ value: ethAmount * TOKEN_18_DECIMALS }(0, path, address(this), now);\r\n  //   emit Log(\"Uniswap Eth for token swap complete.\");\r\n  //   emit UniswapTrade(result[0], result[1]);\r\n  // }\r\n\r\n  // function swapTokenForEtherUniswap(address tokenAddress, uint tokenAmount) public onlyOwner {\r\n  //   // Verify we have enough funds\r\n  //   ERC20 token = ERC20(tokenAddress);\r\n  //   require(tokenAmount * TOKEN_18_DECIMALS <= token.balanceOf(address(this)), \"Not enough tokens in contract to perform swap.\");\r\n\r\n  //   // Approve uniswap to manage contract tokens\r\n  //   token.approve(address(uniswapRouter), token.balanceOf(address(this)));\r\n\r\n  //   // Build arguments for uniswap router call\r\n  //   address[] memory path = new address[](2);\r\n  //   path[0] = tokenAddress;\r\n  //   path[1] = uniswapRouter.WETH();\r\n\r\n  //   // Make the call and log the results\r\n  //   uint[] memory result = uniswapRouter.swapExactTokensForETH(tokenAmount * TOKEN_18_DECIMALS, 0, path, address(this), now);\r\n  //   emit Log(\"Uniswap token for Eth swap complete.\");\r\n  //   emit UniswapTrade(result[0], result[1]);\r\n  // }\r\n\r\n  /*\r\n    Kyber methods\r\n  */\r\n  // function swapEthForTokenKyber(address tokenAddress, uint ethAmount) public onlyOwner {\r\n  //   require(ethAmount * TOKEN_18_DECIMALS <= address(this).balance, \"Not enough Eth in contract to perform swap.\");\r\n\r\n  //   // Declare tokens involved in trade\r\n  //   ERC20 eth = ERC20(ETH_KYBER_ADDRESS);\r\n  //   ERC20 token = ERC20(tokenAddress);\r\n    \r\n  //   // Get the conversion rate\r\n  //   uint minConversionRate;\r\n  //   uint slippageRate;\r\n  //   (minConversionRate, slippageRate) = kyberProxy.getExpectedRate(eth, token, ethAmount * TOKEN_18_DECIMALS);\r\n  //   require(minConversionRate != 0 || slippageRate != 0, \"Trade is not possible at the moment.\");\r\n\r\n  //   // Make the trade. Max amount arbitrarily chosen to be 1 million\r\n  //   bytes memory hint;\r\n  //   kyberProxy.tradeWithHint{ value: ethAmount * TOKEN_18_DECIMALS }(eth, ethAmount * TOKEN_18_DECIMALS, token, address(this), 10**18 * 10**6, minConversionRate, address(0), hint);\r\n  // }\r\n\r\n  // function swapTokenForEtherKyber(address tokenAddress, uint tokenAmount) public onlyOwner {\r\n  //   // Verify we have enough funds\r\n  //   ERC20 eth = ERC20(ETH_KYBER_ADDRESS);\r\n  //   ERC20 token = ERC20(tokenAddress);\r\n  //   require(tokenAmount * TOKEN_18_DECIMALS <= token.balanceOf(address(this)), \"Not enough tokens in contract to perform swap.\");\r\n\r\n  //   // Mitigate ERC20 Approve front-running attack, by initially setting allowance to 0\r\n  //   require(token.approve(KYBER_PROXY_ADDRESS, 0), \"Failure to approve sender front running attack.\");\r\n\r\n  //   // Set the spender's token allowance to tokenQty\r\n  //   require(token.approve(KYBER_PROXY_ADDRESS, tokenAmount * TOKEN_18_DECIMALS), \"Failure to approve sender for token amount.\");\r\n\r\n  //   // Get the conversion rate\r\n  //   uint minConversionRate;\r\n  //   uint slippageRate;\r\n  //   (minConversionRate, slippageRate) = kyberProxy.getExpectedRate(token, eth, tokenAmount * TOKEN_18_DECIMALS);\r\n  //   require(minConversionRate != 0 || slippageRate != 0, \"Trade is not possible at the moment.\");\r\n\r\n  //   // Make the trade. Max amount arbitrarily chosen to be 1 million\r\n  //   bytes memory hint;\r\n  //   kyberProxy.tradeWithHint(token, tokenAmount * TOKEN_18_DECIMALS, eth, address(this), 10**18 * 10**6, minConversionRate, address(0), hint);\r\n  // }\r\n\r\n  /*\r\n    Deposit and Withdrawal methods\r\n  */\r\n  function depositEth() external payable {\r\n    // Nothing to do\r\n  }\r\n\r\n  function depositToken(address tokenAddress, uint tokenAmount) external {\r\n    ERC20 token = ERC20(tokenAddress);\r\n    require (tokenAmount * TOKEN_18_DECIMALS <= token.balanceOf(msg.sender), \"Deposit amount exceeds holding amount.\");\r\n    token.transferFrom(msg.sender, address(this), tokenAmount * TOKEN_18_DECIMALS);\r\n  }\r\n\r\n  function withdrawEth() external onlyOwner {\r\n    msg.sender.transfer(address(this).balance);\r\n  }\r\n\r\n  function withdrawToken(address tokenAddress) external onlyOwner {\r\n    ERC20 token = ERC20(tokenAddress);\r\n    token.transfer(msg.sender, token.balanceOf(address(this)));\r\n  }\r\n\r\n  receive() external payable {\r\n    // Nothing to do\r\n  }\r\n}"
    }
  }
}