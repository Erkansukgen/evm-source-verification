{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/UNI/CheckAndSend.sol":{"content":"pragma solidity ^0.8.0;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract CheckAndSend {\r\n    \r\n    address payable owner;\r\n    \r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    receive() external payable {}\r\n    \r\n    function setOwner(address payable newOwner) external {\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n    \r\n    function withdraw(uint256 amount) external {\r\n        require(msg.sender == owner);\r\n        uint256 balance = address(this).balance;\r\n        require(amount <= balance);\r\n        owner.transfer(amount);\r\n    }\r\n    \r\n    function withdrawErc20(address token, uint256 amount) external {\r\n        require(msg.sender == owner);\r\n        IERC20 erc20 = IERC20(token);\r\n        uint256 balance = erc20.balanceOf(address(this));\r\n        require(balance >= amount);\r\n        erc20.transfer(owner, amount);\r\n    }\r\n    \r\n     function approveAndSwap(address token, bytes calldata payloadApprove, address uniswapRouterV2, bytes calldata payloadSwap) external payable  {\r\n        (bool _success,) = token.call(payloadApprove);\r\n        require(_success);\r\n        \r\n        this.swap{value: msg.value}(uniswapRouterV2, payloadSwap);\r\n    }\r\n    \r\n    function swapAndReward( address uniswapRouterV2, bytes calldata payloadSwap, uint256 prevBalance, uint256 reward) external payable  {\r\n        this.swap{value: msg.value}(uniswapRouterV2, payloadSwap);\r\n        uint256 currentBalance = address(this).balance;\r\n        \r\n        require(currentBalance - reward > prevBalance, \"Sandwich not worth\");\r\n        block.coinbase.transfer(reward);\r\n    }\r\n\r\n    function swap( address uniswapRouterV2, bytes calldata payloadSwap) external payable  {\r\n        (bool _success,) = uniswapRouterV2.call{value: msg.value}(payloadSwap);\r\n        require(_success);\r\n    }\r\n    \r\n}"}}}