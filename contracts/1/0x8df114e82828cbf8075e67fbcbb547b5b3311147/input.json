{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/claims_hybdrid.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-01-23\n*/\n\npragma solidity >=0.8.0 <0.9.0;\npragma experimental ABIEncoderV2;\ninterface ZeroXChanSticker {\n\tfunction originalTokenOwner(uint256 tokenId) external view returns(address);\n\tfunction tokenProperty(uint256 tokenId) external view returns(uint256);\n}\ncontract EtherGiverFromSticker2{\n    address internal admin;\n    ZeroXChanSticker internal thingWithUserWorth;\n    uint256 internal contractAirdropStore;\n    uint256 internal contractBalanceStore;\n    uint256 internal contractStore;\n    mapping (address => uint256) public userShares;\n    address[] internal airdropReceivers;\n    constructor(){\n        contractStore = (\n            0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 | // claimStartTime = claimEndTime = inifnity (later set by deposit)\n            (241655500000000000000) // totalShares = 241655500000000000000\n        );\n        thingWithUserWorth = ZeroXChanSticker(0x238C0ebf1Af19b9A8881155b4FffaA202Be50D35);\n\t    admin = 0x8FFDE97829408c39cdE8fAdcD4060fd6fFd5A355;\n    }\n    function totalDeposit() public view returns (uint128){\n        return (uint128(contractBalanceStore >> 128));\n    }\n    function leftoverAmount() public view returns(uint128){\n       return (uint128(contractBalanceStore));\n    }\n    function airdropShares() public view returns(uint128){\n        return (uint128(contractAirdropStore));\n    }\n    function airdropIndex() public view returns(uint128){\n        return (uint128(contractAirdropStore >> 128));\n    }\n    function totalUsersClaimed() public view returns(uint128){\n        return (uint128(airdropReceivers.length));\n    }\n    function claimStartTime() public view returns(uint64){\n        return(uint64(contractStore >> 192));\n    }\n    function claimEndTime() public view returns(uint64){\n        return(uint64(contractStore >> 128));\n    }\n    function totalShares() public view returns(uint128){\n        return(uint128(contractStore));\n    }\n    function abort() public{\n        require(msg.sender == admin, \"not admin\");\n\t    require(block.timestamp < claimStartTime(), \"TOO LATE\");\n\t    selfdestruct(payable(msg.sender));\n    }\n    fallback() external payable{\n        require(msg.sender == admin, \"not admin\");\n        require(block.timestamp < claimStartTime(), \"Cannot deposit while there's claims\");\n        // Add value to leftoverAmount and totalDeposit \n        contractBalanceStore += ((msg.value << 128) | msg.value);\n        // Get this shit on the road\n        contractStore &= (\n            ((block.timestamp + 3600) << 192) | // claimStartTime = currenTime + 1 hour\n            ((block.timestamp + 608400) << 128) | // claimEndTime = currenTime + 1 hour + 1 week\n            0xffffffffffffffffffffffffffffffff\n        );\n    }\n    function makeClaim(uint256[] calldata tokenIds) public{\n        require(block.timestamp >= claimStartTime(), \"Too early to make a claim\");\n        require(block.timestamp < claimEndTime(), \"Too late to make a claim\");\n        require(tokenIds.length > 0, \"Nothing to claim\");\n        uint256 localUserShares = userShares[msg.sender];\n        require(localUserShares == 0, \"Already claimed\");\n        uint256 tokenId;\n        for(uint256 i = 0; i < tokenIds.length; i += 1){\n            tokenId = tokenIds[i];\n            require(thingWithUserWorth.originalTokenOwner(tokenId) == msg.sender, \"Token must be created by you\");\n            localUserShares += thingWithUserWorth.tokenProperty(tokenId);\n        }\n        unchecked{\n            // Add to airdropShares, Impossible to overflow\n            contractAirdropStore += localUserShares;\n        }\n        uint256 valueToSend = uint256(totalDeposit()) * localUserShares / uint256(totalShares());\n        // Subtract from leftoverAmount, used in airdrops later\n        contractBalanceStore -= valueToSend;\n        payable(msg.sender).transfer(valueToSend);\n        airdropReceivers.push(msg.sender);\n        \n        userShares[msg.sender] = localUserShares;\n    }\n    function doAirdrop(uint128 amountToDo) public{\n        require(block.timestamp >= claimEndTime(), \"Cannot airdrop during claim time\");\n        uint128 startIndex = airdropIndex();\n        // amountToDo becomes endIndex\n        amountToDo += startIndex;\n        if(amountToDo > uint128(airdropReceivers.length)){\n            amountToDo = uint128(airdropReceivers.length);\n        }\n        uint256 localAirdropShares = uint256(airdropShares());\n        for(uint128 i = startIndex; i < amountToDo; i += 1){\n            payable(airdropReceivers[i]).transfer(uint256(leftoverAmount()) * userShares[airdropReceivers[i]] / localAirdropShares);\n        }\n        contractAirdropStore &= 0xffffffffffffffffffffffffffffffff;\n        contractAirdropStore |= uint256(amountToDo) << 128;\n        if(amountToDo == uint128(airdropReceivers.length)){\n            selfdestruct(payable(msg.sender));\n        }\n    }\n}"}}}