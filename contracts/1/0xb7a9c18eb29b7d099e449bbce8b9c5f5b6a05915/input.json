{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":10},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"upgrader.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.9;\r\n\r\n/// @notice Transferrer storage for Tangle\r\n/// @dev This is a Diamond Storage implementation described in EIP-2535.\r\nlibrary SLib {\r\n    \r\n    struct S {\r\n        bool minted;\r\n        uint8 decimals;\r\n        address liquidityAddress;\r\n        uint wc;\r\n        uint last;\r\n        uint totalSupply;\r\n        uint piecesPerUnit;\r\n        uint minHoldAmount;\r\n        uint cropDustAmount;\r\n        string name;\r\n        string symbol;\r\n        address[] addresses;\r\n        address[] blacklist;\r\n        string[] names;\r\n        Reflect_[] reflects;\r\n        mapping(address => uint) balances;\r\n        mapping(address => uint) addressIndex;\r\n        mapping(address => uint) reflectIndex;\r\n        mapping(address => uint) blacklistIndex;\r\n        mapping(address => Split) splits;\r\n        mapping(string => uint) nameIndex;\r\n        mapping(string => string) ids;\r\n        mapping(string => Farm) farms;\r\n        mapping(address => mapping(address => uint)) allowances;\r\n        mapping(address => mapping(string => uint)) points;\r\n        mapping(address => mapping(string => uint)) rewards;\r\n        mapping(address => mapping(string => uint)) wcInits;\r\n        mapping(address => mapping(string => uint)) propSumInits;\r\n    }\r\n    function getS() internal pure returns (S storage sInfo) {\r\n        bytes32 storagePosition = keccak256(bytes(\"0\"));\r\n        assembly { sInfo.slot := storagePosition }\r\n    }\r\n    struct Split {\r\n        uint16 numerator;\r\n        uint16 denominator;\r\n        address to;\r\n    }\r\n    struct Reflect_ {\r\n        address address_;\r\n        bool flag;\r\n    }\r\n    struct Farm {\r\n        uint C;\r\n        uint N;\r\n        uint D;\r\n        uint max;\r\n        uint last;\r\n        uint start;\r\n        uint elapsed;\r\n        uint propSum;\r\n        uint points;\r\n        string name;\r\n    }\r\n    struct SUpgrader {\r\n        address upgradeWallet;\r\n        bytes32 root;\r\n        mapping(address => bool) upgraded;\r\n    }\r\n    function getSUpgrader() internal pure returns (SUpgrader storage s) {\r\n        bytes32 storagePosition = keccak256(bytes(\"Tangle.Upgrader0\"));\r\n        assembly { s.slot := storagePosition }\r\n    }\r\n    /// @notice Records all transfers\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event ChangeUpgradeWallet(address newUpgradeWallet);\r\n    event ChangeRoot(bytes32 newRoot);\r\n    event Upgrade(address upgraded);\r\n\r\n}\r\n\r\ncontract Upgrader {\r\n\r\n    mapping(bytes4 => address) private _0;\r\n    address private owner;\r\n\r\n    function _verifyProof(bytes32[] memory proof, address _address, uint value, uint index) internal view returns (bool) {\r\n        bytes32 hash = keccak256(abi.encodePacked(_address, value));\r\n        for (uint i = 0; i < proof.length; i++) {\r\n            if (index % 2 == 0) {\r\n                hash = keccak256(abi.encodePacked(hash, proof[i]));\r\n            } else {\r\n                hash = keccak256(abi.encodePacked(proof[i], hash));\r\n            }\r\n            index /= 2;\r\n        }\r\n        return hash == SLib.getSUpgrader().root;\r\n    }\r\n    \r\n    function changeUpgradeWallet(address newUpgradeWallet) external {\r\n        require(msg.sender == owner);\r\n        SLib.getSUpgrader().upgradeWallet = newUpgradeWallet;\r\n        emit SLib.ChangeUpgradeWallet(newUpgradeWallet);\r\n    }\r\n    \r\n    function upgradeWallet() external view returns (address) {\r\n        return SLib.getSUpgrader().upgradeWallet;\r\n    }\r\n    \r\n    function changeRoot(bytes32 newRoot) external {\r\n        require(msg.sender == owner);\r\n        SLib.getSUpgrader().root = newRoot;\r\n        emit SLib.ChangeRoot(newRoot);\r\n    }\r\n    \r\n    function root() external view returns (bytes32) {\r\n        return SLib.getSUpgrader().root;\r\n    }\r\n    \r\n    function upgradeStatus(bytes32[] memory proof, address _address, uint value, uint index) external view returns (bool, bool) {\r\n        return (_verifyProof(proof, _address, value, index), SLib.getSUpgrader().upgraded[_address]);\r\n    }\r\n    \r\n    function upgrade(bytes32[] memory proof, address _address, uint value, uint index) external {\r\n        SLib.SUpgrader storage sUpgrader = SLib.getSUpgrader();\r\n        SLib.S storage s = SLib.getS();\r\n        require(_verifyProof(proof, _address, value, index) && !sUpgrader.upgraded[_address]);\r\n        sUpgrader.upgraded[_address] = true;\r\n        s.balances[sUpgrader.upgradeWallet] -= unitsToPieces(value);\r\n        s.balances[_address] += unitsToPieces(value);\r\n        emit SLib.Transfer(sUpgrader.upgradeWallet, _address, value);\r\n        emit SLib.Upgrade(_address);\r\n    }\r\n    \r\n    function unitsToPieces(uint units) internal view returns (uint) {\r\n        return units * SLib.getS().piecesPerUnit;\r\n    }\r\n\r\n}\r\n"}}}