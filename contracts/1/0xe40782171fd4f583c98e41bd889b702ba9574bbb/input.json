{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/ETHGen.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\n\ncontract ETHGen is Ownable\n{\n    using SafeMath for uint256;\n\n    // Allow front end systems to know when new members are added to the tree\n    event NewMember(\n        uint256 indexed memberID\n    );\n    \n    // Allow front end systems to know when a referal is earned by a member (and from who)\n    event ReferalBonus(\n        uint256 indexed memberID,   // member who earned the commission\n        uint256 indexed saleID      // member who paid for their subscription\n    );\n    \n    // Allow front end systems to know when a team bonus is earned by a member\n    event TeamGrowthBonus(\n        uint256 indexed memberID,   // member who earned the commission\n        uint256 indexed saleID      // member who paid for their subscription\n    );\n    \n    // Allow front end systems to know when a generational bonus is earned by a member\n    event GenerationalBonus(\n        uint256 indexed memberID,   // member who earned the commission\n        uint256 indexed saleID,     // member who paid for their subscription\n        uint256 indexed level       // Which Generation Level was earned (1 is first enroller - 10 the top Super paid)\n    );\n\n    // The amount of time added to the subscription for each payment of purchasePrice below\n    uint256 public purchaseTime = 35 days;\n\n    /**\n    * @dev Allows the Purchase Time to be changed from 35 days for future membership purchases\n    */\n    function setPurchaseTime(uint256 _time) external onlyOwner\n    {\n        purchaseTime = _time;\n    }\n\n    // The price to purchase time on the subscription based upon the number of days in PurchaseTime above\n    uint256 public purchasePrice = 0.05 ether;\n\n    /**\n    * @dev Allows the Purchase Price to be changed from 0.05 ether to keep it priced similar to starting USD price for future membership purchases\n    */\n    function setPurchasePrice(uint256 _price) external onlyOwner\n    {\n        purchasePrice = _price;\n    }\n\n    // Price to transfer from one wallet address to another (in the case of a compromised account or account sale)    \n    uint256 public transferPrice = 0.1 ether;\n\n    /**\n    * @dev Allows the Transfer Price to be changed from 0.1 ether to keep it priced similar to starting USD price for transfers\n    */\n    function setTransferPrice(uint256 _price) external onlyOwner\n    {\n        transferPrice = _price;\n    }\n\n    // Over run account...if bonuses are to be paid and no accounts are found that match the criteria\n    address private _primary;\n\n    /**\n    * @dev Allows the account that over runs will roll up into to be changed\n    */\n    function setPrimary(address _newPrime) external onlyOwner\n    {\n        _primary = _newPrime;\n    }\n\n    // Used to iterate through the member list and can be used to display the total number of participants\n    uint256 public memberCount = 0;\n    \n    struct Member\n    {\n        address account;            // Address of the Member\n        address enroller;           // Address of their enroller\n        uint256 salesMade;          // Number of Direct Members this Member enrolled\n        bool    masterLevel;        // Flag to say this is a special account that is always active and meets all criteria (ID 1, and others)\n        uint256 membershipEnds;     // For all other accounts...when the subscription ends\n    }\n    mapping (uint256 => Member) public members;\n\n    // Used for easier lookups within the system\n    mapping (address => uint256) internal ownerToMember;      // Get the ID for a given address\n    mapping (uint256 => address) internal memberToOwner;      // Get the address for a given ID\n    mapping (uint256 => address) internal memberToEnroller;   // Get the enroller address for a given member ID\n    mapping (address => uint256) internal providerToFee;      // Get the fee for a given provider (defaults to 5.00% if missing)\n\n    /**\n    * @dev The Member constructor adds the owner as the base user account in the system (ID 1)\n    */\n    constructor()\n    {\n        _primary = msg.sender;\n        _addMember(_primary, true, address(0x0), 1);\n    }\n\n    /**\n    * @dev Default function adds time to the current person\n    */\n    receive() external payable\n    {\n        renewMembership(1);\n    }\n    \n    /**\n    * @dev Default function adds time to the current person\n    */\n    fallback() external payable\n    {\n        renewMembership(1);\n    }\n\n    /**\n    * @dev The addition of a new member to the system (whether special or not) keeping all of the mappings up to date\n    */\n    function _addMember(address _member, bool _special, address _enroller, uint256 _numPeriods) internal\n    {\n        memberCount = memberCount.add(1);\n        members[memberCount] = Member(_member, _enroller, 0, _special, (_numPeriods.mul(purchaseTime)).add(block.timestamp));\n        emit NewMember(memberCount);\n\n        ownerToMember[_member] = memberCount;\n        memberToOwner[memberCount] = _member;\n        memberToEnroller[memberCount] = _enroller;\n    }\n    \n    /**\n    * @dev The addition of a special (always active) user in the system\n    */\n    function addSpecialMember(address _member, address _enroller) external onlyOwner returns(bool)\n    {\n        // If account already exists...we fail\n        if(getID(_member) != 0) return false;\n\n        // Enroller has to exist...\n        if(getID(_enroller) == 0) return false;\n\n        _addMember(_member, true, _enroller, 1);\n\n        Member storage m = members[ownerToMember[_enroller]];\n        m.salesMade = m.salesMade.add(1);\n\n        return true;\n    }\n\n    /**\n    * @dev The addition of a new member for the specified time and price under the specified enroller\n    */\n    function newMemberJoin(address _enroller, uint256 _numPeriods) external payable returns(uint256)\n    {\n        // Account can't already exist...\n        if(getID(msg.sender) != 0) { revert(); }\n        \n        // Enroller must exist...\n        if(getID(_enroller) == 0) { revert(); }\n        \n        // Check the amount sent...\n        if(msg.value != _numPeriods.mul(purchasePrice)) { revert(); }\n        \n        _addMember(msg.sender, false, _enroller, _numPeriods);\n        \n        Member storage m = members[ownerToMember[_enroller]];\n        m.salesMade = m.salesMade.add(1);\n        \n        if(!_distributeFunds(_enroller, getID(msg.sender), msg.value)) { revert(); }\n        return block.number;\n    }\n\n    /**\n    * @dev Add the specified time and distribute the price for the renewal\n    */\n    function renewMembership(uint256 _numPeriods) public payable returns(uint256)\n    {\n        // Must Include at Least 1 Period\n        if(_numPeriods <= 0) { revert(); }\n\n        // Member Not Found\n        if(getID(msg.sender) == 0) { revert(); }\n\n        // Incorrect Amount Sent\n        if(msg.value != (_numPeriods.mul(purchasePrice))) { revert(); }\n\n        Member storage m = members[getID(msg.sender)];\n        // Check for expired membership\n        if(m.membershipEnds > block.timestamp)\n        {\n            // They were not expired...so we extend it out further by the days in purchaseTime * number of periods\n            m.membershipEnds = m.membershipEnds.add(_numPeriods.mul(purchaseTime));\n        }\n        else\n        {\n            // They were expired...so we start them with a fresh number of days in purchaseTime * number of periods\n            m.membershipEnds = (purchaseTime.mul(_numPeriods)).add(block.timestamp);\n        }\n        \n        if(!_distributeFunds(memberToEnroller[getID(msg.sender)], getID(msg.sender), msg.value)) { return 0; }\n        return block.number;\n    }\n    \n    /**\n    * @dev Used to distribute funds to the members based upon the comp plan\n    *       25% to the enroller of the member ID\n    *       25% to the Team Growth Bonus Qualified upline\n    *        5% to each of 10 Generational Bonus Qualified upline\n    *      ----\n    *      100% paid out = none collected by the smart contract (complete member-to-member payout)\n    * \n    *           Note: _currentID can be 0 if it was a customer (not a distributor) sale being paid out\n    */\n    function _distributeFunds(address enroller, uint256 _currentID, uint256 _amount) internal returns(bool)\n    {\n        bool success;\n        if(enroller == address(0x0))\n        {\n            (success, ) = _primary.call{value: _amount}(\"\");\n            if(!success) return false;\n            return true;\n        }\n        \n        uint256 spID = getID(enroller);\n        if(spID == 0) { return false; } // Enroller Not Found In System\n        \n        uint256 pp4 = _amount.div(4);       // Used for the 2 25% payments\n        uint256 pp20 = _amount.div(20);     // Used for the 10 5% gen bonuses\n\n        // Pay the enroller no matter what..\n        (success, ) = enroller.call{value: pp4}(\"\");\n\n        //Transfer failed to pay enroller\n        if(!success) return false;\n\n        emit ReferalBonus(spID, _currentID);\n        \n        // Pay the Team Growth Bonus...\n        // Note the direct enroller never gets these for their first two membership positions (even on renewals)\n        // -- and they can't be collected from the first line of enrollership either --\n        if(isTeamGrowthQualified(enroller, _currentID) && (getSecondMemberID(enroller) != _currentID))\n        {\n            (success, ) = enroller.call{value: pp4}(\"\");\n\n            //Transfer failed to pay enroller\n            if(!success) return false;\n\n            emit TeamGrowthBonus(spID, _currentID);\n        }\n        else\n        {\n            address prior = enroller;\n            address tg = memberToEnroller[spID];     // Start with first upline of the enroller\n            while((tg != address(0x0)) && (!isTeamGrowthQualified(tg, getID(prior))))\n            {\n                prior = tg;\n                tg = memberToEnroller[getID(prior)];\n            }\n            if(tg == address(0x0))\n            {\n                (success, ) = _primary.call{value: pp4}(\"\");\n\n                // Transfer failed\n                if(!success) return false;\n            }\n            else\n            {\n                (success, ) = tg.call{value: pp4}(\"\");\n\n                // Transfer failed\n                if(!success) return false;\n\n                emit TeamGrowthBonus(getID(tg), _currentID);\n            }\n        }\n\n        // Pay the Generational Bonuses...\n        address gen = enroller;\n        uint256 level = 1;\n        while(level < 3)        // Find Active Affiliates for level 1 and 2\n        {\n            while((gen != address(0x0)) && (!isActiveByAddress(gen)))\n            {\n                gen = memberToEnroller[getID(gen)];\n            }\n            if(gen == address(0x0))\n            {\n                (success, ) = _primary.call{value: pp20}(\"\");\n\n                // Transfer failed\n                if(!success) return false;\n            }\n            else\n            {\n                (success, ) = gen.call{value: pp20}(\"\");\n\n                // Transfer failed\n                if(!success) return false;\n\n                emit GenerationalBonus(getID(gen), _currentID, level);\n            }\n            if(gen != address(0x0)) gen = memberToEnroller[getID(gen)];\n            level = level.add(1);\n        }\n        while(level < 6)        // Find Active Smart Affiliates for level 3, 4 and 5\n        {\n            while((gen != address(0x0)) && (!isSmartAffiliate(gen)))\n            {\n                gen = memberToEnroller[getID(gen)];\n            }\n            if(gen == address(0x0))\n            {\n                (success, ) = _primary.call{value: pp20}(\"\");\n\n                // Transfer failed\n                if(!success) return false;\n            }\n            else\n            {\n                (success, ) = gen.call{value: pp20}(\"\");\n\n                // Transfer failed\n                if(!success) return false;\n\n                emit GenerationalBonus(getID(gen), _currentID, level);\n            }\n            if(gen != address(0x0)) gen = memberToEnroller[getID(gen)];\n            level = level.add(1);\n        }\n        while(level <= 10)        // Find Active Super Affiliates for level 6-10\n        {\n            while((gen != address(0x0)) && (!isSuperAffiliate(gen)))\n            {\n                gen = memberToEnroller[getID(gen)];\n            }\n            if(gen == address(0x0))\n            {\n                (success, ) = _primary.call{value: pp20}(\"\");\n\n                // Transfer failed\n                if(!success) return false;\n            }\n            else\n            {\n                (success, ) = gen.call{value: pp20}(\"\");\n\n                // Transfer failed\n                if(!success) return false;\n\n                emit GenerationalBonus(getID(gen), _currentID, level);\n            }\n            if(gen != address(0x0)) gen = memberToEnroller[getID(gen)];\n            level = level.add(1);\n        }\n        return true;\n    }\n    \n    /**\n    * @dev Quick way to get the ID from an address in the system\n    */\n    function getID(address _member) view public returns(uint256)\n    {\n        return ownerToMember[_member];\n    }\n\n    /**\n    * @dev Quick way to get the address from an ID in the system\n    */\n    function getAddress(uint256 _memberID) view public returns(address)\n    {\n        return memberToOwner[_memberID];\n    }\n\n    /**\n    * @dev Quick way to get the enroller ID from a member address in the system\n    */\n    function getEnrollerID(address _member) view public returns(uint256)\n    {\n        return ownerToMember[memberToEnroller[ownerToMember[_member]]];\n    }\n\n    /**\n    * @dev Quick way to get the enroller address from a member ID in the system\n    */\n    function getEnrollerAddress(uint256 _memberID) view public returns(address)\n    {\n        return memberToEnroller[_memberID];\n    }\n\n    /**\n    * @dev Quick way to get a member structure from a member ID\n    */\n    function getMemberByID(uint256 _memberID) view public returns(Member memory)\n    {\n        //if(_memberID == 0) { return members[0]; } // Not a Valid ID\n        //if(_memberID > memberCount) { return null; } // Not a Valid ID\n        return members[_memberID];\n    }\n\n    /**\n    * @dev Quick way to get a member structure from a member address\n    */\n    function getMemberByAddress(address _member) view public returns(Member memory)\n    {\n        //if(_member == address(0x0)) { return null; } // Not a Valid Address\n        return members[getID(_member)];\n    }\n\n    /**\n    * @dev Determines if the user is special (always active) or has remaining days left of their membership\n    */\n    function isActiveByAddress(address _member) view public returns(bool)\n    {\n        if(_member == address(0x0)) { return false; } // Not a Valid Address\n\n        uint256 ID = ownerToMember[_member];\n\n        if(ID == 0) { return false; } // Not a Valid ID\n        if(ID > memberCount) { return false; } // Not a Valid ID\n\n        return members[ID].masterLevel || members[ID].membershipEnds > block.timestamp;\n    }\n\n    /**\n    * @dev Determines if the user is special (always active) or has remaining days left of their membership\n    */\n    function isActiveByID(uint256 _memberID) view public returns(bool)\n    {\n        if(_memberID == 0) { return false; } // Not a Valid ID\n        if(_memberID > memberCount) { return false; } // Not a Valid ID\n        return members[_memberID].masterLevel || members[_memberID].membershipEnds > block.timestamp;\n    }\n\n    /**\n    * @dev Traverse the list to get the IDs of all members enrolled by this address\n    */\n    function getMembersByOwner(address _owner) public view returns(uint256[] memory)\n    {\n        uint256[] memory result;\n        \n        uint256 numSales = getMemberByAddress(_owner).salesMade;\n        if(numSales < 1) return result;\n        \n        result = new uint256[](numSales);\n        uint counter = 0;\n        for (uint i = 1; i <= memberCount; i++)\n        {\n            if (memberToEnroller[i] == _owner)\n            {\n                result[counter] = i;\n                counter++;\n            }\n        }\n        return result;\n    }\n    \n    /**\n    * @dev Get the ID of the first member they ever sold a membership to (used to determine eligibility for Team bonuses)\n    */\n    function getFirstMemberID(address _owner) internal view returns(uint256)\n    {\n        uint256 numSales = getMemberByAddress(_owner).salesMade;\n        if(numSales < 1) return 0;\n        \n        for (uint i = 1; i <= memberCount; i++)\n        {\n            if (memberToEnroller[i] == _owner) return i;\n        }\n        return 0;\n    }\n\n    /**\n    * @dev Get the ID of the second member they ever sold a membership to (used to determine eligibility for Team bonuses)\n    */\n    function getSecondMemberID(address _owner) internal view returns(uint256)\n    {\n        uint256 numSales = getMemberByAddress(_owner).salesMade;\n        if(numSales < 1) return 0;\n        bool firstFound = false;\n        \n        for (uint i = 1; i <= memberCount; i++)\n        {\n            if (memberToEnroller[i] == _owner)\n            {\n                if(!firstFound) firstFound = true;\n                else return i;\n            }\n        }\n        return 0;\n    }\n\n    /**\n    * @dev Determines whether the member has sold any memberships yet at all\n    */\n    function hasMembers(address _owner) view public returns(bool)\n    {\n        return membershipsSold(_owner) > 0;\n    }\n\n    /**\n    * @dev Determines how many members have ever purchased from a user (need to know if they have at least 2 or not in some cases)\n    *       same as number of directs to this user\n    */\n    function membershipsSold(address _owner) view public returns(uint256)\n    {\n        if(getID(_owner) == 0) return 0;\n        return getMemberByAddress(_owner).salesMade;\n    }\n\n    /**\n    * @dev Make sure they have two sales and the _from ID member is not in the 1st line of their team\n    */\n    function isTeamGrowthQualified(address _owner, uint256 _from) view public returns(bool)\n    {\n        if(getMemberByAddress(_owner).masterLevel) return true;     // masterLevel is always active and qualified\n        if(!isActiveByAddress(_owner)) return false;                // Must be active themselves to be qualified for this\n        // Note: For sales to a direct, personally enrolled, a check is still needed that it is not the second personally enrolled\n        return ((membershipsSold(_owner) > 1) && (getFirstMemberID(_owner) != _from));\n    }\n\n    /**\n    * @dev Determines whether the member still has at least 3 Active Affiliates\n    */\n    function isSmartAffiliate(address _owner) view public returns(bool)\n    {\n        if(getMemberByAddress(_owner).masterLevel) return true;     // masterLevel is always active and qualified\n        if(!isActiveByAddress(_owner)) return false;                // Must be active themselves to be qualified for this\n\n        uint256[] memory mems = getMembersByOwner(_owner);          // Get All member IDs of their directs\n\n        uint256 numSales = mems.length;\n        uint256 numActive = 0;\n\n        for (uint i = 0; i < numSales; i++)\n        {\n            // Just need to find those they enrolled that are active right now\n            if (isActiveByID(mems[i]))\n            {\n                if(numActive >= 2) return true; // As soon as we find a third active Affiliate we are done...no need to add to the temp variable\n                numActive = numActive.add(1);\n            }\n        }\n        return false;\n    }\n\n    /**\n    * @dev Determines whether the member still has at least 3 Active Smart Affiliates\n    */\n    function isSuperAffiliate(address _owner) view public returns(bool)\n    {\n        if(getMemberByAddress(_owner).masterLevel) return true;     // masterLevel is always active and qualified\n        if(!isActiveByAddress(_owner)) return false;                // Must be active first to be qualified\n\n        uint256[] memory mems = getMembersByOwner(_owner);\n        \n        uint256 numSales = mems.length;\n        uint256 numActive = 0;\n\n        for (uint i = 0; i < numSales; i++)\n        {\n            // Smart Affiliate means they are active with three active so it does the second level checks for us\n            if (isSmartAffiliate(memberToOwner[mems[i]]))\n            {\n                if(numActive >= 2) return true; // As soon as we find a third Smart Affiliate we are done...no need to add to the temp variable here\n                numActive = numActive.add(1);\n            }\n        }\n        return false;\n    }\n\n    /**\n    * @dev Allows a User to change the address associated with their membership to a new address (theirs or someone they are selling it to)\n    */\n    function transferMemberPosition(address _to) external payable returns(uint256)\n    {\n        if(msg.value != transferPrice) { revert(); } // Incorrect Amount Sent\n        if(getID(msg.sender) == 0) { revert(); } // Member Account Not Found\n        if(getID(_to) != 0) { revert(); } // To Account Already Exists\n\n        (bool success, ) = _primary.call{value: transferPrice}(\"\");\n        // Transfer failed\n        if(!success) { revert(\"Transfer Failed\"); }\n\n        uint256 memberID = ownerToMember[msg.sender];\n        uint256[] memory mems = getMembersByOwner(msg.sender);\n        uint256 numSales = mems.length;\n        Member storage m = members[memberID];\n        m.account = _to;\n        delete ownerToMember[msg.sender];\n        ownerToMember[_to] = memberID;\n        memberToOwner[memberID] = _to;\n        for(uint256 i = 0; i < numSales; i++)\n        {\n            members[mems[i]].enroller = _to;\n            memberToEnroller[mems[i]] = _to;\n        }\n        return block.number;\n    }\n\n    /**\n    * @dev Get the fee percentage for a specified provider...\n    * \n    *   Note: 500 = 5.00% or 399 = 3.99%\n    */\n    function getProviderFee(address _provider) external view onlyOwner returns(uint256)\n    {\n        if(_provider == address(0x0)) return 500;\n        return providerToFee[_provider];\n    }\n    \n    /**\n    * @dev Set the fee percentage for a specified provider...\n    * \n    *   Calculation will be: Amount * Fee / 10000\n    *       ex. Amount of 100 WEI, Fee of 1000: 100*1000/10000 = 10 WEI (10.00% of 100)\n    *       ex. Amount of 1000 WEI, Fee of 5: 1000*500/10000 = 50 WEI (5.00% of 1000)\n    * \n    *   Note: Used in processProductPurchase\n    */\n    function setProviderFee(address _provider, uint256 _fee) external onlyOwner\n    {\n        if(_provider == address(0x0)) return;\n        uint256 newFee = 500;\n        if(_fee > 0 && _fee <= 10000) newFee = _fee;\n        providerToFee[_provider] = newFee;\n    }\n\n    /**\n    * @dev Allows a Provider to send commissions to the network (the provider MUST be a Member as well)\n    * \n    *   _providerAmountInGWEI + _distAmountInGWEI must match the amount sent by the purchaser\n    * \n    *   A percentage of the provider amount goes to ETH Gen as sales commissions unless the entire amount is sent to commission tree\n    *       Note: This will use the stored fee...or default to a standard 5.00% fee...providerToFee is set in setProviderFee by the contract owner\n    * \n    *   If the sender is in the system, it determines the enroller and ignores the _enroller passed\n    *   Otherwise, if the sender is not in the system, the sender is assumed to be a customer and an enroller should be specified who is responsible for the sale\n    *       Note: This means the provider tracked who the customer was brought to their site by (in other words, the affiliate who IS a member of this system)\n    *       Note: This is on the honor of the provider as the smart contract would not know this...they could pass a bad address and keep the customer as their own\n    *   But, if there is no _enroller passed, then the amount is considered a house sale and distribution amount starts with the provider as the enroller\n    */\n    function processProductPurchase(address _provider, address _enroller, uint256 _providerAmountInWEI, uint256 _distAmountInWEI) external payable returns(uint256)\n    {\n        if(msg.value != (_providerAmountInWEI + _distAmountInWEI)) { revert(); } // Incorrect Amount Sent\n        if(address(0x0) == _provider) { revert(); } // Invalid Provider Address\n\n        if(_providerAmountInWEI > 0)\n        {\n            // Compute the provider fee collected by ETHGen...\n            uint256 ethgenFee = providerToFee[_provider];           // See if a special rate is specified...\n            if(ethgenFee < 1) ethgenFee = 500;                        // If not, default to 5.00% standard fee\n    \n            uint256 eamount = (_providerAmountInWEI.mul(ethgenFee)).div(10000);\n            uint256 pamount = _providerAmountInWEI.sub(eamount);\n    \n            if(eamount > 0)\n            {\n                (bool success, ) = _primary.call{value: eamount}(\"\");\n    \n                // Transfer failed to ETHGen\n                if(!success) { revert(); }\n            }\n            if(pamount > 0)\n            {\n                (bool success, ) = _provider.call{value: pamount}(\"\");\n    \n                // Transfer failed to Provider\n                if(!success) { revert(); }\n            }\n        }\n        if(_distAmountInWEI > 0)\n        {\n            uint256 ID = getID(msg.sender);\n            if(ID == 0)\n            {\n                uint256 eID = getID(_enroller);\n                if(eID == 0)\n                {\n                    uint256 pID = getID(_provider);\n\n                    // Provider Not Found In System (they must be a member)...\n                    if(pID == 0) { revert(); }\n                    \n                    // If we have a customer and the enroller is not passed, then they are treated as a customer of the partner directly\n                    // In that case we treat the enroller as the partner's member account directly for distribution...\n                    if(!_distributeFunds(_provider, ID, _distAmountInWEI)) { revert(); }\n                }\n                else\n                {\n                    // The caller is not a member, so they must be a customer...\n                    // If the provider tracked that customer's affiliate status and passed a member to use we use that here...\n                    if(!_distributeFunds(_enroller, ID, _distAmountInWEI)) { revert(); }\n                }\n            }\n            else\n            {\n                // We found the purchaser and they are a member...so make sure their enroller is the start of the distribution...\n                if(!_distributeFunds(memberToEnroller[ID], ID, _distAmountInWEI)) { revert(); }\n            }\n        }\n        return block.number;\n    }\n}\n"},"contracts/Ownable.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable\n{\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n  * account.\n  */\n  constructor()\n  {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n  * @return the address of the owner.\n  */\n  function owner() public view returns(address)\n  {\n    return _owner;\n  }\n\n  /**\n  * @dev Throws if called by any account other than the owner.\n  */\n  modifier onlyOwner()\n  {\n    require(isOwner());\n    _;\n  }\n\n  /**\n  * @return true if `msg.sender` is the owner of the contract.\n  */\n  function isOwner() public view returns(bool)\n  {\n    return msg.sender == _owner;\n  }\n\n  /**\n  * @dev Allows the current owner to transfer control of the contract to a newOwner.\n  * @param newOwner The address to transfer ownership to.\n  */\n  function transferOwnership(address newOwner) public onlyOwner\n  {\n    _transferOwnership(newOwner);\n  }\n\n  /**\n  * @dev Transfers control of the contract to a newOwner.\n  * @param newOwner The address to transfer ownership to.\n  */\n  function _transferOwnership(address newOwner) internal\n  {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"},"contracts/SafeMath.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath\r\n{\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n  {\r\n    if (a == 0)\r\n    {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256)\r\n  {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n  {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256)\r\n  {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n"}}}