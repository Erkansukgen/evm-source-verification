{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/_50Win.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.8;\ncontract _50Win {\n    struct Bet {\n        address creator;\n        address referrer;\n        uint256 time;\n        uint256 value;\n        uint256 betFor; //tails or heads\n    }\n    \n    address private _chef;\n    mapping(address => Bet) public Bets;\n    address[] public BetLUT;\n    uint256 private _chefTips;\n    uint256 public _tipsRate;\n    uint256 public _refRate;\n    uint256 public _cancelFee;\n    \n    event NewBet (address creator, uint256 betFor, uint256 value, uint256 time);\n    event CancelBet (address creator, uint256 betFor, uint256 value);\n    event WinBet (address indexed creator, address indexed joiner, address indexed ref, uint256 betFor, uint256 win, uint256 value, uint256 time);\n    \n    constructor () public {\n        _chef = msg.sender;\n        _tipsRate=500; _cancelFee=100; _refRate=100;// rate/10000 => 500 <=> 5%\n    }\n    \n    function toss() internal view returns(uint256) { return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, block.gaslimit, block.coinbase, block.number)))%2; }\n    \n    function send(address to, uint256 amt, uint256 tips, address ref) private returns (bool){\n        (bool sentTo,) = address(to).call{value : amt-tips}(\"\");\n        if(tips>0) {\n            if(ref != 0x0000000000000000000000000000000000000000) {\n                uint256 refEarn = amt/2*_refRate/10000;//sharing tips with referral\n                (bool sentRef,) = address(ref).call{value : refEarn}(\"\");\n                if(sentRef) tips -= refEarn;\n            }\n            \n            (bool sentFee,) = address(_chef).call{value : tips}(\"\");\n            _chefTips += tips;\n            return sentTo&&sentFee;\n        }\n        return sentTo;\n    }\n    \n    function removeBet(address addr) private {\n        for (uint256 i = 0; i < BetLUT.length; i++) {\n            if (BetLUT[i] == addr) {\n                delete Bets[addr];\n                BetLUT[i] = BetLUT[BetLUT.length - 1];\n                BetLUT.pop();\n                break;\n            }\n        }\n    }\n    \n    function createBet (uint256 betFor, address ref) public payable {\n        require(msg.value > 0, \"Cant bet for zero\"); require(betFor < 2, \"BetFor 1 or 0\");\n        require(msg.sender != ref, \"!self ref\");require(Bets[msg.sender].value == 0, \"You have a pending bet\");\n        Bets[msg.sender] = Bet({ creator: msg.sender, referrer: ref, value: msg.value, betFor: betFor, time: block.timestamp });\n        BetLUT.push(msg.sender);\n        emit NewBet(msg.sender, betFor, msg.value, block.timestamp);\n    }\n    \n    function cancelBet () public payable {\n        require(Bets[msg.sender].value > 0, \"You have no pending bet\");\n        uint256 fee = Bets[msg.sender].value * _cancelFee/10000;\n        require(send(msg.sender, Bets[msg.sender].value, fee, 0x0000000000000000000000000000000000000000), 'Cancel bet failed');\n        removeBet(msg.sender);\n        emit CancelBet (msg.sender, Bets[msg.sender].betFor, Bets[msg.sender].value);\n    }\n    \n    function takeBet (address with) public payable {\n        require(tx.origin == msg.sender, \"Humans only\");\n        Bet memory bet = Bets[with];\n        require(bet.value > 0, \"Bet is unavailable\");\n        require(msg.value > 0 && msg.value == bet.value, \"Unfair bet\");\n        uint256 tips = bet.value * _tipsRate/10000;\n        uint256 win = bet.value + msg.value;\n        uint256 winNum = toss();\n        if(winNum==bet.betFor) require(send(with, win, tips, bet.referrer), 'Reward failed');//creator win\n        else require(send(msg.sender, win, tips, bet.referrer), 'Reward failed');//joiner win\n        \n        removeBet(with);\n        emit WinBet (with, msg.sender, bet.referrer, bet.betFor, winNum, msg.value, block.timestamp);\n    }\n    \n    function countBets() public view returns (uint256) { return BetLUT.length; }\n    \n    function chefTips() public view returns (uint256) { require(msg.sender==_chef, \"!chef\"); return _chefTips; }\n    function setTipRate(uint256 rate) public { require(msg.sender==_chef, \"!chef\");require(rate <= 1500, \"hey chef! don't be greedy\");_tipsRate = rate; }\n    function setRefRate(uint256 rate) public { require(msg.sender==_chef, \"!chef\");require(rate <= 1500, \"nax 15%\");_refRate = rate; }\n    function setCancelRate(uint256 rate) public { require(msg.sender==_chef, \"!chef\");require(rate <= 300, \"max 3%\");_cancelFee = rate; }\n}"}}}