{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DrakonsDeployment.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/math/SafeMath.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/utils/Pausable.sol\";\n\ncontract DrakonsDeploment is Pausable {\n    using SafeMath for uint256;\n    string public name = \"Drakons Deployment\";\n    \n    uint256 public totalDrakonsDeployed;\n    uint256 public deploymentFee = 45600000 gwei;\n\n    address public CEOAddress;\n    address public CIOAddress;\n    address public COOAddress;\n    address payable CFOAddress;\n    \n    address[] internal drakonmasters;\n    mapping(address => bool) internal deployedDrakon;\n    mapping(address => uint256) internal deployedDrakonID;\n    \n    event SetCIOAddress(address _newAddress);\n    event SetCOOAddress(address _newAddress);\n    event SetCFOAddress(address _newAddress);\n    event RequestForDeployDrakon(address _address, uint256 _drakonID);\n    event UpdateDeploymentFee(address _address, uint256 _newValue);\n    \n    modifier onlyCEO() {\n        require(msg.sender == CEOAddress, \"Drakons Bonus: Only the CEO is allowed to call this function.\");\n        _;\n    }\n\n    modifier onlyCLevel() {\n        require(\n            msg.sender == CEOAddress ||\n            msg.sender == CIOAddress ||\n            msg.sender == COOAddress ||\n            msg.sender == CFOAddress\n        , \"Only accounts with C-Level admin rights are allowed to call this function.\");\n        _;\n    }\n    \n    constructor(address _cooAddress, address _cioAddress, address payable _cfoAddress) public {\n        CEOAddress = msg.sender;\n        CIOAddress = _cioAddress;\n        COOAddress = _cooAddress;\n        CFOAddress = _cfoAddress;\n    }\n\n    function pause() external onlyCEO() {\n        _pause();\n    }\n\n    function unpause() external onlyCEO() {\n        _unpause();\n    }\n\n    function setCIOAddress(address  _newAddress) external onlyCEO() {\n        CIOAddress = _newAddress;\n        emit SetCIOAddress(_newAddress);\n    }\n    \n    function setCOOAddress(address  _newAddress) external onlyCEO() {\n        COOAddress = _newAddress;\n        emit SetCOOAddress(_newAddress);\n    }\n    \n    function setCFOAddress(address payable _newAddress) external onlyCEO() {\n        CFOAddress = _newAddress;\n        emit SetCFOAddress(_newAddress);\n    }\n    \n    function updateDeploymentFee(uint256 _newValue) external onlyCEO() {\n        require(_newValue > 0, \"Drakons Deployment: value must be more than 0.\");\n        deploymentFee = _newValue;\n        \n        emit UpdateDeploymentFee(msg.sender, _newValue);\n        \n    }\n    \n    function requestForDeployment(uint256 _drakonID) external payable whenNotPaused {\n        require(_drakonID > 0, \"Drakons Deployment: Value must be more than 0.\");\n        require(msg.value >= deploymentFee);\n        require(!deployedDrakon[msg.sender], \"Drakons Deployment: Already deployed a Drakon.\");\n        \n        deployedDrakon[msg.sender] = true;\n        //deployedDrakonID[msg.sender] = _drakonID;\n        //totalDrakonsDeployed = totalDrakonsDeployed.add(1);\n        \n        emit RequestForDeployDrakon(msg.sender, _drakonID);\n    }\n    \n    function getBalance() external view onlyCLevel returns (uint256) {\n        return address(this).balance;\n    }\n    \n    function getDeployedDrakon(address _address) view public returns (uint256) {\n        return deployedDrakonID[_address];\n    }\n    \n    function getCFOAddress() view public onlyCLevel() returns (address) {\n        return CFOAddress;\n    }\n    \n    function withdrawBalance() external onlyCLevel() {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"Nothing to withdraw\");\n        CFOAddress.transfer(balance);\n    }\n    \n    function resetDeployedDrakonFor(address _address) external onlyCLevel() {\n        deployedDrakon[_address] = false;\n    }\n    \n}"},"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/GSN/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/utils/Pausable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"}}}