{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Jointer/ethBonus.sol": {
      "content": "// SPDX-License-Identifier: No License (None)\npragma solidity ^0.7.0;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(),\"Not Owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0),\"Zero address not allowed\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    \n}\n\ncontract RequestBonusETH is Ownable {\n    \n    uint256 public fee = 0.00025 ether; // 0.00025 ETH\n    \n    address public system;          // system address may change fee amount\n    \n    address payable public company; // company address receive fee\n\n    mapping(address => address) vaultToken ; // vault => token;\n    \n    mapping (address => uint256) public companyRate;       // % the our company received as fee (with 2 decimals i.e. 1250 = 12.5%)\n    \n    mapping (address => uint256[]) private allowedAmount;   // amount of ETH that have to be send to request bonus\n    \n    mapping (address => address payable) public bonusOwners;\n    \n    mapping (address => bool) public isActive;\n    \n    mapping(address => mapping(address => uint256)) public paidETH; // token => user => paid ETH amount\n    \n    event TokenRequest(address indexed vault, address indexed user, uint256 amount);\n    \n    event CompanyRate(address indexed vault, uint256 rate);\n\n    modifier onlySystem() {\n        require(msg.sender == system || isOwner(), \"Caller is not the system\");\n        _;\n    }\n\n    constructor (address _system, address payable _company) {\n        require(_company != address(0) && _system != address(0));\n        system = _system;\n        company = _company;\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n\n    // set our company rate in % that will be send to it as a fee\n    function setCompanyRate(address vault, uint256 _rate) external onlyOwner returns(bool) {\n        require(_rate <= 10000);\n        companyRate[vault] = _rate;\n        emit CompanyRate(vault, _rate);\n        return true;\n    }\n\n    function setSystem(address _system) external onlyOwner returns(bool) {\n        require(_system != address(0));\n        system = _system;\n        return true;\n    }\n\n    function setFee(uint256 _fee) external onlySystem returns(bool) {\n        fee = _fee;\n        return true;\n    }\n\n    function setCompany(address payable _company) external onlyOwner returns(bool) {\n        require(_company != address(0));\n        company = _company;\n        return true;\n    }\n\n    function getAllowedAmount(address vault) external view returns(uint256[] memory) {\n        return allowedAmount[vault];\n    }\n    \n    function tokenRequest(address vault) public payable {\n        require(isActive[vault], \"Not active\");\n        require(fee < msg.value, \"Not enough value\");\n        address token = vaultToken[vault];\n        require(paidETH[token][msg.sender] == 0, \"You already participated in this bonus program\");\n\n        uint256 value = msg.value - fee;\n        require(isAllowedAmount(vault, value), \"Wrong value\");\n        paidETH[token][msg.sender] = value;\n        uint256 companyPart = value * companyRate[vault] / 10000 + fee;\n        safeTransferETH(company, companyPart);\n        safeTransferETH(bonusOwners[vault], msg.value - companyPart);\n        emit TokenRequest(vault, msg.sender, value);\n    }\n    \n\n    function isAllowedAmount(address vault, uint256 amount) internal view returns(bool) {\n        uint256 len = allowedAmount[vault].length;\n        for (uint256 i = 0; i < len; i++) {\n            if(allowedAmount[vault][i] == amount) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function registerBonus(\n        address vault,\n        address token,              // token contract address\n        address payable bonusOwner, // owner of bonus program (who create bonus program)\n        uint256 rate,               // % the our company received as fee (with 2 decimals i.e. 1250 = 12.5%)\n        uint256[] memory amountETH  // amount of ETH that have to be send to request bonus\n    ) external onlySystem returns(bool) {\n        \n        require(bonusOwners[vault] == address(0) && bonusOwner != address(0) ,\"bonusOwner is not ok\");\n        vaultToken[vault] = token;\n        companyRate[vault] = rate;\n        bonusOwners[vault] = bonusOwner;\n        createOptions(vault, amountETH);\n        isActive[vault] = true;\n        return true;\n    }\n\n    // create set of options by customer (bonusOwner)\n    function createOptions(\n        address vault,              // token contract address\n        uint256[] memory amountETH // amount of ETH that have to be send to request bonus\n    ) public returns(bool) {\n        \n        require(msg.sender == bonusOwners[vault] || msg.sender == system, \"Caller is not the bonusOwners or system\");\n        if(allowedAmount[vault].length > 0) delete allowedAmount[vault];    // delete old allowedAmount if exist\n        allowedAmount[vault] = amountETH;\n        return true;\n    }\n\n    function setActiveBonus(address vault, bool active) external returns(bool) {\n        require(msg.sender == bonusOwners[vault], \"Caller is not the bonusOwners\");\n        isActive[vault] = active;\n        return true;\n    }\n\n    // allow bonus owner change address\n    function changeBonusOwner(address vault, address payable newBonusOwner) external returns(bool) {\n        require(newBonusOwner != address(0));\n        require(msg.sender == bonusOwners[vault], \"Caller is not the bonusOwners\");\n        bonusOwners[vault] = newBonusOwner;\n        return true;\n    }\n}\n"
    }
  }
}