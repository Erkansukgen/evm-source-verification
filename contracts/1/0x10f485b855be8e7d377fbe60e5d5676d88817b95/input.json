{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/presaleOwnerFinalize.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract maindappMaps {\r\n    \r\n    mapping(address => address) public tokenAddrToOwnerAddr;\r\n    mapping(address => address) public presaleAddrToOwnerAddr;\r\n    mapping(address => uint256) public presaleOwnerToIndex;\r\n    mapping(address => uint256) public tokenAddrToIndex; \r\n    \r\n    \r\n}\r\n\r\ncontract Consts {\r\n    uint  constant TOKEN_DECIMALS = 18;\r\n    uint8  constant TOKEN_DECIMALS_UINT8 = 18;\r\n    uint  constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\r\n    \r\n}    \r\ncontract PresaleOwnerFinalize is Consts,Ownable {\r\n    \r\n    bool public votingEnabled = true;\r\n    bool public votingOnlyOwnerEnabled = true;\r\n    bool public votingWhitelistEnabled = true;\r\n    \r\n    address public mainDappAddr;\r\n    address public templateCrowdSaleAddr;\r\n    mapping(uint256 => address) public indexToCaller;\r\n    mapping(address => uint256) public callerToIndex;\r\n    mapping(address => bool) public callerToBool;\r\n    mapping(address => address) public callerToPresaleAddr;\r\n    mapping(address => address) public presaleAddrToCaller;\r\n    mapping(address => address) public callerToOwnerAddr;\r\n    mapping(address => address) public ownerAddrToCaller; \r\n    mapping(uint256 => address) public indexToPresaleAddr;\r\n    mapping(uint256 => address) public indexToOwnerAddr;\r\n    mapping(uint256 => address) public indexToOwner;\r\n    mapping(address => uint256) public ownerToIndex;\r\n    mapping(address => bool) public ownerToBool;\r\n    mapping(address => uint256) public finalizeCallByUserTimestamp;\r\n    mapping(address => uint256) public finalizeCallByOwnerTimestamp;\r\n    mapping(address => uint256) public finalizeCallByWhitelistTimestamp;\r\n    mapping(address => bool) public voterFinalizeEnableFlag;\r\n    mapping(address => uint256) public voterEnableFlagTime;\r\n    mapping(address => bool) public finalized;\r\n    mapping(address => bool) public whitelist;\r\n    mapping(address => string) public whitelistToName;\r\n    mapping(string => address) public whitelistNameToAddr;\r\n    uint256 public callerIndex;\r\n    uint256 public ownerIndex;    \r\n    uint256 public checkEndTime;\r\n    uint256 public voterFinalizeTime = 172800;\r\n    uint256 public minimumTime = 7200;\r\n   \r\n    constructor(address addrMain) public {\r\n        mainDappAddr = addrMain;\r\n    }\r\n    \r\n    using SafeMath for uint256;\r\n       \r\n    function ownerCallsFinalizeRefundMainDapp() public { //only presaleCreator to finalize\r\n\r\n        require(votingOnlyOwnerEnabled, \"ownerCallIsDisabled\");\r\n        (bool _ownerfinalized, bytes memory _finalizedReturn) = address(mainDappAddr).call(abi.encodeWithSignature(\"voterCallsFinalizeRefund(address)\", msg.sender));\r\n        require(_ownerfinalized, \"presaleOwner Emergency Finalization call failed\" );\r\n        indexToOwner[ownerIndex] = msg.sender;\r\n        ownerToIndex[msg.sender] = ownerIndex;\r\n        ownerToBool[msg.sender] = true;\r\n        ownerIndex++;\r\n        finalizeCallByOwnerTimestamp[msg.sender] = block.timestamp;\r\n    }\r\n    \r\n    function whitelistCallsFinalizeRefundMainDapp(address addrPre) public { //only presaleCreator to finalize\r\n\r\n        require(votingWhitelistEnabled, \"whitelistCallIsDisabled\");\r\n        require(whitelist[msg.sender],\"not whitelisted\");\r\n        address presaleOwnerAddress = maindappMaps(mainDappAddr).presaleAddrToOwnerAddr(addrPre);\r\n        (bool _ownerfinalized, bytes memory _finalizedReturn) = address(mainDappAddr).call(abi.encodeWithSignature(\"voterCallsFinalizeRefund(address)\", presaleOwnerAddress));\r\n        require(_ownerfinalized, \"whitelist Emergency Finalization call failed\" );\r\n        finalized[addrPre] = true;\r\n        indexToCaller[callerIndex] = msg.sender;\r\n        callerToIndex[msg.sender] = callerIndex;\r\n        callerToBool[msg.sender] = true;\r\n        indexToPresaleAddr[callerIndex] = addrPre;\r\n        indexToOwnerAddr[callerIndex] = presaleOwnerAddress;\r\n        callerToPresaleAddr[msg.sender] = addrPre;\r\n        presaleAddrToCaller[addrPre] = msg.sender;\r\n        callerToOwnerAddr[msg.sender] = presaleOwnerAddress;\r\n        ownerAddrToCaller[presaleOwnerAddress] = msg.sender;\r\n        callerIndex++;        \r\n        finalizeCallByUserTimestamp[addrPre] = block.timestamp;\r\n        finalizeCallByWhitelistTimestamp[addrPre] = block.timestamp;\r\n    }\r\n    \r\n    function voterCallsFinalizeRefundMainDapp(address addrPre) public { //anyone to be able to finalize after voterFinalizeTime\r\n    \r\n        require(!finalized[addrPre],\"already finalized!\");\r\n        require(votingEnabled, \"voterCallIsDisabled\");        \r\n\r\n        (bool _endtime, bytes memory _endtimeFetch) = address(addrPre).call(abi.encodeWithSignature(\"presaleEndTime()\"));\r\n        require(_endtime, \"presale address is incorrect... No endTime observed\" );\r\n        uint256 endtimeReturn = abi.decode (_endtimeFetch, (uint256));\r\n        require((block.timestamp > endtimeReturn.add(voterFinalizeTime)), \"voter cannot finalze if time is not greater than presale _endtime + voterFinalizeTime\");\r\n\r\n        address presaleOwnerAddress = maindappMaps(mainDappAddr).presaleAddrToOwnerAddr(addrPre);\r\n        (bool _voterfinalized, bytes memory _finalizedReturn) = address(mainDappAddr).call(abi.encodeWithSignature(\"voterCallsFinalizeRefund(address)\", presaleOwnerAddress));\r\n        require(_voterfinalized, \"voter Emergency Finalization call failed\" );\r\n        \r\n        finalized[addrPre] = true;\r\n        indexToCaller[callerIndex] = msg.sender;\r\n        callerToIndex[msg.sender] = callerIndex;\r\n        callerToBool[msg.sender] = true;\r\n        indexToPresaleAddr[callerIndex] = addrPre;\r\n        indexToOwnerAddr[callerIndex] = presaleOwnerAddress;\r\n        callerToPresaleAddr[msg.sender] = addrPre;\r\n        presaleAddrToCaller[addrPre] = msg.sender;\r\n        callerToOwnerAddr[msg.sender] = presaleOwnerAddress;\r\n        ownerAddrToCaller[presaleOwnerAddress] = msg.sender;\r\n        callerIndex++;        \r\n        finalizeCallByUserTimestamp[addrPre] = block.timestamp;\r\n    }\r\n    \r\n    \r\n    function voterCallsFinalizeRefundMainDappHardCap(address addrPre) public { //anyone to be able to finalize after voterFinalizeTime if voterFinalizeEnableFlag is enabled\r\n        \r\n        require(!finalized[addrPre],\"already finalized!\");\r\n        require(votingEnabled, \"voterCallIsDisabled\");\r\n        require(voterFinalizeEnableFlag[addrPre], \"voter Finalize flag is disabled\");\r\n        require(voterEnableFlagTime[addrPre] > 0, \"voterEnableFlagTime not setup\");\r\n        require((block.timestamp > voterEnableFlagTime[addrPre].add(voterFinalizeTime)), \"voter cannot finalze if time is not greater than voterEnableFlagTime + voterFinalizeTime\");\r\n\r\n        address presaleOwnerAddress = maindappMaps(mainDappAddr).presaleAddrToOwnerAddr(addrPre);\r\n        (bool _voterfinalized, bytes memory _finalizedReturn) = address(mainDappAddr).call(abi.encodeWithSignature(\"voterCallsFinalizeRefund(address)\", presaleOwnerAddress));\r\n        require(_voterfinalized, \"voter Emergency Finalization call by enable flag failed\" );\r\n        \r\n        finalized[addrPre] = true;\r\n        indexToCaller[callerIndex] = msg.sender;\r\n        callerToIndex[msg.sender] = callerIndex;\r\n        callerToBool[msg.sender] = true;\r\n        indexToPresaleAddr[callerIndex] = addrPre;\r\n        indexToOwnerAddr[callerIndex] = presaleOwnerAddress;\r\n        callerToPresaleAddr[msg.sender] = addrPre;\r\n        presaleAddrToCaller[addrPre] = msg.sender;\r\n        callerToOwnerAddr[msg.sender] = presaleOwnerAddress;\r\n        ownerAddrToCaller[presaleOwnerAddress] = msg.sender;\r\n        callerIndex++;        \r\n        finalizeCallByUserTimestamp[addrPre] = block.timestamp;\r\n    }\r\n    \r\n    \r\n    \r\n    function CheckBlockTimestamp() public view returns (uint256){\r\n         \r\n         \r\n        return block.timestamp;\r\n         \r\n     \r\n    }    \r\n    \r\n    \r\n    function changeVoterFinalizeTime(uint256 _newVoterTime) public onlyOwner {\r\n         \r\n        require((_newVoterTime >= minimumTime), \"_newvoterTime must be >= minimum time\");\r\n         \r\n        voterFinalizeTime = _newVoterTime;\r\n         \r\n    }   \r\n    \r\n    function changeVoterMinTime(uint256 _newMinTime) public onlyOwner {\r\n         \r\n        require((_newMinTime >= 0), \"_newMinTime must be >= 0\");\r\n         \r\n        minimumTime = _newMinTime;\r\n         \r\n    } \r\n\r\n    function disableVoterCall() public onlyOwner {\r\n        \r\n        votingEnabled = false;\r\n        \r\n        \r\n    }\r\n    \r\n\r\n    function enableVoterCall() public onlyOwner {\r\n        \r\n        votingEnabled = true;\r\n        \r\n        \r\n    }\r\n    \r\n    function disableWhitelistCall() public onlyOwner {\r\n        \r\n        votingWhitelistEnabled = false;\r\n        \r\n        \r\n    }\r\n    \r\n\r\n    function enableWhitelistCall() public onlyOwner {\r\n        \r\n        votingWhitelistEnabled = true;\r\n        \r\n        \r\n    }\r\n\r\n    function disableOwnerCall() public onlyOwner {\r\n        \r\n        votingOnlyOwnerEnabled = false;\r\n        \r\n        \r\n    }\r\n    \r\n\r\n    function enableOwnerCall() public onlyOwner {\r\n        \r\n        votingOnlyOwnerEnabled = true;\r\n        \r\n        \r\n    }\r\n    \r\n    function updateMaindappAddr(address _newMaindapp) public onlyOwner {\r\n        \r\n        mainDappAddr = _newMaindapp;\r\n        \r\n        \r\n        \r\n    }\r\n    \r\n    function addToWhitelist(address _whitelistAddr, string memory _name) onlyOwner public {\r\n        \r\n        \r\n        whitelist[_whitelistAddr] = true;\r\n        \r\n        whitelistToName[_whitelistAddr] = _name;\r\n        whitelistNameToAddr[_name] = _whitelistAddr;\r\n        \r\n    }\r\n        \r\n    function removeFromWhitelist(address _whitelistAddr) onlyOwner public {\r\n        \r\n        \r\n        whitelist[_whitelistAddr] = false;\r\n        \r\n        \r\n        \r\n    }\r\n\r\n    function voterFinalizeEnable(address addrPre) public {\r\n        \r\n        require(!voterFinalizeEnableFlag[addrPre], \"already enabled!\");\r\n        \r\n        (bool _closed, bytes memory _closeCheck) = address(addrPre).call(abi.encodeWithSignature(\"hasClosed()\"));\r\n        require(_closed, \"presale not closed\");\r\n        bool presaleClosed = abi.decode (_closeCheck, (bool));\r\n        \r\n        require(presaleClosed,\"presale has not finished yet!\");\r\n\r\n        \r\n        voterFinalizeEnableFlag[addrPre] = true;\r\n        voterEnableFlagTime[addrPre] = block.timestamp;\r\n        \r\n    }\r\n    \r\n    function getVoterFinalizeEnableFlag(address addrPre) public view returns(bool) {\r\n          return voterFinalizeEnableFlag[addrPre];\r\n    }    \r\n}\r\n\r\n"
    }
  }
}