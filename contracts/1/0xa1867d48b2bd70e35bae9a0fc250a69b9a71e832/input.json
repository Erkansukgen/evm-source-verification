{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Untitled.sol": {
      "content": "pragma solidity ^0.6.1;\n\ninterface MinereumContract {\n  function transfer(address _to, uint256 _value) external;\n}\n\ninterface External1 {\n  function mintNewCoins(uint256 _amount) external;\n  function setBondOwner() external;\n}\n\ninterface Genesis {\n\tfunction availableBalanceOf ( address _address ) external view returns ( uint256 Balance );\n}\n\ncontract MinereumCryptoBond\n{\n\t\nuint256 public OneYearYield = 30;\nuint256 public ThreeYearsYield = 40;\nuint256 public FiveYearsYield = 50;\n\t\nuint256 public OneYearBondCount = 0;\nuint256 public ThreeYearsBondCount = 0;\nuint256 public FiveYearsBondCount = 0;\n\nuint256 public OneYearBondBuiltCount = 0;\nuint256 public ThreeYearsBondBuiltCount = 0;\nuint256 public FiveYearsBondBuiltCount = 0;\n\nuint256 public MNEOneYearBondsCount = 0;\nuint256 public MNEThreeYearsBondsCount = 0;\nuint256 public MNEFiveYearsBondsCount = 0;\n\nuint256 public newMintedCoins = 0;\nuint256 public paidBondCoins = 0;\n\naddress[] public participatedAddress;\n\nmapping (address => uint256[]) public BondYearsType;\nmapping (address => uint256[]) public BondMNE;\nmapping (address => uint256[]) public BondStartDate;\nmapping (address => uint256[]) public BondYield;\n\nmapping (address => uint256[]) public BondPayoutsBondID;\nmapping (address => uint256[]) public BondPayoutsMNE;\nmapping (address => uint256[]) public BondPayoutsDate;\nmapping (address => bool[]) public BondPayoutsPaid;\nmapping (address => uint[]) public BondPayoutsPaidDate;\n\nmapping (address => uint[]) public BonusDay;\nmapping (address => address[]) public BonusFrom;\nmapping (address => uint[]) public BonusAmount;\nmapping (address => bool[]) public BonusPaid;\nmapping (address => uint[]) public BonusPaidDate;\n\naddress[] public bonusAddress;\nuint256 overallBonus = 0;\nuint256 amountBonusPaid = 0;\n\nuint256 ReferrerRate = 15;\n\nMinereumContract public mneContract;\nExternal1 public external1;\nGenesis public gn;\naddress public updaterAddress = 0x0000000000000000000000000000000000000000;\nbool public BlockPayouts = false;\nbool public BlockBonds = false;\n\nconstructor() public\n{\n\tsetUpdater();\n\tmneContract = MinereumContract(0x426CA1eA2406c07d75Db9585F22781c096e3d0E0);\n\tgn = Genesis(0xa6be27538A28114Fe03EB7ADE9AdfE53164f2a4c);\n}\n\nfunction updateVars(uint256 _OneYearYield, uint256 _ThreeYearsYield, uint256 _FiveYearsYield, bool _BlockPayouts, bool _BlockBonds, uint256 _ReferrerRate) public\n{\n\tif (msg.sender == updaterAddress)\n\t{\n\t\tOneYearYield = _OneYearYield;\n\t\tThreeYearsYield = _ThreeYearsYield;\n\t\tFiveYearsYield = _FiveYearsYield;\n\t\tBlockPayouts = _BlockPayouts;\n\t\tBlockBonds = _BlockBonds;\n\t\tReferrerRate = _ReferrerRate;\n\t}\n\telse\n\t{\n\t\trevert();\n\t}\n}\n\nfunction setUpdater() public {if (updaterAddress == 0x0000000000000000000000000000000000000000) updaterAddress = msg.sender; else revert();}\nfunction updateExternal1(address _address) public {if (tx.origin == updaterAddress) {external1 = External1(_address); external1.setBondOwner(); } else revert();}\nfunction updateGenesis(address _address) public {if (tx.origin == updaterAddress) {gn = Genesis(_address); } else revert();}\nfunction updateMneContract(address _address) public {if (tx.origin == updaterAddress) {mneContract = MinereumContract(_address); } else revert();}\n\nfunction BondYearsTypeGetAt(address _address, uint i) public view returns (uint256) { return BondYearsType[_address][i]; }\nfunction BondMNEGetAt(address _address, uint i) public view returns (uint256) { return BondMNE[_address][i]; }\nfunction BondStartDateGetAt(address _address, uint i) public view returns (uint256) { return BondStartDate[_address][i]; }\nfunction BondYieldGetAt(address _address, uint i) public view returns (uint256) { return BondYield[_address][i]; }\n\nfunction BondPayoutsBondIDGetAt(address _address, uint i) public view returns (uint256) { return BondPayoutsBondID[_address][i]; }\nfunction BondPayoutsMNEGetAt(address _address, uint i) public view returns (uint256) { return BondPayoutsMNE[_address][i]; }\nfunction BondPayoutsDateGetAt(address _address, uint i) public view returns (uint256) { return BondPayoutsDate[_address][i]; }\nfunction BondPayoutsPaidGetAt(address _address, uint i) public view returns (bool) { return BondPayoutsPaid[_address][i]; }\nfunction BondPayoutsPaidDateGetAt(address _address, uint i) public view returns (uint256) { return BondPayoutsPaidDate[_address][i]; }\n\nfunction BondYearsTypeLength(address _address) public view returns (uint256) { return BondYearsType[_address].length; }\nfunction BondPayoutsBondIDLength(address _address) public view returns (uint256) { return BondPayoutsBondID[_address].length; }\nfunction BonusDayLength(address _address) public view returns (uint256) { return BonusDay[_address].length; }\nfunction participatedAddressLength() public view returns (uint256) { return participatedAddress.length; }\n\n\nfunction TransferAllFundsOut(address _address, uint256 _amount) public\n{\t\t\n\tif (msg.sender == updaterAddress)\n\t{\n\t\tmneContract.transfer(_address, _amount); //in case of migration to another contract\t\n\t}\n\telse\n\t{\n\t\trevert();\n\t}\n}\n\nfunction GetBonds(address _address) public view returns (uint256[] memory _BondIDs, uint256[] memory _BondYearsType, uint256[] memory _BondMNE, uint256[] memory _BondStartDate, uint256[] memory _BondYield)\n{\n\t_BondIDs = new uint[](BondYearsType[_address].length);\n\t_BondYearsType = BondYearsType[_address];\n\t_BondMNE = BondMNE[_address];\n\t_BondStartDate = BondStartDate[_address];\n\t_BondYield = BondYield[_address];\n\t\n\tuint i = 0;\n\twhile (i < BondYearsType[_address].length)\n\t{\n\t\t_BondIDs[i] = i;\n\t\ti++;\n\t}\n}\n\nfunction GetPayouts(address _address) public view returns (uint256[] memory _BondPayoutsBondID, uint256[] memory _BondPayoutsMNE, uint256[] memory _BondPayoutsDate, bool[] memory _BondPayoutsPaid, uint[] memory _BondPayoutsPaidDate)\n{\n\t_BondPayoutsBondID = BondPayoutsBondID[_address];\n\t_BondPayoutsMNE = BondPayoutsMNE[_address];\n\t_BondPayoutsDate = BondPayoutsDate[_address];\n\t_BondPayoutsPaid = BondPayoutsPaid[_address];\n\t_BondPayoutsPaidDate = BondPayoutsPaidDate[_address];\n}\n\nfunction GetTotalBonds() public view returns (uint256)\n{\n\treturn OneYearBondCount + ThreeYearsBondCount + FiveYearsBondCount;\n}\n\nfunction GetTotalMNE() public view returns (uint256)\n{\n\treturn MNEOneYearBondsCount + MNEThreeYearsBondsCount + MNEFiveYearsBondsCount;\n}\n\t\nfunction externalFunction(address _sender, uint256 _mneAmount, address[] memory _addressList, uint256[] memory _uintList) public {\n\t\n\tif (msg.sender != address(mneContract)) revert();\n\t\n\tif (BlockBonds) revert('Bonds Blocked');\t\n\t\n\tBondYearsType[_sender].push(_uintList[0]);\n\tBondMNE[_sender].push(_mneAmount);\n\tBondStartDate[_sender].push(now);\n\n\tif (BondYearsType[_sender].length == 0)\t\n\t\tparticipatedAddress.push(_sender);\n\t\n\tif (_uintList[0] == 1)\n\t{\n\t\tBondYield[_sender].push(OneYearYield);\n\t\t\n\t\tOneYearBondCount++;\n\t\tMNEOneYearBondsCount += _mneAmount;\n\t}\n\telse if (_uintList[0] == 3)\n\t{\n\t\tBondYield[_sender].push(ThreeYearsYield);\n\t\t\n\t\tThreeYearsBondCount++;\n\t\tMNEThreeYearsBondsCount += _mneAmount;\n\t}\n\telse if (_uintList[0] == 5)\n\t{\n\t\tBondYield[_sender].push(FiveYearsYield);\n\t\t\n\t\tFiveYearsBondCount++;\n\t\tMNEFiveYearsBondsCount += _mneAmount;\n\t}\n\telse\n\t{\n\t\trevert('invalid bond');\n\t}\t\n\t\n\t\n\tif (_addressList.length > 1)\n\t{\n\t\tif (_sender == _addressList[1] || _addressList[1] == address(this) || _addressList[1] == address(mneContract)) revert('invalid referal');\n\t\t\n\t\tuint bonusAmountReferrer = _mneAmount * ReferrerRate / 100;\n\t\t\n\t\tBonusDay[_addressList[1]].push(now);\n\t\tBonusFrom[_addressList[1]].push(_sender);\n\t\tBonusAmount[_addressList[1]].push(bonusAmountReferrer);\n\t\tBonusPaid[_addressList[1]].push(false);\n\t\tBonusPaidDate[_addressList[1]].push(0);\n\t\t\n\t\tif (BonusDay[_addressList[1]].length == 0)\n\t\t\tbonusAddress.push(_addressList[1]);\n\t\n\t\toverallBonus += bonusAmountReferrer;\n\t}\t\n}\n\nfunction BuildBond(address _address, uint256 _bondID) public\n{\n\tif (_bondID + 1 > BondYearsType[_address].length) revert('invalid id');\n\t\n\t\n\tif (BondPayoutsBondID[_address].length > 0)\n\t{\n\t\tuint i = 0;\t\n\t\twhile (i < BondPayoutsBondID[_address].length)\n\t\t{\n\t\t\tif (BondPayoutsBondID[_address][i] == _bondID)\n\t\t\t\trevert('Bond already built');\n\t\t\ti++;\n\t\t}\t\n\t}\n\t\n\tif (BondYearsType[_address][_bondID] == 1)\n\t{\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + 31556926);\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID]);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + 31556926);\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tOneYearBondBuiltCount++;\n\t}\n\telse if (BondYearsType[_address][_bondID] == 3)\n\t{\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + 31556926);\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + (31556926 * 2));\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + (31556926 * 3));\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID]);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + (31556926 * 3));\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tThreeYearsBondBuiltCount++;\n\t}\n\telse if (BondYearsType[_address][_bondID] == 5)\n\t{\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + 31556926);\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + (31556926 * 2));\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + (31556926 * 3));\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + (31556926 * 4));\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID] * BondYield[_address][_bondID] / 100);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + (31556926 * 5));\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\t\t\n\t\t\n\t\tBondPayoutsBondID[_address].push(_bondID);\n\t\tBondPayoutsMNE[_address].push(BondMNE[_address][_bondID]);\n\t\tBondPayoutsDate[_address].push(BondStartDate[_address][_bondID] + (31556926 * 5));\n\t\tBondPayoutsPaid[_address].push(false);\n\t\tBondPayoutsPaidDate[_address].push(0);\n\t\t\n\t\tFiveYearsBondBuiltCount++;\n\t}\n\telse\n\t{\n\t\trevert('invalid bond');\n\t}\n}\n\nfunction PayoutAllValidBondPayouts(address _address) public {\n\tuint i = 0;\n\twhile (i < BondPayoutsBondID[msg.sender].length)\n\t{\n\t\tif (now >= BondPayoutsDate[msg.sender][i] && !BondPayoutsPaid[msg.sender][i])\n\t\t\tPayoutBond(BondPayoutsBondID[msg.sender][i], _address);\n\t\ti++;\n\t}\n}\n\nfunction PayoutBond(uint _bondID, address _address) public {\n\tif (BlockPayouts) revert('payouts blocked'); //in case of migration to another contract\n\t\n\tif (BondPayoutsBondID[msg.sender].length == 0) revert('No Bonds Available');\n\t\n\tuint i = 0;\n\tuint payoutID = 323232323232;\n\twhile (i < BondPayoutsBondID[msg.sender].length)\n\t{\n\t\tif (BondPayoutsBondID[msg.sender][i] == _bondID)\n\t\t\tpayoutID = i;\n\t\ti++;\n\t}\n\t\n\tif (payoutID == 323232323232) revert('Bond ID not found');\n\t\n\tif (BondPayoutsPaid[msg.sender][payoutID]) revert('Bond already paid');\n\t\n\tif (block.timestamp < BondPayoutsDate[msg.sender][payoutID]) revert('Payout Date not reached yet');\n\t\n\tif (block.timestamp >= BondPayoutsDate[msg.sender][payoutID] && !BondPayoutsPaid[msg.sender][payoutID])\n\t{\n\t\tuint coinsToMint = 0;\n\t\t\n\t\tif (gn.availableBalanceOf(address(this)) < BondPayoutsMNE[msg.sender][payoutID])\n\t\t{\n\t\t\tcoinsToMint = BondPayoutsMNE[msg.sender][payoutID] - gn.availableBalanceOf(address(this));\n\t\t\texternal1.mintNewCoins(coinsToMint);\n\t\t}\n\t\t\n\t\tuint amountToPay = BondPayoutsMNE[msg.sender][payoutID];\n\t\t\n\t\tif (_address != 0x0000000000000000000000000000000000000000)\t\t\t\n\t\t\tmneContract.transfer(_address, amountToPay);\n\t\telse\n\t\t\tmneContract.transfer(msg.sender, amountToPay);\n\t\t\n\t\tnewMintedCoins += coinsToMint;\n\t\tpaidBondCoins += amountToPay;\n\t\t\n\t\tBondPayoutsPaid[msg.sender][payoutID] = true;\n\t\tBondPayoutsPaidDate[msg.sender][payoutID] = now;\n\t}\n\telse\n\t{\n\t\trevert('Payout Date Not Valid');\n\t}\n}\n\nfunction PayoutBonus(address _address, uint i) public {\n\tif (i >= BonusAmount[msg.sender].length) revert('no bonus index found');\t\n\t\n\tif (BonusAmount[msg.sender][i] > 0 && now >= (BonusDay[msg.sender][i] + 31556926) && !BonusPaid[msg.sender][i])\n\t{\n\t\tif (gn.availableBalanceOf(address(this)) < BonusAmount[msg.sender][i])\n\t\t{\n\t\t\tuint coinsToMint = BonusAmount[msg.sender][i] - gn.availableBalanceOf(address(this));\n\t\t\texternal1.mintNewCoins(coinsToMint);\n\t\t}\t\t\n\t\t\n\t\tif (_address != 0x0000000000000000000000000000000000000000)\t\t\t\n\t\t\tmneContract.transfer(_address, BonusAmount[msg.sender][i]);\n\t\telse\n\t\t\tmneContract.transfer(msg.sender, BonusAmount[msg.sender][i]);\t\n\t\t\n\t\tBonusPaidDate[msg.sender][i] = now;\n\t\tBonusPaid[msg.sender][i] = true;\t\t\n\t\tamountBonusPaid += BonusAmount[msg.sender][i];\t\t\n\t}\n\telse\n\t{\n\t\trevert('Invalid bonus payout');\n\t}\n}\n\nfunction OpenBonusValue(address _address) public view returns (uint256) \n{\n\tuint256 openBonusValue = 0;\n\tuint256 i = 0;\n\t\n\tif (BonusDay[_address].length == 0) return 0;\n\t\n\twhile (i < BonusDay[_address].length)\n\t{\n\t\tif (!BonusPaid[_address][i])\n\t\t\topenBonusValue += BonusAmount[_address][i];\t\t\n\t\ti++;\n\t}\t\n\treturn openBonusValue; \n}\n}"
    }
  }
}