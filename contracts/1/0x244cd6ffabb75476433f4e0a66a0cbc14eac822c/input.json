{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/mutlCall.sol":{"content":"pragma solidity ^0.8.0;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC1155Receiver {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface INFTAddress {\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) external;\n    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external;\n}\n\ncontract NFTCaller is IERC721Receiver, IERC1155Receiver {\n    mapping(address => bool) public owners;\n\n    constructor(address[] memory owners_){\n        for (uint256 i; i < owners_.length; i++) {\n            owners[owners_[i]] = true;\n        }\n    }\n\n    function mintMul(address nftAddress, uint256 txAmount, uint256 mintAmount, uint256 price, bytes calldata data, uint256 e) public onlyOwner payable {\n        for (uint256 i; i < txAmount; i++) {\n            (bool s,) = nftAddress.call{value : price * mintAmount}(data);\n            require(s);\n        }\n\n        if (e > 0) {\n            if (address(this).balance > e) { \n                block.coinbase.transfer(e);\n            } else {\n                block.coinbase.transfer(address(this).balance);\n            }\n        }\n\n        if (address(this).balance > 0) {\n            payable(msg.sender).transfer(address(this).balance);\n        }\n    }\n\n    function transferSelfNFTs(address nftAddress, address to, uint256[] calldata tokenIDs) public onlyOwner {\n        for (uint256 i; i < tokenIDs.length; i++) {\n            INFTAddress(nftAddress).transferFrom(address(this), to, tokenIDs[i]);\n        }\n    }\n\n    function transferSelfNFT1155(address nftAddress, address to, uint256[] calldata tokenIDs, uint256 amount) public onlyOwner {\n        for (uint256 i; i < tokenIDs.length; i++) {\n            INFTAddress(nftAddress).safeTransferFrom(address(this), to, tokenIDs[i], amount, \"\");\n        }\n    }\n\n    function transferSelfNFT1155Batch(address nftAddress, address to, uint256[] calldata tokenIDs, uint256[] calldata amounts) public onlyOwner {\n        INFTAddress(nftAddress).safeBatchTransferFrom(address(this), to, tokenIDs, amounts, \"\");\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external pure override returns (bytes4){\n        IERC721Receiver i;\n        return i.onERC721Received.selector;\n    }\n\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        IERC1155Receiver i;\n        return i.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        IERC1155Receiver i;\n        return i.onERC1155BatchReceived.selector;\n    }\n\n    receive() external payable {\n\n    }\n\n    modifier onlyOwner(){\n        require(owners[msg.sender], \"not owner\");\n        _;\n    }\n}"}}}