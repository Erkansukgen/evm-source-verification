{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Interfaces/IAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.3;\npragma experimental ABIEncoderV2;\n\ninterface ILendingPoolAddressesProvider {\n    \n    event LendingPoolUpdated(address indexed newAddress);\n    \n    function getLendingPool() external view returns (address);\n    \n    function getPriceOracle() external view returns (address);\n    \n    function getLendingRateOracle() external view returns (address);\n    \n    function getAddress(bytes32 id) external view returns (address);\n    \n}   \n\ninterface IProtocolDataProvider {\n  struct TokenData {\n    string symbol;\n    address tokenAddress;\n  }\n\n  function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n  function getAllReservesTokens() external view returns (TokenData[] memory);\n  function getAllATokens() external view returns (TokenData[] memory);\n  function getReserveConfigurationData(address asset) external view returns (uint256 decimals, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus, uint256 reserveFactor, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowRateEnabled, bool isActive, bool isFrozen);\n  function getReserveData(address asset) external view returns (uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp);\n  function getUserReserveData(address asset, address user) external view returns (uint256 currentATokenBalance, uint256 currentStableDebt, uint256 currentVariableDebt, uint256 principalStableDebt, uint256 scaledVariableDebt, uint256 stableBorrowRate, uint256 liquidityRate, uint40 stableRateLastUpdated, bool usageAsCollateralEnabled);\n  function getReserveTokensAddresses(address asset) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);\n}\n\n\ninterface ILendingPool {\n    \n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n    \n    function withdraw(address token, uint256 amount, address destination) external returns (uint256);\n    \n    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external;\n    \n    function repay(address asset, uint256 amount, uint256 rateMode, address onBehalfOf) external returns (uint256);\n    \n    function getUserAccountData(address user) external view returns (\n        uint256 totalCollateralETH, \n        uint256 totalDebtETH, \n        uint256 availableBorrowsETH, \n        uint256 currentLiquidationThreshold, \n        uint256 ltv,\n        uint256 healthFactor\n    );\n    \n    function getReservesList() external view returns (address[] memory);\n    \n    function getAssetsPrices(address[] calldata _assets) external view returns(uint256[] memory);\n}\n\ninterface IDebtToken {\n    \n    function approveDelegation(address delegatee, uint256 amount) external;\n    \n    function borrowAllowance(address fromUser, address toUser) external view returns (uint256);\n    \n    function mint(\n        address user,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 rate\n    ) external returns (bool);\n    \n    function principalBalanceOf(address user) external view returns (uint256);\n    \n    function getUserStableRate(address user) external view returns (uint256);\n\n    function getAverageStableRate() external view returns (uint256);\n\n    function getSupplyData() external view returns (uint256, uint256, uint256, uint40);\n    \n    function scaledBalanceOf(address user) external view returns (uint256);\n    \n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n    \n    function scaledTotalSupply() external view returns (uint256);\n    \n}"
    },
    "contracts/Interfaces/IMoloch.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.3;\n\ninterface IMOLOCH { // brief interface for moloch dao v2\n\n    function cancelProposal(uint256 proposalId) external;\n    \n    function depositToken() external view returns (address);\n    \n    function getProposalFlags(uint256 proposalId) external view returns (bool[6] memory);\n    \n    function totalLoot() external view returns (uint256); \n    \n    function totalShares() external view returns (uint256); \n    \n    function getUserTokenBalance(address user, address token) external view returns (uint256);\n    \n    function members(address user) external view returns (address, uint256, uint256, bool, uint256, uint256);\n    \n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) external; \n\n    function submitProposal(\n        address applicant,\n        uint256 sharesRequested,\n        uint256 lootRequested,\n        uint256 tributeOffered,\n        address tributeToken,\n        uint256 paymentRequested,\n        address paymentToken,\n        string calldata details\n    ) external returns (uint256);\n    \n    function tokenWhitelist(address token) external view returns (bool);\n\n    function updateDelegateKey(address newDelegateKey) external; \n    \n    function userTokenBalances(address user, address token) external view returns (uint256);\n\n    function withdrawBalance(address token, uint256 amount) external;\n}"
    },
    "contracts/PoolPartyAaveMinion.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.3;\n\nimport \"./Interfaces/IMoloch.sol\";\nimport \"./Interfaces/IAave.sol\";\n\ninterface IERC20 { // interface for erc20 approve/transfer\n    function balanceOf(address who) external view returns (uint256);\n    \n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\n\ncontract ReentrancyGuard { // call wrapper for reentrancy check\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\n\n\ncontract PoolPartyAaveMinion is ReentrancyGuard {\n\n    IMOLOCH public moloch;\n\n    ILendingPoolAddressesProvider public provider = ILendingPoolAddressesProvider(address(AAVE_ADDRESS_PROVIDER));\n    IProtocolDataProvider public data = IProtocolDataProvider(address(aaveData));\n    ILendingPool public pool = ILendingPool(aavePool);\n    \n    address public dao; // dao that manages minion \n    address public aavePool; // Initial Aave Lending Pool address\n    address public aaveData; // Initial Aave Data address\n    address private feeAddress; //address for collecting fees\n    \n    uint256 public minionId; //Id to help identify minion\n    uint256 public feeFactor; // Fee BPs\n    uint256 public minHealthFactor; // Minimum health factor for borrowing\n    uint256[] public proposals; // Array of proposals\n    \n    string public desc; //description of minion\n    bool private initialized; // internally tracks deployment under eip-1167 proxy pattern\n    \n    address public constant AAVE_ADDRESS_PROVIDER = 0xd05e3E715d945B59290df0ae8eF85c1BdB684744; // matic\n    uint256 public constant FEE_BASE = 10000; // Fee Factor in BPs 1/10000\n    uint256 public constant WITHDRAW_FACTOR = 10; // Fee \n\n    mapping(uint256 => Deposit) public deposits; // proposalId => Funding\n    mapping(uint256 => Loan) public loans; // loans taken out\n    mapping(uint256 => CollateralWithdraw) public collateralWithdraws; // proposalID => withdraws of collateral\n    mapping(uint256 => LoanRepayment) public loanRepayments; // proposalID => loan repayments\n    mapping(uint256 => Action) public actions; // proposalID => actions\n    mapping(address => int) public earningsPeg; // peg for earnings and fees \n    mapping(address => bool) public rewardsOn; // tracks rewards taken out by users by token\n    mapping(address => mapping(address => uint256)) public aTokenRedemptions; // tracks rewards taken out by users by token\n    \n    struct Deposit {\n        address token;\n        address proposer;\n        uint256 paymentRequested;\n        bool executed;\n    }\n    \n    struct Loan {\n        address token;\n        address proposer;\n        address onBehalfOf;\n        uint256 amount;\n        uint256 rateMode; // 1 for stableDebt, 2 for variableDebt\n        bool executed;\n    }\n    \n    struct CollateralWithdraw {\n        address proposer;\n        address token;\n        address destination;\n        uint256 amount;\n        bool executed;\n    }\n    \n    struct LoanRepayment {\n        address proposer;\n        address token;\n        address onBehalfOf;\n        uint256 amount;\n        uint256 rateMode;\n        bool executed;\n    }\n    \n    struct Action {\n        address proposer;\n        address token;\n        uint256 amount;\n        uint16 actionType; // 1 - DAO withdraw, 2 - Earnings toggle\n        bool executed;\n    }\n\n    event ProposeDeposit(uint256 proposalId, address proposer, address token, uint256 amount);\n    event DepositExecuted(uint256 proposalId);\n    event ProposeLoan(uint256 proposalId, address proposer, address beneficiary, address token, uint256 amount, uint256 rateMode);\n    event LoanExecuted(uint256 proposalId);\n    event ProposeCollateralWithdraw(uint256 proposalId, address proposer, address token, uint256 amount, address destination);\n    event CollateralWithdrawExecuted(uint256 proposalId, uint256 amount);\n    event ProposeRepayLoan(uint256 proposalId, address proposer, address token, uint256 amount, uint256 rateMode, address onBehalfOf);\n    event RepayLoanExecuted(uint256 proposalId);\n    event WithdrawToDAO(uint256 proposalId, address proposer, address token, uint256 amount);\n    event EarningsWithdraw(address member, address token, uint256 earnings, address destination);\n    event ProposeToggleEarnings(uint256 proposalId, address proposer, address token);\n    event EarningsToggled(uint256 proposalId, bool status);\n    event WithdrawToMinion(address targetDao, address token, uint256 amount);\n    event Canceled(uint256 proposalId, uint256 proposalType, string functionCaller);\n\n    \n    modifier memberOnly() {\n        require(isMember(msg.sender), \"AP::not member\");\n        _;\n    }\n    \n    /**\n     * @dev Takes place of constructor function with EIP-1167\n     * @param _dao The address of the child dao joining UberHaus\n     * @param _aavePool The initial AavePool interface address\n     * @param _aaveData The initial AaveDataProvider interface address\n     * @param _minionId Helps to track minion\n     * @param _feeAddress The address recieving fees\n     * @param _feeFactor Fee in basis points\n     * @param _minHealthFactor Minimum Aave Health Factor in Wei \n     * @param _desc Name or description of the minion\n     */  \n    \n    function init(\n        address _dao, \n        address _feeAddress,\n        address _aavePool,\n        address _aaveData,\n        uint256 _minionId,\n        uint256 _feeFactor,\n        uint256 _minHealthFactor,\n        string memory _desc\n    )  public {\n        require(_dao != address(0), \"AP::no 0x address\");\n        require(!initialized, \"AP::already initialized\");\n\n        //Set up interfaces\n        moloch = IMOLOCH(_dao);\n        pool = ILendingPool(_aavePool);\n        data = IProtocolDataProvider(_aaveData);\n        provider = ILendingPoolAddressesProvider(address(AAVE_ADDRESS_PROVIDER));\n        \n        dao = _dao;\n        minionId = _minionId;\n        feeAddress = _feeAddress;\n        feeFactor = _feeFactor;\n        minHealthFactor = _minHealthFactor;\n        desc = _desc;\n        \n        aavePool = _aavePool; \n        aaveData = _aaveData;\n        \n        initialized = true; \n        \n    }\n\n    \n    /**********************************************************************\n                             PROPOSAL FUNCTIONS \n    ***********************************************************************/\n    \n    // -- LENDING AND BORROWING FUNCTIONS -- //\n    \n    /**\n     * Creates a generic proposal to the DAO to do actions at the minion level\n     * @dev Returns a proposalId which is used by the rest of the functions for tracking proposal status\n     * @param token The token being used for the DAO proposal (default is DAO deposit token)\n     * @param tributeOffered Used if the Minion is moving funds into the DAO\n     * @param paymentRequested Used to move funds from DAO to minion\n     * @param details Human readable text for the proposal being submitted \n     */ \n    \n    function proposeAction(\n        address token,\n        uint256 tributeOffered,\n        uint256 paymentRequested,\n        string memory details\n    ) internal returns (uint256) {\n        \n        //submit proposal to its moloch \n        uint256 proposalId = moloch.submitProposal(\n            address(this),\n            0,\n            0,\n            tributeOffered,\n            token,\n            paymentRequested,\n            token,\n            details\n        );\n        \n        return proposalId;\n    }\n\n    /**\n     * Special proposal function to make funding the minion via a DAO proposal and moving those funds into Aave easy\n     * @param token The base token to be wrapped in Aave\n     * @param paymentRequested Amount of tokens to be requested from \n     * @param details Details for the DAO proposal\n     */  \n    \n    function depositCollateral(\n        address token,\n        uint256 paymentRequested,\n        string calldata details\n    ) external memberOnly returns (uint256) {\n        \n        // Checks there's an existing aToken for this token\n        (address aToken,,) = getAaveTokenAddresses(token);\n        require(aToken != address(0), \"AP::No aToken\");\n        \n        uint256 proposalId = proposeAction(\n            token,\n            0,\n            paymentRequested,\n            details\n            );\n\n\n        Deposit memory deposit = Deposit({\n            token: token,\n            proposer: msg.sender,\n            paymentRequested: paymentRequested,\n            executed: false\n        });\n\n        deposits[proposalId] = deposit;\n\n        emit ProposeDeposit(proposalId, msg.sender, token, paymentRequested);\n        return proposalId;\n    }\n    \n    /**\n     * Executes the depositCollateral() proposal once it's passed \n     * @dev calls the doWithdraw() function to remove funds from the DAO \n     * @dev calls the aavePool deposit() function to immediately move those funds into aTokens\n     * @param proposalId The id of the associated proposal\n     **/ \n\n    function executeCollateralDeposit(uint256 proposalId) external nonReentrant memberOnly returns (uint256) {\n        Deposit storage deposit = deposits[proposalId];\n        bool[6] memory flags = moloch.getProposalFlags(proposalId);\n        (address aToken,,) = getAaveTokenAddresses(deposit.token);\n\n        require(!deposit.executed,  \"AP::already executed\");\n        require(flags[2], \"AP::proposal not passed\");\n        require(flags[1], \"AP::proposal not processed\");\n        \n        //Withdraws the funds for deposit from the Moloch\n        doWithdraw(address(dao), deposit.token, deposit.paymentRequested);\n        //Approves that token to be spent by Aave\n        IERC20(deposit.token).approve(aavePool, type(uint256).max);\n        //Also approves the aToken to be used by Aave in anticipation of eventual withdraw\n        IERC20(aToken).approve(aavePool, type(uint256).max);\n        //Deposits token into the AaveLending Pool with the minion as the destination for aTokens\n        pool.deposit(deposit.token, deposit.paymentRequested, address(this), 0);\n        \n        //Updates internal accounting for earnings pegs\n        earningsPeg[aToken] += int(deposit.paymentRequested);\n        \n        // execute call\n        deposit.executed = true;\n        \n        emit DepositExecuted(proposalId);\n        return proposalId;\n    }\n    \n    /**\n     * Allows minion to borrow funds from Aave \n     * Requires that the minion holds sufficient aTokens as collateral \n     * @dev uses the proposeAction() function in order to submit a proposal for the borrow action\n     * @param token The underlying token to be borrowed\n     * @param amount The amount to be borrowed\n     * @param rateMode Determines whether using stable or variable debt \n     * @param onBehalfOf Used for credit delegation if borrowing using another's collateral \n     **/ \n    \n    function borrowFunds(\n        address token, \n        uint256 amount, \n        uint256 rateMode, \n        address onBehalfOf,\n        string calldata details\n    ) external memberOnly returns (uint256){\n        \n        (,address sToken, address vToken) = getAaveTokenAddresses(token);\n        // Check health before allowing member to propose borrowing more\n        require(isHealthy(), \"AP::Not healthy enough\");\n        //Check that debtToken exists for that rateMode \n        if (rateMode == 1){\n            require(sToken != address(0), \"AP::no sToken\");\n        } else if (rateMode == 2){\n            require(vToken != address(0), \"AP::no sToken\");\n        } else {\n            revert(\"AP::no rateMode\");\n        }\n        \n        uint256 proposalId = proposeAction(\n            token,\n            0,\n            0,\n            details\n            );\n        \n        Loan memory loan = Loan({\n            token: token,\n            proposer: msg.sender,\n            onBehalfOf: onBehalfOf,\n            amount: amount,\n            rateMode: rateMode,\n            executed: false\n        });\n\n        loans[proposalId] = loan;\n\n        emit ProposeLoan(proposalId, msg.sender, onBehalfOf, token, amount, rateMode);\n        return proposalId;\n    }\n    \n    /**\n     * Executes the borrowFunds() proposal once it's passed a\n     * @dev requires a special processing function in order to check health and track liabities \n     * @dev calls the aavePool borrow() function to borrow funds from Aave with dTokens being held in minion\n     * @param proposalId The id of the associated proposal\n     **/     \n    \n    function executeBorrow(uint256 proposalId) external nonReentrant memberOnly returns (uint256){\n        Loan storage loan = loans[proposalId];\n        bool[6] memory flags = moloch.getProposalFlags(proposalId);\n        \n        require(!loan.executed,  \"AP::already executed\");\n        require(flags[2], \"AP::proposal not passed\");\n        // Recheck health factor, which could have changed since proposal\n        require(isHealthy(), \"AP::not healthy enough\");\n        \n        pool.borrow(loan.token, loan.amount, loan.rateMode, 0, loan.onBehalfOf);\n        loan.executed = true;\n        \n        //Update accounting so loan isn't mistaken for earnings\n        earningsPeg[loan.token] += int(loan.amount);\n\n        emit LoanExecuted(proposalId);\n        return proposalId;\n    }\n    \n    //  -- REPAYMENT AND WITHDRAW FUNCTIONS -- //\n    \n    /**\n     * Allows minion to withdraw funds from Aave \n     * @dev destination is limited to the DAO or the minion for security  \n     * @dev uses the proposeWithdrawCollateral() function in order to submit a proposal for the withdraw action\n     * @dev checks health factory at point of execution\n     * @param token The underlying token to be withdrawn from Aave \n     * @param amount The amount to be taken out of Aave\n     * @param destination Where withdrawn tokens get dumped\n     * @param details Used for proposal details\n     **/ \n    \n    function withdrawCollateral(\n        address token, \n        uint256 amount, \n        address destination, \n        string calldata details\n    ) external memberOnly returns (uint256) {\n        (uint256 aTokenBal,,,,) = getOurCompactReserveData(token);\n        //Check health before collateral withdraw proposal\n        require(isHealthy(), \"AP::not healthy enough\");\n        //Check aTokens available is <= amount being withdrawn\n        require(aTokenBal >= amount, \"AP::not enough tokens\");\n        \n        uint256 proposalId = proposeAction(\n            token,\n            0,\n            0,\n            details\n            );\n            \n        CollateralWithdraw memory withdraw = CollateralWithdraw({\n            proposer: msg.sender,\n            token: token,\n            destination: destination,\n            amount: amount,\n            executed: false\n        });\n\n        collateralWithdraws[proposalId] = withdraw;  \n        \n        emit ProposeCollateralWithdraw(proposalId, msg.sender, token, amount, destination);\n        return proposalId;\n    }\n    \n    /**\n     * Allows minion to repay funds borrowed from Aave\n     * @dev uses the proposeRepayLoan() function in order to submit a proposal for the withdraw action\n     * @dev onBehalfOf will usually be the minion address \n     * @param token The underlying token to be withdrawn from Aave \n     * @param amount The amount to be taken out of Aave\n     * @param rateMode whether loan uses a stable or variable rate\n     * @param onBehalfOf should be minion address, except in special circumstances\n     * @param details Used for proposal details\n     **/ \n    \n    function repayLoan(\n        address token, \n        uint256 amount, \n        uint256 rateMode, \n        address onBehalfOf, \n        string calldata details\n    ) external memberOnly returns (uint256) {\n        \n        uint256 proposalId = proposeAction(\n            token,\n            0,\n            0,\n            details\n            );\n            \n        LoanRepayment memory repayment = LoanRepayment({\n            proposer: msg.sender,\n            token: token,\n            onBehalfOf: onBehalfOf,\n            amount: amount,\n            rateMode: rateMode,\n            executed: false\n        });\n\n        loanRepayments[proposalId] = repayment; \n        emit ProposeRepayLoan(proposalId, msg.sender, token, amount, rateMode, onBehalfOf);\n        return proposalId;\n    }\n    \n    /**\n     * Withdraws funds from the minion by tributing them into the DAO via proposal for 0 shares / 0 loot\n     * @dev can be undone by DAO if they vote down proposal or msg.sender cancels \n     * @dev takes a fee on aTokens withdrawn, since we don't otherwise get that fee\n     * @param token The underlying token to be withdrawn from Aave \n     * @param amount The amount to be taken out of Aave\n     * @param details Used for proposal details\n     **/ \n    \n\n    function daoWithdraw(\n        address token, \n        uint256 amount, \n        string calldata details\n    ) external nonReentrant memberOnly returns (uint256) {\n        //Checks that token is already whitelisted \n        require(moloch.tokenWhitelist(token), \"AP::not a whitelisted token\");\n        //Approves moloch to withdraw the tributed tokens\n        IERC20(token).approve(address(moloch), type(uint256).max);\n        \n        uint256 netDraw;\n        if (checkaToken(token)){\n            //Checks health before withdraw\n            require(isHealthy(), \"AP::not healthy enough\");\n            //Pulls smaller withdraw fee\n            uint256 fee = pullWithdrawFees(token, amount);  \n            netDraw = amount - fee;\n        } else {\n            netDraw = amount;\n        }\n        \n        uint256 proposalId = proposeAction(\n            token,\n            netDraw,\n            0,\n            details\n            );\n            \n        Action memory action = Action({\n            proposer: msg.sender,\n            token: token,\n            amount: amount,\n            actionType: 1,\n            executed: true\n        });\n        \n        //Updates accounting for earnings, which have moved to the DAO \n        earningsPeg[token] -= int(amount);\n        actions[proposalId] = action; \n        emit WithdrawToDAO(proposalId, msg.sender, token, amount);\n        return proposalId;\n    }\n    \n    /**\n     * Executes the proposeWithdrawCollateral() proposal once it's passed\n     * @dev requires a special processing function in order to check health and track remaning assets  \n     * @dev calls the aavePool withdraw() function to swap aTokens for tokens back to the aavePartyMinions\n     * @param proposalId The id of the associated proposal\n     **/ \n    \n    function executeCollateralWithdraw(uint256 proposalId) external nonReentrant memberOnly returns (uint256) {\n         \n         CollateralWithdraw storage withdraw = collateralWithdraws[proposalId];\n         bool[6] memory flags = moloch.getProposalFlags(proposalId);\n        \n         require(flags[2], \"AP::proposal not passed\");\n         require(!withdraw.executed, \"AP::already executed\");\n         // Recheck health factor, which could have changed since proposal\n         require(isHealthy(), \"AP::not healthy enough\");\n         \n         //Fetchs aToken address\n         (address aToken,,) = getAaveTokenAddresses(withdraw.token);\n         //Subtracts fees in aTokens\n         uint256 fee = pullEarningsFees(aToken, withdraw.amount);\n         uint256 netWithdraw = withdraw.amount - fee;\n         //Withdraws net amount from Aave into the minion or DAO\n         uint256 withdrawAmt = pool.withdraw(\n             withdraw.token, \n             netWithdraw, \n             withdraw.destination\n             );\n             \n         collateralWithdraws[proposalId].executed = true;\n         \n        // Adjust earnings peg for aTokens converted back into reserveTokens\n         earningsPeg[aToken] -= int(withdraw.amount);\n         emit CollateralWithdrawExecuted(proposalId, withdrawAmt);\n         return proposalId;\n    }\n    \n    /**\n     * Executes the proposeRepayLoan() proposal once it's passed\n     * @dev repays loan by sending tokens and having Aave burn dTokens\n     * @param proposalId The id of the associated proposal\n     **/ \n    \n    function executeLoanRepay(uint256 proposalId) external nonReentrant memberOnly returns (uint256) {\n        \n        LoanRepayment storage repay = loanRepayments[proposalId];\n        bool[6] memory flags = moloch.getProposalFlags(proposalId);\n        \n        require(flags[2], \"AP::proposal not passed\");\n        require(!repay.executed, \"AP::already executed\");\n\n        uint256 repaidAmt = pool.repay(\n            repay.token, \n            repay.amount, \n            repay.rateMode, \n            repay.onBehalfOf\n            );\n        repay.executed = true;\n        \n        // Adjust earnings peg to reflect debt repaid \n        earningsPeg[repay.token] -= int(repaidAmt);\n        emit RepayLoanExecuted(proposalId);\n        return repaidAmt;\n    }\n    \n    /**\n     * Simple function to cancel Aave-related proposals  \n     * @dev Can only be called by proposer\n     * @dev Can only be called if the proposal has not been sponsored in DAO\n     * @param proposalId The id of the proposal to be cancelled\n     * @param propType The type of proposal to be cancelled\n     **/ \n     \n    function cancelAaveProposal(uint256 proposalId, uint16 propType) external {\n        bool[6] memory flags = moloch.getProposalFlags(proposalId);\n        require(!flags[0], \"AP::proposal already sponsored\");\n        \n        if (propType == 1){\n            Deposit storage prop = deposits[proposalId];\n            require(msg.sender == prop.proposer, \"AP::not proposer\");\n        } else if (propType == 2) {\n            Loan storage prop = loans[proposalId];\n            require(msg.sender == prop.proposer, \"AP::not proposer\");\n        } else if (propType == 3) {\n            CollateralWithdraw storage prop = collateralWithdraws[proposalId];\n            require(msg.sender == prop.proposer, \"AP::not proposer\");\n        } else if (propType == 4) {\n            LoanRepayment storage prop = loanRepayments[proposalId];\n            require(msg.sender == prop.proposer, \"AP::not proposer\");\n        }\n        \n        emit Canceled(proposalId, propType, \"undoAaveProp\");\n        moloch.cancelProposal(proposalId);\n    }\n    \n    /**\n     * Simple function to cancel proposals that use actions\n     * @dev Can only be called by proposer\n     * @dev Can only be called if the proposal has not been sponsored in DAO\n     * @param proposalId The id of the proposal to be cancelled\n     **/ \n    \n    function undoAction(uint256 proposalId) external memberOnly {\n        \n        Action storage action = actions[proposalId];\n        bool[6] memory flags = moloch.getProposalFlags(proposalId);\n        require(!flags[0], \"AP::proposal already sponsored\");\n        \n        moloch.cancelProposal(proposalId);\n        emit Canceled(proposalId, action.actionType, \"undoAction\");\n    }\n    \n    \n    /**********************************************************************\n                             EARNGINS & FEE FUNCTIONS \n    ***********************************************************************/\n    \n    /**\n     * Allows DAO member to withdraw their share of earnings of a particular token\n     * @dev Earnings withdraws need to be turned on by the DAO first \n     * @dev Destination is restricted to the member or the DAO (if they're feeling generous)\n     * @param token The token with earnings to withdraw\n     * @param destination Where member sends their earnings \n     **/ \n     \n    function withdrawMyEarnings(address token, address destination) external nonReentrant memberOnly returns (uint256) {\n    \n        require(rewardsOn[token], \"AP::rewards not on\");\n        // Check health before withdrawing earnings, which are likely aTokens\n        require(isHealthy(), \"AP::not healthy enough\");\n        // Restrict destination to DAO or member for v1\n        require(destination == msg.sender || destination == address(moloch), \"not acceptable destination\");\n        \n        // Get earnings and fees\n        uint256 myEarnings = calcMemberEarnings(token, msg.sender);\n        uint256 fees = pullEarningsFees(token, myEarnings);\n        \n        // Transfer member earnings - fees \n        uint256 transferAmt = myEarnings - fees;\n        IERC20(token).transfer(destination, uint256(transferAmt));\n        \n        emit EarningsWithdraw(msg.sender, token, transferAmt, destination);\n        return myEarnings;\n    }\n    \n    /**\n     * Simple function to withdraw the fees on earnings\n     * @dev Is often withdrawing the aToken\n     * @param token The address of the token \n     * @param amount The amount being withdrawn\n     **/ \n     \n    function pullEarningsFees(address token, uint256 amount) internal returns (uint256) {\n        \n        uint256 feeToPull = calcFees(token, amount);\n        IERC20(token).transfer(feeAddress, feeToPull);\n\n        return feeToPull;\n    }\n    \n    /**\n     * Simple function to withdraw the fees withdraws of the aToken from the Minion \n     * Compensates for situations where aTokens are moved from DAO before earnings accumulate\n     * @param token The address of the token \n     * @param amount The amount being withdrawn\n     **/ \n     \n    function pullWithdrawFees(address token, uint256 amount) internal returns (uint256){\n        uint256 feeToPull = calcFees(token, amount) / WITHDRAW_FACTOR; //lowers fee by factor of 10 \n        IERC20(token).transfer(feeAddress, feeToPull);\n\n        return feeToPull;\n    }\n    \n    \n    /**\n     * @dev Simple function to turn rewardsOn for a token\n     * @param token The address of the token having its earnings EarningsToggled\n     * @param details Human readable details for the proposal\n     **/ \n    \n    function proposeToggleEarnings(address token, string memory details) external memberOnly returns (uint256) {\n        \n        uint256 proposalId = proposeAction(\n            token,\n            0,\n            0,\n            details\n            );\n        \n        Action memory action = Action({\n            proposer: msg.sender,\n            token: token,\n            amount: 0,\n            actionType: 2,\n            executed: false\n        });\n        \n        actions[proposalId] = action;\n        emit ProposeToggleEarnings(proposalId, msg.sender, token);\n        return proposalId;\n    }\n    \n     /**\n     * @notice Executes function above when proposal has passed\n     * @param proposalId of that EarningsToggled proposal\n     **/\n     \n     function executeToggleEarnings(uint256 proposalId) external nonReentrant memberOnly returns (address, bool) {\n        Action storage action = actions[proposalId];\n        bool[6] memory flags = moloch.getProposalFlags(proposalId);\n        \n        require(flags[2], \"AP::proposal not passed\");\n        require(!action.executed, \"AP::already executed\");\n        require(action.actionType == 2, \"AP::right actionType\");\n        action.executed = true; //Marks as executed\n        \n        if (!rewardsOn[action.token]){\n            //Turns on rewards\n            rewardsOn[action.token] = true;\n            emit EarningsToggled(proposalId, true);\n            return (action.token, true);\n        } else {\n            //Turns off rewards, if already on\n            rewardsOn[action.token] = false;\n            emit EarningsToggled(proposalId, false);\n            return (action.token, false);\n        }\n        \n        \n    }\n    \n    /**********************************************************************\n                             VIEW & HELPER FUNCTIONS \n    ***********************************************************************/\n    \n    //  --EARNINGS AND FEE FUNCTIONS-- //\n    \n    /**\n     * Calculates base fees   \n     * @dev Total earnings = balance of aToken in minion - earnings peg\n     * @dev Adjust fee by amt being withdrawn / total balance of aToken in minion\n     * @param token The address of the aToken \n     * @param amount The amount being withdrawn\n     **/ \n    \n    function calcFees(address token, uint256 amount) public view returns (uint256) {\n        \n        uint256 peg = zero(earningsPeg[token]); // earnings peg for that aToken to get base \n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        uint256 fee = (tokenBalance - peg) * feeFactor * amount / FEE_BASE / tokenBalance; \n        \n        return fee;\n    }\n    \n    /**\n     * Calculates member earnings w/r to a single token  \n     * @dev Member earnings = balance of member's share of aToken in minion - member's share of earnings peg\n     * @dev Adjusted by previous withdraws of the token for earnings \n     * @param token The address of the aToken \n     * @param user The amount being withdrawn\n     **/ \n    \n    function calcMemberEarnings(address token, address user) public view returns (uint256) {\n        \n        //Get all the shares and loot inputs\n        uint256 memberSharesAndLoot = getMemberSharesAndLoot(user);\n        uint256 molochSharesAndLoot = getMolochSharesAndLoot();\n        \n        //Get current balance and basis \n        uint256 currentBalance = fairShare(IERC20(token).balanceOf(address(this)), memberSharesAndLoot, molochSharesAndLoot);\n        uint256 basis = (zero(earningsPeg[token]) / molochSharesAndLoot * memberSharesAndLoot) + aTokenRedemptions[user][token];\n        uint256 earnings = currentBalance - basis;\n\n        return earnings;\n    }\n    \n    \n    //  -- AAVE VIEW FUNCTIONS -- //\n    \n    /**\n     * Checks whether the current health is greater minHealthFactor\n     * @dev Should check transaction's effects on health factor on front-end\n     **/ \n    \n    function isHealthy() public view returns (bool){\n        uint256 health = getHealthFactor(address(this));\n        return health > minHealthFactor;\n    }\n    \n    function getHealthFactor(address user) public view returns (uint256) {\n        (,,,,, uint256 health) = pool.getUserAccountData(user);\n        return health;\n    }\n    \n    function getOurCompactReserveData(address token) public view returns (\n        uint256 aTokenBalance, \n        uint256 stableDebt, // interest rate on stable debt\n        uint256 variableDebt, // interest rate on variable debt\n        uint256 liquidityRate, //interest rate being earned\n        bool usageAsCollateralEnabled\n    ){\n    \n       (aTokenBalance, \n       stableDebt, \n       variableDebt,,,,\n       liquidityRate,, \n       usageAsCollateralEnabled\n       ) = data.getUserReserveData(token, address(this));\n       \n    }\n    \n    function getAaveTokenAddresses(address token) public view returns (\n        address aTokenAddress, \n        address stableDebtTokenAddress, \n        address variableDebtTokenAddress) {\n            \n        (aTokenAddress, \n         stableDebtTokenAddress, \n         variableDebtTokenAddress\n        ) = data.getReserveTokensAddresses(token);\n\n    }\n    \n    function checkaToken(address token) internal view returns (bool) {\n        \n        (address aToken,,) = getAaveTokenAddresses(token);\n        if (aToken == address(0)){\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    //  -- Moloch-related View Functions -- //\n    \n    function isMember(address user) internal view returns (bool) {\n        (, uint256 shares,,,,) = moloch.members(user);\n        return shares > 0;\n    }\n    \n    function getMemberSharesAndLoot(address user) internal view returns (uint256){\n        (, uint256 shares, uint256 loot,,,) = moloch.members(user);\n        return shares + loot;\n    }\n    \n    \n    function getMolochSharesAndLoot() internal view returns (uint256){\n        uint256 molochShares = moloch.totalShares();\n        uint256 molochLoot = moloch.totalLoot();\n        return molochShares + molochLoot;\n    }\n    \n    function fairShare(uint256 balance, uint256 shares, uint256 totalShares) internal pure returns (uint256) {\n        require(totalShares != 0);\n\n        if (balance == 0) { return 0; }\n\n        uint256 prod = balance * shares;\n\n        if (prod / balance == shares) { // no overflow in multiplication above?\n            return prod / totalShares;\n        }\n\n        return (balance / totalShares) * shares;\n    }\n    \n    //  -- HELPER FUNCTIONS -- //\n    \n    /**\n     * Withdraws funds from any Moloch into this Minion\n     * Set as an public function to allow for member or this contract to call via proposal\n     * @param targetDao the dao from which the minion is withdrawing funds\n     * @param token the token being withdrawn \n     * @param amount the amount being withdrawn \n     */ \n    \n    function doWithdraw(\n        address targetDao, \n        address token, \n        uint256 amount\n    ) public returns (address, uint256){\n        \n        require(moloch.getUserTokenBalance(address(this), token) >= amount, \"AP::user balance < amount\");\n        moloch.withdrawBalance(token, amount); // withdraw funds from DAO\n        earningsPeg[token] += int(amount);\n        \n        emit WithdrawToMinion(targetDao, token, amount);\n        return (token, amount);\n    }\n    \n\n    \n    /**\n     * Simple function to update the lending pool address \n     * Can be called by any member of the DAO\n     **/\n     \n    function resetAavePool() public returns (address) {\n        \n        address updatedPool = provider.getLendingPool();\n        require (aavePool != updatedPool, \"AP::already set\");\n        aavePool = updatedPool;\n        \n        return aavePool;\n    }\n    \n    /**\n     * Simple function to update the data provider address \n     * Can be called by any member of the DAO\n     **/\n    \n    function resetDataProvider() public returns (address){\n        \n        address _dataProvider = provider.getAddress(\"0x1\");\n        require(aaveData != _dataProvider, \"AP::already set\");\n        aaveData = _dataProvider;\n        \n        return aaveData;\n    }\n    \n    function zero(int x) internal pure returns (uint256) {\n        return uint(x) >= 0 ? uint(x) : 0;\n    }\n    \n}\n\n/*\nThe MIT License (MIT)\nCopyright (c) 2018 Murray Software, LLC.\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\ncontract CloneFactory {\n    function createClone(address target) internal returns (address result) { // eip-1167 proxy pattern adapted for payable minion\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n\n\n\ncontract AavePartyMinionFactory is CloneFactory {\n    \n    address public owner; \n    address public aavePool;\n    address public aaveData;\n    \n    // Tracking minions\n    address immutable public template; // fixed template for minion using eip-1167 proxy pattern\n    address[] public aavePartyMinions; // list of the minions \n    uint256 public counter; // counter to prevent overwriting minions\n    mapping(address => mapping(uint256 => address)) public ourMinions; //mapping minions to DAOs;\n    \n    modifier ownerOnly() {\n        require(msg.sender == owner, \"APFactory::only owner\");\n        _;\n    }\n    \n    event SummonAavePartyMinion(address partyAddress, address dao, address protocol, address feeAddress, uint256 minionId, uint256 feeFactor, string desc, string name);\n    \n    constructor(address _template)  {\n        template = _template;\n        owner = msg.sender;\n        aavePool = 0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf; // matic address\n        aaveData = 0x7551b5D2763519d4e37e8B81929D336De671d46d; // matic address\n    }\n    \n\n    function summonAavePartyMinion(\n            address _dao, \n            address _feeAddress,\n            uint256 _feeFactor,\n            uint256 _minHealthFactor,\n            string memory _desc) \n    external returns (address) {\n        require(isMember(_dao) || msg.sender == owner, \"APFactory:: not member and not owner\");\n        \n        string memory name = \"Aave Party Minion\";\n        uint256 minionId = counter ++;\n        PoolPartyAaveMinion aaveparty = PoolPartyAaveMinion(createClone(template));\n        aaveparty.init(_dao, _feeAddress, aavePool, aaveData, minionId, _feeFactor, _minHealthFactor, _desc);\n        \n        emit SummonAavePartyMinion(address(aaveparty), _dao, aavePool, _feeAddress, minionId, _feeFactor, _desc, name);\n        \n        // add new minion to array and mapping\n        aavePartyMinions.push(address(aaveparty));\n        // @Dev summoning a new minion for a DAO updates the mapping \n        ourMinions[_dao][minionId] = address(aaveparty); \n        \n        return(address(aaveparty));\n    }\n    \n    function isMember(address _dao) internal view returns (bool) {\n        (, uint shares,,,,) = IMOLOCH(_dao).members(msg.sender);\n        return shares > 0;\n    }\n    \n    function updateOwner(address _newOwner) external ownerOnly returns (address) {\n        owner = _newOwner;\n        return owner;\n    }\n    \n    function updatePool(address _newPool) external ownerOnly {\n        aavePool = _newPool;\n    }\n    \n    function updateData(address _newData) external ownerOnly {\n        require(msg.sender == owner, \"APFactory::only owner\");\n        aaveData = _newData;\n    }\n    \n}"
    }
  }
}