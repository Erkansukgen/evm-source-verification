{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/auth/AdminAuth.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract AdminAuth {\n\n    address public owner;\n    address public admin;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner\n    /// @param _admin Address of multisig that becomes admin\n    function setAdminByOwner(address _admin) public {\n        require(msg.sender == owner);\n        require(admin == address(0));\n\n        admin = _admin;\n    }\n\n    /// @notice Admin is able to set new admin\n    /// @param _admin Address of multisig that becomes new admin\n    function setAdminByAdmin(address _admin) public {\n        require(msg.sender == admin);\n\n        admin = _admin;\n    }\n\n    /// @notice Admin is able to change owner\n    /// @param _owner Address of new owner\n    function setOwnerByAdmin(address _owner) public {\n        require(msg.sender == admin);\n\n        owner = _owner;\n    }\n}\n"},"localhost/compound/automatic/CompoundMonitorProxy.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Contract with the actuall DSProxy permission calls the automation operations\ncontract CompoundMonitorProxy is AdminAuth {\n\n    uint public CHANGE_PERIOD;\n    address public monitor;\n    address public newMonitor;\n    address public lastMonitor;\n    uint public changeRequestedTimestamp;\n\n    mapping(address => bool) public allowed;\n\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\n    event MonitorChangeCanceled();\n    event MonitorChangeFinished(address monitor);\n    event MonitorChangeReverted(address monitor);\n\n    // if someone who is allowed become malicious, owner can't be changed\n    modifier onlyAllowed() {\n        require(allowed[msg.sender] || msg.sender == owner);\n        _;\n    }\n\n    modifier onlyMonitor() {\n        require (msg.sender == monitor);\n        _;\n    }\n\n    constructor(uint _changePeriod) public {\n        CHANGE_PERIOD = _changePeriod * 1 days;\n    }\n\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _compoundSaverProxy Address of CompoundSaverProxy\n    /// @param _data Data to send to CompoundSaverProxy\n    function callExecute(address _owner, address _compoundSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_compoundSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }\n\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    function changeMonitor(address _newMonitor) public onlyAllowed {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }\n\n    /// @notice At any point allowed users are able to cancel monitor change\n    function cancelMonitorChange() public onlyAllowed {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }\n\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }\n\n    /// @notice Its possible to revert monitor to last used monitor\n    function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }\n\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }\n\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }\n\n    function setChangePeriod(uint _periodInDays) public onlyAllowed {\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInDays * 1 days;\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    /// @param _token address of token to withdraw balance\n    function withdrawToken(address _token) public onlyOwner {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, balance);\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    function withdrawEth() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n}\n"},"localhost/interfaces/DSProxyInterface.sol":{"content":"pragma solidity ^0.6.0;\n\n\nabstract contract DSProxyInterface {\n\n    /// Truffle wont compile if this isn't commented\n    // function execute(bytes memory _code, bytes memory _data)\n    //     public virtual\n    //     payable\n    //     returns (address, bytes32);\n\n    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);\n\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\n\n    function owner() public virtual returns (address);\n}\n"},"localhost/interfaces/ERC20.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function decimals() external view returns (uint256 digits);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"}}}