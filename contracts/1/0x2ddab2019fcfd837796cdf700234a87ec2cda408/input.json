{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "FRTRebaser.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'SafeMath: addition overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, 'SafeMath: subtraction overflow');\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, 'SafeMath: division by zero');\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface FRT {\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        external\r\n        returns (bool);\r\n\r\n    function governance() external view returns (address);\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        external\r\n        returns (bool);\r\n\r\n    function monetaryPolicy() external view returns (address);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function rebase(uint256 epoch, int256 supplyDelta)\r\n        external\r\n        returns (uint256);\r\n\r\n    function setGovernance(address _governance) external;\r\n\r\n    function setMonetaryPolicy(address monetaryPolicy_) external;\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface FRTTreasury {\r\n    function sendReward(uint256 rate, address account) external;\r\n}\r\n\r\ncontract FRTRebaser {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant PERIOD = 10 minutes; // will be 10 minutes in REAL CONTRACT\r\n\r\n    IUniswapV2Pair public pair;\r\n    FRT public token;\r\n    FRTTreasury public treasury;\r\n\r\n    uint256 public starttime = 1606266000; // EDIT_ME: 2020-11-25UTC:01:00+00:00\r\n    uint256 public price0CumulativeLast = 0;\r\n    uint32 public blockTimestampLast = 0;\r\n    uint224 public price0RawAverage = 0;\r\n    address public lastRebaser = 0x0000000000000000000000000000000000000000;\r\n\r\n    uint256 public epoch = 0;\r\n\r\n    constructor(address _pair, address _treasury) public {\r\n        pair = IUniswapV2Pair(_pair);\r\n        treasury = FRTTreasury(_treasury);\r\n        token = FRT(pair.token0());\r\n        price0CumulativeLast = pair.price0CumulativeLast();\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\r\n        require(reserve0 != 0 && reserve1 != 0, 'NO_RESERVES');\r\n    }\r\n\r\n    event LogRebase(uint indexed epoch, uint totalSupply, uint256 rand, address account);\r\n\r\n    uint256 private constant MAX_INT256 = ~(uint256(1) << 255);\r\n    \r\n    function rebaseTime() public view returns (bool) {\r\n       return block.timestamp % 3600 < 3 * 60;\r\n    }\r\n\r\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\r\n        require(a <= MAX_INT256);\r\n        return int256(a);\r\n    }\r\n\r\n    //Only callers that hold FRT can rebase.\r\n    function hasFRT() private view returns (bool) {\r\n        if (token.balanceOf(msg.sender) > 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function rand() private view returns (uint256) {\r\n        uint256 seed = uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    block.timestamp +\r\n                        block.difficulty +\r\n                        ((\r\n                            uint256(keccak256(abi.encodePacked(block.coinbase)))\r\n                        ) / (now)) +\r\n                        block.gaslimit +\r\n                        ((uint256(keccak256(abi.encodePacked(msg.sender)))) /\r\n                            (now)) +\r\n                        block.number\r\n                )\r\n            )\r\n        );\r\n\r\n        if ((seed - ((seed / 10) * 10)) == 0 || (seed - ((seed / 10) * 10)) > 9 ) {\r\n            return 1;\r\n        } else {\r\n            return (seed - ((seed / 10) * 10));\r\n        }\r\n    }\r\n\r\n    function rebase() external {\r\n       // uint256 timestamp = block.timestamp;\r\n        require(block.timestamp > starttime, 'REBASE IS NOT ACTIVE YET');\r\n        require(lastRebaser != msg.sender, 'YOU_ALREADY_REBASED');\r\n        require(rebaseTime(), 'IS_NOT_TIME_TO_REBASE'); // rebase can only happen between XX:00:00 ~ XX:02:59 of every hour\r\n        require(hasFRT(), 'YOU_DO_NOT_HOLD_FRT'); //Only holders can rebase.\r\n        uint256 price0Cumulative = pair.price0CumulativeLast();\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        uint32 blockTimestamp;\r\n        (reserve0, reserve1, blockTimestamp) = pair.getReserves();\r\n        require(reserve0 != 0 && reserve1 != 0, 'NO_RESERVES');\r\n\r\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n\r\n        // ensure that at least one full period has passed since the last update\r\n        require(timeElapsed >= PERIOD, 'PERIOD_NOT_ELAPSED');\r\n\r\n        // overflow is desired, casting never truncates\r\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n        price0RawAverage = uint224(\r\n            (price0Cumulative - price0CumulativeLast) / timeElapsed\r\n        );\r\n\r\n        price0CumulativeLast = price0Cumulative;\r\n        blockTimestampLast = blockTimestamp;\r\n\r\n        // compute rebase\r\n\r\n        uint256 price = price0RawAverage;\r\n        uint256 priceComp = 0;\r\n        price = price.mul(10**5).div(2**112); // DAI decimals = 18, 100000 = 10^5, 18 - 18 + 5 = 5   ***Important***\r\n        priceComp = price.mul(10**3).div(2**112);\r\n\r\n        require(priceComp != 1000 || priceComp != 999, 'NO_NEED_TO_REBASE'); // don't rebase if price is close to 1.00000\r\n\r\n        // rebase & sync\r\n        uint256 random = rand();\r\n        if (price > 100000) {\r\n            // positive rebase\r\n            uint256 delta = price.sub(100000);\r\n            token.rebase(\r\n                epoch,\r\n                toInt256Safe(token.totalSupply().mul(delta).div(100000 * 10))\r\n            ); // rebase using 10% of price delta\r\n            treasury.sendReward(random, msg.sender);\r\n        } else {\r\n            // negative rebase\r\n            uint256 delta = 100000;\r\n            delta = delta.sub(price);\r\n            token.rebase(\r\n                epoch,\r\n                -toInt256Safe(token.totalSupply().mul(delta).div(100000 * 2))\r\n            ); // Use 2% of delta\r\n            treasury.sendReward(random, msg.sender);\r\n        }\r\n\r\n        pair.sync();\r\n        epoch = epoch.add(1);\r\n        lastRebaser = msg.sender;\r\n        emit LogRebase(epoch, token.totalSupply(), random, msg.sender);\r\n    }\r\n}"
    }
  }
}