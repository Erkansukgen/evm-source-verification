{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Prediction.sol":{"content":"pragma solidity 0.6.12;\n\n    // SPDX-License-Identifier: No License\n\n    /**\n    * @title SafeMath\n    * @dev Math operations with safety checks that throw on error\n    */\n    library SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n    }\n\n    /**\n    * @dev Library for managing\n    * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n    * types.\n    *\n    * Sets have the following properties:\n    *\n    * - Elements are added, removed, and checked for existence in constant time\n    * (O(1)).\n    * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n    *\n    * ```\n    * contract Example {\n    *     // Add the library methods\n    *     using EnumerableSet for EnumerableSet.AddressSet;\n    *\n    *     // Declare a set state variable\n    *     EnumerableSet.AddressSet private mySet;\n    * }\n    * ```\n    *\n    * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n    * (`UintSet`) are supported.\n    */\n    library EnumerableSet {\n        \n\n        struct Set {\n        \n            bytes32[] _values;\n    \n            mapping (bytes32 => uint256) _indexes;\n        }\n    \n        function _add(Set storage set, bytes32 value) private returns (bool) {\n            if (!_contains(set, value)) {\n                set._values.push(value);\n                \n                set._indexes[value] = set._values.length;\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        /**\n        * @dev Removes a value from a set. O(1).\n        *\n        * Returns true if the value was removed from the set, that is if it was\n        * present.\n        */\n        function _remove(Set storage set, bytes32 value) private returns (bool) {\n            // We read and store the value's index to prevent multiple reads from the same storage slot\n            uint256 valueIndex = set._indexes[value];\n\n            if (valueIndex != 0) { // Equivalent to contains(set, value)\n                \n\n                uint256 toDeleteIndex = valueIndex - 1;\n                uint256 lastIndex = set._values.length - 1;\n\n            \n                bytes32 lastvalue = set._values[lastIndex];\n\n                set._values[toDeleteIndex] = lastvalue;\n                set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n                set._values.pop();\n\n                delete set._indexes[value];\n\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        \n        function _contains(Set storage set, bytes32 value) private view returns (bool) {\n            return set._indexes[value] != 0;\n        }\n\n        \n        function _length(Set storage set) private view returns (uint256) {\n            return set._values.length;\n        }\n\n    \n        function _at(Set storage set, uint256 index) private view returns (bytes32) {\n            require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n            return set._values[index];\n        }\n\n        \n\n        struct AddressSet {\n            Set _inner;\n        }\n    \n        function add(AddressSet storage set, address value) internal returns (bool) {\n            return _add(set._inner, bytes32(uint256(value)));\n        }\n\n    \n        function remove(AddressSet storage set, address value) internal returns (bool) {\n            return _remove(set._inner, bytes32(uint256(value)));\n        }\n\n        \n        function contains(AddressSet storage set, address value) internal view returns (bool) {\n            return _contains(set._inner, bytes32(uint256(value)));\n        }\n\n    \n        function length(AddressSet storage set) internal view returns (uint256) {\n            return _length(set._inner);\n        }\n    \n        function at(AddressSet storage set, uint256 index) internal view returns (address) {\n            return address(uint256(_at(set._inner, index)));\n        }\n\n\n    \n        struct UintSet {\n            Set _inner;\n        }\n\n        \n        function add(UintSet storage set, uint256 value) internal returns (bool) {\n            return _add(set._inner, bytes32(value));\n        }\n\n    \n        function remove(UintSet storage set, uint256 value) internal returns (bool) {\n            return _remove(set._inner, bytes32(value));\n        }\n\n        \n        function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n            return _contains(set._inner, bytes32(value));\n        }\n\n        \n        function length(UintSet storage set) internal view returns (uint256) {\n            return _length(set._inner);\n        }\n\n    \n        function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n            return uint256(_at(set._inner, index));\n        }\n    }\n    \n    contract Ownable {\n    address public owner;\n\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    \n    function transferOwnership(address newOwner) onlyOwner public {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n    }\n\n\n    interface Token {\n        function transferFrom(address, address, uint) external returns (bool);\n        function transfer(address, uint) external returns (bool);\n    }\n\n    contract RCHARTpredictionV1 is Ownable {\n        using SafeMath for uint;\n        using EnumerableSet for EnumerableSet.AddressSet;\n        \n    \n        /*\n        participanta[i] = [\n            0 => user staked,\n            1 => amount staked,\n            2 => result time,\n            3 => prediction time,\n            4 => market pair,\n            5 => value predicted at,\n            6 => result value,\n            7 => prediction type  0 => Down, 1 => up ,\n            8 => result , 0 => Pending , 2 => Lost, 1 => Won, 3 => Withdrawn\n        ]\n        */\n\n        // RCHART token contract address\n        address public constant tokenAddress = 0xE63d7A762eF855114dc45c94e66365D163B3E5F6;\n        // Lost token contract address\n        address public constant lossPool = 0x639d0AFE157Fbb367084fc4b5c887725112148F9; \n        \n    \n        \n        // mapping(address => uint[]) internal participants;\n        \n        struct Prediction {\n            address user;\n            uint betAmount;\n            uint resultTime;\n            uint betTime;\n            uint marketPair;\n            uint marketType;\n            uint valuePredictedAt;\n            uint valueResult;\n            uint predictionType;\n            uint result;       \n            bool exists;\n        }\n        \n\n        mapping(uint => Prediction)  predictions;\n        \n        mapping (address => uint) public totalEarnedTokens;\n        mapping (address => uint) public totalClaimedTokens;\n        mapping (address => uint) public totalAvailableRewards;\n        mapping (address => uint) public totalPoints;\n        mapping (address => uint) public totalStaked;\n        event PredictionMade(address indexed user, uint matchid);\n        event PointsEarned(address indexed user, uint indexed time ,  uint score);\n    \n        event RewardsTransferred(address indexed user, uint amount);\n        event ResultDeclared(address indexed user, uint matchID);\n        \n        uint public payoutPercentage = 6500 ;\n        uint public expresultime = 24 hours;\n        uint public maximumToken = 5e18 ; \n        uint public minimumToken = 1e17 ; \n        uint public totalClaimedRewards = 0;\n        \n        uint public scorePrdzEq = 50 ;\n     \n        uint[] public matches;\n\n    \n    function getallmatches() view public  returns (uint[] memory){\n        return matches;\n    }\n        \n        function predict(uint matchID , uint amountToPredict, uint resultTime, uint predictedtime, uint marketPair, uint valuePredictedAt, uint predictionType,uint marketType) public returns (uint)  {\n            require(amountToPredict >= minimumToken && amountToPredict <= maximumToken, \"Cannot predict with 0 Tokens\");\n            require(resultTime > predictedtime, \"Cannot predict at the time of result\");\n            require(Token(tokenAddress).transferFrom(msg.sender, address(this), amountToPredict), \"Insufficient Token Allowance\");\n            \n            require(predictions[matchID].exists !=  true  , \"Match already Exists\" );\n            \n            \n\n            Prediction storage newprediction = predictions[matchID];\n            newprediction.user =  msg.sender;\n            newprediction.betAmount =  amountToPredict; \n            newprediction.resultTime =  resultTime ;\n            newprediction.betTime =  predictedtime; \n            newprediction.marketPair =  marketPair ;\n            newprediction.marketType =  marketType ;\n            newprediction.valuePredictedAt =  valuePredictedAt ;\n            newprediction.valueResult =  0 ;\n            newprediction.predictionType =  predictionType ;\n            newprediction.result =  0 ;\n            newprediction.exists =  true ;\n            matches.push(matchID) ;\n\n            totalPoints[msg.sender] = totalPoints[msg.sender].add(amountToPredict.mul(scorePrdzEq).div(1e18));\n            emit PointsEarned(msg.sender, now , amountToPredict.mul(scorePrdzEq).div(1e18));\n\n            totalStaked[msg.sender] =  totalStaked[msg.sender].add(amountToPredict) ;\n            emit PredictionMade(msg.sender, matchID);\n\n        }\n        \n        function declareresult(uint curMarketValue , uint matchID  ) public  onlyOwner returns (bool)   {\n\n\n                    Prediction storage eachparticipant = predictions[matchID];\n\n                        if(eachparticipant.resultTime <= now && eachparticipant.result == 0 && curMarketValue > 0 ){\n\n                            /* When User Predicted Up && Result is Up */\n                                if(eachparticipant.valuePredictedAt  < curMarketValue && eachparticipant.predictionType  == 1  ){\n                                    eachparticipant.result  = 1 ;\n                                    eachparticipant.valueResult  = curMarketValue ;\n                                    uint reward = eachparticipant.betAmount.mul(payoutPercentage).div(1e4);\n                                    totalEarnedTokens[eachparticipant.user] = totalEarnedTokens[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\n                                    \n                                    totalAvailableRewards[eachparticipant.user] = totalAvailableRewards[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\n                                }\n\n                            /* When User Predicted Up && Result is Down */\n                                if(eachparticipant.valuePredictedAt  > curMarketValue && eachparticipant.predictionType  == 1  ){\n                                    eachparticipant.result  = 2 ;\n                                    eachparticipant.valueResult  = curMarketValue ;\n                                    Token(tokenAddress).transfer(lossPool, eachparticipant.betAmount);\n\n                                }\n\n                            /* When User Predicted Down && Result is Up */\n                                if(eachparticipant.valuePredictedAt  < curMarketValue && eachparticipant.predictionType  == 0  ){\n                                    eachparticipant.result  = 2 ;\n                                    eachparticipant.valueResult  = curMarketValue ;\n                                    Token(tokenAddress).transfer(lossPool, eachparticipant.betAmount);\n\n                                }\n\n                            /* When User Predicted Down && Result is Down */\n                                if(eachparticipant.valuePredictedAt  > curMarketValue && eachparticipant.predictionType  == 0  ){\n                                    eachparticipant.result  = 1 ;\n                                    eachparticipant.valueResult  = curMarketValue ;\n                                    uint reward = eachparticipant.betAmount.mul(payoutPercentage).div(1e4);\n                                    totalEarnedTokens[eachparticipant.user] = totalEarnedTokens[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\n                                    totalAvailableRewards[eachparticipant.user] = totalAvailableRewards[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\n\n                                }\n                        emit ResultDeclared(msg.sender, matchID);\n                    \n                }\n                \n            \n                return true ;\n\n            }\n\n\n            function getmatchBasic(uint  _matchID ) view public returns (address , uint , uint , uint , uint  ) {\n                        return (predictions[_matchID].user , predictions[_matchID].betAmount , predictions[_matchID].resultTime , predictions[_matchID].betTime , predictions[_matchID].marketPair  );\n            }\n\n            function getmatchAdv(uint  _matchID ) view public returns (uint , uint , uint , uint , uint  , bool  ) {\n                        return (predictions[_matchID].marketType , predictions[_matchID].valuePredictedAt, predictions[_matchID].valueResult, predictions[_matchID].predictionType , predictions[_matchID].result  , predictions[_matchID].exists );\n            }\n\n            \n    \n\n        function withdrawNotExecutedResult(uint  _matchID) \n            public \n            \n            returns (bool) {\n            \n            if(predictions[_matchID].result == 0 && predictions[_matchID].user == msg.sender && now.sub(predictions[_matchID].resultTime) > expresultime){\n                Prediction storage eachparticipant = predictions[_matchID];\n                eachparticipant.result =  3 ;\n                Token(tokenAddress).transfer(predictions[_matchID].user, predictions[_matchID].betAmount);\n            }\n            \n            return true ;\n        }\n\n    function addContractBalance(uint amount) public {\n            require(Token(tokenAddress).transferFrom(msg.sender, address(this), amount), \"Cannot add balance!\");\n            \n        }\n\n         function addScore(uint  score, uint amount, address _holder) \n            public \n            onlyOwner\n            returns (bool) {\n             totalPoints[_holder] = totalPoints[_holder].add(score);\n              totalStaked[_holder] = totalStaked[_holder].add(amount);\n            \n            return true ;\n        }\n\n        function updateMaximum(uint  amount) \n            public \n            onlyOwner\n            returns (bool) {\n            maximumToken = amount;\n            \n            return true ;\n        }\n\n        function updateMinimum(uint  amount) \n            public \n            onlyOwner\n            returns (bool) {\n            minimumToken = amount;\n            \n            return true ;\n        }\n\n        \n\n        function updatePayout(uint  percentage) \n            public \n            onlyOwner\n            returns (bool) {\n            payoutPercentage = percentage;\n            \n            return true ;\n        }\n\n    function updateScoreEq(uint  prdzeq) \n            public \n            onlyOwner\n            returns (bool) {\n            scorePrdzEq = prdzeq;\n            \n            return true ;\n        }\n\n\n    \n    \n\n\n        function updateAccount(address account) private {\n            uint pendingDivs = totalAvailableRewards[account];\n            if (pendingDivs > 0 ) {\n                require(Token(tokenAddress).transfer(account, pendingDivs), \"Could not transfer tokens.\");\n                totalClaimedTokens[account] = totalClaimedTokens[account].add(pendingDivs);\n                totalAvailableRewards[account] = 0 ;\n                totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\n                emit RewardsTransferred(account, pendingDivs);\n            }\n        \n            \n        }\n        \n            \n        function claimDivs() public {\n            updateAccount(msg.sender);\n        }\n        \n        \n        \n    \n\n    }"}}}