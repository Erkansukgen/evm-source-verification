{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"},"ethContract.sol":{"content":"pragma solidity =0.7.5;\npragma abicoder v2;\nimport \"https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\";\nimport \"https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol\";\n\n\ninterface IUniswapV3Factory {\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ncontract Bot {\n    \n    address private constant WETH9 = 0xc778417E063141139Fce010982780140Aa0cD5Ab;\n    IUniswapV3Factory private constant factory = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    ISwapRouter private constant uniswapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    IQuoter private constant quoter = IQuoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n\n    address private tokenIn;\n    address private tokenOut;\n    uint256 public token_reserve;\n\n    IERC20 public token;\n    uint256 private swap_value;\n    uint256 private amountOutMin;\n    uint256 private count;\n\n    uint24 poolFee;\n\n    bool public success;\n    bool private isHoneyPot_;\n    bool private isHoneyPotChecked_;\n    bool private liq;\n    bool private hp;\n    bool private doInternal;\n\n    address[] private result;\n    address payable public owner;\n    address pair_addr;\n    uint256 private resultSelector;\n    uint private feeThreshold;\n\n    constructor() payable public {\n       owner = msg.sender;\n    }\n\n    event Success(bool result);\n    event Logging(string msg);\n\n    receive() payable external {}\n\n    function returnBalance() payable public {\n        require(msg.sender == owner, \"Only owner\");\n        owner.transfer(address(this).balance);\n        returnTokenBalance(0xdAC17F958D2ee523a2206206994597C13D831ec7); //BUSD\n        returnTokenBalance(WETH9); //WBNB\n    }\n\n    function returnTokenBalance(address _token) payable public {\n        require(msg.sender == owner, \"Only owner\");\n        uint amount = IERC20(_token).balanceOf(address(this));\n        TransferHelper.safeTransfer(_token, owner, amount);\n    }\n\n    function setOptions(\n        address _tokenIn, address _tokenOut, \n        address[] memory _result, \n        uint256 _value, \n        uint256 _amountOutMin, \n        uint256 _count, bool _liq, bool _hp, bool _internal, uint256 _threshold, uint24 _poolFee\n    ) public{\n        require(msg.sender == owner, \"Only owner\");\n        tokenIn = _tokenIn;\n        tokenOut = _tokenOut;\n\n        pair_addr = factory.getPool(tokenIn, tokenOut, _poolFee);\n        IERC20(tokenIn).approve(address(uniswapRouter), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        IERC20(tokenOut).approve(address(uniswapRouter), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n\n        token = IERC20(tokenOut);\n        token_reserve = token.balanceOf(pair_addr);\n        // reserve1 = IERC20(path[1]).balanceOf(pair_addr);\n        swap_value = _value;\n        amountOutMin = _amountOutMin;\n        result = _result;\n        count = _count;\n        success = false;\n        liq = _liq;\n        hp = _hp;\n        doInternal = _internal;\n        isHoneyPotChecked_ = false;\n        isHoneyPot_ = false;\n        feeThreshold = _threshold;\n        poolFee = _poolFee;\n        resultSelector = 0;\n    }\n\n    function checkHoneyPotSell() internal virtual returns (bool) {\n        if (isHoneyPotChecked_) {\n            return isHoneyPot_;\n        }\n        \n        uint balance0Before = IERC20(tokenIn).balanceOf(address(this));\n        uint balance1Before = IERC20(tokenOut).balanceOf(address(this));\n        \n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(\n                tokenIn,\n                tokenOut,\n                poolFee,\n                address(this),\n                block.timestamp,\n                500000000,\n                0,\n                0\n        );\n        \n        uniswapRouter.exactInputSingle{ gas: gasleft() }(params);\n\n        uint balance1After = IERC20(tokenOut).balanceOf(address(this));\n        \n        \n        ISwapRouter.ExactInputSingleParams memory paramsSell = ISwapRouter.ExactInputSingleParams(\n            tokenOut,\n            tokenIn,\n            poolFee,\n            address(this),\n            block.timestamp,\n            balance1After - balance1Before,\n            0,\n            0\n        );\n        \n        \n        try uniswapRouter.exactInputSingle{ gas: gasleft() }(paramsSell) {\n            uint balance0After = IERC20(tokenIn).balanceOf(address(this));\n            if ((balance0Before - balance0After) >  (500000000 * feeThreshold / 100)) {\n                isHoneyPot_ = true;\n                emit Logging(\"HP fee\");\n            }else {\n                emit Logging(\"HP OK\");\n                isHoneyPot_ = false;\n            }\n        }  catch Error(string memory reason) {\n            emit Logging(\"HP sell\");\n            emit Logging(reason);\n            isHoneyPot_ = true;\n        }\n        isHoneyPotChecked_ = true;\n        return isHoneyPot_;\n    }\n    \n    function buy() payable public {\n        require(!success, \"Already done\");\n        require(!isHoneyPot_, \"HP\");\n        if (liq) {\n            require(token.balanceOf(pair_addr) > token_reserve, 'Liq empty');\n        }\n        if (hp && checkHoneyPotSell()) {\n            return;\n        }\n\n        // TOKEN to TOKEN\n        uint256 execGas = 0;\n        uint256 execGasInit = 0;\n        while (true) {\n            if (execGas == 0) {\n                execGasInit = gasleft();\n            }\n            if (resultSelector >= result.length) {\n                resultSelector = 0;\n            }\n            address resultAddr = result[resultSelector];\n            resultSelector++;\n\n            ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(\n                tokenIn,\n                tokenOut,\n                poolFee,\n                resultAddr,\n                block.timestamp,\n                swap_value,\n                amountOutMin,\n                0\n            );\n            uniswapRouter.exactInputSingle{ gas: gasleft() }(params);\n\n            uint balance = IERC20(tokenIn).balanceOf(address(this));\n            if (balance == 0) {\n                emit Logging(\"Zero bal\");\n                success = true;\n                emit Success(true);\n                break;\n            } else if (balance < swap_value) {\n                emit Logging(\"Set pennies\");\n                swap_value = balance;\n            }\n\n            if (!doInternal){\n                emit Logging(\"!internal\");\n                return;\n            }\n            \n            if (execGas == 0) {\n                execGas = (execGasInit - gasleft()) + 12000;\n            }\n            if (gasleft() < execGas) {\n                emit Logging(\"Gasleft\");\n                return;\n            }\n        }\n        \n    }\n\n    function buy9() payable public {\n        require(!success, \"Already done\");\n        require(!isHoneyPot_, \"HP\");\n\n        if (liq) {\n            require(token.balanceOf(pair_addr) > token_reserve, 'Liq empty');\n        }\n\n        if (hp && checkHoneyPotSell()) {\n            return;\n        }\n    \n        while (true) {\n            if (resultSelector >= result.length) {\n                resultSelector = 0;\n            }\n            address resultAddr = result[resultSelector];\n            resultSelector++;\n            ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams(\n                tokenIn,\n                tokenOut,\n                poolFee,\n                resultAddr,\n                block.timestamp,\n                amountOutMin,\n                swap_value,\n                0\n            );\n\n            \n            try uniswapRouter.exactOutputSingle{ value: 0 }(params) {\n                // none\n            }  catch Error(string memory reason) {\n                emit Logging(reason);\n                break;\n            }\n\n            if (!doInternal){\n                \n                return;\n            }\n\n            if (gasleft() < 700000) {\n                emit Logging(\"Gasleft\");\n                return;\n            }\n        }\n        \n        success = true;\n        emit Success(true);\n    }\n\n    //function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to)\n\n    // function sell(uint amountIn, uint amountOutMin, address[] calldata path, address to) external virtual {\n    //     require(msg.sender == owner, \"Only owner\");\n    //     bool zeroForOne = tokenIn < tokenOut;\n\n    //     (int256 amount0, int256 amount1) =\n    //         pair_addr.swap(\n    //             owner,\n    //             zeroForOne,\n    //             amountIn,\n    //              (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1),\n    //             abi.encode(ISwapRouter.SwapCallbackData({path: abi.encodePacked(tokenIn, poolFee, tokenOut), payer: msg.sender}))\n    //         );\n    // }\n\n    // function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n    //     for (uint i; i < path.length - 1; i++) {\n    //         (address input, address output) = (path[i], path[i + 1]);\n    //         (address token0,) = PancakeLibrary.sortTokens(input, output);\n    //         IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(factory, input, output));\n    //         uint amountInput;\n    //         uint amountOutput;\n    //         { // scope to avoid stack too deep errors\n    //         (uint reserve0, uint reserve1,) = pair.getReserves();\n    //         (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    //         amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n    //         amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\n    //         }\n    //         (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n    //         address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n    //         pair.swap(amount0Out, amount1Out, to, new bytes(0));\n    //     }\n    // }\n}"},"https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/IQuoter.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n"},"https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"}}}