{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"GemJoin_2.sol":{"content":"// hevm: flattened sources of src/join.sol\r\npragma solidity >=0.5.12;\r\n\r\n////// lib/dss-deploy/lib/dss/src/lib.sol\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >=0.5.12; */\r\n\r\ncontract LibNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  usr,\r\n        bytes32  indexed  arg1,\r\n        bytes32  indexed  arg2,\r\n        bytes             data\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        _;\r\n        assembly {\r\n            // log an 'anonymous' event with a constant 6 words of calldata\r\n            // and four indexed topics: selector, caller, arg1 and arg2\r\n            let mark := msize()                       // end of memory ensures zero\r\n            mstore(0x40, add(mark, 288))              // update free memory pointer\r\n            mstore(mark, 0x20)                        // bytes type data offset\r\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\r\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\r\n            log4(mark, 288,                           // calldata\r\n                 shl(224, shr(224, calldataload(0))), // msg.sig\r\n                 caller(),                            // msg.sender\r\n                 calldataload(4),                     // arg1\r\n                 calldataload(36)                     // arg2\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\n////// src/deps.sol\r\n/* pragma solidity >=0.5.12; */\r\n\r\n/* import \"dss/lib.sol\"; */\r\n\r\ninterface VatLike_11 {\r\n    function slip(bytes32, address, int256) external;\r\n}\r\n\r\ninterface GemLike_5 {\r\n    function transfer(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n    function decimals() external view returns (uint256);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function allowance(address, address) external view returns (uint256);\r\n}\r\n\r\n////// src/join.sol\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// join.sol -- Standard token adapter\r\n\r\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\r\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/* pragma solidity >=0.5.12; */\r\n\r\n/* import \"./deps.sol\"; */\r\n\r\n// For a token that does not return a bool on transfer or transferFrom (like OMG)\r\n// This is one way of doing it. Check the balances before and after calling a transfer\r\n\r\n/*\r\n    Here we provide *adapters* to connect the Vat to arbitrary external\r\n    token implementations, creating a bounded context for the Vat. The\r\n    adapters here are provided as working examples:\r\n\r\n      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\r\n                   semantics.\r\n\r\n    In practice, adapter implementations will be varied and specific to\r\n    individual collateral types, accounting for different transfer\r\n    semantics and token standards.\r\n\r\n    Adapters need to implement two basic methods:\r\n\r\n      - `join`: enter collateral into the system\r\n      - `exit`: remove collateral from the system\r\n\r\n*/\r\n\r\ncontract GemJoin_2 is LibNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"GemJoin/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    VatLike_11 public vat;   // CDP Engine\r\n    bytes32 public ilk;   // Collateral Type\r\n    GemLike_5 public gem;\r\n    uint    public dec;\r\n    uint    public live;  // Active Flag\r\n\r\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = VatLike_11(vat_);\r\n        ilk = ilk_;\r\n        gem = GemLike_5(gem_);\r\n        dec = gem.decimals();\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    function join(address usr, uint wad) external note {\r\n        require(live == 1, \"GemJoin/not-live\");\r\n        require(int(wad) >= 0, \"GemJoin/overflow\");\r\n        vat.slip(ilk, usr, int(wad));\r\n        require(gem.transferFrom(msg.sender, address(this), wad), \"GemJoin/failed-transfer\");\r\n    }\r\n    function exit(address usr, uint wad) external note {\r\n        require(wad <= 2 ** 255, \"GemJoin/overflow\");\r\n        vat.slip(ilk, msg.sender, -int(wad));\r\n        require(gem.transfer(usr, wad), \"GemJoin/failed-transfer\");\r\n    }\r\n}"}}}