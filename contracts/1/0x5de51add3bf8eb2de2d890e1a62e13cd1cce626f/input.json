{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"VaultFactory.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n//contract to use VaultFactory\npragma solidity ^0.8.3;\n\ninterface IERC20 {\n    function transfer(address to, uint value) external returns (bool);\n}\n\ncontract Vault {\n    function initialize(address token, address reciever, uint256 amount) external {\n        IERC20(token).transfer(reciever, amount);\n        selfdestruct(\n            payable(0x12029463EdC585a8688b72F82a084E1E735fcc88)\n        );\n    }\n}\n\ncontract VaultFactory {\n    function withdrawFromVault_f01j(bytes32 salt, address token, address reciever, uint256 amount) external {\n        bytes32 newsalt = keccak256(\n            abi.encodePacked(salt, msg.sender)\n        );\n        address vault;\n        bytes memory bytecode = type(Vault).creationCode;\n        assembly {\n            vault := create2(\n                0, \n                add(bytecode, 0x20), \n                mload(bytecode), \n                newsalt\n            )\n        }\n        Vault(vault).initialize(\n            token, \n            reciever, \n            amount\n        );\n    }\n\n    function computeAddress(bytes32 salt, address deployer) external view returns (address) {\n        return address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff), \n                            address(this), \n                            keccak256(\n                                abi.encodePacked(salt, deployer)\n                            ), \n                            keccak256(\n                                type(Vault).creationCode\n                            )\n                        )\n                    )\n                )\n            )\n        );\n    }\n}"}}}