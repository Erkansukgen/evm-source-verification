{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/hype .sol":{"content":"pragma solidity ^0.7.0;\n//SPDX-License-Identifier: UNLICENSED\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address who) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function transfer(address to, uint value) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\ninterface IUNIv2 {\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) \n    external \n    payable \n    returns (uint amountToken, uint amountETH, uint liquidity);\n    \n    function WETH() external pure returns (address);\n\n}\n\ninterface IUnicrypt {\n    event onDeposit(address, uint256, uint256);\n    event onWithdraw(address, uint256);\n    function depositToken(address token, uint256 amount, uint256 unlock_date) external payable; \n    function withdrawToken(address token, uint256 amount) external;\n\n}\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract ATH is IERC20, Context {\n    \n    using SafeMath for uint;\n    IUNIv2 uniswap = IUNIv2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV2Factory uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n    IUnicrypt unicrypt = IUnicrypt(0x17e00383A843A9922bCA3B280C0ADE9f8BA48449);\n    string public _symbol;\n    string public _name;\n    uint8 public _decimals;\n    uint _totalSupply;\n    address payable owner;\n    address public pool;\n    uint256 public liquidityUnlock;\n    bool transferPaused;\n    uint256 public lockedLiquidityAmount;\n    bool public burning;\n    // Timeframes \n    uint256 public firstFee;\n    uint256 public secondFee;\n    uint256 maxBuyAmount = 50 ether;\n    uint256 antiBotsTime;\n    mapping(address => uint) _balances;\n    mapping(address => mapping(address => uint)) _allowances;\n    \n\n     modifier onlyOwner() {\n        require(msg.sender == owner, \"You are not the owner\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender; \n        _symbol = \"ATH\";\n        _name = \"AllTimeHype\";\n        _decimals = 18;\n        _totalSupply = 1000 ether;\n        _balances[owner] = _totalSupply;\n        transferPaused = true;\n        liquidityUnlock = block.timestamp.add(30 days);\n        \n        emit Transfer(address(0),owner, _totalSupply);\n        setUniswapPool();\n    }\n    \n    \n    receive() external payable {\n        \n        \n    }\n    \n    function withdrawETHInCaseOfNotLaunching() external onlyOwner {\n        owner.transfer(address(this).balance);\n    }\n    \n    function calculateFee(uint256 amount) public view returns (uint256) {\n        if (block.timestamp < firstFee)\n            return amount.mul(30).div(100);\n        if (block.timestamp < secondFee && block.timestamp >= firstFee)\n            return amount.mul(20).div(100);\n            \n        return amount.mul(10).div(100);\n    }\n    \n \n    function lockWithUnicrypt() external onlyOwner {\n        IERC20 liquidityTokens = IERC20(pool);\n        uint256 liquidityBalance = liquidityTokens.balanceOf(address(this));\n        uint256 timeToLuck = liquidityUnlock;\n        liquidityTokens.approve(address(unicrypt), liquidityBalance);\n\n        unicrypt.depositToken{value: 0} (pool, liquidityBalance, timeToLuck);\n        lockedLiquidityAmount = lockedLiquidityAmount.add(liquidityBalance);\n    }\n    \n    function withdrawFromUnicrypt(uint256 amount) external onlyOwner{\n        unicrypt.withdrawToken(pool, amount);\n    }\n    \n    function setUniswapPool() public {\n        require(pool == address(0), \"the pool already created\");\n        pool = uniswapFactory.createPair(address(this), uniswap.WETH());\n    }\n    \n    \n    function moonMissionStart() external onlyOwner {\n        uint256 ETH = address(this).balance;\n        transferPaused = false;\n        this.approve(address(uniswap), balanceOf(address(this)));\n        uniswap.addLiquidityETH\n        { value: ETH }\n        (\n            address(this),\n            balanceOf(address(this)),\n            balanceOf(address(this)),\n            ETH,\n            address(this),\n            block.timestamp + 5 minutes\n        );\n        \n        \n        firstFee = block.timestamp.add(20 minutes);\n        secondFee = block.timestamp.add(40 minutes);\n        antiBotsTime = block.timestamp.add(2 minutes);\n        burning = true;\n   }\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address _owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[_owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    \n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(!transferPaused || msg.sender == owner, \"Transfer is paused\");\n        if (amount > maxBuyAmount && sender == pool && block.timestamp < antiBotsTime){\n            revert();\n        }\n        if (recipient == pool && burning){\n        uint256 ToBurn = calculateFee(amount);\n        uint256 ToTransfer = amount.sub(ToBurn);\n        \n        _burn(sender, ToBurn);\n        _beforeTokenTransfer(sender, recipient, ToTransfer);\n\n        _balances[sender] = _balances[sender].sub(ToTransfer, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(ToTransfer);\n        emit Transfer(sender, recipient, ToTransfer);\n    }\n        else {\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n        }\n    }\n    // in case something happens and the address is wrong \n    function setPool(address _pool) public onlyOwner{\n        pool = _pool;\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function burnMyTokens(uint256 amount) external {\n        require(amount > 0);\n        address account = msg.sender;\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address _owner, address spender, uint256 amount) internal virtual {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    \n    function recoverERC20(address tokenAddress, uint256 tokenAmount) public onlyOwner  {\n        require(block.timestamp >= liquidityUnlock);\n        IERC20(tokenAddress).transfer(owner, tokenAmount);\n    }\n}\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}}