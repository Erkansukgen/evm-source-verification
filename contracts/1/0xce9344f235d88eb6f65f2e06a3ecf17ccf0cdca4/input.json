{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/interfaces/v3pool.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity ^0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"
    },
    "contracts/wsohmarb.sol": {
      "content": "pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './interfaces/v3pool.sol';\r\nimport './lib/SafeMath.sol';\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\n\r\n\r\ninterface v3quoter{\r\n  function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountOut);\r\n}\r\n\r\n\r\ninterface v2pool{\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface wsohm{\r\n    function wrap( uint _amount ) external returns ( uint );\r\n    function unwrap( uint _amount ) external returns ( uint ) ;\r\n    function wOHMTosOHM( uint _amount ) external view returns ( uint );\r\n    function sOHMTowOHM( uint _amount ) external view returns ( uint );\r\n}\r\n\r\n\r\ncontract wsohmarb {\r\n    using SafeMath for uint;\r\n    \r\n    address payable public owner;\r\n    \r\n    \r\n    // main net\r\n    \r\n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\r\n    \r\n    \r\n    \r\n    v3quoter quoter = v3quoter(quoter_addr);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        \r\n        // approve sohm and ohm of the wrap contract\r\n            \r\n        IERC20(address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F)).approve(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n\r\n    function v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\r\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\r\n    }\r\n\r\n\r\n    struct Arbinfo{\r\n        uint256 flag;\r\n        uint256 wethamount;\r\n        bool[] flags;\r\n        uint256[] amounts;\r\n        address[] pools;\r\n    }\r\n\r\n\r\n\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata _data\r\n    ) external {\r\n        Arbinfo memory arbinfo = abi.decode(_data, (Arbinfo));\r\n        uint256 flag = arbinfo.flag;\r\n        uint256 weth_amount = arbinfo.wethamount;\r\n        bool[] memory flags = arbinfo.flags;\r\n        uint256[] memory amounts = arbinfo.amounts;\r\n        address[] memory pools = arbinfo.pools;        \r\n\r\n\r\n        if(flag == 0){\r\n            // wrap sohm to wsohm\r\n            uint256 wsohmamount = wsohm(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65)).wrap(uint256(-amount0Delta));\r\n\r\n            IERC20(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65)).transfer(pools[0], wsohmamount);\r\n            address receiver;\r\n            // sell wsohmamount\r\n            for(uint256 i = 0; i < flags.length; i++){\r\n                if((flags.length - 1) == i){\r\n                    receiver = address(this);\r\n                }else{\r\n                    receiver = pools[i+1];\r\n                }\r\n\r\n                if(flags[i]){\r\n                    v2pool(pools[i]).swap(0, amounts[i], receiver, new bytes(0));\r\n                }else{\r\n                    v2pool(pools[i]).swap(amounts[i], 0, receiver, new bytes(0));\r\n                }  \r\n            }\r\n\r\n            IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, uint256(amount1Delta));\r\n\r\n\r\n        }else{\r\n\r\n            // buy wsohm and unwrap wsohm to sohm\r\n            IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(pools[0], weth_amount);\r\n            address receiver;\r\n            for(uint256 i = 0; i < flags.length; i++){\r\n                if((flags.length - 1) == i){\r\n                    receiver = address(this);\r\n                }else{\r\n                    receiver = pools[i+1];\r\n                }\r\n\r\n                if(flags[i]){\r\n                    v2pool(pools[i]).swap(0, amounts[i], receiver, new bytes(0));\r\n                }else{\r\n                    v2pool(pools[i]).swap(amounts[i], 0, receiver, new bytes(0));\r\n                }  \r\n            } \r\n\r\n            wsohm(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65)).unwrap(amounts[amounts.length-1]);\r\n\r\n            // transfer sohm back to the pool to pay back\r\n            IERC20(address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F)).transfer(msg.sender, uint256(amount0Delta));\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    function wrap_arb(uint256 weth_in, bool[] memory flags, uint256[] memory amounts, address[] memory pools) public payable{\r\n        // check the blknum to avoid the uncle blk pack\r\n        require(block.number <= msg.value, \"s\");\r\n\r\n        uint256 gasstart = gasleft();\r\n        \r\n        bytes memory data = abi.encode(Arbinfo({flag: 0, wethamount:0, flags: flags, amounts: amounts, pools: pools}));\r\n        \r\n        // sohm - weth pool, flash swap weth out\r\n        v3pool(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920)).swap(address(this), false, int256(weth_in), \r\n        1461446703485210103287273052203988822378723970342 - 1, data);\r\n        \r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n        \r\n        require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance);\r\n       \r\n    }\r\n\r\n\r\n\r\n    function unwrap_arb(uint256 weth_in, uint256 sohm_in, bool[] memory flags, uint256[] memory amounts, address[] memory pools) public payable{\r\n        // check the blknum to avoid the uncle blk pack\r\n        require(block.number <= msg.value, \"s\");\r\n\r\n        uint256 gasstart = gasleft();\r\n        \r\n        bytes memory data = abi.encode(Arbinfo({flag: 1, wethamount:weth_in, flags: flags, amounts: amounts, pools: pools}));\r\n        \r\n        // sohm - weth pool, flash swap weth out\r\n        v3pool(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920)).swap(address(this), true, int256(sohm_in), \r\n        4295128739 + 1, data);\r\n        \r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n        \r\n        require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance);\r\n       \r\n    }\r\n\r\n\r\n\r\n    function wrap_arb_mem(uint256 weth_in, bool[] memory flags, address[] memory pools, uint256 minbenefit) public{\r\n\r\n        // see if we can make profit here\r\n\r\n        bytes memory returnData;\r\n        uint256 amountout;\r\n        uint256[] memory amounts = new uint256[](flags.length);\r\n\r\n        uint256 v3out = v3out(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F), 10000, weth_in);\r\n        v3out = wsohm(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65)).sOHMTowOHM(v3out);\r\n        uint256 amountin = v3out;\r\n\r\n\r\n        for(uint256 i = 0; i < flags.length; i++){\r\n            (, returnData) = address(pools[i]).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n            (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); \r\n\r\n            if(flags[i]){\r\n                amounts[i] = getAmountOut(amountin, reserve0, reserve1);\r\n                amountin = amounts[i];\r\n            }else{\r\n                amounts[i] = getAmountOut(amountin, reserve1, reserve0);\r\n                amountin = amounts[i];\r\n            }\r\n        }\r\n\r\n        require(amountin > weth_in + minbenefit, \"shit\");\r\n\r\n        bytes memory data = abi.encode(Arbinfo({flag: 0, wethamount:0, flags: flags, amounts: amounts, pools: pools}));\r\n        \r\n        // sohm - weth pool, flash swap weth out\r\n        v3pool(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920)).swap(address(this), false, int256(weth_in), \r\n        1461446703485210103287273052203988822378723970342 - 1, data);\r\n        \r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n\r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance);\r\n       \r\n    }\r\n\r\n\r\n\r\n\r\n    function unwrap_arb_mem(uint256 weth_in, bool[] memory flags, address[] memory pools, uint256 minbenefit) public{\r\n\r\n        bytes memory returnData;\r\n        uint256[] memory amounts = new uint256[](flags.length);\r\n\r\n        uint256 amountin = weth_in;\r\n\r\n        for(uint256 i = 0; i < flags.length; i++){\r\n            (, returnData) = address(pools[i]).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n            (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); \r\n\r\n            if(flags[i]){\r\n                amounts[i] = getAmountOut(amountin, reserve0, reserve1);\r\n                amountin = amounts[i];\r\n            }else{\r\n                amounts[i] = getAmountOut(amountin, reserve1, reserve0);\r\n                amountin = amounts[i];\r\n            }\r\n        }\r\n\r\n\r\n        // unwrap it\r\n        uint256 sohm_in = wsohm(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65)).wOHMTosOHM(amountin);\r\n\r\n        uint256 amountout = v3out(address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F), address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), 10000, sohm_in);\r\n\r\n\r\n        require(amountout > weth_in + minbenefit, \"shit\");\r\n\r\n\r\n\r\n        bytes memory data = abi.encode(Arbinfo({flag: 1, wethamount:weth_in, flags: flags, amounts: amounts, pools: pools}));\r\n        \r\n        // sohm - weth pool, flash swap weth out\r\n        v3pool(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920)).swap(address(this), true, int256(sohm_in), \r\n        4295128739 + 1, data);\r\n        \r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n        \r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance);\r\n       \r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    } \r\n  \r\n\r\n\r\n    function wrap_best(uint256 lowerbound, uint256 higherbound , uint256 step, address[] memory sellpools, address[] memory selltokens) public returns(uint256 bestprofit, uint256 bestin, uint256[] memory amountouts){\r\n        // uint256 amountin;\r\n        uint256 v3_sohm_out;\r\n        uint256[] memory poolreserves = new uint256[](sellpools.length * 2);\r\n\r\n        /*\r\n        uint256 bestprofit;\r\n        uint256 bestin;\r\n        uint256[] memory amountouts = new uint256[](sellpools.length);\r\n        */\r\n        \r\n        // save some time to just use getreserve once\r\n        bytes memory returnData;\r\n\r\n        for(uint256 i = 0; i<sellpools.length; i++){\r\n            // ohm - eth\r\n            (, returnData) = address(sellpools[i]).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n            (poolreserves[i * 2], poolreserves[i * 2 + 1], ) = abi.decode(returnData, (uint,uint,uint)); \r\n        }\r\n\r\n\r\n        while(lowerbound < higherbound){\r\n            uint256[] memory temp_amountouts = new uint256[](sellpools.length);\r\n            // amountin = lowerbound;\r\n            \r\n            //v2_ohm_out = getAmountOut(amountin, reserve1, reserve0);\r\n\r\n            v3_sohm_out = v3out(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F), 10000, lowerbound);\r\n            // wrap to wohm\r\n            v3_sohm_out = wsohm(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65)).sOHMTowOHM(v3_sohm_out);\r\n            \r\n            // sell it\r\n            for(uint256 i = 0; i < sellpools.length; i++){\r\n                if(selltokens[i] < selltokens[i+1]){\r\n                    v3_sohm_out = getAmountOut(v3_sohm_out, poolreserves[i*2], poolreserves[i*2+1]);\r\n                    temp_amountouts[i] = v3_sohm_out;\r\n                }else{\r\n                    v3_sohm_out = getAmountOut(v3_sohm_out, poolreserves[i*2+1], poolreserves[i*2]);\r\n                    temp_amountouts[i] = v3_sohm_out;\r\n                }\r\n            }\r\n\r\n            if(v3_sohm_out < lowerbound){\r\n                break;\r\n            }\r\n            \r\n            if((v3_sohm_out - lowerbound) > bestprofit){\r\n                bestprofit = v3_sohm_out - lowerbound;\r\n                bestin = lowerbound;\r\n                lowerbound = lowerbound + step;\r\n                amountouts = temp_amountouts;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n\r\n        // return(bestin, bestprofit, amountouts);\r\n    }\r\n\r\n\r\n\r\n    function unwrap_best(uint256 lowerbound, uint256 higherbound , uint256 step, address[] memory buypools, address[] memory buytokens) public returns(uint256 bestprofit, uint256 bestin, uint256 sohm_in, uint256[] memory amountouts){\r\n        uint256 amountin;\r\n        uint256 v2_out;\r\n        uint256 v3_eth_out;\r\n        uint256[] memory poolreserves = new uint256[](buypools.length * 2);\r\n        // uint256[] memory amountouts = new uint256[](buypools.length);\r\n\r\n        \r\n        // save some time to just use getreserve once\r\n        bytes memory returnData;\r\n\r\n        for(uint256 i = 0; i < buypools.length; i++){\r\n            // ohm - eth\r\n            (, returnData) = address(buypools[i]).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n            (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); \r\n            poolreserves[i * 2] = reserve0;\r\n            poolreserves[i * 2 + 1] = reserve1;\r\n        }\r\n\r\n\r\n        while(lowerbound < higherbound){\r\n            uint256[] memory temp_amountouts = new uint256[](buypools.length);\r\n            amountin = lowerbound;\r\n            v2_out = amountin;\r\n        \r\n            // buy it\r\n            for(uint256 i = 0; i < buypools.length; i++){\r\n                if(buytokens[i] < buytokens[i+1]){\r\n                    v2_out = getAmountOut(v2_out, poolreserves[i*2], poolreserves[i*2+1]);\r\n                    temp_amountouts[i] = v2_out;\r\n                }else{\r\n                    v2_out = getAmountOut(v2_out, poolreserves[i*2+1], poolreserves[i*2]);\r\n                    temp_amountouts[i] = v2_out;\r\n                }\r\n            }\r\n\r\n            // unwrap the wsohm to sohm\r\n            v2_out = wsohm(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65)).wOHMTosOHM(v2_out);\r\n\r\n            v3_eth_out = v3out(address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F), address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), 10000, v2_out);\r\n\r\n\r\n            if(v3_eth_out < amountin){\r\n                break;\r\n            }\r\n            \r\n            if((v3_eth_out - amountin) > bestprofit){\r\n                bestprofit = v3_eth_out - amountin;\r\n                bestin = amountin;\r\n                sohm_in = v2_out;\r\n                amountouts = temp_amountouts;\r\n                lowerbound = lowerbound + step;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n}"
    }
  }
}