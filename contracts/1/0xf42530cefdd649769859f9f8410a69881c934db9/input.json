{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Wallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function transfer(address, uint256) external;\n    function balanceOf(address) external view returns(uint256);\n}\n\n/// @title The Invoice contract sends all tokens to the receiver and destructs himself\n/// @author davy42\n/// @dev The rest of ETH on the wallet will be sent to the receiver even if it's a contract without receive function\ncontract Invoice {\n\n    /// @notice Constructor\n    /// @dev The Invoice contract has only constructor.\n    /// @param token The address of the erc20 token contract\n    /// @param receiver The address to which tokens will be sent\n    /// @param amount amount of tokens\n    constructor(IERC20 token, address payable receiver, uint256 amount) {\n        token.transfer(receiver, amount);\n        selfdestruct(receiver);\n    }\n}\n\n/// @title The Invoice contract sends all tokens to the receiver and destructs himself\n/// @author davy42\n/// @dev The rest of ETH on the wallet will be sent to the receiver even if it's a contract without receive function\ncontract AddressInvoice {\n\n    /// @notice Constructor\n    /// @dev The Invoice contract has only constructor.\n    /// @param token The address of the erc20 token contract\n    /// @param receiver The address to which tokens will be sent\n    constructor(IERC20 token, address payable receiver) {\n        token.transfer(receiver, token.balanceOf(address(this)));\n        selfdestruct(receiver);\n    }\n}"
    },
    "contracts/WalletFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport {AddressInvoice} from \"./Wallet.sol\";\n\ncontract WalletFactory  {\n\n    bytes constant private invoiceCreationCode = type(AddressInvoice).creationCode;\n\n    function withdraw(uint256 salt, address token, address receiver) external returns (address wallet) {\n        bytes memory bytecode = getByteCode(token, receiver);\n        assembly {\n            wallet := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(wallet != address(0), \"Create2: Failed on deploy\");\n    }\n\n    function computeAddress(uint256 salt, address token, address receiver) public view returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(getByteCode(token, receiver))));\n        return address(uint160(uint256(_data)));\n    }\n\n    function getByteCode(address token, address receiver) private pure returns (bytes memory bytecode) {\n        bytecode = abi.encodePacked(invoiceCreationCode, abi.encode(token, receiver));\n    }\n}"
    }
  }
}