{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"github/rodolfopatane/uniswap-arbitrage-flash-swap/contracts/Flashswap.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.6 <0.8.0;\n\nimport './interfaces/IUniswapV2Router.sol';\nimport './interfaces/IUniswapV2Pair.sol';\nimport './interfaces/IUniswapV2Factory.sol';\nimport './interfaces/IERC20.sol';\n\n// @author Daniel Espendiller - https://github.com/Haehnchen/uniswap-arbitrage-flash-swap - espend.de\n//\n// e00: out of block\n// e01: no profit\n// e10: Requested pair is not available\n// e11: token0 / token1 does not exist\n// e12: src/target router empty\n// e13: pancakeCall not enough tokens for buyback\n// e14: pancakeCall msg.sender transfer failed\n// e15: pancakeCall owner transfer failed\n// e16\ncontract Flashswap {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function start(\n        uint _maxBlockNumber,\n        address _tokenBorrow, // example BUSD\n        uint256 _amountTokenPay, // example: BNB => 10 * 1e18\n        address _tokenPay, // our profit and what we will get; example BNB\n        address _sourceRouter,\n        address _targetRouter,\n        address _sourceFactory\n    ) external {\n        require(block.number <= _maxBlockNumber, 'e00');\n\n        // recheck for stopping and gas usage\n        (int256 profit, uint256 _tokenBorrowAmount) = check(_tokenBorrow, _amountTokenPay, _tokenPay, _sourceRouter, _targetRouter);\n        require(profit > 0, 'e01');\n\n        address pairAddress = IUniswapV2Factory(_sourceFactory).getPair(_tokenBorrow, _tokenPay); // is it cheaper to compute this locally?\n        require(pairAddress != address(0), 'e10');\n\n        address token0 = IUniswapV2Pair(pairAddress).token0();\n        address token1 = IUniswapV2Pair(pairAddress).token1();\n\n        require(token0 != address(0) && token1 != address(0), 'e11');\n\n        IUniswapV2Pair(pairAddress).swap(\n            _tokenBorrow == token0 ? _tokenBorrowAmount : 0,\n            _tokenBorrow == token1 ? _tokenBorrowAmount : 0,\n            address(this),\n            abi.encode(_sourceRouter, _targetRouter)\n        );\n    }\n\n    function check(\n        address _tokenBorrow, // example: BUSD\n        uint256 _amountTokenPay, // example: BNB => 10 * 1e18\n        address _tokenPay, // example: BNB\n        address _sourceRouter,\n        address _targetRouter\n    ) public view returns(int256, uint256) {\n        address[] memory path1 = new address[](2);\n        address[] memory path2 = new address[](2);\n        path1[0] = path2[1] = _tokenPay;\n        path1[1] = path2[0] = _tokenBorrow;\n\n        uint256 amountOut = IUniswapV2Router(_sourceRouter).getAmountsOut(_amountTokenPay, path1)[1];\n        uint256 amountRepay = IUniswapV2Router(_targetRouter).getAmountsOut(amountOut, path2)[1];\n\n        return (\n            int256(amountRepay - _amountTokenPay), // our profit or loss; example output: BNB amount\n            amountOut // the amount we get from our input \"_amountTokenPay\"; example: BUSD amount\n        );\n    }\n\n    function execute(address _sender, uint256 _amount0, uint256 _amount1, bytes memory _data) internal {\n        // obtain an amount of token that you exchanged\n        uint256 amountToken = _amount0 == 0 ? _amount1 : _amount0;\n\n        IUniswapV2Pair iUniswapV2Pair = IUniswapV2Pair(msg.sender);\n        address token0 = iUniswapV2Pair.token0();\n        address token1 = iUniswapV2Pair.token1();\n\n        // require(token0 != address(0) && token1 != address(0), 'e16');\n\n        // if _amount0 is zero sell token1 for token0\n        // else sell token0 for token1 as a result\n        address[] memory path1 = new address[](2);\n        address[] memory path = new address[](2);\n        path[0] = path1[1] = _amount0 == 0 ? token1 : token0; // c&p\n        path[1] = path1[0] = _amount0 == 0 ? token0 : token1; // c&p\n\n        (address sourceRouter, address targetRouter) = abi.decode(_data, (address, address));\n        require(sourceRouter != address(0) && targetRouter != address(0), 'e12');\n\n        // IERC20 token that we will sell for otherToken\n        IERC20 token = IERC20(_amount0 == 0 ? token1 : token0);\n        token.approve(targetRouter, amountToken);\n\n        // calculate the amount of token how much input token should be reimbursed\n        uint256 amountRequired = IUniswapV2Router(sourceRouter).getAmountsIn(amountToken, path1)[0];\n\n        // swap token and obtain equivalent otherToken amountRequired as a result\n        uint256 amountReceived = IUniswapV2Router(targetRouter).swapExactTokensForTokens(\n            amountToken,\n            amountRequired, // we already now what we need at least for payback; get less is a fail; slippage can be done via - ((amountRequired * 19) / 981) + 1,\n            path,\n            address(this), // its a foreign call; from router but we need contract address also equal to \"_sender\"\n            block.timestamp + 60\n        )[1];\n\n        // fail if we didn't get enough tokens\n        require(amountReceived > amountRequired, 'e13');\n\n        IERC20 otherToken = IERC20(_amount0 == 0 ? token0 : token1);\n\n        // transfer failing already have error message\n        otherToken.transfer(msg.sender, amountRequired); // send back borrow\n        otherToken.transfer(owner, amountReceived - amountRequired); // our win\n    }\n\n    // pancake, pancakeV2, apeswap, kebab\n    function pancakeCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n\n    function waultSwapCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n\n    function uniswapV2Call(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n\n    // mdex\n    function swapV2Call(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n\n    // pantherswap\n    function pantherCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n\n    // jetswap\n    function jetswapCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n\n    // cafeswap\n    function cafeCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n\n    // @TODO: pending release\n    function BiswapCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n\n    // @TODO: pending release\n    function wardenCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\n        execute(_sender, _amount0, _amount1, _data);\n    }\n}\n"},"github/rodolfopatane/uniswap-arbitrage-flash-swap/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"},"github/rodolfopatane/uniswap-arbitrage-flash-swap/contracts/interfaces/IUniswapV2Factory.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n"},"github/rodolfopatane/uniswap-arbitrage-flash-swap/contracts/interfaces/IUniswapV2Pair.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"},"github/rodolfopatane/uniswap-arbitrage-flash-swap/contracts/interfaces/IUniswapV2Router.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router {\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n}\n"}}}