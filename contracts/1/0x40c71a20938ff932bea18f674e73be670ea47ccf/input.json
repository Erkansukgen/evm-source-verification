{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DSA_READ/1inch.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface OneProtoInterface {\n    function getExpectedReturn(\n        TokenInterface fromToken,\n        TokenInterface toToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 disableFlags\n    )\n    external\n    view\n    returns(\n        uint256 returnAmount,\n        uint256[] memory distribution\n    );\n\n    function getExpectedReturnWithGas(\n        TokenInterface fromToken,\n        TokenInterface destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags, // See constants in IOneSplit.sol\n        uint256 destTokenEthPriceTimesGasPrice\n    )\n    external\n    view\n    returns(\n        uint256 returnAmount,\n        uint256 estimateGasAmount,\n        uint256[] memory distribution\n    );\n\n    function getExpectedReturnWithGasMulti(\n        TokenInterface[] calldata tokens,\n        uint256 amount,\n        uint256[] calldata parts,\n        uint256[] calldata flags,\n        uint256[] calldata destTokenEthPriceTimesGasPrices\n    )\n    external\n    view\n    returns(\n        uint256[] memory returnAmounts,\n        uint256 estimateGasAmount,\n        uint256[] memory distribution\n    );\n}\n\ninterface OneProtoMappingInterface {\n    function oneProtoAddress() external view returns(address);\n}\n\n\ninterface TokenInterface {\n    function decimals() external view returns (uint);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint);\n}\n\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n}\n\n\ncontract Helpers is DSMath {\n\n    /**\n     * @dev get Ethereum address\n     */\n    function getAddressETH() public pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    }\n}\n\n\ncontract OneProtoHelpers is Helpers {\n   /**\n     * @dev Return 1proto mapping Address\n     */\n    function getOneProtoMappingAddress() internal pure returns (address payable) {\n        return 0x8d0287AFa7755BB5f2eFe686AA8d4F0A7BC4AE7F;\n    }\n\n    /**\n     * @dev Return 1proto Address\n     */\n    function getOneProtoAddress() internal view returns (address payable) {\n        return payable(OneProtoMappingInterface(getOneProtoMappingAddress()).oneProtoAddress());\n    }\n\n    function getTokenDecimals(TokenInterface buy, TokenInterface sell) internal view returns(uint _buyDec, uint _sellDec){\n        _buyDec = address(buy) == getAddressETH() ? 18 : buy.decimals();\n        _sellDec = address(sell) == getAddressETH() ? 18 : sell.decimals();\n    }\n\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = mul(_amt, 10 ** (18 - _dec));\n    }\n\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = (_amt / 10 ** (18 - _dec));\n    }\n\n    function getBuyUnitAmt(\n        TokenInterface buyAddr,\n        uint expectedAmt,\n        TokenInterface sellAddr,\n        uint sellAmt,\n        uint slippage\n    ) internal view returns (uint unitAmt) {\n        (uint buyDec, uint sellDec) = getTokenDecimals(buyAddr, sellAddr);\n        uint _sellAmt = convertTo18(sellDec, sellAmt);\n        uint _buyAmt = convertTo18(buyDec, expectedAmt);\n        unitAmt = wdiv(_buyAmt, _sellAmt);\n        unitAmt = wmul(unitAmt, sub(WAD, slippage));\n    }\n}\n\n\ncontract Resolver is OneProtoHelpers {\n\n    function getBuyAmount(\n        address buyAddr,\n        address sellAddr,\n        uint sellAmt,\n        uint slippage,\n        uint distribution,\n        uint disableDexes\n    ) public view returns (uint buyAmt, uint unitAmt, uint[] memory distributions) {\n        TokenInterface _buyAddr = TokenInterface(buyAddr);\n        TokenInterface _sellAddr = TokenInterface(sellAddr);\n        (buyAmt, distributions) = OneProtoInterface(getOneProtoAddress())\n                .getExpectedReturn(\n                    _sellAddr,\n                    _buyAddr,\n                    sellAmt,\n                    distribution,\n                    disableDexes\n                    );\n        unitAmt = getBuyUnitAmt(_buyAddr, buyAmt, _sellAddr, sellAmt, slippage);\n    }\n\n    function getBuyAmountWithGas(\n        address buyAddr,\n        address sellAddr,\n        uint sellAmt,\n        uint slippage,\n        uint distribution,\n        uint disableDexes,\n        uint destTokenEthPriceTimesGasPrices\n    ) public view returns (uint buyAmt, uint unitAmt, uint[] memory distributions, uint estimateGasAmount) {\n        TokenInterface _buyAddr = TokenInterface(buyAddr);\n        TokenInterface _sellAddr = TokenInterface(sellAddr);\n        (buyAmt, estimateGasAmount, distributions) = OneProtoInterface(getOneProtoAddress())\n                .getExpectedReturnWithGas(\n                    _sellAddr,\n                    _buyAddr,\n                    sellAmt,\n                    distribution,\n                    disableDexes,\n                    destTokenEthPriceTimesGasPrices\n                    );\n        unitAmt = getBuyUnitAmt(_buyAddr, buyAmt, _sellAddr, sellAmt, slippage);\n    }\n\n\n    function getBuyAmountMultiWithGas(\n        TokenInterface[] memory tokens,\n        uint sellAmt,\n        uint slippage,\n        uint[] memory distribution,\n        uint[] memory disableDexes,\n        uint[] memory destTokenEthPriceTimesGasPrices\n    )\n    public\n    view\n    returns(\n        uint buyAmt,\n        uint unitAmt,\n        uint[] memory distributions,\n        uint[] memory returnAmounts,\n        uint estimateGasAmount\n    ) {\n        uint len = tokens.length;\n        (returnAmounts, estimateGasAmount, distributions) = OneProtoInterface(getOneProtoAddress())\n                .getExpectedReturnWithGasMulti(\n                    tokens,\n                    sellAmt,\n                    distribution,\n                    disableDexes,\n                    destTokenEthPriceTimesGasPrices\n                    );\n        buyAmt = returnAmounts[len - 2];\n        unitAmt = getBuyUnitAmt(TokenInterface(tokens[len - 1]), buyAmt, TokenInterface(tokens[0]), sellAmt, slippage);\n    }\n\n    struct MultiTokenPaths {\n        TokenInterface[] tokens;\n        uint[] distribution;\n        uint[] disableDexes;\n        uint[] destTokenEthPriceTimesGasPrices;\n    }\n\n    struct MultiTokenPathsBuyAmt {\n        uint buyAmt;\n        uint unitAmt;\n        uint[] distributions;\n        uint[] returnAmounts;\n        uint estimateGasAmount;\n    }\n\n    function getBuyAmountsMulti(\n        MultiTokenPaths[] memory multiTokenPaths,\n        uint sellAmt,\n        uint slippage\n    )\n    public\n    view\n    returns (MultiTokenPathsBuyAmt[] memory)\n    {\n        uint len = multiTokenPaths.length;\n        MultiTokenPathsBuyAmt[] memory data = new MultiTokenPathsBuyAmt[](len);\n        for (uint i = 0; i < len; i++) {\n            data[i] = MultiTokenPathsBuyAmt({\n               buyAmt: 0,\n               unitAmt: 0,\n               distributions: new uint[](0),\n               returnAmounts: new uint[](0),\n               estimateGasAmount: 0\n            });\n            (\n                data[i].buyAmt,\n                data[i].unitAmt,\n                data[i].distributions,\n                data[i].returnAmounts,\n                data[i].estimateGasAmount\n            ) = getBuyAmountMultiWithGas(\n                multiTokenPaths[i].tokens,\n                sellAmt,\n                slippage,\n                multiTokenPaths[i].distribution,\n                multiTokenPaths[i].disableDexes,\n                multiTokenPaths[i].destTokenEthPriceTimesGasPrices\n            );\n        }\n        return data;\n    }\n}\n\n\ncontract InstaOneProtoResolver is Resolver {\n    string public constant name = \"1Proto-Resolver-v1\";\n}"}}}