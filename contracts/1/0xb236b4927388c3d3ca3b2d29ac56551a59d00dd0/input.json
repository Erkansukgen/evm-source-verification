{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@openzeppelin/contracts/token/ERC20/ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"@openzeppelin/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"},"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"Auctions.sol":{"content":"\n\nimport { ITux } from \"./ITux.sol\";\nimport { ITuxERC20 } from \"./ITuxERC20.sol\";\nimport { IAuctions } from \"./IAuctions.sol\";\n\nimport \"./library/UintSet.sol\";\nimport \"./library/AddressSet.sol\";\nimport \"./library/OrderedSet.sol\";\nimport \"./library/RankedSet.sol\";\nimport \"./library/RankedAddressSet.sol\";\nimport { IERC721, IERC165 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\n\ncontract Auctions is\n    IAuctions\n{\n    using UintSet for UintSet.Set;\n    using AddressSet for AddressSet.Set;\n    using OrderedSet for OrderedSet.Set;\n    using RankedSet for RankedSet.Set;\n    using RankedAddressSet for RankedAddressSet.Set;\n\n    uint256 private _lastBidId;\n    uint256 private _lastOfferId;\n    uint256 private _lastHouseId;\n    uint256 private _lastAuctionId;\n\n    // TuxERC20 contract address\n    address public tuxERC20;\n\n    // Minimum amount of time left in seconds to an auction after a new bid is placed\n    uint256 constant public timeBuffer = 900;  // 15 minutes -> 900 seconds\n\n    // Minimum percentage difference between the last bid and the current bid\n    uint16 constant public minimumIncrementPercentage = 500;  // 5%\n\n    // Mapping from house name to house ID\n    mapping(string => uint256) public houseIDs;\n\n    // Mapping from keccak256(contract, token) to currently running auction ID\n    mapping(bytes32 => uint256) public tokenAuction;\n\n    // Mapping of token contracts\n    mapping(address => IAuctions.TokenContract) public contracts;\n\n    // Mapping of auctions\n    mapping(uint256 => IAuctions.Auction) public auctions;\n\n    // Mapping of houses\n    mapping(uint256 => IAuctions.House) public houses;\n\n    // Mapping of bids\n    mapping(uint256 => IAuctions.Bid) public bids;\n\n    // Mapping of offers\n    mapping(uint256 => IAuctions.Offer) public offers;\n\n    // Mapping of accounts\n    mapping(address => IAuctions.Account) public accounts;\n\n    // Mapping from creator to stats\n    mapping(address => IAuctions.CreatorStats) public creatorStats;\n\n    // Mapping from collector to stats\n    mapping(address => IAuctions.CollectorStats) public collectorStats;\n\n    // Mapping from creator to token contracts\n    mapping(address => AddressSet.Set) private _collections;\n\n    // Mapping from house ID to token IDs requiring approval\n    mapping(uint256 => UintSet.Set) private _houseQueue;\n\n    // Mapping from auction ID to bids\n    mapping(uint256 => UintSet.Set) private _auctionBids;\n\n    // Mapping from house ID to active auction IDs\n    mapping(uint256 => OrderedSet.Set) private _houseAuctions;\n\n    // Mapping from curator to enumerable house IDs\n    mapping(address => UintSet.Set) private _curatorHouses;\n\n    // Mapping from creator to enumerable house IDs\n    mapping(address => UintSet.Set) private _creatorHouses;\n\n    // Mapping from house id to enumerable creators\n    mapping(uint256 => AddressSet.Set) private _houseCreators;\n\n    // Mapping from seller to active auction IDs\n    mapping(address => UintSet.Set) private _sellerAuctions;\n\n    // Mapping from bidder to active auction IDs\n    mapping(address => UintSet.Set) private _bidderAuctions;\n\n    // Mapping from keccak256(contract, token) to previous auction IDs\n    mapping(bytes32 => UintSet.Set) private _previousTokenAuctions;\n\n    // Mapping from keccak256(contract, token) to offer IDs\n    mapping(bytes32 => UintSet.Set) private _tokenOffers;\n\n    // RankedSet of house IDs\n    RankedSet.Set private _rankedHouses;\n\n    // RankedAddressSet of creators\n    RankedAddressSet.Set private _rankedCreators;\n\n    // RankedAddressSet of collectors\n    RankedAddressSet.Set private _rankedCollectors;\n\n    // OrderedSet of active token contracts\n    RankedAddressSet.Set private _rankedContracts;\n\n    // OrderedSet of active houses\n    OrderedSet.Set private _activeHouses;\n\n    // OrderedSet of active auction IDs without a house ID\n    OrderedSet.Set private _activeAuctions;\n\n\n    bytes4 constant interfaceId = 0x80ac58cd; // ERC721 interfaceId\n    bytes4 constant interfaceIdMetadata = 0x5b5e139f; // Metadata extension\n    bytes4 constant interfaceIdEnumerable = 0x780e9d63; // Enumerable extension\n\n\n    modifier auctionExists(uint256 auctionId) {\n        require(\n            auctions[auctionId].tokenOwner != address(0),\n            \"Does not exist\");\n        _;\n    }\n\n    modifier onlyHouseCurator(uint256 houseId) {\n        require(\n            msg.sender == houses[houseId].curator,\n            \"Not house curator\");\n        _;\n    }\n\n\n    /*\n     * Constructor\n     */\n    constructor(\n        address tuxERC20_\n    ) {\n        tuxERC20 = tuxERC20_;\n    }\n\n    function totalHouses() public view override returns (uint256) {\n        return _lastHouseId;\n    }\n\n    function totalAuctions() public view override returns (uint256) {\n        return _lastAuctionId;\n    }\n\n    function totalContracts() public view override returns (uint256) {\n        return _rankedContracts.length();\n    }\n\n    function totalCreators() public view override returns (uint256) {\n        return _rankedCreators.length();\n    }\n\n    function totalCollectors() public view override returns (uint256) {\n        return _rankedCollectors.length();\n    }\n\n    function totalActiveHouses() public view override returns (uint256) {\n        return _activeHouses.length();\n    }\n\n    function totalActiveAuctions() public view override returns (uint256) {\n        return _activeAuctions.length();\n    }\n\n    function totalActiveHouseAuctions(uint256 houseId) public view override returns (uint256) {\n        return _houseAuctions[houseId].length();\n    }\n\n    function getActiveHouses(uint256 from, uint256 n) public view override returns (uint256[] memory) {\n        return _activeHouses.valuesFromN(from, n);\n    }\n\n    function getRankedHouses(uint256 from, uint256 n) public view override returns (uint256[] memory) {\n        return _rankedHouses.valuesFromN(from, n);\n    }\n\n    function getRankedCreators(address from, uint256 n) public view override returns (address[] memory) {\n        return _rankedCreators.valuesFromN(from, n);\n    }\n\n    function getRankedCollectors(address from, uint256 n) public view override returns (address[] memory) {\n        return _rankedCollectors.valuesFromN(from, n);\n    }\n\n    function getRankedContracts(address from, uint256 n) public view override returns (address[] memory) {\n        return _rankedContracts.valuesFromN(from, n);\n    }\n\n    function getCollections(address creator) external view override returns (address[] memory) {\n        return _collections[creator].values();\n    }\n\n    function getAuctions(uint256 from, uint256 n) public view override returns (uint256[] memory) {\n        return _activeAuctions.valuesFromN(from, n);\n    }\n\n    function getHouseAuctions(uint256 houseId, uint256 from, uint256 n) public view override returns (uint256[] memory) {\n        return _houseAuctions[houseId].valuesFromN(from, n);\n    }\n\n    function getHouseQueue(uint256 houseId) public view override returns (uint256[] memory) {\n        return _houseQueue[houseId].values();\n    }\n\n    function getAuctionBids(uint256 auctionId) public view override returns (uint256[] memory) {\n        return _auctionBids[auctionId].values();\n    }\n\n    function getCuratorHouses(address curator) public view override returns (uint256[] memory) {\n        return _curatorHouses[curator].values();\n    }\n\n    function getCreatorHouses(address creator) public view override returns (uint256[] memory) {\n        return _creatorHouses[creator].values();\n    }\n\n    function getHouseCreators(uint256 houseId) public view override returns (address[] memory) {\n        return _houseCreators[houseId].values();\n    }\n\n    function getSellerAuctions(address seller) public view override returns (uint256[] memory) {\n        return _sellerAuctions[seller].values();\n    }\n\n    function getBidderAuctions(address bidder) public view override returns (uint256[] memory) {\n        return _bidderAuctions[bidder].values();\n    }\n\n    function getPreviousAuctions(bytes32 tokenHash) public view override returns (uint256[] memory) {\n        return _previousTokenAuctions[tokenHash].values();\n    }\n\n    function getTokenOffers(bytes32 tokenHash) public view override returns (uint256[] memory) {\n        return _tokenOffers[tokenHash].values();\n    }\n\n\n    function createHouse(\n        string  memory name,\n        address curator,\n        uint16  fee,\n        bool    preApproved,\n        string  memory metadata\n    )\n        public\n        override\n    {\n        require(\n            houseIDs[name] == 0,\n            \"Already exists\");\n        require(\n            bytes(name).length > 0,\n            \"Name required\");\n        require(\n            bytes(name).length <= 32,\n            \"Name too long\");\n        require(\n            curator != address(0),\n            \"Address required\");\n        require(\n            fee < 10000,\n            \"Fee too high\");\n\n        _lastHouseId += 1;\n        uint256 houseId = _lastHouseId;\n\n        houses[houseId].name = name;\n        houses[houseId].curator = payable(curator);\n        houses[houseId].fee = fee;\n        houses[houseId].preApproved = preApproved;\n        houses[houseId].metadata = metadata;\n\n        _curatorHouses[curator].add(houseId);\n        _rankedHouses.add(houseId);\n        houseIDs[name] = houseId;\n\n        ITuxERC20(tuxERC20).updateFeatured();\n        ITuxERC20(tuxERC20).mint(msg.sender, 5 * 10**18);\n\n        emit HouseCreated(\n            houseId\n        );\n    }\n\n    function addCreator(\n        uint256 houseId,\n        address creator\n    )\n        public\n        override\n        onlyHouseCurator(houseId)\n    {\n        require(\n            _houseCreators[houseId].contains(creator) == false,\n            \"Already added\");\n\n        _houseCreators[houseId].add(creator);\n        _creatorHouses[creator].add(houseId);\n\n        ITuxERC20(tuxERC20).mint(msg.sender, 1 * 10**18);\n\n        emit CreatorAdded(\n            houseId,\n            creator\n        );\n    }\n\n    function removeCreator(\n        uint256 houseId,\n        address creator\n    )\n        public\n        override\n        onlyHouseCurator(houseId)\n    {\n        require(\n            _houseCreators[houseId].contains(creator) == true,\n            \"Already removed\");\n\n        _houseCreators[houseId].remove(creator);\n        _creatorHouses[creator].remove(houseId);\n\n        emit CreatorRemoved(\n            houseId,\n            creator\n        );\n    }\n\n    function updateFee(\n        uint256 houseId,\n        uint16  fee\n    )\n        public\n        override\n        onlyHouseCurator(houseId)\n    {\n        require(\n            fee < 10000,\n            \"Fee too high\");\n\n        houses[houseId].fee = fee;\n\n        emit FeeUpdated(\n            houseId,\n            fee\n        );\n    }\n\n    function updateMetadata(\n        uint256 houseId,\n        string memory metadata\n    )\n        public\n        override\n        onlyHouseCurator(houseId)\n    {\n        houses[houseId].metadata = metadata;\n\n        emit MetadataUpdated(\n            houseId,\n            metadata\n        );\n    }\n\n    function updateName(\n        string  memory name\n    )\n        public\n        override\n    {\n        accounts[msg.sender].name = name;\n\n        emit AccountUpdated(\n            msg.sender\n        );\n    }\n\n    function updateBio(\n        string  memory bioHash\n    )\n        public\n        override\n    {\n        accounts[msg.sender].bioHash = bioHash;\n\n        emit AccountUpdated(\n            msg.sender\n        );\n    }\n\n    function updatePicture(\n        string  memory pictureHash\n    )\n        public\n        override\n    {\n        accounts[msg.sender].pictureHash = pictureHash;\n\n        emit AccountUpdated(\n            msg.sender\n        );\n    }\n\n    function createAuction(\n        address tokenContract,\n        uint256 tokenId,\n        uint256 duration,\n        uint256 reservePrice,\n        uint256 houseId\n    )\n        public\n        override\n    {\n        if (contracts[tokenContract].tokenContract == address(0)) {\n            registerTokenContract(tokenContract);\n        }\n\n        address tokenOwner = IERC721(tokenContract).ownerOf(tokenId);\n        require(\n            msg.sender == tokenOwner ||\n            msg.sender == IERC721(tokenContract).getApproved(tokenId),\n            \"Not owner or approved\");\n\n        uint16  fee = 0;\n        bool    preApproved = true;\n        address curator = address(0);\n\n        if (houseId > 0) {\n            curator = houses[houseId].curator;\n\n            require(\n                curator != address(0),\n                \"House does not exist\");\n            require(\n                _houseCreators[houseId].contains(tokenOwner) || msg.sender == curator,\n                \"Not approved by curator\");\n\n            fee = houses[houseId].fee;\n            preApproved = houses[houseId].preApproved;\n            houses[houseId].activeAuctions += 1;\n        }\n\n        try ITux(tokenContract).tokenCreator(tokenId) returns (address creator) {\n            if (!_rankedCreators.contains(creator)) {\n                _rankedCreators.add(creator);\n            }\n        } catch {}\n\n        _lastAuctionId += 1;\n        uint256 auctionId = _lastAuctionId;\n\n        tokenAuction[keccak256(abi.encode(tokenContract, tokenId))] = auctionId;\n\n        _sellerAuctions[tokenOwner].add(auctionId);\n\n        bool approved = (curator == address(0) || preApproved || curator == tokenOwner);\n\n        if (houseId > 0) {\n            if (approved == true) {\n                _houseAuctions[houseId].add(auctionId);\n                if (_activeHouses.head() != houseId) {\n                    if (_activeHouses.contains(houseId)) {\n                        _activeHouses.remove(houseId);\n                    }\n                    _activeHouses.add(houseId);\n                }\n            }\n            else {\n                _houseQueue[houseId].add(auctionId);\n            }\n        }\n        else {\n            _activeAuctions.add(auctionId);\n        }\n\n        auctions[auctionId] = Auction({\n            tokenContract: tokenContract,\n            tokenId: tokenId,\n            tokenOwner: tokenOwner,\n            duration: duration,\n            reservePrice: reservePrice,\n            houseId: houseId,\n            fee: fee,\n            approved: approved,\n            firstBidTime: 0,\n            amount: 0,\n            bidder: payable(0),\n            created: block.timestamp\n        });\n\n        IERC721(tokenContract).transferFrom(tokenOwner, address(this), tokenId);\n\n        ITuxERC20(tuxERC20).updateFeatured();\n        ITuxERC20(tuxERC20).mint(msg.sender, 10 * 10**18);\n\n        emit AuctionCreated(\n            auctionId\n        );\n    }\n\n    function setAuctionApproval(uint256 auctionId, bool approved)\n        public\n        override\n        auctionExists(auctionId)\n    {\n        IAuctions.Auction storage auction = auctions[auctionId];\n        address curator = houses[auction.houseId].curator;\n\n        require(\n            curator == msg.sender,\n            \"Not auction curator\");\n        require(\n            auction.firstBidTime == 0,\n            \"Already started\");\n        require(\n            (approved == true && auction.approved == false) ||\n            (approved == false && auction.approved == true),\n            \"Already in this state\");\n\n        auction.approved = approved;\n\n        if (approved == true) {\n            _houseAuctions[auction.houseId].add(auctionId);\n            _houseQueue[auction.houseId].remove(auctionId);\n\n            if (_activeHouses.head() != auction.houseId) {\n                if (_activeHouses.contains(auction.houseId)) {\n                    _activeHouses.remove(auction.houseId);\n                }\n                _activeHouses.add(auction.houseId);\n            }\n        }\n\n        emit AuctionApprovalUpdated(\n            auctionId,\n            approved\n        );\n    }\n\n    function setAuctionReservePrice(uint256 auctionId, uint256 reservePrice)\n        public\n        override\n        auctionExists(auctionId)\n    {\n        IAuctions.Auction storage auction = auctions[auctionId];\n\n        require(\n            msg.sender == auction.tokenOwner,\n            \"Not token owner\");\n        require(\n            auction.firstBidTime == 0,\n            \"Already started\");\n\n        auction.reservePrice = reservePrice;\n\n        emit AuctionReservePriceUpdated(\n            auctionId,\n            reservePrice\n        );\n    }\n\n    function createBid(uint256 auctionId)\n        public\n        payable\n        override\n        auctionExists(auctionId)\n    {\n        IAuctions.Auction storage auction = auctions[auctionId];\n\n        require(\n            auction.approved,\n            \"Not approved by curator\");\n        require(\n            auction.firstBidTime == 0 ||\n            block.timestamp < auction.firstBidTime + auction.duration,\n            \"Auction expired\");\n        require(\n            msg.value >= auction.amount + (\n                auction.amount * minimumIncrementPercentage / 10000),\n            \"Amount too low\");\n        require(\n            msg.value >= auction.reservePrice,\n            \"Bid below reserve price\");\n\n        address payable lastBidder = auction.bidder;\n        bool isFirstBid = true;\n        if (lastBidder != payable(0)) {\n            isFirstBid = false;\n        }\n\n        if (auction.firstBidTime == 0) {\n            auction.firstBidTime = block.timestamp;\n        } else if (isFirstBid == false) {\n            _handleOutgoingBid(lastBidder, auction.amount);\n        }\n\n        auction.amount = msg.value;\n        auction.bidder = payable(msg.sender);\n\n        if (auction.duration > 0) {\n            _lastBidId += 1;\n            uint256 bidId = _lastBidId;\n\n            bids[bidId] = Bid({\n                timestamp: block.timestamp,\n                bidder: msg.sender,\n                value: msg.value\n            });\n\n            _auctionBids[auctionId].add(bidId);\n            _bidderAuctions[msg.sender].add(auctionId);\n        }\n\n        contracts[auction.tokenContract].bids += 1;\n\n        try ITux(auction.tokenContract).tokenCreator(auction.tokenId) returns (address creator) {\n            if (creator == auction.tokenOwner) {\n                creatorStats[auction.tokenOwner].bids += 1;\n            }\n        } catch {}\n\n        if (collectorStats[msg.sender].bids == 0) {\n            _rankedCollectors.add(msg.sender);\n        }\n        collectorStats[msg.sender].bids += 1;\n\n        if (auction.houseId > 0) {\n            houses[auction.houseId].bids += 1;\n            /* _rankedHouses.rankScore(auction.houseId, houses[auction.houseId].bids); // This gets too expensive... */\n\n            _houseAuctions[auction.houseId].remove(auctionId);\n            _houseAuctions[auction.houseId].add(auctionId);\n        }\n\n        bool extended = false;\n        if (auction.duration > 0) {\n          uint256 timeRemaining = auction.firstBidTime + auction.duration - block.timestamp;\n          if (timeRemaining < timeBuffer) {\n              auction.duration += timeBuffer - timeRemaining;\n              extended = true;\n          }\n        }\n\n        ITuxERC20(tuxERC20).updateFeatured();\n        ITuxERC20(tuxERC20).mint(msg.sender, 10 * 10**18);\n\n        emit AuctionBid(\n            auctionId,\n            msg.sender,\n            msg.value,\n            isFirstBid,\n            extended\n        );\n\n        if (extended) {\n            emit AuctionDurationExtended(\n                auctionId,\n                auction.duration\n            );\n        }\n    }\n\n    function endAuction(uint256 auctionId)\n        public\n        override\n        auctionExists(auctionId)\n    {\n        IAuctions.Auction storage auction = auctions[auctionId];\n\n        require(\n            uint256(auction.firstBidTime) != 0,\n            \"Not started\");\n        require(\n            block.timestamp >=\n            auction.firstBidTime + auction.duration,\n            \"Not ended\");\n\n        try IERC721(auction.tokenContract).safeTransferFrom(\n            address(this), auction.bidder, auction.tokenId\n        ) {} catch {\n            _handleOutgoingBid(auction.bidder, auction.amount);\n            _cancelAuction(auctionId);\n            return;\n        }\n\n        uint256 houseId = auction.houseId;\n        address curator = address(0);\n        uint256 curatorFee = 0;\n        uint256 tokenOwnerProfit = auction.amount;\n\n        collectorStats[auction.bidder].bought += 1;\n        collectorStats[auction.bidder].totalSpent += tokenOwnerProfit;\n        contracts[auction.tokenContract].sales += 1;\n        contracts[auction.tokenContract].total += tokenOwnerProfit;\n\n        try ITux(auction.tokenContract).tokenCreator(auction.tokenId) returns (address creator) {\n            if (creator == auction.tokenOwner) {\n                creatorStats[creator].sales += 1;\n                creatorStats[creator].total += tokenOwnerProfit;\n            } else {\n                collectorStats[auction.tokenOwner].sales += 1;\n                collectorStats[auction.tokenOwner].totalSold += tokenOwnerProfit;\n            }\n        } catch {\n            collectorStats[auction.tokenOwner].sales += 1;\n            collectorStats[auction.tokenOwner].totalSold += tokenOwnerProfit;\n        }\n\n        if (houseId > 0) {\n            curator = houses[houseId].curator;\n            houses[houseId].sales += 1;\n            houses[houseId].total += tokenOwnerProfit;\n            if (houses[houseId].activeAuctions > 0) {\n                houses[houseId].activeAuctions -= 1;\n            }\n            _houseAuctions[houseId].remove(auctionId);\n        }\n        else {\n            _activeAuctions.remove(auctionId);\n        }\n\n        if (curator != address(0) && auction.fee > 0) {\n            curatorFee = tokenOwnerProfit * auction.fee / 10000;\n            tokenOwnerProfit = tokenOwnerProfit - curatorFee;\n            _handleOutgoingBid(curator, curatorFee);\n        }\n        _handleOutgoingBid(auction.tokenOwner, tokenOwnerProfit);\n\n        if (houseId > 0) {\n            houses[houseId].feesTotal += curatorFee;\n        }\n\n        bytes32 auctionHash = keccak256(abi.encode(auction.tokenContract, auction.tokenId));\n        _previousTokenAuctions[auctionHash].add(auctionId);\n        delete tokenAuction[auctionHash];\n\n        if (auction.duration > 0) {\n            uint256 i = _auctionBids[auctionId].length();\n            while (i > 0) {\n                uint256 bidId = _auctionBids[auctionId].at(i - 1);\n                _bidderAuctions[bids[bidId].bidder].remove(auctionId);\n                i--;\n            }\n        }\n\n        _sellerAuctions[auction.tokenOwner].remove(auctionId);\n\n        ITuxERC20(tuxERC20).updateFeatured();\n        ITuxERC20(tuxERC20).mint(msg.sender, 10 * 10**18);\n\n        emit AuctionEnded(\n            auctionId\n        );\n    }\n\n    function buyAuction(uint256 auctionId)\n        public\n        payable\n        override\n    {\n        createBid(auctionId);\n        endAuction(auctionId);\n    }\n\n    function cancelAuction(uint256 auctionId)\n        public\n        override\n        auctionExists(auctionId)\n    {\n        require(\n            auctions[auctionId].tokenOwner == msg.sender,\n            \"Not auction owner\");\n        require(\n            uint256(auctions[auctionId].firstBidTime) == 0,\n            \"Already started\");\n\n        _cancelAuction(auctionId);\n    }\n\n    function registerTokenContract(address tokenContract)\n        public\n        override\n    {\n        require(\n            contracts[tokenContract].tokenContract == address(0),\n            \"Already registered\");\n        require(\n            IERC165(tokenContract).supportsInterface(interfaceId),\n            \"Does not support ERC721\");\n        require(\n            IERC165(tokenContract).supportsInterface(interfaceIdMetadata),\n            \"Does not support ERC721Metadata\");\n        require(\n            IERC165(tokenContract).supportsInterface(interfaceIdEnumerable),\n            \"Does not support ERC721Enumerable\");\n\n        contracts[tokenContract].name = IERC721Metadata(tokenContract).name();\n        contracts[tokenContract].tokenContract = tokenContract;\n\n        try ITux(tokenContract).owner() returns(address owner) {\n            if (owner != address(0)) {\n                _collections[owner].add(tokenContract);\n            }\n        } catch {}\n\n        _rankedContracts.add(tokenContract);\n\n        ITuxERC20(tuxERC20).mint(msg.sender, 1 * 10**18);\n    }\n\n    function makeOffer(address tokenContract, uint256 tokenId)\n        public\n        payable\n        override\n    {\n        require(\n            IERC165(tokenContract).supportsInterface(interfaceId),\n            \"Does not support ERC721\");\n\n        bytes32 auctionHash = keccak256(abi.encode(tokenContract, tokenId));\n        require(\n            tokenAuction[auctionHash] == 0,\n            \"Auction exists\");\n\n        _lastOfferId += 1;\n        uint256 offerId = _lastOfferId;\n\n        offers[offerId] = Offer({\n            tokenContract: tokenContract,\n            tokenId: tokenId,\n            from: msg.sender,\n            amount: msg.value,\n            timestamp: block.timestamp\n        });\n\n        _tokenOffers[auctionHash].add(offerId);\n\n        ITuxERC20(tuxERC20).mint(msg.sender, 1 * 10**18);\n    }\n\n    function acceptOffer(uint256 offerId)\n        public\n        override\n    {\n        IAuctions.Offer storage offer = offers[offerId];\n        require(\n            offer.tokenContract != address(0),\n            \"Does not exist\");\n        require(\n            msg.sender == IERC721(offer.tokenContract).ownerOf(offer.tokenId) ||\n            msg.sender == IERC721(offer.tokenContract).getApproved(offer.tokenId),\n            \"Not owner or approved\");\n\n        IERC721(offer.tokenContract).safeTransferFrom(msg.sender, offer.from, offer.tokenId);\n\n        _handleOutgoingBid(msg.sender, offer.amount);\n\n        bytes32 auctionHash = keccak256(abi.encode(offer.tokenContract, offer.tokenId));\n        _tokenOffers[auctionHash].remove(offerId);\n\n        delete offers[offerId];\n\n        ITuxERC20(tuxERC20).mint(msg.sender, 1 * 10**18);\n    }\n\n    function cancelOffer(uint256 offerId)\n        public\n        override\n    {\n        IAuctions.Offer storage offer = offers[offerId];\n        require(\n            offer.from == msg.sender,\n            \"Not owner or missing\");\n\n        _handleOutgoingBid(msg.sender, offer.amount);\n\n        bytes32 auctionHash = keccak256(abi.encode(offer.tokenContract, offer.tokenId));\n        _tokenOffers[auctionHash].remove(offerId);\n\n        delete offers[offerId];\n    }\n\n    function updateHouseRank(uint256 houseId)\n        public\n        override\n    {\n        require(\n            _rankedHouses.scoreOf(houseId) < houses[houseId].bids,\n            \"Rank up to date\");\n\n        _rankedHouses.rankScore(houseId, houses[houseId].bids);\n\n        ITuxERC20(tuxERC20).mint(msg.sender, 1 * 10**18);\n    }\n\n    function updateCreatorRank(address creator)\n        public\n        override\n    {\n        require(\n            _rankedCreators.scoreOf(creator) < creatorStats[creator].bids,\n            \"Rank up to date\");\n\n        _rankedCreators.rankScore(creator, creatorStats[creator].bids);\n\n        ITuxERC20(tuxERC20).mint(msg.sender, 1 * 10**18);\n    }\n\n    function updateCollectorRank(address collector)\n        public\n        override\n    {\n        require(\n            _rankedCollectors.scoreOf(collector) < collectorStats[collector].bids,\n            \"Rank up to date\");\n\n        _rankedCollectors.rankScore(collector, collectorStats[collector].bids);\n\n        ITuxERC20(tuxERC20).mint(msg.sender, 1 * 10**18);\n    }\n\n    function updateContractRank(address tokenContract)\n        public\n        override\n    {\n        require(\n            _rankedContracts.scoreOf(tokenContract) < contracts[tokenContract].bids,\n            \"Rank up to date\");\n\n        _rankedContracts.rankScore(tokenContract, contracts[tokenContract].bids);\n\n        ITuxERC20(tuxERC20).mint(msg.sender, 1 * 10**18);\n    }\n\n    function feature(uint256 auctionId, uint256 amount)\n        public\n        override\n    {\n        require(\n            auctions[auctionId].tokenOwner == msg.sender,\n            \"Not token owner\");\n        ITuxERC20(tuxERC20).feature(auctionId, amount, msg.sender);\n    }\n\n    function cancelFeature(uint256 auctionId)\n        public\n        override\n    {\n        require(\n            auctions[auctionId].tokenOwner == msg.sender,\n            \"Not token owner\");\n        ITuxERC20(tuxERC20).cancel(auctionId, msg.sender);\n    }\n\n    function _handleOutgoingBid(address to, uint256 amount) internal {\n        require(\n            _safeTransferETH(to, amount),\n            \"ETH transfer failed\");\n    }\n\n    function _safeTransferETH(address to, uint256 value) internal returns (bool) {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        return success;\n    }\n\n    function _cancelAuction(uint256 auctionId) internal {\n        IAuctions.Auction storage auction = auctions[auctionId];\n\n        IERC721(auction.tokenContract).safeTransferFrom(address(this), auction.tokenOwner, auction.tokenId);\n\n        uint256 houseId = auction.houseId;\n        if (houseId > 0) {\n            _houseAuctions[houseId].remove(auctionId);\n            if (houses[houseId].activeAuctions > 0) {\n                houses[houseId].activeAuctions -= 1;\n            }\n        }\n        else {\n            _activeAuctions.remove(auctionId);\n        }\n\n        auction.approved = false;\n        bytes32 auctionHash = keccak256(abi.encode(auction.tokenContract, auction.tokenId));\n        _previousTokenAuctions[auctionHash].add(auctionId);\n        delete tokenAuction[auctionHash];\n\n        emit AuctionCanceled(\n            auctionId\n        );\n    }\n}"},"IAuctions.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.9;\n\n\ninterface IAuctions {\n\n    struct House {\n        // House name\n        string  name;\n\n        // House curator\n        address payable curator;\n\n        // House percentage fee\n        uint16  fee;\n\n        // Pre-approve added creators\n        bool    preApproved;\n\n        // IPFS hash for metadata (logo, featured creators, pieces, links)\n        string  metadata;\n\n        // Total bids\n        uint256 bids;\n\n        // Total sales number\n        uint256 sales;\n\n        // Total sales amount\n        uint256 total;\n\n        // Total fees amount\n        uint256 feesTotal;\n\n        // Counter of active autions\n        uint256 activeAuctions;\n    }\n\n    struct Auction {\n        // Address of the ERC721 contract\n        address tokenContract;\n\n        // ERC721 tokenId\n        uint256 tokenId;\n\n        // Address of the token owner\n        address tokenOwner;\n\n        // Length of time in seconds to run the auction for, after the first bid was made\n        uint256 duration;\n\n        // Minimum price of the first bid\n        uint256 reservePrice;\n\n        // House ID for curator address\n        uint256 houseId;\n\n        // Curator fee for this auction\n        uint16  fee;\n\n        // Whether or not the auction curator has approved the auction to start\n        bool    approved;\n\n        // The time of the first bid\n        uint256 firstBidTime;\n\n        // The current highest bid amount\n        uint256 amount;\n\n        // The address of the current highest bidder\n        address payable bidder;\n\n        // The timestamp when this auction was created\n        uint256 created;\n    }\n\n    struct TokenContract {\n        string  name;\n        address tokenContract;\n        uint256 bids;\n        uint256 sales;\n        uint256 total;\n    }\n\n    struct Account {\n        string  name;\n        string  bioHash;\n        string  pictureHash;\n    }\n\n    struct CreatorStats {\n        uint256 bids;\n        uint256 sales;\n        uint256 total;\n    }\n\n    struct CollectorStats {\n        uint256 bids;\n        uint256 sales;\n        uint256 bought;\n        uint256 totalSold;\n        uint256 totalSpent;\n    }\n\n    struct Bid {\n        uint256 timestamp;\n        address bidder;\n        uint256 value;\n    }\n\n    struct Offer {\n        address tokenContract;\n        uint256 tokenId;\n        address from;\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    event HouseCreated(\n        uint256 indexed houseId\n    );\n\n    event CreatorAdded(\n        uint256 indexed houseId,\n        address indexed creator\n    );\n\n    event CreatorRemoved(\n        uint256 indexed houseId,\n        address indexed creator\n    );\n\n    event FeeUpdated(\n        uint256 indexed houseId,\n        uint16  fee\n    );\n\n    event MetadataUpdated(\n        uint256 indexed houseId,\n        string  metadata\n    );\n\n    event AccountUpdated(\n        address indexed owner\n    );\n\n    event AuctionCreated(\n        uint256 indexed auctionId\n    );\n\n    event AuctionApprovalUpdated(\n        uint256 indexed auctionId,\n        bool    approved\n    );\n\n    event AuctionReservePriceUpdated(\n        uint256 indexed auctionId,\n        uint256 reservePrice\n    );\n\n    event AuctionBid(\n        uint256 indexed auctionId,\n        address indexed bidder,\n        uint256 value,\n        bool    firstBid,\n        bool    extended\n    );\n\n    event AuctionDurationExtended(\n        uint256 indexed auctionId,\n        uint256 duration\n    );\n\n    event AuctionEnded(\n        uint256 indexed auctionId\n    );\n\n    event AuctionCanceled(\n        uint256 indexed auctionId\n    );\n\n    function totalHouses() external view returns (uint256);\n\n    function totalAuctions() external view returns (uint256);\n\n    function totalContracts() external view returns (uint256);\n\n    function totalCreators() external view returns (uint256);\n\n    function totalCollectors() external view returns (uint256);\n\n    function totalActiveHouses() external view returns (uint256);\n\n    function totalActiveAuctions() external view returns (uint256);\n\n    function totalActiveHouseAuctions(uint256 houseId) external view returns (uint256);\n\n    function getActiveHouses(uint256 from, uint256 n) external view returns (uint256[] memory);\n\n    function getRankedHouses(uint256 from, uint256 n) external view returns (uint256[] memory);\n\n    function getRankedCreators(address from, uint256 n) external view returns (address[] memory);\n\n    function getRankedCollectors(address from, uint256 n) external view returns (address[] memory);\n\n    function getRankedContracts(address from, uint256 n) external view returns (address[] memory);\n\n    function getCollections(address creator) external view returns (address[] memory);\n\n    function getAuctions(uint256 from, uint256 n) external view returns (uint256[] memory);\n\n    function getHouseAuctions(uint256 houseId, uint256 from, uint256 n) external view returns (uint256[] memory);\n\n    function getHouseQueue(uint256 houseId) external view returns (uint256[] memory);\n\n    function getCuratorHouses(address curator) external view returns (uint256[] memory);\n\n    function getCreatorHouses(address creator) external view returns (uint256[] memory);\n\n    function getHouseCreators(uint256 houseId) external view returns (address[] memory);\n\n    function getSellerAuctions(address seller) external view returns (uint256[] memory);\n\n    function getBidderAuctions(address bidder) external view returns (uint256[] memory);\n\n    function getAuctionBids(uint256 auctionId) external view returns (uint256[] memory);\n\n    function getPreviousAuctions(bytes32 tokenHash) external view returns (uint256[] memory);\n\n    function getTokenOffers(bytes32 tokenHash) external view returns (uint256[] memory);\n\n    function registerTokenContract(\n        address tokenContract\n    ) external;\n\n    function makeOffer(\n        address tokenContract,\n        uint256 tokenId\n    ) external payable;\n\n    function acceptOffer(\n        uint256 offerId\n    ) external;\n\n    function cancelOffer(\n        uint256 offerId\n    ) external;\n\n    function createHouse(\n        string  memory name,\n        address curator,\n        uint16  fee,\n        bool    preApproved,\n        string  memory metadata\n    ) external;\n\n    function addCreator(\n        uint256 houseId,\n        address creator\n    ) external;\n\n    function removeCreator(\n        uint256 houseId,\n        address creator\n    ) external;\n\n    function updateMetadata(\n        uint256 houseId,\n        string  memory metadata\n    ) external;\n\n    function updateFee(\n        uint256 houseId,\n        uint16  fee\n    ) external;\n\n    function updateName(\n        string  memory name\n    ) external;\n\n    function updateBio(\n        string  memory bioHash\n    ) external;\n\n    function updatePicture(\n        string  memory pictureHash\n    ) external;\n\n    function createAuction(\n        address tokenContract,\n        uint256 tokenId,\n        uint256 duration,\n        uint256 reservePrice,\n        uint256 houseId\n    ) external;\n\n    function setAuctionApproval(\n        uint256 auctionId,\n        bool approved\n    ) external;\n\n    function setAuctionReservePrice(\n        uint256 auctionId,\n        uint256 reservePrice\n    ) external;\n\n    function createBid(\n        uint256 auctionId\n    ) external payable;\n\n    function endAuction(\n        uint256 auctionId\n    ) external;\n\n    function buyAuction(\n      uint256 auctionId\n    ) external payable;\n\n    function cancelAuction(\n        uint256 auctionId\n    ) external;\n\n    function feature(\n        uint256 auctionId,\n        uint256 amount\n    ) external;\n\n    function cancelFeature(\n        uint256 auctionId\n    ) external;\n\n    function updateHouseRank(\n        uint256 houseId\n    ) external;\n\n    function updateCreatorRank(\n        address creator\n    ) external;\n\n    function updateCollectorRank(\n        address collector\n    ) external;\n\n    function updateContractRank(\n        address tokenContract\n    ) external;\n}"},"ITux.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.9;\n\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface ITux is IERC721 {\n    function owner() external view returns (address);\n    function tokenCreator(uint256 tokenId) external view returns (address);\n    function creatorTokens(address creator) external view returns (uint256[] memory);\n}"},"ITuxERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface ITuxERC20 {\n    function mint(address to, uint256 amount) external;\n\n    function feature(\n        uint256 auctionId,\n        uint256 amount,\n        address from\n    ) external;\n\n    function cancel(\n        uint256 auctionId,\n        address from\n    ) external;\n\n    function updateFeatured() external;\n    function payouts() external;\n}"},"Test.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\n\npragma solidity 0.8.9;\nimport { Auctions } from \"./Auctions.sol\";\nimport { TuxERC20 } from \"./TuxERC20.sol\";\n\ncontract Test {\n\n    Auctions _auctions = Auctions(0x06d3E950fE4CeD87c7b24e8336B8688CE2c0Ca9c);\n\n    function run(string[] memory str) public {\n       for (uint i = 0; i < str.length; i++) {\n         _auctions.createHouse(str[i], address(0x18f67d110E7c6fCc3A25E4f27b13976EA86FE970), 500, true, \"\");\n        TuxERC20(0xBb76A956eF664c942bC2e952B172e553118a463c).transfer(address(0x18f67d110E7c6fCc3A25E4f27b13976EA86FE970), 5000000000000000000 );\n\n       } \n       \n    } \n}\n\n"},"TuxERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./ITuxERC20.sol\";\nimport \"./library/RankedSet.sol\";\nimport \"./library/AddressSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - Preminted initial supply\n *  - Ability for holders to burn (destroy) their tokens\n *  - No access control mechanism (for minting/pausing) and hence no governance\n *\n * This contract uses {ERC20Burnable} to include burn capabilities - head to\n * its documentation for details.\n *\n * _Available since v3.4._\n */\ncontract TuxERC20 is\n    ITuxERC20,\n    ERC20Burnable\n{\n    using RankedSet for RankedSet.Set;\n    using AddressSet for AddressSet.Set;\n\n    // Admin address for managing payout addresses\n    address public owner;\n\n    // Tux auctions address\n    address public minter;\n\n    // Currently featured auction\n    uint256 public featured;\n\n    // Timestamp of next featured auction\n    uint256 public nextFeaturedTime;\n\n    // Amount of time for featured auctions\n    uint256 constant public featuredDuration = 3600; // 1 hour -> 3600 seconds\n\n    // Amount of time between payouts\n    uint256 constant public payoutsFrequency = 604800; // 7 days -> 604800 seconds\n\n    // Timestamp of next payouts\n    uint256 public nextPayoutsTime = block.timestamp + payoutsFrequency;\n\n    // Payout amount to pinning and API services\n    uint256 public payoutAmount = 100 * 10**18;\n\n    // AddressSet of payout addresses to pinning and API services\n    AddressSet.Set private _payoutAddresses;\n\n    // RankedSet for queue of next featured auction\n    RankedSet.Set private _featuredQueue;\n\n    /**\n     * @dev Mints 100,000 tokens and adds payout addresses.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {\n        owner = msg.sender;\n\n        _mint(owner, 100000 * 10**18);\n\n        _payoutAddresses.add(0x71C7656EC7ab88b098defB751B7401B5f6d8976F); // Etherscan\n        // _payoutAddresses.add(0xInfura); // Infura\n        // _payoutAddresses.add(0xPinata); // Pinata\n        // _payoutAddresses.add(0xAlchemy); // Alchemy\n        // _payoutAddresses.add(0xNFT.Storage); // nft.storage\n    }\n\n    /**\n     * @dev Sets the minting address.\n     */\n    function setMinter(address minter_)\n        external\n    {\n        require(\n            msg.sender == owner,\n            \"Not owner address\");\n\n        minter = minter_;\n    }\n\n    /**\n     * @dev Add a payout address, up to 10.\n     */\n    function addPayoutAddress(address payoutAddress)\n        external\n    {\n        require(\n            msg.sender == owner,\n            \"Not owner address\");\n        require(\n            _payoutAddresses.length() < 10,\n            \"Maximum reached\");\n\n        _payoutAddresses.add(payoutAddress);\n    }\n\n    /**\n     * @dev Remove a payout address.\n     */\n    function removePayoutAddress(address payoutAddress)\n        external\n    {\n        require(\n            msg.sender == owner,\n            \"Not owner address\");\n\n        _payoutAddresses.remove(payoutAddress);\n    }\n\n    /**\n     * @dev Update payout amount up to 1000.\n     */\n    function updatePayoutAmount(uint256 amount)\n        external\n    {\n        require(\n            msg.sender == owner,\n            \"Not owner address\");\n        require(\n            amount < 1000 * 10**18,\n            \"Amount too high\");\n\n        payoutAmount = amount;\n    }\n\n    /**\n     * @dev Renounce ownership once payout addresses are added and the payout\n     * amount gets settled.\n     */\n    function renounceOwnership()\n        external\n    {\n        require(\n            msg.sender == owner,\n            \"Not owner address\");\n\n        owner = address(0);\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must be the Tux auctions contract.\n     */\n    function mint(address to, uint256 amount)\n        external\n        virtual\n        override\n    {\n        require(\n            msg.sender == minter,\n            \"Not minter address\");\n\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount)\n        public\n        override(ERC20Burnable)\n    {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * Add Tux auction to featured queue\n     */\n    function feature(uint256 auctionId, uint256 amount, address from)\n        external\n        virtual\n        override\n    {\n        require(\n            msg.sender == minter,\n            \"Not minter address\");\n        require(\n            balanceOf(from) >= amount,\n            \"Not enough TUX\");\n        require(\n            _featuredQueue.contains(auctionId) == false,\n            \"Already queued\");\n        require(\n            amount >= 1 * 10**18,\n            \"Price too low\");\n\n        updateFeatured();\n\n        _burn(from, amount);\n\n        _featuredQueue.add(auctionId);\n        _featuredQueue.rankScore(auctionId, amount);\n\n        payouts();\n    }\n\n    function cancel(uint256 auctionId, address from)\n        external\n        virtual\n        override\n    {\n        require(\n            msg.sender == minter,\n            \"Not minter address\");\n        require(\n            _featuredQueue.contains(auctionId) == true,\n            \"Not queued\");\n\n        _mint(from, _featuredQueue.scoreOf(auctionId));\n\n        _featuredQueue.remove(auctionId);\n\n        updateFeatured();\n        payouts();\n    }\n\n    /**\n     * Get featured items\n     */\n    function getFeatured(uint256 from, uint256 n)\n        view\n        public\n        returns(uint256[] memory)\n    {\n        return _featuredQueue.valuesFromN(from, n);\n    }\n\n    /**\n     * Get featured queue length\n     */\n    function getFeaturedLength()\n        view\n        public\n        returns(uint256 length)\n    {\n        return _featuredQueue.length();\n    }\n\n    /**\n     * Get if featured queue contains an auction ID\n     */\n    function getFeaturedContains(uint auctionId)\n        view\n        public\n        returns(bool)\n    {\n        return _featuredQueue.contains(auctionId);\n    }\n\n    /**\n     * Get next featured timestamp\n     */\n    function getNextFeaturedTime()\n        view\n        public\n        returns(uint256 timestamp)\n    {\n        return nextFeaturedTime;\n    }\n\n    /**\n     * Get featured price of queue item\n     */\n    function getFeaturedPrice(uint256 auctionId)\n        view\n        public\n        returns(uint256 price)\n    {\n        return _featuredQueue.scoreOf(auctionId);\n    }\n\n    /**\n     * Update featured queue\n     */\n    function updateFeatured()\n        public\n        override\n    {\n        if (block.timestamp < nextFeaturedTime || _featuredQueue.length() == 0) {\n            return;\n        }\n\n        nextFeaturedTime = block.timestamp + featuredDuration;\n        uint256 auctionId = _featuredQueue.head();\n        _featuredQueue.remove(auctionId);\n        featured = auctionId;\n\n        _mint(msg.sender, 1 * 10**18);\n    }\n\n    /**\n     * Mint weekly payouts to pinning and API services\n     */\n    function payouts()\n        public\n        override\n    {\n        if (block.timestamp < nextPayoutsTime) {\n            return;\n        }\n\n        nextPayoutsTime = block.timestamp + payoutsFrequency;\n\n        for (uint i = 0; i < _payoutAddresses.length(); i++) {\n            _mint(_payoutAddresses.at(i), payoutAmount);\n        }\n\n        _mint(msg.sender, 1 * 10**18);\n    }\n}"},"library/AddressSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `address` (`addressSet`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary AddressSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // address values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in address.\n\n    struct Set {\n        // Storage of set values\n        address[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(address => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Set storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Set storage set, address value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                address lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Set storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(Set storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Set storage set, uint256 index) internal view returns (address) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Set storage set) internal view returns (address[] memory) {\n        return set._values;\n    }\n}"},"library/OrderedAddressSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title OrderedSet\n * @dev Ordered data structure. It has the properties of a mapping of uint256, but members are ordered\n * and can be enumerated. Values can be inserted and removed from anywhere. Add, append, remove and\n * contains are O(1). Enumerate is O(N).\n */\nlibrary OrderedAddressSet {\n\n    struct Set {\n        uint256 count;\n        mapping (address => address) _next;\n        mapping (address => address) _prev;\n    }\n\n    /**\n     * @dev Insert a value between two values\n     */\n    function insert(Set storage set, address prev_, address value, address next_) internal {\n        set._next[prev_] = value;\n        set._next[value] = next_;\n        set._prev[next_] = value;\n        set._prev[value] = prev_;\n        set.count += 1;\n    }\n\n    /**\n     * @dev Insert a value as the new head\n     */\n    function add(Set storage set, address value) internal {\n        insert(set, address(0), value, set._next[address(0)]);\n    }\n\n    /**\n     * @dev Insert a value as the new tail\n     */\n    function append(Set storage set, address value) internal {\n        insert(set, set._prev[address(0)], value, address(0));\n    }\n\n    /**\n     * @dev Remove a value\n     */\n    function remove(Set storage set, address value) internal {\n        set._next[set._prev[value]] = set._next[value];\n        set._prev[set._next[value]] = set._prev[value];\n        delete set._next[value];\n        delete set._prev[value];\n        if (set.count > 0) {\n            set.count -= 1;\n        }\n    }\n\n    /**\n     * @dev Returns the head\n     */\n    function head(Set storage set) internal view returns (address) {\n        return set._next[address(0)];\n    }\n\n    /**\n     * @dev Returns the tail\n     */\n    function tail(Set storage set) internal view returns (address) {\n        return set._prev[address(0)];\n    }\n\n    /**\n     * @dev Returns the length\n     */\n    function length(Set storage set) internal view returns (uint256) {\n        return set.count;\n    }\n\n    /**\n     * @dev Returns the next value\n     */\n    function next(Set storage set, address _value) internal view returns (address) {\n        return set._next[_value];\n    }\n\n    /**\n     * @dev Returns the previous value\n     */\n    function prev(Set storage set, address _value) internal view returns (address) {\n        return set._prev[_value];\n    }\n\n    /**\n     * @dev Returns true if the value is in the set\n     */\n    function contains(Set storage set, address value) internal view returns (bool) {\n        return set._next[address(0)] == value ||\n               set._next[value] != address(0) ||\n               set._prev[value] != address(0);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Set storage set) internal view returns (address[] memory) {\n        address[] memory _values = new address[](set.count);\n        address value = set._next[address(0)];\n        uint256 i = 0;\n        while (value != address(0)) {\n            _values[i] = value;\n            value = set._next[value];\n            i += 1;\n        }\n        return _values;\n    }\n\n    /**\n     * @dev Return an array with n values in the set, starting after \"from\"\n     */\n    function valuesFromN(Set storage set, address from, uint256 n) internal view returns (address[] memory) {\n        address[] memory _values = new address[](n);\n        address value = set._next[from];\n        uint256 i = 0;\n        while (i < n) {\n            _values[i] = value;\n            value = set._next[value];\n            i += 1;\n        }\n        return _values;\n    }\n}"},"library/OrderedSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title OrderedSet\n * @dev Ordered data structure. It has the properties of a mapping of uint256, but members are ordered\n * and can be enumerated. Values can be inserted and removed from anywhere. Add, append, remove and\n * contains are O(1). Enumerate is O(N).\n */\nlibrary OrderedSet {\n\n    struct Set {\n        uint256 count;\n        mapping (uint256 => uint256) _next;\n        mapping (uint256 => uint256) _prev;\n    }\n\n    /**\n     * @dev Insert a value between two values\n     */\n    function insert(Set storage set, uint256 prev_, uint256 value, uint256 next_) internal {\n        set._next[prev_] = value;\n        set._next[value] = next_;\n        set._prev[next_] = value;\n        set._prev[value] = prev_;\n        set.count += 1;\n    }\n\n    /**\n     * @dev Insert a value as the new head\n     */\n    function add(Set storage set, uint256 value) internal {\n        insert(set, 0, value, set._next[0]);\n    }\n\n    /**\n     * @dev Insert a value as the new tail\n     */\n    function append(Set storage set, uint256 value) internal {\n        insert(set, set._prev[0], value, 0);\n    }\n\n    /**\n     * @dev Remove a value\n     */\n    function remove(Set storage set, uint256 value) internal {\n        set._next[set._prev[value]] = set._next[value];\n        set._prev[set._next[value]] = set._prev[value];\n        delete set._next[value];\n        delete set._prev[value];\n        if (set.count > 0) {\n            set.count -= 1;\n        }\n    }\n\n    /**\n     * @dev Returns the head\n     */\n    function head(Set storage set) internal view returns (uint256) {\n        return set._next[0];\n    }\n\n    /**\n     * @dev Returns the tail\n     */\n    function tail(Set storage set) internal view returns (uint256) {\n        return set._prev[0];\n    }\n\n    /**\n     * @dev Returns the length\n     */\n    function length(Set storage set) internal view returns (uint256) {\n        return set.count;\n    }\n\n    /**\n     * @dev Returns the next value\n     */\n    function next(Set storage set, uint256 _value) internal view returns (uint256) {\n        return set._next[_value];\n    }\n\n    /**\n     * @dev Returns the previous value\n     */\n    function prev(Set storage set, uint256 _value) internal view returns (uint256) {\n        return set._prev[_value];\n    }\n\n    /**\n     * @dev Returns true if the value is in the set\n     */\n    function contains(Set storage set, uint256 value) internal view returns (bool) {\n        return set._next[0] == value ||\n               set._next[value] != 0 ||\n               set._prev[value] != 0;\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Set storage set) internal view returns (uint256[] memory) {\n        uint256[] memory _values = new uint256[](set.count);\n        uint256 value = set._next[0];\n        uint256 i = 0;\n        while (value != 0) {\n            _values[i] = value;\n            value = set._next[value];\n            i += 1;\n        }\n        return _values;\n    }\n\n    /**\n     * @dev Return an array with n values in the set, starting after \"from\"\n     */\n    function valuesFromN(Set storage set, uint256 from, uint256 n) internal view returns (uint256[] memory) {\n        uint256[] memory _values = new uint256[](n);\n        uint256 value = set._next[from];\n        uint256 i = 0;\n        while (i < n) {\n            _values[i] = value;\n            value = set._next[value];\n            i += 1;\n        }\n        return _values;\n    }\n}"},"library/RankedAddressSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./OrderedSet.sol\";\nimport \"./OrderedAddressSet.sol\";\n\n/**\n * @title RankedSet\n * @dev Ranked data structure using two ordered sets, a mapping of scores to\n * boundary values, a mapping of last ranked scores, and a highest score.\n */\nlibrary RankedAddressSet {\n    using OrderedSet for OrderedSet.Set;\n    using OrderedAddressSet for OrderedAddressSet.Set;\n\n    struct RankGroup {\n        uint256 count;\n        address start;\n        address end;\n    }\n\n    struct Set {\n        uint256 highScore;\n        mapping(uint256 => RankGroup) rankgroups;\n        mapping(address => uint256) scores;\n        OrderedSet.Set rankedScores;\n        OrderedAddressSet.Set rankedItems;\n    }\n\n    /**\n     * @dev Add an item at the end of the set\n     */\n    function add(Set storage set, address item) internal {\n        set.rankedItems.append(item);\n        set.rankgroups[0].end = item;\n        set.rankgroups[0].count += 1;\n        if (set.rankgroups[0].start == address(0)) {\n            set.rankgroups[0].start = item;\n        }\n    }\n\n    /**\n     * @dev Remove an item\n     */\n    function remove(Set storage set, address item) internal {\n        uint256 score = set.scores[item];\n        delete set.scores[item];\n\n        RankGroup storage rankgroup = set.rankgroups[score];\n        if (rankgroup.count > 0) {\n            rankgroup.count -= 1;\n        }\n\n        if (rankgroup.count == 0) {\n            rankgroup.start = address(0);\n            rankgroup.end = address(0);\n            if (score == set.highScore) {\n                set.highScore = set.rankedScores.next(score);\n            }\n            if (score > 0) {\n                set.rankedScores.remove(score);\n            }\n        } else {\n            if (rankgroup.start == item) {\n                rankgroup.start = set.rankedItems.next(item);\n            }\n            if (rankgroup.end == item) {\n                rankgroup.end = set.rankedItems.prev(item);\n            }\n        }\n\n        set.rankedItems.remove(item);\n    }\n\n    /**\n     * @dev Returns the head\n     */\n    function head(Set storage set) internal view returns (address) {\n        return set.rankedItems._next[address(0)];\n    }\n\n    /**\n     * @dev Returns the tail\n     */\n    function tail(Set storage set) internal view returns (address) {\n        return set.rankedItems._prev[address(0)];\n    }\n\n    /**\n     * @dev Returns the length\n     */\n    function length(Set storage set) internal view returns (uint256) {\n        return set.rankedItems.count;\n    }\n\n    /**\n     * @dev Returns the next value\n     */\n    function next(Set storage set, address _value) internal view returns (address) {\n        return set.rankedItems._next[_value];\n    }\n\n    /**\n     * @dev Returns the previous value\n     */\n    function prev(Set storage set, address _value) internal view returns (address) {\n        return set.rankedItems._prev[_value];\n    }\n\n    /**\n     * @dev Returns true if the value is in the set\n     */\n    function contains(Set storage set, address value) internal view returns (bool) {\n        return set.rankedItems._next[address(0)] == value ||\n               set.rankedItems._next[value] != address(0) ||\n               set.rankedItems._prev[value] != address(0);\n    }\n\n    /**\n     * @dev Returns a value's score\n     */\n    function scoreOf(Set storage set, address value) internal view returns (uint256) {\n        return set.scores[value];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Set storage set) internal view returns (address[] memory) {\n        address[] memory _values = new address[](set.rankedItems.count);\n        address value = set.rankedItems._next[address(0)];\n        uint256 i = 0;\n        while (value != address(0)) {\n            _values[i] = value;\n            value = set.rankedItems._next[value];\n            i += 1;\n        }\n        return _values;\n    }\n\n    /**\n     * @dev Return an array with n values in the set, starting after \"from\"\n     */\n    function valuesFromN(Set storage set, address from, uint256 n) internal view returns (address[] memory) {\n        address[] memory _values = new address[](n);\n        address value = set.rankedItems._next[from];\n        uint256 i = 0;\n        while (i < n) {\n            _values[i] = value;\n            value = set.rankedItems._next[value];\n            i += 1;\n        }\n        return _values;\n    }\n\n    /**\n     * @dev Rank new score\n     */\n    function rankScore(Set storage set, address item, uint256 newScore) internal {\n        RankGroup storage rankgroup = set.rankgroups[newScore];\n\n        if (newScore > set.highScore) {\n            remove(set, item);\n            rankgroup.start = item;\n            set.highScore = newScore;\n            set.rankedItems.add(item);\n            set.rankedScores.add(newScore);\n        } else {\n            uint256 score = set.scores[item];\n            uint256 prevScore = set.rankedScores.prev(score);\n\n            if (set.rankgroups[score].count == 1) {\n                score = set.rankedScores.next(score);\n            }\n\n            remove(set, item);\n\n            while (prevScore > 0 && newScore > prevScore) {\n                prevScore = set.rankedScores.prev(prevScore);\n            }\n\n            set.rankedItems.insert(\n                set.rankgroups[prevScore].end,\n                item,\n                set.rankgroups[set.rankedScores.next(prevScore)].start\n            );\n\n            if (rankgroup.count == 0) {\n                set.rankedScores.insert(prevScore, newScore, score);\n                rankgroup.start = item;\n            }\n        }\n\n        rankgroup.end = item;\n        rankgroup.count += 1;\n\n        set.scores[item] = newScore;\n    }\n}"},"library/RankedSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./OrderedSet.sol\";\n\n/**\n * @title RankedSet\n * @dev Ranked data structure using two ordered sets, a mapping of scores to\n * boundary values and counter, a mapping of last ranked scores, and a highest\n * score.\n */\nlibrary RankedSet {\n    using OrderedSet for OrderedSet.Set;\n\n    struct RankGroup {\n        uint256 count;\n        uint256 start;\n        uint256 end;\n    }\n\n    struct Set {\n        uint256 highScore;\n        mapping(uint256 => RankGroup) rankgroups;\n        mapping(uint256 => uint256) scores;\n        OrderedSet.Set rankedScores;\n        OrderedSet.Set rankedItems;\n    }\n\n    /**\n     * @dev Add an item at the end of the set\n     */\n    function add(Set storage set, uint256 item) internal {\n        set.rankedItems.append(item);\n        set.rankgroups[0].end = item;\n        set.rankgroups[0].count += 1;\n        if (set.rankgroups[0].start == 0) {\n            set.rankgroups[0].start = item;\n        }\n    }\n\n    /**\n     * @dev Remove an item\n     */\n    function remove(Set storage set, uint256 item) internal {\n        uint256 score = set.scores[item];\n        delete set.scores[item];\n\n        RankGroup storage rankgroup = set.rankgroups[score];\n        if (rankgroup.count > 0) {\n            rankgroup.count -= 1;\n        }\n\n        if (rankgroup.count == 0) {\n            rankgroup.start = 0;\n            rankgroup.end = 0;\n            if (score == set.highScore) {\n                set.highScore = set.rankedScores.next(score);\n            }\n            if (score > 0) {\n                set.rankedScores.remove(score);\n            }\n        } else {\n            if (rankgroup.start == item) {\n                rankgroup.start = set.rankedItems.next(item);\n            }\n            if (rankgroup.end == item) {\n                rankgroup.end = set.rankedItems.prev(item);\n            }\n        }\n\n        set.rankedItems.remove(item);\n    }\n\n    /**\n     * @dev Returns the head\n     */\n    function head(Set storage set) internal view returns (uint256) {\n        return set.rankedItems._next[0];\n    }\n\n    /**\n     * @dev Returns the tail\n     */\n    function tail(Set storage set) internal view returns (uint256) {\n        return set.rankedItems._prev[0];\n    }\n\n    /**\n     * @dev Returns the length\n     */\n    function length(Set storage set) internal view returns (uint256) {\n        return set.rankedItems.count;\n    }\n\n    /**\n     * @dev Returns the next value\n     */\n    function next(Set storage set, uint256 _value) internal view returns (uint256) {\n        return set.rankedItems._next[_value];\n    }\n\n    /**\n     * @dev Returns the previous value\n     */\n    function prev(Set storage set, uint256 _value) internal view returns (uint256) {\n        return set.rankedItems._prev[_value];\n    }\n\n    /**\n     * @dev Returns true if the value is in the set\n     */\n    function contains(Set storage set, uint256 value) internal view returns (bool) {\n        return set.rankedItems._next[0] == value ||\n               set.rankedItems._next[value] != 0 ||\n               set.rankedItems._prev[value] != 0;\n    }\n\n    /**\n     * @dev Returns a value's score\n     */\n    function scoreOf(Set storage set, uint256 value) internal view returns (uint256) {\n        return set.scores[value];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Set storage set) internal view returns (uint256[] memory) {\n        uint256[] memory _values = new uint256[](set.rankedItems.count);\n        uint256 value = set.rankedItems._next[0];\n        uint256 i = 0;\n        while (value != 0) {\n            _values[i] = value;\n            value = set.rankedItems._next[value];\n            i += 1;\n        }\n        return _values;\n    }\n\n    /**\n     * @dev Return an array with n values in the set, starting after \"from\"\n     */\n    function valuesFromN(Set storage set, uint256 from, uint256 n) internal view returns (uint256[] memory) {\n        uint256[] memory _values = new uint256[](n);\n        uint256 value = set.rankedItems._next[from];\n        uint256 i = 0;\n        while (i < n) {\n            _values[i] = value;\n            value = set.rankedItems._next[value];\n            i += 1;\n        }\n        return _values;\n    }\n\n    /**\n     * @dev Rank new score\n     */\n    function rankScore(Set storage set, uint256 item, uint256 newScore) internal {\n        RankGroup storage rankgroup = set.rankgroups[newScore];\n\n        if (newScore > set.highScore) {\n            remove(set, item);\n            rankgroup.start = item;\n            set.highScore = newScore;\n            set.rankedItems.add(item);\n            set.rankedScores.add(newScore);\n        } else {\n            uint256 score = set.scores[item];\n            uint256 prevScore = set.rankedScores.prev(score);\n\n            if (set.rankgroups[score].count == 1) {\n                score = set.rankedScores.next(score);\n            }\n\n            remove(set, item);\n\n            while (prevScore > 0 && newScore > prevScore) {\n                prevScore = set.rankedScores.prev(prevScore);\n            }\n\n            set.rankedItems.insert(\n                set.rankgroups[prevScore].end,\n                item,\n                set.rankgroups[set.rankedScores.next(prevScore)].start\n            );\n\n            if (rankgroup.count == 0) {\n                set.rankedScores.insert(prevScore, newScore, score);\n                rankgroup.start = item;\n            }\n        }\n\n        rankgroup.end = item;\n        rankgroup.count += 1;\n\n        set.scores[item] = newScore;\n    }\n}"},"library/UintSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary UintSet {\n\n    struct Set {\n        // Storage of set values\n        uint256[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(uint256 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Set storage set, uint256 value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Set storage set, uint256 value) internal returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                uint256 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Set storage set, uint256 value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(Set storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Set storage set, uint256 index) internal view returns (uint256) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Set storage set) internal view returns (uint256[] memory) {\n        return set._values;\n    }\n}"}}}