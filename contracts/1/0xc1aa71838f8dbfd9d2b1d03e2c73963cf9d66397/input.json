{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/gohmarb.sol": {
      "content": "pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './lib/SafeMath.sol';\r\n\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\n\r\ninterface v2pool{\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface migrator{\r\n    function migrate(\r\n        uint256 _amount,\r\n        uint8 _from,\r\n        uint8 _to\r\n    ) external;\r\n    function bridgeBack(uint256 _amount, uint8 _to) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract gohmarb {\r\n    using SafeMath for uint;\r\n    \r\n    address payable public owner;\r\n    \r\n\r\n    \r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        \r\n        // approve wsohm    \r\n        IERC20(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65)).approve(address(0x184f3FAd8618a6F458C16bae63F70C426fE784B3), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        // approve gohm\r\n        IERC20(address(0x0ab87046fBb341D058F17CBC4c1133F25a20a52f)).approve(address(0x184f3FAd8618a6F458C16bae63F70C426fE784B3), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function approvetoken(address token, address target) external onlyowner{\r\n        IERC20(token).approve(target, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n    }\r\n\r\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\r\n    \r\n        (uint256 v2outamount, uint256 fdt_out, uint256 fdt_back)  = abi.decode(_data, (uint256, uint256, uint256));\r\n\r\n\r\n        // fdt -> gohm --> wsohm -> fdt\r\n        // convert gohm to wsohm, sell for fdt payback\r\n        if(msg.sender == address(0x75b02b9889536B617d57D08c1Ccb929c523945C1)){\r\n            // bridge back gohm to wsohm\r\n            migrator(address(0x184f3FAd8618a6F458C16bae63F70C426fE784B3)).bridgeBack(v2outamount, 2);\r\n            // sell wsohm for fdt\r\n            _safeTransfer(address(0xCa76543Cf381ebBB277bE79574059e32108e3E65), address(0x2E30E758b3950DD9aFeD2e21F5Ab82156FBDbbBA), v2outamount);\r\n            v2pool(address(0x2E30E758b3950DD9aFeD2e21F5Ab82156FBDbbBA)).swap(0, fdt_out, address(this), new bytes(0));\r\n\r\n            // payback fdt\r\n            _safeTransfer(address(0xEd1480d12bE41d92F36f5f7bDd88212E381A3677), msg.sender, fdt_back);\r\n\r\n        }\r\n\r\n\r\n        // fdt -> wsohm --> gohm -> fdt\r\n        if(msg.sender == address(0x2E30E758b3950DD9aFeD2e21F5Ab82156FBDbbBA)){\r\n            // migrate wsohm -> gohm\r\n            migrator(address(0x184f3FAd8618a6F458C16bae63F70C426fE784B3)).migrate(v2outamount, 2,2);\r\n            // sell gohm for fdt\r\n            _safeTransfer(address(0x0ab87046fBb341D058F17CBC4c1133F25a20a52f), address(0x75b02b9889536B617d57D08c1Ccb929c523945C1), v2outamount);\r\n            v2pool(address(0x75b02b9889536B617d57D08c1Ccb929c523945C1)).swap(0, fdt_out, address(this), new bytes(0));\r\n\r\n            // payback fdt\r\n            _safeTransfer(address(0xEd1480d12bE41d92F36f5f7bDd88212E381A3677), msg.sender, fdt_back);\r\n        }\r\n        \r\n\r\n    }\r\n\r\n\r\n\r\n    function migratorarb_mem(bool direct, uint256 amountin, uint256 minbenefit) public {\r\n\r\n        bytes memory returnData;\r\n        (, returnData) = address(0x75b02b9889536B617d57D08c1Ccb929c523945C1).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint r0, uint r1, ) = abi.decode(returnData, (uint,uint,uint)); // gohm fdt\r\n\r\n        (, returnData) = address(0x2E30E758b3950DD9aFeD2e21F5Ab82156FBDbbBA).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint r2, uint r3, ) = abi.decode(returnData, (uint,uint,uint)); // wsohm fdt   \r\n\r\n        if(direct){\r\n            uint256 gohm_out = getAmountOut(amountin, r1, r0);\r\n            uint256 fdt_out = getAmountOut(gohm_out, r2, r3);\r\n            require(fdt_out > amountin + minbenefit, \"shit\");\r\n\r\n            bytes memory data = abi.encode(gohm_out, fdt_out, amountin);\r\n\r\n            v2pool(address(0x75b02b9889536B617d57D08c1Ccb929c523945C1)).swap(gohm_out, 0, address(this), data);\r\n        }else{\r\n            uint256 wsohm_out = getAmountOut(amountin, r3, r2);\r\n            uint256 fdt_out = getAmountOut(wsohm_out, r0, r1);\r\n            require(fdt_out > amountin + minbenefit, \"shit\");\r\n\r\n            bytes memory data = abi.encode(wsohm_out, fdt_out, amountin);\r\n            v2pool(address(0x2E30E758b3950DD9aFeD2e21F5Ab82156FBDbbBA)).swap(wsohm_out, 0, address(this), data);\r\n\r\n        }\r\n\r\n\r\n        _safeTransfer(address(0xEd1480d12bE41d92F36f5f7bDd88212E381A3677), msg.sender, IERC20(address(0xEd1480d12bE41d92F36f5f7bDd88212E381A3677)).balanceOf(address(this)) - 1);\r\n\r\n\r\n    }\r\n\r\n    function migratorarb(bool direct, uint256 amountin, uint256 gohm_out, uint256 fdt_out, uint256 minbenefit) public payable{\r\n\r\n        require(block.number <= msg.value, \"fuck\");\r\n\r\n        if(direct){\r\n            bytes memory data = abi.encode(gohm_out, fdt_out, amountin);\r\n            v2pool(address(0x75b02b9889536B617d57D08c1Ccb929c523945C1)).swap(gohm_out, 0, address(this), data);\r\n\r\n        }else{\r\n            // reuse gohm out for wsohm out var\r\n            bytes memory data = abi.encode(gohm_out, fdt_out, amountin);\r\n            v2pool(address(0x2E30E758b3950DD9aFeD2e21F5Ab82156FBDbbBA)).swap(gohm_out, 0, address(this), data);\r\n\r\n        }\r\n\r\n        _safeTransfer(address(0xEd1480d12bE41d92F36f5f7bDd88212E381A3677), msg.sender, minbenefit - 1);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    } \r\n  \r\n\r\n    function detectarb(uint256 lowerbound, uint256 higherbound , uint256 step) public view returns(uint256 bestin_gohm, uint256 bestprofit_gohm, uint256 bestin_wsohm, uint256 bestprofit_wsohm, uint256 bestmiddle, uint256 finalout){\r\n        bytes memory returnData;\r\n        (, returnData) = address(0x75b02b9889536B617d57D08c1Ccb929c523945C1).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint r0, uint r1, ) = abi.decode(returnData, (uint,uint,uint)); // gohm fdt\r\n\r\n        (, returnData) = address(0x2E30E758b3950DD9aFeD2e21F5Ab82156FBDbbBA).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint r2, uint r3, ) = abi.decode(returnData, (uint,uint,uint)); // wsohm fdt     \r\n\r\n\r\n        uint256 fdt_in = lowerbound;\r\n        // uint256 middle_out;\r\n        // uint256 fdt_out;\r\n        // fdt -> gohm --> wsohm -> fdt\r\n        while(fdt_in < higherbound){\r\n\r\n            uint256 middle_out = getAmountOut(fdt_in, r1, r0);\r\n            uint256 fdt_out = getAmountOut(middle_out, r2, r3);\r\n\r\n            if(fdt_out <  fdt_in){\r\n                break;\r\n            }\r\n\r\n            if(fdt_out - fdt_in < bestprofit_gohm){\r\n                break;\r\n            }else{\r\n                bestprofit_gohm = fdt_out - fdt_in;\r\n                bestin_gohm = fdt_in;\r\n                bestmiddle = middle_out;\r\n                finalout = fdt_out;\r\n                fdt_in = fdt_in + step;\r\n            }\r\n        }\r\n\r\n\r\n        fdt_in = lowerbound;\r\n\r\n        // fdt -> wsohm --> gohm -> fdt\r\n        while(fdt_in < higherbound){\r\n\r\n            uint256 middle_out = getAmountOut(fdt_in, r3, r2);\r\n            uint256 fdt_out = getAmountOut(middle_out, r0, r1);\r\n\r\n            if(fdt_out <  fdt_in){\r\n                break;\r\n            }\r\n\r\n            if(fdt_out - fdt_in < bestprofit_wsohm){\r\n                break;\r\n            }else{\r\n                bestprofit_wsohm = fdt_out - fdt_in;\r\n                bestin_wsohm = fdt_in;\r\n                bestmiddle = middle_out;\r\n                finalout = fdt_out;\r\n                fdt_in = fdt_in + step;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity ^0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"
    }
  }
}