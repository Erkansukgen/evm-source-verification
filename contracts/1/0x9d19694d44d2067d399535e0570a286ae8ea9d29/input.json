{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "s.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-11-28\n*/\n\n/**\n * SPDX-License-Identifier: MIT\n */ \n \n// FLOKI2022 https://t.me/floki2022crypto\n\npragma solidity ^0.8.6;\n\nlibrary SafeMath {\n\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n \n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\n    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) { \n        uint256 size; assembly { size := extcodesize(account) } return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");(bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n        \n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n        \n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n        \n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) { return returndata; } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {revert(errorMessage);}\n        }\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }   \n    \n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    \n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IPancakeV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IPancakeV2Router {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    \n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract FLOKI2022 is IERC20Metadata, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n    \n    address internal deadAddress = 0x000000000000000000000000000000000000dEaD;\n    address public presaleAddress = address(0);\n    \n    address public marketingWallet = 0x5B6B252Fceb83AcE18db9902c05B6Cf3cBa5051b;\n    address public launchpadWallet = 0x82a27faa29fE9632A847132761313579F41F60d2;\n    address public teamWallet = 0x0305b5580400d08B8488e92D01B287BBb0F0a982;\n    \n    string constant _name = \"Floki2022\";\n    string constant _symbol = \"FLOKI2022\";\n    uint8 constant _decimals = 18;\n    \n    uint256 private constant MAX = ~uint256(0);\n    uint256 internal constant _totalSupply = 1000000000000 * (10**18);\n    uint256 internal _reflectedSupply = (MAX - (MAX % _totalSupply));\n    \n    uint256 public collectedFeeTotal;\n  \n    uint256 public maxTxAmount = _totalSupply / 1000; // 0.5% of the total supply\n    uint256 public maxWalletBalance = _totalSupply / 50; // 2% of the total supply\n    \n    bool public takeFeeEnabled = true;\n    bool public tradingIsEnabled = true;\n    bool public isInPresale = false;\n    \n    bool private swapping;\n    bool public swapEnabled = true;\n    uint256 public swapTokensAtAmount = 10000000 * (10**18);\n\n    bool public antiBotEnabled = false;\n    uint256 public antiBotFee = 990; // 99%\n    uint256 public _startTimeForSwap;\n    \n    uint256 internal FEES_DIVISOR = 10**2;\n\n    uint256 public sellingRfiFee = 1;\n    uint256 public buyingRfiFee =1;\n\n    uint256 public sellingMarketingFee = 3;\n    uint256 public buyingMarketingFee = 3;\n    \n    uint256 public sellingLaunchpadFee = 2;\n    uint256 public buyingLaunchpadFee = 2;\n\n    uint256 public sellingTeamFee = 4;\n    uint256 public buyingTeamFee = 4;\n    \n    uint256 public sellingLpFee = 1;\n    uint256 public buyingLpFee = 1;\n    \n    uint256 public buyersTotalFees = buyingRfiFee.add(buyingMarketingFee).add(buyingLaunchpadFee).add(buyingTeamFee).add(buyingLpFee);\n    uint256 public sellersTotalFees = sellingRfiFee.add(sellingMarketingFee).add(sellingLaunchpadFee).add(sellingTeamFee).add(sellingLpFee);\n    \n    // Total = 100% (100)\n    uint256 public marketingPortionOfSwap = 30; // 30%\n    uint256 public launchpadPortionOfSwap = 20; // 20%\n    uint256 public teamPortionOfSwap = 40; // 40%\n    uint256 public lpPortionOfSwap = 10; // 10%\n    \n    IPancakeV2Router public router;\n    address public pair;\n    \n    \n    mapping (address => uint256) internal _reflectedBalances;\n    mapping (address => uint256) internal _balances;\n    mapping (address => mapping (address => uint256)) internal _allowances;\n\n    mapping(address => bool) public _isBlacklisted;\n    \n    mapping (address => bool) internal _isExcludedFromFee;\n    mapping (address => bool) internal _isExcludedFromRewards;\n    address[] private _excluded;\n    \n    event UpdatePancakeswapRouter(address indexed newAddress, address indexed oldAddress);\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    \n    event MarketingWalletUpdated(address indexed newMarketingWallet, address indexed oldMarketingWallet);\n    event LaunchpadWalletUpdated(address indexed newDevWallet, address indexed oldDevWallet);\n    event TeamWalletUpdated(address indexed newTeamWallet, address indexed oldTeamWallet);\n\n    event LiquidityAdded(uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity);\n    \n    event SwapTokensForETH(\n        uint256 amountIn,\n        address[] path\n    );\n    \n    constructor () {\n        _reflectedBalances[owner()] = _reflectedSupply;\n        \n        IPancakeV2Router _newPancakeRouter = IPancakeV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        pair = IPancakeV2Factory(_newPancakeRouter.factory()).createPair(address(this), _newPancakeRouter.WETH());\n        router = _newPancakeRouter;\n        \n        // exclude owner and this contract from fee\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        \n        // exclude the owner and this contract from rewards\n        _exclude(owner());\n        _exclude(address(this));\n        \n        // exclude the pair address from rewards - we don't want to redistribute\n        _exclude(pair);\n        _exclude(deadAddress);\n        \n        _approve(owner(), address(router), ~uint256(0));\n        \n        emit Transfer(address(0), owner(), _totalSupply);\n    }\n    \n    receive() external payable { }\n    \n    function name() external pure override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external pure override returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function balanceOf(address account) public view override returns (uint256){\n        if (_isExcludedFromRewards[account]) return _balances[account];\n        return tokenFromReflection(_reflectedBalances[account]);\n        }\n        \n    function transfer(address recipient, uint256 amount) external override returns (bool){\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n        }\n        \n    function allowance(address owner, address spender) external view override returns (uint256){\n        return _allowances[owner][spender];\n        }\n    \n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n        }\n        \n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool){\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n        }\n        \n    function burn(uint256 amount) external {\n\n        address sender = _msgSender();\n        require(sender != address(0), \"ERC20: burn from the zero address\");\n        require(sender != address(deadAddress), \"ERC20: burn from the burn address\");\n\n        uint256 balance = balanceOf(sender);\n        require(balance >= amount, \"ERC20: burn amount exceeds balance\");\n\n        uint256 reflectedAmount = amount.mul(_getCurrentRate());\n\n        // remove the amount from the sender's balance first\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(reflectedAmount);\n        if (_isExcludedFromRewards[sender])\n            _balances[sender] = _balances[sender].sub(amount);\n\n        _burnTokens( sender, amount, reflectedAmount );\n    }\n    \n    /**\n     * @dev \"Soft\" burns the specified amount of tokens by sending them \n     * to the burn address\n     */\n    function _burnTokens(address sender, uint256 tBurn, uint256 rBurn) internal {\n\n        /**\n         * @dev Do not reduce _totalSupply and/or _reflectedSupply. (soft) burning by sending\n         * tokens to the burn address (which should be excluded from rewards) is sufficient\n         * in RFI\n         */ \n        _reflectedBalances[deadAddress] = _reflectedBalances[deadAddress].add(rBurn);\n        if (_isExcludedFromRewards[deadAddress])\n            _balances[deadAddress] = _balances[deadAddress].add(tBurn);\n\n        /**\n         * @dev Emit the event so that the burn address balance is updated (on bscscan)\n         */\n        emit Transfer(sender, deadAddress, tBurn);\n    }\n    \n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    \n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"BaseRfiToken: approve from the zero address\");\n        require(spender != address(0), \"BaseRfiToken: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n      \n     /**\n     * @dev Calculates and returns the reflected amount for the given amount with or without \n     * the transfer fees (deductTransferFee true/false)\n     */\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee, bool isBuying) external view returns(uint256) {\n         require(tAmount <= _totalSupply, \"Amount must be less than supply\");\n        uint256 feesSum;\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,) = _getValues(tAmount,0);\n            return rAmount;\n        } else {\n            feesSum = isBuying ? buyersTotalFees : sellersTotalFees;\n            feesSum = antiBotEnabled && block.timestamp < _startTimeForSwap ? antiBotFee : feesSum;\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount, feesSum);\n            return rTransferAmount;\n        }\n    }\n\n    /**\n     * @dev Calculates and returns the amount of tokens corresponding to the given reflected amount.\n     */\n    function tokenFromReflection(uint256 rAmount) internal view returns(uint256) {\n        require(rAmount <= _reflectedSupply, \"Amount must be less than total reflections\");\n        uint256 currentRate = _getCurrentRate();\n        return rAmount.div(currentRate);\n    }\n    \n    function excludeFromReward(address account) external onlyOwner() {\n        require(!_isExcludedFromRewards[account], \"Account is not included\");\n        _exclude(account);\n    }\n    \n    function _exclude(address account) internal {\n        if(_reflectedBalances[account] > 0) {\n            _balances[account] = tokenFromReflection(_reflectedBalances[account]);\n        }\n        _isExcludedFromRewards[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeInReward(address account) external onlyOwner() {\n        require(_isExcludedFromRewards[account], \"Account is not excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _balances[account] = 0;\n                _isExcludedFromRewards[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n    \n    function setExcludedFromFee(address account, bool value) external onlyOwner { \n        _isExcludedFromFee[account] = value; \n    }\n\n    function _getValues(uint256 tAmount, uint256 feesSum) internal view returns (uint256, uint256, uint256, uint256, uint256) {\n        \n        uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\n        uint256 tTransferAmount = tAmount.sub(tTotalFees);\n        uint256 currentRate = _getCurrentRate();\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rTotalFees = tTotalFees.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rTotalFees);\n        \n        return (rAmount, rTransferAmount, tAmount, tTransferAmount, currentRate);\n    }\n    \n    function _getCurrentRate() internal view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n    \n    function _getCurrentSupply() internal view returns(uint256, uint256) {\n        uint256 rSupply = _reflectedSupply;\n        uint256 tSupply = _totalSupply;\n\n        /**\n         * The code below removes balances of addresses excluded from rewards from\n         * rSupply and tSupply, which effectively increases the % of transaction fees\n         * delivered to non-excluded holders\n         */    \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_reflectedBalances[_excluded[i]] > rSupply || _balances[_excluded[i]] > tSupply)\n            return (_reflectedSupply, _totalSupply);\n            rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\n            tSupply = tSupply.sub(_balances[_excluded[i]]);\n        }\n        if (tSupply == 0 || rSupply < _reflectedSupply.div(_totalSupply)) return (_reflectedSupply, _totalSupply);\n        return (rSupply, tSupply);\n    }\n    \n    \n    /**\n     * @dev Redistributes the specified amount among the current holders via the reflect.finance\n     * algorithm, i.e. by updating the _reflectedSupply (_rSupply) which ultimately adjusts the\n     * current rate used by `tokenFromReflection` and, in turn, the value returns from `balanceOf`. \n     * \n     */\n    function _redistribute(uint256 amount, uint256 currentRate, uint256 fee) internal {\n        uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\n        uint256 rFee = tFee.mul(currentRate);\n\n        _reflectedSupply = _reflectedSupply.sub(rFee);\n        \n        collectedFeeTotal = collectedFeeTotal.add(tFee);\n    }\n    \n    function _burn(uint256 amount, uint256 currentRate, uint256 fee) private {\n        uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\n        uint256 rBurn = tBurn.mul(currentRate);\n\n        _burnTokens(address(this), tBurn, rBurn);\n        \n        collectedFeeTotal = collectedFeeTotal.add(tBurn);\n    }\n\n    function totalCollectedFees() external view returns (uint256) {\n        return collectedFeeTotal;\n    }\n    \n     function isExcludedFromReward(address account) external view returns (bool) {\n        return _isExcludedFromRewards[account];\n    }\n    \n    function isExcludedFromFee(address account) public view returns(bool) { \n        return _isExcludedFromFee[account]; \n    }\n    \n    function whitelistDxSale(address _presaleAddress, address _routerAddress) external onlyOwner {\n  \t    presaleAddress = _presaleAddress;\n  \t    \n        _exclude(_presaleAddress);\n        _isExcludedFromFee[_presaleAddress] = true;\n\n        _exclude(_routerAddress);\n        _isExcludedFromFee[_routerAddress] = true;\n  \t}\n\n    function blacklistAddress(address account, bool value) external onlyOwner{\n        _isBlacklisted[account] = value;\n    }\n \n    function prepareForPreSale() external onlyOwner {\n        takeFeeEnabled = false;\n        swapEnabled = false;\n        isInPresale = true;\n        maxTxAmount = _totalSupply;\n        maxWalletBalance = _totalSupply;\n    }\n    \n    function afterPreSale() external onlyOwner {\n        takeFeeEnabled = true;\n        swapEnabled = true;\n        isInPresale = false;\n        maxTxAmount = _totalSupply / 1000;\n        maxWalletBalance = _totalSupply / 50;\n    }\n    \n    function setSwapEnabled(bool _enabled) external onlyOwner {\n        swapEnabled  = _enabled;\n    }\n    \n    function updateSwapTokensAt(uint256 _swaptokens) external onlyOwner {\n        swapTokensAtAmount = _swaptokens * (10**18);\n    }\n    \n    function updateWalletMax(uint256 _walletMax) external onlyOwner {\n        maxWalletBalance = _walletMax * (10**18);\n    }\n    \n    function updateTransactionMax(uint256 _txMax) external onlyOwner {\n        maxTxAmount = _txMax * (10**18);\n    }\n    \n    function calcBuyersTotalFees() private {\n        buyersTotalFees = buyingRfiFee.add(buyingMarketingFee).add(buyingLaunchpadFee).add(buyingTeamFee).add(buyingLpFee);\n    }\n    \n    function calcSellersTotalFees() private {\n        sellersTotalFees = sellingRfiFee.add(sellingMarketingFee).add(sellingLaunchpadFee).add(sellingTeamFee).add(sellingLpFee);\n    }\n    \n    function updateBuyingRfiFee(uint256 newFee) external onlyOwner {\n        buyingRfiFee = newFee;\n        calcBuyersTotalFees();\n    }\n    \n    function updateBuyingMarketingFee(uint256 newFee) external onlyOwner {\n        buyingMarketingFee = newFee;\n        calcBuyersTotalFees();\n    }\n    \n    function updateBuyingLaunchpadFee(uint256 newFee) external onlyOwner {\n        buyingLaunchpadFee = newFee;\n        calcBuyersTotalFees();\n    }\n    \n    function updateBuyingTeamFee(uint256 newFee) external onlyOwner {\n        buyingTeamFee = newFee;\n        calcBuyersTotalFees();\n    }\n\n    function updateBuyingLpFee (uint256 newFee) external onlyOwner {\n        buyingLpFee = newFee;\n        calcBuyersTotalFees();\n    }\n\n    function updateSellingRfiFee(uint256 newFee) external onlyOwner {\n        sellingRfiFee = newFee;\n        calcSellersTotalFees();\n    }\n    \n    function updateSellingMarketingFee(uint256 newFee) external onlyOwner {\n        sellingMarketingFee = newFee;\n        calcSellersTotalFees();\n    }\n    \n    function updateSellingLaunchpadFee(uint256 newFee) external onlyOwner {\n        sellingLaunchpadFee = newFee;\n        calcSellersTotalFees();\n    }\n    \n    function updateSellingTeamFee(uint256 newFee) external onlyOwner {\n        sellingTeamFee = newFee;\n        calcSellersTotalFees();\n    }\n\n    function updateSellingLpFee (uint256 newFee) external onlyOwner {\n        sellingLpFee = newFee;\n        calcSellersTotalFees();\n    }\n    \n    function updateMarketingWallet(address newMarketingWallet) external onlyOwner {\n        require(newMarketingWallet != marketingWallet, \"The Marketing wallet is already this address\");\n        emit MarketingWalletUpdated(newMarketingWallet, marketingWallet);\n        \n        marketingWallet = newMarketingWallet;\n    }\n    \n    function updateLaunchpadWallet(address newLaunchpadWallet) external onlyOwner {\n        require(newLaunchpadWallet != launchpadWallet, \"The Launchpad wallet is already this address\");\n        emit LaunchpadWalletUpdated(newLaunchpadWallet, launchpadWallet);\n        \n        launchpadWallet = newLaunchpadWallet;\n    }\n    \n    function updateTeamWallet(address newTeamWallet) external onlyOwner {\n        require(newTeamWallet != teamWallet, \"The Team wallet is already this address\");\n        emit TeamWalletUpdated(newTeamWallet, teamWallet);\n        \n        teamWallet = newTeamWallet;\n    }\n    \n    function updatePortionsOfSwap(uint256 marketingPortion, uint256 launchpadPortion, uint256 teamPortion, uint256 lpPortion) \n    external onlyOwner {\n        \n        uint256 totalPortion = marketingPortion.add(launchpadPortion).add(teamPortion).add(lpPortion);\n        require(totalPortion == 100, \"Total must be equal to 100 (100%)\");\n        \n        marketingPortionOfSwap = marketingPortion;\n        launchpadPortionOfSwap = launchpadPortion;\n        teamPortionOfSwap = teamPortion;\n        lpPortionOfSwap = lpPortion;\n    }\n    \n    function setFeesDivisor(uint256 divisor) external onlyOwner() {\n        FEES_DIVISOR = divisor;\n    }\n    \n    function updateTradingIsEnabled(bool tradingStatus) external onlyOwner() {\n        tradingIsEnabled = tradingStatus;\n    }\n    \n    function updateRouterAddress(address newAddress) external onlyOwner {\n        require(newAddress != address(router), \"The router already has that address\");\n        emit UpdatePancakeswapRouter(newAddress, address(router));\n        \n        router = IPancakeV2Router(newAddress);   \n    }\n\n    function toggleAntiBot(bool toggleStatus) external onlyOwner() {\n        antiBotEnabled = toggleStatus;\n        if(antiBotEnabled){\n            _startTimeForSwap = block.timestamp + 60;    \n        }    \n    }\n    \n    function _takeFee(uint256 amount, uint256 currentRate, uint256 fee, address recipient) private {\n        uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\n        uint256 rAmount = tAmount.mul(currentRate);\n\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rAmount);\n        if(_isExcludedFromRewards[recipient])\n            _balances[recipient] = _balances[recipient].add(tAmount);\n\n        collectedFeeTotal = collectedFeeTotal.add(tAmount);\n    }\n    \n    function _transferTokens(address sender, address recipient, uint256 amount, bool takeFee) private {\n        \n        uint256 sumOfFees = buyersTotalFees; // if buying\n\n        bool isBuying = true;\n         \n        if(recipient == pair) {\n            sumOfFees = sellersTotalFees; // if selling\n            isBuying  = false;\n        }\n\n        sumOfFees = antiBotEnabled && block.timestamp <= _startTimeForSwap ? antiBotFee : sumOfFees;\n        \n        if ( !takeFee ){ sumOfFees = 0; }\n        \n        processReflectedBal(sender, recipient, amount, sumOfFees, isBuying);\n       \n    }\n    \n    function processReflectedBal (address sender, address recipient, uint256 amount, uint256 sumOfFees, bool isBuying) private {\n        \n        (uint256 rAmount, uint256 rTransferAmount, uint256 tAmount, \n        uint256 tTransferAmount, uint256 currentRate ) = _getValues(amount, sumOfFees);\n         \n        theReflection(sender, recipient, rAmount, rTransferAmount, tAmount, tTransferAmount); \n        \n        _takeFees(amount, currentRate, sumOfFees, isBuying);\n        \n        emit Transfer(sender, recipient, tTransferAmount);    \n    }\n    \n    function theReflection(address sender, address recipient, uint256 rAmount, uint256 rTransferAmount, uint256 tAmount, \n        uint256 tTransferAmount) private {\n            \n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rTransferAmount);\n        \n        /**\n         * Update the true/nominal balances for excluded accounts\n         */        \n        if (_isExcludedFromRewards[sender]) { _balances[sender] = _balances[sender].sub(tAmount); }\n        if (_isExcludedFromRewards[recipient] ) { _balances[recipient] = _balances[recipient].add(tTransferAmount); }\n    }\n    \n    \n    function _takeFees(uint256 amount, uint256 currentRate, uint256 sumOfFees, bool isBuying) private {\n        \n         if ( sumOfFees > 0 && !isInPresale ){\n            if(antiBotEnabled && block.timestamp < _startTimeForSwap) {\n                _takeFee( amount, currentRate, antiBotFee, address(this));    \n            }\n            else if(isBuying) {\n                _redistribute( amount, currentRate, buyingRfiFee);\n                _takeFee( amount, currentRate, buyingMarketingFee, address(this));\n                _takeFee( amount, currentRate, buyingLpFee, address(this));\n                _takeFee( amount, currentRate, buyingLaunchpadFee, address(this));\n                _takeFee( amount, currentRate, buyingTeamFee, address(this));     \n            }\n            else{\n                _redistribute( amount, currentRate, sellingRfiFee);\n                _takeFee( amount, currentRate, sellingMarketingFee, address(this));\n                _takeFee( amount, currentRate, sellingLpFee, address(this));\n                _takeFee( amount, currentRate, sellingLaunchpadFee, address(this));\n                _takeFee( amount, currentRate, sellingTeamFee, address(this));\n            }\n        }\n    }\n    \n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"Token: transfer from the zero address\");\n        require(recipient != address(0), \"Token: transfer to the zero address\");\n        require(sender != address(deadAddress), \"Token: transfer from the burn address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        \n        require(tradingIsEnabled, \"This account cannot send tokens until trading is enabled\");\n\n        require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], \"Blacklisted address\");\n        \n        if (\n            sender != address(router) && //router -> pair is removing liquidity which shouldn't have max\n            !_isExcludedFromFee[recipient] && //no max for those excluded from fees\n            !_isExcludedFromFee[sender] \n        ) {\n            require(amount <= maxTxAmount, \"Transfer amount exceeds the Max Transaction Amount.\");\n            \n        }\n        \n        if ( maxWalletBalance > 0 && !_isExcludedFromFee[recipient] && !_isExcludedFromFee[sender] && recipient != address(pair) ) {\n                uint256 recipientBalance = balanceOf(recipient);\n                require(recipientBalance + amount <= maxWalletBalance, \"New balance would exceed the maxWalletBalance\");\n            }\n            \n         // indicates whether or not fee should be deducted from the transfer\n        bool _isTakeFee = takeFeeEnabled;\n        if ( isInPresale ){ _isTakeFee = false; }\n        \n         // if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) { \n            _isTakeFee = false; \n        }\n        \n        _beforeTokenTransfer(recipient);\n        _transferTokens(sender, recipient, amount, _isTakeFee);\n        \n    }\n    \n    function _beforeTokenTransfer(address recipient) private {\n            \n        if ( !isInPresale ){\n            uint256 contractTokenBalance = balanceOf(address(this));\n            // swap\n            bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n            \n            if (!swapping && canSwap && swapEnabled && recipient == pair) {\n                swapping = true;\n                \n                swapBack();\n  \n                swapping = false;\n            }\n            \n        }\n    }\n    \n    function swapBack() private {\n        uint256 splitLiquidityPortion = lpPortionOfSwap.div(2);\n        uint256 amountToLiquify = balanceOf(address(this)).mul(splitLiquidityPortion).div(FEES_DIVISOR);\n        uint256 amountToSwap = balanceOf(address(this)).sub(amountToLiquify);\n\n        uint256 balanceBefore = address(this).balance;\n        \n        swapTokensForETH(amountToSwap);\n\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\n        \n        uint256 amountBNBMarketing = amountBNB.mul(marketingPortionOfSwap).div(FEES_DIVISOR);\n        uint256 amountBNBLaunchpad = amountBNB.mul(launchpadPortionOfSwap).div(FEES_DIVISOR);\n        uint256 amountBNBTeam = amountBNB.mul(teamPortionOfSwap).div(FEES_DIVISOR);\n        uint256 amountBNBLiquidity = amountBNB.mul(splitLiquidityPortion).div(FEES_DIVISOR);\n        \n        // Send to addresses\n        transferToAddress(payable(marketingWallet), amountBNBMarketing);\n        transferToAddress(payable(launchpadWallet), amountBNBLaunchpad);\n        transferToAddress(payable(teamWallet), amountBNBTeam);\n\n         // add liquidity\n        _addLiquidity(amountToLiquify, amountBNBLiquidity);\n    }\n\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(router), tokenAmount);\n\n        // add the liquidity\n        (uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity) = router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0,\n            0,\n            owner(),\n            block.timestamp\n        );\n\n        emit LiquidityAdded(tokenAmountSent, ethAmountSent, liquidity);\n    }\n\n    \n    function swapTokensForETH(uint256 tokenAmount) private {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = router.WETH();\n\n        _approve(address(this), address(router), tokenAmount);\n\n        // make the swap\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n        \n        emit SwapTokensForETH(tokenAmount, path);\n    }\n    \n    function transferToAddress(address payable recipient, uint256 amount) private {\n        recipient.transfer(amount);\n    }\n    \n    function TransferETH(address payable recipient, uint256 amount) external onlyOwner {\n        require(recipient != address(0), \"Cannot withdraw the ETH balance to the zero address\");\n        recipient.transfer(amount);\n    }\n    \n}"
    }
  }
}