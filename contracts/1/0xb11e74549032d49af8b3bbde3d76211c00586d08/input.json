{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/flash.sol": {
      "content": "pragma solidity >=0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface Structs {\n    struct Val {\n        uint256 value;\n    }\n    enum ActionType {\n      Deposit,   // supply tokens\n      Withdraw,  // borrow tokens\n      Transfer,  // transfer balance between accounts\n      Buy,       // buy an amount of some token (externally)\n      Sell,      // sell an amount of some token (externally)\n      Trade,     // trade tokens against another account\n      Liquidate, // liquidate an undercollateralized or expiring account\n      Vaporize,  // use excess tokens to zero-out a completely negative account\n      Call       // send arbitrary data to an address\n    }\n    enum AssetDenomination {\n        Wei // the amount is denominated in wei\n    }\n    enum AssetReference {\n        Delta // the amount is given as a delta from the current value\n    }\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n    struct Info {\n        address owner;  // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n}\n\nabstract contract DyDxPool is Structs {\n    function getAccountWei(Info memory account, uint256 marketId) public virtual returns (Wei memory);\n    function operate(Info[] memory, ActionArgs[] memory) public virtual;\n}\n\ncontract DyDxFlashLoan is Structs {\n    DyDxPool pool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e); //this is dydx solo margin sc\n    // token address\n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    mapping(address => uint256) public currencies;\n    constructor() public {\n        currencies[WETH] = 1;\n        currencies[SAI] = 2;\n        currencies[USDC] = 3;\n        currencies[DAI] = 4;\n    }\n    modifier onlyPool() {\n        require(\n            msg.sender == address(pool),\n            \"FlashLoan: could be called by DyDx pool only\"\n        );\n        _;\n    }\n    function tokenToMarketId(address token) public view returns (uint256) {\n        uint256 marketId = currencies[token];\n        require(marketId != 0, \"FlashLoan: Unsupported token\");\n        return marketId - 1;\n    }\n    // the DyDx will call `callFunction(address sender, Info memory accountInfo, bytes memory data) public` after during `operate` call\n    // token: erc20 token for flashloan from dydx\n    function flashloan(\n      address token,\n      uint256 amount,\n      bytes memory data\n    )\n        internal\n    {\n        // approve dydx solo pool\n        IERC20(token).approve(address(pool), amount + 1);\n        Info[] memory _infos = new Info[](1);\n        ActionArgs[] memory _args = new ActionArgs[](3);\n        _infos[0] = Info(address(this), 0);\n        AssetAmount memory _withdrawAmt = AssetAmount(\n            false,\n            AssetDenomination.Wei,\n            AssetReference.Delta,\n            amount\n        );\n        ActionArgs memory _withdraw;\n        _withdraw.actionType = ActionType.Withdraw;\n        _withdraw.accountId = 0;\n        _withdraw.amount = _withdrawAmt;\n        _withdraw.primaryMarketId = tokenToMarketId(token);\n        _withdraw.otherAddress = address(this);\n        _args[0] = _withdraw;\n        ActionArgs memory _call;\n        _call.actionType = ActionType.Call;\n        _call.accountId = 0;\n        _call.otherAddress = address(this);\n        _call.data = data;\n        _args[1] = _call;\n        ActionArgs memory _deposit;\n        AssetAmount memory _depositAmt = AssetAmount(\n            true,\n            AssetDenomination.Wei,\n            AssetReference.Delta,\n            amount + 1\n        );\n        _deposit.actionType = ActionType.Deposit;\n        _deposit.accountId = 0;\n        _deposit.amount = _depositAmt;\n        _deposit.primaryMarketId = tokenToMarketId(token);\n        _deposit.otherAddress = address(this);\n        _args[2] = _deposit;\n        pool.operate(_infos, _args);\n    }\n}\n\ninterface IUniswapV2Router02  {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface Orchastrator {\n    function rebase() external ;\n}\n\ninterface IWeth {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n    function balanceOf(address owner) external view returns(uint);\n}\n\ncontract DyDxFlashloanArb is DyDxFlashLoan{\n\n  address owner;\n\n  IUniswapV2Router02 public uniswapRouterV2;\n \n  constructor() public payable {\n    owner = msg.sender;\n    uniswapRouterV2 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n  }\n\n  modifier onlyOwner () {\n    require(msg.sender == owner);\n    _;\n  }\n\n  // function () external payable {}\n\n\n  function getFlashloan(\n    uint256 _flashAmount,\n    address token,\n    address rebaser\n  )\n    external\n  {\n      address _flashToken = WETH;\n      uint256 _balanceBefore = IERC20(_flashToken).balanceOf(address(this));\n      bytes memory _data = abi.encode(_flashToken, _flashAmount, _balanceBefore, token, rebaser);\n      flashloan(_flashToken, _flashAmount, _data); // execution goes to `callFunction`\n      // and this point we have succefully paid the dept\n      IWeth(WETH).withdraw(IWeth(WETH).balanceOf(address(this)));\n      selfdestruct(payable(owner));\n  }\n\n  // dydx call back\n  function callFunction(\n    address, // sender\n    Info calldata, // accountInfo\n    bytes calldata _data\n  )\n    external onlyPool\n  {\n    (address flashToken, uint256 flashAmount, uint256 balanceBefore, address token, address rebaser) = abi.decode(_data, (address, uint256, uint256, address, address));\n    uint256 balanceAfter = IERC20(flashToken).balanceOf(address(this));\n    require(balanceAfter - balanceBefore == flashAmount, \"contract did not get the loan\");\n\n    arbTrade(token, balanceAfter, rebaser);\n  }\n\n\n  function arbTrade(address token, uint256 amount, address rebaser) public {\n      \n    // 1. get eth off weth - unwrap weth\n    IWeth(WETH).withdraw(IWeth(WETH).balanceOf(address(this)));\n    \n    // 2. buy defib\n    address[] memory path = new address[](2);\n    path[0] = WETH;\n    path[1] = token;\n    uint[] memory amountInMin = uniswapRouterV2.getAmountsOut(amount, path);\n    uniswapRouterV2.swapExactETHForTokens{value: amount}(\n        amountInMin[1],\n        path,\n        owner,\n        now + 10 minutes\n    );\n\n    // 3. rebase\n    Orchastrator(rebaser).rebase();\n    \n    // 4. sell defib\n    uint256 amountToSell = IERC20(token).balanceOf(address(this));\n    \n    path[0] = token;\n    path[1] = WETH;\n    \n    IERC20(token).approve(address(uniswapRouterV2), amountToSell);\n    \n    uint[] memory amountOutMin = uniswapRouterV2.getAmountsOut(amountToSell, path);\n    \n     uniswapRouterV2.swapExactTokensForETH(\n          amountToSell,\n          amountOutMin[1],\n          path,\n          owner,\n          now + 10 minutes\n        );\n        \n    // 5. get weth from eth - wrap eth\n    IWeth(payable(WETH)).deposit{ value: address(this).balance - 2 }();\n  }\n\n\n}"
    }
  }
}