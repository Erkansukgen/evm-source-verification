{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "JustRouter.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity >=0.6.8 <=0.6.13;\n\n\n\ninterface IRouter {\n    function factory() external pure returns(address);\n    function WBASE() external pure returns(address);\n\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns(uint256 amountA, uint256 amountB, uint256 liquidity);\n    function addLiquidityBase(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) external payable returns(uint256 amountToken, uint256 amountBase, uint256 liquidity);\n    function removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns(uint256 amountA, uint256 amountB);\n    function removeLiquidityBase(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) external returns(uint256 amountToken, uint256 amountBase);\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 amountA, uint256 amountB);\n    function removeLiquidityBaseWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns(uint256 amountToken, uint256 amountBase);\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external returns(uint256[] memory amounts);\n    function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external returns(uint256[] memory amounts);\n    function swapExactBaseForTokens(uint256 amountOutMin, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external payable returns(uint256[] memory amounts);\n    function swapTokensForExactBase(uint256 amountOut, uint256 amountInMax, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external returns(uint256[] memory amounts);\n    function swapExactTokensForBase(uint256 amountIn, uint256 amountOutMin, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external returns(uint256[] memory amounts);\n    function swapBaseForExactTokens(uint256 amountOut, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external payable returns(uint256[] memory amounts);\n\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns(uint256 amountB);\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external pure returns(uint256 amountOut);\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external pure returns(uint256 amountIn);\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns(uint256[] memory amounts);\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns(uint256[] memory amounts);\n    function getAmountsOutTaxed(uint256 amountIn, address[] calldata path, bytes32[] memory taxes) external view returns(uint256[] memory amounts);\n    function getAmountsInTaxed(uint256 amountOut, address[] calldata path, bytes32[] memory taxes) external view returns(uint256[] memory amounts);\n    function syncPair(address pair) external ;\n\n    function removeLiquidityBaseSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) external returns(uint256 amountBase);\n    function removeLiquidityBaseWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns(uint256 amountBase);\n}\n\ninterface IFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns(address);\n    function owner() external view returns(address);\n\n    function getPair(address tokenA, address tokenB) external view returns(address pair);\n    function allPairs(uint256) external view returns(address pair);\n    function allPairsLength() external view returns(uint256);\n\n    function createPair(address tokenA, address tokenB) external returns(address pair);\n\n    function setFeeTo(address) external;\n    function setNewOwner(address) external;\n\n    function INIT_CODE_PAIR_HASH() external view returns(bytes32);\n}\n\ninterface IPair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns(string memory);\n    function symbol() external pure returns(string memory);\n    function decimals() external pure returns(uint8);\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address owner) external view returns(uint256);\n    function allowance(address owner, address spender) external view returns(uint256);\n\n    function approve(address spender, uint256 value) external returns(bool);\n    function transfer(address to, uint256 value) external returns(bool);\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n\n    function DOMAIN_SEPARATOR() external view returns(bytes32);\n    function PERMIT_TYPEHASH() external pure returns(bytes32);\n    function nonces(address owner) external view returns(uint256);\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns(uint256);\n    function factory() external view returns(address);\n    function token0() external view returns(address);\n    function token1() external view returns(address);\n    function getReserves() external view returns(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns(uint256);\n    function price1CumulativeLast() external view returns(uint256);\n    function kLast() external view returns(uint256);\n\n    function mint(address to) external returns(uint256 liquidity);\n    function burn(address to) external returns(uint256 amount0, uint256 amount1);\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IXRC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns(string memory);\n    function symbol() external view returns(string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint256);\n    function balanceOf(address owner) external view returns(uint256);\n    function allowance(address owner, address spender) external view returns(uint256);\n\n    function approve(address spender, uint256 value) external returns(bool);\n    function transfer(address to, uint256 value) external returns(bool);\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n}\n\ninterface IWBASE {\n    function deposit() external payable;\n    function transfer(address to, uint256 value) external returns(bool);\n    function withdraw(uint256) external;\n}\n\nlibrary SwapLibrary {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns(address token0, address token1) {\n        require(tokenA != tokenB, 'SwapLibrary: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'SwapLibrary: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns(address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'f51ca69eb1a82502fdd641b3105488d5e37d94e5277e55f63a9051e664d85c52' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns(uint256 reserveA, uint256 reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        pairFor(factory, tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IPair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns(uint256 amountB) {\n        require(amountA > 0, 'SwapLibrary: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'SwapLibrary: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) internal pure returns(uint256 amountOut) {\n        require(amountIn > 0, 'SwapLibrary: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'SwapLibrary: INSUFFICIENT_LIQUIDITY');\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) internal pure returns(uint256 amountIn) {\n        require(amountOut > 0, 'SwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'SwapLibrary: INSUFFICIENT_LIQUIDITY');\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint256 amountIn, address[] memory path) internal view returns(uint256[] memory amounts) {\n        require(path.length >= 2, 'SwapLibrary: INVALID_PATH');\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint256 amountOut, address[] memory path) internal view returns(uint256[] memory amounts) {\n        require(path.length >= 2, 'SwapLibrary: INVALID_PATH');\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOutTaxed(address factory, uint256 amountIn, address[] memory path, bytes32[] memory taxes) internal view returns(uint256[] memory amounts) {\n        require(path.length >= 2, 'SwapLibrary: INVALID_PATH');\n        require(taxes.length == path.length, 'SwapLibrary: INVALID_TAXES_LENGTH');\n\n        uint256[] memory taxInt = new uint256[](taxes.length);\n        taxInt = bytes32toUint(taxes);\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            if(taxInt[i] > 0) {\n                uint256 taxD = 10**20;\n                amounts[i + 1] = getAmountOut((taxD.sub(taxInt[i])).mul(amounts[i]).div0(taxD), reserveIn, reserveOut);\n            } else {\n                amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n            }\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsInTaxed(address factory, uint256 amountOut, address[] memory path, bytes32[] memory taxes) internal view returns(uint256[] memory amounts) {\n        require(path.length >= 2, 'SwapLibrary: INVALID_PATH');\n        require(taxes.length == path.length, 'SwapLibrary: INVALID_TAXES_LENGTH');\n\n        uint256[] memory taxInt = new uint256[](taxes.length);\n        taxInt = bytes32toUint(taxes);\n        amounts = new uint256[](path.length);\n        uint256 taxD = 10**20;\n        amounts[amounts.length - 1] = (taxInt[taxInt.length - 1] > 0) ? (((taxD.mul(taxD)).div(taxD.sub(taxInt[taxInt.length - 1]))).mul(amountOut)).div(taxD) : amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            if(taxInt[i - 1] > 0){\n                uint256 amountIn = getAmountIn(amounts[i], reserveIn, reserveOut);\n                amounts[i - 1] = (((taxD.mul(taxD)).div(taxD.sub(taxInt[i - 1]))).mul(amountIn)).div(taxD);\n            } else {\n                amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n            }\n        }\n    }\n\n    function bytes32toUint(bytes32[] memory arr) internal pure returns (uint256[] memory) {\n        uint256[] memory toUint = new uint256[](arr.length);\n        for(uint256 j = 0; j < arr.length; j++){\n            for (uint256 i = 0; i < 32; i++) {\n                uint256 c = (uint256(arr[j]) >> (i * 8)) & 0xff;\n                if (48 <= c && c <= 57)\n                    toUint[j] += (c - 48) * 10 ** i;\n                else\n                    break;\n            }\n        }\n        return toUint;\n    }\n\n}\n\n// helper methods for interacting with (X)RC20 tokens and sending (TRX, BSC, ETH) that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferBase(address to, uint256 value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: BASE_TRANSFER_FAILED');\n    }\n}\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x + y) >= x, 'Router SafeMath: ds-math-add-overflow');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x - y) <= x, 'Router SafeMath: ds-math-sub-underflow');\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'Router SafeMath: ds-math-mul-overflow');\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x / y) > 0, 'Router SafeMath: ds-math-div-overflow');\n    }\n    function div0(uint256 x, uint256 y) internal pure returns(uint256) {\n        require(y > 0);\n        uint256 z = x / y;\n        if (z < 0) {\n            z = 0;\n        }\n        return z;\n    }\n}\n\ncontract JMSwapRouter is IRouter {\n    using SafeMath for uint256;\n\n    address public immutable override factory;\n    address public immutable override WBASE;\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WBASE) public {\n        factory = _factory;\n        WBASE = _WBASE;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WBASE); // only accept BASE via fallback from the WBASE contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin) internal virtual returns(uint256 amountA, uint256 amountB) {\n        // create the pair if it doesn't exist yet\n        if (IFactory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IFactory(factory).createPair(tokenA, tokenB);\n        }\n        (uint256 reserveA, uint256 reserveB) = SwapLibrary.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = SwapLibrary.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = SwapLibrary.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external virtual override ensure(deadline) returns(uint256 amountA, uint256 amountB, uint256 liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IPair(pair).mint(to);\n    }\n    function addLiquidityBase(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) external virtual override payable ensure(deadline) returns(uint256 amountToken, uint256 amountBase, uint256 liquidity) {\n        (amountToken, amountBase) = _addLiquidity(token, WBASE, amountTokenDesired, msg.value, amountTokenMin, amountBaseMin);\n        address pair = SwapLibrary.pairFor(factory, token, WBASE);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWBASE(WBASE).deposit{value: amountBase}();\n        assert(IWBASE(WBASE).transfer(pair, amountBase));\n        liquidity = IPair(pair).mint(to);\n        // refund dust (trx, bsc, eth) if any\n        if (msg.value > amountBase) TransferHelper.safeTransferBase(msg.sender, msg.value - amountBase);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) public virtual override ensure(deadline) returns(uint256 amountA, uint256 amountB) {\n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB);\n        IPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IPair(pair).burn(to);\n        (address token0,) = SwapLibrary.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n    }\n    function removeLiquidityBase(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) public virtual override ensure(deadline) returns(uint256 amountToken, uint256 amountBase) {\n        (amountToken, amountBase) = removeLiquidity(token, WBASE, liquidity, amountTokenMin, amountBaseMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWBASE(WBASE).withdraw(amountBase);\n        TransferHelper.safeTransferBase(to, amountBase);\n    }\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external virtual override returns(uint256 amountA, uint256 amountB) {\n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB);\n        uint256 value = approveMax ? uint256(-1) : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityBaseWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external virtual override returns(uint256 amountToken, uint256 amountBase) {\n        address pair = SwapLibrary.pairFor(factory, token, WBASE);\n        uint256 value = approveMax ? uint256(-1) : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountBase) = removeLiquidityBase(token, liquidity, amountTokenMin, amountBaseMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityBaseSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) public virtual override ensure(deadline) returns(uint256 amountBase) {\n        (, amountBase) = removeLiquidity(token, WBASE, liquidity, amountTokenMin, amountBaseMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, IXRC20(token).balanceOf(address(this)));\n        IWBASE(WBASE).withdraw(amountBase);\n        TransferHelper.safeTransferBase(to, amountBase);\n    }\n    function removeLiquidityBaseWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external virtual override returns(uint256 amountBase) {\n        address pair = SwapLibrary.pairFor(factory, token, WBASE);\n        uint256 value = approveMax ? uint256(-1) : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountBase = removeLiquidityBaseSupportingFeeOnTransferTokens(token, liquidity, amountTokenMin, amountBaseMin, to, deadline);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint256 i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = SwapLibrary.sortTokens(input, output);\n            uint256 amountOut = amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));\n            address to = i < path.length - 2 ? SwapLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            IPair(SwapLibrary.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n    function syncPair(address pair) external virtual override {\n        IPair(pair).sync();\n    }\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external virtual override ensure(deadline) returns(uint256[] memory amounts) {\n        amounts = SwapLibrary.getAmountsOutTaxed(factory, amountIn, path, taxes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, SwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external virtual override ensure(deadline) returns(uint256[] memory amounts) {\n        amounts = SwapLibrary.getAmountsInTaxed(factory, amountOut, path, taxes);\n        require(amounts[0] <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, SwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapExactBaseForTokens(uint256 amountOutMin, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external virtual override payable ensure(deadline) returns(uint256[] memory amounts) {\n        require(path[0] == WBASE, 'Router: INVALID_PATH');\n        amounts = SwapLibrary.getAmountsOutTaxed(factory, msg.value, path, taxes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWBASE(WBASE).deposit{value: amounts[0]}();\n        assert(IWBASE(WBASE).transfer(SwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactBase(uint256 amountOut, uint256 amountInMax, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external virtual override ensure(deadline) returns(uint256[] memory amounts) {\n        require(path[path.length - 1] == WBASE, 'Router: INVALID_PATH');\n        amounts = SwapLibrary.getAmountsInTaxed(factory, amountOut, path, taxes);\n        require(amounts[0] <= amountInMax, 'Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, SwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWBASE(WBASE).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferBase(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForBase(uint256 amountIn, uint256 amountOutMin, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external virtual override ensure(deadline) returns(uint256[] memory amounts) {\n        require(path[path.length - 1] == WBASE, 'Router: INVALID_PATH');\n        amounts = SwapLibrary.getAmountsOutTaxed(factory, amountIn, path, taxes);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, SwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWBASE(WBASE).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferBase(to, amounts[amounts.length - 1]);\n    }\n    function swapBaseForExactTokens(uint256 amountOut, address[] calldata path, bytes32[] memory taxes, address to, uint256 deadline) external virtual override payable ensure(deadline) returns(uint256[] memory amounts) {\n        require(path[0] == WBASE, 'Router: INVALID_PATH');\n        amounts = SwapLibrary.getAmountsInTaxed(factory, amountOut, path, taxes);\n        require(amounts[0] <= msg.value, 'Router: EXCESSIVE_INPUT_AMOUNT');\n        IWBASE(WBASE).deposit{value: amounts[0]}();\n        assert(IWBASE(WBASE).transfer(SwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust (trx, bsc, eth) if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferBase(msg.sender, msg.value - amounts[0]);\n    }\n\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) public pure virtual override returns(uint256 amountB) {\n        return SwapLibrary.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) public pure virtual override returns(uint256 amountOut) {\n        return SwapLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) public pure virtual override returns(uint256 amountIn) {\n        return SwapLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(uint256 amountIn, address[] memory path) public view virtual override returns(uint256[] memory amounts) {\n        return SwapLibrary.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint256 amountOut, address[] memory path) public view virtual override returns(uint256[] memory amounts) {\n        return SwapLibrary.getAmountsIn(factory, amountOut, path);\n    }\n\n    function getAmountsOutTaxed(uint256 amountIn, address[] memory path, bytes32[] memory taxes) public view virtual override returns(uint256[] memory amounts) {\n        return SwapLibrary.getAmountsOutTaxed(factory, amountIn, path, taxes);\n    }\n\n    function getAmountsInTaxed(uint256 amountOut, address[] memory path, bytes32[] memory taxes) public view virtual override returns(uint256[] memory amounts) {\n        return SwapLibrary.getAmountsInTaxed(factory, amountOut, path, taxes);\n    }\n\n    function getUserLPwithPair(address user, address pair) external view returns(uint256 totalSupply, uint256 userSupply, uint256 userShare) {\n        totalSupply = IPair(pair).totalSupply();\n        userSupply = IPair(pair).balanceOf(user);\n        userShare = (userSupply.mul(100000000000000000000)).div0(totalSupply);\n    }\n\n    function getUserLP(address user, address tokenA, address tokenB) external view returns(uint256 totalSupply, uint256 userSupply, uint256 userShare) {\n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB);\n        require(pair != address(0), 'Router: INVALID_PATH_LENGTH');\n        totalSupply = IPair(pair).totalSupply();\n        userSupply = IPair(pair).balanceOf(user);\n        userShare = (userSupply.mul(100000000000000000000)).div0(totalSupply);\n    }\n\n    function getPairBalance(address tokenA, address tokenB) external view returns(uint256 balanceTokenA, uint256 balanceTokenB) {\n        balanceTokenA = IXRC20(tokenA).balanceOf(SwapLibrary.pairFor(factory, tokenA, tokenB));\n        balanceTokenB = IXRC20(tokenB).balanceOf(SwapLibrary.pairFor(factory, tokenA, tokenB));\n    }\n\n    function calcPairLiquidity(uint256 amountA, address tokenA, address tokenB, bool reverse) external view returns(uint256 amountB, uint256 share) {\n        (uint256 reserveA, uint256 reserveB) = SwapLibrary.getReserves(factory, tokenA, tokenB);\n\n        amountB = reverse ? SwapLibrary.quote(amountA, reserveB, reserveA) : SwapLibrary.quote(amountA, reserveA, reserveB);\n        share = reverse ? amountA.mul(100) / reserveB.add(amountA) : amountA.mul(100) / reserveA.add(amountA);\n    }\n}"
    }
  }
}