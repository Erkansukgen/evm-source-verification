{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/DS/DSAuth.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./DSAuthority.sol\";\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"},"localhost/DS/DSAuthority.sol":{"content":"pragma solidity ^0.6.0;\n\n\nabstract contract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\n}\n"},"localhost/DS/DSGuard.sol":{"content":"pragma solidity ^0.6.0;\n\n\nabstract contract DSGuard {\n    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function permit(address src, address dst, bytes32 sig) public virtual;\n\n    function forbid(address src, address dst, bytes32 sig) public virtual;\n}\n\n\nabstract contract DSGuardFactory {\n    function newGuard() public virtual returns (DSGuard guard);\n}\n"},"localhost/DS/DSMath.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"},"localhost/DS/DSNote.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n"},"localhost/DS/DSProxy.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./DSAuth.sol\";\nimport \"./DSNote.sol\";\n\n\nabstract contract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache; // global cache for contracts\n\n    constructor(address _cacheAddr) public {\n        require(setCache(_cacheAddr));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    // use the proxy to execute calldata _data on contract _code\n    function execute(bytes memory _code, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (address target, bytes32 response);\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes32 response);\n\n    //set new cache\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\n}\n\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n"},"localhost/auth/ProxyPermission.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../DS/DSGuard.sol\";\nimport \"../DS/DSAuth.sol\";\n\ncontract ProxyPermission {\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n\n    /// @notice Called in the context of DSProxy to authorize an address\n    /// @param _contractAddr Address which will be authorized\n    function givePermission(address _contractAddr) internal {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n\n    /// @notice Called in the context of DSProxy to remove authority of an address\n    /// @param _contractAddr Auth address which will be removed from authority list\n    function removePermission(address _contractAddr) internal {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n}\n"},"localhost/compound/helpers/CompoundSaverHelper.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../../interfaces/CEtherInterface.sol\";\nimport \"../../interfaces/CompoundOracleInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\n\nimport \"../../mcd/Discount.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../DS/DSProxy.sol\";\n\n/// @title Utlity functions for Compound contracts\ncontract CompoundSaverHelper is DSMath {\n\n    address payable public constant WALLET_ADDR = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    address public constant COMPOUND_LOGGER = 0x3DD0CDf5fFA28C6847B4B276e2fD256046a44bb7;\n    address public constant COMPOUND_ORACLE = 0xDDc46a3B076aec7ab3Fc37420A8eDd2959764Ec4;\n\n    /// @notice Helper method to payback the Compound debt\n    /// @dev If amount is bigger it will repay the whole debt and send the extra to the _user\n    /// @param _amount Amount of tokens we want to repay\n    /// @param _cBorrowToken Ctoken address we are repaying\n    /// @param _borrowToken Token address we are repaying\n    /// @param _user Owner of the compound position we are paying back\n    function paybackDebt(uint _amount, address _cBorrowToken, address _borrowToken, address payable _user) internal {\n        uint wholeDebt = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(address(this));\n\n        if (_amount > wholeDebt) {\n            if (_borrowToken == ETH_ADDRESS) {\n                _user.transfer((_amount - wholeDebt));\n            } else {\n                ERC20(_borrowToken).transfer(_user, (_amount - wholeDebt));\n            }\n\n            _amount = wholeDebt;\n        }\n\n        approveCToken(_borrowToken, _cBorrowToken);\n\n        if (_borrowToken == ETH_ADDRESS) {\n            CEtherInterface(_cBorrowToken).repayBorrow{value: _amount}();\n        } else {\n            require(CTokenInterface(_cBorrowToken).repayBorrow(_amount) == 0);\n        }\n    }\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getFee(uint _amount, address _user, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        uint fee = SERVICE_FEE;\n\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            uint ethTokenPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cTokenAddr);\n            _gasCost = rmul(_gasCost, ethTokenPrice);\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        if (tokenAddr == ETH_ADDRESS) {\n            WALLET_ADDR.transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).transfer(WALLET_ADDR, feeAmount);\n        }\n    }\n\n    /// @notice Enters the market for the collatera and borrow tokens\n    /// @param _cTokenAddrColl Collateral address we are entering the market in\n    /// @param _cTokenAddrBorrow Borrow address we are entering the market in\n    function enterMarket(address _cTokenAddrColl, address _cTokenAddrBorrow) internal {\n        address[] memory markets = new address[](2);\n        markets[0] = _cTokenAddrColl;\n        markets[1] = _cTokenAddrBorrow;\n\n        ComptrollerInterface(COMPTROLLER).enterMarkets(markets);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveCToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).approve(_cTokenAddr, uint(-1));\n        }\n    }\n\n    /// @notice Returns the underlying address of the cToken asset\n    /// @param _cTokenAddress cToken address\n    /// @return Token address of the cToken specified\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(uint160(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Returns the maximum amount of collateral available to withdraw\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cCollAddress Collateral we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. collateral amount in that token\n    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n\n        if (liquidityInEth == 0) return usersBalance;\n\n        if (_cCollAddress == CETH_ADDRESS) {\n            if (liquidityInEth > usersBalance) return usersBalance;\n\n            return liquidityInEth;\n        }\n\n        uint ethPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cCollAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        if (liquidityInToken > usersBalance) return usersBalance;\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n\n    /// @notice Returns the maximum amount of borrow amount available\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. borrow amount in that token\n    function getMaxBorrow(address _cBorrowAddress, address _account) public view returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n\n        if (_cBorrowAddress == CETH_ADDRESS) return liquidityInEth;\n\n        uint ethPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cBorrowAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n}\n"},"localhost/compound/saver/CompoundFlashLoanTaker.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../flashloan/aave/ILendingPool.sol\";\nimport \"./CompoundSaverProxy.sol\";\nimport \"../../flashloan/FlashLoanLogger.sol\";\nimport \"../../auth/ProxyPermission.sol\";\n\n/// @title Entry point for the FL Repay Boosts, called by DSProxy\ncontract CompoundFlashLoanTaker is CompoundSaverProxy, ProxyPermission, GasBurner {\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address payable public constant COMPOUND_SAVER_FLASH_LOAN = 0x632cfd9245B7A4692F03b3D562Ed01E5cff94898;\n\n    // solhint-disable-next-line const-name-snakecase\n    FlashLoanLogger public constant logger = FlashLoanLogger(\n        0xb9303686B0EE92F92f63973EF85f3105329D345c\n    );\n\n    /// @notice Repays the position with it's own fund or with FL if needed\n    /// @param _data Amount and exchange data [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x callData\n    function repayWithLoan(\n        uint[5] calldata _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] calldata _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes calldata _callData\n    ) external payable burnGas(0) {\n        uint maxColl = getMaxCollateral(_addrData[0], address(this));\n\n        if (_data[0] <= maxColl) {\n            repay(_data, _addrData, _callData);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_data[0] - maxColl);\n            bytes memory paramsData = abi.encode(_data, _addrData, _callData, true, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_addrData[0]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.logFlashLoan(\"CompoundFlashRepay\", loanAmount, _data[0], _addrData[0]);\n        }\n    }\n\n    /// @notice Boosts the position with it's own fund or with FL if needed\n    /// @param _data Amount and exchange data [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x callData\n    function boostWithLoan(\n        uint[5] calldata _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] calldata _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes calldata _callData\n    ) external payable burnGas(0) {\n        uint maxBorrow = getMaxBorrow(_addrData[1], address(this));\n\n        if (_data[0] <= maxBorrow) {\n            boost(_data, _addrData, _callData);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_data[0] - maxBorrow);\n            bytes memory paramsData = abi.encode(_data, _addrData, _callData, false, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_addrData[1]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.logFlashLoan(\"CompoundFlashBoost\", loanAmount, _data[0], _addrData[1]);\n        }\n\n    }\n\n}\n"},"localhost/compound/saver/CompoundSaverProxy.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../../mcd/saver_proxy/ExchangeHelper.sol\";\nimport \"../../loggers/CompoundLogger.sol\";\nimport \"../helpers/CompoundSaverHelper.sol\";\n\n/// @title Contract that implements repay/boost functionality\ncontract CompoundSaverProxy is CompoundSaverHelper, ExchangeHelper {\n\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\n    /// @dev Called through the DSProxy\n    /// @param _data Amount and exchange data for the repay [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData Coll/Debt addresses [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x calldata info\n    function repay(\n        uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes memory _callData\n    ) public payable {\n        enterMarket(_addrData[0], _addrData[1]);\n\n        address payable user = address(uint160(getUserAddress()));\n\n        uint maxColl = getMaxCollateral(_addrData[0], address(this));\n\n        uint collAmount = (_data[0] > maxColl) ? maxColl : _data[0];\n\n        require(CTokenInterface(_addrData[0]).redeemUnderlying(collAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_addrData[0]);\n        address borrowToken = getUnderlyingAddr(_addrData[1]);\n\n        uint swapAmount = swap(\n            [collAmount, _data[1], _data[2], _data[4]], // collAmount, minPrice, exchangeType, 0xPrice\n            collToken,\n            borrowToken,\n            _addrData[2],\n            _callData\n        );\n\n        swapAmount -= getFee(swapAmount, user, _data[3], _addrData[1]);\n\n        paybackDebt(swapAmount, _addrData[1], borrowToken, user);\n\n        // handle 0x fee\n        user.transfer(address(this).balance);\n\n        CompoundLogger(COMPOUND_LOGGER).LogRepay(user, _data[0], swapAmount, collToken, borrowToken);\n    }\n\n    /// @notice Borrows token, converts to collateral, and adds to position\n    /// @dev Called through the DSProxy\n    /// @param _data Amount and exchange data for the boost [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData Coll/Debt addresses [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x calldata info\n    function boost(\n        uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes memory _callData\n    ) public payable {\n        enterMarket(_addrData[0], _addrData[1]);\n\n        address payable user = address(uint160(getUserAddress()));\n\n        uint maxBorrow = getMaxBorrow(_addrData[1], address(this));\n        uint borrowAmount = (_data[0] > maxBorrow) ? maxBorrow : _data[0];\n\n        require(CTokenInterface(_addrData[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_addrData[0]);\n        address borrowToken = getUnderlyingAddr(_addrData[1]);\n\n        borrowAmount -= getFee(borrowAmount, user, _data[3], _addrData[1]);\n\n        uint swapAmount = swap(\n            [borrowAmount, _data[1], _data[2], _data[4]], // collAmount, minPrice, exchangeType, 0xPrice\n            borrowToken,\n            collToken,\n            _addrData[2],\n            _callData\n        );\n\n        approveCToken(collToken, _addrData[0]);\n\n        if (collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_addrData[0]).mint(swapAmount) == 0);\n        } else {\n            CEtherInterface(_addrData[0]).mint{value: swapAmount}(); // reverts on fail\n        }\n\n        // handle 0x fee\n        user.transfer(address(this).balance);\n\n        CompoundLogger(COMPOUND_LOGGER).LogBoost(user, _data[0], swapAmount, collToken, borrowToken);\n    }\n\n}\n"},"localhost/constants/ConstantAddressesExchange.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./ConstantAddressesExchangeMainnet.sol\";\nimport \"./ConstantAddressesExchangeKovan.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ncontract ConstantAddressesExchange is ConstantAddressesExchangeMainnet {}\n"},"localhost/constants/ConstantAddressesExchangeKovan.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract ConstantAddressesExchangeKovan {\n    address public constant MAKER_DAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant MKR_ADDRESS = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;\n    address public constant WETH_ADDRESS = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;\n    address payable public constant WALLET_ID = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;\n    address public constant LOGGER_ADDRESS = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;\n    address public constant DISCOUNT_ADDRESS = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;\n\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000170CcC93903185bE5A2094C870Df62;\n    address public constant SAVER_EXCHANGE_ADDRESS = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;\n\n    // new MCD contracts\n    address public constant MANAGER_ADDRESS = 0x1476483dD8C35F25e568113C5f70249D3976ba21;\n    address public constant VAT_ADDRESS = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;\n    address public constant SPOTTER_ADDRESS = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;\n    address public constant PROXY_ACTIONS = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;\n\n    address public constant JUG_ADDRESS = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;\n    address public constant DAI_JOIN_ADDRESS = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;\n    address public constant ETH_JOIN_ADDRESS = 0x775787933e92b709f2a3C70aa87999696e74A9F8;\n    address public constant MIGRATION_ACTIONS_PROXY = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;\n\n    address public constant SAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\n    address public constant DAI_ADDRESS = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;\n\n    address payable public constant SCD_MCD_MIGRATION = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;\n\n    // Our contracts\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n    address public constant NEW_IDAI_ADDRESS = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;\n}\n"},"localhost/constants/ConstantAddressesExchangeMainnet.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract ConstantAddressesExchangeMainnet {\n    address public constant MAKER_DAI_ADDRESS = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant MKR_ADDRESS = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant LOGGER_ADDRESS = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n    address public constant SAVER_EXCHANGE_ADDRESS = 0x862F3dcF1104b8a9468fBb8B843C37C31B41eF09;\n\n    // new MCD contracts\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n    address public constant PROXY_ACTIONS = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;\n\n    address public constant JUG_ADDRESS = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public constant ETH_JOIN_ADDRESS = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;\n    address public constant MIGRATION_ACTIONS_PROXY = 0xe4B22D484958E582098A98229A24e8A43801b674;\n\n    address public constant SAI_ADDRESS = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address payable public constant SCD_MCD_MIGRATION = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;\n\n    // Our contracts\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n    address public constant NEW_IDAI_ADDRESS = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;\n}\n"},"localhost/flashloan/FlashLoanLogger.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract FlashLoanLogger {\n    event FlashLoan(string actionType, uint256 id, uint256 loanAmount, address sender);\n\n    function logFlashLoan(\n        string calldata _actionType,\n        uint256 _id,\n        uint256 _loanAmount,\n        address _sender\n    ) external {\n        emit FlashLoan(_actionType, _loanAmount, _id, _sender);\n    }\n}\n"},"localhost/flashloan/aave/ILendingPool.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract ILendingPool {\n    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\n\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\n\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\n\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual;\n\tfunction getReserveData(address _reserve)\n        external virtual\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            address aTokenAddress,\n            uint40 lastUpdateTimestamp\n        );\n}\n"},"localhost/interfaces/CEtherInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract CEtherInterface {\n    function mint() external virtual payable;\n    function repayBorrow() external virtual payable;\n}\n"},"localhost/interfaces/CTokenInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract CTokenInterface is ERC20 {\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    function mint() external virtual payable;\n\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrow() external virtual payable;\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrowBehalf(address borrower) external virtual payable;\n\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\n        external virtual\n        returns (uint256);\n\n    function liquidateBorrow(address borrower, address cTokenCollateral) external virtual payable;\n\n    function exchangeRateCurrent() external virtual returns (uint256);\n\n    function supplyRatePerBlock() external virtual returns (uint256);\n\n    function borrowRatePerBlock() external virtual returns (uint256);\n\n    function totalReserves() external virtual returns (uint256);\n\n    function reserveFactorMantissa() external virtual returns (uint256);\n\n    function borrowBalanceCurrent(address account) external virtual returns (uint256);\n\n    function totalBorrowsCurrent() external virtual returns (uint256);\n\n    function getCash() external virtual returns (uint256);\n\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\n\n    function underlying() external virtual returns (address);\n\n    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint, uint);\n}\n"},"localhost/interfaces/CompoundOracleInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract CompoundOracleInterface {\n    function getUnderlyingPrice(address cToken) external view virtual returns (uint);\n}\n"},"localhost/interfaces/ComptrollerInterface.sol":{"content":"pragma solidity ^0.6.0;\n\n\nabstract contract ComptrollerInterface {\n    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\n\n    function exitMarket(address cToken) external virtual returns (uint256);\n\n    function getAssetsIn(address account) external virtual view returns (address[] memory);\n\n    function markets(address account) public virtual view returns (bool, uint256);\n\n    function getAccountLiquidity(address account) external virtual view returns (uint256, uint256, uint256);\n}\n"},"localhost/interfaces/ERC20.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function decimals() external view returns (uint256 digits);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"},"localhost/interfaces/ExchangeInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\n//TODO: currenlty only adjusted to kyber, but should be genric interfaces for more dec. exchanges\ninterface ExchangeInterface {\n    function swapEtherToToken(uint256 _ethAmount, address _tokenAddress, uint256 _maxAmount)\n        external\n        payable\n        returns (uint256, uint256);\n\n    function swapTokenToEther(address _tokenAddress, uint256 _amount, uint256 _maxAmount)\n        external\n        returns (uint256);\n\n    function swapTokenToToken(address _src, address _dest, uint256 _amount)\n        external\n        payable\n        returns (uint256);\n\n    function getExpectedRate(address src, address dest, uint256 srcQty)\n        external\n        view\n        returns (uint256 expectedRate);\n}\n"},"localhost/interfaces/GasTokenInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract GasTokenInterface is ERC20 {\n    function free(uint256 value) public virtual returns (bool success);\n\n    function freeUpTo(uint256 value) public virtual returns (uint256 freed);\n\n    function freeFrom(address from, uint256 value) public virtual returns (bool success);\n\n    function freeFromUpTo(address from, uint256 value) public virtual returns (uint256 freed);\n}\n"},"localhost/interfaces/SaverExchangeInterface.sol":{"content":"pragma solidity ^0.6.0;\n\n\nabstract contract SaverExchangeInterface {\n    function getBestPrice(\n        uint256 _amount,\n        address _srcToken,\n        address _destToken,\n        uint256 _exchangeType\n    ) public view virtual returns (address, uint256);\n}\n"},"localhost/interfaces/TokenInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract TokenInterface {\n    function allowance(address, address) public virtual returns (uint256);\n\n    function balanceOf(address) public virtual returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(address, address, uint256) public virtual returns (bool);\n\n    function deposit() public virtual payable;\n\n    function withdraw(uint256) public virtual;\n}\n"},"localhost/loggers/CompoundLogger.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract CompoundLogger {\n    event Repay(\n        address indexed owner,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        address collAddr,\n        address borrowAddr\n    );\n\n    event Boost(\n        address indexed owner,\n        uint256 borrowAmount,\n        uint256 collateralAmount,\n        address collAddr,\n        address borrowAddr\n    );\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LogRepay(address _owner, uint256 _collateralAmount, uint256 _borrowAmount, address _collAddr, address _borrowAddr)\n        public\n    {\n        emit Repay(_owner, _collateralAmount, _borrowAmount, _collAddr, _borrowAddr);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LogBoost(address _owner, uint256 _borrowAmount, uint256 _collateralAmount, address _collAddr, address _borrowAddr)\n        public\n    {\n        emit Boost(_owner, _borrowAmount, _collateralAmount, _collAddr, _borrowAddr);\n    }\n}\n"},"localhost/mcd/Discount.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract Discount {\n    address public owner;\n    mapping(address => CustomServiceFee) public serviceFees;\n\n    uint256 constant MAX_SERVICE_FEE = 400;\n\n    struct CustomServiceFee {\n        bool active;\n        uint256 amount;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }\n\n    function getCustomServiceFee(address _user) public view returns (uint256) {\n        return serviceFees[_user].amount;\n    }\n\n    function setServiceFee(address _user, uint256 _fee) public {\n        require(msg.sender == owner, \"Only owner\");\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n    }\n\n    function disableServiceFee(address _user) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n    }\n}\n"},"localhost/mcd/saver_proxy/ExchangeHelper.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ExchangeInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../interfaces/SaverExchangeInterface.sol\";\n\nimport \"../../constants/ConstantAddressesExchange.sol\";\n\n\n/// @title Helper methods for integration with SaverExchange\ncontract ExchangeHelper is ConstantAddressesExchange {\n\n    /// @notice Swaps 2 tokens on the Saver Exchange\n    /// @dev ETH is sent with Weth address\n    /// @param _data [amount, minPrice, exchangeType, 0xPrice]\n    /// @param _src Token address of the source token\n    /// @param _dest Token address of the destination token\n    /// @param _exchangeAddress Address of 0x exchange that should be called\n    /// @param _callData data to call 0x exchange with\n    function swap(uint[4] memory _data, address _src, address _dest, address _exchangeAddress, bytes memory _callData) internal returns (uint) {\n        address wrapper;\n        uint price;\n        // [tokensReturned, tokensLeft]\n        uint[2] memory tokens;\n        bool success;\n\n        // tokensLeft is equal to amount at the beginning\n        tokens[1] = _data[0];\n\n        _src = wethToKyberEth(_src);\n        _dest = wethToKyberEth(_dest);\n\n        // use this to avoid stack too deep error\n        address[3] memory orderAddresses = [_exchangeAddress, _src, _dest];\n\n        // if _data[2] == 4 use 0x if possible\n        if (_data[2] == 4) {\n            if (orderAddresses[1] != KYBER_ETH_ADDRESS) {\n                ERC20(orderAddresses[1]).approve(address(ERC20_PROXY_0X), _data[0]);\n            }\n\n            (success, tokens[0], ) = takeOrder(orderAddresses, _callData, address(this).balance, _data[0]);\n\n            // if specifically 4, then require it to be successfull\n            require(success && tokens[0] > 0, \"0x transaction failed\");\n        }\n\n        // no 0x\n        // if (_data[2] == 5) {\n        //     (wrapper, price) = SaverExchangeInterface(SAVER_EXCHANGE_ADDRESS).getBestPrice(tokens[1], orderAddresses[1], orderAddresses[2], _data[2]);\n\n        //     require(price > _data[1], \"Slippage hit onchain price\");\n\n        //     if (orderAddresses[1] == KYBER_ETH_ADDRESS) {\n        //         uint tRet;\n        //         (tRet,) = ExchangeInterface(wrapper).swapEtherToToken.value(tokens[1])(tokens[1], orderAddresses[2], uint(-1));\n        //         tokens[0] += tRet;\n        //     } else {\n        //         ERC20(orderAddresses[1]).transfer(wrapper, tokens[1]);\n\n        //         if (orderAddresses[2] == KYBER_ETH_ADDRESS) {\n        //             tokens[0] += ExchangeInterface(wrapper).swapTokenToEther(orderAddresses[1], tokens[1], uint(-1));\n        //         } else {\n        //             tokens[0] += ExchangeInterface(wrapper).swapTokenToToken(orderAddresses[1], orderAddresses[2], tokens[1]);\n        //         }\n        //     }\n\n        //     return tokens[0];\n        // }\n\n        if (tokens[0] == 0) {\n            (wrapper, price) = SaverExchangeInterface(SAVER_EXCHANGE_ADDRESS).getBestPrice(_data[0], orderAddresses[1], orderAddresses[2], _data[2]);\n\n            require(price > _data[1] || _data[3] > _data[1], \"Slippage hit\");\n\n            // handle 0x exchange, if equal price, try 0x to use less gas\n            if (_data[3] >= price) {\n                if (orderAddresses[1] != KYBER_ETH_ADDRESS) {\n                    ERC20(orderAddresses[1]).approve(address(ERC20_PROXY_0X), _data[0]);\n                }\n\n                // when selling eth its possible that some eth isn't sold and it is returned back\n                (success, tokens[0], tokens[1]) = takeOrder(orderAddresses, _callData, address(this).balance, _data[0]);\n            }\n\n            // if there are more tokens left, try to sell them on other exchanges\n            if (tokens[1] > 0) {\n                // as it stands today, this can happend only when selling ETH\n                if (tokens[1] != _data[0]) {\n                    (wrapper, price) = SaverExchangeInterface(SAVER_EXCHANGE_ADDRESS).getBestPrice(tokens[1], orderAddresses[1], orderAddresses[2], _data[2]);\n                }\n\n                require(price > _data[1], \"Slippage hit onchain price\");\n\n                if (orderAddresses[1] == KYBER_ETH_ADDRESS) {\n                    uint tRet;\n                    (tRet,) = ExchangeInterface(wrapper).swapEtherToToken{value: tokens[1]}(tokens[1], orderAddresses[2], uint(-1));\n                    tokens[0] += tRet;\n                } else {\n                    ERC20(orderAddresses[1]).transfer(wrapper, tokens[1]);\n\n                    if (orderAddresses[2] == KYBER_ETH_ADDRESS) {\n                        tokens[0] += ExchangeInterface(wrapper).swapTokenToEther(orderAddresses[1], tokens[1], uint(-1));\n                    } else {\n                        tokens[0] += ExchangeInterface(wrapper).swapTokenToToken(orderAddresses[1], orderAddresses[2], tokens[1]);\n                    }\n                }\n            }\n        }\n\n        return tokens[0];\n    }\n\n    // @notice Takes order from 0x and returns bool indicating if it is successful\n    // @param _addresses [exchange, src, dst]\n    // @param _data Data to send with call\n    // @param _value Value to send with call\n    // @param _amount Amount to sell\n    function takeOrder(address[3] memory _addresses, bytes memory _data, uint _value, uint _amount) private returns(bool, uint, uint) {\n        bool success;\n\n        (success, ) = _addresses[0].call{value: _value}(_data);\n\n        uint tokensLeft = _amount;\n        uint tokensReturned = 0;\n        if (success){\n            // check how many tokens left from _src\n            if (_addresses[1] == KYBER_ETH_ADDRESS) {\n                tokensLeft = address(this).balance;\n            } else {\n                tokensLeft = ERC20(_addresses[1]).balanceOf(address(this));\n            }\n\n            // check how many tokens are returned\n            if (_addresses[2] == KYBER_ETH_ADDRESS) {\n                TokenInterface(WETH_ADDRESS).withdraw(TokenInterface(WETH_ADDRESS).balanceOf(address(this)));\n                tokensReturned = address(this).balance;\n            } else {\n                tokensReturned = ERC20(_addresses[2]).balanceOf(address(this));\n            }\n        }\n\n        return (success, tokensReturned, tokensLeft);\n    }\n\n    /// @notice Converts WETH -> Kybers Eth address\n    /// @param _src Input address\n    function wethToKyberEth(address _src) internal pure returns (address) {\n        return _src == WETH_ADDRESS ? KYBER_ETH_ADDRESS : _src;\n    }\n}\n"},"localhost/utils/GasBurner.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../interfaces/GasTokenInterface.sol\";\n\ncontract GasBurner {\n    // solhint-disable-next-line const-name-snakecase\n    GasTokenInterface public constant gasToken = GasTokenInterface(0x0000000000b3F879cb30FE243b4Dfee438691c04);\n\n    modifier burnGas(uint _amount) {\n        uint gst2Amount = _amount;\n\n        if (_amount == 0) {\n            gst2Amount = (gasleft() + 14154) / (2 * 24000 - 6870);\n            gst2Amount = gst2Amount - (gst2Amount / 8); // 12.5% less because of gaslimit != gas_used\n        }\n\n        if (gasToken.balanceOf(address(this)) >= gst2Amount) {\n            gasToken.free(gst2Amount);\n        }\n\n        _;\n    }\n}\n"}}}