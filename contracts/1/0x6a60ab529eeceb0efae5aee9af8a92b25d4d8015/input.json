{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/router.sol":{"content":"/*\nPlease note, there are 3 native components to this token design. Token, Router, and Core. \nEach component is deployed separately as an external contract.\n\nThis is the main code of a mutable token contract.\nThe Router component is the mutable part and it can be re-routed should there be any code updates.\nAny other contract is also external and it must be additionally registered and routed within the native components.\nThe main idea of this design was to follow the adjusted Proxy and the MVC design patterns.\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity = 0.7 .4;\n\nabstract contract Context\n{\n\tfunction _msgSender() internal view virtual returns(address payable)\n\t{\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view virtual returns(bytes memory)\n\t{\n\t\tthis;\n\t\treturn msg.data;\n\t}\n}\n\ncontract Ownable is Context\n{\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\tconstructor()\n\t{\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\tfunction owner() public view returns(address)\n\t{\n\t\treturn _owner;\n\t}\n\n\tmodifier onlyOwner()\n\t{\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\tfunction renounceOwnership() public virtual onlyOwner\n\t{\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner\n\t{\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\ninterface IERC20\n{\n\tfunction currentCoreContract() external view returns(address routerAddress);\n\n\tfunction currentTokenContract() external view returns(address routerAddress);\n\n\tfunction getExternalContractAddress(string memory contractName) external view returns(address routerAddress);\n\n\tfunction callRouter(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\n\n\tfunction _callRouter(string memory route, address[3] memory addressArr, uint[3] memory uintArr) external returns(bool success);\n\n\tfunction extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external returns(bool success);\n\n}\n\nabstract contract Core\n{\n\n\t// native core functions\n\n\tfunction transfer(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n\tfunction approve(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n\tfunction increaseAllowance(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n\tfunction decreaseAllowance(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n\tfunction transferFrom(address[3] memory addressArr, uint[3] memory uintArr) external virtual returns(bool success);\n\n\t//non-native core functions\n\n\tfunction mint(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n\tfunction burn(address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n\n\tfunction updateTotalSupply(uint[2] memory uintArr) external virtual returns(bool success);\n\n\tfunction updateCurrentSupply(uint[2] memory uintArr) external virtual returns(bool success);\n\n\tfunction updateJointSupply(uint[2] memory uintArr) external virtual returns(bool success);\n\n}\n\nabstract contract Token\n{\n\tfunction allowance(address owner, address spender) external view virtual returns(uint256 data);\n}\n\n//============================================================================================\n// MAIN CONTRACT \n//============================================================================================\n\ncontract Router is Ownable, IERC20\n{\n\n\taddress public tokenContract;\n\taddress public coreContract;\n\tCore private core;\n\tToken private token;\n\n\tmapping(string => address) public externalContracts;\t//for non-native functions\n\tmapping(address => bool) mutex;\t//against reentrancy attacks\n \n\n\t//============== NATIVE FUNCTIONS START HERE ==================================================\n\t//These functions should never change when introducing a new version of a router.\n\t//Router is expected to constantly change, and the code should be written under \n\t//the \"NON-CORE FUNCTIONS TO BE CODED BELOW\".\n\n\tfunction equals(string memory a, string memory b) internal view virtual returns(bool isEqual)\n\t{\n\t\treturn (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n\t}\n\n\tfunction currentTokenContract() override external view virtual returns(address routerAddress)\n\t{\n\t\treturn tokenContract;\n\t}\n\n\tfunction currentCoreContract() override external view virtual returns(address routerAddress)\n\t{\n\t\treturn coreContract;\n\t}\n\n\tfunction getExternalContractAddress(string memory contractName) override external view virtual returns(address routerAddress)\n\t{\n\t\treturn externalContracts[contractName];\n\t}\n\n\t//function is not needed if token address is hard-coded in a constructor\n\tfunction setNewTokenContract(address newTokenAddress) onlyOwner public virtual returns(bool success)\n\t{\n\t\ttokenContract = newTokenAddress;\n\t\ttoken = Token(tokenContract);\n\t\treturn true;\n\t}\n\n\tfunction setNewCoreContract(address newCoreAddress) onlyOwner public virtual returns(bool success)\n\t{\n\t\tcoreContract = newCoreAddress;\n\t\tcore = Core(coreContract);\n\t\treturn true;\n\t}\n\n\tfunction setNewExternalContract(string memory contractName, address newContractAddress) onlyOwner public virtual returns(bool success)\n\t{\n\t\texternalContracts[contractName] = newContractAddress;\n\t\treturn true;\n\t}\n\n\tfunction callRouter(string memory route, address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success)\n\t{\n\t\trequire(msg.sender == tokenContract, \"at: router.sol | contract: Router | function: callRouter | message: Must be called by the registered Token contract\");\n\n\t\trequire(!mutex[addressArr[0]]);\n\t\tmutex[addressArr[0]] = true;\n\n\t\tif (equals(route, \"transfer\"))\n\t\t{\n\t\t\tif(!core.transfer(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (equals(route, \"approve\"))\n\t\t{\n\t\t\tif (!core.approve(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (equals(route, \"increaseAllowance\"))\n\t\t{\n\t\t\tif (!core.increaseAllowance(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (equals(route, \"decreaseAllowance\"))\n\t\t{\n\t\t\tif (!core.decreaseAllowance(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\n\t\tmutex[addressArr[0]] = false;\n\n\t\treturn true;\n\t}\n\n\tfunction _callRouter(string memory route, address[3] memory addressArr, uint[3] memory uintArr) override external virtual  returns(bool success)\n\t{\n\n\t\trequire(msg.sender == tokenContract, \"at: router.sol | contract: Router | function: _callRouter | message: Must be called by the registered Token contract\");\n\n\t\trequire(!mutex[addressArr[0]]);\n\t\tmutex[addressArr[0]] = true;\n\n\t\tif (equals(route, \"transferFrom\"))\n\t\t{\n\t\t\tif (!core.transferFrom(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\n\t\tmutex[addressArr[0]] = false;\n\n\t\treturn true;\n\t}\n\n\tfunction revertWithMutex(address userAddress) private\n\t{\n\t\tmutex[userAddress] = false;\n\t\trequire(mutex[userAddress], \"at: router.sol | contract: Router | function: revertWithMutex | message: Prevented multiple calls with the mutex, your previous call must end or cancel\");\n\t}\n\n\t//============== NATIVE FUNCTIONS END HERE ==================================================\n\n\t//=============== NON-NATIVE ROUTES TO BE CODED BELOW =======================================\n\t// This code is a subject to a change, should we decide to alter anything.\n\t// We can also design another external router, possibilities are infinite.\n\n\tfunction extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) override external virtual returns(bool success)\n\t{\n\n\t\trequire(!mutex[addressArr[0]]);\n\t\tmutex[addressArr[0]] = true;\n\n\t\trequire(externalContracts[route] == msg.sender, \"at: router.sol | contract: Router | function: extrenalRouterCall | message: Must be called by the registered external contract\");\n\n\t\t//WARNING! This kind of a design exposes a danger with old contracts, if linked, to execute the functions. Must be properly maintained.\n\t\t//also, we must be careful about the substrings  not to mess up the function calls\n\t\tif (substringOf(route, \"mint\"))\n\t\t{\n\t\t\tif (!core.mint(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (substringOf(route, \"burn\"))\n\t\t{\n\t\t\tif (!core.burn(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (substringOf(route, \"updateTotalSupply\"))\n\t\t{\n\t\t\tif (!core.updateTotalSupply(uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (substringOf(route, \"updateCurrentSupply\"))\n\t\t{\n\t\t\tif (!core.updateCurrentSupply(uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (substringOf(route, \"updateJointSupply\"))\n\t\t{\n\t\t\tif (!core.updateJointSupply(uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (substringOf(route, \"transfer\"))\n\t\t{\n\t\t\tif(!core.transfer(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (substringOf(route, \"approve\"))\n\t\t{\n\t\t\tif (!core.approve(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (substringOf(route, \"increaseAllowance\"))\n\t\t{\n\t\t\tif (!core.increaseAllowance(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\t\telse if (substringOf(route, \"decreaseAllowance\"))\n\t\t{\n\t\t\tif (!core.decreaseAllowance(addressArr, uintArr)) revertWithMutex(addressArr[0]);\n\t\t}\n\n\t\tmutex[addressArr[0]] = false;\n\n\t\treturn true;\n\t}\n\n\t//string comparison used to generalize the functions called by multiple contracts\n\tfunction substringOf(string memory _haystack, string memory _needle) public pure returns(bool t)\n\t{\n\t\tbytes memory h = bytes(_haystack);\n\t\tbytes memory n = bytes(_needle);\n\t\tif (h.length < 1 || n.length < 1 || (n.length > h.length))\n\t\t\treturn false;\n\t\telse if (h.length > (2 **128 - 1))\n\t\t\treturn false;\n\t\telse\n\t\t{\n\t\t\tuint subindex = 0;\n\t\t\tfor (uint i = 0; i < h.length; i++)\n\t\t\t{\n\t\t\t\tif (h[i] == n[0])\n\t\t\t\t{\n\t\t\t\t\tsubindex = 1;\n\t\t\t\t\twhile (subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n\t\t\t\t\t{\n\t\t\t\t\t\tsubindex++;\n\t\t\t\t\t}\n\t\t\t\t\tif (subindex == n.length)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"}}}