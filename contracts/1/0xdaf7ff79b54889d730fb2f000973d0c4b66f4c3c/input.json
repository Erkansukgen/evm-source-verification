{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"},"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"},"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"QuickBuy.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport './Token.sol';\n\ninterface CallQuickBuy {\n  function executeWithoutFees(uint256 testEthAmount, uint256 minTokenAmount, address destination, uint256 deadline) external;\n  function executeWithFees(uint256 testEthAmount, uint256 minTokenAmount, address destination, uint256 deadline) external;\n}\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, 'dsm-ao');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, 'dsm-su');\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'dsm-mo');\n    }\n}\n\ncontract QuickBuy {\n    using SafeMath for uint256;\n\n    address public owner;\n    address public immutable routerAddress;\n    address public tokenAddress;\n\n    constructor(address router, address token) payable {\n        owner = msg.sender;\n        routerAddress = router;\n        tokenAddress = token;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"UM-NO\");\n        _;\n    }\n\n    modifier onlySelf() {\n        require(address(this) == msg.sender, \"UM-NO\");\n        _;\n    }\n\n    function changeOwner(address newOwner) public onlyOwner {\n      owner = newOwner;\n    }\n\n    function changeToken(address newToken) public onlyOwner {\n      tokenAddress = newToken;\n    }\n\n    function executeWithoutFees(uint256 testEthAmount, uint256 minTokenAmount, address destination, uint256 deadline) external onlySelf {\n      IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);\n\n      address[] memory buyPath = new address[](2);\n      buyPath[0] = router.WETH();\n      buyPath[1] = tokenAddress;\n\n      address[] memory sellPath = new address[](2);\n      sellPath[0] = buyPath[1];\n      sellPath[1] = buyPath[0];\n\n      router.swapExactETHForTokens{value: testEthAmount}(0, buyPath, address(this), deadline);\n      router.swapExactTokensForETH(Token(tokenAddress).balanceOf(address(this)), 0, sellPath, address(this), deadline);\n      router.swapExactETHForTokens{value: address(this).balance}(minTokenAmount, buyPath, destination, deadline);\n    }\n\n    function executeWithFees(uint256 testEthAmount, uint256 minTokenAmount, address destination, uint256 deadline) external onlySelf {\n      IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);\n\n      address[] memory buyPath = new address[](2);\n      buyPath[0] = router.WETH();\n      buyPath[1] = tokenAddress;\n\n      address[] memory sellPath = new address[](2);\n      sellPath[0] = buyPath[1];\n      sellPath[1] = buyPath[0];\n\n      router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: testEthAmount}(0, buyPath, address(this), deadline);\n      router.swapExactTokensForETHSupportingFeeOnTransferTokens(Token(tokenAddress).balanceOf(address(this)), 0, sellPath, address(this), deadline);\n      router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: address(this).balance}(minTokenAmount, buyPath, destination, deadline);\n    }\n\n    function execute(uint256 testEthAmount, uint256 minTokenAmount, address destination, uint256 deadline) internal {\n      Token token = Token(tokenAddress);\n\n      // Check that transfers are enabled (not needed since the rest will will)\n      // require(!token.transferLocked(), \"QB-TL\");\n\n      // Approve router for max\n      token.approve(routerAddress, type(uint256).max);\n\n      // Try to buy a test amount and then sell it immediately, and then buy with all this contract's ETH\n      try CallQuickBuy(address(this)).executeWithoutFees(testEthAmount, minTokenAmount, destination, deadline) {\n        return;\n      } catch (bytes memory) {\n        CallQuickBuy(address(this)).executeWithFees(testEthAmount, minTokenAmount, destination, deadline);\n        return;\n      }\n    }\n\n    function quickBuy(uint256 testEthAmount, uint256 minTokenAmount, address destination, uint256 deadline) public payable {\n      execute(testEthAmount, minTokenAmount, destination, deadline);\n    }\n\n    function quickBuyAndKill(uint256 testEthAmount, uint256 minTokenAmount, address destination, uint256 deadline) public payable {\n      execute(testEthAmount, minTokenAmount, destination, deadline);\n      selfdestruct(payable(msg.sender));\n    }\n\n    function retrieveEth(address payable destination) external onlyOwner {\n        destination.transfer(address(this).balance);\n    }\n\n    function retrieveToken(address tokenAddress, address destination) external onlyOwner {\n        Token token = Token(tokenAddress);\n        uint256 tokenAmount = token.balanceOf(address(this));\n        require(token.transfer(destination, tokenAmount), 'QB-TF');\n    }\n\n    fallback() external payable {\n      (uint256 testEthAmount, uint256 minTokenAmount, uint256 deadline, address destination, bool kill) = abi.decode(msg.data, (uint256, uint256, uint256, address, bool));\n      execute(testEthAmount, minTokenAmount, destination, deadline);\n\n      if (kill) {\n        selfdestruct(payable(msg.sender));\n      }\n    }\n\n    receive() external payable {\n    }\n}\n"},"Token.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary SafeMath2 {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\ncontract Token {\n    using SafeMath2 for uint256;\n\n    address private owner;\n\n    string public constant name = 'Token';\n    string public constant symbol = 'TOK';\n    uint8 public constant decimals = 9;\n    uint256 public totalSupply;\n    bool public transferLocked = false;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Approval(address indexed user, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 _totalSupply) payable {\n        owner = msg.sender;\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address msgSender, address spender, uint256 value) internal {\n        allowance[msgSender][spender] = value;\n\n        emit Approval(msgSender, spender, value);\n    }\n\n    function _transfer(address from, address to, uint256 value) internal {\n        require(!transferLocked, \"No transfer\");\n\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n\n        _transfer(from, to, value);\n\n        return true;\n    }\n\n    function lockTransfer(bool _status) external returns (bool) {\n    transferLocked = _status;\n  }\n}\n"}}}