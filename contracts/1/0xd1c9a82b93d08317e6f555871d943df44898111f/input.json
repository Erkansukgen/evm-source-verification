{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "uni_test2.sol": {
      "content": "pragma solidity >=0.6.2 <=0.9.0;\n\nimport \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\";\n//import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\n\n\n\ninterface IERC20 {\n  function transferFrom(\n    address sender, \n    address recipient, \n    uint256 amount) \n    external \n    returns (bool); \n\n  function approve(address spender, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n\ncontract UniswapObfuscated is Ownable {\n    \n  // test DAI: 0xaD6D458402F60fD3Bd25163575031ACDce07538D\n  // test UNI: 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\n  address internal constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n  //address internal constant OVR_ADDRESS = 0x21BfBDa47A0B4B5b1248c767Ee49F7caA9B23697;\n  //address internal constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n  \n  address internal _dai_token;\n  address internal _trade_token;\n\n  IUniswapV2Router02 internal uniswapRouter;\n  \n\n  constructor(address dai_token, address trade_token) {\n    uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n    _dai_token = dai_token;\n    _trade_token = trade_token;\n    \n    require(IERC20(_dai_token).approve(address(uniswapRouter), 999999999999999999999999999), 'approve failed.');\n    require(IERC20(_trade_token).approve(address(uniswapRouter), 999999999999999999999999999), 'approve failed.');\n  }\n  \n  function changeTokens(address dai_token, address trade_token) external onlyOwner {\n    _dai_token = dai_token;\n    _trade_token = trade_token;\n    \n    require(IERC20(_dai_token).approve(address(uniswapRouter), 999999999999999999999999999), 'approve failed.');\n    require(IERC20(_trade_token).approve(address(uniswapRouter), 999999999999999999999999999), 'approve failed.');\n  }\n\n  function getPath(uint direction) internal view returns (address[] memory) {\n    address[] memory path = new address[](3);\n    if (direction == 1) {   // buy\n        path[0] = _dai_token;\n        path[1] = uniswapRouter.WETH();\n        path[2] = _trade_token;\n    } else if (direction == 2) {                // sell\n        path[0] = _trade_token;\n        path[1] = uniswapRouter.WETH();\n        path[2] = _dai_token;\n    }\n    return path;\n  }\n  \n  function swap(uint direction, uint amountIn, uint amountOutMin, uint deadline) external onlyOwner {\n      address[] memory path = getPath(direction);\n      \n      IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n      \n      //require(IERC20(path[0]).approve(address(uniswapRouter), amountIn), 'approve failed.');\n      \n      uniswapRouter.swapExactTokensForTokens(\n        amountIn,\n        amountOutMin,\n        path,\n        msg.sender,\n        deadline\n      );\n  }\n  \n  function obfSwap(uint pwd, uint directionObf, uint amountInObf, uint amountOutMinObf, uint deadlineObf) external onlyOwner {\n      address[] memory path = getPath(deobfuscate(pwd, directionObf));\n      \n      uint amountIn = deobfuscate(pwd, amountInObf);\n      \n      IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n      \n      //require(IERC20(path[0]).approve(address(uniswapRouter), amountIn), 'approve failed.');\n      \n      uniswapRouter.swapExactTokensForTokens(\n        amountIn,\n        deobfuscate(pwd, amountOutMinObf),\n        path,\n        msg.sender,\n        deobfuscate(pwd, deadlineObf)\n      );\n  }\n  \n  function withdrawErc20(IERC20 token) external onlyOwner {\n    token.transfer(msg.sender, token.balanceOf(address(this)));\n  }\n  \n  /*\n  function letsxor(uint qty, uint pwd) public view returns (uint) {\n      return qty ^ pwd;\n      // uint256(uint160(a))\n  }\n  */\n  \n  function deobfuscate(uint pwd, uint param) internal view returns (uint) {\n      return uint256(uint160(msg.sender)) ^ pwd ^ param;\n  }\n  \n  // important to receive ETH\n  //receive() payable external onlyOwner {}\n}"
    }
  }
}