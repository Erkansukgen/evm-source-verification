{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "kbtoken.sol": {
      "content": "pragma solidity >=0.8.0 <0.9.0;\n\n\ncontract KB24 {\n     string  _name;\n    string  _symbol;\n    uint8  _decimals = 0;\n    uint256  _totalSupply = 24000000;\n    uint256 exchange_rate = 100000000000000;\n    address exchange_address;\n    address launch_address;\n    address reserved_address;\n    address owner_address;\n    address manager_address;\n    address contract_publisher;\n    mapping (address => uint256) airdropcounts;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    event Transfer(address owner,address spender,uint256 value);\n    event Approval(address owner,address spender,uint256 value);\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    event Received(address, uint);\n \n    function initCoin(\n        address holder,address exchange,address launch,address reserved)  public{\n        uint256 totalSupply = _totalSupply * 10 ** uint256(_decimals); // Update total supply\n        balances[holder] += totalSupply;                       // Give the creator all initial tokens\n        _name = \"KB24\";                                      // Set the name for display purposes\n        _symbol = \"KB24\";                                   // Set the symbol for display purposes\n        contract_publisher = msg.sender;\n        owner_address = holder;\n        manager_address = exchange;\n        exchange_address = exchange;\n        launch_address = launch;\n        reserved_address = reserved;\n        allowed[owner_address][exchange_address] = 20000000;\n        allowed[owner_address][launch_address] = 1000000;\n        allowed[owner_address][reserved_address] = 3000000;\n    }\n \n    function transfer(address _to, uint256 _value) public payable  returns (bool success){\n        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to],\"Insufficient funds\");\n        balances[msg.sender] -= _value;//从消息发送者账户中减去token数量_value\n        balances[_to] += _value;//往接收账户增加token数量_value\n        emit Transfer(msg.sender, _to, _value);//触发转币交易事件\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) payable public returns \n    (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value,\"Insufficient funds\");\n        balances[_to] += _value;//接收账户增加token数量_value\n        balances[_from] -= _value; //支出账户_from减去token数量_value\n        allowed[_from][msg.sender] -= _value;//消息发送者可以从账户_from中转出的数量减少_value\n        emit Transfer(_from, _to, _value);//触发转币交易事件\n        return true;\n    }\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    function approve(address _spender, uint256 _value) public returns (bool success)   \n    { \n         require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n        allowed[msg.sender][_spender] = _value;\n       emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];//允许_spender从_owner中转出的token数\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory){\n        return _symbol;\n    }\n    function decimals() public view returns (uint8){\n        return _decimals;\n    }\n    function totalSupply() public view returns (uint256){\n        return _totalSupply;\n    }\n   //@notice 向符合条件投资人增发\n    function seo(address _to, uint256 _value) public {\n        require(msg.sender == manager_address,\"Unqualified\");\n        _totalSupply += _value;\n        balances[msg.sender] += _value;\n        allowed[msg.sender][_to] = _value;\n        emit Approval(msg.sender, _to, _value);\n    }\n    //@notice 销毁\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n  \n    function burnAll() external {\n        uint256 amount = balances[msg.sender];\n        _burn(msg.sender, amount);\n    }\n    function sendToManager(uint amount) public {\n        require(msg.sender == manager_address,\"Unqualified\");\n        address payable manager = payable(msg.sender);\n        require(owner_address.balance>=amount,\"not enough\");\n        manager.transfer(amount);\n    }\n   function _burn(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= balances[account]);\n        require(msg.sender == manager_address,\"Unqualified\");\n        _totalSupply -= amount;\n        balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n   }\n   \n   function burnFrom(address account, uint256 amount) external {\n        require(amount <= allowed[account][msg.sender]);\n        allowed[account][msg.sender] -= amount;\n        _burn(account, amount);\n   }\n   function getExchangeAddress() public view returns (address) {\n       require(msg.sender == manager_address,\"Unqualified\");\n        return exchange_address;\n    }\n    function getLaunchAddress() public view returns (address) {\n       require(msg.sender == manager_address,\"Unqualified\");\n        return launch_address;\n    }\n    function getReservedAddress() public view returns (address) {\n       require(msg.sender == manager_address,\"Unqualified\");\n        return reserved_address;\n    }\n   function getOwnerAddress() public view returns (address) {\n       require(msg.sender == manager_address,\"Unqualified\");\n        return owner_address;\n    }\n   function getOwnerBalance() public view returns (uint) {\n       require(msg.sender == manager_address,\"Unqualified\");\n        return owner_address.balance;\n    }\n   receive() external payable {\n         if(msg.sender != contract_publisher){\n           address account = msg.sender;\n           address use_address = exchange_address;\n           uint256 kb_amount = msg.value / exchange_rate;\n           if (msg.value == 0 ether ){\n               require(1 > airdropcounts[msg.sender],\"the address has received airdrop\");\n               use_address = launch_address;\n               kb_amount = 24;\n               airdropcounts[msg.sender] += 1;\n           }\n           allowed[owner_address][use_address] -= kb_amount;\n           balances[owner_address] -= kb_amount;//从持有者账户中减去token数量_value\n           balances[msg.sender] += kb_amount;//往接收账户增加token数量_value\n           emit Received(msg.sender, msg.value);\n         }\n        \n   }\n}\n"
    }
  }
}