{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "marketplace.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: BSD-3-Clause\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n}\n\n// Modern ERC20 Token interface\ninterface IERC20 {\n    function transfer(address to, uint amount) external returns (bool);\n    function transferFrom(address from, address to, uint amount) external returns (bool);\n}\n\n// Modern ERC721 Token interface\ninterface IERC721 {\n    function transferFrom(address from, address to, uint tokenId) external;\n    function mint(address to) external;\n}\n\ncontract NFT_Market is Ownable {\n    using SafeMath for uint;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    // =========== Start Smart Contract Setup ==============\n    \n    // MUST BE CONSTANT - THE FEE TOKEN ADDRESS AND NFT ADDRESS\n    // the below addresses are trusted and constant so no issue of re-entrancy happens\n    address public constant trustedFeeTokenAddress = 0x961C8c0B1aaD0c0b10a51FeF6a867E3091BCef17;\n    address public constant trustedNftAddress = 0x582c905df6caD7a1c490eDc215F0Baa0Dc0960Dd;\n    \n    // minting fee in token, 10 tokens (10e18 because token has 18 decimals)\n    uint public mintFee = 10e18;\n    \n    // selling fee rate\n    uint public sellingFeeRateX100 = 30;\n    \n    // ============ End Smart Contract Setup ================\n    \n    // ---------------- owner modifier functions ------------------------\n    function setMintFee(uint _mintFee) public onlyOwner {\n        mintFee = _mintFee;\n    }\n    function setSellingFeeRateX100(uint _sellingFeeRateX100) public onlyOwner {\n        sellingFeeRateX100 = _sellingFeeRateX100;\n    }\n    \n    // --------------- end owner modifier functions ---------------------\n    \n    enum PriceType {\n        ETHER,\n        TOKEN\n    }\n    \n    event List(uint tokenId, uint price, PriceType priceType);\n    event Unlist(uint tokenId);\n    event Buy(uint tokenId);\n    \n     \n    EnumerableSet.UintSet private nftsForSaleIds;\n    \n    // nft id => nft price\n    mapping (uint => uint) private nftsForSalePrices;\n    // nft id => nft owner\n    mapping (uint => address) private nftOwners;\n    // nft id => ETHER | TOKEN\n    mapping (uint => PriceType) private priceTypes;\n    \n    // nft owner => nft id set\n    mapping (address => EnumerableSet.UintSet) private nftsForSaleByAddress;\n    \n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return nftsForSaleByAddress[owner].length();\n    }\n    function totalListed() public view returns (uint256) {\n        return nftsForSaleIds.length();\n    }\n\n    function getToken(uint tokenId) public view returns (uint _tokenId, uint _price, address _owner, PriceType _priceType) {\n        _tokenId = tokenId;\n        _price = nftsForSalePrices[tokenId];\n        _owner = nftOwners[tokenId];\n        _priceType = priceTypes[tokenId];\n    }\n    \n    function getTokens(uint startIndex, uint endIndex) public view returns \n        (uint[] memory _tokens, uint[] memory _prices, address[] memory _owners, PriceType[] memory _priceTypes) {\n        require(startIndex < endIndex, \"Invalid indexes supplied!\");\n        uint len = endIndex.sub(startIndex);\n        require(len <= totalListed(), \"Invalid length!\");\n        \n        _tokens = new uint[](len);\n        _prices = new uint[](len);\n        _owners = new address[](len);\n        _priceTypes = new PriceType[](len);\n        \n        for (uint i = startIndex; i < endIndex; i = i.add(1)) {\n            uint listIndex = i.sub(startIndex);\n            \n            uint tokenId = nftsForSaleIds.at(i);\n            uint price = nftsForSalePrices[tokenId];\n            address nftOwner = nftOwners[tokenId];\n            PriceType priceType = priceTypes[tokenId];\n            \n            _tokens[listIndex] = tokenId;\n            _prices[listIndex] = price;\n            _owners[listIndex] = nftOwner;\n            _priceTypes[listIndex] = priceType;\n        }\n    }\n    \n    // overloaded getTokens to allow for getting seller tokens\n    // _owners array not needed but returned for interface consistency\n    // view function so no gas is used\n    function getTokens(address seller, uint startIndex, uint endIndex) public view returns\n        (uint[] memory _tokens, uint[] memory _prices, address[] memory _owners, PriceType[] memory _priceTypes) {\n        require(startIndex < endIndex, \"Invalid indexes supplied!\");\n        uint len = endIndex.sub(startIndex);\n        require(len <= balanceOf(seller), \"Invalid length!\");\n        \n        _tokens = new uint[](len);\n        _prices = new uint[](len);\n        _owners = new address[](len);\n        _priceTypes = new PriceType[](len);\n        \n        for (uint i = startIndex; i < endIndex; i = i.add(1)) {\n            uint listIndex = i.sub(startIndex);\n            \n            uint tokenId = nftsForSaleByAddress[seller].at(i);\n            uint price = nftsForSalePrices[tokenId];\n            address nftOwner = nftOwners[tokenId];\n            PriceType priceType = priceTypes[tokenId];\n            \n            _tokens[listIndex] = tokenId;\n            _prices[listIndex] = price;\n            _owners[listIndex] = nftOwner;\n            _priceTypes[listIndex] = priceType;\n        }\n    }\n    \n    function mint() public {\n        // owner can mint without fee\n        // other users need to pay a fixed fee in token\n        if (msg.sender != owner) {\n            require(IERC20(trustedFeeTokenAddress).transferFrom(msg.sender, owner, mintFee), \"Could not transfer mint fee!\");\n        }\n        \n        IERC721(trustedNftAddress).mint(msg.sender);\n    }\n    \n    function list(uint tokenId, uint price, PriceType priceType) public {\n        IERC721(trustedNftAddress).transferFrom(msg.sender, address(this), tokenId);\n        \n        nftsForSaleIds.add(tokenId);\n        nftsForSaleByAddress[msg.sender].add(tokenId);\n        nftOwners[tokenId] = msg.sender;\n        nftsForSalePrices[tokenId] = price;\n        priceTypes[tokenId] = priceType;\n        \n        emit List(tokenId, price, priceType);\n    }\n    \n    function unlist(uint tokenId) public {\n        require(nftsForSaleIds.contains(tokenId), \"Trying to unlist an NFT which is not listed yet!\");\n        address nftOwner = nftOwners[tokenId];\n        require(nftOwner == msg.sender, \"Cannot unlist other's NFT!\");\n        \n        nftsForSaleIds.remove(tokenId);\n        nftsForSaleByAddress[msg.sender].remove(tokenId);\n        delete nftOwners[tokenId];\n        delete nftsForSalePrices[tokenId];\n        delete priceTypes[tokenId];\n        \n        IERC721(trustedNftAddress).transferFrom(address(this), msg.sender, tokenId);\n        emit Unlist(tokenId);\n    }\n\n    function buy(uint tokenId) public payable {\n        require(nftsForSaleIds.contains(tokenId), \"Trying to unlist an NFT which is not listed yet!\");\n        address payable nftOwner = address(uint160(nftOwners[tokenId]));\n        address payable _owner = address(uint160(owner));\n        \n        uint price = nftsForSalePrices[tokenId];\n        uint fee = price.mul(sellingFeeRateX100).div(1e4);\n        uint amountAfterFee = price.sub(fee);\n        PriceType _priceType = priceTypes[tokenId];\n    \n        nftsForSaleIds.remove(tokenId);\n        nftsForSaleByAddress[nftOwners[tokenId]].remove(tokenId);\n        delete nftOwners[tokenId];\n        delete nftsForSalePrices[tokenId];\n        delete priceTypes[tokenId];\n        \n        if (_priceType == PriceType.ETHER) {\n            require(msg.value >= price, \"Insufficient ETH is transferred to purchase!\");\n            _owner.transfer(fee);\n            nftOwner.transfer(amountAfterFee);\n            // in case extra ETH is transferred, forward the extra to owner\n            if (msg.value > price) {\n                _owner.transfer(msg.value.sub(price));                \n            }\n        } else if (_priceType == PriceType.TOKEN) {\n            require(IERC20(trustedFeeTokenAddress).transferFrom(msg.sender, address(this), price), \"Could not transfer fee to Marketplace!\");\n            require(IERC20(trustedFeeTokenAddress).transfer(_owner, fee), \"Could not transfer purchase fee to admin!\");\n            require(IERC20(trustedFeeTokenAddress).transfer(nftOwner, amountAfterFee), \"Could not transfer sale revenue to NFT seller!\");\n        } else {\n            revert(\"Invalid Price Type!\");\n        }\n        IERC721(trustedNftAddress).transferFrom(address(this), msg.sender, tokenId);\n        emit Buy(tokenId);\n    }\n    \n    event ERC721Received(address operator, address from, uint256 tokenId, bytes data);\n    \n    // ERC721 Interface Support Function\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data) public returns(bytes4) {\n        require(msg.sender == trustedNftAddress);\n        emit ERC721Received(operator, from, tokenId, data);\n        return this.onERC721Received.selector;\n    }\n    \n}"
    }
  }
}