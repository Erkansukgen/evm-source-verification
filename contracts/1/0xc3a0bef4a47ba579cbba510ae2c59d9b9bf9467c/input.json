{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"UniqueAddresses.sol":{"content":"pragma solidity 0.8.2;\n\n/**\n * This file is part of the 1st Solidity Gas Golfing Contest.\n *\n * This work is licensed under Creative Commons Attribution ShareAlike 3.0.\n * https://creativecommons.org/licenses/by-sa/3.0/\n *\n * Author: Greg Hysen (hyszeth.eth)\n * Date: June 2018\n * Description: A simple hash table with open-addressing and linear probing\n *              is used to filter out duplicate array elements. The unique\n *              array is generated in-place, with distinct elements overwriting\n *              duplicates. At the end of the algorithm, these values are\n *              transposed to a separate array with a length equal to the number\n *              of unique elements.\n */\ncontract UniqueAddressesHelper {\n    // Convert uint256 > address\n    function toUint(address val) internal pure returns (uint256 addr) {\n        assembly {\n            addr := add(val, 32)\n        }\n    }\n\n    // Convert address > uint256\n    function toAddr(uint256 val) internal pure returns (address addr) {\n        assembly {\n            addr := add(val, 32)\n        }\n    }\n\n    // Hash table size.\n    // - Size should be prime for a good average distribution.\n    // - Space is preallocated, for efficiency.\n    // - Specific value was selected based on gas and average # of collisions.\n    uint256 constant HASH_TABLE_SIZE = 313;\n\n    // A randomly generated offset that is added to each entry in the hash table.\n    // Rather than storing additional information on occupancy, we add this offset to each entry.\n    // Since the table is initially zeroed out, we consider `0` to mean unoccupied.\n    uint256 constant RAND_OFFSET =\n        0x613c12789c3f663a544355053c9e1e25d50176d60796a155f553aa0f8445ee66;\n\n    function uniqueAddresses(address[] memory input)\n        public\n        pure\n        returns (address[] memory ret)\n    {\n        // Base cases\n        uint256 inputLength = input.length;\n        if (inputLength == 0 || inputLength == 1) return input;\n\n        // Fast forward to second unique character, if one exists.\n        uint256 firstCharacter = toUint(input[0]);\n        uint256 i = 1;\n        while (toUint(input[i]) == firstCharacter) {\n            if (++i != inputLength) continue;\n            // The entire array was composed of a single value.\n            ret = createUniqueArray(input, 1);\n            return ret;\n        }\n\n        // Run uniquify on remaining elements.\n        // `i` is the index of the first mismatch.\n        ret = uniquifyPrivate(input, inputLength, firstCharacter, i);\n        return ret;\n    }\n\n    /**\n     * @dev A simple hash table with open-addressing and linear probing\n     *      is used to filter out duplicate array elements. The unique\n     *      array is generated in-place, with distinct elements overwriting\n     *      duplicates. At the end of the algorithm, these values are\n     *      transposed to a separate array with a length equal to the number\n     *      of unqiue elements.\n     *\n     * @param input The list of integers to uniquify.\n     * @param inputLength The length of `input`.\n     * @param current First element in `input`.\n     * @param i Where to start search.\n     * @return The input list, with any duplicate elements removed.\n     */\n    function uniquifyPrivate(\n        address[] memory input,\n        uint256 inputLength,\n        uint256 current,\n        uint256 i\n    ) private pure returns (address[] memory) {\n        // Create hash table; initialized to all zeroes.\n        uint256[HASH_TABLE_SIZE] memory hashTable;\n        // Record first element in `hashTable`\n        uint256 hashKey = current % HASH_TABLE_SIZE;\n        uint256 hashValue = current + RAND_OFFSET;\n        hashTable[hashKey] = hashValue;\n        // Unique elements overwrite duplicates in `input`.\n        uint256 uniqueIndex = 1;\n        // Holds the current hash value while searching the hash table.\n        uint256 queriedHashValue;\n\n        // Create unique list.\n        while (i != inputLength) {\n            // One the right side of `==`, `current` resolves\n            // to the value it had on the previous loop iteration.\n            if ((current = toUint(input[i])) == current) {\n                ++i;\n                continue;\n            }\n\n            // Check if current `input` element is unique.\n            hashValue = current + RAND_OFFSET;\n            if (\n                (queriedHashValue = hashTable[\n                    (hashKey = current % HASH_TABLE_SIZE)\n                ]) == 0\n            ) {\n                // Current element is unique.\n                // Move value to its correct position in `input` and record in hash table.\n                if (uniqueIndex != i++) input[uniqueIndex] = toAddr(current);\n                uniqueIndex++;\n                hashTable[hashKey] = hashValue;\n                continue;\n            }\n\n            // We know `hashKey` exists in `hashTable`, meaning this value\n            // is either a duplcicate or we have a hash collision.\n            while (queriedHashValue != hashValue) {\n                // Calculate next key\n                hashKey = (hashKey + 1) % HASH_TABLE_SIZE;\n                // If non-zero, keep searching.\n                if ((queriedHashValue = hashTable[(hashKey)]) != 0) {\n                    continue;\n                }\n                // False positive, this element is unique.\n                // Move value to its correct position in `input` and record in hash table.\n                if (uniqueIndex != i) input[uniqueIndex] = toAddr(current);\n                uniqueIndex++;\n                hashTable[hashKey] = hashValue;\n                break;\n            }\n\n            // We found a duplicate element. Increment index into `input`.\n            ++i;\n        }\n\n        // If all elements were unique, simply return `input`.\n        // Otherwise, transpose the unique list to its own array.\n        if (i == uniqueIndex) return input;\n        return createUniqueArray(input, uniqueIndex);\n    }\n\n    function createUniqueArray(address[] memory input, uint256 uniqueLength)\n        private\n        pure\n        returns (address[] memory ret)\n    {\n        // Copy in groups of 10 to save gas.\n        ret = new address[](uniqueLength);\n        uint256 max = (uniqueLength / 10) * 10;\n        uint256 i;\n        while (i != max) {\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n            ret[i++] = input[i];\n        }\n        while (i != uniqueLength) ret[i++] = input[i];\n        return ret;\n    }\n}\n"}}}