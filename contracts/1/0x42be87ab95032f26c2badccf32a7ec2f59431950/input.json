{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/DSA_test/1inch.sol": {
      "content": "pragma solidity ^0.6.0;\n\n// interface OneInchInterace {\n\n// }\n\ninterface OneSplitInterface {\n    function swap(\n        TokenInterface fromToken,\n        TokenInterface toToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution, // [Uniswap, Kyber, Bancor, Oasis]\n        uint256 disableFlags // 16 - Compound, 32 - Fulcrum, 64 - Chai, 128 - Aave, 256 - SmartToken, 1024 - bDAI\n    ) external payable;\n\n    function getExpectedReturn(\n        TokenInterface fromToken,\n        TokenInterface toToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 disableFlags\n    )\n    external\n    view\n    returns(\n        uint256 returnAmount,\n        uint256[] memory distribution\n    );\n}\n\n\ninterface TokenInterface {\n    function allowance(address, address) external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n    function approve(address, uint) external;\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\n// interface MemoryInterface {\n//     function getUint(uint _id) external returns (uint _num);\n//     function setUint(uint _id, uint _val) external;\n// }\n\n// interface EventInterface {\n//     function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external;\n// }\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n}\n\n\ncontract Helpers is DSMath {\n    /**\n     * @dev Return ethereum address\n     */\n    function getAddressETH() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\n    }\n\n    // /**\n    //  * @dev Return Memory Variable Address\n    //  */\n    // function getMemoryAddr() internal pure returns (address) {\n    //     return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\n    // }\n\n    // /**\n    //  * @dev Return InstaEvent Address.\n    //  */\n    // function getEventAddr() internal pure returns (address) {\n    //     return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\n    // }\n\n    // /**\n    //  * @dev Get Uint value from InstaMemory Contract.\n    // */\n    // function getUint(uint getId, uint val) internal returns (uint returnVal) {\n    //     returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\n    // }\n\n    // /**\n    //  * @dev Set Uint value in InstaMemory Contract.\n    // */\n    // function setUint(uint setId, uint val) internal {\n    //     if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\n    // }\n\n    // /**\n    //  * @dev Connector Details\n    // */\n    // function connectorID() public pure returns(uint _type, uint _id) {\n    //     (_type, _id) = (1, 0);\n    // }\n}\n\n\ncontract CompoundHelpers is Helpers {\n    // /**\n    //  * @dev Return 1 Inch Address\n    //  */\n    // function getOneInchAddress() internal pure returns (address) {\n    //     return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    // }\n\n    /**\n     * @dev Return 1 Split Address\n     */\n    function getOneSplitAddress() internal pure returns (address) {\n        return 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\n    }\n}\n\n\ncontract BasicResolver is CompoundHelpers {\n\n    function sell(\n        address buyAddr,\n        address sellAddr,\n        uint sellAmt,\n        uint unitAmt,\n        uint getId\n    ) external payable {\n        TokenInterface _buyAddr = TokenInterface(buyAddr);\n        TokenInterface _sellAddr = TokenInterface(sellAddr);\n        OneSplitInterface oneSplitContract = OneSplitInterface(getOneSplitAddress());\n        uint ethAmt = getAddressETH() == sellAddr ? sellAmt : 0;\n        (uint buyAmt, uint[] memory distribution) =\n        oneSplitContract.getExpectedReturn(\n                _sellAddr,\n                _buyAddr,\n                sellAmt,\n                unitAmt,\n                getId\n            );\n        oneSplitContract.swap.value(ethAmt)(\n            _sellAddr,\n            _buyAddr,\n            sellAmt,\n            buyAmt,\n            distribution,\n            getId\n        );\n    }\n\n}"
    }
  }
}