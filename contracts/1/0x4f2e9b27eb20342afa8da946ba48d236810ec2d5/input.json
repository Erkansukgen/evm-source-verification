{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Interfaces.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.6;\n\nimport { DataTypes } from \"Libraries.sol\";\n\ninterface CEther {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address owner) external view returns (uint256);\n    function balanceOfUnderlying(address owner) external returns (uint);\n    function deposit() external payable;\n    function exchangeRateCurrent() external returns (uint256);\n    // cToken.liquidateBorrow.value(100)(0xBorrower, cTokenCollateral)\n    function liquidateBorrow(address borrower, address cTokenCollateral) external payable;\n    // cToken.mint{value: _LqdtAmount, gas:250000}();\n    function mint() external payable;\n    function redeem(uint) external returns (uint);\n    function redeemUnderlying(uint) external returns (uint);\n    function supplyRatePerBlock() external returns (uint256);\n    function transfer(address dst, uint256 amount) external returns (bool);\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  // underlying function is not available for Aave tokens\n  function underlying (  ) external view returns ( address );\n\n  function liquidateBorrow ( address borrower, uint256 repayAmount, address cTokenCollateral ) external returns ( uint256 );\n  /************\n   * The mint function transfers an asset into the CompFi protocol, which begins \n   * accumulating interest based on the current Supply Rate for the asset. \n   * The user receives a quantity of cTokens equal to the underlying \n   * tokens supplied, divided by the current Exchange Rate.\n   * **********/\n  function mint ( uint256 mintAmount ) external returns ( uint256 );\n  /**********\n   * redeem function converts a specified quantity of cTokens into the underlying asset, \n   * and returns them to the user.\n   * redeemTokens - numberr of tokens to convert to the underlying token.\n   * RETURN: 0 on success, otherwise an Error code.\n   * ********/\n  function redeem( uint redeemTokens ) external returns ( uint );\n  \n  /**\n   * redeem underlying function converts cTokens into a specified quantity of the \n   * underlying asset, and returns them to the user.\n   * redeemAmount - number of underlying tokens desired, depends on the exchange rate\n   **/\n    // available only for Compound tokens, like cUSDC or cETH\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IFlashLoanReceiver {\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n}\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}\n\ninterface ILendingPool {\n  /**\n   * @dev Emitted on deposit()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the deposit\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n   * @param amount The amount deposited\n   * @param referral The referral code used\n   **/\n  event Deposit(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlyng asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to Address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed\n   * @param referral The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint256 borrowRateMode,\n    uint256 borrowRate,\n    uint16 indexed referral\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address indexed initiator,\n    address indexed asset,\n    uint256 amount,\n    uint256 premium,\n    uint16 referralCode\n  );\n\n  /**\n   * @dev Emitted when the pause is triggered.\n   */\n  event Paused();\n\n  /**\n   * @dev Emitted when the pause is lifted.\n   */\n  event Unpaused();\n\n  /**\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n   * LendingPoolCollateral manager using a DELEGATECALL\n   * This allows to have the events in the generated ABI for LendingPool.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n   * gets added to the LendingPool ABI\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The new liquidity rate\n   * @param stableBorrowRate The new stable borrow rate\n   * @param variableBorrowRate The new variable borrow rate\n   * @param liquidityIndex The new liquidity index\n   * @param variableBorrowIndex The new variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to deposit\n   * @param amount The amount to be deposited\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external;\n\n  /**\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n   * @param asset The address of the underlying asset borrowed\n   * @param rateMode The rate mode that the user wants to swap to\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n  /**\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n   *        borrowed at a stable rate and depositors are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n   * @param asset The address of the underlying asset deposited\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n   * For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts amounts being flash-borrowed\n   * @param modes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralETH the total collateral in ETH of the user\n   * @return totalDebtETH the total debt in ETH of the user\n   * @return availableBorrowsETH the borrowing power left of the user\n   * @return currentLiquidationThreshold the liquidation threshold of the user\n   * @return ltv the loan to value of the user\n   * @return healthFactor the current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  function initReserve(\n    address reserve,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n    external;\n\n  function setConfiguration(address reserve, uint256 configuration) external;\n\n  /**\n   * @dev Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @dev Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @dev Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @dev Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromAfter,\n    uint256 balanceToBefore\n  ) external;\n\n  function getReservesList() external view returns (address[] memory);\n\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n  function setPause(bool val) external;\n\n  function paused() external view returns (bool);\n}\n\n\ninterface IComptroller {\n\n    /**\n     * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n  function checkMembership ( address account, address cToken ) external view returns ( bool );\n  \n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n  function closeFactorMantissa (  ) external view returns ( uint256 );\n\n  function enterMarkets ( address[] memory cTokens ) external returns ( uint256[] memory );\n\n  function exitMarket ( address cTokenAddress ) external returns ( uint256 );\n\n    /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return ( possible error code ( semi-opaque ),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements )\n     */\n  function getAccountLiquidity ( address account ) external view returns ( uint256, uint256, uint256 );\n\n  function getAllMarkets (  ) external view returns ( address[] memory );\n\n    /**\n     * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n  function getAssetsIn ( address account ) external view returns ( address[] memory );\n\n  function liquidateBorrowAllowed ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 repayAmount ) external returns ( uint256 );\n\n  function liquidateBorrowVerify ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 actualRepayAmount, uint256 seizeTokens ) external;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n  function liquidationIncentiveMantissa (  ) external view returns ( uint256 );\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n// https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Factory.sol\n// https://github.com/Austin-Williams/uniswap-flash-swapper/blob/master/contracts/UniswapV2Interfaces.sol\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n  function allPairs(uint) external view returns (address pair);\n  function allPairsLength() external view returns (uint);\n  function feeTo() external view returns (address);\n  function feeToSetter() external view returns (address);\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n  function name() external pure returns (string memory);\n  function symbol() external pure returns (string memory);\n  function decimals() external pure returns (uint8);\n  function totalSupply() external view returns (uint);\n  function balanceOf(address owner) external view returns (uint);\n  function allowance(address owner, address spender) external view returns (uint);\n  function approve(address spender, uint value) external returns (bool);\n  function transfer(address to, uint value) external returns (bool);\n  function transferFrom(address from, address to, uint value) external returns (bool);\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n  function nonces(address owner) external view returns (uint);\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n  event Mint(address indexed sender, uint amount0, uint amount1);\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n  event Swap(\n      address indexed sender,\n      uint amount0In,\n      uint amount1In,\n      uint amount0Out,\n      uint amount1Out,\n      address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\n  function factory() external view returns (address);\n  function token0() external view returns (address);\n  function token1() external view returns (address);\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n  function price0CumulativeLast() external view returns (uint);\n  function price1CumulativeLast() external view returns (uint);\n  function kLast() external view returns (uint);\n  function mint(address to) external returns (uint liquidity);\n  function burn(address to) external returns (uint amount0, uint amount1);\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n  function skim(address to) external;\n  function sync() external;\n}\n\n\ninterface IWETH {\n    function approve ( address guy, uint256 wad ) external returns ( bool );\n    function balanceOf ( address ) external view returns ( uint256 );\n    function deposit() external payable;    // as opposed to mint\n    function transfer(address dst, uint wad) external returns (bool);\n    function withdraw(uint) external;       // as opposed to redeem\n}\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}"},"Libraries.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.6;\n\nimport { IERC20, IUniswapV2Pair, IUniswapV2Factory } from \"Interfaces.sol\";\n\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, 'SafeMath: addition overflow');\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, 'SafeMath: subtraction overflow');\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, 'SafeMath: multiplication overflow');\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, 'SafeMath: division by zero');\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, 'SafeMath: modulo by zero');\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      codehash := extcodehash(account)\n    }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, 'Address: insufficient balance');\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}('');\n    require(success, 'Address: unable to send value, recipient may have reverted');\n  }\n}\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      'SafeERC20: approve from non-zero to non-zero allowance'\n    );\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = address(token).call(data);\n    require(success, 'SafeERC20: low-level call failed');\n\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\n    }\n  }\n}\n\nlibrary DataTypes {\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60-63: reserved\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    uint256 data;\n  }\n\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n    \n        // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n}"},"PreachersCompFiLqdt.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.6;\n// PreachersCompFiLqdt v1.0.24 Mainnet\n\nimport { IERC20,\n    IComptroller, IUniswapV2Router01, IUniswapV2Router02, IUniswapV2Factory, IUniswapV2Pair,\n    IWETH, CEther, IUniswapV2Callee } from \"Interfaces.sol\";\nimport { SafeMath, UniswapV2Library } from \"Libraries.sol\";\n\n// https://uniswap.org/docs/v2/smart-contracts/router02/\n// Same address on Mainnet and Kovan\naddress constant UNISWAP_ROUTER_ADDRESS = address( 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D );\naddress constant kUniswapV2Factory = address( 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f );\n\n//address constant kETH = address( 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE );\naddress constant kETH = address( 0x0000000000000000000000000000000000000000 );    // preferred by UniSwap\n\naddress constant kCETH = address ( 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5 );    //  Mainnet\naddress constant kUnitroller = address( 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B );    // Mainnet\naddress constant kDAI = address( 0x6B175474E89094C44Da98b954EedeAC495271d0F );    // Mainnet\n\ncontract PreachersCompFiLqdt {\n    \n    IUniswapV2Router02 public uniswapRouter = IUniswapV2Router02( UNISWAP_ROUTER_ADDRESS );\n    IUniswapV2Factory constant uniswapV2Factory = IUniswapV2Factory( kUniswapV2Factory ); // same for all networks\n    address kWETH = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS).WETH();\n\n    // ACCESS CONTROL\n    // Only the `permissionedPairAddress` may call the `uniswapV2Call` function\n    address permissionedPairAddress = address( 1 );\n    enum SwapType {SimpleLoan, SimpleSwap, TriangularSwap}\n    \n    // stack too deep\n    address lqdtAccount;\n    address lqdtToken;\n    uint256 lqdtTokenAmount = 0;\n    address collateralToken;\n    IERC20 cCollateralToken;\n    IERC20 G_cCollateralUnderlying;\n    address[] cTokens = new address[]( 2 );\n    address[] cTokens1 = new address[]( 1 );\n    address dbgPair;\n\n   // Contract owner\n    address payable public owner;\n\n    // Modifiers\n    modifier onlyOwner( ) {\n        require( msg.sender == owner, \"caller is not the owner!\" );\n        _;\n    }\n\n   constructor( ) {\n       owner = payable( msg.sender );\n   }\n    \n    receive( ) external payable {\n        emit Received( \"Tokens received\", msg.sender, msg.value );\n    }\n    event Received( string, address, uint256 );\n    \n    /*************************************************************************************************************\n     * Call this contract function from the external \n     * remote job to perform the liquidation.\n     ************************************************************************************************************/\n    function doCompFiLiquidate( \n        // Borrow Account to be liquidated\n        address _lqdtAccount,       // Borrower\n        address _lqdtToken,         // CompFi CErc20/CEther Token to be liquidated\n        address _lqdtUnderlying,    // Token to be flash loaned and minted into _lqdtToken\n        uint256 _lqdtAmount,   // Maximum wei allowed of Underlying token for liquidation\n        // liquidation reimbursement and Reward Token\n        address _collateralToken,   // Tokens to be redeemed to repay flash loan and for reward\n        address _collateralUnderlying,  // Cryptocurrency to repay flash loan\n        uint256 _Gas                // gas amount ( 3000000 wei? ) for liquidateBorrow\n        ) external payable returns( bool ) {\n        \n        address LqdtUnderlying = address( _lqdtUnderlying );\n        address CollateralUnderlying = address( _collateralUnderlying );\n        \n        if ( address( _lqdtUnderlying ) == kETH ){ LqdtUnderlying = kWETH; }\n        if ( address( _collateralUnderlying ) == kETH ){ CollateralUnderlying = kWETH; }\n        \n        bytes memory _params =\n            abi.encode( \n                address( _lqdtAccount ),\n                address( _lqdtToken ),\n                address( _collateralToken ),\n                _Gas );\n        \n        PreachersSwap(\n            LqdtUnderlying,\n            _lqdtAmount,\n            CollateralUnderlying,\n            _params );\n\n        // Transfer any remaining tokens    - verified working for flashtoken\n        fWithdraw( _lqdtToken, 1 );\n        fWithdraw( _collateralToken, 1 );\n        fWithdraw( _lqdtUnderlying, 1 );\n        fWithdraw( _collateralUnderlying, 1 );\n        fWithdraw( kWETH, 1 );\n        fWithdraw( kETH, 1 );\n        /*************************************************************************/\n\n        return true;\n    }\n\n    /*****************************************************************************************************/\n    /*********************  UNISWAP FLASH SWAP SECTION  **************************************************/\n    /*****************************************************************************************************/\n    // https://github.com/Austin-Williams/uniswap-flash-swapper/blob/master/contracts/UniswapFlashSwapper.sol\n    // @description Flash-borrows _amount of _tokenBorrow from a Uniswap V2 pair and repays using _tokenPay\n    // @param _tokenBorrow The address of the token to flash-borrow, use 0x0 for ETH\n    //      _lqdtTokenUnderlying\n    // @param _amount, The amount of _tokenBorrow needed\n    // @param _tokenPay, The address of the token to use to payback the flash-borrow, use 0x0 for ETH\n    //      _collateralUnderlying\n    // @param _params, Data that will be passed to the `execute` function\n    \n    // @notice Flash-borrows _amount of _tokenBorrow from a Uniswap V2 pair and repays using _tokenPay\n    // @param _tokenBorrow The address of the token you want to flash-borrow, use 0x0 for ETH\n    // @param _amount The amount of _tokenBorrow you will borrow\n    // @param _tokenPay The address of the token you want to use to payback the flash-borrow, use 0x0 for ETH\n    // @param _userData Data that will be passed to the `execute` function for the user\n    // @dev Depending on your use case, you may want to add access controls to this function\n    function PreachersSwap(\n        address _tokenBorrow,\n        uint256 _amount,\n        address _tokenPay,\n        bytes memory _userData ) internal {\n        \n        bool isBorrowingEth = false;\n        bool isPayingEth = false;\n        address tokenBorrow = _tokenBorrow;\n        address tokenPay = _tokenPay;\n\n        if ( _tokenBorrow == kETH ) {\n            isBorrowingEth = true;\n            tokenBorrow = kWETH; // we'll borrow WETH from UniswapV2 but then unwrap it for the user\n        }\n        if ( _tokenPay == kETH ) {\n            isPayingEth = true;\n            tokenPay = kWETH; // we'll wrap the user's ETH before sending it back to UniswapV2\n        }\n\n        /*******************************************************************************************\n        if ( tokenBorrow == tokenPay ) {\n            simpleFlashLoan( tokenBorrow, _amount, isBorrowingEth, isPayingEth, _userData );\n            return;\n        } else if ( tokenBorrow == kWETH || tokenPay == kWETH ) {\n            simpleFlashSwap( tokenBorrow, _amount, tokenPay, isBorrowingEth, isPayingEth, _userData );\n            return;\n        } else {\n            triangularFlashSwap( tokenBorrow, _amount, tokenPay, _userData );\n            return;\n        }\n        *******************************************************************************************/\n\n        if ( tokenBorrow == tokenPay ) {\n            simpleFlashLoan( tokenBorrow, _amount, isBorrowingEth, isPayingEth, _userData );\n        } else if ( tokenBorrow == kWETH || tokenPay == kWETH ) {\n            simpleFlashSwap( tokenBorrow, _amount, tokenPay, isBorrowingEth, isPayingEth, _userData );\n        }\n    }\n    \n    // @description This function is used when the user repays with the same token they borrowed\n    // @dev This initiates the flash borrow.\n    // See `simpleFlashLoanExecute` for the code that executes after the borrow.\n    function simpleFlashLoan(\n        address _tokenBorrow,\n        uint256 _amount,\n        bool _isBorrowingEth, \n        bool _isPayingEth,\n        bytes memory _params ) private {\n        \n        // if WETH is being borrowed, pair it with DAI,     WETH=>DAI, 0xb77098da3262E65739116A6CF9A111DC639b1a0f\n        address tokenPay = _tokenBorrow == kWETH ? kDAI : kWETH;\n        \n        // WETH=>WETH becomes WETH=>DAI\n        // to get,create a token pair. they must be sorted less to greater\n        (address token0, address token1 ) = _tokenBorrow < tokenPay ?\n            (_tokenBorrow, tokenPay) : (tokenPay, _tokenBorrow);\n\n        // permissionedPairAddress = uniswapV2Factory.getPair( _tokenBorrow, tokenPay );\n        permissionedPairAddress = uniswapV2Factory.getPair( token0, token1 );\n        address pairAddress = permissionedPairAddress; // gas efficiency\n        require( pairAddress != address( 0 ), \"Requested pair is not available.\" );\n        \n        token0 = IUniswapV2Pair( pairAddress ).token0( );\n        token1 = IUniswapV2Pair( pairAddress ).token1( );\n        \n        uint256 amount0Out = _tokenBorrow == token0 ? _amount : 0;\n        uint256 amount1Out = _tokenBorrow == token1 ? _amount : 0;\n        \n        bytes memory data = abi.encode( \n            SwapType.SimpleLoan,\n            _tokenBorrow,\n            _amount,\n            _tokenBorrow,\n            _isBorrowingEth,\n            _isPayingEth,\n            bytes( \"\" ),\n            _params\n        );\n\n        //  PERFORM THE SWAP. This will call the function uniswapV2Call.\n        // The swap will be for ????/WETH or for DAI/WETH\n        IUniswapV2Pair( pairAddress ).swap( amount0Out, amount1Out, address( this ), data );\n        \n        return;\n    }\n\n     // @description This function is used when either the _tokenBorrow or _tokenPay is kWETH or ETH\n    // @dev Since ~all tokens trade against kWETH ( if they trade at all ), we can use a single UniswapV2 pair to\n    //     flash-borrow and repay with the requested tokens.\n    // @dev This initiates the flash borrow. See `simpleFlashSwapExecute` for the code that executes after the borrow.\n    function simpleFlashSwap( \n        address _tokenBorrow,\n        uint256 _amount,\n        address _tokenPay,\n        bool _isBorrowingEth,\n        bool _isPayingEth,\n        bytes memory _params\n    ) private {\n        \n        // to get,create a token pair. they must be sorted less to greater\n        (address token0, address token1 ) = _tokenBorrow < _tokenPay ?\n            (_tokenBorrow, _tokenPay) : (_tokenPay, _tokenBorrow);\n            \n        permissionedPairAddress = uniswapV2Factory.getPair( token0, token1 );\n        address pairAddress = permissionedPairAddress; // gas efficiency\n        require( pairAddress != address( 0 ), \"Requested pair is not available.\" );\n        \n        token0 = IUniswapV2Pair( pairAddress ).token0( );\n        token1 = IUniswapV2Pair( pairAddress ).token1( );\n        \n        uint256 amount0Out = _tokenBorrow == token0 ? _amount : 0;\n        uint256 amount1Out = _tokenBorrow == token1 ? _amount : 0;\n\n        bytes memory data = abi.encode( \n            SwapType.SimpleSwap,\n            _tokenBorrow,\n            _amount,\n            _tokenPay,\n            _isBorrowingEth,\n            _isPayingEth,\n            bytes( \"\" ),\n            _params\n        );\n        \n        // PERFORM THE SWAP. This will call the function uniswapV2Call.\n        IUniswapV2Pair( pairAddress ).swap( amount0Out, amount1Out, address( this ), data );\n        \n        return;\n    }\n    \n    \n    \n    /********************************************************************************************/\n    /***********************  START OF SWAP EXECUTE FUNCTIONS  ***********************************/\n    /********************************************************************************************/\n\n    /*****************************************************************************************************\n     * THIS FUNCTION IS CALLED BY THE IUniswapV2Pair.swap FUNCTION BY NAME AND PARAMETERS\n     *                  --------------------------------------\n     * Repayment\n     * At the end of following uniswapV2Call, there must return enough tokens to repay the pair to make\n     * it whole. Specifically, this means that the product of the pair reserves after the swap,\n     * discounting all token amounts sent by 0.3% LP fee, must be greater than before.\n     * \n     * msg.sender is the swap pair address\n     * function uniswapV2Call( \n     *      address sender,         // this contract\n     *      uint amount0,           // amount of token0\n     *      uint amount1,           // amount of token1\n     *      bytes calldata data ) { // local parameter data\n     * \n     *  address token0 = IUniswapV2Pair( msg.sender ).token0( ); // fetch the address of token0\n     *  address token1 = IUniswapV2Pair( msg.sender ).token1( ); // fetch the address of token1\n     * \n     *   // ensure that msg.sender is a V2 pair\n     *  assert( msg.sender == IUniswapV2Factory( factoryV2 ).getPair( token0, token1 ) );\n     *  ---- rest of the custom actions go here;'\n     * }\n     * \n    *****************************************************************************************************/\n    // @notice Function is called by the Uniswap V2 pair's `swap` function\n    function uniswapV2Call( \n        address _sender,\n        uint _amount0,\n        uint _amount1,\n        bytes calldata _data ) external payable {\n        \n        // access control\n        require( msg.sender == permissionedPairAddress, \"only permissioned UniswapV2 pair can call\" );\n        require( _sender == address( this ), \"only this contract may initiate\" );\n\n        // decode data\n        (SwapType _swapType,\n         address _tokenBorrow,\n         uint256 _amount,\n         address _tokenPay,\n         bool _isBorrowingEth,\n         bool _isPayingEth,\n         bytes memory _triangleData,\n         bytes memory _userData\n        ) = abi.decode( _data, ( SwapType, address, uint256, address, bool, bool, bytes, bytes ) );\n\n        if ( _swapType == SwapType.SimpleLoan ) {\n            \n            simpleFlashLoanExecute( _tokenBorrow, _amount, msg.sender, _isBorrowingEth, _isPayingEth, _userData );\n\n        } else if ( _swapType == SwapType.SimpleSwap ) {\n            \n            simpleFlashSwapExecute( _tokenBorrow, _amount, _tokenPay, msg.sender, _isBorrowingEth, _isPayingEth, _userData );\n\n        }\n\n        // NOOP to silence compiler \"unused parameter\" warning\n        if ( false ) {\n            _amount0;\n            _amount1;\n            _triangleData;\n        }\n    }\n    \n    // token Borrowed same as token to repay\n    function simpleFlashLoanExecute( \n        address _tokenBorrow,\n        uint256 _amount,\n        address _pairPayAddress,\n        bool _isBorrowingEth,\n        bool _isPayingEth,\n        bytes memory _userData\n    ) private {\n        // unwrap the kWETH just loaned by UniSwap, if necessary\n        if ( _isBorrowingEth ) {\n            IWETH( kWETH ).withdraw( _amount ); // burn WETH mint ETH\n            // we now have ETH\n        }\n        \n        // compute amount of tokens that need to be paid back\n        uint fee = ((_amount * 3) / 997) + 1;\n        uint amountToRepay = _amount + fee;\n\n        address tokenBorrowed = _isBorrowingEth ? kETH : _tokenBorrow;\n        address tokenToRepay = _isPayingEth ? kETH : _tokenBorrow;\n\n        // use the swap flash tokens to liquidate the CompFi unhealthy account\n        executeLiquidation( tokenBorrowed, _amount, tokenToRepay, amountToRepay, _isBorrowingEth, _userData );\n\n        // payback the loan\n\n        if ( _isPayingEth || tokenToRepay == kWETH || tokenToRepay == kETH ){\n            \n            // CompFi just paid in ETH, redeemed earlier from cETH. UniSwap takes WETH.\n\n            IWETH( kWETH ).transfer( _pairPayAddress, amountToRepay );\n\n        } else {  //  DO NOT TOUCH !!!\n            \n            IERC20 cTokenBorrow = IERC20( _tokenBorrow );\n            cTokenBorrow.approve( _tokenBorrow, amountToRepay );\n            \n            cTokenBorrow.transfer( _pairPayAddress, amountToRepay );\n        }\n\n    }\n\n    // @description This is the code that is executed after `simpleFlashSwap` initiated the flash-borrow\n    // @dev When this code executes, this contract will hold the flash-borrowed _amount of _tokenBorrow\n    function simpleFlashSwapExecute( \n        address _tokenBorrow,\n        uint _amount,\n        address _tokenPay,\n        address _pairPayAddress,\n        bool _isBorrowingEth,\n        bool _isPayingEth,\n        bytes memory _userData\n    ) private {\n        // unwrap the kWETH just loaned by UniSwap, if necessary\n        if ( _isBorrowingEth ) {\n            IWETH( kWETH ).withdraw( _amount ); // burn WETH mint ETH\n            // we now have ETH with which to liquidate\n        }\n        \n        // compute the amount of _tokenPay that needs to be repaid\n\n        // function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn)\n        // out DAI, in WETH\n\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair( _pairPayAddress ).getReserves();\n        uint256 amountToRepay = UniswapV2Library.getAmountIn( _amount, reserve1, reserve0 );\n\n        // get the orignal tokens the user requested\n        address tokenBorrowed = _isBorrowingEth ? kETH : _tokenBorrow;\n        address tokenToRepay = _isPayingEth ? kETH : _tokenPay;\n\n        executeLiquidation( tokenBorrowed, _amount, tokenToRepay, amountToRepay, _isBorrowingEth, _userData );\n\n        // pay back loan using the collateral just received\n        \n        if ( _isPayingEth || tokenToRepay == kWETH || tokenToRepay == kETH ){\n            \n            // CompFi just paid in ETH, redeemed earlier from cETH. UniSwap takes WETH.\n\n            IWETH( kWETH ).transfer( _pairPayAddress, amountToRepay );\n            \n        } else {\n            \n            IERC20 cTokenToRepay = IERC20( tokenToRepay );\n            cTokenToRepay.approve( tokenToRepay, amountToRepay );\n            \n            cTokenToRepay.transfer( _pairPayAddress, amountToRepay );\n        }\n        \n        return;\n    }\n    \n\n    // @description This is where the unhealthy CompFi account is liquidated\n    // @dev When this function executes, this contract will hold _amount of _tokenBorrow ( LqdtToken ).\n    // @dev It is important that, by the end of the execution of this function, this contract holds the necessary\n    //     amount of the original _tokenPay ( CollateralToken ) needed to pay back the flash-loan.\n    //\n    \n    function executeLiquidation( \n        address _LqdtTokenUnderlying, \n        uint256 _LqdtAmount,\n        address _CollateralUnderlying,\n        uint _amountToRepay,\n        bool _isBorrowingEth,\n        bytes memory _params ) public payable {\n\n\t\tIComptroller ctroll = IComptroller( kUnitroller );\n        address LqdtAccount;\n        address LqdtToken;\n        address CollateralToken;\n        uint256 iGas = 0;\n        \n        ( LqdtAccount, LqdtToken, CollateralToken, iGas ) = \n            abi.decode( _params, ( address, address, address, uint256 ) );\n        \n        address LqdtTokenUnderlying = _LqdtTokenUnderlying;\n        \n        // if CompFi lqdt is cETH, convert WETH to ETH first, then mint cETH.\n        if ( LqdtToken == kCETH ){\n            if ( _isBorrowingEth == false ){    // if true, ETH was unwrapped earlier\n                // unwrap WETH, create ETH\n                IWETH( kWETH ).withdraw( _LqdtAmount ); // burn WETH mint ETH\n            }\n            LqdtTokenUnderlying = kETH; // was WETH, now ETH\n        }\n        \n        if ( LqdtToken == CollateralToken ){\n            cTokens1[0] = LqdtToken;\n            ctroll.enterMarkets( cTokens1 );\n        } else {\n            cTokens[0] = LqdtToken;\n            cTokens[1] = CollateralToken;\n            ctroll.enterMarkets( cTokens );\n        }\n        \n        // convert the _LqdtTokenUnderlying to a CompFi LqdtToken\n        if ( LqdtTokenUnderlying == kETH ){\n            // D:\\CRYPTO\\Liquidation\\Compound.Finance\\Contracts\\examples\\\n            //  compound-supply-examples-master\\solidity-examples\\MyContracts.sol\n            // function supplyEthToCompound( )\n            \n    \t\tCEther cCEth = CEther( LqdtToken );\n\n            // the liquidateBorrow will convert ETH to cETH, then pay down the debt\n            cCEth.liquidateBorrow{value: _LqdtAmount, gas: iGas }( LqdtAccount, CollateralToken );\n\n        } else {    //    DO NOT TOUCH !!!\n            IERC20 cLqdtTokenUnderlying = IERC20 ( LqdtTokenUnderlying );\n\n            IERC20 cLqdtToken = IERC20( LqdtToken );\n            \n            // contract has underlying, no compound tokens\n            cLqdtTokenUnderlying.approve( LqdtToken, _LqdtAmount );  // approve to liquidate\n\n            // liquidation expects underlying to pay Comp tokens\n    \t    cLqdtToken.liquidateBorrow( LqdtAccount, _LqdtAmount, CollateralToken );\n        }\n        \n        if ( LqdtToken != CollateralToken ){\n            ctroll.exitMarket( LqdtToken );\n        }\n\n        // Redeem the collateral to repay the flash loan\n\t\t// convert the CompFi token to the underlying token\n\n        if ( CollateralToken == kCETH ){    // WORKS, DO NOT TOUCH !!!\n            \n\n            CEther cEther = CEther( CollateralToken );\n\n     \t    cEther.redeemUnderlying( _amountToRepay );   // Create ETH\n\n            // ETH just redeemed needs to be wrapped as WETH to repay the WETH=>DAI flash loan\n            IWETH( kWETH ).deposit{ value: _amountToRepay }( );\n\n        } else {            // WORKS, DO NOT TOUCH !!!\n\n            cCollateralToken = IERC20( CollateralToken );\n\n     \t    cCollateralToken.redeemUnderlying( _amountToRepay );\n        }\n        \n        ctroll.exitMarket( CollateralToken );\n\n        if ( false ){ _CollateralUnderlying = _CollateralUnderlying; }\n        \n        return;\n    }\n\n    /********************************************************************************************/\n    /***********************  END OF SWAP EXECUTE FUNCTIONS  ***********************************/\n    /********************************************************************************************/\n    \n    /***************  End of UNISWAP functions  **********************************************************/\n\n    /*************************************************************************************/\n    function fWithdraw( address _token, uint256 _iApprove ) payable public returns( bool ) {\n        uint256 tokenBalance = 0;\n        \n        if ( address( _token ) == kETH ){\n            tokenBalance = address( this ).balance;\n            if ( tokenBalance > 0 ){\n                owner.transfer( tokenBalance );\n            }\n        } else {\n\n            IERC20 cWithdrawToken = IERC20( _token );\n            if ( cWithdrawToken.balanceOf( address( this ) ) > 0 ){\n                tokenBalance = cWithdrawToken.balanceOf( address( this ) );\n                if ( _iApprove == 1 ) {\n                    cWithdrawToken.approve( address( this ), tokenBalance );\n                }\n                return cWithdrawToken.transfer( owner, tokenBalance );\n            }\n        }\n        return false; // nothing was withdrawn\n    }\n    \n    function AccountLiquidity( address _account ) public view returns ( uint, uint, uint ){\n        \n        IComptroller cTroll = IComptroller( kUnitroller );\n\n        return ( cTroll.getAccountLiquidity( address( _account ) ) );\n    }\n\n    function AccountAssets( address _account ) public view returns ( address[] memory ){\n        \n        IComptroller cTroll = IComptroller( kUnitroller );\n\n        return ( cTroll.getAssetsIn( address( _account ) ) );\n    }\n\n    function RedeemUnderling( address _Token ) public payable returns ( uint256, address ){\n        uint256 inBalance = 0;\n        uint256 outBalance = 0;\n        address inToken = address( _Token );\n        address outToken;\n\n        if ( inToken == kCETH ){\n            CEther cInToken = CEther( inToken );\n            inBalance = cInToken.balanceOf( address( this ) );\n            outBalance = cInToken.redeem( inBalance );\n            outToken = kETH;\n        } else {\n            IERC20 cInToken = IERC20( inToken );\n            inBalance = cInToken.balanceOf( address( this ) );\n            outBalance = cInToken.redeem( inBalance );\n            outToken = address( cInToken.underlying( ) );\n        }\n        return ( outBalance, outToken );\n    }\n    \n    function GetPair( address _token0, address _token1) public{\n        \n        (address token0, address token1 ) = _token0 < _token1 ?\n            (_token0, _token1) : (_token1, _token0);\n            \n        permissionedPairAddress = uniswapV2Factory.getPair( token0, token1 );\n        address pairAddress = permissionedPairAddress; // gas efficiency\n\n        token0 = IUniswapV2Pair( pairAddress ).token0( );\n        token1 = IUniswapV2Pair( pairAddress ).token1( );\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair( pairAddress ).getReserves();\n        \n        uint256 token0PairBalance = IERC20( token0 ).balanceOf( pairAddress );\n        uint256 token1PairBalance = IERC20( token1 ).balanceOf( pairAddress );\n\n        emit PairInfo( token0, reserve0, token1, reserve1,\n            pairAddress, token0PairBalance, token1PairBalance, \"PairInfo\" );\n        return;\n    }\n    event PairInfo( address tokenA, uint256 reserveA,\n        address tokenB, uint256 reserveB, address pairAddress, uint256, uint256, string _eventname );\n\n    function ShowWETH() public view returns(address){\n        return kWETH;\n    }\n\n\n/*************************************************************************/    \n}\n"}}}