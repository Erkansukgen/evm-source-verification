{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/TorroIco.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity 0.6.6;\n\n/// @title Interface for ERC-20 Torro governing token.\n/// @notice ERC-20 token.\n/// @author ORayskiy - @robitnik_TorroDao\ninterface ITorro {\n\n  // Initializer.\n\n  /// @notice Initializes governing token.\n  /// @param dao_ address of cloned DAO.\n  /// @param factory_ address of factory.\n  /// @param supply_ total supply of tokens.\n  function initializeCustom(address dao_, address factory_, uint256 supply_) external;\n\n  // Public calls.\n\n  /// @notice Token's name.\n  /// @return string name of the token.\n  function name() external view returns (string memory);\n\n  /// @notice Token's symbol.\n  /// @return string symbol of the token.\n  function symbol() external view returns (string memory);\n\n  /// @notice Token's decimals.\n  /// @return uint8 demials of the token.\n  function decimals() external pure returns (uint8);\n\n  /// @notice Token's total supply.\n  /// @return uint256 total supply of the token.\n  function totalSupply() external view returns (uint256);\n\n  /// @notice Count of token holders.\n  /// @return uint256 number of token holders.\n  function holdersCount() external view returns (uint256);\n\n  /// @notice All token holders.\n  /// @return array of addresses of token holders.\n  function holders() external view returns (address[] memory);\n\n  /// @notice Available balance for address.\n  /// @param sender_ address to get available balance for.\n  /// @return uint256 amount of tokens available for given address.\n  function balanceOf(address sender_) external view returns (uint256);\n\n  /// @notice Staked balance for address.\n  /// @param sender_ address to get staked balance for.\n  /// @return uint256 amount of staked tokens for given address.\n  function stakedOf(address sender_) external view returns (uint256);\n\n  /// @notice Total balance for address = available + staked.\n  /// @param sender_ address to get total balance for.\n  /// @return uint256 total amount of tokens for given address.\n  function totalOf(address sender_) external view returns (uint256);\n\n  /// @notice Spending allowance.\n  /// @param owner_ token owner address.\n  /// @param spender_ token spender address.\n  /// @return uint256 amount of owner's tokens that spender can use.\n  function allowance(address owner_, address spender_) external view returns (uint256);\n\n  /// @notice Unstaked supply of token.\n  /// @return uint256 amount of tokens in circulation that are not staked.\n  function unstakedSupply() external view returns (uint256);\n\n  /// @notice Staked supply of token.\n  /// @return uint256 amount of tokens in circulation that are staked.\n  function stakedSupply() external view returns (uint256);\n\n  // Public transactions.\n\n  /// @notice Transfer tokens to recipient.\n  /// @param recipient_ address of tokens' recipient.\n  /// @param amount_ amount of tokens to transfer.\n  /// @return bool true if successful.\n  function transfer(address recipient_, uint256 amount_) external returns (bool);\n\n  /// @notice Approve spender to spend an allowance.\n  /// @param spender_ address that will be allowed to spend specified amount of tokens.\n  /// @param amount_ amount of tokens that spender can spend.\n  /// @return bool true if successful.\n  function approve(address spender_, uint256 amount_) external returns (bool);\n\n  /// @notice Approves DAO to spend tokens.\n  /// @param owner_ address whose tokens DAO can spend.\n  /// @param amount_ amount of tokens that DAO can spend.\n  /// @return bool true if successful.\n  function approveDao(address owner_, uint256 amount_) external returns (bool);\n\n  /// @notice Transfers tokens from owner to recipient by approved spender.\n  /// @param owner_ address of tokens' owner whose tokens will be spent.\n  /// @param recipient_ address of recipient that will recieve tokens.\n  /// @param amount_ amount of tokens to be spent.\n  /// @return bool true if successful.\n  function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool);\n\n  /// @notice Increases allowance for given spender.\n  /// @param spender_ spender to increase allowance for.\n  /// @param addedValue_ extra amount that spender can spend.\n  /// @return bool true if successful.\n  function increaseAllowance(address spender_, uint256 addedValue_) external returns (bool);\n\n  /// @notice Decreases allowance for given spender.\n  /// @param spender_ spender to decrease allowance for.\n  /// @param subtractedValue_ removed amount that spender can spend.\n  /// @return bool true if successful.\n  function decreaseAllowance(address spender_, uint256 subtractedValue_) external returns (bool);\n\n  /// @notice Stake tokens.\n  /// @param amount_ amount of tokens to be staked.\n  /// @return bool true if successful.\n  function stake(uint256 amount_) external returns (bool);\n\n  /// @notice Unstake tokens.\n  /// @param amount_ amount of tokens to be unstaked.\n  /// @return bool true if successful.\n  function unstake(uint256 amount_) external returns (bool);\n\n  /// @notice Functionality for DAO to add benefits for all stakers.\n  /// @param amount_ amount of wei to be shared among stakers.\n  function addBenefits(uint256 amount_) external;\n\n  /// @notice Sets DAO and Factory addresses.\n  /// @param dao_ DAO address that this token governs.\n  /// @param factory_ Factory address.\n  function setDaoFactoryAddresses(address dao_, address factory_) external;\n\n  /// @notice Pauses token functionality.\n  /// @param paused_ whether token functionality is paused.\n  function setPause(bool paused_) external;\n\n  /// @notice Sets whitelist address allowing it to make token operations when paused.\n  /// @param whitelistAddress_ address to whitelist.\n  function setWhitelistAddress(address whitelistAddress_) external;\n\n  /// @notice Functionality for owner to burn tokens.\n  /// @param amount_ amount of tokens to burn.\n  function burn(uint256 amount_) external;\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/// @author ORayskiy - @robitnik_TorroDao\ncontract TorroIco {\n  using SafeMath for uint256;\n\n  ITorro private _token;\n  address private _owner;\n  uint256 private _startRate;\n  uint256 private _rateDecrease;\n  uint256 private _currentRate;\n  uint256 private _startingBalance;\n  uint256 private _rateDecreaseBalanceStep;\n  uint256 private _rateDecreaseBalance;\n  bool private _isClosed;\n  uint256 private _weiLimit;\n  mapping (address => uint256) private _addressSpent;\n\n  event Purchase();\n\n  // startRate = 180\n  // rateDecrease = 10\n  // rateSteps = 3\n  // startingBalance = 60,000\n  // ethLimit = 10\n  constructor(address token_, uint256 startRate_, uint256 rateDecrease_, uint256 rateSteps_, uint256 startingBalance_, uint256 ethLimit_) public {\n    require(startRate_ > 0);\n    require(token_ != address(0x0));\n    _token = ITorro(token_);\n    _owner = msg.sender;\n    _startRate = startRate_;\n    _rateDecrease = rateDecrease_;\n    _currentRate = _startRate;\n    _startingBalance = startingBalance_.mul(10**uint256(_token.decimals()));\n    _rateDecreaseBalanceStep = _startingBalance.div(rateSteps_);\n    _rateDecreaseBalance = _startingBalance.sub(_rateDecreaseBalanceStep);\n    _weiLimit = ethLimit_.mul(1 ether);\n    _isClosed = true;\n  }\n\n  receive() external payable {\n    require(_isClosed == false);\n    require(msg.sender != address(0x0));\n\n    uint256 weiAmount = msg.value;\n    require(weiAmount > 0);\n\n    uint256 alreadySpent = _addressSpent[msg.sender];\n    uint256 afterSpent = alreadySpent.add(weiAmount);\n    require(afterSpent <= _weiLimit);\n\n    (uint256 tokens, uint256 refund) = _getTokenAmount(weiAmount);\n\n    _token.transfer(msg.sender, tokens);\n\n    if (refund > 0) {\n      payable(msg.sender).transfer(refund);\n    }\n\n    _addressSpent[msg.sender] = afterSpent;\n\n    emit Purchase();\n  }\n\n  function currentRate() public view returns (uint256) {\n    return _currentRate;\n  }\n\n  function tokensLeftAtCurrentRate() public view returns (uint256) {\n    uint256 balance = _token.balanceOf(address(this));\n    if (balance < _rateDecreaseBalance) {\n      return balance;\n    }\n    return balance.sub(_rateDecreaseBalance);\n  }\n\n  function isClosed() public view returns (bool) {\n    return _isClosed;\n  }\n\n  function _getTokenAmount(uint256 weiAmount_) private returns (uint256, uint256) {\n    uint256 amount = weiAmount_.mul(_currentRate);\n    uint256 balance = _token.balanceOf(address(this));\n    if (amount > balance || balance.sub(amount) <= _rateDecreaseBalance) {\n      uint256 hiRateAmount = balance.sub(_rateDecreaseBalance);\n      uint256 hiRateWeiAmount = hiRateAmount.div(_currentRate);\n      uint256 leftOverWeiAmount = weiAmount_.sub(hiRateWeiAmount);\n\n      bool proceed = _decreaseRate();\n      if (!proceed) {\n        return (hiRateAmount, leftOverWeiAmount);\n      }\n      uint256 loRateAmount = leftOverWeiAmount.mul(_currentRate);\n      return (hiRateAmount.add(loRateAmount), 0);\n    }\n    return (amount, 0);\n  }\n\n  function _decreaseRate() private returns (bool) {\n    if (_rateDecreaseBalance == 0) {\n      _currentRate = 0;\n      _isClosed = true;\n      return false;\n    }\n    _rateDecreaseBalance = _rateDecreaseBalance.sub(_rateDecreaseBalanceStep);\n    _currentRate = _currentRate.sub(_rateDecrease);\n    return true;\n  }\n\n  function open() public {\n    require(msg.sender == _owner);\n    _isClosed = false;\n  }\n\n  function close() public {\n    require(msg.sender == _owner);\n    payable(_owner).transfer(address(this).balance);\n    uint256 tokensLeft = _token.balanceOf(address(this));\n    if (tokensLeft > 0) {\n      _token.transfer(msg.sender, tokensLeft);\n    }\n    _isClosed = true;\n  }\n}\n"
    }
  }
}