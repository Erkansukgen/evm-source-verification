{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/AuditVerifier.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract variables {\r\n\r\n    address public constant platformTokenETH = 0xF063fE1aB7a291c5d06a86e14730b00BF24cB589; // Sale token address valid for mainnet ETH\r\n    address public constant platformTokenBSC = 0x04F73A09e2eb410205BE256054794fB452f0D245; // Sale token address valid for mainnet BSC\r\n    address public team_acc = 0xC14fb72518E67B008f1BD8E195861472f8128090;    //valid for mainnet\r\n    uint256  public minPlatTokenReq = 1000000000000000000000;  //1000 sale tokens\r\n    address public dead = 0x000000000000000000000000000000000000dEaD;\r\n    bool public burn = false;\r\n    bool public feesEnabled = false;\r\n    uint256 public verifyFees = 1000000000000000000;\r\n} \r\n\r\n\r\n\r\ncontract TokenAuditVerify is variables,Ownable {\r\n    \r\nmapping(address => bool) public Auditors;\r\nmapping(address => bool) public AuditorsAdded;\r\nmapping(address => address) public auditedBy;\r\nmapping(address => string) public auditedByName;\r\nmapping(address => bool) public AuditVerfied;\r\nmapping(address => string) public auditorComment;\r\nmapping(address => string) public auditorComment1;\r\nmapping(address => string) public auditorComment2;\r\nmapping(address => string) public auditorScore;\r\nmapping(address => string) public AuditorName;  \r\nmapping(address => bool) public verifiedAlready;\r\nmapping(address => uint256) public AuditorNumbers;\r\nmapping(address => mapping(uint256 => address)) public AuditorTotalList;\r\nmapping(uint256 => address) public AllAuditTokens;\r\nuint256 public auditsverifiedNumber;\r\n\r\n  function verifyAudit(address _token, string memory _score, string memory _comment, string memory _comment1, string memory _comment2) public payable {\r\n  \r\n    require(Auditors[msg.sender],\"NOT auditor\"); \r\n    require(!verifiedAlready[_token],\"already verified!\");\r\n  \r\n    if(feesEnabled){\r\n        if(burn){\r\n            require(IERC20(platformTokenBSC).transferFrom(msg.sender,dead,minPlatTokenReq), \"sale token transfer fail\");\r\n        }\r\n        else{\r\n            require(msg.value >= verifyFees,\"msg.value must be >= drop fees\");\r\n            payable(team_acc).transfer(verifyFees);\r\n        }\r\n    } \r\n\r\n\r\n    AuditVerfied[_token] = true;\r\n    auditorComment[_token] = _comment;\r\n    auditorComment1[_token] = _comment1;\r\n    auditorComment2[_token] = _comment2;\r\n    auditorScore[_token] = _score;\r\n    auditedBy[_token] = msg.sender;\r\n    auditedByName[_token] = AuditorName[msg.sender];\r\n    verifiedAlready[_token] = true;\r\n    AllAuditTokens[auditsverifiedNumber] = _token;\r\n    auditsverifiedNumber++;\r\n    \r\n    AuditorTotalList[msg.sender][AuditorNumbers[msg.sender]] = _token;\r\n    AuditorNumbers[msg.sender]++;\r\n    \r\n  }\r\n\r\nfunction updateComment(address _tokenAddress, string memory _newComment) public {\r\n    \r\n    require(Auditors[msg.sender],\"NOT auditor\");\r\n    require(auditedBy[_tokenAddress] == msg.sender, \"Incorrect Auditor\");\r\n    require(verifiedAlready[_tokenAddress],\"token not audit verified yet\");\r\n    auditorComment[_tokenAddress] = _newComment;\r\n    \r\n    \r\n}\r\n    \r\nfunction updateComment1(address _tokenAddress, string memory _newComment1) public {\r\n    \r\n    require(Auditors[msg.sender],\"NOT auditor\");\r\n    require(auditedBy[_tokenAddress] == msg.sender, \"Incorrect Auditor\");\r\n    require(verifiedAlready[_tokenAddress],\"token not audit verified yet\");\r\n    auditorComment1[_tokenAddress] = _newComment1;\r\n    \r\n    \r\n}    \r\nfunction updateComment2(address _tokenAddress, string memory _newComment2) public {\r\n    \r\n    require(Auditors[msg.sender],\"NOT auditor\");\r\n    require(auditedBy[_tokenAddress] == msg.sender, \"Incorrect Auditor\");\r\n    require(verifiedAlready[_tokenAddress],\"token not audit verified yet\");\r\n    auditorComment2[_tokenAddress] = _newComment2;\r\n    \r\n    \r\n}\r\nfunction updateScore(address _tokenAddress, string memory _newScore) public {\r\n    \r\n    require(Auditors[msg.sender],\"NOT auditor\");\r\n    require(auditedBy[_tokenAddress] == msg.sender, \"Incorrect Auditor\");\r\n    require(verifiedAlready[_tokenAddress],\"token not audit verified yet\");\r\n    auditorScore[_tokenAddress] = _newScore;\r\n    \r\n    \r\n} \r\n    function addToAuditors(address _auditorAddress, string memory _name)  onlyOwner public{\r\n        require(!Auditors[_auditorAddress], \"auditor already exist\");\r\n        Auditors[_auditorAddress]=true;\r\n        AuditorsAdded[_auditorAddress] = true;\r\n        AuditorName[_auditorAddress] = _name;\r\n        \r\n    }\r\n    \r\n    function changeAuditorName(address _auditorAddress, string memory _newName)  onlyOwner public{\r\n        \r\n        require(AuditorsAdded[_auditorAddress], \"auditor doesn't exist\");\r\n        AuditorName[_auditorAddress] = _newName;\r\n        \r\n    }\r\n    \r\n    function enableAuditor(address _auditorAddress)  onlyOwner public{\r\n        \r\n        require(AuditorsAdded[_auditorAddress], \"auditor doesnot exist!\");\r\n        require(!Auditors[_auditorAddress],\"Auditor already enabled\");\r\n        Auditors[_auditorAddress]=true;\r\n\r\n        \r\n    }\r\n    \r\n    function disableAuditor(address _auditorAddress)  onlyOwner public{\r\n        \r\n        require(AuditorsAdded[_auditorAddress], \"auditor doesnot exist!\");\r\n        require(Auditors[_auditorAddress],\"Auditor already disabled\");\r\n        Auditors[_auditorAddress]=false;\r\n        \r\n        \r\n    }\r\n\r\n    function updateAuditorName(address _auditorAddress,string memory _newName) public onlyOwner {\r\n        \r\n        AuditorName[_auditorAddress] = _newName;\r\n        \r\n        \r\n    }\r\n    \r\n    \r\n    function updateDeadAddress(address _newDeadAddress) onlyOwner public {\r\n        \r\n        dead = _newDeadAddress;\r\n        \r\n        \r\n    }    \r\n \r\n\r\n    \r\n function AddToAuditorsInMass(address[] memory _auditorAddresses, string[] memory _auditorNames) public onlyOwner{\r\n     \r\n    for(uint256 i = 0; i < _auditorAddresses.length; i++){\r\n        addToAuditors(_auditorAddresses[i],_auditorNames[i]);\r\n    }\r\n     \r\n }\r\n \r\n function RemoveFromAuditorsInMass(address[] memory _auditorAddresses) public onlyOwner{\r\n     \r\n    for(uint256 i = 0; i < _auditorAddresses.length; i++){\r\n        disableAuditor(_auditorAddresses[i]);\r\n    }\r\n }\r\n \r\nfunction changeSaleRequired(uint256 _newFeeAmount) public onlyOwner {\r\n    \r\n    require(_newFeeAmount >= 0,\"invalid amount\");\r\n    minPlatTokenReq = _newFeeAmount;\r\n    \r\n    \r\n    \r\n}\r\n\r\nfunction changeFees(uint256 _newFeeAmount) public onlyOwner {\r\n    \r\n    require(_newFeeAmount >= 0,\"invalid amount\");\r\n    verifyFees = _newFeeAmount;\r\n    \r\n   \r\n    \r\n}\r\n\r\n\r\nfunction removeAuditVerified(address _tokenAddress) public onlyOwner {\r\n    \r\n    AuditVerfied[_tokenAddress] = false;\r\n    \r\n    \r\n}\r\n    function enableFees() public onlyOwner{\r\n        \r\n        \r\n        feesEnabled = true;\r\n        \r\n    }\r\n    function disableFees() public onlyOwner{\r\n        \r\n        \r\n        feesEnabled = false;\r\n        \r\n    }    \r\n    function enableBurn() public onlyOwner{\r\n        \r\n        \r\n        burn = true;\r\n        \r\n    }\r\n    function disableBurn() public onlyOwner{\r\n        \r\n        \r\n        burn = false;\r\n        \r\n    }\r\n    \r\n    \r\n    function getTotalTokensByAuditor(address _Auditor) public view returns(address[] memory) {\r\n        \r\n        address[] memory auditedTokenList = new address[](AuditorNumbers[_Auditor]);\r\n        for(uint256 i = 0; i < AuditorNumbers[_Auditor]; i++){\r\n            auditedTokenList[i] = AuditorTotalList[_Auditor][i];\r\n    }\r\n        \r\n     return auditedTokenList;   \r\n        \r\n    }\r\n    \r\n    function getData(address _token) public view returns(bool,address,string memory,string memory,string memory,string memory,string memory) {\r\n        \r\n        return (AuditVerfied[_token],auditedBy[_token],auditedByName[_token],auditorComment[_token],auditorComment1[_token],auditorComment2[_token],auditorScore[_token]);\r\n        \r\n        \r\n    }\r\n    function getAllAuditTokens() public view returns (address[] memory){\r\n     address[] memory TokenList = new address[](auditsverifiedNumber);   \r\n        for(uint256 i = 0; i < auditsverifiedNumber; i++){\r\n            TokenList[i] = AllAuditTokens[i];\r\n    }  \r\n    \r\n    return TokenList;    \r\n        \r\n        \r\n    }\r\n}\r\n"}}}