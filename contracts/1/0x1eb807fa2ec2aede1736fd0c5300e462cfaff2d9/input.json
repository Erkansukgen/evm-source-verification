{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/UtrinCrowdSale.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-11-05\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.4;\n\n\ncontract Ownable {\n\n    address private owner;\n    \n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}\n\nlibrary SafeMath {\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n}\n\ninterface Token {\n    function tokensSoldCrowdSale(address buyer, uint256 amount) external  returns (bool success);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function burn(uint256 _value) external returns (bool success);\n}\n\ncontract UtrinCrowdSale is Ownable{\n    \n    using SafeMath for uint256;\n    \n    uint256 public priceFactor;\n    uint256 public totalSold;\n    address public tokenAddress;\n    uint256 public startTime =  1611054000;                                     //GMT Tuesday 19 January 2021 11:00:00\n    uint256 public endTime =    1611572400;                                     //GMT Monday 25 January 2021 11:00:00\n    \n    uint256 public minimumBuyAmount = 10 ** 17;                                 //Set to 0.1 ETH.\n    address payable public walletAddress;\n    event TokensSold(address indexed to, uint256 amount);\n    \n    constructor() {\n        priceFactor = uint256(1500);                                            //1 ETH = 1500 Utrin.   \n        walletAddress = 0x22bAF3bF140928201962dD1a01A63EE158BcC616;             \n        tokenAddress = address(0x0);\n    }\n    \n    receive() external payable {\n        buy();\n    }\n    \n    function setToken(address _tokenAddress) onlyOwner public {\n        tokenAddress = _tokenAddress;\n    }\n    \n    function buy() public payable {\n        require((block.timestamp > startTime ) && (block.timestamp < endTime)  , \"UTRIN crowdsale is not active\");\n        uint256 weiValue = msg.value;\n        require(weiValue >= minimumBuyAmount, \"Minimum amount is 0.1 eth\");\n        uint256 amount = weiValue.mul(priceFactor);\n        Token token = Token(tokenAddress);\n        require(walletAddress.send(weiValue));\n        require(token.tokensSoldCrowdSale(msg.sender, amount));\n        totalSold += amount;\n        emit TokensSold(msg.sender, amount);\n    }\n    \n    function burnUnsold() onlyOwner public {\n        require((block.timestamp > endTime), \"UTRIN crowdsale is still active\");\n        Token token = Token(tokenAddress);\n        uint256 amount = token.balanceOf(address(this));\n        token.burn(amount);\n    }\n    \n}\n"
    }
  }
}