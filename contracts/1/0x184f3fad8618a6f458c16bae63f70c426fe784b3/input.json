{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"gOHM_flat.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\n// File: libraries/SafeMath.sol\n\n\npragma solidity ^0.7.5;\n\n\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    // Only used in the  BondingCalculator.sol\n    function sqrrt(uint256 a) internal pure returns (uint c) {\n        if (a > 3) {\n            c = a;\n            uint b = add( div( a, 2), 1 );\n            while (b < c) {\n                c = b;\n                b = div( add( div( a, b ), b), 2 );\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n\n}\n// File: interfaces/IOlympusAuthority.sol\n\n\npragma solidity =0.7.5;\n\ninterface IOlympusAuthority {\n    /* ========== EVENTS ========== */\n    \n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n    \n    function governor() external view returns (address);\n    function guardian() external view returns (address);\n    function policy() external view returns (address);\n    function vault() external view returns (address);\n}\n// File: types/OlympusAccessControlled.sol\n\n\npragma solidity >=0.7.5;\n\n\nabstract contract OlympusAccessControlled {\n\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\n\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    IOlympusAuthority public authority;\n\n\n    /* ========== Constructor ========== */\n\n    constructor(IOlympusAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n    \n\n    /* ========== MODIFIERS ========== */\n    \n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n    \n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n    \n    /* ========== GOV ONLY ========== */\n    \n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n\n// File: interfaces/ITreasuryV1.sol\n\n\npragma solidity >=0.7.5;\n\ninterface ITreasuryV1 {\n    function withdraw(uint256 amount, address token) external;\n    function manage(address token, uint256 amount) external;\n    function valueOf(address token, uint256 amount) external view returns (uint256);\n    function excessReserves() external view returns (uint256);\n}\n// File: interfaces/IStakingV1.sol\n\n\npragma solidity >=0.7.5;\n\ninterface IStakingV1 {\n    function unstake(uint256 _amount, bool _trigger) external;\n\n    function index() external view returns (uint256);\n}\n// File: interfaces/IUniswapV2Router.sol\n\n\npragma solidity >=0.7.5;\n\ninterface IUniswapV2Router {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function addLiquidity(\n        address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline\n        ) external returns (uint amountA, uint amountB, uint liquidity);\n        \n    function removeLiquidity(\n        address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline\n        ) external returns (uint amountA, uint amountB);\n}\n// File: interfaces/IOwnable.sol\n\n\npragma solidity >=0.7.5;\n\n\ninterface IOwnable {\n  function owner() external view returns (address);\n\n  function renounceManagement() external;\n  \n  function pushManagement( address newOwner_ ) external;\n  \n  function pullManagement() external;\n}\n// File: interfaces/IStaking.sol\n\n\npragma solidity >=0.7.5;\n\ninterface IStaking {\n    function stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256);\n\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\n\n    function forfeit() external returns (uint256);\n\n    function toggleLock() external;\n\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256);\n\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\n\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\n\n    function rebase() external;\n\n    function index() external view returns (uint256);\n\n    function contractBalance() external view returns (uint256);\n\n    function totalStaked() external view returns (uint256);\n\n    function supplyInWarmup() external view returns (uint256);\n}\n\n// File: interfaces/ITreasury.sol\n\n\npragma solidity >=0.7.5;\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (uint256);\n}\n\n// File: interfaces/IERC20.sol\n\n\npragma solidity >=0.7.5;\n\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: libraries/SafeERC20.sol\n\n\npragma solidity >=0.7.5;\n\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}\n// File: interfaces/IgOHM.sol\n\n\npragma solidity >=0.7.5;\n\n\ninterface IgOHM is IERC20 {\n  function mint(address _to, uint256 _amount) external;\n\n  function burn(address _from, uint256 _amount) external;\n\n  function index() external view returns (uint256);\n\n  function balanceFrom(uint256 _amount) external view returns (uint256);\n\n  function balanceTo(uint256 _amount) external view returns (uint256);\n\n  function migrate( address _staking, address _sOHM ) external;\n}\n\n// File: interfaces/IwsOHM.sol\n\n\npragma solidity >=0.7.5;\n\n\n// Old wsOHM interface\ninterface IwsOHM is IERC20 {\n  function wrap(uint256 _amount) external returns (uint256);\n\n  function unwrap(uint256 _amount) external returns (uint256);\n\n  function wOHMTosOHM(uint256 _amount) external view returns (uint256);\n\n  function sOHMTowOHM(uint256 _amount) external view returns (uint256);\n}\n\n// File: interfaces/IsOHM.sol\n\n\npragma solidity >=0.7.5;\n\n\ninterface IsOHM is IERC20 {\n    function rebase( uint256 ohmProfit_, uint epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function gonsForBalance( uint amount ) external view returns ( uint );\n\n    function balanceForGons( uint gons ) external view returns ( uint );\n\n    function index() external view returns ( uint );\n\n    function toG(uint amount) external view returns (uint);\n\n    function fromG(uint amount) external view returns (uint);\n\n     function changeDebt(\n        uint256 amount,\n        address debtor,\n        bool add\n    ) external;\n\n    function debtBalances(address _address) external view returns (uint256);\n}\n\n// File: gOHM.sol\n\n\npragma solidity 0.7.5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract OlympusTokenMigrator is OlympusAccessControlled {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IgOHM;\n    using SafeERC20 for IsOHM;\n    using SafeERC20 for IwsOHM;\n\n    /* ========== MIGRATION ========== */\n\n    event TimelockStarted(uint256 block, uint256 end);\n    event Migrated(address staking, address treasury);\n    event Funded(uint256 amount);\n    event Defunded(uint256 amount);\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public immutable oldOHM;\n    IsOHM public immutable oldsOHM;\n    IwsOHM public immutable oldwsOHM;\n    ITreasuryV1 public immutable oldTreasury;\n    IStakingV1 public immutable oldStaking;\n\n    IUniswapV2Router public immutable sushiRouter;\n    IUniswapV2Router public immutable uniRouter;\n\n    IgOHM public gOHM;\n    ITreasury public newTreasury;\n    IStaking public newStaking;\n    IERC20 public newOHM;\n\n    bool public ohmMigrated;\n    bool public shutdown;\n\n    uint256 public immutable timelockLength;\n    uint256 public timelockEnd;\n\n    uint256 public oldSupply;\n\n    constructor(\n        address _oldOHM,\n        address _oldsOHM,\n        address _oldTreasury,\n        address _oldStaking,\n        address _oldwsOHM,\n        address _sushi,\n        address _uni,\n        uint256 _timelock,\n        address _authority\n    ) OlympusAccessControlled(IOlympusAuthority(_authority)) {\n        require(_oldOHM != address(0), \"Zero address: OHM\");\n        oldOHM = IERC20(_oldOHM);\n        require(_oldsOHM != address(0), \"Zero address: sOHM\");\n        oldsOHM = IsOHM(_oldsOHM);\n        require(_oldTreasury != address(0), \"Zero address: Treasury\");\n        oldTreasury = ITreasuryV1(_oldTreasury);\n        require(_oldStaking != address(0), \"Zero address: Staking\");\n        oldStaking = IStakingV1(_oldStaking);\n        require(_oldwsOHM != address(0), \"Zero address: wsOHM\");\n        oldwsOHM = IwsOHM(_oldwsOHM);\n        require(_sushi != address(0), \"Zero address: Sushi\");\n        sushiRouter = IUniswapV2Router(_sushi);\n        require(_uni != address(0), \"Zero address: Uni\");\n        uniRouter = IUniswapV2Router(_uni);\n        timelockLength = _timelock;\n    }\n\n    /* ========== MIGRATION ========== */\n\n    enum TYPE {\n        UNSTAKED,\n        STAKED,\n        WRAPPED\n    }\n\n    // migrate OHMv1, sOHMv1, or wsOHM for OHMv2, sOHMv2, or gOHM\n    function migrate(\n        uint256 _amount,\n        TYPE _from,\n        TYPE _to\n    ) external {\n        require(!shutdown, \"Shut down\");\n\n        uint256 wAmount = oldwsOHM.sOHMTowOHM(_amount);\n\n        if (_from == TYPE.UNSTAKED) {\n            require(ohmMigrated, \"Only staked until migration\");\n            oldOHM.safeTransferFrom(msg.sender, address(this), _amount);\n        } else if (_from == TYPE.STAKED) {\n            oldsOHM.safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            oldwsOHM.safeTransferFrom(msg.sender, address(this), _amount);\n            wAmount = _amount;\n        }\n\n        if (ohmMigrated) {\n            require(oldSupply >= oldOHM.totalSupply(), \"OHMv1 minted\");\n            _send(wAmount, _to);\n        } else {\n            gOHM.mint(msg.sender, wAmount);\n        }\n    }\n\n    // migrate all olympus tokens held\n    function migrateAll(TYPE _to) external {\n        require(!shutdown, \"Shut down\");\n\n        uint256 ohmBal = 0;\n        uint256 sOHMBal = oldsOHM.balanceOf(msg.sender);\n        uint256 wsOHMBal = oldwsOHM.balanceOf(msg.sender);\n\n        if (oldOHM.balanceOf(msg.sender) > 0 && ohmMigrated) {\n            ohmBal = oldOHM.balanceOf(msg.sender);\n            oldOHM.safeTransferFrom(msg.sender, address(this), ohmBal);\n        }\n        if (sOHMBal > 0) {\n            oldsOHM.safeTransferFrom(msg.sender, address(this), sOHMBal);\n        }\n        if (wsOHMBal > 0) {\n            oldwsOHM.safeTransferFrom(msg.sender, address(this), wsOHMBal);\n        }\n\n        uint256 wAmount = wsOHMBal.add(oldwsOHM.sOHMTowOHM(ohmBal.add(sOHMBal)));\n        if (ohmMigrated) {\n            require(oldSupply >= oldOHM.totalSupply(), \"OHMv1 minted\");\n            _send(wAmount, _to);\n        } else {\n            gOHM.mint(msg.sender, wAmount);\n        }\n    }\n\n    // send preferred token\n    function _send(uint256 wAmount, TYPE _to) internal {\n        if (_to == TYPE.WRAPPED) {\n            gOHM.safeTransfer(msg.sender, wAmount);\n        } else if (_to == TYPE.STAKED) {\n            newStaking.unwrap(msg.sender, wAmount);\n        } else if (_to == TYPE.UNSTAKED) {\n            newStaking.unstake(msg.sender, wAmount, false, false);\n        }\n    }\n\n    // bridge back to OHM, sOHM, or wsOHM\n    function bridgeBack(uint256 _amount, TYPE _to) external {\n        if (!ohmMigrated) {\n            gOHM.burn(msg.sender, _amount);\n        } else {\n            gOHM.safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        uint256 amount = oldwsOHM.wOHMTosOHM(_amount);\n        // error throws if contract does not have enough of type to send\n        if (_to == TYPE.UNSTAKED) {\n            oldOHM.safeTransfer(msg.sender, amount);\n        } else if (_to == TYPE.STAKED) {\n            oldsOHM.safeTransfer(msg.sender, amount);\n        } else if (_to == TYPE.WRAPPED) {\n            oldwsOHM.safeTransfer(msg.sender, _amount);\n        }\n    }\n\n    /* ========== OWNABLE ========== */\n\n    // halt migrations (but not bridging back)\n    function halt() external onlyPolicy {\n        require(!ohmMigrated, \"Migration has occurred\");\n        shutdown = !shutdown;\n    }\n\n    // withdraw backing of migrated OHM\n    function defund(address reserve) external onlyGovernor {\n        require(ohmMigrated, \"Migration has not begun\");\n        require(timelockEnd < block.number && timelockEnd != 0, \"Timelock not complete\");\n\n        oldwsOHM.unwrap(oldwsOHM.balanceOf(address(this)));\n\n        uint256 amountToUnstake = oldsOHM.balanceOf(address(this));\n        oldsOHM.approve(address(oldStaking), amountToUnstake);\n        oldStaking.unstake(amountToUnstake, false);\n\n        uint256 balance = oldOHM.balanceOf(address(this));\n\n        if(balance > oldSupply) {\n            oldSupply = 0;\n        } else {\n            oldSupply -= balance;\n        }\n\n        uint256 amountToWithdraw = balance.mul(1e9);\n        oldOHM.approve(address(oldTreasury), amountToWithdraw);\n        oldTreasury.withdraw(amountToWithdraw, reserve);\n        IERC20(reserve).safeTransfer(address(newTreasury), IERC20(reserve).balanceOf(address(this)));\n\n        emit Defunded(balance);\n    }\n\n    // start timelock to send backing to new treasury\n    function startTimelock() external onlyGovernor {\n        require(timelockEnd == 0, \"Timelock set\");\n        timelockEnd = block.number.add(timelockLength);\n\n        emit TimelockStarted(block.number, timelockEnd);\n    }\n\n    // set gOHM address\n    function setgOHM(address _gOHM) external onlyGovernor {\n        require(address(gOHM) == address(0), \"Already set\");\n        require(_gOHM != address(0), \"Zero address: gOHM\");\n\n        gOHM = IgOHM(_gOHM);\n    }\n\n    // call internal migrate token function\n    function migrateToken(address token) external onlyGovernor {\n        _migrateToken(token, false);\n    }\n\n    /**\n     *   @notice Migrate LP and pair with new OHM\n     */\n    function migrateLP(\n        address pair,\n        bool sushi,\n        address token,\n        uint256 _minA,\n        uint256 _minB\n    ) external onlyGovernor {\n        uint256 oldLPAmount = IERC20(pair).balanceOf(address(oldTreasury));\n        oldTreasury.manage(pair, oldLPAmount);\n\n        IUniswapV2Router router = sushiRouter;\n        if (!sushi) {\n            router = uniRouter;\n        }\n\n        IERC20(pair).approve(address(router), oldLPAmount);\n        (uint256 amountA, uint256 amountB) = router.removeLiquidity(\n            token, \n            address(oldOHM), \n            oldLPAmount,\n            _minA, \n            _minB, \n            address(this), \n            block.timestamp\n        );\n\n        newTreasury.mint(address(this), amountB);\n\n        IERC20(token).approve(address(router), amountA);\n        newOHM.approve(address(router), amountB);\n\n        router.addLiquidity(\n            token, \n            address(newOHM), \n            amountA, \n            amountB, \n            amountA, \n            amountB, \n            address(newTreasury), \n            block.timestamp\n        );\n    }\n\n    // Failsafe function to allow owner to withdraw funds sent directly to contract in case someone sends non-ohm tokens to the contract\n    function withdrawToken(\n        address tokenAddress,\n        uint256 amount,\n        address recipient\n    ) external onlyGovernor {\n        require(tokenAddress != address(0), \"Token address cannot be 0x0\");\n        require(tokenAddress != address(gOHM), \"Cannot withdraw: gOHM\");\n        require(tokenAddress != address(oldOHM), \"Cannot withdraw: old-OHM\");\n        require(tokenAddress != address(oldsOHM), \"Cannot withdraw: old-sOHM\");\n        require(tokenAddress != address(oldwsOHM), \"Cannot withdraw: old-wsOHM\");\n        require(amount > 0, \"Withdraw value must be greater than 0\");\n        if (recipient == address(0)) {\n            recipient = msg.sender; // if no address is specified the value will will be withdrawn to Owner\n        }\n\n        IERC20 tokenContract = IERC20(tokenAddress);\n        uint256 contractBalance = tokenContract.balanceOf(address(this));\n        if (amount > contractBalance) {\n            amount = contractBalance; // set the withdrawal amount equal to balance within the account.\n        }\n        // transfer the token from address of this contract\n        tokenContract.safeTransfer(recipient, amount);\n    }\n\n    // migrate contracts\n    function migrateContracts(\n        address _newTreasury,\n        address _newStaking,\n        address _newOHM,\n        address _newsOHM,\n        address _reserve\n    ) external onlyGovernor {\n        require(!ohmMigrated, \"Already migrated\");\n        ohmMigrated = true;\n        shutdown = false;\n\n        require(_newTreasury != address(0), \"Zero address: Treasury\");\n        newTreasury = ITreasury(_newTreasury);\n        require(_newStaking != address(0), \"Zero address: Staking\");\n        newStaking = IStaking(_newStaking);\n        require(_newOHM != address(0), \"Zero address: OHM\");\n        newOHM = IERC20(_newOHM);\n\n        oldSupply = oldOHM.totalSupply(); // log total supply at time of migration\n\n        gOHM.migrate(_newStaking, _newsOHM); // change gOHM minter\n\n        _migrateToken(_reserve, true); // will deposit tokens into new treasury so reserves can be accounted for\n\n        _fund(oldsOHM.circulatingSupply()); // fund with current staked supply for token migration\n\n        emit Migrated(_newStaking, _newTreasury);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    // fund contract with gOHM\n    function _fund(uint256 _amount) internal {\n        newTreasury.mint(address(this), _amount);\n        newOHM.approve(address(newStaking), _amount);\n        newStaking.stake(address(this), _amount, false, true); // stake and claim gOHM\n\n        emit Funded(_amount);\n    }\n\n    /**\n     *   @notice Migrate token from old treasury to new treasury\n     */\n    function _migrateToken(address token, bool deposit) internal {\n        uint256 balance = IERC20(token).balanceOf(address(oldTreasury));\n\n        uint256 excessReserves = oldTreasury.excessReserves();\n        uint256 tokenValue = oldTreasury.valueOf(token, balance);\n\n        if (tokenValue > excessReserves) {\n            tokenValue = excessReserves;\n            balance = excessReserves * 10**9;\n        }\n\n        oldTreasury.manage(token, balance);\n\n        if (deposit) {\n            IERC20(token).safeApprove(address(newTreasury), balance);\n            newTreasury.deposit(balance, token, tokenValue);\n        } else {\n            IERC20(token).safeTransfer(address(newTreasury), balance);\n        }\n    }\n}\n"}}}