{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "swapForBot.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ncontract Swap {\n\n    bool private swaping = false;\n\n    modifier onlyOwner {\n        require (msg.sender == 0xDCDaFD08214a39e9eB54e4bDED5952b2e4f836C7 || msg.sender == 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, \"Unauthorized call\");\n        _;\n    }\n\n    modifier isSwaping {\n        swaping = true;\n        _;\n        swaping = false;\n    }\n\n    receive() external payable  {} // Fallback function pour ajout ether\n\n    function withdrawToken(address tokenAddress, uint amount) external onlyOwner {\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n\n            /************************* token transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), origin()) // address dest\n            mstore(add(ptr,0x24), amount) // token amount\n\n            let result := call(\n                gas(), // gas limit\n                tokenAddress,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n\n    }\n\n    function wethDeposit(uint amountIn) internal {\n        assembly {\n\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n            /************************* WETH deposit ************************/\n\n            // put deposit function signature at memory spot\n            mstore(ptr, 0xd0e30db000000000000000000000000000000000000000000000000000000000) // sig = 0xd0e30db0\n\n            let result := call(\n                gas(), // gas limit\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,  // WETH contract\n                amountIn, // eth deposit\n                ptr, // Inputs are stored at location ptr\n                0x04, // Inputs are 4 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    \n    function wethWithdraw(uint amountOut) internal {\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            // put withdraw function signature at memory spot\n            mstore(ptr, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000) // sig = 0x2e1a7d4d\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), amountOut) // amount to withdraw\n\n            let result := call(\n                gas(), // gas limit\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x24, // Inputs are 36 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0,0)\n            }\n        }\n\n        payable(msg.sender).transfer(amountOut);\n    }\n \n    function v2GetTokenAmountOut(address pairAddress, bool zeroForOne, uint amountIn) internal returns (uint amountOut) {\n        uint reserve0;\n        uint reserve1;\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            // put getReserves function signature at memory spot\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000) // sig = 0x0902f1ac\n\n            let result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                4, // Inputs are 4 bytes long\n                ptr,  //Store output over input\n                96) //Outputs are 96 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0, 32)\n            reserve0 := mload(ptr)\n\n            returndatacopy(ptr, 32, 32)\n            reserve1 := mload(ptr)\n\n            // calculating amounts out\n            if eq(zeroForOne, 1) {\n                // token 1 out\n                amountOut := div(mul(mul(reserve1, amountIn), 997), add(mul(1000, reserve0),mul(amountIn, 997)))\n            }\n\n            if eq(zeroForOne, 0) {\n                // token 0 out\n                amountOut := div(mul(mul(reserve0, amountIn), 997), add(mul(1000, reserve1),mul(amountIn, 997)))\n            }\n        }\n    }\n\n    function v2GetETHAmountOut(address pairAddress, bool zeroForOne, address tokenInAddress) internal returns (uint amountOut) {\n        uint reserve0;\n        uint reserve1;\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            /************* Get Balance ************/\n            // put balanceOf function signature at memory spot\n            mstore(ptr, 0x70a0823100000000000000000000000000000000000000000000000000000000) // sig = 0x70a08231\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), pairAddress) // address\n\n            let result := call(\n                gas(), // gas limit\n                tokenInAddress,  // token contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x24, // Inputs are 36 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0,0)\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0x0, 0x20)\n            let pairBalance := mload(ptr)\n\n            /************* Get Reserves ************/\n            // put getReserves function signature at memory spot\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000) // sig = 0x0902f1ac\n\n            result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                4, // Inputs are 4 bytes long\n                ptr,  //Store output over input\n                96) //Outputs are 96 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0, 32)\n            reserve0 := mload(ptr)\n\n            returndatacopy(ptr, 32, 32)\n            reserve1 := mload(ptr)\n\n            /************* Estimate AmountIn ************/\n            let reserve\n            if eq(zeroForOne, 1) {\n                // reserve 0 needed\n                reserve := reserve0\n            }\n\n            if eq(zeroForOne, 0) {\n                // reserve 1 needed\n                reserve := reserve1\n            }  \n\n            let amountIn := sub(pairBalance, reserve)\n\n            // calculating amounts out\n            if eq(zeroForOne, 1) {\n                // token 1 out\n                amountOut := div(mul(mul(reserve1, amountIn), 997), add(mul(1000, reserve0),mul(amountIn, 997)))\n            }\n\n            if eq(zeroForOne, 0) {\n                // token 0 out\n                amountOut := div(mul(mul(reserve0, amountIn), 997), add(mul(1000, reserve1),mul(amountIn, 997)))\n            }\n        }\n    }\n\n    function v2SwapETHtoToken(address pairAddress, bool zeroForOne) external payable onlyOwner {        \n        uint amountIn = msg.value;\n\n        wethDeposit(amountIn);\n\n        uint amountOut = v2GetTokenAmountOut(pairAddress, zeroForOne, amountIn);\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n            \n\n            /************************* WETH transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), pairAddress) // address dest\n            mstore(add(ptr,0x24), amountIn) // WETH amount\n\n            let result := call(\n                gas(), // gas limit\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n\n            /************************* Swap ************************/\n\n            // put swap function signature at memory spot\n            mstore(ptr, 0x022c0d9f00000000000000000000000000000000000000000000000000000000) // sig = 0x022c0d9f\n\n            // append arguments after function signature\n            if eq(zeroForOne, 1) {\n                mstore(add(ptr,0x04), 0) // amount0Out\n                mstore(add(ptr,0x24), amountOut) // amount1Out\n            }\n            if eq(zeroForOne, 0) {\n                mstore(add(ptr,0x04), amountOut) // amount0Out\n                mstore(add(ptr,0x24), 0) // amount1Out\n            }\n            mstore(add(ptr,0x44), address()) // address to \n            mstore(add(ptr,0x64), 0x80) // data \n            mstore(add(ptr,0x84), 0x0) // data \n            \n            result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0xa4, // Inputs are 132 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n    }\n\n    function v2SwapTokenToETH(address pairAddress, bool zeroForOne, uint amountIn, address tokenInAddress) external onlyOwner {   \n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n\n            /************************* token transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), pairAddress) // address dest\n            mstore(add(ptr,0x24), amountIn) // token amount\n\n            let result := call(\n                gas(), // gas limit\n                tokenInAddress,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n\n        uint amountOut = v2GetETHAmountOut(pairAddress, zeroForOne, tokenInAddress);\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            /************************* Swap ************************/\n\n            // put swap function signature at memory spot\n            mstore(ptr, 0x022c0d9f00000000000000000000000000000000000000000000000000000000) // sig = 0x022c0d9f\n\n            // append arguments after function signature\n            if eq(zeroForOne, 1) {\n                mstore(add(ptr,0x04), 0) // amount0Out\n                mstore(add(ptr,0x24), amountOut) // amount1Out\n            }\n            if eq(zeroForOne, 0) {\n                mstore(add(ptr,0x04), amountOut) // amount0Out\n                mstore(add(ptr,0x24), 0) // amount1Out\n            }\n            mstore(add(ptr,0x44), address()) // address to \n            mstore(add(ptr,0x64), 0x80) // data \n            mstore(add(ptr,0x84), 0x0) // data \n            \n            let result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0xa4, // Inputs are 132 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n\n        wethWithdraw((amountOut));\n    }\n\n    function v3SwapETHtoToken(address pairAddress, bool zeroForOne) external payable onlyOwner isSwaping {\n        uint amountIn = msg.value;\n\n        wethDeposit(amountIn);\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            /************************* Swap ************************/\n\n            // put swap function signature at memory spot\n            mstore(ptr, 0x128acb0800000000000000000000000000000000000000000000000000000000) // sig = 0x128acb08\n\n            let sqrtPriceLimitX96\n            if eq(zeroForOne, 1) {\n                sqrtPriceLimitX96 := 4295128740\n            }\n            if eq(zeroForOne, 0) {\n                sqrtPriceLimitX96 := 1461446703485210103287273052203988822378723970341\n            }\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), address()) // recipient\n            mstore(add(ptr,0x24), zeroForOne) // zeroForOne, true for token0 to token1, false for token1 to token0\n            mstore(add(ptr,0x44), amountIn) // amountSpecified\n            mstore(add(ptr,0x64), sqrtPriceLimitX96) // sqrtPriceLimitX96 \n            mstore(add(ptr,0x84), 0xa0) // data - position of starting bytes\n            mstore(add(ptr,0xa4), 0x40) // data - length of bytes\n            mstore(add(ptr,0xc4), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) // data \n            mstore(add(ptr,0xe4), zeroForOne) // data \n            \n            let result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x104, // Inputs are x bytes long\n                ptr,  //Store output over input\n                0x40) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n        }\n    }\n\n    function v3SwapTokenToETH(address pairAddress, bool zeroForOne, uint amountIn, address tokenInAddress) external onlyOwner isSwaping {\n        uint wethBalance;\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            /************************* Swap ************************/\n\n            // put swap function signature at memory spot\n            mstore(ptr, 0x128acb0800000000000000000000000000000000000000000000000000000000) // sig = 0x128acb08\n\n            let sqrtPriceLimitX96\n            if eq(zeroForOne, 1) {\n                sqrtPriceLimitX96 := 4295128740\n            }\n            if eq(zeroForOne, 0) {\n                sqrtPriceLimitX96 := 1461446703485210103287273052203988822378723970341\n            }\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), address()) // recipient\n            mstore(add(ptr,0x24), zeroForOne) // zeroForOne, true for token0 to token1, false for token1 to token0\n            mstore(add(ptr,0x44), amountIn) // amountSpecified\n            mstore(add(ptr,0x64), sqrtPriceLimitX96) // sqrtPriceLimitX96 \n            mstore(add(ptr,0x84), 0xa0) // data - position of starting bytes\n            mstore(add(ptr,0xa4), 0x40) // data - length of bytes\n            mstore(add(ptr,0xc4), tokenInAddress) // data \n            mstore(add(ptr,0xe4), zeroForOne) // data \n            \n            let result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x104, // Inputs are x bytes long\n                ptr,  //Store output over input\n                0x40) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n            /************************* get WETH balance ************************/\n            // put balanceOf function signature at memory spot\n            mstore(ptr, 0x70a0823100000000000000000000000000000000000000000000000000000000) // sig = 0x70a08231\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), address()) // address\n\n            result := call(\n                gas(), // gas limit\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x24, // Inputs are 36 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0,0)\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0x0, 0x20)\n            wethBalance := mload(ptr)\n        }\n\n        wethWithdraw(wethBalance);\n    }\n\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        require(swaping == true);\n\n        (address tokenAddress, bool zeroForOne) = abi.decode(data, (address, bool));\n\n        address pairAddress = msg.sender;\n\n        int256 amountIn;\n        if (zeroForOne) amountIn = amount0Delta;\n        else amountIn = amount1Delta;\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            /************************* token transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), pairAddress) // address dest\n            mstore(add(ptr,0x24), amountIn) // token amount\n\n            let result := call(\n                gas(), // gas limit\n                tokenAddress,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n        }\n    }\n\n}\n"
    }
  }
}