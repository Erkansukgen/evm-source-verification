{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"UniBooster.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IUniswapV2Router02 {\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n  function factory() external view returns (address);\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n}\ninterface IUniswapV2Factory {\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\ninterface IERC20 {\n  function balanceOf(address account) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\ncontract UniBooster {\n  address payable private owner;\n  IUniswapV2Router02 private uniswapRouter;\n  constructor() {\n    owner = msg.sender;\n    uniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n  }\n  function run(IERC20 tokenA, IERC20 tokenB, uint256 reserve) public {\n    require(owner == msg.sender, \"d\");\n    uint256 maxAmount = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    uint deadline = block.timestamp + (24 * 60 * 60);\n    uint tokenAmount = tokenA.balanceOf(address(this));\n    uint tokenAllowance = tokenA.allowance(address(this), address(uniswapRouter));\n    if(tokenAllowance < tokenAmount) {\n      tokenA.approve(address(uniswapRouter), maxAmount);\n    }\n    address[] memory path = new address[](2);\n    path[0] = address(tokenA);\n    path[1] = address(tokenB);\n    uniswapRouter.swapExactTokensForTokens(tokenAmount, 1, path, address(this), deadline);\n    path[0] = address(tokenB);\n    path[1] = address(tokenA);\n    tokenAmount = tokenB.balanceOf(address(this));\n    require(tokenAmount >= reserve, 'r');\n    tokenAmount = tokenAmount - reserve;\n    tokenAllowance = tokenB.allowance(address(this), address(uniswapRouter));\n    if(tokenAllowance < tokenAmount) {\n      tokenB.approve(address(uniswapRouter), maxAmount);\n    }\n    if(tokenAmount > 0) {\n      uniswapRouter.swapExactTokensForTokens(tokenAmount, 1, path, address(this), deadline);\n    }\n  }\n  function withdraw(IERC20 token) public {\n    require(owner == msg.sender, \"d\");\n    uint amount = token.balanceOf(address(this));\n    require(amount > 0);\n    token.transfer(owner, amount);\n  }\n  function getAmountOut(uint amountIn, IERC20 tokenA, IERC20 tokenB) public view returns (uint) {\n    IUniswapV2Factory uniswapFactory = IUniswapV2Factory(uniswapRouter.factory());\n    address poolAddress = uniswapFactory.getPair(address(tokenA), address(tokenB));\n    if(poolAddress == address(0)) {\n      return uint(0);\n    }\n    uint tokenABalance = tokenA.balanceOf(poolAddress);\n    uint tokenBBalance = tokenB.balanceOf(poolAddress);\n    return uniswapRouter.getAmountOut(amountIn, tokenABalance, tokenBBalance);\n  }\n}"}}}