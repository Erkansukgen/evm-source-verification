{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "solidity/WebContent/merge/IDO_NEW.sol": {
      "content": "// SPDX-License-Identifier: GPLv3\n\npragma solidity ^0.8.0;\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint c = a - b;\n        return c;\n    }\n    function mul(uint a, uint b) internal pure returns (uint) {\n        if (a == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint c = a / b;\n        return c;\n    }\n}\ninterface ERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function decimals() external view returns (uint8);\n}\n\nabstract contract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract Ownable {\n    address owner;\n    constructor() {\n        owner = msg.sender;\n    }\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"address is null\");\n        owner = newOwner;\n    }\n}\n\ncontract TokenIDO is Ownable, ReentrancyGuard {\n    uint PRECISION_FACTOR;\n    event ChangeUsdtToTokenRate(uint before, uint afters);\n    event ChangeExFeePercent(uint before, uint afters);\n    using SafeMath for uint;\n    ERC20 token;\n    ERC20 usdt;\n    ERC20 airdrop;\n    uint usdt_to_token_rate = 552631578947368000;\n    uint ex_fee_percent     = 0;\n    uint total_usdt_ex_in;\n    uint total_token_fee;\n    mapping(address => bool) public whitelistusers;\n    constructor(address _token_addr, address _usdt_addr, address _airdrop_addr) {\n        token = ERC20(_token_addr);\n        usdt  = ERC20(_usdt_addr);\n        airdrop = ERC20(_airdrop_addr);\n        PRECISION_FACTOR = 10 ** (18 - usdt.decimals());\n    }\n    receive() external payable {}\n    function usdt_to_token(uint amount) public nonReentrant returns (bool)  {\n        uint usdt_amount = amount.div(PRECISION_FACTOR);\n        require(usdt.balanceOf(msg.sender) >= usdt_amount, \"Insufficient token balance\");\n        require(usdt.allowance(msg.sender, address(this)) >= usdt_amount, \"Insufficient approve amount\");\n        uint token_amount = amount.mul(usdt_to_token_rate).div(1 ether);\n        if (whitelistusers[msg.sender]) token_amount = token_amount.mul(11111).div(10000);\n        uint token_fee = token_amount.mul(ex_fee_percent).div(100);\n        token_amount = token_amount.sub(token_fee);\n        total_usdt_ex_in = total_usdt_ex_in.add(amount);\n        total_token_fee = total_token_fee.add(token_fee);\n        usdt.transferFrom(msg.sender, address(this), usdt_amount);\n        token.transfer(msg.sender, token_amount);\n        airdrop.transfer(msg.sender, token_amount);\n        return true;\n    }\n    function query_account(address addr) public view returns(uint, uint, uint, uint, uint, uint, uint) {\n        return (addr.balance,\n                token.balanceOf(addr),\n                usdt.balanceOf(addr).mul(PRECISION_FACTOR),\n                token.allowance(addr, address(this)),\n                usdt.allowance(addr, address(this)).mul(PRECISION_FACTOR),\n                usdt_to_token_rate,\n                ex_fee_percent);\n    }\n    function query_summary() public view returns(uint, uint, uint, uint) {\n        return (token.balanceOf(address(this)),\n                usdt.balanceOf(address(this)).mul(PRECISION_FACTOR),\n                total_usdt_ex_in,\n                total_token_fee);\n    }\n    function set_usdt_to_token_rate(uint new_rate) public onlyOwner returns (bool) {\n        require(new_rate > 0, \"need greater than zero\");\n        require(usdt_to_token_rate != new_rate, \"need new rate\");\n        emit ChangeUsdtToTokenRate(usdt_to_token_rate, new_rate);\n        usdt_to_token_rate = new_rate;\n        return true;\n    }\n    function set_ex_fee_percent(uint new_fee_percent) public onlyOwner returns (bool) {\n        require(new_fee_percent >= 0, \"Can't be less than zero\");\n        require(ex_fee_percent != new_fee_percent, \"need new fee percent\");\n        emit ChangeExFeePercent(ex_fee_percent, new_fee_percent);\n        ex_fee_percent = new_fee_percent;\n        return true;\n    }\n    function sys_clear() public onlyOwner {\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n        usdt.transfer(msg.sender, usdt.balanceOf(address(this)));\n        airdrop.transfer(msg.sender, airdrop.balanceOf(address(this)));\n        selfdestruct(payable(msg.sender));\n    }\n    function setWhiteListUser(address addr, bool isWhiteListUser) public onlyOwner() {\n        whitelistusers[addr] = isWhiteListUser;\n    }\n    function otherLinesTokenTransfer(address addr, uint amount) public onlyOwner() {\n        token.transfer(addr, amount);\n        airdrop.transfer(addr, amount);\n    }\n}"
    }
  }
}