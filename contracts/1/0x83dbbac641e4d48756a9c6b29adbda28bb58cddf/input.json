{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "mainnetSigner.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.11;\r\n\r\ncontract mainnetSigner{\r\n\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function getOwner() public view returns(address){\r\n        return owner;\r\n    }\r\n\r\n    function setOwner(address _owner) public{\r\n        require(msg.sender == owner,\"can only be called by owner\");\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n   * @notice Verifies that the signer is the owner of the signing contract.\r\n   */\r\n  function isValidSignature(\r\n    bytes32 _hash,\r\n    bytes calldata _signature\r\n  ) external view returns (bytes4) {\r\n    // Validate signatures\r\n    if (recoverSigner(_hash, _signature) == owner) {\r\n      return 0x1626ba7e;\r\n    } else {\r\n      return 0xffffffff;\r\n    }\r\n  }\r\n\r\n /**\r\n   * @notice Recover the signer of hash, assuming it's an EOA account\r\n   * @dev Only for EthSign signatures\r\n   * @param _ethSignedMessageHash       Hash of message that was signed\r\n   * @param _signature  Signature encoded as (bytes32 r, bytes32 s, uint8 v)\r\n   */\r\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig)\r\n        public\r\n        pure\r\n        returns (\r\n            bytes32 r,\r\n            bytes32 s,\r\n            uint8 v\r\n        )\r\n    {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            /*\r\n            First 32 bytes stores the length of the signature\r\n\r\n            add(sig, 32) = pointer of sig + 32\r\n            effectively, skips first 32 bytes of signature\r\n\r\n            mload(p) loads next 32 bytes starting at the memory address p into memory\r\n            */\r\n\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // implicitly return (r, s, v)\r\n    }\r\n}"
    }
  }
}