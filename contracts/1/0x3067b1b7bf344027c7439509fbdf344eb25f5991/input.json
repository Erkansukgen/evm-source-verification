{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SimpleMultiCall.sol": {
      "content": "pragma solidity >=0.7.0 <0.8.0;\r\n\r\n/**\r\n    * @notice this interface is taken from indexed-core commit hash dae7f231d0f58bfc0993f6c01199cd6b74b01895\r\n */\r\ninterface IndexPoolI {\r\n  function getDenormalizedWeight(address token) external view returns (uint256);\r\n  function getBalance(address token) external view returns (uint256);\r\n  function getUsedBalance(address token) external view returns (uint256);\r\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256);    \r\n}\r\n\r\ninterface ERC20I {\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n/**\r\n    * @notice SimpleMultiCall is a multicall-like contract for reading IndexPool information\r\n    * @notice it is intended to minimize the need for manual abi encoding/decoding\r\n    * @notice and leverage Golang's abigen to do the heavy lifting\r\n */\r\ncontract SimpleMultiCall {\r\n\r\n    // index pool methods\r\n\r\n    function getDenormalizedWeights(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory weights = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            weights[i] = IndexPoolI(poolAddress).getDenormalizedWeight(tokens[i]);\r\n        }\r\n        return (tokens, weights);\r\n    }\r\n\r\n    function getBalances(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory balances = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            balances[i] = IndexPoolI(poolAddress).getBalance(tokens[i]);\r\n        }\r\n        return (tokens, balances);\r\n    }\r\n\r\n    function getUsedBalances(\r\n        address poolAddress,\r\n        address[] memory tokens\r\n    ) \r\n        public \r\n        view\r\n        returns (address[] memory, uint256[] memory) \r\n    {\r\n        uint256[] memory balances = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            balances[i] = IndexPoolI(poolAddress).getUsedBalance(tokens[i]);\r\n        }\r\n        return (tokens, balances);\r\n    }\r\n\r\n    function getSpotPrices(\r\n        address poolAddress,\r\n        address[] memory inTokens,\r\n        address[] memory outTokens\r\n    )\r\n        public\r\n        view \r\n        returns (address[] memory, address[] memory, uint256[] memory)\r\n    {\r\n        require(inTokens.length == outTokens.length);\r\n        uint256[] memory prices = new uint256[](inTokens.length);\r\n        for (uint256 i = 0; i < inTokens.length; i++) {\r\n            prices[i] = IndexPoolI(poolAddress).getSpotPrice(inTokens[i], outTokens[i]);\r\n        }\r\n        return (inTokens, outTokens, prices);\r\n    }\r\n\r\n    // erc20 methods\r\n\r\n    function getTotalSupplies(\r\n        address[] memory tokens\r\n    )\r\n        public\r\n        view\r\n        returns (address[] memory, uint256[] memory)\r\n    {\r\n        uint256[] memory supplies = new uint256[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            supplies[i] = ERC20I(tokens[i]).totalSupply();\r\n        }\r\n        return (tokens, supplies);\r\n    }\r\n}"
    }
  }
}