{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"bundle.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\n// import \"hardhat/console.sol\";\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint) external;\n}\n\n// This contract simply calls multiple targets sequentially, ensuring WETH balance before and after\ncontract BundleExecutor {\n    address private immutable owner;\n    IWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    // modifier onlyOwner() {\n    //     require(msg.sender == owner);\n    //     _;\n    // }\n\n    constructor() public payable {\n        owner = msg.sender;\n        if (msg.value > 0) {\n            WETH.deposit{value: msg.value}();\n        }\n    }\n\n    receive() external payable {\n    }\n\n    // function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n    //         if (_i == 0) {\n    //             return \"0\";\n    //         }\n    //         uint j = _i;\n    //         uint len;\n    //         while (j != 0) {\n    //             len++;\n    //             j /= 10;\n    //         }\n    //         bytes memory bstr = new bytes(len);\n    //         uint k = len;\n    //         while (_i != 0) {\n    //             k = k-1;\n    //             uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n    //             bytes1 b1 = bytes1(temp);\n    //             bstr[k] = b1;\n    //             _i /= 10;\n    //         }\n    //         return string(bstr);\n    //     }\n    \n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return 'Transaction reverted silently';\n    \n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function _runCalls(bytes calldata _data) internal {\n        (address[] memory _targets, bytes[] memory _payloads) = abi.decode(_data, (address[], bytes[]));\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            // console.log(\"Callback call sttarted: \", i, _targets[i]);\n            (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\n            require(_success, _getRevertMsg(_response)); _response;\n            // console.log(\"Callback call completed: \", i, _targets[i]);\n        }\n    }\n\n    // AAVE\n    function executeOperation(address[] calldata, uint256[] calldata, uint256[] calldata, address, bytes calldata _data) external returns (bool) {\n        require (tx.origin == owner, \"U\");\n        _runCalls(_data);\n        \n        return true;\n    }\n\n    //https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/vault/contracts/FlashLoans.sol\n    //        IERC20[] memory tokens,\n    // address[] memory _targets\n    // uint256[] memory amounts,\n    // uint256[] memory feeAmounts\n    // bytes memory userData\n    // recipient.receiveFlashLoan(tokens, amounts, feeAmounts, userData);\n    function receiveFlashLoan(address[] calldata, uint256[] calldata , uint256[] calldata , bytes calldata _data) external {\n        require (tx.origin == owner, \"U\");\n        _runCalls(_data);\n    }\n\n    function uniswapV3FlashCallback(uint, uint, bytes calldata _data) external {\n        require (tx.origin == owner, \"U\");\n        _runCalls(_data);\n\n        // (address[] memory _targets, bytes[] memory _payloads) = abi.decode(_data, (address[], bytes[]));\n\n        // for (uint256 i = 0; i < _targets.length; i++) {\n        //     (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\n        //     require(_success, _getRevertMsg(_response)); _response;\n        // }\n    }\n\n    function uniswapV2Call(address, uint, uint, bytes calldata _data) external {\n        require (tx.origin == owner, \"U\");\n        _runCalls(_data);\n        // (address[] memory _targets, bytes[] memory _payloads) = abi.decode(_data, (address[], bytes[]));\n\n        // for (uint256 i = 0; i < _targets.length; i++) {\n        //     (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\n        //     require(_success, _getRevertMsg(_response)); _response;\n        //     //console.log(\"Uniswapv2 call completed: \", i, _targets[i]);\n        // }\n    }\n\n    function start(uint256 _ethAmountToCoinbase, address[] memory _targets, bytes[] memory _payloads) external payable {\n        require(msg.sender == owner);\n        uint256 _wethBalanceBefore = WETH.balanceOf(address(this));\n        uint256 _ethBalanceBefore = address(this).balance;\n        // console.log(\"Starting WETH Balance: \", _wethBalanceBefore);\n        // console.log(\"Starting ETH Balance: \", _ethBalanceBefore);\n        for (uint256 i = 0; i < _targets.length; i++) {\n            (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\n            require(_success, _getRevertMsg(_response)); _response;\n            // console.log(\"Start call completed: \", i);\n        }\n\n        // Make sure there's profit\n        uint256 _wethBalanceAfter = WETH.balanceOf(address(this));\n        uint256 _ethBalanceAfter = address(this).balance;\n        // console.log(\"Ending WETH Balance: \", _wethBalanceAfter);\n        // console.log(\"Ending ETH Balance: \", _ethBalanceAfter);\n        // console.log(\"TO MINER: \", _ethAmountToCoinbase);\n        require(_wethBalanceAfter + _ethBalanceAfter > _wethBalanceBefore + _ethBalanceBefore + _ethAmountToCoinbase, \"P\");\n        if (_ethAmountToCoinbase == 0) return;\n\n        // Make sure there's enough to pay the miners\n        if (_ethBalanceAfter < _ethAmountToCoinbase) {\n            WETH.withdraw(_ethAmountToCoinbase);\n            // console.log(\"Withdrawing Weth\");\n        }\n        // console.log(\"Paying Miner\");\n        block.coinbase.transfer(_ethAmountToCoinbase);\n    }\n\n    function c(address payable _to, uint256 _value, address[] memory _targets, bytes[] memory _payloads, bytes calldata _data) external payable returns (bytes memory) {\n        require(msg.sender == owner);\n        require(_to != address(0));\n        for (uint256 i = 0; i < _targets.length; i++) {\n            (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\n            require(_success, _getRevertMsg(_response)); _response;\n        }\n        (bool _success, bytes memory _result) = _to.call{value: _value}(_data);\n        require(_success);\n        return _result;\n    }\n}\n"}}}