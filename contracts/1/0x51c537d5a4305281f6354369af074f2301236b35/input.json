{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"presale dep.sol":{"content":"\r\n// SPDX-License-Identifier: UNLICENSED \r\npragma solidity 0.8.9;     \r\n\r\ncontract RMath {\r\n\r\n    function btoi(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return a / 10**18;\r\n    }\r\n\r\n    function bfloor(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return btoi(a) * 10**18;\r\n    }\r\n\r\n    function badd(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        (uint c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint a, uint b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint c1 = c0 + (10**18 / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / 10**18;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint c0 = a * 10**18;\r\n        require(a == 0 || c0 / a == 10**18, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function bpowi(uint a, uint n)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint z = n % 2 != 0 ? a : 10**18;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    function bpow(uint base, uint exp)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(base >= 1 wei, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= (2 * 10**18) - 1 wei, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint whole  = bfloor(exp);\r\n        uint remain = bsub(exp, whole);\r\n\r\n        uint wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint partialResult = bpowApprox(base, remain, 10**18 / 10**10);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(uint base, uint exp, uint precision)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        // term 0:\r\n        uint a     = exp;\r\n        (uint x, bool xneg)  = bsubSign(base, 10**18);\r\n        uint term = 10**18;\r\n        uint sum   = term;\r\n        bool negative = false;\r\n\r\n\r\n        for (uint i = 1; term >= precision; i++) {\r\n            uint bigK = i * 10**18;\r\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, 10**18));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\ncontract Earl is RMath {\r\n    \r\n    function calcSpotPrice(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint spotPrice)\r\n    {\r\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\r\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\r\n        uint ratio = bdiv(numer, denom);\r\n        uint scale = bdiv(10**18, bsub(10**18, swapFee));\r\n        return  (spotPrice = bmul(ratio, scale));\r\n    }\r\n\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    )\r\n        public pure\r\n        returns (uint256 tokenAmountIn, uint256 tokenInFee)\r\n    {\r\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint256 y = bdiv(tokenBalanceOut, diff);\r\n        uint256 foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, 1e18);\r\n        foo = bmul(tokenBalanceIn, foo);\r\n        tokenAmountIn = bsub(1e18, swapFee);\r\n        tokenAmountIn = bdiv(foo, tokenAmountIn);\r\n        tokenInFee = bdiv(foo, 1e18);\r\n        tokenInFee = bsub(tokenAmountIn, tokenInFee);\r\n        return (tokenAmountIn, tokenInFee);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface wrap {\r\n    function deposit() external payable;\r\n    function withdraw(uint amt) external;\r\n}\r\n\r\ninterface swap {\r\n    function BUY(\r\n        uint dot,\r\n        address to,\r\n        uint minAmountOut\r\n    )\r\n        external payable\r\n        returns (uint tokenAmountOut);\r\n    function depositInternal(address asset, uint256 amt) external;\r\n    function payMain(address payee, uint amount) external;\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success);\r\n    }\r\n}\r\n\r\ncontract SDDeployer{\r\n    using Address for address;\r\n    mapping(address => address) private getSD;\r\n    address[] public allSD;\r\n    uint256 private rate = 1e9;\r\n    address private setter = 0xA039627567170Fec5852E740632FC4c9e24926a6;\r\n    address private FEG = 0xacFC95585D80Ab62f67A14C566C1b7a49Fe91167;\r\n    address private presaleDeployer = 0xA039627567170Fec5852E740632FC4c9e24926a6;\r\n    \r\n    function createSD(string memory name, uint256 supply, uint256 reflection, uint256 backing) external returns(address SD) { /*, bool _bool, address tokentomerge*/\r\n        //require(backing >= 90 && backing <= 99 && reflection < 50 , \"Backing must be inbetween 1 - 10%, Reflection must be under 50%\");\r\n        bytes memory bytecode = type(SMARTDeFi).creationCode;\r\n        bytes32 salt = keccak256(abi.encodePacked(SD));\r\n        assembly {\r\n            SD := create2(0, add(bytecode, 32), mload(bytecode), salt)\r\n        }\r\n        \r\n        /*if(_bool == true) {\r\n        require(tokentomerge != address(0));\r\n        supply = IERC20(tokentomerge).totalSupply();\r\n        }*/\r\n        \r\n        SDpair(SD).initialize(name, supply, reflection, msg.sender, presaleDeployer, backing, 1001); \r\n        getSD[SD] = SD;\r\n        allSD.push(SD);\r\n        \r\n        /*if(supply >= 10000000000){\r\n        bool xfer = IERC20(FEG).transferFrom(msg.sender, address(this), 10000000000 * rate);\r\n        require(xfer);\r\n        }\r\n        if(supply < 10000000000){\r\n        bool xfer = IERC20(FEG).transferFrom(msg.sender, address(this), supply * rate);\r\n        require(xfer);\r\n        }*/\r\n        return SD;\r\n    }\r\n    \r\n    function setPresaleDeployer(address addy, address addy1) public {\r\n        require(msg.sender == setter);\r\n        presaleDeployer = addy;\r\n        FEG = addy1;\r\n    }\r\n    \r\n    function setRate(uint256 _rate) public {\r\n        require(msg.sender == setter);\r\n        require(rate <= 1e9 && rate != 0, \"Must be under 1e9 and over 0\");\r\n        rate = _rate;\r\n    }\r\n    \r\n    function changeSetter(address addy) public {\r\n        require(msg.sender == setter);\r\n        setter = addy;\r\n    }\r\n\r\n    function getPairContract(address tokenA) public view returns(address){\r\n        return getSD[tokenA];\r\n    }\r\n}\r\n\r\ninterface SDpair {\r\n    function initialize(string calldata, uint256, uint256, address, address, uint256, uint256) external;\r\n}\r\n\r\ncontract SMARTDeFi is Earl {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    \r\n    struct Record {\r\n        uint balance;\r\n    }\r\n    \r\n    struct Blocks {\r\n        uint256[] amtMain;\r\n        uint256[] amtToken;\r\n        address[] user;\r\n    }\r\n    \r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountIn,\r\n        uint256         tokenAmountOut\r\n);\r\n\r\n    event LOG_SMARTSWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountIn,\r\n        uint256         tokenAmountOut\r\n);\r\n\r\n    address private FEGstake = 0xd2cD476Dd955EC713762EB830e467B50BADA4b6C; // All sells pay out to FEGstake!\r\n    address private _controller = 0x4c9BC793716e8dC05d1F48D8cA8f84318Ec3043C; // Can update FEGstake\r\n    address public _beneficiary = 0xA039627567170Fec5852E740632FC4c9e24926a6; // Token creator, can set poolOwner functions\r\n    address public Main = 0x87b1AccE6a1958E522233A737313C086551a5c76;\r\n    address public Token = address(this);\r\n    address public migrateFrom; //Token to be migrated to SmartDeFi\r\n    address private FEG = 0xacFC95585D80Ab62f67A14C566C1b7a49Fe91167;\r\n    address private burn = 0x000000000000000000000000000000000000dEaD;\r\n    address private perp = 0x7E5644faDF3F57A30b882774566B3163228fF5De; // ROX is sent here and burnt for backing, supports growth\r\n    address private FEGpair = 0x818E2013dD7D9bf4547AaabF6B617c1262578bc7;\r\n    address private ROX = 0xa3D522c151aD654b36BDFe7a69D0c405193A22F9;\r\n    address private presaleDeployer;\r\n    uint public Backing = 95; // This amount sets the share of Backing\r\n    bool private _publicSwap = false; // true if PUBLIC can call SWAP functions\r\n   // uint private FSS = 20; // 0.25% goes to FEGstake.\r\n    //uint private PSS = 50; //  has a 0.5% Sell Fee that goes towards buying FEG at market value and burning it.\r\n    uint private spec = 1001;\r\n   // uint256 private id = 0;\r\n    uint256 public _totalSupply1; // Internal Token\r\n    uint256 public _totalSupply2; // Internal Main\r\n    uint256 public _totalSupply5; // Asset Backing\r\n    uint256 public _totalSupply6; // Total waiting for FEGstake\r\n    uint256 public _totalSupply7; // Total waiting for FEG/Burn\r\n    uint256 public _totalSupply8; // Total waiting for ROX/Burn\r\n    uint256 public _totalSupply9; // Total tokens to migrate\r\n    uint256 public collateral;    // Total lending collateral, considered burnt until recovered\r\n    mapping(address=>Record) private  _records;\r\n    mapping(uint256=>Blocks) private  _data;\r\n    mapping(address=>bool) public whiteListContract;\r\n    mapping(address => uint256) private _balances1;\r\n    mapping(address => uint256) private _balances2;\r\n    mapping(address => uint256) private _userLoanRate;\r\n    mapping(address => uint256) private _loansBase; // base asset loan amount\r\n    mapping(address => uint256) public _loansToken;  // token collateral user\r\n    mapping(address => uint256) private _rBank;\r\n    mapping(address => uint256) private _aBank;\r\n    mapping(address => mapping (address => uint256)) private _allowances;\r\n    mapping(address => uint256) private transData;\r\n    mapping(address => uint256) public lendData;\r\n    mapping(address => mapping(address=>uint)) internal _allowance;\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private _tTotal = 1000000 * 1e9; // total supply\r\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n    uint256 private _tShareTotal;\r\n    bool public open = false;\r\n    bool public done = false;\r\n    bool public presaleSet = false;\r\n    bool public imported = false;\r\n    uint256 private fee;\r\n    uint256 public  tx1 = 98; // Token tx fee\r\n    uint256 public  tx2 = 99;  // Main tx fee\r\n    uint256 private MAX_RATIO = 50;\r\n    uint256 public MAX_SELL_RATIO = 10000 * 1e9;\r\n    uint256 public MAX_BUY_RATIO = 100e18;\r\n    string public name = \"FuzzyCat\";\r\n    string public symbol = \"zippers\";\r\n    uint8  public decimals = 9;\r\n    uint256 public totalSentRebates;\r\n    event Approval(address indexed src, address indexed dst, uint amt);\r\n    event Transfer(address indexed src, address indexed dst, uint amt);\r\n    \r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    modifier nonReentrant() {\r\n\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    constructor(){ //string memory _name, uint256 supply, uint256 reflection, address owner, address psdep, uint256 bk, uint256 _spec\r\n        require(done == false, \"Can only be used once\");\r\n        //uint256 amt = IERC20(migrateFrom).balanceOf(address(0)) + IERC20(migrateFrom).balanceOf(burn);\r\n        done = true;\r\n        _status = _NOT_ENTERED;\r\n        _tTotal = 1e20;\r\n        MAX_SELL_RATIO = bmul(1e20, 1e7);\r\n        //symbol = Hello;\r\n        spec = 1001;\r\n        Backing = 95;\r\n        _beneficiary = 0xA039627567170Fec5852E740632FC4c9e24926a6;\r\n        fee = 2;\r\n        tx1 = 98;\r\n        //presaleDeployer = psdep;\r\n        //whiteListContract[psdep] = true;\r\n        whiteListContract[address(this)] = true;\r\n        _rBank[_beneficiary] = _rTotal;\r\n        emit Transfer(burn, _beneficiary, _tTotal);\r\n        /*}\r\n        if(_bool == true){\r\n        _rBank[address(this)] = _rTotal - amt;\r\n        _totalSupply9 += _rTotal - amt;\r\n        _rBank[burn] = amt;\r\n        imported = true;\r\n        emit Transfer(burn, Token, _tTotal - amt);\r\n        }*/\r\n    }\r\n    \r\n    receive() external payable {\r\n    }\r\n    \r\n    function setPresale(bool _bool) external{\r\n        require(msg.sender == presaleDeployer);\r\n        presaleSet = _bool;\r\n    }\r\n    \r\n    function migrateTokens(uint256 amt) public { //Function to migrate existing token into a SmartDeFi Token. Deposit token to migrate and get new SmartDeFi Token instantly.\r\n        require(imported == true, \"Must be importable\");\r\n        _pullUnderlying(migrateFrom, msg.sender, amt);\r\n        _status = _NOT_ENTERED;\r\n        _pushUnderlying(Token, msg.sender, amt);\r\n        _totalSupply9 -= amt;\r\n    }\r\n    \r\n    function openit() public{\r\n        require(msg.sender == _beneficiary, \"No permission\");\r\n        require(_publicSwap == true, \"Deploy swap first\");\r\n        open = true;\r\n    }\r\n\r\n    function userBalanceInternal(address _addr) public view returns (uint256 token, uint256 main) {\r\n        return (_balances1[_addr], _balances2[_addr]);\r\n    }\r\n    \r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n    \r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return tokenFromGift(_rBank[account]);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        if(IsWhiteListContract(account)) {  return false; }\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    \r\n    function addWhiteListContract(address _addy, bool boolean) public {\r\n        require(msg.sender == _controller); \r\n        whiteListContract[_addy] = boolean;\r\n    }\r\n\r\n    function IsWhiteListContract(address _addy) public view returns(bool){\r\n        return whiteListContract[_addy];\r\n    }\r\n\r\n    function setMaxBuySellRatio(uint256 sellmax, uint256 buymax) public {\r\n        require(msg.sender == _beneficiary, \"You do not have permission\");\r\n        uint256 tob = _tTotal;\r\n        require(sellmax >= bdiv(tob, 1000) && sellmax <= tob, \"min 0.1% of token supply, max 100% of token supply\"); \r\n        require(buymax >= 2e18, \"2 BNB minimum\");\r\n        MAX_SELL_RATIO = sellmax;\r\n        MAX_BUY_RATIO = buymax;\r\n    }\r\n\r\n    function getBalance(address token)\r\n        external view\r\n        returns (uint)\r\n    {\r\n        return _records[token].balance;\r\n    }\r\n\r\n    function addBacking() public payable {\r\n        wrap(Main).deposit{value: msg.value}();\r\n        _totalSupply5 += bmul(msg.value, bdiv(99, 100));\r\n    }\r\n    \r\n    function deploySwap (uint256 amtoftoken, uint256 amtofMain, uint256 amtofBack) external {\r\n       // require(msg.sender == _beneficiary || msg.sender == presaleDeployer, \"Only owner\");\r\n       // require(_publicSwap == false && presaleSet == false, \"Not public\");\r\n        \r\n        _pullUnderlying(Token, msg.sender, amtoftoken);   \r\n        //_status = _NOT_ENTERED;\r\n        \r\n        _pullUnderlying(Main, msg.sender, amtofMain.add(amtofBack));\r\n        //_status = _NOT_ENTERED;\r\n        \r\n        _totalSupply5 = bmul(amtofBack, bdiv(99, 100));\r\n        //_pullUnderlying(Main, msg.sender, amtofMain.add(amtofBack));\r\n        \r\n        _publicSwap = true;\r\n        _records[Token].balance = IERC20(Token).balanceOf(Token).sub(_totalSupply9); \r\n        _records[Main].balance += bmul(amtofMain, bdiv(99, 100)); //gives wrap reflections gained during presale to swap liquidity\r\n    }\r\n\r\n    function getSpotPrice(address tokenIn, address tokenOut)\r\n        external view\r\n        returns (uint spotPrice)\r\n    {\r\n        Record storage inRecord = _records[tokenIn];\r\n        Record storage outRecord = _records[tokenOut];\r\n        return calcSpotPrice(inRecord.balance, 25, outRecord.balance, 25, 0);\r\n    }\r\n    \r\n    address b1;  uint256 b1v; uint256 b1m;\r\n    address b2;  uint256 b2v; uint256 b2m;\r\n    address b3;  uint256 b3v; uint256 b3m;\r\n    address b4;  uint256 b4v; uint256 b4m;\r\n    address b5;  uint256 b5v; uint256 b5m;\r\n    address b6;  uint256 b6v; uint256 b6m;\r\n    address b7;  uint256 b7v; uint256 b7m;\r\n    address b8;  uint256 b8v; uint256 b8m;\r\n    address b9;  uint256 b9v; uint256 b9m;\r\n    address b10; uint256 b10v; uint256 b10m;\r\n    address s1;  uint256 s1v; uint256 s1m;\r\n    address s2;  uint256 s2v; uint256 s2m;\r\n    address s3;  uint256 s3v; uint256 s3m;\r\n    address s4;  uint256 s4v; uint256 s4m;\r\n    address s5;  uint256 s5v; uint256 s5m;\r\n    address s6;  uint256 s6v; uint256 s6m;\r\n    address s7;  uint256 s7v; uint256 s7m;\r\n    address s8;  uint256 s8v; uint256 s8m;\r\n    address s9;  uint256 s9v; uint256 s9m;\r\n    address s10; uint256 s10v; uint256 s10m;\r\n    uint256 sBatch;\r\n    uint256 bBatch;\r\n    \r\n    function closeBatch(address to) internal returns(uint256 amt){\r\n        Record storage tREC = _records[Token];\r\n        Record storage mREC = _records[Main];\r\n        amt = (s1v + s2v + s3v + s4v + s5v + s6v + s7v + s8v + s9v + s10v);\r\n        uint256 amtb = (b1v + b2v + b3v + b4v + b5v + b6v + b7v + b8v + b9v + b10v);\r\n        _records[Main].balance = _records[Main].balance.add(bmul(amtb, bdiv((Backing - bdiv(25, 100)), 100))).sub(_totalSupply2 + _totalSupply5 + _totalSupply6 + _totalSupply7 + _totalSupply8);\r\n        _records[Token].balance = _records[Token].balance.add(amt).sub(_totalSupply9 + collateral);\r\n        buyIt(mREC.balance, tREC.balance);\r\n        if(amt > 0){\r\n        uint256 pre = bmul(bdiv(_records[Main].balance, _records[Token].balance), amt);\r\n        uint256 tokenAmountOut = bmul(bmul(pre, bdiv(Backing, 100)), bdiv(99, 100));\r\n        uint256 gass = bmul(bmul(pre, bdiv(Backing, 100)), bdiv(1, 100));\r\n        require(tokenAmountOut <= bmul(_records[Main].balance, bdiv(MAX_RATIO, 100)), \"Over MAX_OUT_RATIO\");  \r\n        wrap(Main).withdraw(tokenAmountOut);\r\n        uint256 ba = bmul(tokenAmountOut, bdiv(99, 100));\r\n        uint256 bao = bmul(ba, bdiv(Backing, 100));\r\n        uint256 back = ba - bao;\r\n        uint256 feg = bmul(bao, bdiv(3, 1000)); \r\n        uint256 boo = bao - feg;\r\n        _totalSupply5 += back;\r\n        burnFEG(feg);\r\n        if(s1v !=0){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s1, bdiv(s1v, bal)); s1v = 0; s1 = address(0);}  \r\n        if(s2v !=0){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s2, bdiv(s2v, bal)); s2v = 0; s2 = address(0);}  \r\n        if(s3v !=0){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s3, bdiv(s3v, bal)); s3v = 0; s3 = address(0);}\r\n        if(s4v !=0){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s4, bdiv(s4v, bal)); s4v = 0; s4 = address(0);}\r\n        if(s5v !=0){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s5, bdiv(s5v, bal)); s5v = 0; s5 = address(0);}\r\n        /*if(s6v !=0 ){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s6, bdiv(s6v, bal)); s6v = 0; s6 = address(0);}\r\n        if(s7v !=0 ){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s7, bdiv(s7v, bal)); s7v = 0; s7 = address(0);}\r\n        if(s8v !=0 ){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s8, bdiv(s8v, bal)); s8v = 0; s8 = address(0);}\r\n        if(s9v !=0 ){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s9, bdiv(s9v, bal)); s9v = 0; s9 = address(0);}\r\n        if(s10v !=0){uint256 bal = bdiv(boo, tokenAmountOut); TransferHelper.safeTransferETH(s10, bdiv(s10v, bal)); s10v = 0; s10 = address(0);}  */\r\n        uint256 gasRebate = (_balances2[burn] + gass);\r\n        _balances2[burn] = 0;\r\n        TransferHelper.safeTransferETH(to, gasRebate);\r\n        bBatch = 0;\r\n        return amt;\r\n       }\r\n    }\r\n    \r\n    function buyIt(uint256 _main, uint256 _token) internal returns(uint256 amt){ \r\n        amt = (b1v + b2v + b3v + b4v + b5v + b6v + b7v + b8v + b9v + b10v);\r\n        if(amt > 0) {\r\n        uint256 oil = bmul(amt, bdiv(99, 100));\r\n        wrap(Main).deposit{value: oil}();\r\n        uint256 ol = bmul(amt, bdiv(99, 100)); // 0.9801\r\n        uint256 cut = bmul(ol, bdiv(Backing, 100)); // 0.931095\r\n        uint256 back = ol - cut;\r\n        uint256 fega = bmul(cut, bdiv(997, 1000)); // 0.9283\r\n        payStake(Main, (cut - fega));\r\n        uint256 van = bmul(fega, bdiv(990, 1000));\r\n        _balances2[burn] += bmul(fega, bdiv(9, 1000));\r\n        burnROX(bmul(fega, bdiv(1, 1000)));\r\n        uint256 worth = fega - van;\r\n        uint256 tokenAmountOut = bmul(bdiv(_main, _token), worth);\r\n        require(tokenAmountOut <= bmul(_records[Token].balance, bdiv(MAX_RATIO, 100)), \"Over MAX_OUT_RATIO\"); \r\n        if(b1v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b1, bdiv(b1v, bal)); b1v = 0; b1 = address(0);}  \r\n        if(b2v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b2, bdiv(b2v, bal)); b2v = 0; b2 = address(0);}  \r\n        if(b3v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b3, bdiv(b3v, bal)); b3v = 0; b3 = address(0);}\r\n        if(b4v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b4, bdiv(b4v, bal)); b4v = 0; b4 = address(0);}\r\n        if(b5v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b5, bdiv(b5v, bal)); b5v = 0; b5 = address(0);}\r\n        /*if(b6v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b6, bdiv(b6v, bal)); b6v = 0; b6 = address(0);}\r\n        if(b7v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b7, bdiv(b7v, bal)); b7v = 0; b7 = address(0);}\r\n        if(b8v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b8, bdiv(b8v, bal)); b8v = 0; b8 = address(0);}\r\n        if(b9v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b9, bdiv(b9v, bal)); b9v = 0; b9 = address(0);}\r\n        if(b10v !=0){uint256 bal = bdiv(worth , tokenAmountOut); _pushUnderlying(Token, b10, bdiv(b10v, bal)); b10v = 0; b10 = address(0);}*/\r\n        TransferHelper.safeTransferETH(_beneficiary, bmul(amt, bdiv(1, 100)));\r\n        _totalSupply5 += back;\r\n        return amt;\r\n        }\r\n    }\r\n    \r\n    function closeStaleBatch() public {\r\n        require(transData[burn] < block.timestamp, \"Can only close after 10 min\");\r\n        closeBatch(msg.sender);\r\n        transData[burn] = 0;\r\n    }\r\n    \r\n    function BUY(\r\n        uint256 dot,\r\n        address to,\r\n        uint256 minAmountOut\r\n    ) \r\n        external nonReentrant payable\r\n    {   \r\n        transData[burn] = block.timestamp + 10 minutes;\r\n        require(msg.value <= MAX_BUY_RATIO, \"BUY amount is over limit\");\r\n        bBatch += 1; dot; uint256 i = minAmountOut;\r\n        if(bBatch == 1){b1 = to; b1v = msg.value; b1m = i;}\r\n        if(b1v >= 6e18) {closeBatch(to);}\r\n        if(bBatch == 2){b2 = to; b2v = msg.value; b2m = i;}\r\n        uint256 peace2 = (b1v + b2v);\r\n        if(peace2 >= 12e18) {closeBatch(to);}\r\n        if(bBatch == 3){b3 = to; b3v = msg.value; b3m = i;}\r\n        uint256 peace3 = (b1v + b2v + b3v);\r\n        if(peace3 >= 18e18) {closeBatch(to);}\r\n        if(bBatch == 4){b4 = to; b4v = msg.value; b4m = i;}\r\n        uint256 peace4 = (b1v + b2v + b3v + b4v);\r\n        if(peace4 >= 24e18) {closeBatch(to);}\r\n        if(bBatch == 5){b5 = to; b5v = msg.value; b5m = i; {closeBatch(to);}\r\n        \r\n        /*\r\n        if(bBatch == 6){b6 = to; b6v = msg.value; b6m = i;}\r\n        uint256 peace6 = (b1v + b2v + b3v + b4v +b5v + b6v);\r\n        if(peace6 >= 36e18) {closeBatch(to);}\r\n        if(bBatch == 7){b7 = to; b7v = msg.value; b7m = i;}\r\n        uint256 peace7 = (b1v + b2v + b3v + b4v +b5v + b6v + b7v);\r\n        if(peace7 >= 42e18) {closeBatch(to);}\r\n        if(bBatch == 8){b8 = to; b8v = msg.value; b8m = i;}\r\n        uint256 peace8 = (b1v + b2v + b3v + b4v + b5v + b6v + b7v + b8v);\r\n        if(peace8 >= 48e18) {closeBatch(to);}\r\n        if(bBatch == 9){b9 = to; b9v = msg.value; b9m = i;}\r\n        uint256 peace9 = (b1v + b2v + b3v + b4v + b5v + b6v + b7v + b8v + b9v);\r\n        if(peace9 >= 56e18) {closeBatch(to);}\r\n        if(bBatch == 10){b10 = to; b10v = msg.value; b10m = i; closeBatch(to);}*/\r\n        }\r\n    }\r\n    \r\n    function SELL(\r\n        uint256 dot,\r\n        address to,\r\n        uint256 tokenAmountIn,\r\n        uint256 minAmountOut\r\n    ) \r\n        external nonReentrant\r\n    {   \r\n        transData[burn] = block.timestamp + 10 minutes;\r\n        require(tokenAmountIn <= MAX_SELL_RATIO, \"SELL amount is over limit\");\r\n        uint256 sello = totalSupply();\r\n        \r\n        sBatch += 1; dot; uint256 i = minAmountOut;\r\n        if(sBatch == 1){s1 = to; s1v = tokenAmountIn; s1m = i;}\r\n        if(s1v >= sello.div(40000)) {closeBatch(to);}\r\n        \r\n        if(sBatch == 2){s2 = to; s2v = tokenAmountIn; s2m = i;}\r\n        uint256 peace2 = (s1v + s2v);\r\n        if(peace2 >= sello.div(20000)) {closeBatch(to);}\r\n        \r\n        if(sBatch == 3){s3 = to; s3v = tokenAmountIn; s3m = i;}\r\n        uint256 peace3 =(s1v + s2v + s3v);\r\n        if(peace3 >= sello.div(10000)) {closeBatch(to);}\r\n        \r\n        if(sBatch == 4){s4 = to; s4v = tokenAmountIn; s4m = i;}\r\n        uint256 peace4 = (s1v + s2v + s3v + s4v);\r\n        if(peace4 >= sello.div(5000)) {closeBatch(to);}\r\n        \r\n        if(sBatch == 5){s5 = to; s5v = tokenAmountIn; s5m = i; closeBatch(to);}\r\n        \r\n        /*if(sBatch == 6){s6 = to; s6v = tokenAmountIn; s6m = i;}\r\n        uint256 peace6 = (s1v + s2v + s3v + s4v +s5v + s6v);\r\n        if(peace6 >= sello.div(1250)) {closeBatch(to);}\r\n        \r\n        if(sBatch == 7){s7 = to; s7v = tokenAmountIn; s7m = i;}\r\n        uint256 peace7 = (s1v + s2v + s3v + s4v +s5v + s6v + s7v);\r\n        if(peace7 >= sello.div(1250)) {closeBatch(to);}\r\n        \r\n        if(sBatch == 8){s8 = to; s8v = tokenAmountIn; s8m = i;}\r\n        uint256 peace8 = (s1v + s2v + s3v + s4v + s5v + s6v + s7v + s8v);\r\n        if(peace8 >= sello.div(625)) {closeBatch(to);}\r\n        \r\n        if(sBatch == 9){s9 = to; s9v = tokenAmountIn; s9m = i;}\r\n        uint256 peace9 = (s1v + s2v + s3v + s4v + s5v + s6v + s7v + s8v + s9v);\r\n        if(peace9 >= sello.div(300)) {closeBatch(to);}\r\n        \r\n        if(sBatch == 10){s10 = to; s10v = tokenAmountIn; s10m = i; closeBatch(to);}*/\r\n    }\r\n    \r\n    function liquifyForMain(uint256 amt) external{ //Instantly burns your Token and sends you proportional backing.\r\n        Loan(amt);\r\n        _loansToken[msg.sender] = 0;\r\n        collateral -= amt;\r\n        _status = _NOT_ENTERED;\r\n        _pushUnderlying(Token, burn, amt);\r\n    }\r\n    \r\n    function Loan(uint256 amt) public returns(uint tokenAmountOut){ // You have 30 days to repay or you forfeit your collateral. You can only have one loan open at a time.\r\n        address user = msg.sender;\r\n        uint256 timeNow1 = block.timestamp;\r\n        require(open == true, \"Not public\");\r\n        if(_loansToken[user] > 0 && lendData[user] <= timeNow1){\r\n        _loansToken[user] = 0;  \r\n        lendData[user] = 0;\r\n        }\r\n        require(lendData[user] == 0 || timeNow1 >= lendData[user], \"Settle existing loan first\");\r\n        uint256 amt1 = bmul(amt, bdiv(tx1, 100));\r\n        uint256 total = _tTotal.sub(IERC20(address(this)).balanceOf(address(burn)).add(collateral));\r\n        tokenAmountOut = bmul(_totalSupply5, bdiv(amt1, total));\r\n        uint256 timeNow = block.timestamp.add(30 days);\r\n        lendData[user] = timeNow;\r\n        _loansToken[user] += amt1;\r\n        collateral += amt1;\r\n        _pullUnderlying(Token, user, amt);\r\n        _loansBase[user] += tokenAmountOut; \r\n        _totalSupply5 -= tokenAmountOut;\r\n        wrap(Main).withdraw(tokenAmountOut);\r\n        TransferHelper.safeTransferETH(user, bmul(tokenAmountOut, bdiv(99, 100)));\r\n        _userLoanRate[user] = oneTokentoBacking();\r\n        return tokenAmountOut; \r\n    }\r\n    \r\n    function extendLoan() public nonReentrant { // This will extend your loan 30 days, 0.1% collateral will be burnt.\r\n        require(_loansToken[msg.sender] > 0 && lendData[msg.sender] > block.timestamp, \"Period ended\");\r\n        _loansToken[msg.sender] = bmul(_loansToken[msg.sender], bdiv(999, 1000));\r\n        lendData[msg.sender] += lendData[msg.sender] + 30 days;\r\n        uint256 oj = bmul(_loansToken[msg.sender], bdiv(1, 1000));\r\n        collateral -= oj;\r\n        _pushUnderlying(Token, burn, oj);\r\n    }\r\n    \r\n    function amountToRepay(address user) public view returns(uint256 finalamt){  // Your amount to repay loan at time of calling function, will raise overtime as backing increases.\r\n        uint256 amt  = _loansBase[user]; \r\n        uint256 fef = oneTokentoBacking(); \r\n        uint256 bef = (fef.sub(_userLoanRate[user]));\r\n        uint256 difference = bef.mul(_loansToken[user]);\r\n        uint256 wif = bmul((amt + difference), bmul(102, 10000)); // add 1.02% for wrap tx fee coming back to ensure positive ratios\r\n        finalamt = badd((amt + difference), wif);\r\n        return finalamt;\r\n    }    \r\n    \r\n    function repayLoan() external { // You must repay the difference in your tokens asset backing increase and both 1% wrap tx fees on Loan and repayLoan. Baseline Value ratio must be kept at all times.\r\n        address user = msg.sender;\r\n        uint256 finalamt = amountToRepay(user);\r\n        uint256 timeNow = block.timestamp;\r\n        require(timeNow <= lendData[user] && lendData[user] != 0, \"Your loan has expired or not existing lender\");\r\n        wrap(Main).deposit{value: finalamt}();\r\n        uint256 out = _loansToken[user];\r\n        collateral -= out;\r\n        _totalSupply5 += bmul(finalamt, bdiv(99, 100));\r\n        _pushUnderlying(Token, user, out);\r\n        _loansToken[user]  = 0;\r\n        _loansBase[user] = 0;\r\n        _userLoanRate[user]  = 0;\r\n        lendData[user] = 0;\r\n    }    \r\n    \r\n    function oneTokentoBacking()\r\n        public view \r\n        returns (uint256)\r\n    {   \r\n        uint256 amountBacking = _totalSupply5;\r\n        uint256 total = _tTotal.sub(IERC20(address(this)).balanceOf(address(burn)).add(collateral));\r\n        uint256 tokenAmountOut = bmul(amountBacking, bdiv(bmul(1, bdiv(tx1, 100)), total));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    function depositInternal(address asset, uint256 amt) external {\r\n        require(asset == Main || asset == Token);\r\n        require(open == true, \"Swap not activated\");\r\n        if(asset == Token){    \r\n        _pullUnderlying(Token, msg.sender, amt);\r\n        uint256 finalAmount = bmul(amt, bdiv(99, 100));\r\n        _totalSupply1 += finalAmount;\r\n        _balances1[msg.sender] += finalAmount;\r\n    }\r\n    \r\n        else{\r\n        _pullUnderlying(Main, msg.sender, amt);\r\n        uint256 finalAmount = bmul(amt, bdiv(tx1, 100));\r\n        _totalSupply2 += finalAmount;\r\n        _balances2[msg.sender] += finalAmount;\r\n        }\r\n    }\r\n\r\n    function withdrawInternal(address asset, uint256 amt) external {\r\n        require(asset == Main || asset == Token);\r\n        if(asset == Token){\r\n        require(_balances1[msg.sender] >= amt, \"Not enough token\");\r\n        _totalSupply1 -= amt;\r\n        _balances1[msg.sender] -= amt;\r\n        _pushUnderlying(Token, msg.sender, amt); \r\n    }\r\n        else{\r\n        require(_balances2[msg.sender] >= amt, \"Not enough Main\");\r\n        _totalSupply2 -= amt;\r\n        _balances2[msg.sender] -= amt;\r\n        _pushUnderlying(Main, msg.sender, amt);\r\n        }\r\n    }\r\n\r\n    function _pullUnderlying(address erc20, address from, uint amount)\r\n        internal\r\n        //nonReentrant\r\n    {\r\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer);\r\n    }\r\n    \r\n    function _pushUnderlying(address erc20, address to, uint amount)\r\n        internal\r\n        //nonReentrant\r\n    {\r\n        bool xfer = IERC20(erc20).transfer(to, amount);\r\n        require(xfer);\r\n    }\r\n    \r\n    function payStake(address erc20, uint amount) internal{   \r\n        _totalSupply7 = _totalSupply7.add(amount);\r\n        \r\n        if(_totalSupply7 > 1e15) {\r\n        bool xfer = IERC20(erc20).transfer(FEGstake, amount);\r\n        require(xfer);\r\n        _totalSupply7 = 0;\r\n        }\r\n    }\r\n    \r\n    function burnROX(uint amount) internal{\r\n        _totalSupply8 = _totalSupply8.add(amount);\r\n        \r\n        if(_totalSupply8 > 1e15) {\r\n        wrap(Main).withdraw(_totalSupply8);\r\n        swap(ROX).BUY{value: bmul(_totalSupply8, bdiv(99, 100))}(1001, perp, 1);\r\n        _totalSupply8 = 0;\r\n        }\r\n    }\r\n    \r\n    function burnFEG(uint amount) internal{   \r\n        _totalSupply6 = _totalSupply6.add(amount);\r\n        \r\n        if(_totalSupply6 > 1e15) {\r\n        wrap(Main).withdraw(_totalSupply6);\r\n        swap(FEGpair).BUY{value: bmul(_totalSupply6, bdiv(99, 100)) }(1001, burn, 100);\r\n        _totalSupply6 = 0;\r\n        }\r\n    }\r\n    \r\n    function updateS(address _FEG, address _FEGpair, address cont, address fsp, address _rox, address _perp) public{ // Incase updates later\r\n        require(msg.sender == _controller);\r\n        FEG = _FEG;\r\n        ROX = _rox;\r\n        FEGpair = _FEGpair;\r\n        _controller = cont;\r\n        perp = _perp;\r\n        FEGstake = fsp;\r\n    }\r\n\r\n    function tokenFromGift(uint256 rAmount) public view returns(uint256) {\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        if(Address.isContract(spender) == true ){\r\n            require(IsWhiteListContract(spender) == true, \"3rd party not supported\");\r\n        }\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rShare, uint256 tTransferAmount, uint256 tShare) = _getValues(amount);\r\n        _rBank[sender] = _rBank[sender].sub(rAmount);\r\n        _rBank[recipient] = _rBank[recipient].add(rTransferAmount);       \r\n        _smartFee(rShare, tShare);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n   \r\n    function _smartFee(uint256 rFee, uint256 tFee) private {\r\n        _rTotal = _rTotal.sub(rFee);\r\n        _tShareTotal = _tShareTotal.add(tFee);\r\n    } \r\n\r\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) {\r\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\r\n        uint256 currentRate =  _getRate();\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\r\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\r\n    }\r\n\r\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) {\r\n        uint256 tFee = tAmount.div(100).mul(2);\r\n        uint256 tTransferAmount = tAmount.sub(tFee);\r\n        return (tTransferAmount, tFee);\r\n    }\r\n\r\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\r\n        uint256 rAmount = tAmount.mul(currentRate);\r\n        uint256 rFee = tFee.mul(currentRate);\r\n        uint256 rTransferAmount = rAmount.sub(rFee);\r\n        return (rAmount, rTransferAmount, rFee);\r\n    }\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply.div(tSupply);\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;      \r\n\r\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n    \r\n    function payMain(address payee, uint amount)\r\n        external nonReentrant \r\n        \r\n    {   \r\n        require(_balances2[msg.sender] >= amount, \"Not enough token\");\r\n        _balances2[msg.sender] -= amount;\r\n        _balances2[payee] += amount;\r\n    }\r\n    \r\n    function payToken(address payee, uint amount)\r\n        external nonReentrant \r\n        \r\n    {\r\n        require(_balances1[msg.sender] >= amount, \"Not enough token\");\r\n        _balances1[msg.sender] -= amount;\r\n        _balances1[payee] += amount;\r\n    }\r\n    \r\n    function swapToSwap(address path, address asset, address to, uint256 amt) nonReentrant external {\r\n        asset = Main;\r\n        require(_balances2[msg.sender] >= amt, \"Not enough Main\");\r\n        uint256 aft = bmul(amt, bdiv(99, 100)); \r\n        IERC20(address(Main)).approve(address(path), amt);   \r\n        _totalSupply2 -= amt;\r\n        _balances2[msg.sender] = bsub(_balances2[msg.sender], amt);\r\n        swap(path).depositInternal(Main, amt);\r\n        swap(path).payMain(to, aft);\r\n        \r\n    }\r\n}"}}}