{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BotRouterV3.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport './libraries/Path.sol';\nimport './libraries/TransferHelper.sol';\nimport './interfaces/IUniswapV3Pool.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/IERC20.sol';\nimport './libraries/SafeCast.sol';\n\ncontract BotRouterV3 {\n    using Path for bytes;\n\n    uint160 internal constant MIN_SQRT_RATIO = 4295128740;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970341;\n    address private constant factory = address(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n    \n    // weth mainnet\n    address private constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address private constant USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    address private constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address private constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    address private constant WBTC = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n\n    // ownership\n    address private constant OWNER1 = address(0xD43975Be509eA732A3BD64F2D5fa34D355A8F911);\n    address private constant OWNER2 = address(0x0D0B3F21d7c90d0b957Aa6aCBc993621311208E4);\n    address private constant OWNER3 = address(0xb1BD29E35D7ca6f499fFc4180357a4d237e1E0De);\n    address private constant OWNER4 = address(0xF0475a1f184f062D1eee88f0D79EC4EB2795D4F0);\n    \n    function _onlyOwner() internal view {\n        require(\n            msg.sender == OWNER1 || msg.sender == OWNER2 || msg.sender == OWNER3 || msg.sender == OWNER4, \n            \"Only Owner\"\n        );\n    }\n\n    function _payAndVerifyBlockNumber() internal {\n       // FB pay in coinbase \n        if (msg.value > 0) {\n            uint16 blockNumber = lastFourDigitsOf(msg.value); \n            require(lastFourDigitsOf(block.number) == blockNumber, \"BN\");\n            block.coinbase.transfer(msg.value);\n        }\n   }\n    \n    function withdrawToken(address to, address token, uint256 amount) external {\n        require(WETH != token, 'WETH not allowed');\n        _onlyOwner();\n        \n        if (amount == 0) {\n            amount = IERC20(token).balanceOf(address(this));\n        }\n        require(amount > 0, \"no balance\");\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n    \n    function balanceOfAddress(address token, address add) external view returns(uint256) {\n        return IERC20(token).balanceOf(add);\n    }\n\n    function balanceOf(address token) external view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n    \n    receive() external payable {\n        if (msg.sender != WETH) {\n            IWETH(WETH).deposit{value: msg.value}();\n        }\n    }\n    \n    function withdrawWeth(uint256 etherAmount) external {\n        _onlyOwner();\n        \n        if (etherAmount == 0) {\n            etherAmount = IERC20(WETH).balanceOf(address(this));\n        }\n        \n        IWETH(WETH).withdraw(etherAmount);\n        (bool success,) = msg.sender.call{value:etherAmount}(new bytes(0));\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n\n    function withdrawWethAndDepositInCEX(uint256 withdrawAmount, uint256 transferAmount, address depositAddress) external {\n        _onlyOwner();\n        \n        if (withdrawAmount == 0) {\n            withdrawAmount = IERC20(WETH).balanceOf(address(this));\n        }\n        \n        IWETH(WETH).withdraw(withdrawAmount);\n        if (transferAmount > 0) {\n            (bool success,) = msg.sender.call{value:transferAmount}(new bytes(0));\n            require(success, 'ETH_TRANSFER_FAILED');\n        }\n        if (transferAmount < withdrawAmount && depositAddress != address(0)) {\n            uint256 depositAmount = withdrawAmount - transferAmount;\n            (bool success,) = depositAddress.call{value:depositAmount}(new bytes(0));\n            require(success, 'ETH_DEPOSIT_FAILED');\n        }\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        (address tokenIn, address tokenOut, uint24 fee) = _data.decodeFirstPool();\n        address pool = getPool(tokenIn, tokenOut, fee);\n        require(msg.sender == pool);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n\n        if (isExactInput) {\n            TransferHelper.safeTransfer(tokenIn, pool, amountToPay);\n        } else {\n            TransferHelper.safeTransfer(tokenOut, pool, amountToPay);\n        }\n    }\n\n    function exactInputInternal(\n        uint256 amountIn,\n        bytes memory data\n    ) private returns (uint256) {\n        (address tokenIn, address tokenOut, uint24 fee) = data.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        address pool = getPool(tokenIn, tokenOut, fee);\n\n        (int256 amount0, int256 amount1) = \n            IUniswapV3Pool(pool).swap(\n                address(this),\n                zeroForOne,\n                SafeCast.toInt256(amountIn),\n                zeroForOne ? MIN_SQRT_RATIO : MAX_SQRT_RATIO,\n                data\n            );\n\n        return uint256(-(zeroForOne ? amount1 : amount0));\n    }\n    \n    function swapExactTokensForApprovedTokenV3(\n        uint256 minAmountOut,\n        address tokenIn,\n        address tokenOut,\n        uint24 fee\n    ) external payable returns (uint256 amountOutReturned) {\n        uint256 balance = IERC20(tokenIn).balanceOf(address(this));\n        require(balance > 0, \"No balance\");\n        require(\n            tokenOut == WETH || tokenOut == USDT || tokenOut == USDC || tokenOut == DAI || tokenOut == WBTC, \n            \"BTO\"\n        ); // bad token out\n        _onlyOwner();\n        _payAndVerifyBlockNumber();\n\n        amountOutReturned = exactInputInternal(\n            balance,\n            abi.encodePacked(tokenIn, fee, tokenOut)\n        );\n        require(amountOutReturned >= minAmountOut, 'MAO'); // min amount out\n    }\n\n    function exactOutputInternal(\n        uint256 amountOut,\n        address recipient,\n        bytes memory data\n    ) private returns (uint256 amountIn) {\n        if (recipient == address(0)) recipient = address(this);\n\n        (address tokenOut, address tokenIn, uint24 fee) = data.decodeFirstPool();\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        address pool = getPool(tokenIn, tokenOut, fee);\n\n        (int256 amount0Delta, int256 amount1Delta) = \n            IUniswapV3Pool(pool).swap(\n                recipient,\n                zeroForOne,\n                -SafeCast.toInt256(amountOut),\n                zeroForOne ? MIN_SQRT_RATIO : MAX_SQRT_RATIO,\n                data\n            );\n\n        uint256 amountOutReceived;\n        (amountIn, amountOutReceived) = zeroForOne\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\n            : (uint256(amount1Delta), uint256(-amount0Delta));\n        // it's technically possible to not receive the full output amount,\n        // so if no price limit has been specified, require this possibility away\n        require(amountOutReceived == amountOut);\n    }\n\n    function swapApprovedTokenForExactTokensAndDepositV3(\n        uint256 maxAmountIn,\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        address recipient // deposit address CEX or address(0) (-> recipient will be address(this))\n    ) external payable returns (uint256 amountInReturned) {\n        require(\n            tokenIn == WETH || tokenIn == USDT || tokenIn == USDC || tokenIn == DAI || tokenIn == WBTC,\n            \"BTI\"\n        ); // bad token in\n        _onlyOwner();\n        _payAndVerifyBlockNumber();\n        \n        amountInReturned = exactOutputInternal(\n            amountOut,\n            recipient,\n            abi.encodePacked(tokenOut, fee, tokenIn)\n        );\n        require(amountInReturned <= maxAmountIn, 'MAI'); // max amount in\n    }\n\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) private pure returns (address pool) {\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(token0, token1, fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            )\n        );\n    }\n\n    // returns uint16 with the last three digits of x\n    function lastFourDigitsOf(uint256 num) private pure returns (uint16) {\n        return uint16(num % 65536);\n    }\n    \n    function emergencySubmitTransaction(address destination, bytes memory data) public returns (bool) {\n        _onlyOwner();\n        \n        uint256 dataLength = data.length;\n        bool result;\n        assembly {\n            let x := mload(0x40) // memory for output\n            let d := add(data, 32) // first 32 bytes are the padded length of data, so exclude that\n            result := call(\n                gas(),\n                destination,\n                0, // value is ignored\n                d,\n                dataLength,\n                x,\n                0 // output is ignored\n            )\n        }\n        return result;\n    }\n\n}"},"interfaces/IERC20.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    // event Approval(address indexed owner, address indexed spender, uint value);\n    // event Transfer(address indexed from, address indexed to, uint value);\n\n    // function name() external view returns (string memory);\n    // function symbol() external view returns (string memory);\n    // function decimals() external view returns (uint8);\n    // function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    // function allowance(address owner, address spender) external view returns (uint);\n\n    // function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    // function transferFrom(address from, address to, uint value) external returns (bool);\n}"},"interfaces/IUniswapV3Pool.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IUniswapV3Pool {  \n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}"},"interfaces/IWETH.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    // function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"},"libraries/BytesLib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.5.0 <0.8.0;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, 'slice_overflow');\n        require(_start + _length >= _start, 'slice_overflow');\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"},"libraries/Path.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport './BytesLib.sol';\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}\n"},"libraries/SafeCast.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}"},"libraries/TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    // function safeApprove(\n    //     address token,\n    //     address to,\n    //     uint256 value\n    // ) internal {\n    //     // bytes4(keccak256(bytes('approve(address,uint256)')));\n    //     (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n    //     require(\n    //         success && (data.length == 0 || abi.decode(data, (bool))),\n    //         'TransferHelper::safeApprove: approve failed'\n    //     );\n    // }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    // function safeTransferFrom(\n    //     address token,\n    //     address from,\n    //     address to,\n    //     uint256 value\n    // ) internal {\n    //     // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    //     (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n    //     require(\n    //         success && (data.length == 0 || abi.decode(data, (bool))),\n    //         'TransferHelper::transferFrom: transferFrom failed'\n    //     );\n    // }\n\n    // function safeTransferETH(address to, uint256 value) internal {\n    //     (bool success, ) = to.call{value: value}(new bytes(0));\n    //     require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    // }\n}\n"}}}