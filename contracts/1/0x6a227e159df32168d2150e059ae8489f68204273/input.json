{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Presale.sol":{"content":"\n    pragma solidity ^0.6.6;\n   \n   \n    /**\n    * @title SafeMath\n    * @dev Math operations with safety checks that throw on error\n    */\n    library SafeMath {\n   \n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n   \n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */  \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n   \n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n       \n        return c;\n    }\n   \n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n   \n    /**\n    * @dev Mod two numbers.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n        }\n    }\n   \n   \n    /**\n    * @dev Interface of the ERC20 standard as defined in the EIP.\n    */\n    interface IERC20 {\n   \n    function totalSupply() external view returns (uint256);\n   \n    function balanceOf(address account) external view returns (uint256);\n   \n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n   \n    /**\n    * @dev Returns the remaining number of tokens that `spender` will be\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\n    * zero by default.\n    *\n    * This value changes when {approve} or {transferFrom} are called.\n    */\n   \n    function approve(address spender, uint256 amount) external returns (bool);\n   \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n   \n    event Transfer(address indexed from, address indexed to, uint256 value);\n   \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    }\n   \n   \n    /**\n    * @title SafeERC20\n    * @dev Wrappers around ERC20 operations that throw on failure.\n    * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n    * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n    */\n    library SafeERC20 {\n    using SafeMath for uint256;\n   \n        function safeTransfer(IERC20 token, address to, uint256 value) internal {\n            require(token.transfer(to, value));\n        }\n   \n        function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n            require(token.transferFrom(from, to, value));\n        }\n    }\n   \n     /**\n    * @title Presale\n    * @dev Presale distribution of tokens\n    */\n    contract Presale {\n       \n        using SafeERC20 for IERC20;\n       \n        using SafeMath for uint256;\n       \n        IERC20 private token;\n       \n        address private _owner;\n       \n        // Amount raised in presale\n        uint256 public amountRaisedPresale;\n       \n        address payable private wallet;\n       \n        mapping (address => uint256) private presaleInvestors;\n        uint256 public presaleStartDate;\n        uint256 public presaleEndDate;\n        uint256 public minContribution;\n        uint256 public minCap;\n        uint256 public maxCap;\n        uint public rate=20000000000000;\n   \n        //Tokens for presale\n        uint256 public presaleToken=50000000000000000000000000;\n       \n        //Tokens distributed in presale\n        uint256 public tokenSoldInPresale;\n       \n        // Events\n        event TokenPurchase(address _beneficiary,uint256 amount,uint256 tokens);\n\n        /**\n       * @dev constructor\n       * @param contractAddress Main token contractAddress\n       * @param _targetWallet Address where ether will be transferred\n       * @param _minContribution Minimum contribution in Presale\n       * @param _minCap Minimum cap to make presale successfull\n       * @param _maxCap Maximum cap of presale\n       * @param _endDate Presale end date\n       */\n        constructor(address contractAddress,address payable _targetWallet,uint256 _minContribution,uint256 _minCap,uint256 _maxCap,uint256 _endDate) public {\n            require(_targetWallet != address(0) ,\"Address zero\");\n            require(_minCap >0 && _maxCap>_minCap,\"Value must be greater\");\n            token=IERC20(contractAddress);\n            _owner=msg.sender;\n            wallet=_targetWallet;\n            presaleEndDate = block.timestamp+(60*60*24*_endDate);\n            presaleStartDate = block.timestamp;\n            minContribution = _minContribution;\n            minCap = _minCap;\n            maxCap = _maxCap;\n        }\n        /**\n       * @dev Throws if called by any account other than the owner.\n       */\n        modifier onlyOwner(){\n            require(_owner==msg.sender,\"Only owner\");\n             _;\n        }\n     \n       \n        modifier onlyBeforeEnd() {\n            require(block.timestamp>=presaleStartDate && block.timestamp <= presaleEndDate,\"Closed\");\n            _;\n        }\n   \n        modifier onlyMoreThanMinContribution() {\n            require(msg.value >= minContribution,\"Amount less than the minimum contribution\");\n            _;\n        }\n   \n        modifier onlyMaxCapNotReached() {\n            require(amountRaisedPresale <= maxCap,\"Max cap reached\");\n            _;\n        }\n   \n        /**\n       * @dev Receive function to receive funds\n       */\n        receive() external payable {\n             buyTokens(msg.sender);\n        }\n   \n        /**\n       * @dev Buy tokens .\n       * @param _beneficiary Address that will fund the smart contract and trafer the tokens\n       */\n        function buyTokens(address payable _beneficiary) public onlyBeforeEnd onlyMoreThanMinContribution onlyMaxCapNotReached payable {\n            require(_beneficiary != address(0));\n            uint256 amount=msg.value;\n            require(amount>0,\"Amount must be greater than 0\");\n\n            uint bonus=1;\n            if(amount>=1000000000000000000)\n            {\n                bonus=2;\n            }\n            uint256 tokens= _getTokens(amount);\n           \n            amountRaisedPresale=amountRaisedPresale.add(amount);\n            tokens=tokens.mul(bonus)*1000000000000000000;\n            token.transfer(_beneficiary,tokens);\n            tokenSoldInPresale=tokenSoldInPresale.add(tokens);\n            uint256 amountDeposited= presaleInvestors[_beneficiary];\n            presaleInvestors[_beneficiary]=amountDeposited.add(amount);\n            wallet.transfer(amount);\n            emit TokenPurchase(_beneficiary,amount,tokens);\n        }\n       \n        /**\n         * @dev Admin can close the presale\n         */\n        function closePresale() public onlyOwner{\n            presaleEndDate=block.timestamp;\n        }\n       \n         /**\n         * @dev Calculate number of tokens\n         */\n        function _getTokens(uint256 _amount) internal view returns (uint256 tokens)\n        {\n            uint256 capacityLeft = presaleToken.sub(tokenSoldInPresale);\n            tokens = _amount.div(rate);\n            require(capacityLeft >=tokens,\"Insufficient tokens\");\n            return tokens;\n        }\n       \n        // Check Presale is Closed\n        function checkPresaleClosed() public view returns(bool) {\n            return (block.timestamp>=presaleEndDate);\n        }\n   \n        //check presale failed\n        function checkPresaleFailed() public view returns(bool) {\n            return block.timestamp >= presaleEndDate && amountRaisedPresale < minCap;\n        }\n \n    }"}}}