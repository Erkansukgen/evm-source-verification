{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/ChainBridge.sol": {
      "content": "pragma solidity ^0.8.0;\n\n\nimport \"./Owner.sol\";\nimport \"./IERC20.sol\";\n\ncontract ChainBridge is Owner{\n    \n    IERC20 token;\n    \n    address payable collect;\n    \n    event Cross(address indexed collect,address indexed to_address,uint256 amount);\n    \n    constructor(address _token,address payable _collect) {\n        token = IERC20(_token);\n        collect = _collect;\n    }\n    \n    \n    function cross(address to_address,uint256 amount) public payable {\n        require(token.transferFrom(msg.sender,collect,amount) == true,\"send fail\");\n        collect.transfer(msg.value);\n        emit Cross(collect,to_address,amount);\n    }\n    \n    function deposit() payable public{\n    }\n    \n    function withdraw(uint256 amount) isOwner public{\n        collect.transfer(amount);\n    }\n    \n    function setCollect(address payable _collect) isOwner public{\n        collect = _collect;\n    }\n    \n    function setToken(address _token) isOwner public{\n        token = IERC20(_token);\n    }\n\n    \n    \n    \n}"
    },
    "contracts/IERC20.sol": {
      "content": "pragma solidity ^0.8.0;\n\n/**\n * @title IERC20\n * @dev\n */\n\ninterface IERC20 {\n\n    function transfer(address recipient, uint256 amount) external;\n    function balanceOf(address account) external view returns (uint256);\n   function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    function decimals() external view returns (uint8);\n\n\n}"
    },
    "contracts/Owner.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Owner\n * @dev Set & change owner\n */\ncontract Owner {\n\n    address owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}"
    }
  }
}