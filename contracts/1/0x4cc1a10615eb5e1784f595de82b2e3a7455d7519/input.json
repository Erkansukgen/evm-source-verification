{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/lib/SafeMath.sol":{"content":"pragma solidity >=0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"},"contracts/yvboostv2.sol":{"content":"pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nimport './lib/SafeMath.sol';\r\n\r\n\r\ninterface IWETH {\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\n\r\ninterface yvault{\r\n    function deposit(uint256 amount, address receiver) external returns (uint256);\r\n    function withdraw(uint256 amount, address receiver) external returns(uint256);\r\n    function pricePerShare() external view returns(uint256);\r\n}\r\n\r\n\r\n\r\ninterface v2pool{\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n\r\n\r\n\r\ncontract yvboostv2 {\r\n    using SafeMath for uint;\r\n    \r\n    address payable public owner;\r\n    \r\n    \r\n    // main net\r\n    \r\n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        IERC20(address(0xc5bDdf9843308380375a611c18B50Fb9341f502A)).approve(address(0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a),\r\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n\r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n\r\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\r\n    \r\n        (uint256 param1, uint256 param2, uint256 param3)  = abi.decode(_data, (uint256, uint256, uint256));\r\n\r\n        if(msg.sender == address(0x10B47177E92Ef9D5C6059055d92DdF6290848991)){\r\n            // deposit arb\r\n            yvault(address(0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a)).deposit(param1, address(0x9461173740D27311b176476FA27e94C681b1Ea6b));\r\n            \r\n            v2pool(address(0x9461173740D27311b176476FA27e94C681b1Ea6b)).swap(0, param2, address(this), new bytes(0));\r\n            \r\n            IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, param3);\r\n        }\r\n        \r\n\r\n        if(msg.sender == address(0x9461173740D27311b176476FA27e94C681b1Ea6b)){\r\n            // withdraw arb\r\n            yvault(address(0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a)).withdraw(param1, address(0x10B47177E92Ef9D5C6059055d92DdF6290848991));\r\n            \r\n            v2pool(address(0x10B47177E92Ef9D5C6059055d92DdF6290848991)).swap(param2, 0, address(this), new bytes(0));\r\n            \r\n            IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, param3);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function deposit_arb(uint256 yvecrv_out, uint256 weth_out, uint256 weth_in) public payable{\r\n        // check the blknum to avoid the uncle blk pack\r\n        if(block.number > msg.value){\r\n            return;\r\n        }     \r\n        uint256 gasstart = gasleft();\r\n        \r\n        bytes memory data = abi.encode(yvecrv_out, weth_out, weth_in);\r\n        \r\n        // flash loan yvecrv\r\n        v2pool(address(0x10B47177E92Ef9D5C6059055d92DdF6290848991)).swap(0, yvecrv_out, address(this), data);\r\n\r\n\r\n\r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n        \r\n        require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance - 1);\r\n       \r\n    }\r\n\r\n\r\n\r\n\r\n    function deposit_arb_mem(uint256 weth_in, uint256 totalsupply, uint256 totalasset, uint256 minbenefit) public {\r\n        bytes memory returnData;\r\n        // yvecrv-eth\r\n        (, returnData) = address(0x10B47177E92Ef9D5C6059055d92DdF6290848991).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // weth, yvecrv\r\n        // weth-yvboost\r\n        (, returnData) = address(0x9461173740D27311b176476FA27e94C681b1Ea6b).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint reserve2,uint reserve3, ) = abi.decode(returnData, (uint,uint,uint)); // yvboost, weth\r\n\r\n        uint256 yvecrv_out = getAmountOut(weth_in, reserve0, reserve1);\r\n        uint256 yboost_out = yvecrv_out * totalsupply / totalasset;\r\n        uint256 weth_out = getAmountOut(yboost_out, reserve2, reserve3);\r\n\r\n        \r\n        require(weth_out > weth_in + minbenefit, \"shit\");\r\n\r\n\r\n        bytes memory data = abi.encode(yvecrv_out, weth_out, weth_in);\r\n        \r\n        // flash loan yvecrv\r\n        v2pool(address(0x10B47177E92Ef9D5C6059055d92DdF6290848991)).swap(0, yvecrv_out, address(this), data);\r\n\r\n\r\n\r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n        \r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance - 1);\r\n       \r\n    }\r\n\r\n\r\n    function withdraw_arb(uint256 yvboost_out, uint256 weth_out, uint256 weth_in) public payable{\r\n        // check the blknum to avoid the uncle blk pack\r\n        if(block.number > msg.value){\r\n            return;\r\n        }     \r\n        uint256 gasstart = gasleft();\r\n        \r\n        bytes memory data = abi.encode(yvboost_out, weth_out, weth_in);\r\n        \r\n        // flash loan yvboost\r\n        v2pool(address(0x9461173740D27311b176476FA27e94C681b1Ea6b)).swap(yvboost_out, 0, address(this), data);\r\n\r\n\r\n\r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n        \r\n        require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance - 1);\r\n       \r\n    }\r\n\r\n\r\n    function withdraw_arb_mem(uint256 weth_in, uint256 minbenefit) public{\r\n\r\n        bytes memory returnData;\r\n        // yvecrv-eth\r\n        (, returnData) = address(0x10B47177E92Ef9D5C6059055d92DdF6290848991).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // weth, yvecrv\r\n        // weth-yvboost\r\n        (, returnData) = address(0x9461173740D27311b176476FA27e94C681b1Ea6b).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint reserve2,uint reserve3, ) = abi.decode(returnData, (uint,uint,uint)); // yvboost, weth\r\n\r\n        uint256 pricePerShare = yvault(address(0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a)).pricePerShare();\r\n\r\n        uint256 yvboost_out = getAmountOut(weth_in, reserve3, reserve2);\r\n        uint256 yvecrv_out = yvboost_out * pricePerShare / 10**18;\r\n        uint256 weth_out = getAmountOut(yvecrv_out, reserve1, reserve0);\r\n\r\n        require(weth_out > weth_in + minbenefit, \"shit\");\r\n\r\n        \r\n        bytes memory data = abi.encode(yvboost_out, weth_out, weth_in);\r\n        \r\n        // flash loan yvboost\r\n        v2pool(address(0x9461173740D27311b176476FA27e94C681b1Ea6b)).swap(yvboost_out, 0, address(this), data);\r\n\r\n\r\n\r\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n        \r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance - 1);\r\n       \r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    } \r\n\r\n\r\n\r\n\r\n    function yvarb_deposit(uint256 lowerbound, uint256 higherbound , uint256 step, uint256 totalsupply, uint256 totalasset) \r\n                public view returns(uint256 best_profit, uint256 best_in, uint256 best_crv_out, uint256 best_weth_out) {\r\n        bytes memory returnData;\r\n        // yvecrv-eth\r\n        (, returnData) = address(0x10B47177E92Ef9D5C6059055d92DdF6290848991).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // weth, yvecrv\r\n        // weth-yvboost\r\n        (, returnData) = address(0x9461173740D27311b176476FA27e94C681b1Ea6b).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint reserve2,uint reserve3, ) = abi.decode(returnData, (uint,uint,uint)); // yvboost, weth\r\n\r\n        uint256 amountin = lowerbound;\r\n\r\n        while(lowerbound < higherbound){\r\n\r\n            uint256 yvecrv_out = getAmountOut(amountin, reserve0, reserve1);\r\n            uint256 yboost_out = yvecrv_out * totalsupply / totalasset;\r\n            uint256 weth_out = getAmountOut(yboost_out, reserve2, reserve3);\r\n            \r\n            if(weth_out < amountin){\r\n                break;\r\n            }\r\n            \r\n            if(weth_out - amountin > best_profit){\r\n                best_profit = weth_out - amountin;\r\n                best_in = amountin;\r\n                best_crv_out = yvecrv_out;\r\n                best_weth_out = weth_out;\r\n                amountin = amountin + step;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function yvarb_withdraw(uint256 lowerbound, uint256 higherbound , uint256 step) \r\n                public view returns(uint256 best_profit, uint256 best_in, uint256 best_yvboost_out, uint256 best_weth_out) {\r\n        bytes memory returnData;\r\n        // yvecrv-eth\r\n        (, returnData) = address(0x10B47177E92Ef9D5C6059055d92DdF6290848991).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // weth, yvecrv\r\n        // weth-yvboost\r\n        (, returnData) = address(0x9461173740D27311b176476FA27e94C681b1Ea6b).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (uint reserve2,uint reserve3, ) = abi.decode(returnData, (uint,uint,uint)); // yvboost, weth\r\n\r\n        uint256 amountin = lowerbound;\r\n\r\n        uint256 pricePerShare = yvault(address(0x9d409a0A012CFbA9B15F6D4B36Ac57A46966Ab9a)).pricePerShare();\r\n\r\n\r\n        while(lowerbound < higherbound){\r\n\r\n            uint256 yvboost_out = getAmountOut(amountin, reserve3, reserve2);\r\n            uint256 yvecrv_out = yvboost_out * pricePerShare / 10**18;\r\n            uint256 weth_out = getAmountOut(yvecrv_out, reserve1, reserve0);\r\n            \r\n            if(weth_out < amountin){\r\n                break;\r\n            }\r\n            \r\n            if(weth_out - amountin > best_profit){\r\n                best_profit = weth_out - amountin;\r\n                best_in = amountin;\r\n                best_yvboost_out = yvboost_out;\r\n                best_weth_out = weth_out;\r\n                amountin = amountin + step;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n}"}}}