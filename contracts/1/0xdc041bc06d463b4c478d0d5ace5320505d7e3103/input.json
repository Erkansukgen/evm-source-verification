{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"OfficialSale.sol":{"content":"// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/interface/MinterMintable.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface MinterMintable {\r\n    function isMinter(address check) external view returns (bool);\r\n    function mint(address owner) external returns (uint256);\r\n    function batchMint(address owner, uint256 amount) external returns (uint256[] memory);\r\n}\r\n\r\n// File: contracts/OfficialSale.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n\r\ncontract OfficialSale is Ownable {\r\n\r\n    MinterMintable _minterMintable_;\r\n\r\n    constructor(address ghettoSharkhoodAddress) {\r\n        _minterMintable_ = MinterMintable(ghettoSharkhoodAddress);\r\n    }\r\n\r\n    function price() public view returns (uint256) {\r\n        if (block.timestamp <= whitelistUnlockAt()) return 0.085 ether;\r\n        \r\n        return 0.09 ether;\r\n    }\r\n\r\n    function whitelistUnlockAt() public virtual pure returns (uint256) {\r\n        return 1639360800;\r\n    }\r\n\r\n    // Whitelist\r\n\r\n    struct buyerData {\r\n        uint256 cap; // the max number of NFT buyer can buy\r\n        uint256 bought; // the number of NFT buyer have bought\r\n    }\r\n\r\n    mapping(address => buyerData) _buyers_;\r\n\r\n    /**\r\n     * This purpose of this function is to check whether buyer can buy,\r\n     */\r\n    modifier onlyAllowedBuyer(uint256 amount) {\r\n\r\n        /**\r\n         * only if block.timestamp less than whitelistUnlockAt will check buyer cap\r\n         */\r\n        if (block.timestamp <= whitelistUnlockAt()) {\r\n            require(\r\n                _buyers_[msg.sender].bought < _buyers_[msg.sender].cap\r\n                && _buyers_[msg.sender].bought + amount > _buyers_[msg.sender].bought\r\n                && _buyers_[msg.sender].bought + amount <= _buyers_[msg.sender].cap, \r\n                \"Presale: this address hasn't been added to whitelist.\"\r\n            );\r\n        }\r\n        \r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Set buyer cap, only owner can do this operation, and this function can be call before closing.\r\n     */\r\n    function setBuyerCap(address buyer, uint256 cap) public onlyOwner onlyOpened {\r\n        _buyers_[buyer].cap = cap;\r\n    }\r\n\r\n    /**\r\n     * This function can help owner to add larger than one addresses cap.\r\n     */\r\n    function setBuyerCapBatch(address[] memory buyers, uint256[] memory amount) public onlyOwner onlyOpened {\r\n        require(buyers.length == amount.length, \"Presale: buyers length and amount length not match\");\r\n        require(buyers.length <= 100, \"Presale: the max size of batch is 100.\");\r\n\r\n        for(uint256 i = 0; i < buyers.length; i ++) {\r\n            _buyers_[buyers[i]].cap = amount[i];\r\n        }\r\n    }\r\n\r\n    function buyerCap(address buyer) public view returns (uint256) {\r\n        return _buyers_[buyer].cap;\r\n    }\r\n\r\n    function buyerBought(address buyer) public view returns (uint256) {\r\n        return _buyers_[buyer].bought;\r\n    }\r\n\r\n    // withdraw related functions\r\n\r\n    function withdraw() public onlyOwner {\r\n        address payable receiver = payable(owner());\r\n        receiver.transfer(address(this).balance);\r\n    }\r\n\r\n    // open and start control\r\n    bool _opened_ = true;\r\n    bool _started_ = false;\r\n\r\n    modifier onlyOpened() {\r\n        require(_opened_, \"Presale: presale has been closed.\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyStart() {\r\n        require(_started_, \"Presale: presale is not now.\");\r\n        _;\r\n    }\r\n\r\n    function start() public onlyOwner onlyOpened {\r\n        _started_ = true;\r\n    }\r\n\r\n    function end() public onlyOwner onlyOpened {\r\n        _started_ = false;\r\n    }\r\n\r\n    function close() public onlyOwner onlyOpened {\r\n        _started_ = false;\r\n        _opened_ = false;\r\n    }\r\n\r\n    function started() public view returns (bool) {\r\n        return _started_;\r\n    }\r\n\r\n    function opened() public view returns (bool) {\r\n        return _opened_;\r\n    }\r\n\r\n    // Presale\r\n\r\n    uint256 _sold_ = 0;\r\n\r\n    /**\r\n     * Only pay larger than or equal to total price will\r\n     */\r\n    modifier onlyPayEnoughEth(uint256 amount) {\r\n        require(msg.value >= amount * price(), \"Presale: please pay enough ETH to buy.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Buy one NFT in one transaction\r\n     */\r\n    function buy() public payable \r\n        onlyOpened\r\n        onlyStart\r\n        onlyAllowedBuyer(1) \r\n        onlyPayEnoughEth(1)\r\n        returns (uint256) {\r\n        _sold_ += 1;\r\n        // if whitelist still active, add number of bought\r\n        _buyers_[msg.sender].bought += 1;\r\n        return _minterMintable_.mint(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Buy numbers of NFT in one transaction.\r\n     * It will also increase the number of NFT buyer has bought.\r\n     */\r\n    function buyBatch(uint256 amount) public payable \r\n        onlyOpened\r\n        onlyStart\r\n        onlyAllowedBuyer(amount) \r\n        onlyPayEnoughEth(amount)\r\n        returns (uint256[] memory) {\r\n        require(amount <= 20, \"Presale: batch size should less than 20.\");\r\n        require(amount >= 1, \"Presale: batch size should larger than 0.\");\r\n        _sold_ += amount;\r\n        // if whitelist still active, add number of bought\r\n        _buyers_[msg.sender].bought += amount;\r\n        return _minterMintable_.batchMint(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * Get the number of NFT has been sold during presale\r\n     */\r\n    function sold() public view returns (uint256) {\r\n        return _sold_;\r\n    }\r\n\r\n}"}}}