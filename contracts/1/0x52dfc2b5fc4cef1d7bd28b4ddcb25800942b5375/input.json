{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/MonkeyInu.sol":{"content":"\r/**\r *Submitted for verification at Etherscan.io on 2021-06-23\r*/\r\r//MonkeyInu (MonkeyInu)\r//Powerful Bot Protect yes\r\r//2% Deflationary yes\r//Telegram: https://t.me/MonkeyInuOfficial\r//Website: https://www.monkeyinu.com\r\r//CG, CMC listing: Ongoing\r//Fair Launch\r//Community Driven - 100% Community Owned!\r\r\r// SPDX-License-Identifier: Unlicensed\rpragma solidity ^0.8.4;\r\rabstract contract Context {\r    function _msgSender() internal view virtual returns (address) {\r        return msg.sender;\r    }\r}\r\rinterface IERC20 {\r    function totalSupply() external view returns (uint256);\r\r    function balanceOf(address account) external view returns (uint256);\r\r    function transfer(address recipient, uint256 amount)\r        external\r        returns (bool);\r\r    function allowance(address owner, address spender)\r        external\r        view\r        returns (uint256);\r\r    function approve(address spender, uint256 amount) external returns (bool);\r\r    function transferFrom(\r        address sender,\r        address recipient,\r        uint256 amount\r    ) external returns (bool);\r\r    event Transfer(address indexed from, address indexed to, uint256 value);\r    event Approval(\r        address indexed owner,\r        address indexed spender,\r        uint256 value\r    );\r}\r\rlibrary SafeMath {\r    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r        uint256 c = a + b;\r        require(c >= a, \"SafeMath: addition overflow\");\r        return c;\r    }\r\r    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r        return sub(a, b, \"SafeMath: subtraction overflow\");\r    }\r\r    function sub(\r        uint256 a,\r        uint256 b,\r        string memory errorMessage\r    ) internal pure returns (uint256) {\r        require(b <= a, errorMessage);\r        uint256 c = a - b;\r        return c;\r    }\r\r    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r        if (a == 0) {\r            return 0;\r        }\r        uint256 c = a * b;\r        require(c / a == b, \"SafeMath: multiplication overflow\");\r        return c;\r    }\r\r    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r        return div(a, b, \"SafeMath: division by zero\");\r    }\r\r    function div(\r        uint256 a,\r        uint256 b,\r        string memory errorMessage\r    ) internal pure returns (uint256) {\r        require(b > 0, errorMessage);\r        uint256 c = a / b;\r        return c;\r    }\r}\r\rcontract Ownable is Context {\r    address private _owner;\r    address private _previousOwner;\r    event OwnershipTransferred(\r        address indexed previousOwner,\r        address indexed newOwner\r    );\r\r    constructor() {\r        address msgSender = _msgSender();\r        _owner = msgSender;\r        emit OwnershipTransferred(address(0), msgSender);\r    }\r\r    function owner() public view returns (address) {\r        return _owner;\r    }\r\r    modifier onlyOwner() {\r        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r        _;\r    }\r\r    function renounceOwnership() public virtual onlyOwner {\r        emit OwnershipTransferred(_owner, address(0));\r        _owner = address(0);\r    }\r}\r\rinterface IUniswapV2Factory {\r    function createPair(address tokenA, address tokenB)\r        external\r        returns (address pair);\r}\r\rinterface IUniswapV2Router02 {\r    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r        uint256 amountIn,\r        uint256 amountOutMin,\r        address[] calldata path,\r        address to,\r        uint256 deadline\r    ) external;\r\r    function factory() external pure returns (address);\r\r    function WETH() external pure returns (address);\r\r    function addLiquidityETH(\r        address token,\r        uint256 amountTokenDesired,\r        uint256 amountTokenMin,\r        uint256 amountETHMin,\r        address to,\r        uint256 deadline\r    )\r        external\r        payable\r        returns (\r            uint256 amountToken,\r            uint256 amountETH,\r            uint256 liquidity\r        );\r}\r\rcontract MonkeyInu is Context, IERC20, Ownable {\r    using SafeMath for uint256;\r\r    string private constant _name = \"MonkeyInu | t.me/MonkeyInuOfficial\";\r    string private constant _symbol = \"MonkeyInu\\xF0\\x9F\\x99\\x88\";\r    uint8 private constant _decimals = 9;\r\r    // RFI\r    mapping(address => uint256) private _rOwned;\r    mapping(address => uint256) private _tOwned;\r    mapping(address => mapping(address => uint256)) private _allowances;\r    mapping(address => bool) private _isExcludedFromFee;\r    uint256 private constant MAX = ~uint256(0);\r    uint256 private constant _tTotal = 1000000000000 * 10**9;\r    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r    uint256 private _tFeeTotal;\r    uint256 private _taxFee = 2;\r    uint256 private _teamFee = 12;\r\r    // Bot detection\r    mapping(address => bool) private bots;\r    mapping(address => uint256) private cooldown;\r    address payable private _teamAddress;\r    address payable private _marketingFunds;\r    IUniswapV2Router02 private uniswapV2Router;\r    address private uniswapV2Pair;\r    bool private tradingOpen;\r    bool private inSwap = false;\r    bool private swapEnabled = false;\r    bool private cooldownEnabled = false;\r    uint256 private _maxTxAmount = _tTotal;\r\r    event MaxTxAmountUpdated(uint256 _maxTxAmount);\r    modifier lockTheSwap {\r        inSwap = true;\r        _;\r        inSwap = false;\r    }\r\r    constructor(address payable addr1, address payable addr2) {\r        _teamAddress = addr1;\r        _marketingFunds = addr2;\r        _rOwned[_msgSender()] = _rTotal;\r        _isExcludedFromFee[owner()] = true;\r        _isExcludedFromFee[address(this)] = true;\r        _isExcludedFromFee[_teamAddress] = true;\r        _isExcludedFromFee[_marketingFunds] = true;\r        emit Transfer(address(0), _msgSender(), _tTotal);\r    }\r\r    function name() public pure returns (string memory) {\r        return _name;\r    }\r\r    function symbol() public pure returns (string memory) {\r        return _symbol;\r    }\r\r    function decimals() public pure returns (uint8) {\r        return _decimals;\r    }\r\r    function totalSupply() public pure override returns (uint256) {\r        return _tTotal;\r    }\r\r    function balanceOf(address account) public view override returns (uint256) {\r        return tokenFromReflection(_rOwned[account]);\r    }\r\r    function transfer(address recipient, uint256 amount)\r        public\r        override\r        returns (bool)\r    {\r        _transfer(_msgSender(), recipient, amount);\r        return true;\r    }\r\r    function allowance(address owner, address spender)\r        public\r        view\r        override\r        returns (uint256)\r    {\r        return _allowances[owner][spender];\r    }\r\r    function approve(address spender, uint256 amount)\r        public\r        override\r        returns (bool)\r    {\r        _approve(_msgSender(), spender, amount);\r        return true;\r    }\r\r    function transferFrom(\r        address sender,\r        address recipient,\r        uint256 amount\r    ) public override returns (bool) {\r        _transfer(sender, recipient, amount);\r        _approve(\r            sender,\r            _msgSender(),\r            _allowances[sender][_msgSender()].sub(\r                amount,\r                \"ERC20: transfer amount exceeds allowance\"\r            )\r        );\r        return true;\r    }\r\r    function setCooldownEnabled(bool onoff) external onlyOwner() {\r        cooldownEnabled = onoff;\r    }\r\r    function tokenFromReflection(uint256 rAmount)\r        private\r        view\r        returns (uint256)\r    {\r        require(\r            rAmount <= _rTotal,\r            \"Amount must be less than total reflections\"\r        );\r        uint256 currentRate = _getRate();\r        return rAmount.div(currentRate);\r    }\r\r    function removeAllFee() private {\r        if (_taxFee == 0 && _teamFee == 0) return;\r        _taxFee = 0;\r        _teamFee = 0;\r    }\r\r    function restoreAllFee() private {\r        _taxFee = 2;\r        _teamFee = 12;\r    }\r\r    function _approve(\r        address owner,\r        address spender,\r        uint256 amount\r    ) private {\r        require(owner != address(0), \"ERC20: approve from the zero address\");\r        require(spender != address(0), \"ERC20: approve to the zero address\");\r        _allowances[owner][spender] = amount;\r        emit Approval(owner, spender, amount);\r    }\r\r    function _transfer(\r        address from,\r        address to,\r        uint256 amount\r    ) private {\r        require(from != address(0), \"ERC20: transfer from the zero address\");\r        require(to != address(0), \"ERC20: transfer to the zero address\");\r        require(amount > 0, \"Transfer amount must be greater than zero\");\r\r        if (from != owner() && to != owner()) {\r            if (cooldownEnabled) {\r                if (\r                    from != address(this) &&\r                    to != address(this) &&\r                    from != address(uniswapV2Router) &&\r                    to != address(uniswapV2Router)\r                ) {\r                    require(\r                        _msgSender() == address(uniswapV2Router) ||\r                            _msgSender() == uniswapV2Pair,\r                        \"ERR: Uniswap only\"\r                    );\r                }\r            }\r            require(amount <= _maxTxAmount);\r            require(!bots[from] && !bots[to]);\r            if (\r                from == uniswapV2Pair &&\r                to != address(uniswapV2Router) &&\r                !_isExcludedFromFee[to] &&\r                cooldownEnabled\r            ) {\r                require(cooldown[to] < block.timestamp);\r                cooldown[to] = block.timestamp + (60 seconds);\r            }\r            uint256 contractTokenBalance = balanceOf(address(this));\r            if (!inSwap && from != uniswapV2Pair && swapEnabled) {\r                swapTokensForEth(contractTokenBalance);\r                uint256 contractETHBalance = address(this).balance;\r                if (contractETHBalance > 0) {\r                    sendETHToFee(address(this).balance);\r                }\r            }\r        }\r        bool takeFee = true;\r\r        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\r            takeFee = false;\r        }\r\r        _tokenTransfer(from, to, amount, takeFee);\r    }\r\r    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r        address[] memory path = new address[](2);\r        path[0] = address(this);\r        path[1] = uniswapV2Router.WETH();\r        _approve(address(this), address(uniswapV2Router), tokenAmount);\r        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r            tokenAmount,\r            0,\r            path,\r            address(this),\r            block.timestamp\r        );\r    }\r\r    function sendETHToFee(uint256 amount) private {\r        _teamAddress.transfer(amount.mul(4).div(10));\r        _marketingFunds.transfer(amount.mul(6).div(10));\r    }\r\r    function openTrading() external onlyOwner() {\r        require(!tradingOpen, \"trading is already open\");\r        IUniswapV2Router02 _uniswapV2Router =\r            IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r        uniswapV2Router = _uniswapV2Router;\r        _approve(address(this), address(uniswapV2Router), _tTotal);\r        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r            .createPair(address(this), _uniswapV2Router.WETH());\r        uniswapV2Router.addLiquidityETH{value: address(this).balance}(\r            address(this),\r            balanceOf(address(this)),\r            0,\r            0,\r            owner(),\r            block.timestamp\r        );\r        swapEnabled = true;\r        cooldownEnabled = true;\r        _maxTxAmount = 2500000000 * 10**9;\r        tradingOpen = true;\r        IERC20(uniswapV2Pair).approve(\r            address(uniswapV2Router),\r            type(uint256).max\r        );\r    }\r\r    function manualswap() external {\r        require(_msgSender() == _teamAddress);\r        uint256 contractBalance = balanceOf(address(this));\r        swapTokensForEth(contractBalance);\r    }\r\r    function manualsend() external {\r        require(_msgSender() == _teamAddress);\r        uint256 contractETHBalance = address(this).balance;\r        sendETHToFee(contractETHBalance);\r    }\r\r    function setBots(address[] memory bots_) public onlyOwner {\r        for (uint256 i = 0; i < bots_.length; i++) {\r            bots[bots_[i]] = true;\r        }\r    }\r\r    function delBot(address notbot) public onlyOwner {\r        bots[notbot] = false;\r    }\r\r    function _tokenTransfer(\r        address sender,\r        address recipient,\r        uint256 amount,\r        bool takeFee\r    ) private {\r        if (!takeFee) removeAllFee();\r        _transferStandard(sender, recipient, amount);\r        if (!takeFee) restoreAllFee();\r    }\r\r    function _transferStandard(\r        address sender,\r        address recipient,\r        uint256 tAmount\r    ) private {\r        (\r            uint256 rAmount,\r            uint256 rTransferAmount,\r            uint256 rFee,\r            uint256 tTransferAmount,\r            uint256 tFee,\r            uint256 tTeam\r        ) = _getValues(tAmount);\r        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r        _takeTeam(tTeam);\r        _reflectFee(rFee, tFee);\r        emit Transfer(sender, recipient, tTransferAmount);\r    }\r\r    function _takeTeam(uint256 tTeam) private {\r        uint256 currentRate = _getRate();\r        uint256 rTeam = tTeam.mul(currentRate);\r        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);\r    }\r\r    function _reflectFee(uint256 rFee, uint256 tFee) private {\r        _rTotal = _rTotal.sub(rFee);\r        _tFeeTotal = _tFeeTotal.add(tFee);\r    }\r\r    receive() external payable {}\r\r    function _getValues(uint256 tAmount)\r        private\r        view\r        returns (\r            uint256,\r            uint256,\r            uint256,\r            uint256,\r            uint256,\r            uint256\r        )\r    {\r        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) =\r            _getTValues(tAmount, _taxFee, _teamFee);\r        uint256 currentRate = _getRate();\r        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =\r            _getRValues(tAmount, tFee, tTeam, currentRate);\r        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);\r    }\r\r    function _getTValues(\r        uint256 tAmount,\r        uint256 taxFee,\r        uint256 TeamFee\r    )\r        private\r        pure\r        returns (\r            uint256,\r            uint256,\r            uint256\r        )\r    {\r        uint256 tFee = tAmount.mul(taxFee).div(100);\r        uint256 tTeam = tAmount.mul(TeamFee).div(100);\r        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);\r        return (tTransferAmount, tFee, tTeam);\r    }\r\r    function _getRValues(\r        uint256 tAmount,\r        uint256 tFee,\r        uint256 tTeam,\r        uint256 currentRate\r    )\r        private\r        pure\r        returns (\r            uint256,\r            uint256,\r            uint256\r        )\r    {\r        uint256 rAmount = tAmount.mul(currentRate);\r        uint256 rFee = tFee.mul(currentRate);\r        uint256 rTeam = tTeam.mul(currentRate);\r        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);\r        return (rAmount, rTransferAmount, rFee);\r    }\r\r    function _getRate() private view returns (uint256) {\r        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r        return rSupply.div(tSupply);\r    }\r\r    function _getCurrentSupply() private view returns (uint256, uint256) {\r        uint256 rSupply = _rTotal;\r        uint256 tSupply = _tTotal;\r        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r        return (rSupply, tSupply);\r    }\r\r    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\r        require(maxTxPercent > 0, \"Amount must be greater than 0\");\r        _maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);\r        emit MaxTxAmountUpdated(_maxTxAmount);\r    }\r}"}}}