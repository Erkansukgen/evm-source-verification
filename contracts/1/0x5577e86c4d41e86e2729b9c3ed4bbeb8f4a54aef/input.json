{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/liquidation.sol": {
      "content": "pragma solidity ^0.8.6;\n\n//ERC20 interface\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n//Compound cERC20 interface\ninterface CErc20 {\n  function balanceOf(address) external view returns (uint);\n  function mint(uint) external returns (uint);\n  function exchangeRateCurrent() external returns (uint);\n  function supplyRatePerBlock() external returns (uint);\n  function balanceOfUnderlying(address) external returns (uint);\n  function redeem(uint) external returns (uint);\n  function redeemUnderlying(uint) external returns (uint);\n  function borrow(uint) external returns (uint);\n  function borrowBalanceCurrent(address) external returns (uint);\n  function borrowRatePerBlock() external view returns (uint);\n  function repayBorrow(uint) external returns (uint);\n  function liquidateBorrow(\n    address borrower,\n    uint amount,\n    address collateral\n  ) external returns (uint);\n}\n\n//Compound CETH interface\ninterface CEth {\n  function balanceOf(address) external view returns (uint);\n  function mint() external payable;\n  function exchangeRateCurrent() external returns (uint);\n  function supplyRatePerBlock() external returns (uint);\n  function balanceOfUnderlying(address) external returns (uint);\n  function redeem(uint) external returns (uint);\n  function redeemUnderlying(uint) external returns (uint);\n  function borrow(uint) external returns (uint);\n  function borrowBalanceCurrent(address) external returns (uint);\n  function borrowRatePerBlock() external view returns (uint);\n  function repayBorrow() external payable;\n}\n\n//Compound Comptroller interface\ninterface Comptroller {\n  function markets(address)\n    external\n    view\n    returns (\n      bool,\n      uint,\n      bool\n    );\n  function enterMarkets(address[] calldata) external returns (uint[] memory);\n  function getAccountLiquidity(address)\n    external\n    view\n    returns (\n      uint,\n      uint,\n      uint\n    );\n  function closeFactorMantissa() external view returns (uint);\n  function liquidationIncentiveMantissa() external view returns (uint);\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint actualRepayAmount\n  ) external view returns (uint, uint);\n}\n\n//Compound price feed interface\ninterface PriceFeed {\n  function getUnderlyingPrice(address cToken) external view returns (uint);\n}\n\ncontract performLiquidationOnCompound {\n\n//set several state variables\n   IERC20 public token;\n   CErc20 public ctoken;\n   Comptroller public comptroller = Comptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n   PriceFeed public priceFeed = PriceFeed(0x922018674c12a7F0D394ebEEf9B58F186CdE13c1);\n\n//set token\n    function settoken(address _token) public {\n        token = IERC20(_token);\n    }\n\n\n//set ctoken - Compound token\n    function setctoken(address _ctoken) public {\n        ctoken = CErc20(_ctoken);\n    }\n\n\n  //call on the comptroller contract\n  //close factor is the maximum percentage of borrowed tokens that can be repayed\n  //a percent ranging from 0% to 100% of a liquidatable accountâ€™s borrow.\n  //if you want to view this as a percentage divide the result by 10**18 \n  function closeFactor() external view returns (uint) {\n      return comptroller.closeFactorMantissa();\n  }\n\n  //call on the comptroller contract\n  //liquidation incentive is your incentive amount to liquidate the contract\n  //you are rewarded with a portion of the token that was supplied as collateral\n  //you receive the collateral at a discount aka your incentive\n  function liquidationIncentive() external view returns (uint) {\n    return comptroller.liquidationIncentiveMantissa();\n  }\n\n  //call on the comptroller contract\n  //get the exact amount of collateral to be liquidated\n  function amountToBeLiquidatedSieze(address _cToken, address _cTokenCollateral, uint _actualRepayAmount) external view returns (uint) {\n    (uint error, uint cTokenCollateralAmount) = comptroller\n    .liquidateCalculateSeizeTokens(\n      _cToken,\n      _cTokenCollateral,\n      _actualRepayAmount\n    );\n    require(error == 0, \"error\");\n    return cTokenCollateralAmount;\n  }\n\n  //Call liquidate borrow on the cToken contract\n  //liquidate takes 3 parameters\n  //the address of the borrower, amount that you will repay, and ctoken address that we will receive in return for liquidating the account  \n  function liquidate(address _borrower, uint _repayAmount, address _cTokenCollateral) external {\n  //transfer the token borrowed from mesage.sender to this contract\n    token.transferFrom(msg.sender, address(this), _repayAmount);\n  //then approve the ctoken repay amount to be spent\n    token.approve(address(ctoken), _repayAmount);\n  //call liquidate borrow in the ctoken contract and passing in the necessary parameters using a require statement\n  //a successful liquidate borrow will return o\n  //if the call is not successful liquidation failed will display\n    require(ctoken.liquidateBorrow(_borrower, _repayAmount, _cTokenCollateral) == 0, \"liquidation failed\");\n  }\n\n  function getPriceFeed(address _ctoken) external view returns (uint) {\n    return priceFeed.getUnderlyingPrice(_ctoken);\n  }\n\n}"
    }
  }
}