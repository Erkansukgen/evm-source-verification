{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Amplius.sol":{"content":"pragma solidity >= 0.7;\n\ncontract Ampl {\n    \n    // registration of claims by Merkle root (bytes32)\n    mapping(bytes32 => Claim) public claimRegistry;\n    \n    // registration of links by link ID (36 character ASCII name)\n    mapping(bytes32 => Link) public linkRegistry;\n\n    // registration of URI schemes by auto-incrementing ID (0 < ID <= nMimeTypeRegistry)\n    mapping(uint8 => bytes32) public mimeTypeRegistry;\n    uint8 public nMimeTypeRegistry = 0;\n    \n    // registration of URI schemes by auto-incrementing ID (0 < ID <= nUriSchemeRegistry)\n    mapping(uint8 => bytes32) public uriSchemeRegistry;\n    uint8 public nUriSchemeRegistry = 0;\n    \n    // registration of URI authorities by auto-incrementing ID (0 < ID <= nUriAuthorityRegistry)\n    mapping(uint16 => bytes32) public uriAuthorityRegistry;\n    uint16 public nUriAuthorityRegistry = 0;\n    \n    uint256 deployment_time;\n    \n    // attestation claim data, stored by Merkle root in claimRegistry\n    struct Claim {\n        // registration of claim issuers by claim record ID (0 < ID <= nClaimRecords)\n        mapping(uint8 => IssuerMetadata) issuerMetadata;\n        // registration of storage metadata by claim record ID (0 < ID <= nClaimRecords)\n        mapping(uint8 => StorageMetadata) storageMetadata;\n        uint8 nClaimRecords;\n    }\n\n    // URI scheme and authority\n    struct StorageMetadata {\n        uint16 timestamp;\n        uint8 mimeTypeID;\n        mapping(uint8 => StorageURI) storageURI;\n    }\n\n    // URIs of stored file sets and extensions consisting of scheme, authority, path\n    struct StorageURI {\n        uint8 fileSetExtensionMarker;\n        uint8 schemeID;\n        uint16 authorityID;\n        bytes32 path;\n    }\n\n    // issuer meta data of a claim\n    struct IssuerMetadata {\n        address accountAddress;\n        bytes32 externalDID;\n    }\n   \n    // link data, references a claim controlled by the link issuer\n    struct Link {\n        bytes32 merkleRoot;\n        address linkIssuer;\n        bytes32 parentLinkID;\n    }\n    \n    constructor() {\n        deployment_time = block.timestamp;\n        // possibly add to constructor\n        //ens = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\n    }\n\n    function recordClaim(bytes32 merkleRoot, uint8[] calldata schemeIDs, uint16[] calldata authorityIDs, \n        bytes32[] calldata paths, uint8[] calldata fileSetExtensionMarker, uint8 mimeTypeID) public {\n\n        require(schemeIDs.length == authorityIDs.length && schemeIDs.length == paths.length, \"schema IDs, autority IDs, paths differ in length\");\n\n        uint8 nClaimRecords = claimRegistry[merkleRoot].nClaimRecords + 1;\n        \n        claimRegistry[merkleRoot].issuerMetadata[nClaimRecords].accountAddress = msg.sender;\n        claimRegistry[merkleRoot].storageMetadata[nClaimRecords].timestamp = uint16(block.timestamp - deployment_time);\n        claimRegistry[merkleRoot].storageMetadata[nClaimRecords].mimeTypeID = mimeTypeID;\n        \n        for (uint8 i=0; i<schemeIDs.length; i++) {\n            \n            if (i == 0 || schemeIDs[i] != schemeIDs[i-1]) {\n                claimRegistry[merkleRoot].storageMetadata[nClaimRecords].storageURI[i].schemeID = schemeIDs[i];\n            }\n            if (i == 0 || authorityIDs[i] != authorityIDs[i-1]) {\n                claimRegistry[merkleRoot].storageMetadata[nClaimRecords].storageURI[i].authorityID = authorityIDs[i];\n            }\n            claimRegistry[merkleRoot].storageMetadata[nClaimRecords].storageURI[i].path = paths[i];\n            if (fileSetExtensionMarker[i] > 0) {\n                claimRegistry[merkleRoot].storageMetadata[nClaimRecords].storageURI[i].fileSetExtensionMarker = fileSetExtensionMarker[i];\n            }\n        }\n        claimRegistry[merkleRoot].nClaimRecords = nClaimRecords;\n    }\n\n    function recordClaimURI(bytes32 merkleRoot, uint8 claimRecordID, uint8[] calldata schemeIDs, uint16[] calldata authorityIDs, \n        bytes32[] calldata paths, uint8[] calldata fileSetExtensionMarker) public {\n        \n        require(claimRecordID > 0 && claimRecordID <= claimRegistry[merkleRoot].nClaimRecords, \"claimRecordID out of range\");\n        require(claimIssuedForSender(merkleRoot, claimRecordID), \"Claim not issued to message sender\");\n\n        if (claimRegistry[merkleRoot].storageMetadata[claimRecordID].timestamp == block.timestamp) {\n            \n            for (uint8 i=0; i<schemeIDs.length; i++) {\n                \n                require(schemeIDs[i] > 0 && schemeIDs[i] <= nUriSchemeRegistry, \"schemeID out of range\");\n            \n                if (i == 0 || schemeIDs[i] != schemeIDs[i-1]) {\n                    claimRegistry[merkleRoot].storageMetadata[claimRecordID].storageURI[i].schemeID = schemeIDs[i];\n                }\n                if (i == 0 || authorityIDs[i] != authorityIDs[i-1]) {\n                    claimRegistry[merkleRoot].storageMetadata[claimRecordID].storageURI[i].authorityID = authorityIDs[i];\n                }\n                claimRegistry[merkleRoot].storageMetadata[claimRecordID].storageURI[i].path = paths[i];\n                claimRegistry[merkleRoot].storageMetadata[claimRecordID].storageURI[i].fileSetExtensionMarker = fileSetExtensionMarker[i];\n            }\n        }\n    }\n\n    function link(bytes32 linkID, bytes32 merkleRoot, bytes32 parentLinkID) public {\n        if (linkIDAvailable(linkID) || existingLinkIssuedForSender(linkID)) {\n            linkRegistry[linkID].merkleRoot = merkleRoot;\n            linkRegistry[linkID].linkIssuer = msg.sender;\n            linkRegistry[linkID].parentLinkID = parentLinkID;\n        }\n    }\n    \n   // register protocol scheme\n   function registerUriScheme(bytes32 uriScheme) public returns (uint8) {\n       uint8 uriSchemeID = retrieveUriSchemeIndex(uriScheme);\n       if (uriSchemeID == 0) {\n           nUriSchemeRegistry++;\n           uriSchemeRegistry[nUriSchemeRegistry] = uriScheme;\n           uriSchemeID = nUriSchemeRegistry;\n       }\n       return uriSchemeID;\n   }\n\n   // register authority\n   function registerUriAuthority(bytes32 uriAuthority) public returns (uint16) {\n       uint16 uriAuthorityID = retrieveUriAuthorityIndex(uriAuthority);\n       if (uriAuthorityID == 0) {\n           nUriAuthorityRegistry++;\n           uriAuthorityRegistry[nUriAuthorityRegistry] = uriAuthority;\n           uriAuthorityID = nUriAuthorityRegistry;\n       }\n       return uriAuthorityID;\n   }\n\n   // register mime type\n   function registerMimeType(bytes32 mimeType) public returns (uint8) {\n       uint8 mimeTypeID = retrieveMimeTypeIndex(mimeType);\n       if (mimeTypeID == 0) {\n           nMimeTypeRegistry++;\n           mimeTypeRegistry[nMimeTypeRegistry] = mimeType;\n           mimeTypeID = nMimeTypeRegistry;\n       }\n       return mimeTypeID;\n   }\n   \n    function retrieveUriSchemeIndex(bytes32 uriScheme) public view returns(uint8) {\n        // iterate registry starting at 1 (entry 0 is equal to an unset value)\n        for (uint8 i=1; i<=nUriSchemeRegistry; i++) {\n            if (uriSchemeRegistry[i] == uriScheme) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    \n    function retrieveUriAuthorityIndex(bytes32 uriAuthority) public view returns(uint16) {\n        // iterate registry starting at 1 (entry 0 is equal to an unset value)\n        for (uint16 i=1; i<=nUriAuthorityRegistry; i++) {\n            if (uriAuthorityRegistry[i] == uriAuthority) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    \n    function retrieveMimeTypeIndex(bytes32 mimeType) public view returns(uint8) {\n        // iterate registry starting at 1 (entry 0 is equal to an unset value)\n        for (uint8 i=1; i<=nMimeTypeRegistry; i++) {\n            if (mimeTypeRegistry[i] == mimeType) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    \n    function linkIDAvailable(bytes32 linkID) internal view returns (bool) {\n        if (linkRegistry[linkID].linkIssuer == address(0x0)) {\n            return true;\n        }\n        return false;\n    }\n    \n    function existingLinkIssuedForSender(bytes32 linkID) internal view returns (bool) {\n        if (linkRegistry[linkID].linkIssuer == msg.sender) {\n            return true;\n        }\n        return false;\n    }\n\n    function merkleRootKnown(bytes32 merkleRoot) internal view returns (bool) {\n        if (claimRegistry[merkleRoot].nClaimRecords < 1) {\n            return false;\n        }\n        return true;\n    }\n    \n    function claimIssuedForSender(bytes32 merkleRoot, uint8 claimRecordID) internal view returns (bool) {\n        if (claimRegistry[merkleRoot].nClaimRecords < 1) {\n            return false;\n        }\n        if (claimRegistry[merkleRoot].issuerMetadata[claimRecordID].accountAddress == msg.sender) {\n            return true;\n        }\n        return false;\n    }\n    \n    function getNClaimRecords(bytes32 merkleRoot) public view returns (uint8) {\n        return claimRegistry[merkleRoot].nClaimRecords;\n    }\n    \n    function resolveLink(bytes32 linkID) public view returns (bytes32 merkleRoot, address linkIssuer, bytes32 parentLinkID, uint8 nClaimRecords) {\n        bytes32 mr = linkRegistry[linkID].merkleRoot;\n        bytes32 pi = linkRegistry[linkID].parentLinkID;\n        address li = linkRegistry[linkID].linkIssuer;\n        uint8 ncr = claimRegistry[mr].nClaimRecords;\n        return (mr, li, pi, ncr);\n    }\n    \n    function getStorageMetadata(bytes32 merkleRoot, uint8 claimRecordID) public view returns (bytes32 mimeType, \n        uint256 timestamp) {\n\n        require(merkleRootKnown(merkleRoot), \"Merkle root unknown\"); \n        require(claimRecordID > 0 && claimRecordID <= claimRegistry[merkleRoot].nClaimRecords, \"claimRecordID out of range\");\n        \n        uint8 mTypeID = claimRegistry[merkleRoot].storageMetadata[claimRecordID].mimeTypeID;\n        uint256 tStamp = deployment_time + claimRegistry[merkleRoot].storageMetadata[claimRecordID].timestamp;\n\n        return (mimeTypeRegistry[mTypeID], tStamp);\n    }\n\n    function getStorageMetadataURIs(bytes32 merkleRoot, uint8 claimRecordID, uint8 uriID) public view \n        returns (uint8 fileSetExtensionMarker, uint8 schemeID, uint16 authorityID, bytes32 path) {\n\n        require(merkleRootKnown(merkleRoot), \"Merkle root unknown\");\n        require(claimRecordID > 0 && claimRecordID <= claimRegistry[merkleRoot].nClaimRecords, \"claimRecordID out of range\");\n\n        StorageURI memory sue = claimRegistry[merkleRoot].storageMetadata[claimRecordID].storageURI[uriID];\n        \n        return (sue.fileSetExtensionMarker, sue.schemeID, sue.authorityID, sue.path);\n    }\n\n    function getIssuerMetadata(bytes32 merkleRoot, uint8 claimRecordID) public view \n        returns (address accountAddress, bytes32 externalDID) {\n\n        require(merkleRootKnown(merkleRoot), \"Merkle root unknown\"); \n        require(claimRecordID > 0 && claimRecordID <= claimRegistry[merkleRoot].nClaimRecords, \"claimRecordID out of range\");\n        \n        address aAddr = claimRegistry[merkleRoot].issuerMetadata[claimRecordID].accountAddress;\n        bytes32 extId = claimRegistry[merkleRoot].issuerMetadata[claimRecordID].externalDID;\n        \n        return (aAddr, extId);\n    }\n\n    // returns the claim validation result\n    function validateClaim(bytes32 merkleRoot, uint8 claimRecordID, bytes32 merkleRootPrime) public view \n        returns (bool attestationResultValid, address claimIssuer, uint256 blockTimestamp) {\n            \n        require(merkleRootKnown(merkleRoot), \"Merkle root unknown\"); \n        require(claimRegistry[merkleRoot].nClaimRecords > 0);\n\n        if (claimRegistry[merkleRoot].issuerMetadata[claimRecordID].accountAddress != address(0x0) &&\n            merkleRoot == merkleRootPrime) {\n\n            address aAddr = claimRegistry[merkleRoot].issuerMetadata[claimRecordID].accountAddress;\n            uint256 bTime = deployment_time + claimRegistry[merkleRoot].storageMetadata[claimRecordID].timestamp;\n            \n            return (true, aAddr, bTime);\n\n        }\n        return (false, address(0x0), 0);\n    }\n    \n}\n\n\n"}}}