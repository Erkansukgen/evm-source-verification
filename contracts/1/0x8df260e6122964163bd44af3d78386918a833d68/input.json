{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/UDAO STAKING.sol": {
      "content": "pragma solidity ^0.6.6;\n\n/*Math operations with safety checks */\ncontract SafeMath { \n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;  \n    }\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a/b;  \n    }\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;  \n    }\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c>=a && c>=b);\n    return c;  \n    }  \n  function safePower(uint a, uint b) internal pure returns (uint256) {\n      uint256 c = a**b;\n      return c;  \n    }\n}\n\ninterface Token {\n  // @notice send `_value` token to `_to` from `msg.sender`\n  // @param _to The address of the recipient\n  // @param _value The amount of token to be transferred\n  // @return Whether the transfer was successful or not\n  function transfer(address _to, uint256 _value) external returns (bool success) ;\n\n  // @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n  // @param _from The address of the sender\n  // @param _to The address of the recipient\n  // @param _value The amount of token to be transferred\n  // @return Whether the transfer was successful or not\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) ;\n}\n\ncontract UdaoStakingPool  is SafeMath{\n    \n    address payable public owner;\n\n    //Contract address of UDAO token\n    address public addressUDAO;\n\n    //Accelerator card, use accelerator card to gain + 50% speed\n    address public addressFastCard;\n    \n    //Supplier\n    address public addressSupplier;\n    \n    //mapping of token addresses to mapping of account balances (token=0 means Ether)\n    mapping (address => mapping (address => uint)) public tokens; \n    //Counting the number of blocks at the beginning of staking\n    mapping (address => mapping (address => uint256)) atBlock;\n    //Staking ratio\n    mapping (address => uint256) StakingRatio;\n    \n    event Deposit(address token, address user, uint amount, uint balance);\n    event Withdraw(address token, address user, uint amount, uint balance);\n    event Staking(address token, address user, uint amount);\n    \n    /* Initializes contract*/\n    constructor () public {  \n        owner = msg.sender;\n        addressSupplier = msg.sender;\n    }    \n    \n    receive() external payable {}\n    \n    // transfer Ether balance to owner\n    function withdrawEther(uint amount) public{\n      require(msg.sender == owner);\n      owner.transfer(amount); \n    }\n    \n    //Change owner\n    function changeOwner(address payable _owner) public{\n        if(msg.sender == owner && _owner != address(0)) {\n            owner = _owner;\n        }\n    }\n\n    //Set Staking Ratioï¼Œbase 10**18\n    function setStakingRatio(address _token,uint _stakingRatio) public{\n        if(msg.sender == owner) {\n            StakingRatio[_token] = _stakingRatio;\n        }\n    }\n\n    function setStakingToken(address _addressStakingToken) public{\n        if(msg.sender == owner ) {\n            addressUDAO = _addressStakingToken;\n        }\n    }\n    \n    function setFastStakingCard(address _addressFastCard) public{\n        if(msg.sender == owner  && _addressFastCard != address(0)) {\n            addressFastCard = _addressFastCard;\n        }\n    }\n    \n    function setSupplier(address _addressSupplier) public{\n        if(msg.sender == owner  && _addressSupplier != address(0)) {\n            addressSupplier = _addressSupplier;\n        }\n    }\n    \n  //The player will recharge the token into the contract and get the previous reward.\n  function depositToken(address token, uint amount) public{\n    require (token != address(0x0)) ;\n    _staking(token);\n    require (Token(token).transferFrom(msg.sender, address(this), amount)) ;\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n    emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]); \n  }\n\n  //The player extracts the token stored in the contract\n  function withdrawToken(address token, uint amount) public{\n    require (token!= address(0x0)) ;\n    require (tokens[token][msg.sender] >= amount) ;\n    _staking(token);\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n    require (Token(token).transfer(msg.sender, amount)) ;\n    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  //staking,Supports multiple tokens\n  function _staking(address _token) private returns (bool) {\n    uint256 _giftamount = tokens[_token][msg.sender] * (block.number - atBlock[_token][msg.sender]) * StakingRatio[_token] / 10**18 ;\n    if(tokens[addressFastCard][msg.sender] >= 1) _giftamount = _giftamount * 3 / 2;\n    if(atBlock[_token][msg.sender]==0){atBlock[_token][msg.sender] = block.number;}\n    if(atBlock[_token][msg.sender]<block.number && tokens[addressUDAO][addressSupplier]>=_giftamount)\n    {\n        tokens[addressUDAO][addressSupplier] = safeSub(tokens[addressUDAO][addressSupplier], _giftamount);\n        require (Token(addressUDAO).transfer(msg.sender, _giftamount)) ;\n        atBlock[_token][msg.sender] = block.number;\n        emit Staking(_token, msg.sender, _giftamount);\n    }\n    return true;\n  }\n\n  //View outstanding awards\n    function viewStaking(address _token,address _user) public view returns (uint _giftamount) {\n        _giftamount = tokens[_token][_user] * (block.number - atBlock[_token][_user]) * StakingRatio[_token] / 10**18;\n        if(tokens[addressFastCard][_user] >= 1) _giftamount = _giftamount * 3/2;\n        return _giftamount;\n    }\n    \n    //View StakingRatio\n    function viewStakingRatio(address _token) public view returns (uint) {\n        return StakingRatio[_token];\n    }\n}\n\n"
    }
  }
}