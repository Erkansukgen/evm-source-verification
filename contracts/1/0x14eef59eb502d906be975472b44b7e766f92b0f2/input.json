{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"localhost/IERC20.sol":{"content":"pragma solidity ^0.7.3;\n\n/**\n * @title Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function totalSupply() external view returns (uint256);\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n}\n"},"localhost/Ownable.sol":{"content":"// SPDX-License-Identifier: No License\n\npragma solidity ^0.7.3;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n * @author crypto-pumpkin@github\n *\n * By initialization, the owner account will be the one that called initializeOwner. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable  {\n    address public _owner;\n\n    event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferCompleted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev COVER: Initializes the contract setting the deployer as the initial owner.\n     */\n    function initializeOwner() public  {\n        require(_owner == address(0));\n        _owner = msg.sender;\n        emit OwnershipTransferCompleted(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferInitiated(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"localhost/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"localhost/SafeMath.sol":{"content":"\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"localhost/ieo.sol":{"content":"pragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\nimport \"./Ownable.sol\";\nimport './IERC20.sol';\nimport './SafeMath.sol';\nimport \"./SafeERC20.sol\";\n\n/*\n * 上币 合约 \n*/\ncontract ieoCoinContract is  Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    uint    public priceDecimals;      \n    uint256 public registerAmount;\n    uint8   private TOKEN_DECIMALS; \n    uint8    private PRICE_DECIMALS;\n    IERC20 public COIN;\n    IERC20 public MINI;\n    \n\n    \n    uint256     private fee;\n    uint256     private feeBase;\n    uint        applyCoinId;\n    address     public daoAddress;\n    uint256     public registeFee;\n    constructor(IERC20 _MINI )public{\n        initializeOwner();\n        MINI            = _MINI;\n        priceDecimals   = 4;\n        TOKEN_DECIMALS  = 18;\n        PRICE_DECIMALS  = 6;\n        registerAmount  = 1 * (10 ** uint256(TOKEN_DECIMALS));\n        fee             = 5;\n        feeBase         = 1000;\n        applyCoinId     = 1;\n        addapplyCoin(msg.sender ,\"ETH\",18);          \n        registeFee      = 0;\n        _owner = msg.sender;\n        \n    }\n    struct ieoCoinInfoHead{\n        address     coinAddress;         \n        string      symbol;              \n        uint        decimals;               \n        uint        collectType;            \n        uint256     ieoAmount;                \n        uint256     price;               \n        bool        bBuyLimit;           \n        uint256     uBuyLimitNumber;     \n        bool        bPartner;           \n        uint256     partnerNumber;       \n        bool        bDAO;                \n        uint256     uDAONumber;          \n        uint        openType;            \n        uint        blockNumber;         \n        uint        openTime;            \n\n        bool        bDEX;                    \n        uint256     uDexNumber;         \n        uint256     poolCoinAmount;      \n        bool        usdtType;\n    }\n    struct ieoCoinInfo{\n        ieoCoinInfoHead ieoCoinHead; \n        uint        uTimestamp;          \n        address     coinId;\n        uint256     ieoAmountTotal;      \n        uint256     registerAmount;      \n        uint256     collectAmount;       \n\n        uint256     allCollectAmount;    \n        \n        uint256     ieoAmountComplete;   \n\n        uint256     daoCollectAmount;   //DAO里面预留的币 1:ETH  2:USDT  3:MINI 数量\n        uint256     dexCollectAmount;   //DEX里面预留的币 1:ETH  2:USDT  3:MINI 数量\n\n        bool        bExpired;           \n        uint        buyNonce;           \n        bool        bTop;                \n        address     createUserAddress;   \n        bool        bPayDAO;\n        uint256     txid;\n        bool        UsdtType;   \n    }\n    event CreateIeoCoin(address user,address coinAddress,uint time,uint256 txid,uint256 amount);\n    event BuyCoin(address user,uint256 amount,address applyAddress, uint256 makeCoinAmount,uint256 txid);\n    event TakeOut(address user,uint256 amount,uint collectType ) ;\n    event Withdraw(address user,IERC20 COIN,uint256 amount ,address coinId,uint256 txid);\n    event SetIeoCoinDao(address coinId,address daoAddress,uint256 amount);\n    event AddLiquidity(address user,address coinid,uint256 balance,uint256 txid);\n    event TakeOutFee(address user,uint256 amount);\n\n    mapping(address=>ieoCoinInfo) ieoCoin;                  \n    struct userInfo{\n        uint        uTimestamp;          \n        address     coinAddress;         \n        uint256     makeCoinAmount;      \n        uint256     takeCoinAmount;      \n        address     userAddress;\n    }\n    mapping(address=> mapping(address=> userInfo)) usercoin;\n    struct applyCoinInfo{\n        uint        uTimestamp;\n        address     contractAddress;\n        string      symbol;\n        uint        decimals;\n    }\n    mapping(address => applyCoinInfo) applyCoin;\n    mapping(uint => address) applyCoinAddress;\n \n    \n    uint [] applyCoinList;\n    function setUsdtType(address coinid,bool _UsdtType) public onlyOwner returns(bool){\n        require(coinid != address(0));\n        ieoCoin[coinid].UsdtType = _UsdtType;\n        return true;\n    }\n    function getapplyCoinListLenght() public view returns(uint){\n        return applyCoinList.length;\n    }\n    function getapplyCoinListData(uint index) public view returns(uint){\n        require(applyCoinList.length > index);\n        return applyCoinList[index];\n    }\n    function getapplyCoinAddress(uint coinid) public view returns(address){\n        return applyCoinAddress[coinid];\n    }\n    function getapplyCoin(address contractAddress) public view returns(applyCoinInfo memory){\n        return applyCoin[contractAddress];\n    }\n    function addapplyCoin(address contractAddress,string memory symbol,uint decimals) public onlyOwner returns(bool){\n        require(applyCoin[contractAddress].contractAddress == address(0));   \n        applyCoinInfo memory newapplyCoinInfo = applyCoinInfo({\n            uTimestamp:         block.timestamp,\n            contractAddress:    contractAddress,\n            symbol:             symbol,\n            decimals:           decimals                   \n        });\n        applyCoin[contractAddress] = newapplyCoinInfo;\n        applyCoinList.push(applyCoinId);\n        applyCoinAddress[applyCoinId] = contractAddress;\n        applyCoinId++;\n        return true;\n    }\n   \n \n    function getfee() public view returns(uint){\n        return fee;\n    }\n \n    function setfee(uint _fee) public onlyOwner returns(bool){\n        require(_fee>=0);\n        fee = _fee;\n        return true;\n    }\n \n    function getUserInfo(address userAddress,address coinId) public view returns(userInfo memory){\n        return usercoin[userAddress][coinId];\n    }\n    function getieoCoin( address id ) public view returns(ieoCoinInfo memory){\n        require( id != address(0) );           \n        return ieoCoin[id];\n    }\n    function getregisterAmount() public view  returns(uint256){\n        return registerAmount;\n    }\n    function setregisterAmount(uint256 amount) public onlyOwner returns(bool){\n        require(amount>=0);\n        registerAmount = amount;\n        return true;\n    }\n    function createIeoCoin(ieoCoinInfoHead memory ieoCoinHead,uint256 txid) public payable returns(bool){\n        require(ieoCoinHead.coinAddress != address(0));\n        require(ieoCoinHead.ieoAmount > 0);\n        address coinId = ieoCoinHead.coinAddress;\n        require(ieoCoin[coinId].ieoCoinHead.coinAddress == address(0));  \n        require(msg.value >=  registerAmount );                          \n        ieoCoinInfo memory newieoCoinInfo = ieoCoinInfo({\n            ieoCoinHead:            ieoCoinHead,\n            uTimestamp:             block.timestamp,\n            coinId:                 coinId,\n            ieoAmountTotal:         (ieoCoin[coinId].ieoAmountTotal).add(ieoCoinHead.ieoAmount), \n            registerAmount:         msg.value,\n            collectAmount:          0,\n            allCollectAmount:       0,\n            ieoAmountComplete:      0,\n            daoCollectAmount:       0,\n            dexCollectAmount:       0,\n            bExpired:               false,\n            buyNonce:               0,\n            bTop:                   false,\n            createUserAddress:      msg.sender,\n            bPayDAO:                false,\n            txid:                   txid,\n            UsdtType:               ieoCoinHead.usdtType\n            \n        });\n        \n        ieoCoin[coinId]  = newieoCoinInfo;        \n        ieoCoin[coinId].coinId = coinId;\n\n        ieoCoin[coinId].ieoCoinHead.poolCoinAmount = (ieoCoin[coinId].ieoCoinHead.ieoAmount).mul(ieoCoin[coinId].ieoCoinHead.uDexNumber);\n        ieoCoin[coinId].ieoCoinHead.poolCoinAmount = (ieoCoin[coinId].ieoCoinHead.poolCoinAmount).div(100);\n\n        uint256 amount = ieoCoinHead.ieoAmount.add( ieoCoin[coinId].ieoCoinHead.poolCoinAmount );\n        COIN =  IERC20(ieoCoinHead.coinAddress) ;\n        COIN.safeTransferFrom(msg.sender, address(this), amount);\n        \n        registeFee = registeFee.add(msg.value);\n        emit CreateIeoCoin(msg.sender,ieoCoinHead.coinAddress,block.timestamp,txid,amount);      \n        return true;\n    }\n    function checkBuyStatus(address coinid) private returns(bool){\n        bool bStatus = false;\n        if(block.number > ieoCoin[coinid].ieoCoinHead.blockNumber ){\n            uint num = (block.number).sub( ieoCoin[coinid].ieoCoinHead.blockNumber ) ;\n            if( num.mul(15)  > ieoCoin[coinid].ieoCoinHead.openTime ){\n               bStatus = true;\n            }\n            else{\n                bStatus = false;\n            }\n        }\n        else{\n            bStatus = false;\n        }\n        return bStatus;\n    }\n    function buyCoin(address coinid,uint256 amount) public payable returns(bool){\n        require(ieoCoin[coinid].bExpired == false);        \n        require(ieoCoin[coinid].ieoCoinHead.ieoAmount >= ieoCoin[coinid].ieoAmountComplete );   \n\n        require(ieoCoin[coinid].ieoCoinHead.coinAddress != address(0));\n\n        require(checkBuyStatus(coinid) == false ) ;           \n        \n        \n        address applyAddress = applyCoinAddress[ieoCoin[coinid].ieoCoinHead.collectType];\n        uint decimals = applyCoin[applyAddress].decimals;              \n        uint to_decimals = ieoCoin[coinid].ieoCoinHead.decimals;                                  \n        \n        uint256 makeCoinAmount;                   \n        makeCoinAmount = (amount.mul(10 ** to_decimals)).div(10 ** decimals);\n\n        makeCoinAmount = makeCoinAmount.mul( ieoCoin[coinid].ieoCoinHead.price );\n        \n        makeCoinAmount = makeCoinAmount.div(10 ** uint256(PRICE_DECIMALS));\n        \n        require(ieoCoin[coinid].ieoCoinHead.ieoAmount >= makeCoinAmount.add(ieoCoin[coinid].ieoAmountComplete)  );\n\n        address APPLYCOIN  = applyCoin[applyAddress].contractAddress ; \n\n       \n        if( ieoCoin[coinid].ieoCoinHead.bBuyLimit ){\n            require(usercoin[msg.sender][coinid].takeCoinAmount <= ieoCoin[coinid].ieoCoinHead.uBuyLimitNumber);\n        }\n  \n        if( ieoCoin[coinid].ieoCoinHead.bPartner ){\n            require(MINI.balanceOf(msg.sender) >= ieoCoin[coinid].ieoCoinHead.partnerNumber);\n        }\n        uint256 feeAmount;    \n        if(ieoCoin[coinid].ieoCoinHead.collectType == 1){                                        \n            require(msg.value >= amount );  \n            feeAmount =   amount.mul(fee).div(feeBase);\n            address payable myOwner = address(uint160(_owner));\n            myOwner.transfer(feeAmount);                        \n        }\n        else{\n            require(IERC20(APPLYCOIN).balanceOf(msg.sender) >= amount);\n            feeAmount =   amount.mul(fee).div(feeBase);  \n            \n            IERC20(APPLYCOIN).safeTransferFrom(msg.sender, address(this), amount.sub(feeAmount));      \n            IERC20(APPLYCOIN).safeTransferFrom(msg.sender, _owner, feeAmount);        \n        }\n    \n        ieoCoin[coinid].collectAmount = (amount.sub(feeAmount)).add(ieoCoin[coinid].collectAmount);      \n        ieoCoin[coinid].allCollectAmount = ieoCoin[coinid].collectAmount;\n        ieoCoin[coinid].ieoAmountComplete = makeCoinAmount.add(ieoCoin[coinid].ieoAmountComplete);            \n        setDaoAndDexCollect(coinid);\n        ieoCoin[coinid].buyNonce ++;\n\n        userInfo memory newuserinfo = userInfo({\n            uTimestamp:         block.timestamp,\n            coinAddress:        coinid,\n            makeCoinAmount:     makeCoinAmount.add(usercoin[msg.sender][coinid].makeCoinAmount),   \n            takeCoinAmount:     amount.add(usercoin[msg.sender][coinid].takeCoinAmount),          \n            userAddress:        msg.sender\n        });\n        usercoin[msg.sender][coinid] = newuserinfo;\n        uint256 txid = ieoCoin[coinid].txid;\n        emit BuyCoin(msg.sender,amount,APPLYCOIN,makeCoinAmount,txid);        \n        return true;\n    }  \n    function setDaoAndDexCollect(address coinid) private returns(bool){\n        uint256 collectAmount = ieoCoin[coinid].collectAmount;\n        uint256 daocollectAmount = collectAmount.mul(ieoCoin[coinid].ieoCoinHead.uDAONumber);\n        daocollectAmount = daocollectAmount.div( 100 );\n        ieoCoin[coinid].daoCollectAmount = daocollectAmount;\n\n        uint256 dexCollectAmount = collectAmount.mul(ieoCoin[coinid].ieoCoinHead.uDexNumber);\n        dexCollectAmount = dexCollectAmount.div(100);\n        ieoCoin[coinid].dexCollectAmount = dexCollectAmount;\n        return true;\n    }\n    function takeOut(address coinid) public returns(bool){\n        require(ieoCoin[coinid].collectAmount >= 0);                      \n        require(ieoCoin[coinid].createUserAddress == msg.sender );            \n\n        require(checkBuyStatus(coinid) == true); \n\n        uint256 collectAmount = ieoCoin[coinid].collectAmount;\n        address applyAddress = applyCoinAddress[ieoCoin[coinid].ieoCoinHead.collectType];\n        \n        address APPLYCOIN  = applyCoin[applyAddress].contractAddress ;     \n        ieoCoin[coinid].collectAmount = 0;\n        if( ieoCoin[coinid].ieoCoinHead.bDAO ){\n            collectAmount = collectAmount.sub(ieoCoin[coinid].daoCollectAmount);\n            ieoCoin[coinid].collectAmount = collectAmount ;         \n        }\n        if( ieoCoin[coinid].ieoCoinHead.bDEX ){\n            collectAmount = collectAmount.sub(ieoCoin[coinid].dexCollectAmount);\n            ieoCoin[coinid].collectAmount = collectAmount;\n        }\n        if( collectAmount > 0 ){\n            if( ieoCoin[coinid].ieoCoinHead.collectType == 1 ){\n                address payable createUserAddress = address(uint160(ieoCoin[coinid].createUserAddress));\n                createUserAddress.transfer(collectAmount); \n            }\n            else{\n                IERC20(APPLYCOIN).safeTransfer(msg.sender,collectAmount);    \n            }\n        }\n       \n        ieoCoin[coinid].collectAmount = 0;\n        ieoCoin[coinid].bExpired = true;\n\n        uint256 balance = (ieoCoin[coinid].ieoCoinHead.ieoAmount).sub(ieoCoin[coinid].ieoAmountComplete) ;\n        //add dex\n        uint decimals = applyCoin[applyAddress].decimals;\n        uint to_decimals = ieoCoin[coinid].ieoCoinHead.decimals;\n\n        uint256  dexCoinAmount =  ieoCoin[coinid].dexCollectAmount;\n        dexCoinAmount = (dexCoinAmount.mul(10 ** to_decimals)).div(10 ** decimals);     \n        dexCoinAmount = dexCoinAmount.mul(ieoCoin[coinid].ieoCoinHead.price);          \n        dexCoinAmount = dexCoinAmount.div(10 ** uint256(PRICE_DECIMALS));\n        \n        balance = balance.add( (ieoCoin[coinid].ieoCoinHead.poolCoinAmount).sub(dexCoinAmount) ) ;\n        COIN = IERC20(ieoCoin[coinid].ieoCoinHead.coinAddress); \n        COIN.safeTransfer(msg.sender, balance); \n        emit TakeOut(msg.sender,ieoCoin[coinid].collectAmount,ieoCoin[coinid].ieoCoinHead.collectType);\n        return true;\n    } \n    \n    function withdraw(address coinid,uint256 amount) public returns(bool){\n        require(msg.sender != address(0));\n        require(usercoin[msg.sender][coinid].makeCoinAmount > 0);\n\n        require(usercoin[msg.sender][coinid].userAddress == msg.sender);\n        require(usercoin[msg.sender][coinid].makeCoinAmount >= amount);\n        usercoin[msg.sender][coinid].makeCoinAmount = (usercoin[msg.sender][coinid].makeCoinAmount).sub(amount);\n        COIN = IERC20(ieoCoin[coinid].ieoCoinHead.coinAddress);   \n        COIN.safeTransfer(msg.sender,amount );          \n        emit Withdraw(msg.sender,COIN, amount,coinid,ieoCoin[coinid].txid );\n        return true;\n    }\n    function getieoUserInfo(address user,address coinid) public view returns(uint256,uint256){\n        require(user != address(0));\n        require(ieoCoin[coinid].ieoCoinHead.coinAddress != address(0));\n        uint256 makeCoinAmount = usercoin[user][coinid].makeCoinAmount;\n        uint256 takeCoinAmount = usercoin[user][coinid].takeCoinAmount;\n        return (makeCoinAmount,takeCoinAmount);\n    }\n    function getieoCoinSallInfo(address coinid) public view returns(uint256,uint256){\n        require(ieoCoin[coinid].ieoCoinHead.coinAddress != address(0));\n        uint256 buyNonce = ieoCoin[coinid].buyNonce;\n        uint256 ieoAmountComplete = ieoCoin[coinid].ieoAmountComplete;\n        return (buyNonce,ieoAmountComplete);\n    }\n    function getieoCoinInfoByDao(address coinid) public view returns(address,bool,uint256,uint256,address,bool){\n        require(ieoCoin[coinid].ieoCoinHead.coinAddress != address(0));\n        bool    bDAO                = ieoCoin[coinid].ieoCoinHead.bDAO;\n        uint256 uDAONumber          = ieoCoin[coinid].ieoCoinHead.uDAONumber;\n        uint256 daoCollectAmount    = ieoCoin[coinid].daoCollectAmount;\n        address contractAddress     = ieoCoin[coinid].ieoCoinHead.coinAddress;\n        address createAddress       = ieoCoin[coinid].createUserAddress; \n        bool    bExpired            = ieoCoin[coinid].bExpired;\n        return(contractAddress,bDAO,uDAONumber,daoCollectAmount,createAddress,bExpired);        \n    }\n    function getieoCoinInfoByDex(address coinId) public view returns(address,bool,uint256,uint256,address){\n        require(ieoCoin[coinId].ieoCoinHead.coinAddress != address(0));\n        bool    bDEX                = ieoCoin[coinId].ieoCoinHead.bDEX;\n        uint256 uDexNumber          = ieoCoin[coinId].ieoCoinHead.uDexNumber;\n        uint256 dexCollectAmount    = ieoCoin[coinId].dexCollectAmount;        \n        address contractAddress     = ieoCoin[coinId].ieoCoinHead.coinAddress;\n        address createUserAddress   = ieoCoin[coinId].createUserAddress;\n        return(contractAddress,bDEX,uDexNumber,dexCollectAmount,createUserAddress);        \n    }\n    function setdaoAddress(address _address) public onlyOwner returns(bool){\n        require(_address != address(0));\n        daoAddress = _address;\n        return true;\n    }\n    function setIeoCoinDao(address coinId,uint256 amount,uint256 uDAONumber) public  returns(bool){\n        require(msg.sender == daoAddress);  //only daoieo run\n        require(ieoCoin[coinId].daoCollectAmount > 0);\n        require(ieoCoin[coinId].daoCollectAmount >= amount );\n\n        address applyAddress = applyCoinAddress[ieoCoin[coinId].ieoCoinHead.collectType];\n        address APPLYCOIN  = applyCoin[applyAddress].contractAddress ;      //get apply address\n        if( ieoCoin[coinId].ieoCoinHead.bDAO ){\n            ieoCoin[coinId].bPayDAO = true;\n            ieoCoin[coinId].ieoCoinHead.uDAONumber = uDAONumber;\n            ieoCoin[coinId].daoCollectAmount = (ieoCoin[coinId].daoCollectAmount).sub(amount);          \n        }\n        if( ieoCoin[coinId].daoCollectAmount == 0 ){\n            ieoCoin[coinId].bExpired = true;\n        }\n        if( ieoCoin[coinId].ieoCoinHead.collectType == 1 ){\n            address payable createUserAddress = address(uint160(ieoCoin[coinId].createUserAddress));\n            createUserAddress.transfer(amount); \n        }\n        else{\n            IERC20(APPLYCOIN).safeTransfer((ieoCoin[coinId].createUserAddress),amount);  \n        } \n        emit SetIeoCoinDao(coinId,daoAddress,amount);\n        return true;\n    }\n    function addLiquidity(address coinid) public onlyOwner returns(bool){\n        require(checkBuyStatus(coinid) == true); \n        require(ieoCoin[coinid].dexCollectAmount > 0);\n\n        uint256 dexCollectAmount = ieoCoin[coinid].dexCollectAmount;\n        address applyAddress = applyCoinAddress[ieoCoin[coinid].ieoCoinHead.collectType];        \n        address APPLYCOIN  = applyCoin[applyAddress].contractAddress ;      \n        if( ieoCoin[coinid].ieoCoinHead.bDEX ){\n            ieoCoin[coinid].dexCollectAmount = 0 ;\n        }\n        if( ieoCoin[coinid].ieoCoinHead.collectType == 1 ){\n            address payable myOwner = address(uint160(_owner));\n            myOwner.transfer(dexCollectAmount); \n        }\n        else{\n            IERC20(APPLYCOIN).safeTransfer(_owner,dexCollectAmount);    \n        } \n        uint decimals = applyCoin[applyAddress].decimals;\n        uint to_decimals = ieoCoin[coinid].ieoCoinHead.decimals;\n\n        \n        uint256 balance = (dexCollectAmount.mul(10 ** to_decimals)).div(10 ** decimals);\n        balance = balance.mul(ieoCoin[coinid].ieoCoinHead.price) ;\n        balance = balance.div(10 ** uint256(PRICE_DECIMALS));\n        COIN = IERC20(ieoCoin[coinid].ieoCoinHead.coinAddress);\n        COIN.safeTransfer(_owner, balance);\n        emit AddLiquidity(msg.sender,coinid,balance,ieoCoin[coinid].txid);\n        return true;\n    }\n    function takeOutFee() public onlyOwner returns(bool){\n        require(registeFee > 0);\n        msg.sender.transfer(registeFee);\n        emit TakeOutFee(msg.sender,registeFee);\n        registeFee = 0 ;\n        return true;\n    }\n    function getregisteFee() public view returns(uint256) {\n        return registeFee;\n    }\n    function getCoinType(address coinid) public view returns(bool){\n        require(coinid != address(0));\n        return ieoCoin[coinid].UsdtType; \n    }\n }"}}}