{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/SNFT.sol": {
      "content": "pragma solidity 0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n\r\n\r\n/*****************************************************************************************\r\n    Relative to 04399a39ab5ce9f24ee374d07d0ae3b2e186213c1bebdd361c1fb7124799c270.\r\n    \r\n\r\n\tIn most blockchains, transactions first stays in a memory pool waiting to be included in a block. This is a problem for minting NFTs because everyone can see the contents of the transactions, including the contents of an NFT waiting to be minted.\r\n\r\n\tAn attacker could then craft his own transaction containing the observed data and end up minting an exact copy of the NFT before the original author.\r\n\r\n\tTo prevent that, NFT minting could be made in a two step process, that we will call the preminting and the minting steps, for example:\r\n\r\n\t\tStep 1 - Premint an NFT by sending a transaction containing the SHA-256 hash of:  The user's wallet address concatenated with the the contents of the NFT data.\r\n\r\n\t\tStep 2 - Wait for finality of the preminting transaction and then send a minting transaction revealing, this time, the contents of the NFT data.\r\n\r\n\tSo that the preminting transaction ties the NFT data to the user's wallet without revealing anything about the data itself.\r\n\r\n\tIf an attacker tries to mint an NFT with the same data in this case, the original author can prove precedence by referring to the preminting transaction.\r\n\r\n\r\n\tA smart contract may be created with this process to give the NFT ownership to whoever preminted it first.\r\n\r\n\tThat in turn makes another attack possible in which an NFT owner could trade the NFT and later retake its ownership by proving another earlier premint from another wallet.\r\n\r\n\tIn order to prevent that, whenever an NFT is minted it should have a reclaim period after which it becomes finalized and can not be retaken.\r\n\r\n\r\n\tIn any case, due to possible network problems and other attacks, users should only publish the NFT data on IPFS or eslsewhere after confirming ownership of a minted and finalized NFT.\r\n\t\r\n\t\r\n\tHence, this smart contract was created.\r\n\r\n*****************************************************************************************/\r\n\r\n\r\n\r\ncontract SNFT is ReentrancyGuard {    \r\n\r\n    uint constant       TIME_ALLOWED_TO_RECLAIM_A_MINTED_NFT\t\t=  24 hours;     // An NFT *is not* considered finalized (meaning that most functions will throw) until this time has ellapsed after its minting.\r\n    uint constant       ONE_HUNDRED_PERCENT                         =  1000000000;  // By representing 100% with 1,000,000,000 (which fits in 32bits vars) we natively support an asset to be shared by as much as one billion users (the smallest ownable fraction being 0.0000001%).\r\n    uint constant       BUY_OFFER_SLOT_COUNT                        =  4;           // Slot 0 expires faster, while slots 1, 2 and 3 have default expiring time.\r\n    uint constant       BUY_OFFER_DEFAULT_EXPIRING_TIME             =  24 hours;\r\n    uint constant       BUY_OFFER_SLOT_0_EXPIRING_TIME\t\t\t\t=  1 hours;     // Offers in slot 0 expire faster (useful for prearranged offers and for automation).\r\n    \r\n    // Error strings.\r\n    string constant     NFT_INVALID_OR_NOT_FINALIZED                =  \"NFT invalid or not finalized\";\r\n    string constant     PREMINT_MISMATCH                            =  \"Mint and premint mismatch\";\r\n    string constant     NFT_FINALIZED\t\t\t\t\t\t\t\t=  \"NFT is finalized\";\r\n    string constant     INSUFFICIENT_FUNDS                          =  \"Insufficient funds\";\r\n    string constant     FAILED_TO_TRANSFER_ETH                      =  \"Failed to transfer ETH\";\r\n    string constant     ACCESS_DENIED                               =  \"Access denied\";\r\n    string constant     OFFER_INVALID                               =  \"Offer invalid\";\r\n    string constant     OFFER_EXPIRED                               =  \"Offer expired\";\r\n    string constant     OFFER_PARAMETERS_MISMATCH                   =  \"Offer parameters mismatch\";\r\n\tstring constant\t\tSLOT_UNAVAILABLE\t\t\t\t\t\t\t=  \"Slot unavailable\";\r\n    \r\n\r\n    struct BuyOffer {\r\n        address payable from;\r\n        uint requested_amount;\r\n        uint wei_offered;\r\n        uint expires_at;\r\n    }\r\n\t\r\n    struct NFT {\r\n        address minter;  // we need this attribute so we can reset to zero the fraction owned by a minter who has been superseded by another minter that preminted first.\r\n\t\tuint minted_at;  // timestamp corresponding to the block which minted this NFT.\r\n        uint preminted_at;  // timestamp corresponding to the block which preminted this NFT.\r\n\t\tuint256 fixed_info_1;  // User defined custom information that is fixed at the minting time.\r\n\t\tuint256 fixed_info_2;  // User defined custom information that is fixed at the minting time.\r\n\t\tuint256 updatable_info_1;  // User defined custom information that can be updated after the NFT is finalized by an owner with more than 50% of the NFT shares.\r\n\t\tuint256 updatable_info_2;  // User defined custom information that can be updated after the NFT is finalized by an owner with more than 50% of the NFT shares.\r\n        mapping( address => uint ) owners;  // map of owner addresses to the amount owned in relation to ONE_HUNDRED_PERCENT of the asset.\r\n        BuyOffer[ BUY_OFFER_SLOT_COUNT ] buy_offers;  // every NFT natively comes with slots for buy offers that can be made by locking ETH into this contract.\r\n    }\r\n\t\r\n\t\r\n    mapping( address => mapping(uint256=>uint) ) private premints; // map of [minter's addresses] to [sha256 hashes of the minter's address concatenated with sha256_of_the_nft_data], to the [preminting timestamp].\r\n    mapping( uint256 => NFT ) private nfts; // make it private to prevent users from interacting with non finalized NFTs.\r\n    \r\n    \r\n    event Minted( uint256 indexed sha256_of_the_nft_data, address indexed minter, uint preminted_at, uint256 indexed fixed_info_1, uint256 fixed_info_2 );\r\n    event Transferred( uint256 indexed sha256_of_the_nft_data, address indexed from, address indexed to, uint amount );\r\n    event BuyOfferMade( uint256 indexed sha256_of_the_nft_data, address indexed from, uint requested_amount, uint wei_offered, uint expires_at, uint indexed slot_number );\r\n    event BuyOfferWithdrawn( uint256 indexed sha256_of_the_nft_data, address indexed from, uint requested_amount, uint wei_offered, uint indexed slot_number );\r\n    event BuyOfferAccepted( uint256 indexed sha256_of_the_nft_data, address indexed buyer, address seller, uint requested_amount, uint wei_offered, uint indexed slot_number );\r\n\r\n\r\n    /**\r\n     * Used to premint an NFT, proving prior knowledge of the sha256 hash of the NFT data.\r\n\t *\r\n\t *   sha256_of_the_minters_address_concatenated_with_the_sha256_of_the_nft_data  =  sha256(  abi.encodePacked( bytes20(msg.sender), sha256_of_the_nft_data )  )\r\n     */\r\n    function pre_mint( uint256 sha256_of_the_minters_address_concatenated_with_the_sha256_of_the_nft_data ) external\r\n    {\r\n        // We better prevent the user from inadvertently overwriting his own oldest premint.\r\n        bool was_already_preminted  =  (  premints[ msg.sender ][ sha256_of_the_minters_address_concatenated_with_the_sha256_of_the_nft_data ]  >  0  );\r\n        if( was_already_preminted == false )  premints[ msg.sender ][ sha256_of_the_minters_address_concatenated_with_the_sha256_of_the_nft_data ]  =  block.timestamp;\r\n    }\r\n    \r\n    /**\r\n     * Used to mint an NFT which was already preminted.\r\n\t * The minter's balance starts with the constant value defined by ONE_HUNDRED_PERCENT.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *   fixed_info_1\t\t\t\t\t=  User custom value, can not be changed after minted.\r\n\t *   fixed_info_2\t\t\t\t\t=  User custom value, can not be changed after minted.\r\n\t *\r\n\t *   May throw PREMINT_MISMATCH, NFT_FINALIZED, or ACCESS_DENIED.\r\n\t *\r\n\t *   Emits the Minted event.\r\n     */\r\n    function mint( uint256 sha256_of_the_nft_data, uint256 fixed_info_1, uint256 fixed_info_2 ) external\r\n    {\r\n        bytes memory minters_address_concatenated_with_sha256_of_the_nft_data  =  abi.encodePacked( bytes20(msg.sender), sha256_of_the_nft_data );\r\n        uint256 sha256_of_the_minters_address_concatenated_with_the_sha256_of_the_nft_data  =  uint256(sha256( minters_address_concatenated_with_sha256_of_the_nft_data ));\r\n        uint preminted_at  =  premints[ msg.sender ][ sha256_of_the_minters_address_concatenated_with_the_sha256_of_the_nft_data ];\r\n        require(  preminted_at  >  0,  PREMINT_MISMATCH  );\r\n\r\n\t\tNFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n\t\trequire(  is_finalized( nft ) == false,  NFT_FINALIZED  );\r\n\t\t\r\n        // Check if the NFT was already minted, in which case we will give ownership to whoever preminted it first.\r\n        bool was_nft_already_minted  =  ( nft.minted_at > 0 );\r\n        if( was_nft_already_minted )\r\n        {\r\n            require( preminted_at < nft.preminted_at, ACCESS_DENIED );\r\n\r\n            nft.owners[ nft.minter ]  =  0;  // Reset previous minter balance to zero.\r\n\t\t\t// There is no need to reset the amount of other owners because it is impossible to add other owners before the NFT is finalized.\r\n        }\r\n\t\t\r\n        nft.minter                  =  msg.sender;\r\n\t\tnft.minted_at\t\t\t\t=  block.timestamp;\r\n        nft.preminted_at            =  preminted_at;\r\n\t\tnft.fixed_info_1\t\t\t=  fixed_info_1;\r\n\t\tnft.fixed_info_2\t\t\t=  fixed_info_2;\r\n        nft.owners[ msg.sender ]    =  ONE_HUNDRED_PERCENT;\r\n        \r\n        emit Minted( sha256_of_the_nft_data, nft.minter, nft.preminted_at, nft.fixed_info_1, nft.fixed_info_2 );\r\n    }\r\n    \r\n    function is_finalized( NFT storage nft ) internal view returns (bool)\r\n    {\r\n        bool is_nft_minted  =  ( nft.minted_at > 0 );\r\n        if( is_nft_minted )\r\n        {\r\n            bool has_ellapsed_the_time_allowed_to_reclaim_a_minted_nft   =  (  block.timestamp  >  nft.minted_at + TIME_ALLOWED_TO_RECLAIM_A_MINTED_NFT  );\r\n            if( has_ellapsed_the_time_allowed_to_reclaim_a_minted_nft )  return true;\r\n        }\r\n        return false;\r\n    }\r\n\t\r\n\tfunction make_sure_nft_is_valid_and_finalized( NFT storage nft ) internal view\r\n\t{\r\n\t\trequire(  is_finalized( nft ) == true,  NFT_INVALID_OR_NOT_FINALIZED  );\r\n\t}\r\n\t\r\n    /**\r\n     * Used to get more information from an NFT.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *\r\n\t *   May throw NFT_INVALID_OR_NOT_FINALIZED.\r\n     */\r\n\tfunction get_nft_info( uint256 sha256_of_the_nft_data ) public view returns ( address minter, uint minted_at, uint preminted_at, uint256 fixed_info_1, uint256 fixed_info_2, uint256 updatable_info_1, uint256 updatable_info_2 )\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n        return ( nft.minter, nft.minted_at, nft.preminted_at, nft.fixed_info_1, nft.fixed_info_2, nft.updatable_info_1, nft.updatable_info_2 );\r\n    }\r\n    \r\n    /**\r\n     * Used to update two custom updatable attributes from an NFT.\r\n\t * Can only be issued by an owner with more than 50% of the NFT's shares.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *   owner\t\t\t\t\t\t\t=  The queried address.\r\n\t *\r\n\t *   May throw NFT_INVALID_OR_NOT_FINALIZED or ACCESS_DENIED.\r\n     */\r\n    function update_nft_info( uint256 sha256_of_the_nft_data, uint256 updatable_info_1, uint256 updatable_info_2 ) external\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n        \r\n        bool is_major_owner  =  (  nft.owners[ msg.sender ]  >  ONE_HUNDRED_PERCENT / 2  );\r\n        require(  is_major_owner == true,  ACCESS_DENIED  );\r\n        \r\n        nft.updatable_info_1  =  updatable_info_1;\r\n        nft.updatable_info_2  =  updatable_info_2;\r\n    }\r\n    \r\n    /**\r\n     * Used to transfer shares from an NFT.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *   amount\t\t\t\t\t\t\t=  The amount of shares to transfer.\r\n\t *   to\t\t\t\t\t\t\t\t=  The recipient.\r\n\t *\r\n\t *   May throw NFT_INVALID_OR_NOT_FINALIZED, INSUFFICIENT_FUNDS, or ACCESS_DENIED.\r\n\t *\r\n\t *   Emits the Transferred event.\r\n     */\r\n    function transfer( uint256 sha256_of_the_nft_data, uint amount, address to ) public\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n        require(  nft.owners[ msg.sender ] >= amount,  INSUFFICIENT_FUNDS  );\r\n\t\trequire(  msg.sender != to,  ACCESS_DENIED  );\r\n        \r\n        nft.owners[ msg.sender ]    -=  amount;\r\n        nft.owners[ to ]            +=  amount;\r\n        \r\n        emit Transferred( sha256_of_the_nft_data, msg.sender, to, amount );\r\n    }\r\n    \r\n    /**\r\n     * Used to retrieve the amount of shares of an NFT owned by a specific address.\r\n\t * The returned value is in relation to the constant value defined by ONE_HUNDRED_PERCENT.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *   owner\t\t\t\t\t\t\t=  The queried address.\r\n\t *\r\n\t *   May throw NFT_INVALID_OR_NOT_FINALIZED.\r\n     */\r\n    function get_balance_from( uint256 sha256_of_the_nft_data, address owner ) public view returns (uint)\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n        return  nft.owners[ owner ];\r\n    }\r\n    \r\n    /**\r\n     * Used to retrieve the next available slot to make a buy offer and the timestamp of when it will become available.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *\r\n\t *   May throw NFT_INVALID_OR_NOT_FINALIZED.\r\n     */\r\n    function get_next_available_buy_offer_slot( uint256 sha256_of_the_nft_data ) public view returns ( uint slot_number, uint available_at )\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n        \r\n        uint earliest_slot_available;\r\n        uint earliest_time_available;\r\n        \r\n        for( uint i = 0; i < BUY_OFFER_SLOT_COUNT; i++ )\r\n        {\r\n            BuyOffer memory buy_offer  =  nft.buy_offers[ i ];\r\n            \r\n            bool is_slot_available_now   =   (  buy_offer.expires_at == 0  ||  block.timestamp >= buy_offer.expires_at  );\r\n            if( is_slot_available_now )  return ( i, 0 );\r\n            \r\n            if(  earliest_time_available == 0  ||  buy_offer.expires_at < earliest_time_available  )\r\n            {\r\n                earliest_slot_available  =  i;\r\n                earliest_time_available  =  buy_offer.expires_at;\r\n            }\r\n        }\r\n        \r\n        return  ( earliest_slot_available, earliest_time_available );\r\n    }\r\n    \r\n    function reject_offer( BuyOffer storage buy_offer ) internal\r\n    {\r\n        buy_offer.expires_at  =  0;  // Set slot as empty before sending the wei back to whoever made the previous offer as to avoid a possible re-entrant attack.\r\n        \r\n        // Return wei to whoever made this offer.\r\n        (bool success, )  =  buy_offer.from.call{ value: buy_offer.wei_offered }( \"\" );\r\n        require( success, FAILED_TO_TRANSFER_ETH );\r\n    }\r\n    \r\n    /**\r\n     * Used to propose a buy offer by locking ETH into this contract in exchange for shares of an NFT.\r\n\t * When an owner of the shares invokes 'accept_buy_offer' they receive the locked ETH and the shares are transferred to the buyer.\r\n\t * An offer can be canceled and the ETH returned by invoking 'withdraw_buy_offer'.\r\n\t * Every NFT has the same fixed amount of slots (BUY_OFFER_SLOT_COUNT) to receive buy offers which expire after a period of time (BUY_OFFER_DEFAULT_EXPIRING_TIME or BUY_OFFER_SLOT_0_EXPIRING_TIME).\r\n\t * When an offer has expired, the ETH will be returned after a call to 'withdraw_buy_offer' or when a new offer is placed at the same slot.\r\n\t * The first slot expires faster (BUY_OFFER_SLOT_0_EXPIRING_TIME) and could be used for automated or prearranged offers.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *   requested_amount\t\t\t\t=  The amount of shares requested.\r\n\t *   offer_slot\t\t\t\t\t\t=  An available slot number (starting at 0).\r\n\t *\r\n\t *   May throw NFT_INVALID_OR_NOT_FINALIZED or SLOT_UNAVAILABLE.\r\n\t *\r\n\t *   Emits the BuyOfferMade event.\r\n     */\r\n    function make_buy_offer( uint256 sha256_of_the_nft_data, uint requested_amount, uint offer_slot ) external payable nonReentrant\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n\r\n\t\trequire(  offer_slot < BUY_OFFER_SLOT_COUNT,  SLOT_UNAVAILABLE  );\r\n        \r\n        BuyOffer storage buy_offer\t=  nft.buy_offers[ offer_slot ];\r\n        bool is_empty_slot\t\t\t=  ( buy_offer.expires_at == 0 );\r\n        bool has_offer_expired\t\t=  ( buy_offer.expires_at < block.timestamp );\r\n        require(  is_empty_slot || has_offer_expired,  SLOT_UNAVAILABLE  );\r\n        \r\n        if(  is_empty_slot == false  &&  has_offer_expired == true  )  reject_offer( buy_offer );\r\n        \r\n        buy_offer.from              =  payable( msg.sender );\r\n        buy_offer.requested_amount  =  requested_amount;\r\n        buy_offer.wei_offered       =  msg.value;\r\n        buy_offer.expires_at        =  block.timestamp  +  ( offer_slot == 0 ? BUY_OFFER_SLOT_0_EXPIRING_TIME : BUY_OFFER_DEFAULT_EXPIRING_TIME );\r\n        \r\n        emit BuyOfferMade( sha256_of_the_nft_data, buy_offer.from, buy_offer.requested_amount, buy_offer.wei_offered, buy_offer.expires_at, offer_slot );\r\n    }\r\n    \r\n    /*\r\n    //\r\n    // This function is intentionally disabled becaused it could be abused by an attacker to clog up all the buy offer slots,\r\n    // not allowing enough time for a legit offer to eventually go through.\r\n    //\r\n    function renew_buy_offer( uint256 sha256_of_the_nft_data, uint offer_slot ) external nonReentrant\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n\t\t\r\n\t\trequire(  offer_slot < BUY_OFFER_SLOT_COUNT,  SLOT_UNAVAILABLE  );\r\n        \r\n        BuyOffer storage buy_offer\t=  nft.buy_offers[ offer_slot ];\r\n        bool is_slot_being_used\t\t=  ( buy_offer.expires_at > 0 );\r\n        bool is_owner_of_the_offer\t=  ( msg.sender == buy_offer.from );\r\n        require(  is_slot_being_used && is_owner_of_the_offer,  ACCESS_DENIED  );\r\n        \r\n        buy_offer.expires_at        =  block.timestamp + BUY_OFFER_EXPIRING_TIME;\r\n        \r\n        emit BuyOfferMade( sha256_of_the_nft_data, buy_offer.from, buy_offer.requested_amount, buy_offer.wei_offered, buy_offer.expires_at, offer_slot );\r\n    }\r\n    */\r\n\t\r\n    /**\r\n     * Used to withdraw a buy offer and return the locked ETH.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *   offer_slot\t\t\t\t\t\t=  The slot number in which the offer is located (starting at 0).\r\n\t *\r\n\t *   May throw NFT_INVALID_OR_NOT_FINALIZED, FAILED_TO_TRANSFER_ETH, SLOT_UNAVAILABLE, or ACCESS_DENIED.\r\n\t *\r\n\t *   Emits the BuyOfferWithdrawn event.\r\n     */\r\n    function withdraw_buy_offer( uint256 sha256_of_the_nft_data, uint offer_slot ) external nonReentrant\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n\t\t\r\n\t\trequire(  offer_slot < BUY_OFFER_SLOT_COUNT,  SLOT_UNAVAILABLE  );\r\n        \r\n        BuyOffer storage buy_offer\t=  nft.buy_offers[ offer_slot ];\r\n        bool is_slot_being_used\t\t=  ( buy_offer.expires_at > 0 );\r\n        bool is_owner_of_the_offer\t=  ( msg.sender == buy_offer.from );\r\n        require(  is_slot_being_used && is_owner_of_the_offer,  ACCESS_DENIED  );\r\n        \r\n        emit BuyOfferWithdrawn( sha256_of_the_nft_data, buy_offer.from, buy_offer.requested_amount, buy_offer.wei_offered, offer_slot );\r\n        \r\n        reject_offer( buy_offer );\r\n    }\r\n    \r\n    /**\r\n     * Used to accept a buy offer, receive the locked ETH, and transfer the requested amount of shares to the buyer.\r\n\t *\r\n\t *   sha256_of_the_nft_data\t\t\t=  sha256( nft_data )\r\n\t *   offer_slot\t\t\t\t\t\t=  The slot number in which the offer is located (starting at 0).\r\n\t *   requested_amount\t\t\t\t=  Confirms the amount of shares about to be transferred.\r\n\t *   wei_offered\t\t\t\t\t=  Confirms the amount of ETH (in wei unit) about to be received.\r\n\t *\r\n\t *   May throw NFT_INVALID_OR_NOT_FINALIZED, SLOT_UNAVAILABLE, OFFER_INVALID, OFFER_EXPIRED, OFFER_PARAMETERS_MISMATCH, or FAILED_TO_TRANSFER_ETH.\r\n\t *\r\n\t *   Emits the BuyOfferAccepted event.\r\n     */\r\n    function accept_buy_offer( uint256 sha256_of_the_nft_data, uint offer_slot, uint requested_amount, uint wei_offered ) external nonReentrant\r\n    {\r\n        NFT storage nft  =  nfts[ sha256_of_the_nft_data ];\r\n        make_sure_nft_is_valid_and_finalized( nft );\r\n\t\t\r\n\t\trequire(  offer_slot < BUY_OFFER_SLOT_COUNT,  SLOT_UNAVAILABLE  );\r\n        \r\n        BuyOffer storage buy_offer  =  nft.buy_offers[ offer_slot ];\r\n        require(  buy_offer.expires_at  !=  0,  OFFER_INVALID  );\r\n        require(  block.timestamp  <  buy_offer.expires_at,  OFFER_EXPIRED  );\r\n        require(  buy_offer.requested_amount == requested_amount  &&  buy_offer.wei_offered == wei_offered,  OFFER_PARAMETERS_MISMATCH  );\r\n        \r\n        emit BuyOfferAccepted( sha256_of_the_nft_data, buy_offer.from, msg.sender, requested_amount, wei_offered, offer_slot );\r\n\r\n        transfer( sha256_of_the_nft_data, requested_amount, buy_offer.from );\r\n        \r\n        buy_offer.expires_at  =  0;  // Set the buy offer slot as empty.\r\n\r\n        // Send wei to the person who accepted this offer.\r\n        (bool success, )  =  msg.sender.call{ value: wei_offered }( \"\" );\r\n        require( success, FAILED_TO_TRANSFER_ETH );\r\n    }\r\n}\r\n"
    }
  }
}