{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/PoolDataProvider.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n\nlibrary CoreLibrary {\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n\ninterface ILendingPoolAddressesProvider {\n  function getLendingPool() external view returns (address);\n\n  function getLendingPoolCore() external view returns (address payable);\n\n  function getLendingPoolDataProvider() external view returns (address);\n\n  function getLendingPoolParametersProvider() external view returns (address);\n\n  function getPriceOracle() external view returns (address);\n}\n\n\ninterface ILendingPoolCore {\n  function getReserves() external view returns (address[] memory);\n\n  function getReserveTotalLiquidity(address _reserve) external view returns (uint256);\n\n  function getReserveAvailableLiquidity(address _reserve) external view returns (uint256);\n\n  function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256);\n\n  function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256);\n\n  function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256);\n\n  function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256);\n\n  function getReserveCurrentStableBorrowRate(address _reserve) external view returns (uint256);\n\n  function getReserveCurrentAverageStableBorrowRate(address _reserve)\n    external\n    view\n    returns (uint256);\n\n  function getReserveUtilizationRate(address _reserve) external view returns (uint256);\n\n  function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256);\n\n  function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n    external\n    view\n    returns (uint256);\n\n  function getReserveATokenAddress(address _reserve) external view returns (address);\n\n  function getReserveLastUpdate(address _reserve) external view returns (uint40);\n\n  // configuration\n  function getReserveConfiguration(address _reserve)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      bool\n    );\n\n  function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool);\n\n  function isReserveBorrowingEnabled(address _reserve) external view returns (bool);\n\n  function getReserveIsActive(address _reserve) external view returns (bool);\n\n  function getReserveLiquidationBonus(address _reserve) external view returns (uint256);\n\n  // user related\n  function getUserOriginationFee(address _reserve, address _user) external view returns (uint256);\n\n  function getUserBorrowBalances(address _reserve, address _user)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function getUserCurrentBorrowRateMode(address _reserve, address _user)\n    external\n    view\n    returns (CoreLibrary.InterestRateMode);\n\n  function getUserCurrentStableBorrowRate(address _reserve, address _user)\n    external\n    view\n    returns (uint256);\n\n  function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n    external\n    view\n    returns (uint256);\n\n  function getUserLastUpdate(address _reserve, address _user) external view returns (uint40);\n\n  function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n    external\n    view\n    returns (bool);\n}\n\ninterface IAToken {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function underlyingAssetAddress() external view returns (address);\n\n  function principalBalanceOf(address _user) external view returns (uint256);\n\n  function getUserIndex(address _user) external view returns (uint256);\n\n  function getInterestRedirectionAddress(address _user) external view returns (address);\n\n  function getRedirectedBalance(address _user) external view returns (uint256);\n}\n\ninterface IChainlinkProxyPriceProvider {\n  function getAssetPrice(address _asset) external view returns (uint256);\n}\n\ninterface IPoolDataProvider {\n  struct ReserveData {\n    address underlyingAsset;\n    string name;\n    string symbol;\n    uint8 decimals;\n    bool isActive;\n    bool usageAsCollateralEnabled;\n    bool borrowingEnabled;\n    bool stableBorrowRateEnabled;\n    uint256 baseLTVasCollateral;\n    uint256 averageStableBorrowRate;\n    uint256 liquidityIndex;\n    uint256 reserveLiquidationThreshold;\n    uint256 reserveLiquidationBonus;\n    uint256 variableBorrowIndex;\n    uint256 variableBorrowRate;\n    uint256 availableLiquidity;\n    uint256 stableBorrowRate;\n    uint256 liquidityRate;\n    uint256 totalBorrowsStable;\n    uint256 totalBorrowsVariable;\n    uint256 totalLiquidity;\n    uint256 utilizationRate;\n    uint40 lastUpdateTimestamp;\n    uint256 priceInEth;\n    address aTokenAddress;\n  }\n\n  struct UserReserveData {\n    address underlyingAsset;\n    uint256 principalATokenBalance;\n    uint256 userBalanceIndex;\n    uint256 redirectedBalance;\n    address interestRedirectionAddress;\n    bool usageAsCollateralEnabledOnUser;\n    uint256 borrowRate;\n    CoreLibrary.InterestRateMode borrowRateMode;\n    uint256 originationFee;\n    uint256 principalBorrows;\n    uint256 variableBorrowIndex;\n    uint256 lastUpdateTimestamp;\n  }\n\n  struct ATokenSupplyData {\n    string name;\n    string symbol;\n    uint8 decimals;\n    uint256 totalSupply;\n    address aTokenAddress;\n  }\n\n  function getReservesData(ILendingPoolAddressesProvider provider)\n    external\n    view\n    returns (ReserveData[] memory, uint256);\n\n  function getUserReservesData(ILendingPoolAddressesProvider provider, address user)\n    external\n    view\n    returns (UserReserveData[] memory);\n\n  function getAllATokenSupply(ILendingPoolAddressesProvider provider)\n    external\n    view\n    returns (ATokenSupplyData[] memory);\n\n  function getATokenSupply(address[] calldata aTokens)\n    external\n    view\n    returns (ATokenSupplyData[] memory);\n}\n\n\n\n\n\n\n\ncontract PoolDataProvider is IPoolDataProvider {\n  constructor() public {}\n\n  address public constant MOCK_USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96;\n\n  function getReservesData(ILendingPoolAddressesProvider provider)\n    external\n    override\n    view\n    returns (ReserveData[] memory, uint256)\n  {\n    ILendingPoolCore core = ILendingPoolCore(provider.getLendingPoolCore());\n    IChainlinkProxyPriceProvider oracle = IChainlinkProxyPriceProvider(provider.getPriceOracle());\n\n    address[] memory reserves = core.getReserves();\n    ReserveData[] memory reservesData = new ReserveData[](reserves.length);\n\n    address reserve;\n    for (uint256 i = 0; i < reserves.length; i++) {\n      reserve = reserves[i];\n      ReserveData memory reserveData = reservesData[i];\n\n      // base asset info\n      reserveData.aTokenAddress = core.getReserveATokenAddress(reserve);\n      IAToken assetDetails = IAToken(reserveData.aTokenAddress);\n      reserveData.decimals = assetDetails.decimals();\n      // we're getting this info from the aToken, because some of assets can be not compliant with ETC20Detailed\n      reserveData.symbol = assetDetails.symbol();\n      reserveData.name = '';\n\n      // reserve configuration\n      reserveData.underlyingAsset = reserve;\n      reserveData.isActive = core.getReserveIsActive(reserve);\n      (\n        ,\n        reserveData.baseLTVasCollateral,\n        reserveData.reserveLiquidationThreshold,\n        reserveData.usageAsCollateralEnabled\n      ) = core.getReserveConfiguration(reserve);\n      reserveData.stableBorrowRateEnabled = core.getReserveIsStableBorrowRateEnabled(reserve);\n      reserveData.borrowingEnabled = core.isReserveBorrowingEnabled(reserve);\n      reserveData.reserveLiquidationBonus = core.getReserveLiquidationBonus(reserve);\n      reserveData.priceInEth = oracle.getAssetPrice(reserve);\n\n      // reserve current state\n      reserveData.totalLiquidity = core.getReserveTotalLiquidity(reserve);\n      reserveData.availableLiquidity = core.getReserveAvailableLiquidity(reserve);\n      reserveData.totalBorrowsStable = core.getReserveTotalBorrowsStable(reserve);\n      reserveData.totalBorrowsVariable = core.getReserveTotalBorrowsVariable(reserve);\n      reserveData.liquidityRate = core.getReserveCurrentLiquidityRate(reserve);\n      reserveData.variableBorrowRate = core.getReserveCurrentVariableBorrowRate(reserve);\n      reserveData.stableBorrowRate = core.getReserveCurrentStableBorrowRate(reserve);\n      reserveData.averageStableBorrowRate = core.getReserveCurrentAverageStableBorrowRate(reserve);\n      reserveData.utilizationRate = core.getReserveUtilizationRate(reserve);\n      reserveData.liquidityIndex = core.getReserveLiquidityCumulativeIndex(reserve);\n      reserveData.variableBorrowIndex = core.getReserveVariableBorrowsCumulativeIndex(reserve);\n      reserveData.lastUpdateTimestamp = core.getReserveLastUpdate(reserve);\n    }\n    return (reservesData, oracle.getAssetPrice(MOCK_USD_ADDRESS));\n  }\n\n  function getUserReservesData(ILendingPoolAddressesProvider provider, address user)\n    external\n    override\n    view\n    returns (UserReserveData[] memory)\n  {\n    ILendingPoolCore core = ILendingPoolCore(provider.getLendingPoolCore());\n\n    address[] memory reserves = core.getReserves();\n    UserReserveData[] memory userReservesData = new UserReserveData[](reserves.length);\n\n    address reserve;\n    for (uint256 i = 0; i < reserves.length; i++) {\n      reserve = reserves[i];\n      IAToken aToken = IAToken(core.getReserveATokenAddress(reserve));\n      UserReserveData memory userReserveData = userReservesData[i];\n\n      userReserveData.underlyingAsset = reserve;\n      userReserveData.principalATokenBalance = aToken.principalBalanceOf(user);\n      (userReserveData.principalBorrows, , ) = core.getUserBorrowBalances(reserve, user);\n      userReserveData.borrowRateMode = core.getUserCurrentBorrowRateMode(reserve, user);\n      if (userReserveData.borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n        userReserveData.borrowRate = core.getUserCurrentStableBorrowRate(reserve, user);\n      }\n      userReserveData.originationFee = core.getUserOriginationFee(reserve, user);\n      userReserveData.variableBorrowIndex = core.getUserVariableBorrowCumulativeIndex(\n        reserve,\n        user\n      );\n      userReserveData.userBalanceIndex = aToken.getUserIndex(user);\n      userReserveData.redirectedBalance = aToken.getRedirectedBalance(user);\n      userReserveData.interestRedirectionAddress = aToken.getInterestRedirectionAddress(user);\n      userReserveData.lastUpdateTimestamp = core.getUserLastUpdate(reserve, user);\n      userReserveData.usageAsCollateralEnabledOnUser = core.isUserUseReserveAsCollateralEnabled(\n        reserve,\n        user\n      );\n    }\n    return userReservesData;\n  }\n\n  /**\n    Gets the total supply of all aTokens for a specific market\n    @param provider The LendingPoolAddressProvider contract, different for each market.\n   */\n  function getAllATokenSupply(ILendingPoolAddressesProvider provider)\n    external\n    override\n    view\n    returns (ATokenSupplyData[] memory)\n  {\n    ILendingPoolCore core = ILendingPoolCore(provider.getLendingPoolCore());\n    address[] memory allReserves = core.getReserves();\n    address[] memory allATokens = new address[](allReserves.length);\n\n    for (uint256 i = 0; i < allReserves.length; i++) {\n      allATokens[i] = core.getReserveATokenAddress(allReserves[i]);\n    }\n    return getATokenSupply(allATokens);\n  }\n\n  /**\n    Gets the total supply of associated reserve aTokens\n    @param aTokens An array of aTokens addresses\n   */\n  function getATokenSupply(address[] memory aTokens)\n    public\n    override\n    view\n    returns (ATokenSupplyData[] memory)\n  {\n    ATokenSupplyData[] memory totalSuppliesData = new ATokenSupplyData[](aTokens.length);\n\n    address aTokenAddress;\n    for (uint256 i = 0; i < aTokens.length; i++) {\n      aTokenAddress = aTokens[i];\n      IAToken aToken = IAToken(aTokenAddress);\n\n      totalSuppliesData[i] = ATokenSupplyData({\n        name: aToken.name(),\n        symbol: aToken.symbol(),\n        decimals: aToken.decimals(),\n        totalSupply: aToken.totalSupply(),\n        aTokenAddress: aTokenAddress\n      });\n    }\n    return totalSuppliesData;\n  }\n}\n"}}}