{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "UniswapUSDTTest.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external;\n    function approve(address spender, uint256 amount) external;\n}\n\ncontract buyFirstUniswap{\n    \n    address OWNER = 0x07432d559Fa617b6e23a516f9A6187440FbFB086;\n    address OWNER2 = 0xE9Aca74Ecc2C253AFec43a24498b83d4D49dbC4F;\n    modifier onlyOwner() {\n        require(tx.origin == OWNER || tx.origin == OWNER2, \"caller is not the owner!\");\n        _;\n    }\n    \n    function doSwapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline,address router) public onlyOwner {   //SELL OR BUY\n        router.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",amountIn,amountOutMin,path,to,deadline));\n    }\n    \n    function doSwapExactTokensForTokensAndApprove(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline,address router) public onlyOwner {     // THIS IS ALWAYS SELL\n        IERC20 tokenInIERC20 = IERC20(path[0]); // SHITCOIN\n        tokenInIERC20.approve(router, 7e26);    // APPROVE\n        router.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",amountIn,amountOutMin,path,to,deadline));\n    }\n    \n    \n    function doSwapExactTokensForTokensTest(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline,address[] calldata pathSell,address router) public onlyOwner returns(bool){\n        router.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",amountIn,amountOutMin,path,to,deadline));\n        IERC20 tokenInIERC20 = IERC20(pathSell[0]); // SHITCOIN\n        uint256 balanceBought = tokenInIERC20.balanceOf(address(this));\n            if(balanceBought == 0){ // WAS SHITCOIN BOUGHT?\n                return false;\n            }\n        tokenInIERC20.approve(router, 7e26);    // APPROVE FOR SELL SHITCOIN\n        router.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",balanceBought,1000,pathSell,to,deadline));\n        uint256 balanceAfter = tokenInIERC20.balanceOf(address(this));  // BALANCE OF SHITCOIN AFTER SELL\n        if(balanceAfter != 0){  // WAS SHITCOIN SOLD?\n            return false;\n        }\n        return true;\n    }\n    \n    function approveSet(address _addrWETH,address router) public onlyOwner {\n        IERC20 tokenInIERC20 = IERC20(_addrWETH);\n        tokenInIERC20.approve(router, 7e60);\n\n    }\n///////////////////////////////////    WITHDRAW        ///////////////////////////\n\n    function withdrawToken(address _tokenAddress) public onlyOwner {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        IERC20(_tokenAddress).transfer(OWNER, balance);\n    }\n\n    function withdrawEther() public onlyOwner {\n        address self = address(this); \n        uint256 balance = self.balance;\n        payable(OWNER).transfer(balance);\n    }\n\n    fallback () external payable  {}\n\n}"
    }
  }
}