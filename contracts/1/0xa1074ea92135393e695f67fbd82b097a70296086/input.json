{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/PermanentStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.5;\n\nimport \"./interface/IPermanentStorage.sol\";\nimport \"./utils/lib_storage/PSStorage.sol\";\n\ncontract PermanentStorage is IPermanentStorage {\n\n    // Constants do not have storage slot.\n    bytes32 public constant curveTokenIndexStorageId = 0xf4c750cdce673f6c35898d215e519b86e3846b1f0532fb48b84fe9d80f6de2fc; // keccak256(\"curveTokenIndex\")\n    bytes32 public constant transactionSeenStorageId = 0x695d523b8578c6379a2121164fd8de334b9c5b6b36dff5408bd4051a6b1704d0;  // keccak256(\"transactionSeen\")\n    bytes32 public constant relayerValidStorageId = 0x2c97779b4deaf24e9d46e02ec2699240a957d92782b51165b93878b09dd66f61;  // keccak256(\"relayerValid\")\n\n    // Below are the variables which consume storage slots.\n    address public operator;\n    string public version;  // Current version of the contract\n    mapping(bytes32 => mapping(address => bool)) private permission;\n\n\n    /************************************************************\n    *          Access control and ownership management          *\n    *************************************************************/\n    modifier onlyOperator() {\n        require(operator == msg.sender, \"PermanentStorage: not the operator\");\n        _;\n    }\n\n    modifier validRole(bool _enabled, address _role) {\n        if (_enabled) {\n            require(\n                (_role == operator) || (_role == ammWrapperAddr()) || (_role == pmmAddr()),\n                \"PermanentStorage: not a valid role\"\n            );\n        }\n        _;\n    }\n\n    modifier isPermitted(bytes32 _storageId, address _role) {\n        require(permission[_storageId][_role], \"PermanentStorage: has no permission\");\n        _;\n    }\n\n\n    function transferOwnership(address _newOperator) external onlyOperator {\n        require(_newOperator != address(0), \"PermanentStorage: operator can not be zero address\");\n        operator = _newOperator;\n    }\n\n    /// @dev Set permission for entity to write certain storage.\n    function setPermission(bytes32 _storageId, address _role, bool _enabled) external onlyOperator validRole(_enabled, _role) {\n        permission[_storageId][_role] = _enabled;\n    }\n\n\n    /************************************************************\n    *              Constructor and init functions               *\n    *************************************************************/\n    /// @dev Replacing constructor and initialize the contract. This function should only be called once.\n    function initialize(address _operator) external {\n        require(\n            keccak256(abi.encodePacked(version)) == keccak256(abi.encodePacked(\"\")),\n            \"PermanentStorage: not upgrading from default version\"\n        );\n\n        version = \"5.0.0\";\n        operator = _operator;\n    }\n\n\n    /************************************************************\n    *                     Getter functions                      *\n    *************************************************************/\n    function hasPermission(bytes32 _storageId, address _role) external view returns (bool) {\n        return permission[_storageId][_role];\n    }\n\n    function ammWrapperAddr() public view returns (address) {\n        return PSStorage.getStorage().ammWrapperAddr;\n    }\n\n    function pmmAddr() public view returns (address) {\n        return PSStorage.getStorage().pmmAddr;\n    }\n\n    function wethAddr() override external view returns (address) {\n        return PSStorage.getStorage().wethAddr;\n    }\n\n    function getCurveTokenIndex(address _makerAddr, address _assetAddr) override external view returns (int128) {\n        return AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][_assetAddr];\n    }\n\n    function isTransactionSeen(bytes32 _transactionHash) override external view returns (bool) {\n        return AMMWrapperStorage.getStorage().transactionSeen[_transactionHash];\n    }\n\n    function isRelayerValid(address _relayer) override external view returns (bool) {\n        return AMMWrapperStorage.getStorage().relayerValid[_relayer];\n    }\n\n\n    /************************************************************\n    *           Management functions for Operator               *\n    *************************************************************/\n    /// @dev Update AMMWrapper contract address.\n    function upgradeAMMWrapper(address _newAMMWrapper) external onlyOperator {\n        PSStorage.getStorage().ammWrapperAddr = _newAMMWrapper;\n    }\n\n    /// @dev Update PMM contract address.\n    function upgradePMM(address _newPMM) external onlyOperator {\n        PSStorage.getStorage().pmmAddr = _newPMM;\n    }\n\n    /// @dev Update WETH contract address.\n    function upgradeWETH(address _newWETH) external onlyOperator {\n        PSStorage.getStorage().wethAddr = _newWETH;\n    }\n\n\n    /************************************************************\n    *                   External functions                      *\n    *************************************************************/\n    function setCurveTokenIndex(address _makerAddr, address[] calldata _assetAddrs) override external isPermitted(curveTokenIndexStorageId, msg.sender) {\n        int128 tokenLength = int128(_assetAddrs.length);\n        for (int128 i = 0 ; i < tokenLength; i++) {\n            address assetAddr = _assetAddrs[uint256(i)];\n            AMMWrapperStorage.getStorage().curveTokenIndexes[_makerAddr][assetAddr] = i;\n        }\n    }\n\n    function setTransactionSeen(bytes32 _transactionHash) override external isPermitted(transactionSeenStorageId, msg.sender) {\n        AMMWrapperStorage.getStorage().transactionSeen[_transactionHash] = true;\n    }\n\n    function setRelayersValid(address[] calldata _relayers, bool[] calldata _isValids) override external isPermitted(relayerValidStorageId, msg.sender) {\n        require(_relayers.length == _isValids.length, \"PermanentStorage: inputs length mismatch\");\n        for (uint256 i = 0; i < _relayers.length; i++) {\n            AMMWrapperStorage.getStorage().relayerValid[_relayers[i]] = _isValids[i];\n        }\n    }\n}\n"
    },
    "contracts/interface/IPermanentStorage.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface IPermanentStorage {\n    function wethAddr() external view returns (address);\n    function getCurveTokenIndex(address _makerAddr, address _assetAddr) external view returns (int128);\n    function setCurveTokenIndex(address _makerAddr, address[] calldata _assetAddrs) external;\n    function isTransactionSeen(bytes32 _transactionHash) external view returns (bool);\n    function isRelayerValid(address _relayer) external view returns (bool);\n    function setTransactionSeen(bytes32 _transactionHash) external;\n    function setRelayersValid(address[] memory _relayers, bool[] memory _isValids) external;\n}"
    },
    "contracts/utils/lib_storage/PSStorage.sol": {
      "content": "pragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nlibrary PSStorage {\n    bytes32 private constant STORAGE_SLOT = 0x92dd52b981a2dd69af37d8a3febca29ed6a974aede38ae66e4ef773173aba471;\n\n    struct Storage {\n        address ammWrapperAddr;\n        address pmmAddr;\n        address wethAddr;\n    }\n\n    /// @dev Get the storage bucket for this contract.\n    function getStorage() internal pure returns (Storage storage stor) {\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\"permanent.storage.storage\")) - 1));\n        bytes32 slot = STORAGE_SLOT;\n\n        // Dip into assembly to change the slot pointed to by the local\n        // variable `stor`.\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\n        assembly { stor_slot := slot }\n    }\n}\n\nlibrary AMMWrapperStorage {\n    bytes32 private constant STORAGE_SLOT = 0xd38d862c9fa97c2fa857a46e08022d272a3579c114ca4f335f1e5fcb692c045e;\n\n    struct Storage {\n        mapping(bytes32 => bool) transactionSeen;\n        mapping(address => mapping(address => int128)) curveTokenIndexes;\n        mapping(address => bool) relayerValid;\n    }\n\n    /// @dev Get the storage bucket for this contract.\n    function getStorage() internal pure returns (Storage storage stor) {\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\"permanent.ammwrapper.storage\")) - 1));\n        bytes32 slot = STORAGE_SLOT;\n\n        // Dip into assembly to change the slot pointed to by the local\n        // variable `stor`.\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\n        assembly { stor_slot := slot }\n    }\n}\n\nlibrary PMMStorage {\n    bytes32 private constant STORAGE_SLOT = 0xf9faf013fe1696003dca3723ade1a1b88f21762ea39d9dfa2c55c5bd9c4ae6e9;\n\n    struct Storage {\n        mapping(bytes32 => address) transactions;\n    }\n\n    /// @dev Get the storage bucket for this contract.\n    function getStorage() internal pure returns (Storage storage stor) {\n        assert(STORAGE_SLOT == bytes32(uint256(keccak256(\"permanent.pmm.storage\")) - 1));\n        bytes32 slot = STORAGE_SLOT;\n\n        // Dip into assembly to change the slot pointed to by the local\n        // variable `stor`.\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\n        assembly { stor_slot := slot }\n    }\n}"
    }
  }
}