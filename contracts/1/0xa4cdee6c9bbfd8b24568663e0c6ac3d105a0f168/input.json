{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"VM/CommandBuilder.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nuint256 constant IDX_VARIABLE_LENGTH = 0x80;\r\nuint256 constant IDX_VALUE_MASK = 0x7f;\r\nuint256 constant IDX_END_OF_ARGS = 0xff;\r\nuint256 constant IDX_USE_STATE = 0xfe;\r\n\r\nlibrary CommandBuilder {\r\n    function buildInputs(\r\n        bytes[] memory state,\r\n        bytes4 selector,\r\n        bytes32 indices\r\n    ) internal view returns (bytes memory ret) {\r\n        uint256 count = 0; // Number of bytes in whole ABI encoded message\r\n        uint256 free = 0; // Pointer to first free byte in tail part of message\r\n        bytes memory stateData; // Optionally encode the current state if the call requires it\r\n\r\n        uint256 idx;\r\n\r\n        // Determine the length of the encoded data\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            idx = uint8(indices[i]);\r\n            if (idx == IDX_END_OF_ARGS) break;\r\n\r\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\r\n                if (idx == IDX_USE_STATE) {\r\n                    if (stateData.length == 0) {\r\n                        stateData = abi.encode(state);\r\n                    }\r\n                    count += stateData.length;\r\n                    free += 32;\r\n                } else {\r\n                    // Add the size of the value, rounded up to the next word boundary, plus space for pointer and length\r\n                    uint256 arglen = state[idx & IDX_VALUE_MASK].length;\r\n                    require(\r\n                        arglen % 32 == 0,\r\n                        \"Dynamic state variables must be a multiple of 32 bytes\"\r\n                    );\r\n                    count += arglen + 32;\r\n                    free += 32;\r\n                }\r\n            } else {\r\n                require(\r\n                    state[idx & IDX_VALUE_MASK].length == 32,\r\n                    \"Static state variables must be 32 bytes\"\r\n                );\r\n                count += 32;\r\n                free += 32;\r\n            }\r\n        }\r\n\r\n        // Encode it\r\n        ret = new bytes(count + 4);\r\n        assembly {\r\n            mstore(add(ret, 32), selector)\r\n        }\r\n        count = 0;\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            idx = uint8(indices[i]);\r\n            if (idx == IDX_END_OF_ARGS) break;\r\n\r\n            if (idx & IDX_VARIABLE_LENGTH != 0) {\r\n                if (idx == IDX_USE_STATE) {\r\n                    assembly {\r\n                        mstore(add(add(ret, 36), count), free)\r\n                    }\r\n                    memcpy(stateData, 32, ret, free + 4, stateData.length - 32);\r\n                    free += stateData.length - 32;\r\n                    count += 32;\r\n                } else {\r\n                    uint256 arglen = state[idx & IDX_VALUE_MASK].length;\r\n\r\n                    // Variable length data; put a pointer in the slot and write the data at the end\r\n                    assembly {\r\n                        mstore(add(add(ret, 36), count), free)\r\n                    }\r\n                    memcpy(\r\n                        state[idx & IDX_VALUE_MASK],\r\n                        0,\r\n                        ret,\r\n                        free + 4,\r\n                        arglen\r\n                    );\r\n                    free += arglen;\r\n                    count += 32;\r\n                }\r\n            } else {\r\n                // Fixed length data; write it directly\r\n                bytes memory statevar = state[idx & IDX_VALUE_MASK];\r\n                assembly {\r\n                    mstore(add(add(ret, 36), count), mload(add(statevar, 32)))\r\n                }\r\n                count += 32;\r\n            }\r\n        }\r\n    }\r\n\r\n    function writeOutputs(\r\n        bytes[] memory state,\r\n        bytes1 index,\r\n        bytes memory output\r\n    ) internal view returns (bytes[] memory) {\r\n        uint256 idx = uint8(index);\r\n        if (idx == IDX_END_OF_ARGS) return state;\r\n\r\n        if (idx & IDX_VARIABLE_LENGTH != 0) {\r\n            if (idx == IDX_USE_STATE) {\r\n                state = abi.decode(output, (bytes[]));\r\n            } else {\r\n                // Check the first field is 0x20 (because we have only a single return value)\r\n                uint256 argptr;\r\n                assembly {\r\n                    argptr := mload(add(output, 32))\r\n                }\r\n                require(\r\n                    argptr == 32,\r\n                    \"Only one return value permitted (variable)\"\r\n                );\r\n\r\n                assembly {\r\n                    // Overwrite the first word of the return data with the length - 32\r\n                    mstore(add(output, 32), sub(mload(output), 32))\r\n                    // Insert a pointer to the return data, starting at the second word, into state\r\n                    mstore(\r\n                        add(add(state, 32), mul(and(idx, IDX_VALUE_MASK), 32)),\r\n                        add(output, 32)\r\n                    )\r\n                }\r\n            }\r\n        } else {\r\n            // Single word\r\n            require(\r\n                output.length == 32,\r\n                \"Only one return value permitted (static)\"\r\n            );\r\n\r\n            state[idx & IDX_VALUE_MASK] = output;\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    function writeTuple(\r\n        bytes[] memory state,\r\n        bytes1 index,\r\n        bytes memory output\r\n    ) internal view {\r\n        uint8 idx = uint8(index);\r\n        if (idx == IDX_END_OF_ARGS) return;\r\n\r\n        bytes memory entry = state[idx] = new bytes(output.length + 32);\r\n        memcpy(output, 0, entry, 32, output.length);\r\n        assembly {\r\n            let l := mload(output)\r\n            mstore(add(entry, 32), l)\r\n        }\r\n    }\r\n\r\n    function memcpy(\r\n        bytes memory src,\r\n        uint256 srcidx,\r\n        bytes memory dest,\r\n        uint256 destidx,\r\n        uint256 len\r\n    ) internal view {\r\n        assembly {\r\n            pop(\r\n                staticcall(\r\n                    gas(),\r\n                    4,\r\n                    add(add(src, 32), srcidx),\r\n                    len,\r\n                    add(add(dest, 32), destidx),\r\n                    len\r\n                )\r\n            )\r\n        }\r\n    }\r\n}"}}}