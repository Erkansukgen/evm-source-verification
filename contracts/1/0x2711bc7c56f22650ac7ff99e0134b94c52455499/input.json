{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "unicryptBad.sol": {
      "content": "// SPDX-License-Identifier: 0BSD\r\n\r\npragma solidity ^0.8.10;\r\n\r\ninterface ERC20 {\r\n    function transfer(address to, uint tokens) external;\r\n    function transferFrom(address from, address to, uint tokens) external;\r\n    function balanceOf(address owner) external returns (uint);\r\n}\r\n\r\ncontract UnicryptIsBad { // can handle rebasing tokens, simple locks, and \"warning-with-delay\" locks\r\n\r\n    mapping(uint => address) public owners;\r\n    mapping(uint => address) public tokens;\r\n    mapping(uint => uint) public amounts;\r\n    mapping(uint => uint) public dates;\r\n    mapping(uint => uint) public delays;\r\n    mapping(address => uint) public totals;\r\n    uint public id;\r\n\r\n    function lock(address token, uint amount, uint date, uint delay) public {\r\n        require(amount > 0, \"amount must be greater than 0\");\r\n        uint balance = ERC20(token).balanceOf(address(this));\r\n        owners[id] = msg.sender;\r\n        tokens[id] = token;\r\n        dates[id] = date;\r\n        delays[id] = delay;\r\n        ERC20(token).transferFrom(msg.sender, address(this), amount);\r\n        amount = ERC20(token).balanceOf(address(this)) - balance;\r\n        emit Lock(token, msg.sender, amount, date, delay, id);\r\n        amounts[id] = amount;\r\n        totals[token] += amount;\r\n        id++;\r\n    }\r\n\r\n    function unlock(uint id_) public {\r\n        require(block.timestamp >= dates[id_], \"not yet unlockable\");\r\n        require(owners[id_] != address(0), \"invalid\");\r\n        require(msg.sender == owners[id_], \"not lock owner\");\r\n        if (delays[id_] > 0) { // if lock has a delay\r\n            if (dates[id_] == 0) { // but no date assigned\r\n                uint date = block.timestamp + delays[id_];\r\n                emit Warning(id_, date);\r\n                dates[id_] = date;\r\n            } else { // and date has been assigned\r\n                _unlock(id_);\r\n            }\r\n        } else { // if lock has no delay\r\n            _unlock(id_);\r\n        }\r\n    }\r\n\r\n    function _unlock(uint id_) internal {\r\n        totals[tokens[id_]] -= amounts[id_];\r\n        ERC20(tokens[id_]).transfer(owners[id_], amounts[id_]);\r\n        emit Unlock(id_);\r\n        owners[id_] = address(0);\r\n        tokens[id_] = address(0);\r\n        amounts[id_] = 0;\r\n        dates[id_] = 0;\r\n        delays[id_] = 0;\r\n    }\r\n\r\n    function skim(address token) public {\r\n        uint extra = ERC20(token).balanceOf(address(this)) - totals[token];\r\n        if (extra > 0)\r\n            ERC20(token).transfer(msg.sender, extra);\r\n    }\r\n\r\n    event Lock(address indexed token, address indexed locker, uint amount, uint date, uint delay, uint id);\r\n    event Unlock(uint indexed id);\r\n    event Warning(uint indexed id, uint date);\r\n\r\n}\r\n"
    }
  }
}