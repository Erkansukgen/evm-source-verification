{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ERC1155.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nlibrary Strings {\n\n    function toString(uint256 value) internal pure returns (string memory) {\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n\nlibrary EnumerableMap {\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        MapEntry[] _entries;\n\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            map._entries[toDeleteIndex] = lastEntry;\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            map._entries.pop();\n\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n\nlibrary EnumerableSet {\n    struct Set {\n        bytes32[] _values;\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n            bytes32 lastvalue = set._values[lastIndex];\n\n            set._values[toDeleteIndex] = lastvalue;\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            set._values.pop();\n\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\ninterface IERC165 {\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */ \n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC1155 is IERC165 {\n\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    event tokenBaseURI(string value);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function contractOwner() external view returns(address owner); \n    function royaltyFee(uint256 tokenId) external view returns(uint256);\n    function getCreator(uint256 tokenId) external view returns(address);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n    function setApprovalForAll(address operator, bool approved) external;\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n    function mintAndTransfer(address from, address to, uint256 itemId, uint256 fee, uint256 _supply, string memory _tokenURI, uint256 qty, bytes memory data)external returns(uint256);\n\n}\n\ninterface IERC1155MetadataURI is IERC1155 {\n}\n\ninterface IERC1155Receiver is IERC165 {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n*/\n\nlibrary SafeMath {\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n}\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using SafeMath for uint256;\n    using Address for address;\n    using Strings for uint256;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => address) private creators;\n    mapping (uint256 => uint256) private _royaltyFee;\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n    string public tokenURIPrefix;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    string private _name;\n\n    string private _symbol;\n\n    address public transferProxy;\n\n    address private owner;\n\n    uint256 tokenCounter = 1;\n\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    constructor (string memory name_, string memory symbol_, address _transferProxy) {\n        _name = name_;\n        _symbol = symbol_;\n        owner = msg.sender;\n        transferProxy = _transferProxy;\n\n        _registerInterface(_INTERFACE_ID_ERC1155);\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n        * @dev Internal function to set the token URI for a given token.\n        * Reverts if the token ID does not exist.\n        * @param tokenId uint256 ID of the token to set its URI\n        * @param uri string URI to assign\n    */    \n\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        _tokenURIs[tokenId] = uri;\n    }\n\n\n    function contractOwner() public view virtual override returns(address){\n        return owner;\n    }\n\n    /**\n        @notice Get the royalty associated with tokenID.\n        @param tokenId     ID of the Token.\n        @return        royaltyFee of given ID.\n     */\n\n    function royaltyFee(uint256 tokenId) public view override returns(uint256) {\n        return _royaltyFee[tokenId];\n    }\n\n    /**\n        @notice Get the creator of given tokenID.\n        @param tokenId     ID of the Token.\n        @return        creator of given ID.\n     */    \n\n    function getCreator(uint256 tokenId) public view virtual override returns(address) {\n        return creators[tokenId];\n    }\n\n    /**\n        * @dev Internal function to set the token URI for all the tokens.\n        * @param _tokenURIPrefix string memory _tokenURIPrefix of the tokens.\n    */   \n\n    function _setTokenURIPrefix(string memory _tokenURIPrefix) internal {\n        tokenURIPrefix = _tokenURIPrefix;\n        emit tokenBaseURI(_tokenURIPrefix);\n    }\n\n    /**\n        * @dev Returns an URI for a given token ID.\n        * Throws if the token ID does not exist. May return an empty string.\n        * @param tokenId uint256 ID of the token to query\n    */    \n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC1155Metadata: URI query for nonexistent token\");\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = tokenURIPrefix;\n\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n        @notice Get the balance of an account's Tokens.\n        @param account  The address of the token holder\n        @param tokenId     ID of the Token\n        @return        The owner's balance of the Token type requested\n     */\n\n    function balanceOf(address account, uint256 tokenId) public view override returns (uint256) {\n        require(_exists(tokenId), \"ERC1155Metadata: balance query for nonexistent token\");\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[tokenId][account];\n    }\n\n\n    /**\n        @notice Get the balance of multiple account/token pairs\n        @param accounts The addresses of the token holders\n        @param ids    ID of the Tokens\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n     */\n\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }\n\n    /**\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n        @dev MUST emit the ApprovalForAll event on success.\n        @param operator  Address to add to the set of authorized operators\n        @param approved  True if the operator is approved, false to revoke approval\n    */\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param account     The owner of the Tokens\n        @param operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\n        MUST revert on any other error.\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param tokenId      ID of the token type\n        @param amount   Transfer amount\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\n    */    \n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(tokenId), _asSingletonArray(amount), data);\n\n        _balances[tokenId][from] = _balances[tokenId][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[tokenId][to] = _balances[tokenId][to].add(amount);\n\n        emit TransferSingle(operator, from, to, tokenId, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, tokenId, amount, data);\n    }\n\n    /**\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\n        MUST revert if `_to` is the zero address.\n        MUST revert if length of `_ids` is not the same as length of `_values`.\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\n        MUST revert on any other error.\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\n        @param from    Source address\n        @param to      Target address\n        @param tokenIds     IDs of each token type (order and length must match _values array)\n        @param amounts  Transfer amounts per token type (order and length must match _ids array)\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    */\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, tokenIds, amounts, data);\n\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            uint256 tokenId = tokenIds[i];\n            uint256 amount = amounts[i];\n\n            _balances[tokenId][from] = _balances[tokenId][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[tokenId][to] = _balances[tokenId][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, tokenIds, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, tokenIds, amounts, data);\n    }\n\n\n\n    /**\n        * @dev Internal function to mint a new token.\n        * Reverts if the given token ID already exists.\n        * @param tokenId uint256 ID of the token to be minted\n        * @param _supply uint256 supply of the token to be minted\n        * @param _uri string memory URI of the token to be minted\n        * @param _fee uint256 royalty of the token to be minted\n    */\n\n    function _mint(address from, uint256 tokenId, uint256 _supply, string memory _uri, uint256 _fee) internal {\n        require(!_exists(tokenId), \"ERC1155: token already minted\");\n        require(_supply != 0, \"Supply should be positive\");\n        require(bytes(_uri).length > 0, \"uri should be set\");\n\n        creators[tokenId] = from;\n        _tokenOwners.set(tokenId, from);\n        _royaltyFee[tokenId] = _fee;\n        _balances[tokenId][from] = _supply;\n        _setTokenURI(tokenId, _uri);\n\n        emit TransferSingle(from, address(0x0), from, tokenId, _supply);\n        emit URI(_uri, tokenId);\n    }\n\n    /**\n        * @dev version of {_mint}.\n        *\n        * Requirements:\n        *\n        * - `tokenIds` and `amounts` must have the same length.\n    */\n\n    function _mintBatch(address to, uint256[] memory tokenIds, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, tokenIds, amounts, data);\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            _balances[tokenIds[i]][to] = amounts[i].add(_balances[tokenIds[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, tokenIds, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, tokenIds, amounts, data);\n    }\n\n    /**\n        * @dev Internal function to burn a specific token.\n        * Reverts if the token does not exist.\n        * Deprecated, use {ERC721-_burn} instead.\n        * @param account owner of the token to burn\n        * @param tokenId uint256 ID of the token being burned\n        * @param amount uint256 amount of supply being burned\n    */    \n\n    function _burn(address account, uint256 tokenId, uint256 amount) internal virtual {\n        require(_exists(tokenId), \"ERC1155Metadata: burn query for nonexistent token\");\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(tokenId), _asSingletonArray(amount), \"\");\n\n        _balances[tokenId][account] = _balances[tokenId][account].sub(\n            amount,\n            \"ERC_holderTokens1155: burn amount exceeds balance\"\n        );\n\n\n        emit TransferSingle(operator, account, address(0), tokenId, amount);\n    }\n\n\n    /**\n        * @dev version of {_burn}.\n        * Requirements:\n        * - `ids` and `amounts` must have the same length.\n    */\n\n    function _burnBatch(address account, uint256[] memory tokenIds, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), tokenIds, amounts, \"\");\n\n        for (uint i = 0; i < tokenIds.length; i++) {\n            _balances[tokenIds[i]][account] = _balances[tokenIds[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), tokenIds, amounts);\n    }\n\n    function mintAndTransfer(address from, address to, uint256 itemId, uint256 fee, uint256 _supply,string memory _tokenURI, uint256 qty,bytes memory data) public virtual override returns(uint256){\n        require(msg.sender == transferProxy,\"ERC1155: caller is not Approved\");\n        itemId = tokenCounter;\n        _operatorApprovals[from][transferProxy] = true;\n        _mint(from, itemId, _supply, _tokenURI, fee);\n        safeTransferFrom(from, to, itemId, qty, data);\n        tokenCounter += 1;\n        return itemId;\n\n    }\n\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, tokenId, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, tokenIds, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\ncontract MintySwap is ERC1155 {\n\n    address private owner;\n\n    struct Sign {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    constructor (string memory name, string memory symbol, string memory tokenURIPrefix, address _transferProxy) ERC1155 (name, symbol, _transferProxy) {\n        owner = msg.sender;\n        _setTokenURIPrefix(tokenURIPrefix);\n\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /** @dev change the Ownership from current owner to newOwner address\n        @param newOwner : newOwner address */    \n\n    function ownerTransfership(address newOwner) public onlyOwner returns(bool){\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        owner = newOwner;\n        return true;\n    }\n\n    /** @dev verify the tokenURI that should be verified by owner of the contract.\n        *requirements: signer must be owner of the contract\n        @param tokenURI string memory URI of token to be minted.\n        @param sign struct combination of uint8, bytes32, bytes 32 are v, r, s.\n        note : sign value must be in the order of v, r, s.\n\n    */\n\n    function verifySign(string memory tokenURI, Sign memory sign) internal view {\n        bytes32 hash = keccak256(abi.encodePacked(this,tokenURI));\n        require(owner == ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), sign.v, sign.r, sign.s), \"Owner sign verification failed\");\n    }\n\n    function mint(string memory uri, uint256 supply, uint256 fee, Sign memory sign)  public {\n        verifySign(uri, sign);\n        _mint(msg.sender, tokenCounter, supply, uri, fee);\n        tokenCounter = tokenCounter + 1;\n    }\n\n    function setBaseURI(string memory _baseURI) public onlyOwner{\n         _setTokenURIPrefix(_baseURI);\n    }\n\n    function burn(uint256 tokenId, uint256 supply) public {\n        _burn(msg.sender, tokenId, supply);\n    }\n\n    function burnBatch(uint256[] memory tokenIds, uint256[] memory amounts) public {\n        _burnBatch(msg.sender, tokenIds, amounts);\n    }\n}"
    }
  }
}