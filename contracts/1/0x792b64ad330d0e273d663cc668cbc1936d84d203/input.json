{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Switch.sol": {
      "content": "pragma solidity ^0.5.0;\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying an instance of this contract,which \r\n    // should be used via inheritance.\r\n    constructor() internal {}\r\n    \r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n    \r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\r\n    \r\n    // Initialized the contract setting the deployer as the initial owner\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0),msgSender);\r\n    }\r\n    \r\n    // Returns the address of the current owner.\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    modifier onlyOwner(){\r\n        require(isOwner(),\"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n    \r\n    // Leaves the contract without owner.It will not be possible to call \"onlyOwner\" function anymore.\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner,address(0));\r\n        _owner = address(0);\r\n    }\r\n    \r\n    // Transfers ownership of the contract to a new account\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n    \r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0),\"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner,newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract IERC20 {\r\n    function name() public view returns (string memory) { }\r\n\r\n    function symbol() public view returns (string memory) { }\r\n\r\n    function decimals() public view returns (uint8) { }\r\n\r\n    function totalSupply() public view returns (uint256) { }\r\n\r\n    function balanceOf(address account) public view returns (uint256) { }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) { }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) { }\r\n\r\n    function approve(address spender, uint256 amount) public  returns (bool) { }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public  returns (bool) { }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) { }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) { }\r\n\r\n\r\n}\r\n\r\n\r\ncontract Switch is Ownable {\r\n    uint currentChainIndex;\r\n    IERC20 public AntasyContract;\r\n    address public switchContract;\r\n    address payable public beneficiary;\r\n    \r\n    event Init(address initialAddress,uint chainIndex);\r\n    event ChangeSwitchContract(address preAddress,address currentAddress);\r\n    event ChangeBeneficiary(address preAddress,address currentAddress);\r\n    event SwitchRecord(address fromAddress,uint targetChain,uint256 amount,address targetAddress);\r\n    \r\n    // chainIndex == 1 : eth  chainIndex == 2 : heco chainIndex == 3 : bsc\r\n    constructor(uint chainIndex,IERC20 targetContract) public {\r\n        currentChainIndex = chainIndex;\r\n        AntasyContract = targetContract;\r\n        emit Init(_msgSender(),currentChainIndex);\r\n    }\r\n    \r\n   function changeSwitchContractAddress(address contractAddress) onlyOwner public {\r\n        emit ChangeSwitchContract(switchContract,contractAddress);\r\n        switchContract = contractAddress;\r\n    }\r\n    \r\n    function changeBeneficiaryAddress(address payable beneficiayAddress) onlyOwner public {\r\n         emit ChangeBeneficiary(beneficiary,beneficiayAddress);\r\n         beneficiary = beneficiayAddress;\r\n    }\r\n    \r\n    function withdraw(address payable target) onlyOwner public returns(bool){\r\n        uint256 balance = AntasyContract.balanceOf(address(this));\r\n        bool result = AntasyContract.transfer(target,balance);\r\n        return result;\r\n    }\r\n    \r\n    \r\n    function switchTo(uint targetChain,uint256 switchAmount,address targetAddress) public returns(bool){\r\n        uint256 allowance = AntasyContract.allowance(_msgSender(),address(this));\r\n        require(allowance >= switchAmount,\"Switch:allowance is not enough\");\r\n        \r\n        bool result =  AntasyContract.transferFrom(_msgSender(),address(this),switchAmount);\r\n        if(result){\r\n            emit SwitchRecord(_msgSender(),targetChain,switchAmount,targetAddress);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n     function destroy(address payable addr) public onlyOwner {\r\n        selfdestruct(addr);\r\n    }\r\n    \r\n    \r\n    \r\n}"
    }
  }
}