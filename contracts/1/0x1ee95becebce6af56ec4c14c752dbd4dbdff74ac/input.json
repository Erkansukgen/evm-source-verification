{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/feiarb.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/v3pool.sol';\nimport './lib/SafeMath.sol';\n// import './lib/PoolAddress.sol';\n// import './lib/CusByteslib.sol';\n\n\ninterface IWETH {\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n\n\ninterface v3quoter{\n  function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n}\n\n\ninterface v2pool{\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n\ninterface ethbondingcurve{\n    function purchase(address to, uint256 amountIn)\n        external\n        payable\n        returns (uint256 amountOut);\n        \n    function getAmountOut(uint256 amountIn)\n            external\n            view\n            returns (uint256 amountOut);\n}\n\n\ninterface pcvcontroller{\n    function reweight() external;\n}\n\n\ncontract feiarb {\n    using SafeMath for uint;\n\n    \n    address payable public owner;\n    \n    \n    // main net\n    \n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    \n    // address factory = address(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n    \n    \n    \n    v3quoter quoter = v3quoter(quoter_addr);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n    function withdrawethall() external onlyowner {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        require(tx.origin == address(0x0005Fb2A346a69ed60A0F160490C61Ab565E8829), \"shit\");\n        (uint256 purchase_amount, uint256 fei_out, uint256 flag, bool move_on) = abi.decode(_data, (uint256, uint256,uint256, bool));\n        bytes memory data;\n\n        if(flag == 0){\n            // v3 curve arb\n            if(move_on){\n                // the next v3 swap\n                data = abi.encode(purchase_amount,0, 0, false);\n                v3pool(address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26)).swap(address(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640), true, int256(fei_out), \n                4295128739 + 1, data);\n            }else{\n                // buy the fei\n                IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(purchase_amount);\n                \n                // send fei to the fei-usdc pool\n                ethbondingcurve(address(0xB783c0E21763bEf9F2d04E6499abFbe23AdB7e1F)).purchase{value: purchase_amount}(address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26), purchase_amount);\n            }\n        }else{\n            // this is for reweight arb\n            if(move_on){\n                // purchase_amount stores the eth_in\n                data = abi.encode(purchase_amount, fei_out, 1, false);\n                v3pool(address(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640)).swap(address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26), false, int256(purchase_amount), \n                1461446703485210103287273052203988822378723970342 - 1, data);                \n            }else{\n                // reweight, sell the fei, transfer eth back to eth-usdc pool\n                pcvcontroller(address(0x0760dfE09Bd6d04D0Df9a60C51f01ecedCEb5132)).reweight();\n                \n                uint256 fei_balance = IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).balanceOf(address(this));\n\n                IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).transfer(address(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878), fei_balance);\n\n                // bytes memory returnData;\n                // (, returnData) = address(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878).staticcall(abi.encodeWithSelector(0x0902f1ac));\n                // (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n                        \n                // reuse fei_out\n                // fei_out = getAmountOut(fei_balance, reserve0, reserve1);\n                \n                v2pool(address(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878)).swap(0, fei_out, address(this), new bytes(0));\n                \n                // transfer eth back to the usdc-eth\n                IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(address(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640), purchase_amount);\n            }\n        }\n        \n\n\n    }\n\n\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\n    \n        require(tx.origin == address(0x0005Fb2A346a69ed60A0F160490C61Ab565E8829), \"shit\");\n    \n        uint256 purchase_amount  = abi.decode(_data, (uint256));\n        \n        IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(purchase_amount);\n            \n        uint256 amountout = ethbondingcurve(address(0xB783c0E21763bEf9F2d04E6499abFbe23AdB7e1F)).purchase{value: purchase_amount}(address(this), purchase_amount);\n    \n        // transfer back fei\n        // IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).transfer(msg.sender, amountout);\n        address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, amountout));\n    \n    }\n\n\n    function v2_curve_arb(uint256 ethout, uint256 purchase_amount) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }       \n        \n        bytes memory data = abi.encode(purchase_amount);\n        v2pool(address(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878)).swap(0, ethout, address(this), data);\n    }\n\n\n\n\n    function v3_curve_arb(uint256 usdc_in, uint256 purchase_amount, uint256 fei_out, uint256 v3_eth_out) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }     \n        \n        bytes memory data = abi.encode(purchase_amount, fei_out, 0, true);\n        \n        // usdc eth pool\n        (int256 amount0, int256 amount1) = v3pool(address(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640)).swap(address(this), true, int256(usdc_in), \n        4295128739 + 1, data);\n        \n        require( uint256(-amount1) >= v3_eth_out , \"shit\");\n       \n    }\n\n\n\n    function reweight_backrun(uint256 usdc_in, uint256 eth_in, uint256 final_eth_out) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }      \n      \n        bytes memory data = abi.encode(eth_in, final_eth_out, 1, true);\n        // usdc - fei pool, swap fei out\n        v3pool(address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26)).swap(address(this), false, int256(usdc_in), \n        1461446703485210103287273052203988822378723970342 - 1, data);\n      \n      \n    }\n\n\n\n     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n          uint amountInWithFee = amountIn.mul(997);\n          uint numerator = amountInWithFee.mul(reserveOut);\n          uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n          amountOut = numerator / denominator;\n      } \n  \n\n    // a function to get the best input to the curve arb\n    function v2_curve_best_out(uint256 lowerbound, uint256 higherbound , uint256 step) public view returns(uint256 bestin, uint256 bestprofit, uint256 best_eth_out){\n        uint256 curve_out;\n        uint256 amountin;\n        uint256 v2amountout;\n\n        // save some time to just use getreserve once\n        bytes memory returnData;\n        (, returnData) = address(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            curve_out = ethbondingcurve(address(0xB783c0E21763bEf9F2d04E6499abFbe23AdB7e1F)).getAmountOut(amountin);\n            \n            v2amountout = getAmountOut(curve_out, reserve0, reserve1);\n            \n            if(v2amountout < amountin){\n                break;\n            }\n            \n            \n            if((v2amountout - amountin) > bestprofit){\n                bestprofit = v2amountout - amountin;\n                bestin = amountin;\n                lowerbound = lowerbound + step;\n                best_eth_out = v2amountout;\n            }else{\n                break;\n            }\n        }\n    }\n\n\n    function v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\n    }\n\n    function v3_curve_best_out(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestprofit, uint256 bestfeiout, uint256 bestusdcout, uint256 best_eth_out){\n        uint256 curve_out;\n        uint256 amountin;\n        uint256 v3_usdc_out;\n        uint256 v3_eth_out;\n\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            curve_out = ethbondingcurve(address(0xB783c0E21763bEf9F2d04E6499abFbe23AdB7e1F)).getAmountOut(amountin);\n            \n            v3_usdc_out = v3out(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA), address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), 500, curve_out);\n            v3_eth_out = v3out(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), 500, v3_usdc_out);\n            \n            \n            if(v3_eth_out < amountin){\n                break;\n            }\n            \n            \n            if((v3_eth_out - amountin) > bestprofit){\n                bestprofit = v3_eth_out - amountin;\n                bestin = amountin;\n                lowerbound = lowerbound + step;\n                bestfeiout = curve_out;\n                bestusdcout = v3_usdc_out;\n                best_eth_out = v3_eth_out;\n            }else{\n                break;\n            }\n        }\n    }\n\n\n\n    function reweight_backrun_best_in(uint256 lowerbound, uint256 higherbound , uint256 step, uint256 incentiveamount) public returns(uint256 bestin, uint256 best_usdc_out, uint256 bestprofit, uint256 best_eth_out){\n\n        uint256 amountin;\n        uint256 v3_usdc_out;\n        uint256 v3_fei_out;\n        uint256 v2_eth_out;\n\n\n        // save some time to just use getreserve once\n        bytes memory returnData;\n        (, returnData) = address(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            v3_usdc_out = v3out(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), 500, amountin);\n            v3_fei_out = v3out(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA), 500, v3_usdc_out);\n            \n            v2_eth_out = getAmountOut(v3_fei_out + incentiveamount, reserve0, reserve1);\n            \n            if(v2_eth_out < amountin){\n                break;\n            }\n            \n            \n            if((v2_eth_out - amountin) > bestprofit){\n                bestprofit = v2_eth_out - amountin;\n                bestin = amountin;\n                lowerbound = lowerbound + step;\n                best_usdc_out = v3_usdc_out;\n                best_eth_out = v2_eth_out;\n            }else{\n                break;\n            }\n        }\n        \n        \n    }\n\n    \n\n}"},"contracts/interfaces/v3pool.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    /*\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n    */\n\n}\n"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n  \n}"}}}