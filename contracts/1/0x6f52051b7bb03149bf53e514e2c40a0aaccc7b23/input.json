{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts-v3/BundleExecutorV3.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint) external;\n}\n\ninterface IUniswapV2Router {\n     function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\ninterface ICurveRegistry{\n    function get_coin_indices(address _pool,address _from,address _to) external  view returns (int128 ,int128 ,bool);\n}\ninterface CurvePool{\n    function exchange(int128 i,int128 j, uint256 dx, uint256 min_dy) external payable;\n}\n\nstruct ExactInputParams {\n    bytes path;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n}\ninterface IUniswapV3Router  {\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n}\n\ncontract BundleExecutor {\n    address payable private immutable owner;\n    address private immutable executor;\n    //main:              0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    //test from goerli : 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6\n    IWETH private WETH;\n    \n    ICurveRegistry private curveRegistry;\n\n    modifier onlyExecutor() {\n        require(msg.sender == executor);\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor(address _executor,address _wethAddress) public payable {\n        owner = msg.sender;\n        executor = _executor;\n        WETH = IWETH(_wethAddress);\n        curveRegistry = ICurveRegistry(0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5);\n        if (msg.value > 0) {\n            WETH.deposit{value: msg.value}();\n        }\n    }\n\n    receive() external payable {\n    }\n\n    function withdraw(uint256 _amount)external onlyOwner  payable{\n        owner.transfer(_amount);\n    }\n    function withdrawToken(uint256 _amount,address payable _tokenAddress)external onlyOwner payable{\n        IERC20(_tokenAddress).transfer(owner,_amount);\n    }\n\n\n    event SwapOrder(string  _orderSource, uint256 _amountIn,uint256 _netPnl,uint256 _amountPayToFlashbots);\n\n    struct SwapParams {\n        string  _orderSource;               // order key info from dex_gateway\n        uint256 _amountIn;                  //swap amount in \n        uint256 _minPnl;                    //min pnl for this arb\n        uint256 _ratioPayToFlashbots;       // the ratio of trade pnl ,and pay to flashbots\n        uint256 _payToFlashbots;            //fixed value to pay to flashbots\n        uint256 _ethPrice;                  //ether price for _payToFlashbots\n        int8[]  _exchange_versions;         //1: curve,2:uniswapV2,3:IUniswapV3\n        address[]  _first_token_address;    //the address for the first token for this exchange,use for approve  \n        address[]  _exchange_routers;       //router contract address\n        address[][]  _pathsForRouters;      //paths for v2 or curve \n        bytes[]  _v3Path;                    //path for v3\n    }\n    \n    //supper any X token swap to Y token, \n    //supper require _minPnl  [minPnl can b 0 ]\n    //supper _payToFlashbots or ratioPayToFlashbots [can be 0 ]\n    function swaps(SwapParams calldata params) external onlyExecutor payable {\n        require(params._minPnl > 0);\n        require(params._ratioPayToFlashbots < 100);\n        uint256 _balanceBefore = IERC20(params._first_token_address[0]).balanceOf(address(this));\n        uint256 _amountIn = params._amountIn;\n\n        for (uint256 i = 0; i < params._exchange_routers.length; i++) {\n            if(IERC20(params._first_token_address[i]).allowance(address(this),params._exchange_routers[i])==0){\n                IERC20(params._first_token_address[i]).approve(params._exchange_routers[i],10000000000000000000000000000);\n            }\n            if(params._exchange_versions[i]==1){\n                 (int128 x, int128 y,  bool is_underlying) = curveRegistry.get_coin_indices(params._exchange_routers[i], params._pathsForRouters[i][0], params._pathsForRouters[i][1]); \n                 if(!is_underlying){\n                     CurvePool(params._exchange_routers[i]).exchange(x, y, _amountIn, 0);\n                 }\n                _amountIn = IERC20(params._pathsForRouters[i][1]).balanceOf(address(this));\n            }else if(params._exchange_versions[i]==2){\n                uint[] memory _swap_amounts= IUniswapV2Router(params._exchange_routers[i]).swapExactTokensForTokens(_amountIn,0,params._pathsForRouters[i],address(this),block.timestamp);\n                _amountIn = _swap_amounts[_swap_amounts.length -1];\n            }else if(params._exchange_versions[i]==3){\n                _amountIn = IUniswapV3Router(params._exchange_routers[i]).exactInput(ExactInputParams({\n                    path: params._v3Path[i],\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: _amountIn,\n                    amountOutMinimum: 0\n                }\n                ));\n            }\n\n        }\n        uint256 _balanceAfter = IERC20(params._first_token_address[0]).balanceOf(address(this));\n        require(_balanceAfter > _balanceBefore + params._minPnl);\n\n\n        if (params._ratioPayToFlashbots == 0 &&params._payToFlashbots ==0){\n            emit SwapOrder(params._orderSource, params._amountIn,_balanceAfter - _balanceBefore,0);\n            return;\n        }\n        uint256 _payToFlashbots =params._payToFlashbots;\n        if(_payToFlashbots == 0){\n            _payToFlashbots = (_balanceAfter - _balanceBefore - params._minPnl) * params._ratioPayToFlashbots/100;\n        }\n        uint256 _ethBalance = address(this).balance;\n        if (_ethBalance < _payToFlashbots) {\n            WETH.withdraw(_payToFlashbots - _ethBalance);\n        }\n        block.coinbase.transfer(_payToFlashbots);\n        \n        if(_payToFlashbots > 0){\n            _payToFlashbots = _payToFlashbots*params._ethPrice;\n        }\n\n        uint256 _netPnl = _balanceAfter - _balanceBefore - _payToFlashbots;\n        emit SwapOrder(params._orderSource, _amountIn, _netPnl, _payToFlashbots);\n       \n    }\n\n   \n\n    function call(address payable _to, uint256 _value, bytes calldata _data) external onlyOwner payable returns (bytes memory) {\n        require(_to != address(0));\n        (bool _success, bytes memory _result) = _to.call{value: _value}(_data);\n        require(_success);\n        return _result;\n    }\n    \n    function destroy()  external onlyOwner payable {\n     selfdestruct(owner);\n    } \n\n}\n"}}}