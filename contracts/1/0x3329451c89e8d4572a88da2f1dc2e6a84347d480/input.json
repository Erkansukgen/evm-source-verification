{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/core.sol":{"content":"pragma solidity >=0.6.0 <0.7.0;\nimport \"./safeMath.sol\";\ncontract Core {\n    using SafeMath for uint256;\n    USDT usdt;\n    Db db;\n    Token token;\n    Tool tool;\n    address[] public developer;\n    uint minInvestValue = 100e6;\n    uint minInvestParticle = 1e6;\n    uint lastMinBalance = 100e6;\n    address own = msg.sender;\n    mapping(address => uint) surplusTokenNum;\n    modifier isOwn(){\n        require(msg.sender == own);\n        _;\n    }\n    function init(address usdtAddress,address dbAddress,address tokenAddress,address toolAddress) public isOwn {\n        usdt = USDT(usdtAddress);\n        db = Db(dbAddress);\n        token = Token(tokenAddress);\n        tool = Tool(toolAddress);\n    }\n    function setDevAddress(address _devAddress) public isOwn{\n        for(uint i = 0;i < developer.length;i++){\n            if(developer[i] == _devAddress){\n                developer[i] = developer[(developer.length-1)];\n                developer.pop();\n                return;\n            }\n        }\n        developer.push(_devAddress);\n    }\n    function _setDevReward(uint _balance) internal {\n        uint _ratio = developer.length;\n        uint _giveBalance = _balance.div(_ratio);\n        for (uint i = 0; i < _ratio; i++) {\n            if(developer[i] == address(0x00)){\n                continue;\n            }\n            _sendUsdtToAddress(developer[i],_giveBalance);\n        }\n    }\n    function _sendUsdtToAddress(address _own,uint _balance) internal{\n        require(usdt.balanceOf(address(this)) > _balance);\n        usdt.transfer(_own,_balance);\n    }\n    function getAllowBalance(address _own) public view returns (uint){\n        return  usdt.allowance(_own,address(this));\n    }\n    function _fromUsdtToAddress(uint _balance) internal{\n        address _own = msg.sender;\n        uint _allowBalance =  getAllowBalance(_own);\n        require(_allowBalance >= _balance,\"allow balance < balance\");\n        usdt.transferFrom(_own,address(this),_balance);\n    }\n    function bindParentAndBuyTicket(address _parent,uint _balance) public {\n        address _own = msg.sender;\n        (,,bool _isParent) = db.getPlayerInfo(_own);\n        if(false == _isParent){\n            if(db.systemPlayerNum() == 0){\n                _parent = address(0x0);\n            }else{\n                (,bool _parentIsExits,) = db.getPlayerInfo(_parent);\n                require(_parentIsExits == true,\"parent not exist\");\n            }\n            db.setPlayerParentAddress(_own,_parent);\n        }\n        _fromUsdtToAddress(_balance.mul(1e6));\n        uint _price = token.price();\n        uint _tokenNum = _balance.mul(_price);\n        token.sendTokenToAddress(_own,_tokenNum);\n    }\n    function _useTicket(uint _value) internal returns (bool) {\n        address _own = address(this);\n        return token.sendTokenToGame(_own, _value);\n    }\n    function getNow() public view returns(uint){\n        return now;\n    }\n    function _setLastTime(uint _balance) internal {\n        uint _ratio = _balance / lastMinBalance;\n        uint _t = 2 * 3600;\n        uint _maxTime = 36 * 3600;\n        uint _lastTime = db.lastTime();\n        if(_lastTime < getNow()){\n            _lastTime = getNow();\n        }\n        uint _nowLastTime = _lastTime;\n        uint _newLastTime = _nowLastTime.add(_t.mul(_ratio));\n        if (_newLastTime > _maxTime.add(getNow())) {\n            _newLastTime = _maxTime.add(getNow());\n        }\n        db.setLastTime(_newLastTime);\n    }\n    receive() payable external {\n        withdraw();\n    }\n    function openLastReward() public{\n        if(db.lastTime() >= now){\n            return;\n        }\n        db.openLastPoolReward();\n    }\n    function openReward() public{\n        db.openReward();\n    }\n    function _setforceLuckCode(address _own,uint _balance) internal{\n        if(_balance <= 0){\n            return;\n        }\n        uint _tokenPrice = token.getTokenPrice();\n        uint _scale = _tokenPrice;\n        uint _tokenNum = _balance.mul(_tokenPrice).div(1e6);\n        _balance = _balance.div(1e6);\n        uint _lastTokenNum = surplusTokenNum[_own];\n        uint _allTokenNum = _tokenNum.add(_lastTokenNum);\n        uint _surplusNum = _allTokenNum.mod(_scale);\n        surplusTokenNum[_own] = _surplusNum;\n        uint _codeNum = _allTokenNum.sub(_surplusNum).div(_scale);\n        db.addCodeToPlayer(_own,_codeNum);\n    }\n    function getParent(address _own) view public returns (address,bool,bool){\n        (address _parent,bool _isExist, bool _isParent) = db.getPlayerInfo(_own);\n        return (_parent,_isExist,_isParent);\n    }\n    function getAddressInfo(address _own) public view returns(uint _teamCount,uint _sonCount,uint _investBalance,uint _lev, uint _incomeBalance,uint _withdrawBalance){\n        return db.getAddressSomeInfo(_own);\n    }\n    function getAreaPerformance(address _own) public view returns(uint _maxPerformance, uint _minPerformance){\n        return db.getAreaPerformance(_own);\n    }\n    function getLastTime() public view returns(uint){\n        return db.lastTime();\n    }\n    function getLastPool() public view returns(uint){\n        return db.lastPool();\n    }\n    function getEstimateReward(address _own) public view returns(uint,uint){\n        return db.getEstimateReward(_own);\n    }\n    function getIncomeList(address _own) public view  returns (uint[50] memory , uint[50] memory , uint[50] memory, address[50] memory ){\n        return db.getIncomeList(_own);\n    }\n    function getMyReward(address _own) public view returns (uint[9] memory){\n        return db.getMyReward(_own);\n    }\n    function getLuckNum() public view returns(uint){\n        return db.luckCodeNum();\n    }\n    function getLuckCodePool() public view returns(uint,uint,uint,uint){\n        uint _luckNum = getLuckNum();\n        return (\n            db.luckPool(_luckNum,1,0),\n            db.luckPool(_luckNum,1,1),\n            db.luckPool(_luckNum,1,2),\n            db.luckPool(_luckNum,1,3)\n        );\n    }\n    function getIncomePool() public view returns(uint,uint,uint,uint){\n        uint _luckNum = getLuckNum();\n        return (\n            db.luckPool(_luckNum,0,0),\n            db.luckPool(_luckNum,0,1),\n            db.luckPool(_luckNum,0,2),\n            db.luckPool(_luckNum,0,3)\n        );\n    }\n    function playLuckCode(uint _num) public{\n        address _own = msg.sender;\n        uint _tokenPrice = token.price();\n        uint _needTokenNum = _tokenPrice.mul(_num).mul(1e18);\n        uint _ownBalance = token.getToken(_own);\n        require(_ownBalance >= _needTokenNum,\"token < need\");\n        token.sendTokenToGame(_own,_needTokenNum);\n        db.addCodeToPlayer(_own,_num);\n    }\n    function getPlayerLuckCode(address _own) public view returns(uint[100] memory){\n        return db.getLuckCode(_own);\n    } \n    function getLastOpenLuckCodeList() public view returns(uint[] memory){\n        return db.getLastOpenLuckCodeList();\n    }\n    function getLastInvestAddress() public view returns(address[50] memory ,uint[50] memory ){\n        uint _length = db.getSystemInvestLength();\n        uint j = 0;\n        address[50] memory _address;\n        uint[50] memory _balance;\n        for(uint i = _length; i> 0;i--){\n            if(j >= 50){\n                break;\n            }\n            (address _tempAddress,uint _tempBalance) = db.getSystemInvestInfo(i.sub(1));\n            _address[j] = _tempAddress;\n            _balance[j] = _tempBalance;\n            j++;\n        }\n        return (_address,_balance);\n    }\n    function getInvestList(bool _flag) public view returns(address[21] memory){\n        return db.getInvestList(_flag);\n    }\n    \n    function getSystemLevNum(uint _num) public view returns (uint){\n        return db.systemLevNum(_num);\n    }\n    function invest(uint _balance) public {\n        _balance = _balance.mul(1e6);\n        require(_balance >= minInvestValue, \"insufficient investment amount\");\n        require(_balance.mod(minInvestParticle) == 0, \"wrong investment amount\");\n        _fromUsdtToAddress(_balance);\n        address _selfAddress = msg.sender;\n        (,,bool _isParent) = db.getPlayerInfo(_selfAddress);\n        require(_isParent == true, \"parent does not exist\");\n        uint _myTicketNum = token.getToken(_selfAddress);\n        uint _needTicketNum = tool._getNeedTicketNum(_balance);\n        _needTicketNum = _needTicketNum.mul(1e18);\n        require(_myTicketNum >= _needTicketNum, \"Insufficient tickets\");\n        _useTicket(_needTicketNum);\n        db.addInvestBurnNum(_balance.div(10));\n        db.addInvest(_selfAddress,_balance);\n        db.setAssignment(_balance);\n        db.giveShare(_selfAddress, _balance);\n        db.setParentLev(_selfAddress);\n        db.setTeamLevReward(_selfAddress, _balance);\n        _setDevReward(_balance.mul(3).div(100));\n        db.setTopLevReward(_balance.mul(3).div(100));\n        _setLastTime(_balance);\n    }\n    function withdraw() public{\n        openLastReward();\n        openReward();\n        address payable _own = tx.origin;\n        db.setAllStaticReward(_own);\n        uint _giveAmount = db.getFreeWithdrawBalance(_own);\n        uint _tokenGiveAmount = _giveAmount.mul(5).div(100);\n        uint _newGiveAmount = _giveAmount.sub(_tokenGiveAmount);\n        _setforceLuckCode(_own,_tokenGiveAmount);\n        db.setPlayerWithdraw(_own);\n        _sendUsdtToAddress(_own,_newGiveAmount);\n    }\n}\nabstract contract USDT {\n    function transfer(address to, uint value) public virtual;\n    function allowance(address owner, address spender) public view virtual returns (uint);\n    function transferFrom(address from, address to, uint value) public virtual;\n    function approve(address spender, uint value) public virtual;\n    function balanceOf(address spender) public virtual view returns (uint);\n}\nabstract contract Token {\n    function getToken(address _own) public virtual returns (uint);\n    function sendTokenToGame(address _to, uint _value) public virtual returns (bool);\n    function sendTokenToAddress(address _own,uint _balance) public virtual;\n    function getTokenPrice() public virtual view returns (uint);\n    function price() public view virtual returns (uint);\n}\nabstract contract Db {\n    function setPlayerParentAddress(address _own,address _parent) public virtual;\n    function systemPlayerNum() public virtual returns (uint);\n    function getPlayerInfo(address _own) public view virtual returns(address _parent,bool _isExist,bool _isParent);\n    function addInvest(address _own,uint _balance) public virtual;\n    function setAssignment(uint _balance) public virtual;\n    function giveShare(address _own, uint _balance) public virtual;\n    function setParentLev(address _own) public virtual;\n    function setTeamLevReward(address _own, uint _balance) public virtual;\n    function setTopLevReward(uint _balance) public virtual;\n    function lastTime() public view virtual returns (uint);\n    function lastPool() public view virtual returns (uint);\n    function setLastTime(uint _lastTime) public virtual;\n    function setAllStaticReward(address _own) public virtual;\n    function getFreeWithdrawBalance(address _own) public virtual returns (uint);\n    function addCodeToPlayer(address _own,uint _count) public virtual;\n    function setPlayerWithdraw(address _own) public virtual;\n    function getAreaPerformance(address _own) public view virtual returns (uint _maxPerformance, uint _minPerformance);\n    function getAddressSomeInfo(address _own) public view virtual returns(uint _teamCount,uint _sonCount,uint _investBalance,uint _lev,uint _incomeBalance,uint _withdrawBalance);\n    function luckPool(uint _num,uint _type,uint _index) public view virtual returns (uint _balance);\n    function getEstimateReward(address _own) public view virtual returns(uint,uint);\n    function getMyReward(address _own) public view virtual  returns (uint[9] memory);\n    function getIncomeList(address _own) public view virtual returns (uint[50] memory , uint[50] memory , uint[50] memory, address[50] memory);\n    function luckCodeNum() public view virtual returns (uint);\n    function getSystemInvestLength() public view virtual returns (uint);\n    function getSystemInvestInfo(uint _index) public view virtual returns (address,uint);\n    function getLastOpenLuckCodeList() public view virtual returns(uint[] memory);\n    function getLuckCode(address _own) public view virtual returns(uint[100] memory);\n    function getInvestList(bool _flag) public view virtual returns (address[21] memory);\n    function openLastPoolReward() public virtual;\n    function openReward() public virtual;\n    function systemLevNum(uint _lev) public view virtual returns(uint);\n    function addInvestBurnNum(uint _num) public virtual;\n}\nabstract contract Tool {\n    function _getNeedTicketNum(uint _balance) view public virtual returns (uint);\n    function _getRatio(uint _balance) pure public virtual returns (uint);\n    function _createRandomNum(uint _min, uint _max, uint _randNonce) public virtual view returns (uint);\n    function _crateLuckCodeList(uint _max) public view virtual returns (uint[25] memory);\n}\n\n"},"browser/safeMath.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\r\n\r\nlibrary SafeMath {\r\n    //加\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    //减\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    //乘\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    //除\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    //取余\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}}