{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DsrManager.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-05-18\n*/\n\n// DsrManager.sol\n// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.12;\n\ncontract VatLike {\n    function hope(address) external;\n}\n\ncontract PotLike {\n    function vat() external view returns (address);\n    function chi() external view returns (uint256);\n    function rho() external view returns (uint256);\n    function drip() external returns (uint256);\n    function join(uint256) external;\n    function exit(uint256) external;\n}\n\ncontract JoinLike {\n    function dai() external view returns (address);\n    function join(address, uint256) external;\n    function exit(address, uint256) external;\n}\n\ncontract GemLike {\n    function transferFrom(address,address,uint256) external returns (bool);\n    function approve(address,uint256) external returns (bool);\n}\n\ncontract DsrManager {\n    PotLike  public pot;\n    GemLike  public dai;\n    JoinLike public daiJoin;\n\n    uint256 public supply;\n\n    mapping (address => uint256) public pieOf;\n\n    event Join(address indexed dst, uint256 wad);\n    event Exit(address indexed dst, uint256 wad);\n\n    uint256 constant RAY = 10 ** 27;\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        // always rounds down\n        z = mul(x, y) / RAY;\n    }\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        // always rounds down\n        z = mul(x, RAY) / y;\n    }\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        // always rounds up\n        z = add(mul(x, RAY), sub(y, 1)) / y;\n    }\n\n    constructor(address pot_, address daiJoin_) public {\n        pot = PotLike(pot_);\n        daiJoin = JoinLike(daiJoin_);\n        dai = GemLike(daiJoin.dai());\n\n        VatLike vat = VatLike(pot.vat());\n        vat.hope(address(daiJoin));\n        vat.hope(address(pot));\n        dai.approve(address(daiJoin), uint256(-1));\n    }\n\n    function daiBalance(address usr) external returns (uint256 wad) {\n        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();\n        wad = rmul(chi, pieOf[usr]);\n    }\n\n    // wad is denominated in dai\n    function join(address dst, uint256 wad) external {\n        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();\n        uint256 pie = rdiv(wad, chi);\n        pieOf[dst] = add(pieOf[dst], pie);\n        supply = add(supply, pie);\n\n        dai.transferFrom(msg.sender, address(this), wad);\n        daiJoin.join(address(this), wad);\n        pot.join(pie);\n        emit Join(dst, wad);\n    }\n\n    // wad is denominated in dai\n    function exit(address dst, uint256 wad) external {\n        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();\n        uint256 pie = rdivup(wad, chi);\n\n        require(pieOf[msg.sender] >= pie, \"insufficient-balance\");\n\n        pieOf[msg.sender] = sub(pieOf[msg.sender], pie);\n        supply = sub(supply, pie);\n\n        pot.exit(pie);\n        uint256 amt = rmul(chi, pie);\n        daiJoin.exit(dst, amt);\n        emit Exit(dst, amt);\n    }\n\n    function exitAll(address dst) external {\n        uint256 chi = (now > pot.rho()) ? pot.drip() : pot.chi();\n        uint256 pie = pieOf[msg.sender];\n\n        pieOf[msg.sender] = 0;\n        supply = sub(supply, pie);\n\n        pot.exit(pie);\n        uint256 amt = rmul(chi, pie);\n        daiJoin.exit(dst, amt);\n        emit Exit(dst, amt);\n    }\n}\n"
    }
  }
}