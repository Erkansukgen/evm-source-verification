{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Stats.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface CTokenInterface {\n    function exchangeRateStored() external view returns (uint);\n    function borrowBalanceStored(address) external view returns (uint);\n\n    function balanceOf(address) external view returns (uint);\n}\n\ncontract Helpers {\n\n    struct CompData {\n        uint balanceOfUser;\n        uint borrowBalanceStoredUser;\n    }\n    struct data {\n        address user;\n        CompData[] tokensData;\n    }\n}\n\n\ncontract Resolver is Helpers {\n\n    function getCompoundData(address owner, address[] memory cAddress) public view returns (CompData[] memory) {\n        CompData[] memory tokensData = new CompData[](cAddress.length);\n        for (uint i = 0; i < cAddress.length; i++) {\n            CTokenInterface cToken = CTokenInterface(cAddress[i]);\n            tokensData[i] = CompData(\n                cToken.balanceOf(owner),\n                cToken.borrowBalanceStored(owner)\n            );\n        }\n\n        return tokensData;\n    }\n\n    function getPosition(\n        address[] memory owners,\n        address[] memory cAddress\n    )\n        public\n        view\n        returns (data[] memory)\n    {\n        data[] memory datas = new data[](owners.length);\n        for (uint i = 0; i < cAddress.length; i++) {\n            datas[i] = data(\n                owners[i],\n                getCompoundData(owners[i], cAddress)\n            );\n        }\n        return datas;\n    }\n\n}\n"}}}