{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/test.sol":{"content":"pragma solidity ^0.7.5;\n\ninterface erc20 {\n    function balanceOf(address _owner) external view returns (uint balance);\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n    function decimals() external view returns(uint digits);    \n}\n\ninterface erc20Validation {\n    function balanceOf(address _address, address _tokenAddress) external view returns (uint balance);    \n}\n\ninterface PaymentContract {\n  function Payment (  ) payable external;  \n}\n\ncontract TestBZS\n{\t\n\nerc20 public _erc20;\n\naddress public _owner;\n\nPaymentContract public paymentContract;\n\nuint public fee;\nuint public feeDecimals;\n\nmodifier onlyOwner(){\n    require(msg.sender == _owner);\n     _;\n}\n\t\nconstructor() {\n\t_owner = msg.sender;\n\tpaymentContract = PaymentContract(0x426CA1eA2406c07d75Db9585F22781c096e3d0E0);\n\tfeeDecimals = 1000000;\n}\n\nevent AddTokenEvent(address indexed _tokenAddress);\nevent SetForSaleEvent(address indexed _seller, address indexed _tokenAddress, uint _balance, uint _weiPriceUnitToken, bool update);\nevent RemovedFromSaleEvent(address indexed _seller, address indexed _tokenAddress);\nevent SoldEvent(address indexed _seller, address indexed _buyer, address indexed _tokenAddress, uint256 _balance, uint _weiPriceUnitToken, uint _totalPrice, uint _fee);\n\nmapping (address => address) public SecondaryValidation;\nmapping (address => mapping (address => uint)) public weiPriceUnitTokenList;\n\nfunction SetForSale(address tokenAddress, uint weiPriceUnitToken) public\n{\t\n\tif (weiPriceUnitToken == 0) revert('price cannot be zero');\n\t\t\n\terc20 token = erc20(tokenAddress);\n\tuint balance = token.balanceOf(msg.sender);\n\t\n\tif (SecondaryValidation[tokenAddress] != 0x0000000000000000000000000000000000000000)\n\t{\n\t\terc20Validation vc = erc20Validation(SecondaryValidation[tokenAddress]);\n\t\tbalance = vc.balanceOf(msg.sender, tokenAddress);\n\t}\n\t\n\tif (balance == 0) revert('balance cannot be zero');\n\tif (token.allowance(msg.sender, address(this)) < balance) revert('Approve not granted');\n\t\n\tif (weiPriceUnitTokenList[msg.sender][tokenAddress] == 0)\n\t{\n\t\temit AddTokenEvent(tokenAddress);\n\t\temit SetForSaleEvent(msg.sender, tokenAddress, balance, weiPriceUnitToken, false);\n\t}\n\telse\n\t{\n\t\temit SetForSaleEvent(msg.sender, tokenAddress, balance, weiPriceUnitToken, true);\n\t}\n\t\n\tweiPriceUnitTokenList[msg.sender][tokenAddress] = weiPriceUnitToken;\n}\n\nfunction Buy(address seller, address tokenAddress) public payable\n{\t\n\tif (seller == msg.sender) revert('buyer and seller cannot be the same');\n\t\n\terc20 token = erc20(tokenAddress);\n\tuint allowance = getAvailableBalanceForSale(seller, tokenAddress);\n\t\n\tuint sellerPrice = weiPriceUnitTokenList[seller][tokenAddress] * allowance / token.decimals();\n\tuint buyFee = fee * sellerPrice / feeDecimals;\n\t\n\tif ((msg.value != sellerPrice + buyFee) || msg.value == 0) revert('Price sent not correct');\n\t\n\ttoken.transferFrom(seller, msg.sender, allowance);\n\t\n\tif(!payable(seller).send(sellerPrice)) revert('Error while sending payment to seller');\t\n\tif (fee > 0) { paymentContract.Payment{value:buyFee}(); }\t\n\t\n\temit SoldEvent(seller, msg.sender, tokenAddress, allowance, weiPriceUnitTokenList[seller][tokenAddress], (sellerPrice + buyFee), buyFee);\n\t\n\tweiPriceUnitTokenList[seller][tokenAddress] = 0;\n}\n\nfunction RemoveFromSale(address tokenAddress, bool checkAllowance) public\n{\n\tif (getTokenAllowance(msg.sender, tokenAddress) > 0 && checkAllowance) revert('Approve Needs to be Removed First');\n\tweiPriceUnitTokenList[msg.sender][tokenAddress] = 0;\n\temit RemovedFromSaleEvent(msg.sender, tokenAddress);\n}\n\nfunction getWeiPriceUnitTokenList(address seller, address tokenAddress) public view returns(uint) \n{\n\treturn weiPriceUnitTokenList[seller][tokenAddress];\n}\n\nfunction getFinalPrice(address seller, address tokenAddress) public view returns(uint) \n{\n\terc20 token = erc20(tokenAddress);\n\tuint allowance = getAvailableBalanceForSale(seller, tokenAddress);\n\tuint sellerPrice = weiPriceUnitTokenList[seller][tokenAddress] * allowance / token.decimals();\n\tuint buyFee = fee * sellerPrice / feeDecimals;\n\treturn sellerPrice + buyFee;\n}\n\nfunction getFinalPriceWithoutFee(address seller, address tokenAddress) public view returns(uint) \n{\n\terc20 token = erc20(tokenAddress);\n\tuint allowance = getAvailableBalanceForSale(seller, tokenAddress);\n\tuint sellerPrice = weiPriceUnitTokenList[seller][tokenAddress] * allowance / token.decimals();\n\treturn sellerPrice;\n}\n\nfunction getTokenAllowance(address seller, address tokenAddress) public view returns(uint)\n{\n\terc20 token = erc20(tokenAddress);\n\treturn token.allowance(seller, address(this));\n}\n\nfunction getAvailableBalanceForSale(address seller, address tokenAddress) public view returns(uint)\n{\n\tuint allowance = erc20(tokenAddress).allowance(seller, address(this));\n\tif (SecondaryValidation[tokenAddress] == 0x0000000000000000000000000000000000000000)\n\t{\n\t    uint balance = erc20(tokenAddress).balanceOf(seller);\n\t\tif (balance > allowance)\n\t\t\treturn allowance;\n\t\telse\n\t\t\treturn balance;\t\t\n\t}\n\telse\n\t{\t\n\t\tuint balance = erc20Validation(SecondaryValidation[tokenAddress]).balanceOf(seller, tokenAddress);\n\t\tif (balance > allowance)\n\t\t\treturn allowance;\n\t\telse\n\t\t\treturn balance;\n\t}\n}\n\nfunction setSecondaryValidation(address tokenAddress, address validationContractAddress) public onlyOwner\n{\n\tSecondaryValidation[tokenAddress] = validationContractAddress;\n}\n\nfunction reloadPaymentContract(address _address) public onlyOwner\n{\n\tpaymentContract = PaymentContract(_address);\n}\n\nfunction setFee(uint _fee) public onlyOwner\n{\n\tfee = _fee;\n}\n\nfunction setFeeDecimals(uint _feeDecimals) public onlyOwner\n{\n\tfeeDecimals = _feeDecimals;\n}\n}"}}}