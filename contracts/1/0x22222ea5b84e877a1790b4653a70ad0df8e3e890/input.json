{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LibBaseAuth.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.4;\r\n\r\nimport \"LibRoles.sol\";\r\nimport \"LibIERC20.sol\";\r\n\r\n\r\n/**\r\n * @dev Base auth.\r\n */\r\ncontract BaseAuth {\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private _agents;\r\n\r\n    event AgentAdded(address indexed account);\r\n    event AgentRemoved(address indexed account);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor ()\r\n    {\r\n        _agents.add(msg.sender);\r\n        emit AgentAdded(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by account which is not an agent.\r\n     */\r\n    modifier onlyAgent() {\r\n        require(isAgent(msg.sender), \"AgentRole: caller does not have the Agent role\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue compatible ERC20 Token\r\n     *\r\n     * Can only be called by an agent.\r\n     */\r\n    function rescueToken(\r\n        address tokenAddr,\r\n        address recipient,\r\n        uint256 amount\r\n    )\r\n        external\r\n        onlyAgent\r\n    {\r\n        IERC20 _token = IERC20(tokenAddr);\r\n        require(recipient != address(0), \"Rescue: recipient is the zero address\");\r\n        uint256 balance = _token.balanceOf(address(this));\r\n\r\n        require(balance >= amount, \"Rescue: amount exceeds balance\");\r\n        _token.transfer(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw Ether\r\n     *\r\n     * Can only be called by an agent.\r\n     */\r\n    function withdrawEther(\r\n        address payable recipient,\r\n        uint256 amount\r\n    )\r\n        external\r\n        onlyAgent\r\n    {\r\n        require(recipient != address(0), \"Withdraw: recipient is the zero address\");\r\n        uint256 balance = address(this).balance;\r\n        require(balance >= amount, \"Withdraw: amount exceeds balance\");\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `account` has the Agent role.\r\n     */\r\n    function isAgent(address account)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _agents.has(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Give an `account` access to the Agent role.\r\n     *\r\n     * Can only be called by an agent.\r\n     */\r\n    function addAgent(address account)\r\n        public\r\n        onlyAgent\r\n    {\r\n        _agents.add(account);\r\n        emit AgentAdded(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an `account` access from the Agent role.\r\n     *\r\n     * Can only be called by an agent.\r\n     */\r\n    function removeAgent(address account)\r\n        public\r\n        onlyAgent\r\n    {\r\n        _agents.remove(account);\r\n        emit AgentRemoved(account);\r\n    }\r\n}\r\n\r\n"},"LibIERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.4;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n"},"LibIVokenAudit.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.4;\r\n\r\ninterface IVokenAudit {\r\n    function getAccount(address account) external view\r\n        returns (\r\n            uint72 wei_purchased,\r\n            uint72 wei_rewarded,\r\n            uint72 wei_audit,\r\n            uint16 txs_in,\r\n            uint16 txs_out\r\n        );\r\n}\r\n"},"LibRoles.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.4;\r\n\r\n\r\n/**\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role\r\n    {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev Give an account access to this role.\r\n     */\r\n    function add(\r\n        Role storage role,\r\n        address account\r\n    )\r\n        internal\r\n    {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an account's access to this role.\r\n     */\r\n    function remove(\r\n        Role storage role,\r\n        address account\r\n    )\r\n        internal\r\n    {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an account has this role.\r\n     *\r\n     * @return bool\r\n     */\r\n    function has(\r\n        Role storage role,\r\n        address account\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n"},"browser/Voken2Audit.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.4;\r\n\r\nimport \"LibBaseAuth.sol\";\r\nimport \"LibIVokenAudit.sol\";\r\n\r\n\r\n/**\r\n * @dev Voken2.0 Audit\r\n */\r\ncontract Voken2Audit is BaseAuth, IVokenAudit {\r\n    struct Account {\r\n        uint72 wei_purchased;\r\n        uint72 wei_rewarded;\r\n        uint72 wei_audit;\r\n        uint16 txs_in;\r\n        uint16 txs_out;\r\n    }\r\n\r\n    mapping (address => Account) _accounts;\r\n\r\n    function setAccounts(\r\n        address[] memory accounts,\r\n        uint72[] memory wei_purchased,\r\n        uint72[] memory wei_rewarded,\r\n        uint72[] memory wei_audit,\r\n        uint16[] memory txs_in,\r\n        uint16[] memory txs_out\r\n    )\r\n        external\r\n        onlyAgent\r\n    {\r\n        for (uint8 i = 0; i < accounts.length; i++) {\r\n            _accounts[accounts[i]] = Account(wei_purchased[i], wei_rewarded[i], wei_audit[i], txs_in[i], txs_out[i]);\r\n        }\r\n    }\r\n\r\n    function removeAccounts(address[] memory accounts)\r\n        external\r\n        onlyAgent\r\n    {\r\n        for (uint8 i = 0; i < accounts.length; i++) {\r\n            delete _accounts[accounts[i]];\r\n        }\r\n        \r\n    }\r\n\r\n    function getAccount(address account)\r\n        public\r\n        override\r\n        view\r\n        returns (uint72 wei_purchased, uint72 wei_rewarded, uint72 wei_audit, uint16 txs_in, uint16 txs_out)\r\n    {\r\n        wei_purchased = _accounts[account].wei_purchased;\r\n        wei_rewarded = _accounts[account].wei_rewarded;\r\n        wei_audit = _accounts[account].wei_audit;\r\n        txs_in = _accounts[account].txs_in;\r\n        txs_out = _accounts[account].txs_out;\r\n    }\r\n}\r\n\r\n"}}}