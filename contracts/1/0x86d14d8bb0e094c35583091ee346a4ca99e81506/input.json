{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/contracts/StafiBase.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"./interfaces/storage/IStafiStorage.sol\";\n\nabstract contract StafiBase {\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    IStafiStorage stafiStorage = IStafiStorage(0);\n\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.trusted\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered staking pool\n    */\n    modifier onlyRegisteredStakingPool(address _stakingPoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"stakingpool.exists\", _stakingPoolAddress))), \"Invalid staking pool\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(roleHas(\"owner\", msg.sender), \"Account is not the owner\");\n        _;\n    }\n\n\n    /**\n    * @dev Modifier to scope access to admins\n    */\n    modifier onlyAdmin() {\n        require(roleHas(\"admin\", msg.sender), \"Account is not an admin\");\n        _;\n    }\n\n\n    /**\n    * @dev Modifier to scope access to admins\n    */\n    modifier onlySuperUser() {\n        require(roleHas(\"owner\", msg.sender) || roleHas(\"admin\", msg.sender), \"Account is not a super user\");\n        _;\n    }\n\n\n    /**\n    * @dev Reverts if the address doesn't have this role\n    */\n    modifier onlyRole(string memory _role) {\n        require(roleHas(_role, msg.sender), \"Account does not match the specified role\");\n        _;\n    }\n\n\n    /// @dev Set the main Storage address\n    constructor(address _stafiStorageAddress) public {\n        // Update the contract address\n        stafiStorage = IStafiStorage(_stafiStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(keccak256(abi.encodePacked(contractName)) != keccak256(abi.encodePacked(\"\")), \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return stafiStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint256) { return stafiStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return stafiStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return stafiStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return stafiStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int256) { return stafiStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return stafiStorage.getBytes32(_key); }\n    function getAddressS(string memory _key) internal view returns (address) { return stafiStorage.getAddress(keccak256(abi.encodePacked(_key))); }\n    function getUintS(string memory _key) internal view returns (uint256) { return stafiStorage.getUint(keccak256(abi.encodePacked(_key))); }\n    function getStringS(string memory _key) internal view returns (string memory) { return stafiStorage.getString(keccak256(abi.encodePacked(_key))); }\n    function getBytesS(string memory _key) internal view returns (bytes memory) { return stafiStorage.getBytes(keccak256(abi.encodePacked(_key))); }\n    function getBoolS(string memory _key) internal view returns (bool) { return stafiStorage.getBool(keccak256(abi.encodePacked(_key))); }\n    function getIntS(string memory _key) internal view returns (int256) { return stafiStorage.getInt(keccak256(abi.encodePacked(_key))); }\n    function getBytes32S(string memory _key) internal view returns (bytes32) { return stafiStorage.getBytes32(keccak256(abi.encodePacked(_key))); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { stafiStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint256 _value) internal { stafiStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { stafiStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { stafiStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { stafiStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int256 _value) internal { stafiStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { stafiStorage.setBytes32(_key, _value); }\n    function setAddressS(string memory _key, address _value) internal { stafiStorage.setAddress(keccak256(abi.encodePacked(_key)), _value); }\n    function setUintS(string memory _key, uint256 _value) internal { stafiStorage.setUint(keccak256(abi.encodePacked(_key)), _value); }\n    function setStringS(string memory _key, string memory _value) internal { stafiStorage.setString(keccak256(abi.encodePacked(_key)), _value); }\n    function setBytesS(string memory _key, bytes memory _value) internal { stafiStorage.setBytes(keccak256(abi.encodePacked(_key)), _value); }\n    function setBoolS(string memory _key, bool _value) internal { stafiStorage.setBool(keccak256(abi.encodePacked(_key)), _value); }\n    function setIntS(string memory _key, int256 _value) internal { stafiStorage.setInt(keccak256(abi.encodePacked(_key)), _value); }\n    function setBytes32S(string memory _key, bytes32 _value) internal { stafiStorage.setBytes32(keccak256(abi.encodePacked(_key)), _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { stafiStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { stafiStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { stafiStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { stafiStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { stafiStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { stafiStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { stafiStorage.deleteBytes32(_key); }\n    function deleteAddressS(string memory _key) internal { stafiStorage.deleteAddress(keccak256(abi.encodePacked(_key))); }\n    function deleteUintS(string memory _key) internal { stafiStorage.deleteUint(keccak256(abi.encodePacked(_key))); }\n    function deleteStringS(string memory _key) internal { stafiStorage.deleteString(keccak256(abi.encodePacked(_key))); }\n    function deleteBytesS(string memory _key) internal { stafiStorage.deleteBytes(keccak256(abi.encodePacked(_key))); }\n    function deleteBoolS(string memory _key) internal { stafiStorage.deleteBool(keccak256(abi.encodePacked(_key))); }\n    function deleteIntS(string memory _key) internal { stafiStorage.deleteInt(keccak256(abi.encodePacked(_key))); }\n    function deleteBytes32S(string memory _key) internal { stafiStorage.deleteBytes32(keccak256(abi.encodePacked(_key))); }\n\n\n    /**\n    * @dev Check if an address has this role\n    */\n    function roleHas(string memory _role, address _address) internal view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"access.role\", _role, _address)));\n    }\n\n}\n"
    },
    "localhost/contracts/interfaces/storage/IAddressSetStorage.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IAddressSetStorage {\n    function getCount(bytes32 _key) external view returns (uint256);\n    function getItem(bytes32 _key, uint256 _index) external view returns (address);\n    function getIndexOf(bytes32 _key, address _value) external view returns (int256);\n    function addItem(bytes32 _key, address _value) external;\n    function removeItem(bytes32 _key, address _value) external;\n}\n"
    },
    "localhost/contracts/interfaces/storage/IStafiStorage.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiStorage {\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n}\n"
    },
    "localhost/contracts/storage/AddressSetStorage.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../StafiBase.sol\";\nimport \"../interfaces/storage/IAddressSetStorage.sol\";\n\n// Address set storage helper (contains unique items; has reverse index lookups)\ncontract AddressSetStorage is StafiBase, IAddressSetStorage {\n\n    // Construct\n    constructor(address _stafiStorageAddress) StafiBase(_stafiStorageAddress) public {\n        version = 1;\n    }\n\n    // The number of items in a set\n    function getCount(bytes32 _key) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(_key, \".count\")));\n    }\n\n    // The item in a set by index\n    function getItem(bytes32 _key, uint256 _index) override external view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(_key, \".item\", _index)));\n    }\n\n    // The index of an item in a set\n    // Returns -1 if the value is not found\n    function getIndexOf(bytes32 _key, address _value) override external view returns (int256) {\n        return int256(getUint(keccak256(abi.encodePacked(_key, \".index\", _value)))) - 1;\n    }\n\n    // Add an item to a set\n    // Requires that the item does not exist in the set\n    function addItem(bytes32 _key, address _value) override external onlyLatestContract(\"addressSetStorage\", address(this)) onlyLatestNetworkContract {\n        require(getUint(keccak256(abi.encodePacked(_key, \".index\", _value))) == 0, \"Item already exists in set\");\n        uint256 count = getUint(keccak256(abi.encodePacked(_key, \".count\")));\n        setAddress(keccak256(abi.encodePacked(_key, \".item\", count)), _value);\n        setUint(keccak256(abi.encodePacked(_key, \".index\", _value)), count + 1);\n        setUint(keccak256(abi.encodePacked(_key, \".count\")), count + 1);\n    }\n\n    // Remove an item from a set\n    // Swaps the item with the last item in the set and truncates it; computationally cheap\n    // Requires that the item exists in the set\n    function removeItem(bytes32 _key, address _value) override external onlyLatestContract(\"addressSetStorage\", address(this)) onlyLatestNetworkContract {\n        uint256 index = getUint(keccak256(abi.encodePacked(_key, \".index\", _value)));\n        require(index-- > 0, \"Item does not exist in set\");\n        uint256 count = getUint(keccak256(abi.encodePacked(_key, \".count\")));\n        if (index < count - 1) {\n            address lastItem = getAddress(keccak256(abi.encodePacked(_key, \".item\", count - 1)));\n            setAddress(keccak256(abi.encodePacked(_key, \".item\", index)), lastItem);\n            setUint(keccak256(abi.encodePacked(_key, \".index\", lastItem)), index + 1);\n        }\n        setUint(keccak256(abi.encodePacked(_key, \".index\", _value)), 0);\n        setUint(keccak256(abi.encodePacked(_key, \".count\")), count - 1);\n    }\n\n}\n"
    }
  }
}