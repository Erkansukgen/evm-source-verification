{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"testneth.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); }\r\n    function mul(uint x, uint y) internal pure returns (uint z) { require(y == 0 || (z = x * y) / y == x); }\r\n    uint constant WAD = 10 ** 18;\r\n    function wmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), WAD / 2) / WAD; }\r\n}\r\ncontract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor () { _status = _NOT_ENTERED; }\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\ninterface Aggregator { function latestAnswer() external view returns (int256); }\r\ncontract Testn is DSMath, ReentrancyGuard {\r\n    address payable public owner;\r\n    Aggregator public priceFeed = Aggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n    event Deposit(uint128 a);\r\n    constructor() ReentrancyGuard() { owner = msg.sender; }\r\n    function deposit() nonReentrant public payable { emit Deposit(uint128(wmul(msg.value, (uint256(priceFeed.latestAnswer()) * (10 ** 10))))); }\r\n    function withdraw() nonReentrant public {\r\n      require(msg.sender == owner);\r\n      owner.call{value:address(this).balance}(\"\");\r\n    }\r\n    function transferOwnership(address payable newOwner) external {\r\n        require(msg.sender == owner);\r\n        owner = newOwner;\r\n    }\r\n}"}}}