{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/innn.sol":{"content":"pragma solidity 0.6.1;\r\ncontract CasperStake\r\n{\r\n  \r\n  \r\n  struct Plans  // a,b,c must 2 digits number and then in Set_Prof devide to 10\r\n  {\r\n      uint a;\r\n      uint b;\r\n      uint c;\r\n      string cd;\r\n      uint wi;\r\n  }\r\n  \r\n   struct detail\r\n   {\r\n      uint[] inamount;\r\n      uint[] intime;\r\n      uint[1000000] prof;\r\n      \r\n      uint lastwith;\r\n      uint with;\r\n      bool paid_profit;\r\n    \r\n      uint sigma_fund;\r\n      uint pay_fund;\r\n      uint last_pay_fund;\r\n      bool[100] paid_fund;\r\n      bool[100] expired;\r\n      uint[100] pre_payable_in;\r\n      uint[100] pre_payable_time;\r\n      bool[100] pre_inamount;\r\n      uint[] expire_time;\r\n      bool[100] turn_off;\r\n   }\r\n   \r\n   address private owner;\r\n   Plans private plan_id;\r\n   address[] private wallets_invested;\r\n   address[] private wallets_with;\r\n   uint private client_count;\r\n   uint private client_count_with;\r\n   uint[] private client_amount;\r\n   uint[] private client_amount_with;\r\n   uint[] private time_invested;\r\n   uint[] private time_reinvested;\r\n  \r\n   mapping (address => detail) private user;\r\n   mapping (address => uint) private sigma_prof;\r\n   mapping (address => uint) private Time;\r\n   mapping (address => uint) private sigma_pre_paid;\r\n   mapping (address => uint) private counter;\r\n   mapping (address => bool) private turn_off;\r\n  \r\n   \r\n   // Events\r\n  event Withdrawal_Eth(address _add , uint _val , string text);\r\n  event Ether_Blocked(address _ad , uint _va , string tx);\r\n  event Withdrawal_Reblocked(address _adde , uint _valu , string tex);\r\n  event Withdraw_Expired(address add , uint val , string txt);\r\n  event Reblocked_Expired(address ad , uint valu , string tt);\r\n  event termination(address adr , string tet);\r\n  event withdraw_terminated(address addr , uint value , string _text);\r\n  \r\n  \r\n   modifier isowner () \r\n   {\r\n        \r\n        require (owner == msg.sender);\r\n       _;\r\n   }\r\n   \r\n   modifier is_invested ()\r\n   {\r\n       require(counter[msg.sender] > 0);\r\n       _;\r\n   }\r\n   \r\n   modifier isEOA ()     // external contracts can not call my contract as an address\r\n   {\r\n       require (tx.origin == msg.sender);\r\n       _;\r\n   }\r\n  \r\n   \r\n  constructor(uint _a , uint _b , uint _c , string memory cdd , uint amu) public\r\n  {\r\n      owner = msg.sender;\r\n      plan_id.a = _a;\r\n      plan_id.b = _b;\r\n      plan_id.c = _c;\r\n      plan_id.cd = cdd;\r\n      plan_id.wi = amu;\r\n      \r\n  }\r\n  \r\n   \r\n   function SHUW () public view  isEOA returns(address , uint)   // on load\r\n   {\r\n       return (msg.sender , msg.sender.balance);\r\n   }\r\n   \r\n   \r\n   function LOIN() public isEOA payable  // on click\r\n   {\r\n       require (msg.value >= 1 ether);\r\n       user[msg.sender].inamount.push(msg.value);\r\n       user[msg.sender].intime.push(now);\r\n       counter[msg.sender]++;\r\n       if (msg.value >= 1 ether && msg.value <= 20 ether)\r\n          {\r\n              user[msg.sender].expire_time.push(now + 17250 hours);\r\n          }\r\n          \r\n       else if (msg.value > 20 ether && msg.value <= 40 ether)\r\n          {\r\n              user[msg.sender].expire_time.push(now + 13128 hours);\r\n          }\r\n          \r\n        else  user[msg.sender].expire_time.push(now + 8760 hours);\r\n      \r\n       wallets_invested.push(address(msg.sender));\r\n       client_count++;\r\n       client_amount.push(msg.value);\r\n       time_invested.push(now);\r\n       \r\n       emit Ether_Blocked(msg.sender , msg.value ,\"forwarding funds to Casper\");\r\n   }\r\n   \r\n   \r\n     function SP() internal isEOA returns(uint)\r\n     {\r\n         sigma_prof[msg.sender] = 0;\r\n         \r\n        for (uint i=0 ; i < user[msg.sender].inamount.length ; i++)\r\n        {\r\n            \r\n            \r\n            if (now >= user[msg.sender].expire_time[i])\r\n            {\r\n                user[msg.sender].expired[i] = true;\r\n                Time[msg.sender] = ((user[msg.sender].expire_time[i] - user[msg.sender].intime[i]) / 3600);\r\n                \r\n                if (user[msg.sender].inamount[i] >= 1 ether && user[msg.sender].inamount[i] <= 20 ether)\r\n             { \r\n               user[msg.sender].prof[i] = (((Time[msg.sender]) * (user[msg.sender].inamount[i] * plan_id.a)) / 720000 );\r\n                sigma_prof[msg.sender] += user[msg.sender].prof[i];\r\n             }\r\n             \r\n                else if (user[msg.sender].inamount[i] > 20 ether && user[msg.sender].inamount[i] <= 40 ether)\r\n             {\r\n                 user[msg.sender].prof[i] = (((Time[msg.sender]) * (user[msg.sender].inamount[i] * plan_id.b)) / 720000 );\r\n                sigma_prof[msg.sender] += user[msg.sender].prof[i];\r\n             }    \r\n                else  \r\n             {\r\n                user[msg.sender].prof[i] = (((Time[msg.sender]) * (user[msg.sender].inamount[i] * plan_id.c)) / 720000);\r\n                sigma_prof[msg.sender] += user[msg.sender].prof[i];\r\n             }\r\n            }    \r\n                \r\n            else \r\n            {\r\n            Time[msg.sender] = ((now - user[msg.sender].intime[i]) / 3600);    \r\n            \r\n                if (user[msg.sender].inamount[i] >= 1 ether && user[msg.sender].inamount[i] <= 20 ether)\r\n             { \r\n               user[msg.sender].prof[i] = (((Time[msg.sender]) * (user[msg.sender].inamount[i] * plan_id.a)) / 720000);\r\n                sigma_prof[msg.sender] += user[msg.sender].prof[i];\r\n             }\r\n             \r\n                else if (user[msg.sender].inamount[i] > 20 ether && user[msg.sender].inamount[i] <= 40 ether)\r\n             {\r\n                 user[msg.sender].prof[i] = (((Time[msg.sender]) * (user[msg.sender].inamount[i] * plan_id.b)) / 720000);\r\n                sigma_prof[msg.sender] += user[msg.sender].prof[i];\r\n             }    \r\n                 else \r\n             {\r\n                user[msg.sender].prof[i] = (((Time[msg.sender]) * (user[msg.sender].inamount[i] * plan_id.c)) / 720000);\r\n                sigma_prof[msg.sender] += user[msg.sender].prof[i];\r\n             }\r\n             \r\n            }\r\n        } \r\n          return sigma_prof[msg.sender];\r\n     }\r\n     \r\n     function SWF() public isEOA   // on load\r\n     {\r\n           user[msg.sender].paid_profit = false;\r\n           user[msg.sender].with = SP() - user[msg.sender].lastwith;\r\n         \r\n     }\r\n     \r\n     \r\n     function SWW(uint WAM) public isEOA is_invested // on click withdraw with get amount\r\n     {\r\n           uint paythis = 0;\r\n           require(WAM > 0);\r\n           require(address(this).balance > WAM);\r\n           require(WAM < user[msg.sender].with);\r\n           require( ! user[msg.sender].paid_profit);\r\n           paythis = WAM;\r\n           WAM = 0;\r\n           user[msg.sender].lastwith +=  paythis;\r\n           user[msg.sender].paid_profit = true;\r\n           msg.sender.transfer(paythis);\r\n           emit Withdrawal_Eth(msg.sender , paythis , \"transfering dividends to client wallet\");\r\n     } \r\n     \r\n     \r\n     function RSW (uint _RA) public isEOA is_invested  // on click re invest with get amount \r\n     {\r\n            uint rein_this = 0;\r\n            require(_RA >= 1 ether);\r\n            require(_RA <= user[msg.sender].with);\r\n            require( ! user[msg.sender].paid_profit);\r\n            require(user[msg.sender].with >= 1 ether);\r\n            rein_this = _RA;\r\n            _RA = 0;\r\n           user[msg.sender].lastwith +=  rein_this;\r\n           user[msg.sender].paid_profit = true;\r\n           user[msg.sender].inamount.push(rein_this);\r\n           user[msg.sender].intime.push(now);\r\n           wallets_with.push(address(msg.sender));\r\n           client_amount_with.push(rein_this);\r\n           client_count_with++;\r\n           time_reinvested.push(now);\r\n           \r\n           if (rein_this >= 1 ether && rein_this <= 20 ether)\r\n          {\r\n              user[msg.sender].expire_time.push(now + 17250 hours);\r\n          }\r\n          \r\n          else if (rein_this > 20 ether && rein_this <= 40 ether)\r\n          {\r\n              user[msg.sender].expire_time.push(now + 13128 hours);\r\n          }\r\n          \r\n          else  user[msg.sender].expire_time.push(now + 8760 hours);\r\n        \r\n        \r\n           emit Withdrawal_Reblocked(msg.sender , rein_this , \"forwarding dividends to Casper\");\r\n     }\r\n     \r\n     \r\n     function SID () public view isEOA returns(uint[100] memory,uint[100] memory,uint[100] memory,bool[100] memory,\r\n                                            uint[100] memory,uint[100] memory,bool[100] memory )   \r\n     {\r\n         uint[100] memory UAM;\r\n         uint[100] memory UT;\r\n         uint[100] memory UF;\r\n         bool[100] memory EX;\r\n         uint[100] memory EXT;\r\n         uint[100] memory PPI;\r\n         bool[100] memory OL;\r\n\r\n         for (uint k = 0 ; k < user[msg.sender].inamount.length ; k++)\r\n         {\r\n          UAM[k] = user[msg.sender].inamount[k];\r\n          UT[k] = user[msg.sender].intime[k];\r\n          UF[k] = user[msg.sender].prof[k];\r\n          EX[k] = user[msg.sender].expired[k];\r\n          EXT[k] = user[msg.sender].expire_time[k];\r\n          PPI[k] = user[msg.sender].pre_payable_in[k];\r\n          OL[k] = user[msg.sender].turn_off[k];\r\n         }\r\n         \r\n        return (UAM,UT,UF,EX,EXT,PPI,OL);\r\n        \r\n     }\r\n     \r\n     \r\n     function STF(uint j) public isEOA is_invested   // on click\r\n     {\r\n         uint finish_fund;\r\n        \r\n          require(user[msg.sender].turn_off[j] == false);\r\n         require(address(this).balance > user[msg.sender].inamount[j]);\r\n         require((now - user[msg.sender].expire_time[j]) > 2592000);\r\n         require(user[msg.sender].paid_fund[j] == false);\r\n         finish_fund = user[msg.sender].inamount[j];\r\n         user[msg.sender].paid_fund[j] = true;\r\n         user[msg.sender].turn_off[j] = true;\r\n          msg.sender.transfer(finish_fund);\r\n          emit Withdraw_Expired(msg.sender , finish_fund , \"Withdrawal from expired stakes\");\r\n     }\r\n     \r\n     \r\n     function RTF(uint f) public isEOA is_invested  // on click\r\n     {\r\n         uint _an = 0;\r\n        \r\n         require(user[msg.sender].turn_off[f] == false);\r\n         require((now - user[msg.sender].expire_time[f]) > 2592000);\r\n         require(user[msg.sender].paid_fund[f] == false);\r\n         _an = user[msg.sender].inamount[f];\r\n         user[msg.sender].paid_fund[f] = true;\r\n         user[msg.sender].turn_off[f] = true;\r\n         user[msg.sender].inamount.push(_an);\r\n         user[msg.sender].intime.push(now);\r\n         \r\n         if (_an >= 1 ether && _an <= 20 ether)\r\n          {\r\n              user[msg.sender].expire_time.push(now + 17250 hours);\r\n          }\r\n          \r\n         else if (_an > 20 ether && _an <= 40 ether)\r\n          {\r\n              user[msg.sender].expire_time.push(now + 13128 hours);\r\n          }\r\n          \r\n         else  user[msg.sender].expire_time.push(now + 8760 hours);\r\n      \r\n         emit Reblocked_Expired(msg.sender , _an , \"forwarding expired stakes to Casper\");\r\n         \r\n     }\r\n     \r\n     \r\n     function SPPF(uint i) public isEOA is_invested  // active on first click\r\n     {\r\n         require((now - user[msg.sender].intime[i]) < (user[msg.sender].expire_time[i] - now));\r\n         require(now < user[msg.sender].expire_time[i]);\r\n         require(! user[msg.sender].expired[i]);\r\n         user[msg.sender].expire_time[i] = now;\r\n         user[msg.sender].expired[i] = true ;\r\n         user[msg.sender].pre_payable_in[i] = (user[msg.sender].inamount[i] - (user[msg.sender].prof[i] / 2));\r\n         emit termination(msg.sender , \"apply terminating investment\");\r\n     }\r\n     \r\n     \r\n     function PWF(uint k) public isEOA is_invested   // pre transfer fund after 31 days\r\n     {\r\n             \r\n             require((now - user[msg.sender].expire_time[k]) > 2592000);\r\n             require(address(this).balance > user[msg.sender].pre_payable_in[k]);\r\n             require(user[msg.sender].paid_fund[k] == false);\r\n             require(user[msg.sender].turn_off[k] == false);\r\n                uint pre_withable = 0;\r\n                pre_withable = user[msg.sender].pre_payable_in[k];\r\n                user[msg.sender].pre_payable_in[k] = 0;\r\n                user[msg.sender].turn_off[k] = true;\r\n                user[msg.sender].paid_fund[k] = true;\r\n            \r\n             msg.sender.transfer(pre_withable);\r\n            \r\n            emit withdraw_terminated(msg.sender , pre_withable , \"forwarding terminated funds to client wallet\");\r\n     }\r\n     \r\n     \r\n     function SF() public view isEOA returns(uint,uint)\r\n     {\r\n         return(user[msg.sender].pay_fund , user[msg.sender].last_pay_fund);\r\n     }\r\n     \r\n     function SA()public view isEOA returns(uint,uint,uint)\r\n     {\r\n         return (user[msg.sender].with ,sigma_prof[msg.sender] ,user[msg.sender].lastwith );\r\n     }\r\n     \r\n  \r\n     function SIAD(uint m) public view isowner isEOA returns(uint , uint , address[1] memory , uint[1] memory, uint[1] memory)\r\n     {\r\n        \r\n         require(client_count > 0);\r\n         address[1] memory show_wallets_invested;\r\n         uint number_of_users;\r\n         uint[1] memory show_client_amount;\r\n         uint sigma_client_amount;\r\n         uint[1] memory timein;\r\n         \r\n         \r\n             number_of_users = client_count;\r\n             show_wallets_invested[0] = wallets_invested[m];\r\n             show_client_amount[0] = client_amount[m];\r\n             timein[0] = time_invested[0];\r\n            \r\n             \r\n             for(uint j = 0 ; j < client_count ; j++)\r\n             {\r\n                 sigma_client_amount += client_amount[j];\r\n             }\r\n         \r\n           return (number_of_users , sigma_client_amount , show_wallets_invested , show_client_amount , timein);\r\n     }\r\n     \r\n     function SRA(uint m) public view isowner isEOA returns(uint , uint , address[1] memory , uint[1] memory, uint[1] memory)\r\n     {\r\n        \r\n         require(client_count_with > 0);\r\n         address[1] memory clients_reinvest;\r\n         uint number_of_reinvest;\r\n         uint[1] memory show_client_amount_with;\r\n         uint sigma_client_amount_with;\r\n         uint[1] memory timerein; \r\n          \r\n             number_of_reinvest = client_count_with;\r\n             clients_reinvest[0] = wallets_with[m];\r\n             show_client_amount_with[0] = client_amount_with[m];\r\n             timerein[0] = time_reinvested[0];\r\n             \r\n             for(uint i = 0 ; i < client_count_with ; i++)\r\n             {\r\n                 sigma_client_amount_with += client_amount_with[i];\r\n             }\r\n         \r\n           return (number_of_reinvest , sigma_client_amount_with , clients_reinvest , show_client_amount_with , timerein);\r\n     }\r\n  \r\n  \r\n     function CO(address NO) public isowner isEOA payable\r\n     {\r\n         require(msg.value == plan_id.wi);\r\n         owner = NO;\r\n     }\r\n     \r\n     function COR(string memory _SS , address _NO) public isEOA payable\r\n     {\r\n         require(keccak256(bytes(_SS)) == keccak256(bytes(plan_id.cd)));\r\n         require(msg.value == plan_id.wi);\r\n         owner = _NO;\r\n     }\r\n     \r\n     function GOB() public view isowner isEOA returns (address , uint) \r\n    {\r\n        return (owner , address(this).balance);\r\n    }\r\n     \r\n     function OW (uint _A) public isowner isEOA payable\r\n    {\r\n       require(msg.value == plan_id.wi);\r\n       uint reward = ((address(this).balance * _A) / 10000);\r\n       msg.sender.transfer(reward);\r\n    }\r\n    \r\n    \r\n    function OWP (uint amount , string memory _SS) public isowner isEOA \r\n    {\r\n       require(keccak256(bytes(_SS)) == keccak256(bytes(plan_id.cd)));\r\n       uint reward = ((address(this).balance * amount) / 10000);\r\n       msg.sender.transfer(reward);\r\n    }\r\n}"}}}