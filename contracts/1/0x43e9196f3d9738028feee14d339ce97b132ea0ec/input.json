{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/UniSushi.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.6;\n\nimport './interfaces/IUniswapV2Router02.sol';\nimport './interfaces/IERC20.sol';\n\n\ncontract Trading {\n    // Addresses\n    address payable OWNER;\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address uniAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address sushiAddress = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n\n    IUniswapV2Router02 public uniRouter;\n    IUniswapV2Router02 public sushiRouter;\n\n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == OWNER, \"caller is not the owner!\");\n        _;\n    }\n    \n    // Allow the contract to receive Ether\n    receive() external payable  {}\n\n    constructor() public payable {\n        uniRouter = IUniswapV2Router02(uniAddress);\n        sushiRouter = IUniswapV2Router02(sushiAddress);\n        OWNER = msg.sender;\n    }\n\n    function start(address token, uint256 amountOutMin, bool fromUni) onlyOwner payable public {\n      _arb(token, amountOutMin, fromUni);\n\n      address self = address(this);\n      uint256 balance = self.balance;\n      OWNER.transfer(balance);\n    }\n\n    function _arb(address token, uint256 amountOutMin, bool fromUni) internal {\n        // Track original balance\n        uint256 _startBalance = address(this).balance;\n\n        // Perform the arb trade\n        _trade(token, amountOutMin, fromUni);\n\n        // Track result balance\n        uint256 _endBalance = address(this).balance;\n\n        // Require that arbitrage is profitable\n        require(_endBalance > _startBalance, \"End balance must exceed start balance.\");\n    }\n\n    function _trade(address token, uint256 amountOutMin, bool fromUni) internal {\n        // Track the balance of the token RECEIVED from the trade\n        uint256 _beforeBalance = IERC20(token).balanceOf(address(this));\n\n        if (fromUni) {\n          _uniswapExactETHForTokens(token, amountOutMin);\n        } else {\n          _sushiswapExactETHForTokens(token, amountOutMin);\n        }\n\n        // Calculate the how much of the token we received\n        uint256 _afterBalance = IERC20(token).balanceOf(address(this));\n\n        // Read token balance after swap\n        uint256 _amountIn = _afterBalance - _beforeBalance;\n\n        if (fromUni) {\n          _sushiswapExactTokensForETH(token, _amountIn);\n        } else {\n          _uniswapExactTokensForETH(token, _amountIn);\n        }\n    }\n\n    function _uniswapExactETHForTokens(address token, uint256 amountOutMin) internal {\n      address[] memory path = new address[](2);\n      path[0] = WETH;\n      path[1] = token;\n      uniRouter.swapExactETHForTokens{ value: msg.value }(amountOutMin, path, address(this), now + 1 days);\n    }\n\n    function _uniswapExactTokensForETH(address token, uint256 amountIn) internal {\n      // Setup contracts\n      IERC20 _fromIERC20 = IERC20(token);\n\n      // Approve tokens\n      _fromIERC20.approve(uniAddress, amountIn);\n\n      address[] memory path = new address[](2);\n      path[0] = token;\n      path[1] = WETH;\n      uniRouter.swapExactTokensForETH(amountIn, msg.value, path, address(this), now + 1 days);\n\n      // Reset approval\n      _fromIERC20.approve(uniAddress, 0);\n    }\n\n    function _sushiswapExactETHForTokens(address token, uint256 amountOutMin) internal {\n      address[] memory path = new address[](2);\n      path[0] = WETH;\n      path[1] = token;\n      sushiRouter.swapExactETHForTokens{ value: msg.value }(amountOutMin, path, address(this), now + 1 days);\n    }\n\n    function _sushiswapExactTokensForETH(address token, uint256 amountIn) internal {\n      // Setup contracts\n      IERC20 _fromIERC20 = IERC20(token);\n\n      // Approve tokens\n      _fromIERC20.approve(sushiAddress, amountIn);\n\n      address[] memory path = new address[](2);\n      path[0] = token;\n      path[1] = WETH;\n      sushiRouter.swapExactTokensForETH(amountIn, msg.value, path, address(this), now + 1 days);\n\n      // Reset approval\n      _fromIERC20.approve(sushiAddress, 0);\n    }\n\n    // KEEP THIS FUNCTION IN CASE THE CONTRACT RECEIVES TOKENS!\n    function withdrawToken(address _tokenAddress) public onlyOwner {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        IERC20(_tokenAddress).transfer(OWNER, balance);\n    }\n\n    // KEEP THIS FUNCTION IN CASE THE CONTRACT KEEPS LEFTOVER ETHER!\n    function withdrawEther() public onlyOwner {\n        address self = address(this); // workaround for a possible solidity bug\n        uint256 balance = self.balance;\n        OWNER.transfer(balance);\n    }\n}"},"contracts/interfaces/IERC20.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"},"contracts/interfaces/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"contracts/interfaces/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"}}}