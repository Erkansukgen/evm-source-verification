{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Zones.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\n\ninterface IEthMap {\n  function buyZone(uint zoneId) external payable returns (bool success);\n  function sellZone(uint zoneId, uint amount) external returns (bool success);\n  function transferZone(uint zoneId, address recipient) external returns (bool success);\n  function computeInitialPrice(uint zoneId) external view returns (uint price);\n  function getZone(uint zoneId) external view returns (uint id, address owner, uint sellPrice);\n  function getBalance() external view returns (uint amount);\n  function withdraw() external returns (bool success);\n  function transferContractOwnership(address newOwner) external returns (bool success);\n}\n\n\ncontract ZoneMap {\n  IEthMap public constant map = IEthMap(0xB6bbf89c3DbBa20Cb4d5cABAa4A386ACbbAb455e);\n\n  struct Zone {\n    uint id;\n    address owner;\n    uint sellPrice;\n  }\n\n  function getAllZones() external view returns (Zone[] memory zones) {\n    zones = new Zone[](178);\n    for (uint256 i; i < 178; i++) {\n      (uint id, address owner, uint sellPrice) = map.getZone(i);\n      zones[i] = Zone(id, owner, sellPrice);\n    }\n  }\n\n  function getZonesForSale() external view returns (Zone[] memory zones) {\n    zones = new Zone[](178);\n    uint256 n;\n    for (uint256 i; i < 178; i++) {\n      (uint id, address owner, uint sellPrice) = map.getZone(i + 1);\n      if (sellPrice > 0) {\n        zones[n++] = Zone(id, owner, sellPrice);\n      }\n    }\n    assembly { mstore(zones, n) }\n  }\n}"
    }
  }
}