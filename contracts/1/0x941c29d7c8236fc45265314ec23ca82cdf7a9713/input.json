{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"EverPay.sol":{"content":"// Created by everFinance, https://ever.finance\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ncontract EverPay {\r\n    // Event\r\n    event Submission(\r\n        bytes32 indexed id,\r\n        uint256 indexed proposalID,\r\n        address owner,\r\n        address to,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n    event SubmissionFailure(\r\n        bytes32 indexed id,\r\n        uint256 indexed proposalID,\r\n        address owner,\r\n        address to,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n    event Execution(\r\n        bytes32 indexed id,\r\n        uint256 indexed proposalID,\r\n        address to,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n    event ExecutionFailure(\r\n        bytes32 indexed id,\r\n        uint256 indexed proposalID,\r\n        address to,\r\n        uint256 value,\r\n        bytes data\r\n    );\r\n    // event Revocation(address indexed sender, bytes32 indexed id); // TODO\r\n    event Deposit(address indexed sender, uint256 value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint256 required);\r\n\r\n    event OperatorChange(address indexed operator);\r\n    event PausedChange(bool paused);\r\n    // Event End\r\n\r\n    // Storage & Struct\r\n    bool public paused;\r\n    address public operator;\r\n    uint256 public required;\r\n    address[] public owners;\r\n    mapping(address => bool) public isOwner;\r\n\r\n    mapping(bytes32 => Transaction) public transactions;\r\n    mapping(bytes32 => mapping(address => bool)) public confirmations;\r\n\r\n    struct Transaction {\r\n        uint256 proposalID; // proposal ID is Ar tx id, decide how to operate the contract\r\n        address to;\r\n        uint256 value;\r\n        bytes data;\r\n        bool executed;\r\n        bool existed;\r\n    }\r\n    // Storage & Struct End\r\n\r\n    // Modifier\r\n    modifier validRequirement(uint256 ownerCount, uint256 _required) {\r\n        require(\r\n            ownerCount >= _required && ownerCount != 0 && _required != 0,\r\n            \"invalid_required\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this), \"not_wallet\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operator, \"not_operator\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"paused\");\r\n        _;\r\n    }\r\n\r\n    // Modifier End\r\n\r\n    // Manage\r\n    function getPaused() public view returns (bool) {\r\n        return paused;\r\n    }\r\n\r\n    function getOperator() public view returns (address) {\r\n        return operator;\r\n    }\r\n\r\n    function getOwners() public view returns (address[] memory) {\r\n        return owners;\r\n    }\r\n\r\n    function getRequire() public view returns (uint256) {\r\n        return required;\r\n    }\r\n\r\n    function setOperator(address _operator) public onlyWallet {\r\n        require(_operator != address(0), \"null_address\");\r\n\r\n        operator = _operator;\r\n\r\n        emit OperatorChange(operator);\r\n    }\r\n\r\n    function setPaused(bool _paused) public onlyOperator {\r\n        paused = _paused;\r\n\r\n        emit PausedChange(paused);\r\n    }\r\n\r\n    function addOwner(address owner) public onlyWallet {\r\n        require(owner != address(0), \"null_address\");\r\n\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n\r\n        emit OwnerAddition(owner);\r\n    }\r\n\r\n    function removeOwner(address owner) public onlyWallet {\r\n        require(isOwner[owner], \"no_owner_found\");\r\n\r\n        isOwner[owner] = false;\r\n        for (uint256 i = 0; i < owners.length - 1; i++) {\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        owners.pop();\r\n\r\n        if (required > owners.length) {\r\n            changeRequirement(owners.length);\r\n        }\r\n\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    function replaceOwner(address owner, address newOwner) public onlyWallet {\r\n        require(isOwner[owner], \"no_owner_found\");\r\n        require(newOwner != address(0), \"null_address\");\r\n\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n    function changeRequirement(uint256 _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n    // Manage End\r\n\r\n    // Base\r\n    receive() external payable {\r\n        if (msg.value != 0) emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    constructor(address[] memory _owners, uint256 _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    function submit(\r\n        uint256 proposalID, // ar tx id\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes[] memory sigs\r\n    ) public whenNotPaused returns (bytes32) {\r\n        Transaction memory t =\r\n            Transaction({\r\n                proposalID: proposalID,\r\n                to: to,\r\n                value: value,\r\n                data: data,\r\n                executed: false,\r\n                existed: true\r\n            });\r\n\r\n        bytes32 id = txHash(t);\r\n\r\n        for (uint256 i = 0; i < sigs.length; i++) {\r\n            address owner = ecAddress(id, sigs[i]);\r\n            if (!isOwner[owner]) {\r\n                emit SubmissionFailure(id, proposalID, owner, to, value, data);\r\n                continue;\r\n            }\r\n\r\n            if (!transactions[id].existed) {\r\n                transactions[id] = t;\r\n            }\r\n            confirmations[id][owner] = true;\r\n            emit Submission(id, proposalID, owner, to, value, data);\r\n        }\r\n\r\n        execute(id);\r\n        return id;\r\n    }\r\n\r\n    function execute(bytes32 id) internal {\r\n        Transaction memory t = transactions[id];\r\n\r\n        require(!t.executed, \"tx_is_executed\");\r\n        if (!isConfirmed(id)) return;\r\n\r\n        (bool ok, ) = t.to.call{value: t.value}(t.data);\r\n        if (ok) {\r\n            emit Execution(id, t.proposalID, t.to, t.value, t.data);\r\n        } else {\r\n            emit ExecutionFailure(id, t.proposalID, t.to, t.value, t.data);\r\n        }\r\n\r\n        transactions[id].executed = true;\r\n    }\r\n\r\n    function isConfirmed(bytes32 id) public view returns (bool) {\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            if (confirmations[id][owners[i]]) count += 1;\r\n            if (count >= required) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Base End\r\n\r\n    // Utils\r\n    function txHash(Transaction memory t) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(t.proposalID, t.to, t.value, t.data));\r\n    }\r\n\r\n    function ecAddress(bytes32 id, bytes memory sig)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        require(sig.length == 65, \"invalid_sig_len\");\r\n\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n\r\n        assembly {\r\n            r := mload(add(sig, 0x20))\r\n            s := mload(add(sig, 0x40))\r\n            v := byte(0, mload(add(sig, 0x60)))\r\n        }\r\n\r\n        require(v == 27 || v == 28, \"invalid_sig_v\");\r\n\r\n        return\r\n            ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", id)\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n    }\r\n    // Utils End\r\n}"}}}