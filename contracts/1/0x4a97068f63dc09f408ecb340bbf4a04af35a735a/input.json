{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"multisenderv2.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\nlibrary SafeMath {\n  function mul(uint a, uint b) internal pure  returns (uint) {\n    uint c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n  function div(uint a, uint b) internal pure returns (uint) {\n    require(b > 0);\n    uint c = a / b;\n    require(a == b * c + a % b);\n    return c;\n  }\n  function sub(uint a, uint b) internal pure returns (uint) {\n    require(b <= a);\n    return a - b;\n  }\n  function add(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    require(c >= a);\n    return c;\n  }\n  function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\n    return a >= b ? a : b;\n  }\n  function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\n    return a < b ? a : b;\n  }\n  function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n  function min256(uint256 a, uint256 b) internal  pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n\nabstract contract ST20Basic {\n  uint private totalSupply;\n  function balanceOf(address who) public virtual view returns (uint);\n  function transfer(address to, uint value) virtual public;\n  event Transfer(address indexed from, address indexed to, uint value);\n}\n\nabstract contract ST20 is ST20Basic {\n  function allowance(address owner, address spender) public virtual view returns (uint);\n  function transferFrom(address from, address to, uint value) virtual public;\n  function approve(address spender, uint value) virtual public;\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\ncontract BasicToken is ST20Basic {\n\n  using SafeMath for uint;\n  mapping(address => uint) balances;\n  function transfer(address _to, uint _value) public override {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n  }\n  function balanceOf(address _owner) public view override returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\ncontract StandardToken is BasicToken, ST20 {\n  mapping (address => mapping (address => uint)) allowed;\n  using SafeMath for uint;\n  \n  function transferFrom(address _from, address _to, uint _value) public override {\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n  }\n  function approve(address _spender, uint _value) public override {\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n  }\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\ncontract Ownable {\n     address payable public owner;\n    constructor () {\n        owner = msg.sender;\n    }\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n}\n\ncontract ST_Multisender_v2 is Ownable, StandardToken {\n    using SafeMath for uint;\n    mapping(address => bool) private primeList;\n    address private receiverAddress;\n    uint public senderFee = 1;\n    uint public primeFee = 2;\n    address _tokenAddress;\n    StandardToken token = StandardToken(_tokenAddress);\n    event Multisend_Coin_Log(address token, uint256 total);\n    event Token_Receipt_Log(address token, address receiver, uint256 balance);\n    \n    function Is_Prime(address _address) public view returns (bool) {\n        return _address == owner || primeList[_address];\n    }\n    function Set_Prime_Fee(uint _primeFee) onlyOwner public {\n        primeFee = _primeFee;\n    }\n    function Set_Sender_Fee(uint _senderFee) onlyOwner public {\n        senderFee = _senderFee;\n    }\n    function Set_Owner(address payable _owner) onlyOwner public {\n        owner = _owner;\n    }\n    function Register_Prime() payable public {\n        require(msg.value >= primeFee);\n        require(owner.send(msg.value));\n        primeList[msg.sender] = true;\n    }\n    function Register_Prime_Owner(address _address) public onlyOwner {\n        primeList[_address] = true;\n    }\n    function Add_To_Prime_List(  address[] memory _primeList) onlyOwner public {\n        for (uint i =0;i<_primeList.length;i++){\n        primeList[_primeList[i]] = true;}\n    }\n    function Remove_From_Prime_List(address[] memory _primeList) onlyOwner public {\n        for (uint i =0;i<_primeList.length;i++){\n        primeList[_primeList[i]] = false;}\n    }\n   function Multisend_Coin(address payable[]  memory  _to, uint _value) internal {\n        uint sendAmount = _to.length.mul(_value);\n        uint transferValue = msg.value;\n        bool prime = Is_Prime(msg.sender);\n        if (prime){\n        require(transferValue >= sendAmount);\n        } else {\n        require(transferValue >= sendAmount.add(senderFee));}\n        require(_to.length <= 255);\n        for (uint8 i = 0; i < _to.length; i++) {transferValue = transferValue.sub(_value);\n        require(_to[i].send(_value));}\n        if (!prime){owner.transfer(senderFee);}\n        emit Multisend_Coin_Log(0x000000000000000000000000000000000000bEEF, msg.value);\n    }\n    function Multisend_Differ_Coin(address payable[] memory _to, uint[] memory _value) internal {\n        uint sendAmount =0;\n        for (uint8 i=0;i<_to.length;i++ ){sendAmount+=_value[i];}\n        uint remainingValue = msg.value;\n        bool prime = Is_Prime(msg.sender);\n        if (prime){\n        require(remainingValue >= sendAmount);\n        } else {\n        require(remainingValue >= sendAmount.add(senderFee));}\n        require(_to.length == _value.length);\n        require(_to.length <= 255);\n        for (uint8 i = 0; i < _to.length; i++) {remainingValue = remainingValue.sub(_value[i]);\n        require(_to[i].send(_value[i]));}\n        if (!prime){owner.transfer(senderFee);}\n        emit Multisend_Coin_Log(0x000000000000000000000000000000000000bEEF,msg.value);\n    }\n    function Multisend_Token(address _tokenAddress, address[] memory _to, uint _value) internal {\n        uint sendValue = msg.value;\n        bool prime = Is_Prime(msg.sender);\n        if (!prime){\n        require(sendValue >= senderFee);}\n        require(_to.length <= 255);\n        address from = msg.sender;\n        uint256 sendAmount = _to.length.mul(_value);\n        StandardToken token = StandardToken(_tokenAddress);     \n        for (uint8 i = 0; i < _to.length; i++) {token.transferFrom(from, _to[i], _value);}\n        if (!prime){owner.transfer(senderFee);}\n        emit Multisend_Coin_Log(_tokenAddress, sendAmount);\n    }\n    function Multisend_Differ_Token(address _tokenAddress, address[] memory _to, uint[] memory _value) internal {\n        uint sendValue = msg.value;\n        bool prime = Is_Prime(msg.sender);\n        if (!prime){\n        require(sendValue >= senderFee);}\n        require(_to.length == _value.length);\n        require(_to.length <= 255);\n        uint sendAmount = 0;\n        for (uint8 i=0;i<_to.length;i++) {sendAmount+=_value[i];}\n        StandardToken token = StandardToken(_tokenAddress);\n        for (uint8 i = 0; i < _to.length; i++) {token.transferFrom(msg.sender, _to[i], _value[i]);}\n        if (!prime){owner.transfer(senderFee);}\n        emit Multisend_Coin_Log(_tokenAddress, sendAmount);\n    }\n    function Send_Coin(address payable[] memory _to, uint _value) payable public {\n        Multisend_Coin(_to,_value);\n    }\n    function Send_Same_Coin(address payable[] memory _to, uint _value) payable public {\n        Multisend_Coin(_to,_value);\n    }\n    function Send_Differ_Coin(address payable[] memory _to, uint[] memory _value) payable public {\n        Multisend_Differ_Coin(_to,_value);\n    }\n    function Send_Token(address _tokenAddress, address[] memory _to, uint _value)  payable public {\n        Multisend_Token(_tokenAddress, _to, _value);\n    }\n    function Send_Same_Token(address _tokenAddress, address[] memory _to, uint[] memory _value) payable public {\n        Multisend_Differ_Token(_tokenAddress, _to, _value);   \n    }\n    function Send_Differ_Token(address _tokenAddress, address[] memory _to, uint[] memory _value) payable public {\n        Multisend_Differ_Token(_tokenAddress, _to, _value);  \n    }\n    function Withdraw_Coins(uint256 amount) public onlyOwner {\n        payable(msg.sender).transfer(amount);\n    }\n    function Withdraw_Tokens(address tokenAddress, uint256 tokenAmount) public onlyOwner {\n        ST20Basic(tokenAddress).transfer(msg.sender, tokenAmount);\n    }\n}"}}}