{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"XEscrow.sol":{"content":"pragma solidity 0.7.0;\n\ninterface IERC20 {\n     function transferFrom(address _token, address _from, address _to, uint256 _value) external returns (bool success);\n}\n\ninterface ERC20 {\n     function allowance(address owner, address spender) external returns (uint256 amount);\n}\n\ninterface INFT {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n}\n\ncontract Escrow {\n    address transferAddress = address(0);\n    address feeAddress = address(0);\n    address immutable auer = msg.sender;\n    mapping(uint256 => Data) private datas;\n    mapping(address => uint256[]) private dataIdxs;\n    uint256 dataIdx = 0;\n    uint fee1 = 2;\n    uint fee2 = 100;\n    struct Data{\n        uint256 tokenId;\n        address tokenAddress;\n        uint256 amount;\n        address owner;\n    }\n    constructor(address feeAddresses){\n        feeAddress = feeAddresses;\n    }\n    \n    function getAmount(address nftContract,uint256 tokenId) public view virtual returns (uint256){\n        for(uint256 i = 0;i < dataIdxs[nftContract].length;i++){\n            Data memory d = datas[dataIdxs[nftContract][i]];\n            if(d.tokenId == tokenId){\n                return d.amount;\n            }\n        }\n        return 0;\n    }\n    \n    function getOwner(address nftContract,uint256 tokenId) public view virtual returns (address){\n        for(uint256 i = 0;i < dataIdxs[nftContract].length;i++){\n            Data memory d = datas[dataIdxs[nftContract][i]];\n            if(d.tokenId == tokenId){\n                return d.owner; \n            }\n        }\n        return address(0);\n    }\n    \n    function getTokenAddress(address nftContract,uint256 tokenId) public view virtual returns (address){\n        for(uint256 i = 0;i < dataIdxs[nftContract].length;i++){\n            Data memory d = datas[dataIdxs[nftContract][i]];\n            if(d.tokenId == tokenId){\n                return d.tokenAddress;\n            }\n        }\n        return address(0);\n    }\n    \n    function changeFee(uint m1,uint m2) public {\n        require(auer == msg.sender, \"no author\");\n        fee1 = m1;\n        fee2 = m2;\n    }\n    \n    function initNFT(address transfer) public {\n        require(auer == msg.sender, \"no author\");\n        require(transferAddress == address(0), \"have init\");\n        transferAddress = transfer;\n    }\n    \n    function sellNFT(address nftContract,uint256 tokenId,address tokenAddress,uint256 amount) public {\n        require(INFT(nftContract).ownerOf(tokenId) == msg.sender, \"no owner\");\n        require(INFT(nftContract).getApproved(tokenId) == address(this),\"approve error\");\n        require(amount > 0, \"amount error\");\n        Data memory d = Data(tokenId,tokenAddress,amount,msg.sender);\n        datas[dataIdx] = d;\n        if(dataIdxs[nftContract].length > 0){\n            dataIdxs[nftContract].push(dataIdx);\n        }else{\n            dataIdxs[nftContract] = [dataIdx];\n        }\n        dataIdx = dataIdx + 1;\n        INFT(nftContract).transferFrom(msg.sender,address(this),tokenId);\n    }\n    \n    function sellNFTs(address[] memory nftContracts, uint256[] memory tokenIds, address[] memory tokenAddresses, uint256[] memory amounts) public {\n        require(tokenIds.length == nftContracts.length && tokenIds.length == tokenAddresses.length && tokenIds.length == amounts.length && tokenIds.length >= 1, \"tokenId or tokenAddress or amount or nftContract error\");\n        for(uint256 i = 0; i < tokenIds.length; i++){\n            sellNFT(nftContracts[i],tokenIds[i],tokenAddresses[i],amounts[i]);\n        }\n    }\n    \n    function pullNFT(address nftContract,uint256 tokenId) public {\n        require(INFT(nftContract).ownerOf(tokenId) == address(this), \"no escrow\");\n        for(uint256 i = 0;i < dataIdxs[nftContract].length;i++){\n            Data memory d = datas[dataIdxs[nftContract][i]];\n            if(d.tokenId == tokenId){\n                require(d.owner == msg.sender, \"no owner\");\n                delete datas[dataIdxs[nftContract][i]];\n                delete dataIdxs[nftContract][i];\n                INFT(nftContract).transferFrom(address(this),msg.sender,tokenId);\n            }\n        }\n    }\n    \n    function buyNFT(address nftContract,uint256 tokenId) payable public {\n        require(INFT(nftContract).ownerOf(tokenId) == address(this), \"no escrow\");\n        for(uint256 i = 0;i < dataIdxs[nftContract].length;i++){\n            Data memory d = datas[dataIdxs[nftContract][i]];\n            if(d.tokenId == tokenId){\n                uint256 amount = d.amount;\n                require(amount > 0, \"amount error\");\n                address tokenAddress = d.tokenAddress;\n                address owner = d.owner;\n                uint256 at = amount*(fee2-fee1)/fee2;\n                if(tokenAddress == address(0)){\n                    require(amount == msg.value, \"amount error\");\n                    delete datas[dataIdxs[nftContract][i]];\n                    delete dataIdxs[nftContract][i];\n                    address(uint160(feeAddress)).transfer(amount - at);\n                    if(at > 0){\n                        address(uint160(owner)).transfer(at);\n                    }\n                }else{\n                    require(ERC20(tokenAddress).allowance(msg.sender,transferAddress) >= amount,\"approve error\");\n                    delete datas[dataIdxs[nftContract][i]];\n                    delete dataIdxs[nftContract][i];\n                    IERC20(transferAddress).transferFrom(tokenAddress,msg.sender,feeAddress, amount - at);\n                    if(at > 0){\n                        IERC20(transferAddress).transferFrom(tokenAddress,msg.sender,owner,at);\n                    }\n                }\n                INFT(nftContract).transferFrom(address(this),msg.sender,tokenId);\n            }\n        }\n    }\n}\n\n"}}}