{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Letters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context\n{\n\t// Empty internal constructor, to prevent people from mistakenly deploying\n\t// an instance of this contract, which should be used via inheritance.\n\tconstructor(){}\n\t// solhint-disable-previous-line no-empty-blocks\n\n\tfunction _msgSender() internal view returns(address)\n\t{\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view returns(bytes memory)\n\t{\n\t\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n\t\treturn msg.data;\n\t}\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context\n{\n\taddress private _owner;\n\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor()\n\t{\n\t\taddress msgSender = _msgSender();\n\t\t_owner = msgSender;\n\t\temit OwnershipTransferred(address(0), msgSender);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns(address)\n\t{\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner()\n\t{\n\t\trequire(isOwner(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Returns true if the caller is the current owner.\n\t */\n\tfunction isOwner() public view returns(bool)\n\t{\n\t\treturn _msgSender() == _owner;\n\t}\n\n\t/**\n\t * @dev Leaves the contract without owner. It will not be possible to call\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\n\t *\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\n\t * thereby removing any functionality that is only available to the owner.\n\t */\n\tfunction renounceOwnership() public onlyOwner\n\t{\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public onlyOwner\n\t{\n\t\t_transferOwnership(newOwner);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t */\n\tfunction _transferOwnership(address newOwner) internal\n\t{\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165\n{\n\t/**\n\t * @notice Query if a contract implements an interface\n\t * @dev Interface identification is specified in ERC-165. This function\n\t * uses less than 30,000 gas\n\t * @param _interfaceId The interface identifier, as specified in ERC-165\n\t */\n\tfunction supportsInterface(bytes4 _interfaceId) external view returns(bool);\n}\n\n/**\n * @dev ERC-1155 interface for accepting safe transfers.\n */\ninterface IERC1155TokenReceiver\n{\n\t/**\n\t * @notice Handle the receipt of a single ERC1155 token type\n\t * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n\t * This function MAY throw to revert and reject the transfer\n\t * Return of other amount than the magic value MUST result in the transaction being reverted\n\t * Note: The token contract address is always the message sender\n\t * @param _operator  The address which called the `safeTransferFrom` function\n\t * @param _from      The address which previously owned the token\n\t * @param _id        The id of the token being transferred\n\t * @param _amount    The amount of tokens being transferred\n\t * @param _data      Additional data with no specified format\n\t * @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n\t */\n\tfunction onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n\t/**\n\t * @notice Handle the receipt of multiple ERC1155 token types\n\t * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n\t * This function MAY throw to revert and reject the transfer\n\t * Return of other amount than the magic value WILL result in the transaction being reverted\n\t * Note: The token contract address is always the message sender\n\t * @param _operator  The address which called the `safeBatchTransferFrom` function\n\t * @param _from      The address which previously owned the token\n\t * @param _ids       An array containing ids of each token being transferred\n\t * @param _amounts   An array containing amounts of each token being transferred\n\t * @param _data      Additional data with no specified format\n\t * @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n\t */\n\tfunction onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n\n\t/**\n\t * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n\t * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n\t * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n\t *      This function MUST NOT consume more than 5,000 gas.\n\t * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns(bool);\n\n}\n\ninterface IERC1155\n{\n\t// Events\n\n\t/**\n\t * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n\t *   Operator MUST be msg.sender\n\t *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n\t *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n\t *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n\t *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n\t */\n\tevent TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n\n\t/**\n\t * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n\t *   Operator MUST be msg.sender\n\t *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n\t *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n\t *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID\n\t *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n\t */\n\tevent TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n\n\t/**\n\t * @dev MUST emit when an approval is updated\n\t */\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/**\n\t * @dev MUST emit when the URI is updated for a token ID\n\t *   URIs are defined in RFC 3986\n\t *   The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\"\n\t */\n\tevent URI(string _amount, uint256 indexed _id);\n\n\t/**\n\t * @notice Transfers amount of an _id from the _from address to the _to address specified\n\t * @dev MUST emit TransferSingle event on success\n\t * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\n\t * MUST throw if `_to` is the zero address\n\t * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n\t * MUST throw on any other error\n\t * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n\t * @param _from    Source address\n\t * @param _to      Target address\n\t * @param _id      ID of the token type\n\t * @param _amount  Transfered amount\n\t * @param _data    Additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n\t/**\n\t * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n\t * @dev MUST emit TransferBatch event on success\n\t * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\n\t * MUST throw if `_to` is the zero address\n\t * MUST throw if length of `_ids` is not the same as length of `_amounts`\n\t * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n\t * MUST throw on any other error\n\t * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n\t * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n\t * @param _from     Source addresses\n\t * @param _to       Target addresses\n\t * @param _ids      IDs of each token type\n\t * @param _amounts  Transfer amounts per token type\n\t * @param _data     Additional data with no specified format, sent in call to `_to`\n\t*/\n\tfunction safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n\t\n\t/**\n\t * @notice Get the balance of an account's Tokens\n\t * @param _owner  The address of the token holder\n\t * @param _id     ID of the Token\n\t * @return        The _owner's balance of the Token type requested\n\t */\n\tfunction balanceOf(address _owner, uint256 _id) external view returns(uint256);\n\n\t/**\n\t * @notice Get the balance of multiple account/token pairs\n\t * @param _owners The addresses of the token holders\n\t * @param _ids    ID of the Tokens\n\t * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n\t */\n\tfunction balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns(uint256[] memory);\n\n\t/**\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller's tokens\n\t * @dev MUST emit the ApprovalForAll event on success\n\t * @param _operator  Address to add to the set of authorized operators\n\t * @param _approved  True if the operator is approved, false to revoke approval\n\t */\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/**\n\t * @notice Queries the approval status of an operator for a given owner\n\t * @param _owner      The owner of the Tokens\n\t * @param _operator   Address of authorized operator\n\t * @return isOperator True if the operator is approved, false if not\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns(bool isOperator);\n\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address\n{\n\t/**\n\t * Returns whether the target address is a contract\n\t * @dev This function will return false if invoked during the constructor of a contract,\n\t * as the code is not actually created until after the constructor finishes.\n\t * @param account address of the account to check\n\t * @return whether the target address is a contract\n\t */\n\tfunction isContract(address account) internal view returns(bool)\n\t{\n\t\tbytes32 codehash;\n\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n\t\t// XXX Currently there is no better way to check if there is a contract in an address\n\t\t// than to check the size of the code at that address.\n\t\t// See https://ethereum.stackexchange.com/a/14016/36603\n\t\t// for more details about how this works.\n\t\t// TODO Check this again before the Serenity release, because all addresses will be\n\t\t// contracts then.\n\t\tassembly { codehash := extcodehash(account) }\n\t\treturn (codehash != 0x0 && codehash != accountHash);\n\t}\n}\n\n/**\n * @dev Implementation of Multi-Token Standard contract\n */\ncontract ERC1155 is IERC165\n{\n\tusing Address for address;\n\n\t/***********************************|\n\t|        Variables and Events       |\n\t|__________________________________*/\n\n\t// onReceive function signatures\n\tbytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n\tbytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n\n\t// Objects balances\n\tmapping (address => mapping(uint256 => uint256)) internal balances;\n\n\t// Operator Functions\n\tmapping (address => mapping(address => bool)) internal operators;\n\n\t// Events\n\tevent TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n\tevent TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\t//event URI(string _uri, uint256 indexed _id);\n\n\t/***********************************|\n\t|     Public Transfer Functions     |\n\t|__________________________________*/\n\n\t/**\n\t * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n\t * @param _from    Source address\n\t * @param _to      Target address\n\t * @param _id      ID of the token type\n\t * @param _amount  Transfered amount\n\t * @param _data    Additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data) public\n\t{\n\t\trequire((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeTransferFrom: INVALID_OPERATOR\");\n\t\trequire(_to != address(0),\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\");\n\n\t\t_safeTransferFrom(_from, _to, _id, _amount);\n\t\t_callonERC1155Received(_from, _to, _id, _amount, _data);\n\t}\n\n\t/**\n\t * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n\t * @param _from     Source addresses\n\t * @param _to       Target addresses\n\t * @param _ids      IDs of each token type\n\t * @param _amounts  Transfer amounts per token type\n\t * @param _data     Additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) public\n\t{\n\t\t// Requirements\n\t\trequire((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\");\n\t\trequire(_to != address(0), \"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\");\n\n\t\t_safeBatchTransferFrom(_from, _to, _ids, _amounts);\n\t\t_callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\n\t}\n\n\t/***********************************|\n\t|    Internal Transfer Functions    |\n\t|__________________________________*/\n\n\t/**\n\t * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n\t * @param _from    Source address\n\t * @param _to      Target address\n\t * @param _id      ID of the token type\n\t * @param _amount  Transfered amount\n\t */\n\tfunction _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount) internal\n\t{\n\t\t// Update balances\n\t\tbalances[_from][_id] = balances[_from][_id] - _amount; // Subtract amount\n\t\tbalances[_to][_id] = balances[_to][_id] + _amount;     // Add amount\n\n\t\t// Emit event\n\t\temit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\t}\n\n\t/**\n\t * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\n\t */\n\tfunction _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data) internal\n\t{\n\t\t// Check if recipient is contract\n\t\tif(_to.isContract())\n\t\t{\n\t\t\tbytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\n\t\t\trequire(retval == ERC1155_RECEIVED_VALUE, \"ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE\");\n\t\t}\n\t}\n\n\t/**\n\t * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n\t * @param _from     Source addresses\n\t * @param _to       Target addresses\n\t * @param _ids      IDs of each token type\n\t * @param _amounts  Transfer amounts per token type\n\t */\n\tfunction _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts) internal\n\t{\n\t\trequire(_ids.length == _amounts.length, \"ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH\");\n\n\t\t// Number of transfer to execute\n\t\tuint256 nTransfer = _ids.length;\n\n\t\t// Executing all transfers\n\t\tfor(uint256 i = 0; i < nTransfer; i++)\n\t\t{\n\t\t\t// Update storage balance of previous bin\n\t\t\tbalances[_from][_ids[i]] = balances[_from][_ids[i]] - _amounts[i];\n\t\t\tbalances[_to][_ids[i]] = balances[_to][_ids[i]] + _amounts[i];\n\t\t}\n\n\t\t// Emit event\n\t\temit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n\t}\n\n\t/**\n\t * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\n\t */\n\tfunction _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) internal\n\t{\n\t\t// Pass data if recipient is contract\n\t\tif(_to.isContract())\n\t\t{\n\t\t\tbytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data);\n\t\t\trequire(retval == ERC1155_BATCH_RECEIVED_VALUE, \"ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE\");\n\t\t}\n\t}\n\n\t/***********************************|\n\t|         Operator Functions        |\n\t|__________________________________*/\n\n\t/**\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage all of caller's tokens\n\t * @param _operator  Address to add to the set of authorized operators\n\t * @param _approved  True if the operator is approved, false to revoke approval\n\t */\n\tfunction setApprovalForAll(address _operator, bool _approved) external\n\t{\n\t\t// Update operator status\n\t\toperators[msg.sender][_operator] = _approved;\n\t\temit ApprovalForAll(msg.sender, _operator, _approved);\n\t}\n\n\t/**\n\t * @notice Queries the approval status of an operator for a given owner\n\t * @param _owner      The owner of the Tokens\n\t * @param _operator   Address of authorized operator\n\t * @return isOperator True if the operator is approved, false if not\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) virtual public view returns(bool isOperator)\n\t{\n\t\treturn operators[_owner][_operator];\n\t}\n\n\t/***********************************|\n\t|         Balance Functions         |\n\t|__________________________________*/\n\n\t/**\n\t * @notice Get the balance of an account's Tokens\n\t * @param _owner  The address of the token holder\n\t * @param _id     ID of the Token\n\t * @return The _owner's balance of the Token type requested\n\t */\n\tfunction balanceOf(address _owner, uint256 _id) public view returns(uint256)\n\t{\n\t\treturn balances[_owner][_id];\n\t}\n\n\t/**\n\t * @notice Get the balance of multiple account/token pairs\n\t * @param _owners The addresses of the token holders\n\t * @param _ids    ID of the Tokens\n\t * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n\t */\n\tfunction balanceOfBatch(address[] memory _owners, uint256[] memory _ids) public view returns(uint256[] memory)\n\t{\n\t\trequire(_owners.length == _ids.length, \"ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH\");\n\n\t\t// Variables\n\t\tuint256[] memory batchBalances = new uint256[](_owners.length);\n\n\t\t// Iterate over each owner and token ID\n\t\tfor(uint256 i = 0; i < _owners.length; i++)\n\t\t{\n\t\t\tbatchBalances[i] = balances[_owners[i]][_ids[i]];\n\t\t}\n\n\t\treturn batchBalances;\n\t}\n\n\t/***********************************|\n\t|          ERC165 Functions         |\n\t|__________________________________*/\n\n\t/*\n\t * INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n\t */\n\tbytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n\n\t/*\n\t * INTERFACE_SIGNATURE_ERC1155 =\n\t * bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\")) ^\n\t * bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\")) ^\n\t * bytes4(keccak256(\"balanceOf(address,uint256)\")) ^\n\t * bytes4(keccak256(\"balanceOfBatch(address[],uint256[])\")) ^\n\t * bytes4(keccak256(\"setApprovalForAll(address,bool)\")) ^\n\t * bytes4(keccak256(\"isApprovedForAll(address,address)\"));\n\t */\n\tbytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n\n\t/**\n\t * @notice Query if a contract implements an interface\n\t * @param _interfaceID  The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `_interfaceID` and\n\t */\n\tfunction supportsInterface(bytes4 _interfaceID) pure override external returns(bool)\n\t{\n\t\tif(_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\n\t\t   _interfaceID == INTERFACE_SIGNATURE_ERC1155)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n}\n\n/**\n * @notice Contract that handles metadata related methods.\n * @dev Methods assume a deterministic generation of URI based on token IDs.\n *      Methods also assume that URI uses hex representation of token IDs.\n */\ncontract ERC1155Metadata\n{\n\t// URI's default URI prefix\n\tstring internal baseMetadataURI;\n\tevent URI(string _uri, uint256 indexed _id);\n\n\t/***********************************|\n\t|     Metadata Public Function s    |\n\t|__________________________________*/\n\n\t/**\n\t * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n\t * @dev URIs are defined in RFC 3986.\n\t *      URIs are assumed to be deterministically generated based on token ID\n\t *      Token IDs are assumed to be represented in their hex format in URIs\n\t * @return URI string\n\t */\n\tfunction uri(uint256 _id) external view returns(string memory)\n\t{\n\t\treturn string(abi.encodePacked(baseMetadataURI, _uint2str(_id), \".json\"));\n\t}\n\n\t/***********************************|\n\t|    Metadata Internal Functions    |\n\t|__________________________________*/\n\n\t/**\n\t * @notice Will emit default URI log event for corresponding token _id\n\t * @param _tokenIDs Array of IDs of tokens to log default URI\n\t */\n\tfunction _logURIs(uint256[] memory _tokenIDs) internal {\n\t\tstring memory tokenURI;\n\n\t\tfor(uint256 i = 0; i < _tokenIDs.length; i++)\n\t\t{\n\t\t\ttokenURI = string(abi.encodePacked(baseMetadataURI, _uint2str(_tokenIDs[i]), \".json\"));\n\t\t\temit URI(tokenURI, _tokenIDs[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Will emit a specific URI log event for corresponding token\n\t * @param _tokenIDs IDs of the token corresponding to the _uris logged\n\t * @param _URIs    The URIs of the specified _tokenIDs\n\t */\n\tfunction _logURIs(uint256[] memory _tokenIDs, string[] memory _URIs) internal\n\t{\n\t\trequire(_tokenIDs.length == _URIs.length, \"ERC1155Metadata#_logURIs: INVALID_ARRAYS_LENGTH\");\n\t\tfor(uint256 i = 0; i < _tokenIDs.length; i++)\n\t\t{\n\t\t\temit URI(_URIs[i], _tokenIDs[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Will update the base URL of token's URI\n\t * @param _newBaseMetadataURI New base URL of token's URI\n\t */\n\tfunction _setBaseMetadataURI(string memory _newBaseMetadataURI) internal\n\t{\n\t\tbaseMetadataURI = _newBaseMetadataURI;\n\t}\n\n\t/***********************************|\n\t|    Utility Internal Functions     |\n\t|__________________________________*/\n\n\t/**\n\t * @notice Convert uint256 to string\n\t * @param _i Unsigned integer to convert to string\n\t */\n\tfunction _uint2str(uint256 _i) internal pure returns (string memory _uintAsString)\n\t{\n\t\tif(_i == 0)\n\t\t\treturn \"0\";\n\n\t\tuint256 j = _i;\n\t\tuint256 ii = _i;\n\t\tuint256 len;\n\n\t\t// Get number of bytes\n\t\twhile(j != 0)\n\t\t{\n\t\t\tlen++;\n\t\t\tj /= 10;\n\t\t}\n\n\t\tbytes memory bstr = new bytes(len);\n\t\tuint256 k = len - 1;\n\n\t\t// Get each individual ASCII\n\t\twhile(ii != 0)\n\t\t{\n\t\t\tbstr[k] = bytes1(uint8(48 + (ii % 10)));\n\t\t\tii /= 10;\n\t\t\tif(k != 0) k--;\n\t\t}\n\n\t\t// Convert to string\n\t\treturn string(bstr);\n\t}\n}\n\n/**\n * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\n *      a parent contract to be executed as they are `internal` functions\n */\ncontract ERC1155MintBurn is ERC1155\n{\n\t/****************************************|\n\t|            Minting Functions           |\n\t|_______________________________________*/\n\n\t/**\n\t * @notice Mint _amount of tokens of a given id\n\t * @param _to      The address to mint tokens to\n\t * @param _id      Token id to mint\n\t * @param _amount  The amount to be minted\n\t * @param _data    Data to pass if receiver is contract\n\t */\n\tfunction _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data) internal\n\t{\n\t\t// Add _amount\n\t\tbalances[_to][_id] = balances[_to][_id] + _amount;\n\n\t\t// Emit event\n\t\temit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\n\n\t\t// Calling onReceive method if recipient is contract\n\t\t_callonERC1155Received(address(0x0), _to, _id, _amount, _data);\n\t}\n\n\t/**\n\t * @notice Mint tokens for each ids in _ids\n\t * @param _to       The address to mint tokens to\n\t * @param _ids      Array of ids to mint\n\t * @param _amounts  Array of amount of tokens to mint per id\n\t * @param _data    Data to pass if receiver is contract\n\t */\n\tfunction _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) internal\n\t{\n\t\trequire(_ids.length == _amounts.length, \"ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH\");\n\n\t\t// Number of mints to execute\n\t\tuint256 nMint = _ids.length;\n\n\t\t // Executing all minting\n\t\tfor (uint256 i = 0; i < nMint; i++) {\n\t\t\t// Update storage balance\n\t\t\tbalances[_to][_ids[i]] = balances[_to][_ids[i]] + _amounts[i];\n\t\t}\n\n\t\t// Emit batch mint event\n\t\temit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\n\n\t\t// Calling onReceive method if recipient is contract\n\t\t_callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, _data);\n\t}\n\n\t/****************************************|\n\t|            Burning Functions           |\n\t|_______________________________________*/\n\n\t/**\n\t * @notice Burn _amount of tokens of a given token id\n\t * @param _from    The address to burn tokens from\n\t * @param _id      Token id to burn\n\t * @param _amount  The amount to be burned\n\t */\n\tfunction _burn(address _from, uint256 _id, uint256 _amount) internal\n\t{\n\t\t//Substract _amount\n\t\tbalances[_from][_id] = balances[_from][_id] - _amount;\n\n\t\t// Emit event\n\t\temit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\n\t}\n\n\t/**\n\t * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\n\t * @param _from     The address to burn tokens from\n\t * @param _ids      Array of token ids to burn\n\t * @param _amounts  Array of the amount to be burned\n\t */\n\tfunction _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts) internal\n\t{\n\t\trequire(_ids.length == _amounts.length, \"ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH\");\n\n\t\t// Number of mints to execute\n\t\tuint256 nBurn = _ids.length;\n\n\t\t // Executing all minting\n\t\tfor (uint256 i = 0; i < nBurn; i++) {\n\t\t\t// Update storage balance\n\t\t\tbalances[_from][_ids[i]] = balances[_from][_ids[i]] - _amounts[i];\n\t\t}\n\n\t\t// Emit batch mint event\n\t\temit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\n\t}\n}\n\ncontract OwnableDelegateProxy { }\n\ncontract ProxyRegistry\n{\n\tmapping(address => OwnableDelegateProxy) public proxies;\n}\n\n/**\n * @title ERC1155Tradable\n * ERC1155Tradable - ERC1155 contract that whitelists an operator address, has create and mint functionality, and supports useful standards from OpenZeppelin,\n\tlike _exists(), name(), symbol(), and totalSupply()\n */\ncontract ERC1155Tradable is ERC1155, ERC1155MintBurn, ERC1155Metadata, Ownable\n{\n\taddress proxyRegistryAddress;\n\tuint256 private _currentTokenID = 0;\n\tmapping (address => bool) public minters;\n\tmapping (uint256 => address) public creators;\n\tmapping (uint256 => uint256) public tokenSupply;\n\t// Contract name\n\tstring public name;\n\t// Contract symbol\n\tstring public symbol;\n\n\t/**\n\t * @dev Require msg.sender to be the creator of the token id\n\t */\n\tmodifier creatorOnly(uint256 _id)\n\t{\n\t\trequire(creators[_id] == msg.sender, \"ERC1155Tradable#creatorOnly: ONLY_CREATOR_ALLOWED\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Require msg.sender to own more than 0 of the token id\n\t */\n\tmodifier ownersOnly(uint256 _id)\n\t{\n\t\trequire(balances[msg.sender][_id] > 0, \"ERC1155Tradable#ownersOnly: ONLY_OWNERS_ALLOWED\");\n\t\t_;\n\t}\n\n\tconstructor(string memory _name, string memory _symbol, address _proxyRegistryAddress)\n\t{\n\t\tname = _name;\n\t\tsymbol = _symbol;\n\t\tproxyRegistryAddress = _proxyRegistryAddress;\n\t}\n\n\t/**\n\t\t* @dev Returns the total quantity for a token ID\n\t\t* @param _id uint256 ID of the token to query\n\t\t* @return amount of token in existence\n\t\t*/\n\tfunction totalSupply(uint256 _id) public view returns(uint256)\n\t{\n\t\treturn tokenSupply[_id];\n\t}\n\n\t/**\n\t * @dev Will update the base URL of token's URI\n\t * @param _newBaseMetadataURI New base URL of token's URI\n\t */\n\tfunction setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyOwner\n\t{\n\t\t_setBaseMetadataURI(_newBaseMetadataURI);\n\t}\n\n\t/**\n\t * @dev Will update the proxy registry address\n\t * @param _proxyRegistryAddress New proxy registry address\n\t */\n\tfunction setProxyRegisterAddress(address _proxyRegistryAddress) public onlyOwner\n\t{\n\t\tproxyRegistryAddress = _proxyRegistryAddress;\n\t}\n\n\t/**\n\t * @dev Creates a new token type and assigns _initialSupply to an address\n\t * NOTE: remove onlyOwner if you want third parties to create new tokens on your contract (which may change your IDs)\n\t * @param _initialOwner address of the first owner of the token\n\t * @param _initialSupply amount to supply the first owner\n\t * @param _uri Optional URI for this token type\n\t * @param _data Data to pass if receiver is contract\n\t * @return The newly created token ID\n\t */\n\tfunction create(address _initialOwner, uint256 _initialSupply, string calldata _uri, bytes calldata _data) external onlyOwner returns(uint256)\n\t{\n\t\tuint256 _id = _getNextTokenID();\n\t\t_incrementTokenTypeId();\n\t\tcreators[_id] = msg.sender;\n\n\t\tif(bytes(_uri).length > 0)\n\t\t\temit URI(_uri, _id);\n\n\t\t_mint(_initialOwner, _id, _initialSupply, _data);\n\t\ttokenSupply[_id] = _initialSupply;\n\t\treturn _id;\n\t}\n\n\t/**\n\t * @dev Creates a new token type and assigns _initialSupply to an address\n\t * NOTE: remove onlyOwner if you want third parties to create new tokens on your contract (which may change your IDs)\n\t * @param _initialOwner address of the first owner of the token\n\t * @param _initialSupply amount to supply the first owner\n\t * @param _uri Optional URI for this token type\n\t * @param _data Data to pass if receiver is contract\n\t * @param _count Amount of new tokens to create\n\t * @return The last created token ID\n\t */\n\tfunction batchCreate(address _initialOwner, uint256 _initialSupply, string calldata _uri, bytes calldata _data, uint256 _count) external onlyOwner returns(uint256)\n\t{\n\t\t//uint256[] memory _ids = new uint256[](_count);\n\t\t//uint256[] memory _quantities = new uint256[](_count);\n\t\tfor(uint256 i = 0; i < _count; i++)\n\t\t{\n\t\t\tuint256 _id = _getNextTokenID();\n\t\t\t_incrementTokenTypeId();\n\t\t\tcreators[_id] = msg.sender;\n\t\t\t//_ids[i] = _id;\n\t\t\t//_quantities[i] = _initialSupply;\n\t\t\tif(bytes(_uri).length > 0)\n\t\t\t\temit URI(_uri, _id);\n\t\t\t_mint(_initialOwner, _id, _initialSupply, _data);\n\t\t\ttokenSupply[_id] = _initialSupply;\n\t\t}\n\t\t//_batchMint(_initialOwner, _ids, _quantities, _data);\n\t\treturn _count;\n\t}\n\n\t/**\n\t * @dev Mints some amount of tokens to an address\n\t * @param _to          Address of the future owner of the token\n\t * @param _id          Token ID to mint\n\t * @param _quantity    Amount of tokens to mint\n\t * @param _data        Data to pass if receiver is contract\n\t */\n\tfunction mint(address _to, uint256 _id, uint256 _quantity, bytes memory _data) public\n\t{\n\t\trequire(creators[_id] == msg.sender || minters[msg.sender] == true, \"ERC1155Tradable#batchMint: ONLY_CREATOR_ALLOWED\");\n\t\t_mint(_to, _id, _quantity, _data);\n\t\ttokenSupply[_id] = tokenSupply[_id] + _quantity;\n\t}\n\n\t/**\n\t * @dev Mint tokens for each id in _ids\n\t * @param _to          The address to mint tokens to\n\t * @param _ids         Array of ids to mint\n\t * @param _quantities  Array of amounts of tokens to mint per id\n\t * @param _data        Data to pass if receiver is contract\n\t */\n\tfunction batchMint(address _to, uint256[] memory _ids, uint256[] memory _quantities, bytes memory _data) public\n\t{\n\t\tfor(uint256 i = 0; i < _ids.length; i++)\n\t\t{\n\t\t\tuint256 _id = _ids[i];\n\t\t\trequire(creators[_id] == msg.sender || minters[msg.sender] == true, \"ERC1155Tradable#batchMint: ONLY_CREATOR_ALLOWED\");\n\t\t\tuint256 quantity = _quantities[i];\n\t\t\ttokenSupply[_id] = tokenSupply[_id] + quantity;\n\t\t}\n\t\t_batchMint(_to, _ids, _quantities, _data);\n\t}\n\n\t/**\n\t * @dev Change the creator address for given tokens\n\t * @param _to   Address of the new creator\n\t * @param _ids  Array of Token IDs to change creator\n\t */\n\tfunction setCreator(address _to, uint256[] memory _ids) public\n\t{\n\t\trequire(_to != address(0), \"ERC1155Tradable#setCreator: INVALID_ADDRESS.\");\n\t\tfor(uint256 i = 0; i < _ids.length; i++)\n\t\t{\n\t\t\tuint256 id = _ids[i];\n\t\t\t_setCreator(_to, id);\n\t\t}\n\t}\n\n\t/**\n\t * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) override public view returns(bool isOperator)\n\t{\n\t\t// Whitelist OpenSea proxy contract for easy trading.\n\t\tProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n\t\tif(address(proxyRegistry.proxies(_owner)) == _operator)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn ERC1155.isApprovedForAll(_owner, _operator);\n\t}\n\n\t/**\n\t * @dev Change the creator address for given token\n\t * @param _to   Address of the new creator\n\t * @param _id  Token IDs to change creator of\n\t */\n\tfunction _setCreator(address _to, uint256 _id) internal creatorOnly(_id)\n\t{\n\t\tcreators[_id] = _to;\n\t}\n\n\t/**\n\t * @dev Returns whether the specified token exists by checking to see if it has a creator\n\t * @param _id uint256 ID of the token to query the existence of\n\t * @return bool whether the token exists\n\t */\n\tfunction _exists(uint256 _id) internal view returns(bool)\n\t{\n\t\treturn creators[_id] != address(0);\n\t}\n\n\t/**\n\t * @dev calculates the next token ID based on value of _currentTokenID\n\t * @return uint256 for the next token ID\n\t */\n\tfunction _getNextTokenID() private view returns(uint256)\n\t{\n\t\treturn _currentTokenID + 1;\n\t}\n\n\t/**\n\t * @dev increments the value of _currentTokenID\n\t */\n\tfunction _incrementTokenTypeId() private\n\t{\n\t\t_currentTokenID++;\n\t}\n\n\t/**\n\t * @dev gets the value number of tokens available\n\t */\n\tfunction getTokenCount() public view returns(uint256)\n\t{\n\t\treturn _currentTokenID;\n\t}\n\n\t/**\n\t * @dev gets the base metadata uri\n\t */\n\tfunction getMetadataUri() public view returns(string memory)\n\t{\n\t\treturn baseMetadataURI;\n\t}\n\n\t/**\n\t * @dev adds an approver minter\n\t */\n\tfunction addMinter(address _minter, bool _approved) public onlyOwner\n\t{\n\t\tminters[_minter] = _approved;\n\t}\n}\n\n/**\n * @title Letters\n * Letters - a contract for my semi-fungible tokens.\n */\ncontract Letters is ERC1155Tradable\n{\n\tconstructor(address _proxyRegistryAddress)\n\tERC1155Tradable(\n\t\t\"Letters\",\n\t\t\"LTR\",\n\t\t_proxyRegistryAddress\n\t) {\n\t\t_setBaseMetadataURI(\"https://hacker.dog/nft/letters/\");\n\t}\n\n\tfunction contractURI() public view returns(string memory)\n\t{\n\t\treturn string(abi.encodePacked(baseMetadataURI, \"meta.json\"));\n\t}\n}\n"
    }
  }
}