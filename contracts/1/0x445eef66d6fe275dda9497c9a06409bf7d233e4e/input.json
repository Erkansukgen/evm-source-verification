{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":800},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"cardstarter.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n//pragma solidity ^0.7.0;\n\npragma solidity ^0.6.6;\n\ninterface IUniswapV2Router02{\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n}\n\n\ncontract Owned {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can do this\");\n        _;\n    }\n\n    function kill()\n        public\n        onlyOwner\n    {\n        selfdestruct(msg.sender);\n    }\n}\n\n\ncontract Whitelist is Owned {\n  mapping(address => bool) public whitelist;\n\n  modifier onlyWhitelisted() {\n    require(whitelist[msg.sender], \"Not whitelisted\");\n    _;\n  }\n\n  function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n    if (!whitelist[addr]) {\n      whitelist[addr] = true;\n      success = true; \n    }\n  }\n\n  function addAddressesToWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\n    for (uint256 i = 0; i < addrs.length; i++) {\n      if (addAddressToWhitelist(addrs[i])) {\n        success = true;\n      }\n    }\n  }\n\n}\n\ncontract Arbitrage is Whitelist {\n\n    address[] public receivers = [\n                                    0x3a0dD9787833Fc68430EB425F4AC5047cdA7fbbC,\n                                    0xF9F013224D3E96CfE512aDF3Ff11AC589737dc2d,\n                                    0xf357445B655f2eb0E04eAB798e2c1671B3EaAF21,\n                                    0x99d534Bc8bd188992386E8f2A80b182B9bb2Fc06,\n                                    0x11B8f22382Df2BEbd0840f7647f3De4f08f5eBf5,\n                                    0xCE6570edcB8D6b53c74F8A1930a39c9bc5a1E8e4,\n                                    0x6bcf3C477dca10c06E6495B05D336a0b4A0ec5a7,\n                                    0x552c762aE40C3c985E13322DeccD45166C4F5473,\n                                    0x92894B357aD3dF8BA3a60c4570B22B6720fcba1D,\n                                    0x4EDFF874eb20BAc6BA2414d7e7bE2B9Ee1740313,\n                                    0x6aF080795ad3d721c4E86fbA1d26276951625817,\n                                    0xE09deD786fD054165FFEcD1E0ad9C3d6cc868bDE,\n                                    0x10c65fdf3Bd162CE20F7e0b87d588129a66d77cD,\n                                    0x4a4Dd4e4914FcB215d9f31d8Ff99353FEd4b1A76,\n                                    0x86cb8FbAE15848D275C2786dBA01Bfc9aF69113d\n                                    ];\n    \n    IUniswapV2Router02 uniswapRouterV2;\n    uint deadline = 1645388420; // 20.02.2022 20:20:20\n    address public pool;\n    \n    constructor(address router) public {\n        addAddressToWhitelist(owner);\n        addAddressToWhitelist(receivers[0]);\n        addAddressToWhitelist(receivers[1]);\n        addAddressToWhitelist(receivers[2]);\n        addAddressToWhitelist(receivers[3]);\n        addAddressToWhitelist(receivers[4]);\n        uniswapRouterV2 = IUniswapV2Router02(router);\n        \n        // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D - Uni ETH\n        // 0x10ED43C718714eb63d5aA57B78B54704E256024E - Pancake BNB\n        // 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F - Sushiswap ETH\n    }\n    \n    function addAddressToReceivers(address newReceiver) public {\n        receivers.push(newReceiver);\n    }\n    \n    function swapMultiForExactTokens(uint ethAmountMax, uint amountOut, uint bribeAmount, address[] memory path)\n        public\n        onlyWhitelisted\n        returns (uint[] memory amounts)\n    {\n        require (IERC20(path[path.length - 1]).balanceOf(pool) > 0, \"empty\");\n        if (bribeAmount > 0) {\n            block.coinbase.transfer(bribeAmount);\n        }\n        uint receiversCount = 0;\n        while (gasleft() > 200000 && receiversCount < receivers.length) {\n            amounts = uniswapRouterV2.getAmountsIn(amountOut, path);\n            if (amounts[0] > ethAmountMax) {\n                break;\n            }\n            if (amounts[0] > address(this).balance) {\n                amounts = uniswapRouterV2.swapExactETHForTokens{value: address(this).balance}(1, path, owner, deadline);\n                break;\n            }\n            amounts = uniswapRouterV2.swapETHForExactTokens{value: amounts[0]}(amountOut, path, receivers[receiversCount], deadline);\n            receiversCount += 1;\n        }\n    }\n\n    function withdrawEther() external onlyOwner {\n        payable(address(owner)).transfer(address(this).balance);\n    }\n\n    function withdrawTokens(address token) public onlyOwner {\n        uint balance = IERC20(token).balanceOf(address(this));\n        TransferHelper.safeTransfer(token, owner, balance);\n    }\n    \n    function setPool(address _pool) public {\n        pool = _pool;\n    }\n\n    fallback () external {}\n    receive() external payable {}\n}"}}}