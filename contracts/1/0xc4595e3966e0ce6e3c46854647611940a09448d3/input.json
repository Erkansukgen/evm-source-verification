{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FlashbotsCheckAndSend.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n/*\r\n  Copyright 2021 Flashbots: Scott Bigelow (scott@flashbots.net).\r\n*/\r\n\r\n// This contract performs one or many staticcall's, compares their output, and pays\r\n// the miner directly if all calls exactly match the specified result\r\n// For how to use this script, read the Flashbots searcher docs: https://hackmd.io/@flashbots/ryxxWuD6D\r\ncontract FlashbotsCheckAndSend {\r\n    function check32BytesAndSend(address _target, bytes memory _payload, bytes32 _resultMatch) external payable {\r\n        _check32Bytes(_target, _payload, _resultMatch);\r\n        block.coinbase.transfer(msg.value);\r\n    }\r\n\r\n    function check32BytesAndSendMulti(address[] memory _targets, bytes[] memory _payloads, bytes32[] memory _resultMatches) external payable {\r\n        require (_targets.length == _payloads.length);\r\n        require (_targets.length == _resultMatches.length);\r\n        for (uint256 i = 0; i < _targets.length; i++) {\r\n            _check32Bytes(_targets[i], _payloads[i], _resultMatches[i]);\r\n        }\r\n        block.coinbase.transfer(msg.value);\r\n    }\r\n\r\n    function checkBytesAndSend(address _target, bytes memory _payload, bytes memory _resultMatch) external payable {\r\n        _checkBytes(_target, _payload, _resultMatch);\r\n        block.coinbase.transfer(msg.value);\r\n    }\r\n\r\n    function checkBytesAndSendMulti(address[] memory _targets, bytes[] memory _payloads, bytes[] memory _resultMatches) external payable {\r\n        require (_targets.length == _payloads.length);\r\n        require (_targets.length == _resultMatches.length);\r\n        for (uint256 i = 0; i < _targets.length; i++) {\r\n            _checkBytes(_targets[i], _payloads[i], _resultMatches[i]);\r\n        }\r\n        block.coinbase.transfer(msg.value);\r\n    }\r\n\r\n    // ======== INTERNAL ========\r\n    \r\n    function _check32Bytes(address _target, bytes memory _payload, bytes32 _resultMatch) internal view {\r\n        (bool _success, bytes memory _response) = _target.staticcall(_payload);\r\n        require(_success, \"!success\");\r\n        require(_response.length >= 32, \"response less than 32 bytes\");\r\n        bytes32 _responseScalar;\r\n        assembly {\r\n            _responseScalar := mload(add(_response, 0x20))\r\n        }\r\n        require(_responseScalar == _resultMatch, \"response mismatch\");\r\n    }\r\n\r\n    function _checkBytes(address _target, bytes memory _payload, bytes memory _resultMatch) internal view {\r\n        (bool _success, bytes memory _response) = _target.staticcall(_payload);\r\n        require(_success, \"!success\");\r\n        require(keccak256(_resultMatch) == keccak256(_response), \"response bytes mismatch\");\r\n    }\r\n}"}}}