{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "FINAL_FINAL.sol": {
      "content": "// File: contracts/erc721.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\n\ninterface ERC721\n{\n\n  event Transfer(\n    address indexed _from,\n    address indexed _to,\n    uint256 indexed _tokenId\n  );\n\n  event Approval(\n    address indexed _owner,\n    address indexed _approved,\n    uint256 indexed _tokenId\n  );\n\n  event ApprovalForAll(\n    address indexed _owner,\n    address indexed _operator,\n    bool _approved\n  );\n\n\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external;\n\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external;\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external;\n\n\n  function approve(\n    address _approved,\n    uint256 _tokenId\n  )\n    external;\n\n\n  function setApprovalForAll(\n    address _operator,\n    bool _approved\n  )\n    external;\n\n\n  function balanceOf(\n    address _owner\n  )\n    external\n    view\n    returns (uint256);\n\n\n  function ownerOf(\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (address);\n\n  function getApproved(\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (address);\n\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    external\n    view\n    returns (bool);\n\n}\n\n// File: contracts/Ownable.sol\n\ncontract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  constructor()  {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  function owner() public view returns(address) {\n    return _owner;\n  }\n\n\n  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n\n  \n  function isOwner() public view returns(bool) {\n    return msg.sender == _owner;\n  }\n\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\n// File: contracts/erc721-token-receiver.sol\n\ninterface ERC721TokenReceiver\n{\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external\n    returns(bytes4);\n\n}\n\n// File: contracts/erc165.sol\n\n\ninterface ERC165\n{\n\n  function supportsInterface(\n    bytes4 _interfaceID\n  )\n    external\n    view\n    returns (bool);\n    \n}\n\n// File: contracts/supports-interface.sol\n\ncontract SupportsInterface is\n  ERC165\n{\n\n\n  mapping(bytes4 => bool) internal supportedInterfaces;\n\n  constructor()\n  {\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\n  }\n\n\n  function supportsInterface(\n    bytes4 _interfaceID\n  )\n    external\n    override\n    view\n    returns (bool)\n  {\n    return supportedInterfaces[_interfaceID];\n  }\n\n}\n\n// File: contracts/address-utils.sol\n\nlibrary AddressUtils\n{\n\n\n  function isContract(\n    address _addr\n  )\n    internal\n    view\n    returns (bool addressCheck)\n  {\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\n  }\n\n}\n\n// File: contracts/nf-token.sol\n\ncontract DIEDED_BASE is\n  ERC721,\n  SupportsInterface,\n  Ownable\n{\n  using AddressUtils for address;\n\n  uint256 constant MAX_MINT_NR = 1000;\n  uint256 public nextMintID;\n\n  string baseURI;\n  string _symbol;\n  string _name;\n\n  address [] whitelisted;\n  \n  bool public isMintWindowOpen;\n\n\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n  mapping (uint256 => address) internal idToOwner;\n\n\n  mapping (uint256 => address) internal idToApproval;\n\n\n  mapping (address => uint256) internal ownerToNFTokenCount;\n\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\n\n  modifier canOperate(\n    uint256 _tokenId\n  )\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\n      \"003003\"\n    );\n    _;\n  }\n\n  modifier canTransfer(\n    uint256 _tokenId\n  )\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(\n      tokenOwner == msg.sender\n      || idToApproval[_tokenId] == msg.sender\n      || ownerToOperators[tokenOwner][msg.sender],\n      \"003004\"\n    );\n    _;\n  }\n\n  modifier validNFToken(\n    uint256 _tokenId\n  )\n  {\n    require(idToOwner[_tokenId] != address(0), \"003002\");\n    _;\n  }\n\n  constructor()\n  {\n    _name = \"DIEDED\";\n    _symbol = \"DIEDED\";\n    setBaseTokenURI(\"https://dieded.art/URIS/\");\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\n  }\n\n\n  function setBaseTokenURI(string memory _baseURI) public onlyOwner{\n      baseURI = _baseURI;\n  }\n\n  function name() external view returns (string memory name_ret){\n      return _name;\n  }\n\n  function symbol() external view returns (string memory symbol_ret){\n      return _symbol;\n  }\n\n\n  function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n    require(tokenId <= nextMintID, \"ERC721: URI query for nonexistent token\");\n    return string(abi.encodePacked(baseURI, uint2str(tokenId), \".json\"));\n  }\n\n\n  function _mint(\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n    virtual\n  {\n    require(_to != address(0), \"003001\");\n    require(idToOwner[_tokenId] == address(0), \"003006\");\n\n    _addNFToken(_to, _tokenId);\n    \n    emit Transfer(address(0), _to, _tokenId);\n  }\n\n\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external\n    override\n  {\n    _safeTransferFrom(_from, _to, _tokenId, _data);\n  }\n\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n    override\n  {\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\n  }\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external\n    override\n    canTransfer(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(tokenOwner == _from, \"003007\");\n    require(_to != address(0), \"003001\");\n\n    _transfer(_to, _tokenId);\n  }\n\n  function approve(\n    address _approved,\n    uint256 _tokenId\n  )\n    external\n    override\n    canOperate(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(_approved != tokenOwner, \"003008\");\n\n    idToApproval[_tokenId] = _approved;\n    emit Approval(tokenOwner, _approved, _tokenId);\n  }\n\n  function setApprovalForAll(\n    address _operator,\n    bool _approved\n  )\n    external\n    override\n  {\n    ownerToOperators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }\n\n  function balanceOf(\n    address _owner\n  )\n    external\n    override\n    view\n    returns (uint256)\n  {\n    require(_owner != address(0), \"003001\");\n    return _getOwnerNFTCount(_owner);\n  }\n\n  function ownerOf(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    returns (address _owner)\n  {\n    _owner = idToOwner[_tokenId];\n    require(_owner != address(0), \"003002\");\n  }\n\n  function getApproved(\n    uint256 _tokenId\n  )\n    external\n    override\n    view\n    validNFToken(_tokenId)\n    returns (address)\n  {\n    return idToApproval[_tokenId];\n  }\n\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    external\n    override\n    view\n    returns (bool)\n  {\n    return ownerToOperators[_owner][_operator];\n  }\n\n  function _transfer(\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n  {\n    address from = idToOwner[_tokenId];\n    _clearApproval(_tokenId);\n\n    _removeNFToken(from, _tokenId);\n    _addNFToken(_to, _tokenId);\n\n    emit Transfer(from, _to, _tokenId);\n  }\n\n\n  function _removeNFToken(\n    address _from,\n    uint256 _tokenId\n  )\n    internal\n    virtual\n  {\n    require(idToOwner[_tokenId] == _from, \"003007\");\n    ownerToNFTokenCount[_from] -= 1;\n    delete idToOwner[_tokenId];\n  }\n\n  function _addNFToken(\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n    virtual\n  {\n    require(idToOwner[_tokenId] == address(0), \"003006\");\n\n    idToOwner[_tokenId] = _to;\n    ownerToNFTokenCount[_to] += 1;\n  }\n\n\n  function _getOwnerNFTCount(\n    address _owner\n  )\n    internal\n    virtual\n    view\n    returns (uint256)\n  {\n    return ownerToNFTokenCount[_owner];\n  }\n\n  function _safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    private\n    canTransfer(_tokenId)\n    validNFToken(_tokenId)\n  {\n    address tokenOwner = idToOwner[_tokenId];\n    require(tokenOwner == _from, \"003007\");\n    require(_to != address(0), \"003001\");\n\n    _transfer(_to, _tokenId);\n\n    if (_to.isContract())\n    {\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n      require(retval == MAGIC_ON_ERC721_RECEIVED, \"003005\");\n    }\n  }\n\n  function _clearApproval(\n    uint256 _tokenId\n  )\n    private\n  {\n    delete idToApproval[_tokenId];\n  }\n\n  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n        return \"0\";\n    }\n    uint j = _i;\n    uint len;\n    while (j != 0) {\n        len++;\n        j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint k = len;\n    while (_i != 0) {\n        k = k-1;\n        uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n        bytes1 b1 = bytes1(temp);\n        bstr[k] = b1;\n        _i /= 10;\n    }\n    return string(bstr);\n  }\n\n}\n\n// File: contracts/erc721-enumerable.sol\n\ninterface ERC721Enumerable\n{\n\n  function totalSupply()\n    external\n    view\n    returns (uint256);\n\n  function tokenByIndex(\n    uint256 _index\n  )\n    external\n    view\n    returns (uint256);\n\n  function tokenOfOwnerByIndex(\n    address _owner,\n    uint256 _index\n  )\n    external\n    view\n    returns (uint256);\n\n}\n\n// File: contracts/nf-token-enumerable.sol\n\ncontract DIEDED is\n  DIEDED_BASE,\n  ERC721Enumerable\n{\n\n\n  string constant INVALID_INDEX = \"005007\";\n\n  uint256[] internal tokens;\n\n\n  mapping(uint256 => uint256) internal idToIndex;\n\n\n  mapping(address => uint256[]) internal ownerToIds;\n\n  mapping(uint256 => uint256) internal idToOwnerIndex;\n\n  mapping(address => uint8) internal whitelistedClaimed;\n\n  constructor(address[] memory _whitelisted)\n  {  \n    nextMintID = 45;\n\n    for (uint8 i=0; i<_whitelisted.length; i++)\n    {\n        whitelisted.push(_whitelisted[i]);\n        whitelistedClaimed[_whitelisted[i]] = 10; //not claimed\n    }\n\n    isMintWindowOpen = false;\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n  }\n\n  function openCloseMint(bool _status) public onlyOwner{\n      isMintWindowOpen = _status;\n  }\n\n  function mintForOwner(uint8 section) public onlyOwner{\n    if(section == 0){\n      for (uint8 i=0; i<45; i++) {    \n          _mintForOWner(msg.sender,i); \n      }\n    }\n    else if(section == 1){\n      for (uint8 i=0; i<15; i++) {    \n          _mintForOWner(msg.sender,i); \n      }\n    }\n    else if(section == 2){\n      for (uint8 i=15; i<30; i++) {    \n          _mintForOWner(msg.sender,i); \n      }\n    }\n    else if(section == 3){\n      for (uint8 i=30; i<45; i++) {    \n          _mintForOWner(msg.sender,i); \n      }\n    }\n\n  }\n\n  function addToWhitelistArray(address[] memory _whitelisted) public onlyOwner {\n    for (uint8 i=0; i<_whitelisted.length; i++)\n    {\n        whitelisted.push(_whitelisted[i]);\n        whitelistedClaimed[_whitelisted[i]] = 10; //not claimed\n    }\n  }\n\n  function totalSupply()\n    external\n    override\n    view\n    returns (uint256)\n  {\n    return tokens.length;\n  }\n\n  function tokenByIndex(\n    uint256 _index\n  )\n    external\n    override\n    view\n    returns (uint256)\n  {\n    require(_index < tokens.length, INVALID_INDEX);\n    return tokens[_index];\n  }\n\n  function tokenOfOwnerByIndex(\n    address _owner,\n    uint256 _index\n  )\n    external\n    override\n    view\n    returns (uint256)\n  {\n    require(_index < ownerToIds[_owner].length, INVALID_INDEX);\n    return ownerToIds[_owner][_index];\n  }\n\n  function tokenOfOwnerByIndexInternal(\n    address _owner,\n    uint256 _index\n  )\n    internal\n    view\n    returns (uint256)\n  {\n    require(_index < ownerToIds[_owner].length, INVALID_INDEX);\n    return ownerToIds[_owner][_index];\n  }\n\n  function isEligibleToFutureMints(address who, uint256 _modulo) external view returns (bool)\n  {\n    \n    for (uint256 i=0; i<_getOwnerNFTCount(who); i++)\n    {\n        uint256 token_id = tokenOfOwnerByIndexInternal(who, i);\n        if(token_id % 20 == _modulo)\n        {\n          return true;\n        }\n    }\n\n    return false;\n  }\n\n  function isWhitelistedAndNotClaimedYet(address isWhitelistedAddr) public view returns (bool) {\n    bool result = false;\n    for (uint256 i=0; i<whitelisted.length; i++)\n    {\n        if( whitelisted[i] == isWhitelistedAddr && whitelistedClaimed[isWhitelistedAddr] == 10)\n        {\n            return true;\n        }\n    }\n    return result;\n  } \n\n  function claim(uint8 mint_num) external payable{\n    require(isMintWindowOpen, \"Mint window is not open\");\n    require(mint_num + nextMintID < MAX_MINT_NR+1, \"The amount of mints would exceed the supply!\");\n    require(_getOwnerNFTCount(msg.sender) + mint_num <= 5, \"Claiming too many assets per address\");\n\n    bool whitelisted_res = isWhitelistedAndNotClaimedYet(msg.sender);\n\n  if( \n      (mint_num == 1 && whitelisted_res == false) ||\n      (mint_num == 2 && whitelisted_res == true)\n    )\n  {\n    require(msg.value >= 0.0666 ether, \"Claiming such amount of membership costs 0.0666 ETH for this address\");\n  }\n  else if ( \n      (mint_num == 2 && whitelisted_res == false) ||\n      (mint_num == 3 && whitelisted_res == true)\n    )\n  {\n    require(msg.value >= 0.1332 ether, \"Claiming such amount of membership costs 0.1332 ETH for this address\");\n  }\n  else if ( \n      (mint_num == 3 && whitelisted_res == false) ||\n      (mint_num == 4 && whitelisted_res == true)\n    )\n  {\n    require(msg.value >= 0.1998 ether, \"Claiming such amount of membership costs 0.1998 ETH for this address\");\n  }\n  else if ( (mint_num == 4 && whitelisted_res == false) ||\n            (mint_num == 5 && whitelisted_res == true)\n          )\n  {\n    require(msg.value >= 0.2664 ether, \"Claiming such amount of membership costs 0.2664 ETH for this address\");\n  }\n  else if ( (mint_num == 5 && whitelisted_res == false) )\n  {\n    require(msg.value >= 0.333 ether, \"Claiming such amount of membership costs 0.333 ETH for this address\");\n  }\n\n  for (uint8 i=0; i<mint_num; i++)\n  {\n    whitelisted_res = isWhitelistedAndNotClaimedYet(msg.sender);\n    if ( whitelisted_res == true ){\n      whitelistedClaimed[msg.sender] = 20; //claimed\n        _mint(msg.sender,nextMintID);\n    }\n    else{\n        _mint(msg.sender,nextMintID);\n    }\n  }\n  // Transfer mint price to contract owner\n  payable(owner()).transfer(msg.value);\n}\n\n\n  function _mint(\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n    override\n    virtual\n  {\n    require (nextMintID < MAX_MINT_NR);\n    super._mint(_to, _tokenId);\n    tokens.push(_tokenId);\n    idToIndex[_tokenId] = tokens.length - 1;\n    nextMintID += 1;\n  }\n\n  function _mintForOWner(\n    address _to,\n    uint256 _tokenId\n  )\n    internal onlyOwner\n  {\n    super._mint(_to, _tokenId);\n    tokens.push(_tokenId);\n    idToIndex[_tokenId] = tokens.length - 1;\n\n  }\n\n  function _removeNFToken(\n    address _from,\n    uint256 _tokenId\n  )\n    internal\n    override\n    virtual\n  {\n    require(idToOwner[_tokenId] == _from, \"003006\");\n    delete idToOwner[_tokenId];\n\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\n\n    if (lastTokenIndex != tokenToRemoveIndex)\n    {\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n    }\n\n    ownerToIds[_from].pop();\n  }\n\n  function _addNFToken(\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n    override\n    virtual\n  {\n    require(idToOwner[_tokenId] == address(0), \"003007\");\n    idToOwner[_tokenId] = _to;\n\n    ownerToIds[_to].push(_tokenId);\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\n  }\n\n  function _getOwnerNFTCount(\n    address _owner\n  )\n    internal\n    override\n    virtual\n    view\n    returns (uint256)\n  {\n    return ownerToIds[_owner].length;\n  }\n}\n"
    }
  }
}