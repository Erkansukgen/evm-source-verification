{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Batcher.sol": {
      "content": "pragma solidity 0.7.5;\n\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n *\n * Batcher\n * =======\n *\n * Contract that can take a batch of transfers, presented in the form of a recipients array and a values array, and\n * funnel off those funds to the correct accounts in a single transaction. This is useful for saving on gas when a\n * bunch of funds need to be transferred to different accounts.\n *\n * This contract will return any excess funds in a batch back to the sender. It should never store any ETH on it.\n * If any tokens are accidentally transferred to this account, contact the contract owner in order to recover them.\n *\n *\n */\n\ncontract Batcher {\n    event BatchTransfer(address sender, address recipient, uint256 value);\n    event OwnerChange(address prevOwner, address newOwner);\n    event TransferGasLimitChange(uint256 prevTransferGasLimit, uint256 newTransferGasLimit);\n\n    address public owner;\n    uint256 public lockCounter;\n    uint256 public transferGasLimit;\n\n    constructor() {\n        lockCounter = 1;\n        owner = msg.sender;\n        emit OwnerChange(address(0), owner);\n        transferGasLimit = 10000;\n        emit TransferGasLimitChange(0, transferGasLimit);\n    }\n\n    modifier lockCall() {\n        lockCounter++;\n        uint256 localCounter = lockCounter;\n        _;\n        require(localCounter == lockCounter, \"Reentrancy attempt detected\");\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /**\n     * Transfer funds in a batch to each of recipients\n     * @param recipients The list of recipients to send to\n     * @param values The list of values to send to recipients. \n     *  The recipient with index i in recipients array will be sent values[i].\n     *  Thus, recipients and values must be the same length\n     */\n    function batch(address[] calldata recipients, uint256[] calldata values) external payable lockCall {\n        require(recipients.length != 0, \"Must send to at least one person\");\n        require(recipients.length == values.length, \"Unequal recipients and values\");\n        require(recipients.length < 256, \"Too many recipients\");\n\n        // Try to send all given amounts to all given recipients\n        // Revert everything if any transfer fails\n        for (uint8 i = 0; i < recipients.length; i++) {\n            require(recipients[i] != address(0), \"Invalid recipient address\");\n            (bool success,) = recipients[i].call{value: values[i], gas: transferGasLimit}(\"\");\n            require(success, \"Send failed\");\n            emit BatchTransfer(msg.sender, recipients[i], values[i]);\n        }\n\n        if (address(this).balance > 0) {\n            (bool success,) = msg.sender.call{value: address(this).balance, gas: transferGasLimit}(\"\");\n            require(success, \"Sender refund failed\");\n        }\n    }\n\n    /**\n     * Recovery function for the contract owner to recover any ERC20 tokens or ETH that may get lost in the control of this contract.\n     * @param to The recipient to send to\n     * @param value The ETH value to send with the call\n     * @param data The data to send along with the call\n     */\n    function recover(address to, uint256 value, bytes calldata data) external onlyOwner returns (bytes memory) {\n        (bool success, bytes memory returnData) = to.call{value: value}(data);\n        require(success, \"Call was not successful\");\n        return returnData;\n    }\n\n    /**\n     * Transfers ownership of the contract ot the new owner\n     * @param newOwner The address to transfer ownership of the contract to\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid new owner\");\n        emit OwnerChange(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * Change the gas limit that is sent along with batched transfers. \n     * This is intended to protect against any EVM level changes that would require\n     * a new amount of gas for an internal send to complete. \n     * @param newTransferGasLimit The new gas limit to send along with batched transfers\n     */\n    function changeTransferGasLimit(uint256 newTransferGasLimit) external onlyOwner {\n        require(newTransferGasLimit >= 2300, \"Transfer gas limit too low\");\n        emit TransferGasLimitChange(transferGasLimit, newTransferGasLimit);\n        transferGasLimit = newTransferGasLimit;\n    }\n\n    fallback() external payable {\n        revert(\"Invalid fallback\");\n    }\n    \n    receive() external payable {\n        revert(\"Invalid receive\");\n    }\n}"
    }
  }
}