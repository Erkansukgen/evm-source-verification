{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"hi.sol":{"content":"/// SPDX-License-Identifier: MIT\r\n/*\r\n▄▄█    ▄   ██   █▄▄▄▄ ▄█ \r\n██     █  █ █  █  ▄▀ ██ \r\n██ ██   █ █▄▄█ █▀▀▌  ██ \r\n▐█ █ █  █ █  █ █  █  ▐█ \r\n ▐ █  █ █    █   █    ▐ \r\n   █   ██   █   ▀   \r\n           ▀          */\r\n/// Special thanks to Keno, Boring and Gonpachi for review and continued inspiration.\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\n/// @notice A library for performing overflow-/underflow-safe math,\r\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\r\nlibrary BoringMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\r\n    }\r\n\r\n    function to128(uint256 a) internal pure returns (uint128 c) {\r\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\r\n        c = uint128(a);\r\n    }\r\n\r\n    function to64(uint256 a) internal pure returns (uint64 c) {\r\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\r\n        c = uint64(a);\r\n    }\r\n\r\n    function to32(uint256 a) internal pure returns (uint32 c) {\r\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\r\n        c = uint32(a);\r\n    }\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0\r\n/// License-Identifier: MIT\r\n\r\nlibrary BoringERC20 {\r\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\r\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\r\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\r\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\r\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\r\n\r\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\r\n    }\r\n\r\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\r\n    /// Reverts on a failed transfer.\r\n    /// @param token The address of the ERC-20 token.\r\n    /// @param from Transfer tokens from.\r\n    /// @param to Transfer tokens to.\r\n    /// @param amount The token amount.\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\r\n    }\r\n}\r\n\r\n/// @notice Interface for SushiSwap.\r\ninterface ISushiSwap {\r\n    function deposit() external payable;\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n/// @notice Contract that batches SUSHI staking and DeFi strategies - V1.\r\ncontract Inari {\r\n    using BoringMath for uint256;\r\n    using BoringERC20 for IERC20;\r\n\r\n    address constant sushiSwapFactory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac; // SushiSwap factory contract\r\n    bytes32 constant pairCodeHash = 0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303; // SushiSwap pair code hash\r\n\r\n    /// @notice SushiSwap `fromToken` `amountIn` to `toToken` for benefit of `to`.\r\n    function swap(address fromToken, address toToken, address to, uint256 amountIn) external returns (uint256 amountOut) {\r\n        (address token0, address token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\r\n        ISushiSwap pair =\r\n            ISushiSwap(\r\n                uint256(\r\n                    keccak256(abi.encodePacked(hex\"ff\", sushiSwapFactory, keccak256(abi.encodePacked(token0, token1)), pairCodeHash))\r\n                )\r\n            );\r\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        IERC20(fromToken).safeTransferFrom(msg.sender, address(this), amountIn);\r\n        if (toToken > fromToken) {\r\n            amountOut =\r\n                amountInWithFee.mul(reserve1) /\r\n                reserve0.mul(1000).add(amountInWithFee);\r\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\r\n            pair.swap(0, amountOut, to, \"\");\r\n        } else {\r\n            amountOut =\r\n                amountInWithFee.mul(reserve0) /\r\n                reserve1.mul(1000).add(amountInWithFee);\r\n            IERC20(fromToken).safeTransfer(address(pair), amountIn);\r\n            pair.swap(amountOut, 0, to, \"\");\r\n        }\r\n    }\r\n}"}}}