{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"EsusuStorage.sol":{"content":"pragma solidity 0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract EsusuStorage {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /*  Enum definitions */\r\n    enum CurrencyEnum{\r\n        Dai\r\n    }\r\n\r\n    enum CycleStateEnum{\r\n        Idle,               // Cycle has just been created and members can join in this state\r\n        Active,             // Cycle has started and members can take their ROI\r\n        Expired,            // Cycle Duration has elapsed and members can withdraw their capital as well as ROI\r\n        Inactive            // Total beneficiaries is equal to Total members, so all members have withdrawn their Capital and ROI\r\n    }\r\n\r\n    /*  Struct Definitions */\r\n    struct EsusuCycle{\r\n        uint256 CycleId;\r\n        uint256 GroupId;                   //  Group this Esusu Cycle belongs to\r\n        uint256 DepositAmount;\r\n        uint256 TotalMembers;\r\n        uint256 TotalBeneficiaries;        //  This is the total number of members that have withdrawn their ROI \r\n        uint256 PayoutIntervalSeconds;     //  Time each member receives overall ROI within one Esusu Cycle in seconds\r\n        uint256 TotalCycleDuration;        //  The total time it will take for all users to be paid which is (number of members * payout interval)\r\n        uint256 TotalAmountDeposited;      // Total  Dai Deposited\r\n        uint256 TotalCapitalWithdrawn;     // Total Capital In Dai Withdrawn\r\n        uint256 CycleStartTime;            //  Time, when the cycle starts has elapsed. Anyone can start cycle after this time has elapsed\r\n        uint256 TotalShares;               //  Total yDai Shares \r\n        uint256 MaxMembers;                //  Maximum number of members that can join this esusu cycle\r\n        uint256 TotalSharesAtStart;        //  Total shares at the start of the cycle, will use this to estimate the number of shares that belongs to each member\r\n        address Owner;                  //  This is the creator of the cycle who is also the creator of the group\r\n        CurrencyEnum Currency;          //  Currency supported in this Esusu Cycle \r\n        CycleStateEnum CycleState;      //  The current state of the Esusu Cycle\r\n\r\n    }\r\n    \r\n\r\n    struct MemberCycle{\r\n        uint256 CycleId;\r\n        address MemberId;\r\n        uint256 TotalAmountDepositedInCycle;\r\n        uint256 TotalPayoutReceivedInCycle;\r\n    }\r\n\r\n        /*  Model definition starts */\r\n\r\n    /* Model definition ends */\r\n\r\n    //  Member variables\r\n    address _owner;\r\n\r\n    uint256 EsusuCycleId;\r\n    \r\n    mapping(uint256 => EsusuCycle) EsusuCycleMapping;\r\n\r\n    mapping(address=>mapping(uint256 =>MemberCycle)) MemberAddressToMemberCycleMapping;\r\n\r\n    mapping(uint256=>mapping(address => uint256)) CycleToMemberPositionMapping;   //  This tracks position of the  member in an Esusu Cycle\r\n\r\n    mapping(uint256=>mapping(address => uint256)) CycleToBeneficiaryMapping;  // This tracks members that have received overall ROI and amount received within an Esusu Cycle\r\n\r\n    mapping(uint256=>mapping(address=> uint)) CycleToMemberWithdrawnCapitalMapping;    // This tracks members that have withdrawn their capital and the amount withdrawn\r\n\r\n    mapping(uint256=>uint256) GroupToCycleIndexMapping; //  This tracks the total number of cycles that belong to a group\r\n\r\n    mapping(uint256=>mapping(uint256=>uint256)) GroupToCycleIndexToCycleIDMapping; //  This maps the Group to the cycle index and then the cycle ID\r\n\r\n    mapping(address=>uint256) OwnerToCycleIndexMapping; //  This tracks the number of cycles by index created by an owner\r\n\r\n    mapping(address=>mapping(uint256 => uint256)) OwnerToCycleIndexToCycleIDMapping; //  This maps the owner to the cycle index and then to the cycle ID\r\n\r\n    mapping(address=>uint256) MemberToCycleIndexMapping; //  This tracks the number of cycles by index created by a member\r\n\r\n    mapping(address=>mapping(uint256=>uint256)) MemberToCycleIndexToCycleIDMapping; //  This maps the member to the cycle index and then to the cycle ID\r\n\r\n    mapping(address=>uint256) MemberToXendTokenRewardMapping;  //  This tracks the total amount of xend token rewards a member has received\r\n\r\n    uint256 TotalDeposits; //  This holds all the dai amounts users have deposited in this contract\r\n\r\n\r\n    address  _adapterContract;\r\n    address _adapterDelegateContract;\r\n\r\n    EsusuCycle [] EsusuCycles;  //  This holds the array of all EsusuCycles\r\n\r\n    constructor () public {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function UpdateAdapterAndAdapterDelegateAddresses(address adapterContract, address adapterDelegateContract) onlyOwner external {\r\n            _adapterContract = adapterContract;\r\n            _adapterDelegateContract = adapterDelegateContract;\r\n    }\r\n\r\n    function GetEsusuCycleId() external view returns (uint){\r\n        return EsusuCycleId;\r\n    }\r\n\r\n    function IncrementEsusuCycleId() external onlyOwnerAdapterAndAdapterDelegateContract {\r\n        EsusuCycleId += 1;\r\n    }\r\n    \r\n    function CreateEsusuCycleMapping(uint256 groupId, uint256 depositAmount, uint256 payoutIntervalSeconds,uint256 startTimeInSeconds, address owner, uint256 maxMembers) external onlyOwnerAdapterAndAdapterDelegateContract {\r\n        \r\n        EsusuCycleId += 1;\r\n        EsusuCycle storage cycle = EsusuCycleMapping[EsusuCycleId];\r\n\r\n        cycle.CycleId = EsusuCycleId;\r\n        cycle.DepositAmount = depositAmount;\r\n        cycle.PayoutIntervalSeconds = payoutIntervalSeconds;\r\n        cycle.Currency = CurrencyEnum.Dai;\r\n        cycle.CycleState = CycleStateEnum.Idle;\r\n        cycle.Owner = owner;\r\n        cycle.MaxMembers = maxMembers;\r\n\r\n\r\n        //  Set the Cycle start time\r\n        cycle.CycleStartTime = startTimeInSeconds;\r\n\r\n         //  Assign groupId\r\n        cycle.GroupId = groupId;\r\n        GroupToCycleIndexMapping[groupId] = GroupToCycleIndexMapping[groupId].add(1); //  Increase the cycle index in the group by 1\r\n\r\n        uint256 cycleIndex = GroupToCycleIndexMapping[groupId];\r\n        mapping(uint256=>uint256) storage cylceIndexToCycleId = GroupToCycleIndexToCycleIDMapping[groupId];\r\n        cylceIndexToCycleId[cycleIndex] = EsusuCycleId;\r\n\r\n        // Increase the number of cycles created by the owner\r\n        OwnerToCycleIndexMapping[owner] = OwnerToCycleIndexMapping[owner].add(1);\r\n\r\n        uint256 ownerCreatedCycleIndex = OwnerToCycleIndexMapping[owner];\r\n        mapping(uint256=>uint256) storage ownerCreatedCylceIndexToCycleId = OwnerToCycleIndexToCycleIDMapping[owner];\r\n        ownerCreatedCylceIndexToCycleId[ownerCreatedCycleIndex] = EsusuCycleId;\r\n\r\n        //  Push created cycle into array\r\n        EsusuCycles.push(cycle);\r\n    }\r\n\r\n    function GetEsusuCycle(uint esusuCycleId) external view returns(uint CycleId, uint DepositAmount,\r\n                                                            uint PayoutIntervalSeconds, uint CycleState,\r\n                                                            uint TotalMembers, uint TotalAmountDeposited, uint TotalShares,\r\n                                                            uint TotalCycleDurationInSeconds, uint TotalCapitalWithdrawn, uint CycleStartTimeInSeconds,\r\n                                                            uint TotalBeneficiaries, uint MaxMembers){\r\n\r\n        require(esusuCycleId > 0 && esusuCycleId <= EsusuCycleId, \"Cycle ID must be within valid EsusuCycleId range\");\r\n\r\n        EsusuCycle memory cycle = EsusuCycleMapping[esusuCycleId];\r\n\r\n        return (cycle.CycleId, cycle.DepositAmount,  cycle.PayoutIntervalSeconds,\r\n                uint256(cycle.CycleState),\r\n                cycle.TotalMembers, cycle.TotalAmountDeposited, cycle.TotalShares,\r\n                cycle.TotalCycleDuration, cycle.TotalCapitalWithdrawn, cycle.CycleStartTime,\r\n                cycle.TotalBeneficiaries, cycle.MaxMembers);        \r\n    }\r\n\r\n\r\n\r\n    function GetCycleIndexFromGroupId(uint groupId) external view returns(uint){\r\n\r\n        return GroupToCycleIndexMapping[groupId];\r\n    }\r\n\r\n    function GetCycleIdFromCycleIndexAndGroupId(uint groupId, uint cycleIndex) external view returns(uint){\r\n\r\n      mapping(uint=>uint) storage cylceIndexToCycleId = GroupToCycleIndexToCycleIDMapping[groupId];\r\n\r\n      return cylceIndexToCycleId[cycleIndex];\r\n    }\r\n\r\n    function GetCycleIndexFromCycleCreator(address cycleCreator) external view returns(uint){\r\n\r\n        return OwnerToCycleIndexMapping[cycleCreator];\r\n    }\r\n\r\n    function GetCycleIdFromCycleIndexAndCycleCreator(uint cycleIndex, address cycleCreator) external view returns(uint){\r\n\r\n      mapping(uint=>uint) storage ownerCreatedCylceIndexToCycleId = OwnerToCycleIndexToCycleIDMapping[cycleCreator];\r\n\r\n      return ownerCreatedCylceIndexToCycleId[cycleIndex];\r\n    }\r\n\r\n    function GetCycleIndexFromCycleMember(address member) external view returns(uint){\r\n\r\n        return MemberToCycleIndexMapping[member];\r\n    }\r\n\r\n    function GetCycleIdFromCycleIndexAndCycleMember(uint cycleIndex, address member) external view returns(uint){\r\n\r\n      mapping(uint=>uint) storage memberCreatedCylceIndexToCycleId = MemberToCycleIndexToCycleIDMapping[member];\r\n\r\n      return memberCreatedCylceIndexToCycleId[cycleIndex];\r\n    }\r\n\r\n\r\n\r\n    function GetEsusuCycleBasicInformation(uint esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint CycleId, uint DepositAmount, uint CycleState,uint TotalMembers,uint MaxMembers, uint PayoutIntervalSeconds, uint GroupId){\r\n\r\n        EsusuCycle memory cycle = EsusuCycleMapping[esusuCycleId];\r\n\r\n        return (cycle.CycleId, cycle.DepositAmount,\r\n                uint256(cycle.CycleState),\r\n                cycle.TotalMembers, cycle.MaxMembers, cycle.PayoutIntervalSeconds, cycle.GroupId);\r\n        \r\n    } \r\n    \r\n    \r\n    function GetEsusuCycleTotalShares(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 TotalShares){\r\n                        \r\n        return (EsusuCycleMapping[esusuCycleId].TotalShares);\r\n    }                                                        \r\n\r\n    function GetEsusuCycleStartTime(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 EsusuCycleStartTime){\r\n                         \r\n        return (EsusuCycleMapping[esusuCycleId].CycleStartTime);      \r\n    }\r\n    \r\n    \r\n    function GetEsusuCyclePayoutInterval(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 EsusuCyclePayoutInterval){\r\n                         \r\n        return (EsusuCycleMapping[esusuCycleId].PayoutIntervalSeconds);      \r\n    }\r\n    \r\n    function GetEsusuCycleTotalAmountDeposited(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 EsusuCycleTotalAmountDeposited){\r\n                        \r\n        return (EsusuCycleMapping[esusuCycleId].TotalAmountDeposited);      \r\n    }\r\n    \r\n    function GetCycleOwner(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(address EsusuCycleOwner){\r\n                        \r\n        return (EsusuCycleMapping[esusuCycleId].Owner);\r\n        \r\n    }\r\n    \r\n    function GetEsusuCycleDuration(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 EsusuCycleDuration){\r\n        \r\n        return (EsusuCycleMapping[esusuCycleId].TotalCycleDuration);    \r\n    }\r\n    \r\n    function GetEsusuCycleTotalCapitalWithdrawn(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 EsusuCycleTotalCapitalWithdrawn){\r\n                        \r\n        return (EsusuCycleMapping[esusuCycleId].TotalCapitalWithdrawn);       \r\n    }\r\n    function GetEsusuCycleTotalBeneficiaries(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 EsusuCycleTotalBeneficiaries){\r\n                        \r\n        return (EsusuCycleMapping[esusuCycleId].TotalBeneficiaries);       \r\n    }\r\n    function GetMemberWithdrawnCapitalInEsusuCycle(uint256 esusuCycleId,address memberAddress) external view returns (uint) {\r\n                        \r\n        return CycleToMemberWithdrawnCapitalMapping[esusuCycleId][memberAddress];\r\n    }\r\n    \r\n    function GetMemberCycleToBeneficiaryMapping(uint256 esusuCycleId,address memberAddress) external view returns(uint){\r\n        \r\n        return CycleToBeneficiaryMapping[esusuCycleId][memberAddress];\r\n    }\r\n    \r\n    function GetTotalMembersInCycle(uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 TotalMembers){\r\n                         \r\n        return (EsusuCycleMapping[esusuCycleId].TotalMembers);      \r\n    }\r\n\r\n    function IsMemberInCycle(address memberAddress,uint256 esusuCycleId ) external view returns(bool){\r\n        return MemberAddressToMemberCycleMapping[memberAddress][esusuCycleId].CycleId > 0;\r\n    }\r\n    \r\n    function IncreaseTotalAmountDepositedInCycle(uint256 esusuCycleId, uint256 amount) isCycleIdValid(esusuCycleId) external onlyOwnerAdapterAndAdapterDelegateContract returns (uint){\r\n    \r\n        EsusuCycle storage cycle = EsusuCycleMapping[EsusuCycleId];\r\n\r\n        uint256 amountDeposited = cycle.TotalAmountDeposited.add(amount);\r\n\r\n        cycle.TotalAmountDeposited =  amountDeposited;\r\n\r\n        //  Update cycle in the array\r\n        EsusuCycle storage esusuCycle = EsusuCycles[EsusuCycleId - 1];\r\n        esusuCycle.TotalAmountDeposited =  amountDeposited;\r\n\r\n        \r\n        return amountDeposited;\r\n    }\r\n    \r\n    function CreateMemberAddressToMemberCycleMapping(address member,uint256 esusuCycleId ) isCycleIdValid(esusuCycleId) external onlyOwnerAdapterAndAdapterDelegateContract{\r\n        \r\n        //  Increment the total deposited amount for the member cycle struct\r\n        mapping(uint=>MemberCycle) storage memberCycleMapping =  MemberAddressToMemberCycleMapping[member];\r\n        \r\n        memberCycleMapping[esusuCycleId].CycleId = esusuCycleId;\r\n        memberCycleMapping[esusuCycleId].MemberId = member;\r\n        memberCycleMapping[esusuCycleId].TotalAmountDepositedInCycle = memberCycleMapping[esusuCycleId].TotalAmountDepositedInCycle.add( EsusuCycleMapping[esusuCycleId].DepositAmount);        \r\n    }\r\n    \r\n\r\n    \r\n    function GetEsusuCycleTotalSharesAtStart(uint esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint TotalSharesAtStart){\r\n\r\n\r\n        EsusuCycle memory cycle = EsusuCycleMapping[esusuCycleId];\r\n\r\n        return (cycle.TotalSharesAtStart);\r\n    }\r\n\r\n\r\n    function IncreaseTotalMembersInCycle(uint esusuCycleId) isCycleIdValid(esusuCycleId) external onlyOwnerAdapterAndAdapterDelegateContract{\r\n        //  Increase TotalMembers count by 1\r\n\r\n        EsusuCycleMapping[esusuCycleId].TotalMembers +=1;\r\n       \r\n        //  Update cycle in the array\r\n        EsusuCycle storage esusuCycle = EsusuCycles[EsusuCycleId - 1];\r\n        esusuCycle.TotalMembers = EsusuCycleMapping[esusuCycleId].TotalMembers;\r\n    }    \r\n    function CreateMemberPositionMapping(uint256 esusuCycleId, address member) isCycleIdValid(esusuCycleId) onlyOwnerAdapterAndAdapterDelegateContract external{\r\n        \r\n        mapping(address=>uint) storage memberPositionMapping =  CycleToMemberPositionMapping[esusuCycleId];\r\n\r\n        //  Assign Position to Member In this Cycle\r\n        memberPositionMapping[member] = EsusuCycleMapping[esusuCycleId].TotalMembers;\r\n    }    \r\n    function IncreaseTotalDeposits(uint256 esusuCycleBalance) external onlyOwnerAdapterAndAdapterDelegateContract {\r\n        \r\n        TotalDeposits = TotalDeposits.add(esusuCycleBalance);\r\n\r\n    }\r\n    \r\n    function UpdateEsusuCycleDuringStart(uint256 esusuCycleId,uint256 cycleStateEnum, uint256 toalCycleDuration, uint256 totalShares,uint256 currentTime) external onlyOwnerAdapterAndAdapterDelegateContract{\r\n       \r\n        EsusuCycle storage cycle = EsusuCycleMapping[esusuCycleId];\r\n\r\n        cycle.TotalCycleDuration = toalCycleDuration;\r\n        cycle.CycleState = CycleStateEnum(cycleStateEnum); \r\n        cycle.TotalShares = totalShares;\r\n        cycle.CycleStartTime = currentTime;\r\n        cycle.TotalSharesAtStart = totalShares;\r\n\r\n        //  Update cycle in the array\r\n        EsusuCycle storage esusuCycle = EsusuCycles[esusuCycleId - 1];\r\n        esusuCycle.TotalCycleDuration = toalCycleDuration;\r\n        esusuCycle.CycleState = CycleStateEnum(cycleStateEnum);\r\n        esusuCycle.TotalShares = totalShares;\r\n        esusuCycle.CycleStartTime = currentTime;\r\n        esusuCycle.TotalSharesAtStart = totalShares;\r\n\r\n    }\r\n    \r\n    function UpdateEsusuCycleState(uint256 esusuCycleId,uint256 cycleStateEnum) external onlyOwnerAdapterAndAdapterDelegateContract{\r\n       \r\n        EsusuCycleMapping[esusuCycleId].CycleState = CycleStateEnum(cycleStateEnum); \r\n        \r\n        //  Update cycle in the array\r\n        EsusuCycle storage esusuCycle = EsusuCycles[esusuCycleId - 1];\r\n        esusuCycle.TotalShares = EsusuCycleMapping[esusuCycleId].TotalShares;\r\n    }\r\n    function GetMemberCycleInfo(address memberAddress, uint256 esusuCycleId) isCycleIdValid(esusuCycleId) external view returns(uint256 CycleId, address MemberId, uint256 TotalAmountDepositedInCycle, uint256 TotalPayoutReceivedInCycle, uint256 memberPosition){\r\n                \r\n        mapping(uint=>MemberCycle) storage memberCycleMapping =  MemberAddressToMemberCycleMapping[memberAddress];\r\n\r\n        mapping(address=>uint) storage memberPositionMapping =  CycleToMemberPositionMapping[esusuCycleId];        \r\n        //  Get Number(Position) of Member In this Cycle\r\n        return  (memberCycleMapping[esusuCycleId].CycleId,memberCycleMapping[esusuCycleId].MemberId,\r\n        memberCycleMapping[esusuCycleId].TotalAmountDepositedInCycle,\r\n        memberCycleMapping[esusuCycleId].TotalPayoutReceivedInCycle,memberPositionMapping[memberAddress]);\r\n    }\r\n    \r\n    function CreateMemberCapitalMapping(uint256 esusuCycleId, address member) external onlyOwnerAdapterAndAdapterDelegateContract {\r\n         \r\n        mapping(address=>uint) storage memberCapitalMapping =  CycleToMemberWithdrawnCapitalMapping[esusuCycleId];\r\n        memberCapitalMapping[member] = EsusuCycleMapping[esusuCycleId].DepositAmount;\r\n    }\r\n    \r\n    function UpdateEsusuCycleDuringCapitalWithdrawal(uint256 esusuCycleId, uint256 cycleTotalShares, uint256 totalCapitalWithdrawnInCycle) external onlyOwnerAdapterAndAdapterDelegateContract{\r\n        \r\n        EsusuCycleMapping[esusuCycleId].TotalCapitalWithdrawn = totalCapitalWithdrawnInCycle; \r\n        EsusuCycleMapping[esusuCycleId].TotalShares = cycleTotalShares;\r\n\r\n        //  Update cycle in the array\r\n        EsusuCycle storage esusuCycle = EsusuCycles[esusuCycleId - 1];\r\n        esusuCycle.TotalCapitalWithdrawn = totalCapitalWithdrawnInCycle;\r\n        esusuCycle.TotalShares = cycleTotalShares;\r\n    }\r\n    \r\n    function UpdateEsusuCycleDuringROIWithdrawal(uint256 esusuCycleId, uint256 totalShares, uint256 totalBeneficiaries) external onlyOwnerAdapterAndAdapterDelegateContract{\r\n        EsusuCycleMapping[esusuCycleId].TotalBeneficiaries = totalBeneficiaries; \r\n        EsusuCycleMapping[esusuCycleId].TotalShares = totalShares;  \r\n\r\n        //  Update cycle in the array\r\n        EsusuCycle storage esusuCycle = EsusuCycles[esusuCycleId - 1];\r\n        esusuCycle.TotalBeneficiaries = totalBeneficiaries;\r\n        esusuCycle.TotalShares = totalShares;      \r\n    }\r\n    \r\n    function CreateEsusuCycleToBeneficiaryMapping(uint256 esusuCycleId, address memberAddress, uint256 memberROINet) external onlyOwnerAdapterAndAdapterDelegateContract{\r\n        \r\n        mapping(address=>uint) storage beneficiaryMapping =  CycleToBeneficiaryMapping[esusuCycleId];\r\n\r\n        beneficiaryMapping[memberAddress] = memberROINet;\r\n    }\r\n\r\n    function CalculateMemberWithdrawalTime(uint256 cycleId, address member) external view returns(uint256 withdrawalTime){\r\n\r\n        mapping(address=>uint) storage memberPositionMapping = CycleToMemberPositionMapping[cycleId];\r\n\r\n        uint256 memberPosition = memberPositionMapping[member];\r\n\r\n        withdrawalTime = (EsusuCycleMapping[cycleId].CycleStartTime.add(memberPosition.mul(EsusuCycleMapping[cycleId].PayoutIntervalSeconds)));\r\n        return withdrawalTime;\r\n    }\r\n\r\n    function CreateMemberToCycleIndexToCycleIDMapping(address member, uint256 esusuCycleId) external onlyOwnerAdapterAndAdapterDelegateContract {\r\n      // Increase the number of cycles joined by the member\r\n      MemberToCycleIndexMapping[member] = MemberToCycleIndexMapping[member].add(1);\r\n\r\n      uint256 memberCreatedCycleIndex = MemberToCycleIndexMapping[member];\r\n      mapping(uint256=>uint256) storage memberCreatedCylceIndexToCycleId = MemberToCycleIndexToCycleIDMapping[member];\r\n      memberCreatedCylceIndexToCycleId[memberCreatedCycleIndex] = esusuCycleId;\r\n    }\r\n\r\n    function GetTotalDeposits() external view returns (uint256){\r\n        return TotalDeposits;\r\n    }\r\n\r\n    function GetEsusuCycleState(uint256 esusuCycleId) external view returns (uint256){\r\n        \r\n        return uint256(EsusuCycleMapping[esusuCycleId].CycleState);\r\n\r\n    }\r\n\r\n    function UpdateMemberToXendTokeRewardMapping(address member, uint256 rewardAmount) external onlyOwnerAdapterAndAdapterDelegateContract {\r\n        MemberToXendTokenRewardMapping[member] = MemberToXendTokenRewardMapping[member].add(rewardAmount);\r\n    }\r\n\r\n    function GetMemberXendTokenReward(address member) external view returns(uint256) {\r\n        return MemberToXendTokenRewardMapping[member];\r\n    }\r\n\r\n    //  Get the EsusuCycle Array\r\n    function GetEsusuCycles() external view returns (EsusuCycle [] memory){\r\n        return EsusuCycles;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Unauthorized access to contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerAdapterAndAdapterDelegateContract() {\r\n        require(\r\n            msg.sender == _owner || msg.sender == _adapterDelegateContract || msg.sender == _adapterContract,\r\n            \"Unauthorized access to contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isCycleIdValid(uint256 esusuCycleId) {\r\n\r\n        require(esusuCycleId != 0 && esusuCycleId <= EsusuCycleId, \"Cycle ID must be within valid EsusuCycleId range\");\r\n        _;\r\n    }\r\n    \r\n\r\n\r\n\r\n        /**\r\n        NOTE: before now, we update the cycle during start but because of ForTube precision issue\r\n        we now update the cycle once a member joins the cycle. We also invest member's funds immediately they join so \r\n        as to increase the exchangeRateStored on ForTube. \r\n        This function will not be important on Yearn Finance on the ethereum blockchain\r\n     */\r\n    function UpdateEsusuCycleSharesDuringJoin(uint esusuCycleId, uint memberShares) external onlyOwnerAdapterAndAdapterDelegateContract{\r\n          \r\n        EsusuCycleMapping[esusuCycleId].TotalShares = EsusuCycleMapping[esusuCycleId].TotalShares.add(memberShares);\r\n        \r\n        //  Update cycle in the array\r\n        EsusuCycle storage esusuCycle = EsusuCycles[esusuCycleId - 1];\r\n        esusuCycle.TotalShares = EsusuCycleMapping[esusuCycleId].TotalShares;  \r\n    }\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"}}}