{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"UserWallet.sol":{"content":"pragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title RegistryInterface Interface \r\n */\r\ninterface RegistryInterface {\r\n    function logic(address logicAddr) external view returns (bool);\r\n    function record(address currentOwner, address nextOwner) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Address Registry Record\r\n */\r\ncontract AddressRecord {\r\n\r\n    /**\r\n     * @dev address registry of system, logic and wallet addresses\r\n     */\r\n    address public registry;\r\n\r\n    /**\r\n     * @dev Throws if the logic is not authorised\r\n     */\r\n    modifier logicAuth(address logicAddr) {\r\n        require(logicAddr != address(0), \"logic-proxy-address-required\");\r\n        require(RegistryInterface(registry).logic(logicAddr), \"logic-not-authorised\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title User Auth\r\n */\r\ncontract UserAuth is AddressRecord {\r\n\r\n    event LogSetOwner(address indexed owner);\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev Throws if not called by owner or contract itself\r\n     */\r\n    modifier auth {\r\n        require(isAuth(msg.sender), \"permission-denied\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets new owner\r\n     */\r\n    function setOwner(address nextOwner) public auth {\r\n        RegistryInterface(registry).record(owner, nextOwner);\r\n        owner = nextOwner;\r\n        emit LogSetOwner(nextOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev checks if called by owner or contract itself\r\n     * @param src is the address initiating the call\r\n     */\r\n    function isAuth(address src) public view returns (bool) {\r\n        if (src == owner) {\r\n            return true;\r\n        } else if (src == address(this)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev logging the execute events\r\n */\r\ncontract UserNote {\r\n    event LogNote(\r\n        bytes4 indexed sig,\r\n        address indexed guy,\r\n        bytes32 indexed foo,\r\n        bytes32 bar,\r\n        uint wad,\r\n        bytes fax\r\n    );\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n        emit LogNote(\r\n            msg.sig, \r\n            msg.sender, \r\n            foo, \r\n            bar, \r\n            msg.value,\r\n            msg.data\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title User Owned Contract Wallet\r\n */\r\ncontract UserWallet is UserAuth, UserNote {\r\n\r\n    event LogExecute(address target, uint srcNum, uint sessionNum);\r\n\r\n    /**\r\n     * @dev sets the \"address registry\", owner's last activity, owner's active period and initial owner\r\n     */\r\n    constructor() public {\r\n        registry = msg.sender;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    /**\r\n     * @dev Execute authorised calls via delegate call\r\n     * @param _target logic proxy address\r\n     * @param _data delegate call data\r\n     * @param _src to find the source\r\n     * @param _session to find the session\r\n     */\r\n    function execute(\r\n        address _target,\r\n        bytes memory _data,\r\n        uint _src,\r\n        uint _session\r\n    ) \r\n        public\r\n        payable\r\n        note\r\n        auth\r\n        logicAuth(_target)\r\n        returns (bytes memory response)\r\n    {\r\n        emit LogExecute(\r\n            _target,\r\n            _src,\r\n            _session\r\n        );\r\n        \r\n        // call contract in current context\r\n        assembly {\r\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\r\n            let size := returndatasize\r\n\r\n            response := mload(0x40)\r\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n            mstore(response, size)\r\n            returndatacopy(add(response, 0x20), 0, size)\r\n\r\n            switch iszero(succeeded)\r\n                case 1 {\r\n                    // throw if delegatecall failed\r\n                    revert(add(response, 0x20), size)\r\n                }\r\n        }\r\n    }\r\n\r\n}"}}}