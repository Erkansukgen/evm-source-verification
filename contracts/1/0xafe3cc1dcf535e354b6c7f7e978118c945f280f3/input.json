{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/CryptographFactoryProxiedV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./CryptographFactoryV1.sol\";\n\n/// @author Guillaume Gonnaud 2019\n/// @title  Cryptograph Factory Proxy Smart Contract\n/// @notice The proxied Factory : this is this contract that will be instancied on the blockchain. Cast this as the logic contract to interact with it.\ncontract CryptographFactoryProxiedV1 is VCProxy, CryptographFactoryHeaderV1, CryptographFactoryStorageInternalV1  {\n\n    constructor(uint256 _version, address _vc)  public\n    VCProxy(_version, _vc) //Call the VC proxy constructor so that we know where our logic code is\n    {\n        //Self intialize (nothing)\n    }\n\n    //No other logic code as it is all proxied\n\n}\n\n\n\n"},"browser/CryptographFactoryV1.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Factory Header\n/// @notice Contain all the events emitted by the factory\ncontract CryptographFactoryHeaderV1 {\n    event CryptographCreated(uint256 indexed cryptographIssue, address indexed cryptographAddress, bool indexed official);\n    event CryptographEditionAdded(uint256 indexed cryptographIssue, uint256 indexed editionSize, bool indexed official);\n    event CryptographEditionMinted(uint256 indexed cryptographIssue, uint256 indexed editionIssue, address cryptographAddress, bool indexed official);\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Factory Storage Internal\n/// @notice Contain all the storage of the Factory declared in a way that does not generate getters for Proxy use\ncontract CryptographFactoryStorageInternalV1 {\n\n    bool internal initialized; //A bool controlling if we have been initialized or not\n\n    address internal officialPublisher; //The address that is allowed to publish the official (i.e. non-community) cryptographs\n\n    /*\n    ==================================================\n                    Linking section\n    ==================================================\n    Those are the addresses of other smart contracts in the ecosystem and relevant value to them\n    */\n    address internal targetVC; //Address of the version control that the Cryptograph should use (potentially different than ours)\n    address internal targetAuctionHouse; //Address of the Auction house used by Cryptograph\n    address internal targetIndex; //Address of the Cryptograph library storing both fan made and public cryptographs\n\n    // DO NOT PUT THE CRYPTOGRAPH PROXY CODE ADDRESS IN HERE, it needs to be in the logic code of the factory\n    // IDEM FOR SINGLE AUCTION PROXY CODE\n    uint256 internal targetCryLogicVersion; //Which version of the logic code in the Version Control array the cryptographs should use\n    //Which version of the logic code in the Version Control array the Single Auction should use\n    uint256 internal targetAuctionLogicVersion;\n    //Which version of the logic code in the Version Control array the Single Auction Bid should use\n    uint256 internal targetAuctionBidLogicVersion;\n    //Which version of the logic code in the Version Control array the Minting Auction should use\n    uint256 internal targetMintingAuctionLogicVersion;\n\n    //Actual data storage section\n    mapping (address => uint256) internal mintingAuctionSupply; //How much token can be created by each MintingAuction\n\n    //Are Community cryptographs allowed to be minted ?\n    bool internal communityMintable;\n\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Factory Storage Public\n/// @notice Contain all the storage of the Factory declared in a way that generates getters for Logic use\ncontract CryptographFactoryStoragePublicV1 {\n\n    bool public initialized; //A bool controlling if we have been initialized or not\n\n    address public officialPublisher; //The address that is allowed to publish the non-community cryptographs\n\n    /*\n    ==================================================\n                    Linking section\n    ==================================================\n    Those are the addresses of other smart contracts in the ecosystem and the relevant Version Control index value to them\n    */\n    address public targetVC; //Address of the version control the cryptographs should use\n    address public targetAuctionHouse; //Address of the Auction house used by cryptograph\n    address public targetIndex; //Address of the Cryptograph library storing both fan made and public cryptographs\n\n    uint256 public targetCryLogicVersion; //Which version of the logic code in the Version Control array the cryptographs should use\n    uint256 public targetAuctionLogicVersion; //Which version of the logic code in the Version Control array the Single Auction should use\n    //Which version of the logic code in the Version Control array the Single Auction Bid should use\n    uint256 public targetAuctionBidLogicVersion;\n    //Which version of the logic code in the Version Control array the Minting Auction should use\n    uint256 public targetMintingAuctionLogicVersion;\n\n    //Actual data storage section\n    mapping (address => uint256) public mintingAuctionSupply; //How much token can be created by each MintingAuction\n\n    //Are Community cryptographs allowed to be minted ?\n    bool public communityMintable;\n}"},"browser/VCProxy.sol":{"content":"// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/* Based on a variation of https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201\nThis generic proxy is gonna ask a version control smart contract for its logic code instead\nof storing the remote address himself\n*/\n\n/*\nSmart contract only containing a public array named the same as VC so that the compiler call the proper\nfunction signature in our generic proxy\n*/\ncontract VersionControlStoragePublic {\n    address[] public code;\n}\n\n\n/*\nStorage stack of a proxy contract. VCproxy inherit this, as well as ALL logic contracts associated to a proxy for storage alignment reasons.\n*/\ncontract VCProxyData {\n    address internal vc; //Version Control Smart Contract Address\n    uint256 internal version; //The index of our logic code in the Version Control array.\n}\n\n\n/*\nLogic of a proxy contract. EVERY proxied contract inherit this\n*/\ncontract VCProxy is VCProxyData {\n    constructor(uint256 _version, address _vc) public {\n        version = _version;\n        vc = _vc;\n    }\n\n    fallback () virtual external payable {\n\n        address addr = VersionControlStoragePublic(vc).code(version);\n        assembly {\n            let freememstart := mload(0x40)\n            calldatacopy(freememstart, 0, calldatasize())\n            let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 0)\n            returndatacopy(freememstart, 0, returndatasize())\n            switch success\n            case 0 { revert(freememstart, returndatasize()) }\n            default { return(freememstart, returndatasize()) }\n        }\n    }\n\n    \n    /// @notice Generic catch-all function that refuse payments to prevent accidental Eth burn.\n    receive() virtual external payable{\n       require(false, \"Do not send me Eth without a reason\");\n    }\n}"}}}