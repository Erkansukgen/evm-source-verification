{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"f6.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface NFTContract {\n    function ownerOf(uint256 _tokenId) external view returns (address);\n}\n\ncontract F {\n\n    address internal constant owner = 0x936172478607F372490ffBB5421557aDf187995d;\n\n    // f07928801842988498(address,uint256,uint256,address,uint256,address,bytes) 0x100205f6\n    function f07928801842988498(address _nftAddress, uint256 _tokenId, uint256 _tokenPrice, address _seller, uint256 _sellerBalance, address payable _forwardTo, bytes calldata _forwardData) external payable returns (bool success, bytes memory message) {\n\n        require(msg.sender == owner);\n\n        if (_tokenPrice != 0) {\n\n            require(_seller.balance == _sellerBalance, 'check1');\n\n        } else {\n\n            require(NFTContract(_nftAddress).ownerOf(_tokenId) == _seller, 'check2');\n\n        }\n\n        return _forwardTo.call{value: msg.value}(_forwardData);\n\n    }\n\n    function withdraw() external {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    // simple commandeering for arbitrary functions\n    function forward(uint256 _val, address payable _forwardTo, bytes calldata _forwardData) external payable returns (bool success, bytes memory message) {\n        require(msg.sender == owner);\n        return _forwardTo.call{value: _val}(_forwardData);\n    }\n\n}\n\n// mainnet / owner 0x936172478607F372490ffBB5421557aDf187995d (8004)"}}}