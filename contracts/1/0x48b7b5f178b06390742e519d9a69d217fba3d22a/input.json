{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/keeperdao.sol": {
      "content": "pragma solidity 0.5.17;\n\ninterface LiquidityPool {\n    function borrow(\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n\ncontract KeeperDAO {\n    address constant borrowProxy = 0x82151CA501c81108d032C490E25f804787BEF3b8;\n    address payable constant liquidityPool = 0x4C8cC29226F97d92eC2D299bC14EDF16bAD436b7;\n\n    address constant eee = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    // PAYOUT:\n    // https://indibo-keeper.herokuapp.com/reward_of_keeper/0x96999d1f2c6deb401d2aa87e0d51c66d00c79580\n    // payout https://etherscan.io/address/0xF55A73a366F1F9F03CEf4cc10D3cD21e5c6A9026#writeContract\n    \n    // DAI 0x6b175474e89094c44da98b954eedeac495271d0f\n    // 100 100000000000000000000\n    \n    // USDC 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\n    // 100 100000000\n    \n    // WETH 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n    // .25 250000000000000000\n    \n    // RENBTC 0xeb4c2781e4eba804ce9a9803c67d0893436bb27d\n    // .01 1000000\n    \n    // token 0xfa5047c9c78b8877af97bdcb85db743fd7313d4a\n    // uniswap \n    \n    modifier onlyBorrowProxy {\n        if (msg.sender == borrowProxy) {\n            _;\n        }\n    }\n    \n    function donanteTokensToDAO(address _token, uint256 _amountToBorrow, uint256 _amountToReturn)\n        external\n        payable\n        onlyOwner\n    {\n        LiquidityPool(liquidityPool).borrow(\n            _token,\n            _amountToBorrow,\n            abi.encodeWithSelector(\n                this.LPCallback.selector,\n                _token,\n                _amountToBorrow,\n                _amountToReturn\n            )\n        );\n    }\n\n    function LPCallback(\n        address token,\n        uint256 _amountBorrowed,\n        uint256 _amountToReturn\n    ) external onlyBorrowProxy {\n        if(token == eee){\n            liquidityPool.call.value(_amountToReturn)(\"\");\n        }else{\n            Token(token).transferFrom(owner, address(this), _amountToReturn);\n            Token(token).transfer(liquidityPool, _amountToReturn);\n        }\n    }\n    \n    address payable owner;\n\n    modifier onlyOwner {\n        if (msg.sender == owner) {\n            _;\n        }\n    }\n    \n    function() external payable {}\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    function setOwner(address payable _newOwner) external onlyOwner {\n        owner = _newOwner;\n    }\n    \n    function withdrawToken(address token, uint256 amount) public onlyOwner {\n        Token(token).transfer(owner, amount);\n    }\n    \n    function withdrawEther(uint256 amount) public onlyOwner {\n        require(\n            owner.send(amount),\n            \"Sending of ETH failed.\"\n        );\n    }\n}\n\n\n\ncontract Token {\n    /** @return total amount of tokens\n        */\n    function totalSupply() view public returns (uint256 supply) {}\n\n    /** @param _owner The address from which the balance will be retrieved\n        * @return The balance\n        */\n    function balanceOf(address _owner) view public returns (uint256 balance) {}\n\n    /** @notice send `_value` token to `_to` from `msg.sender`\n        * @param  _to     The address of the recipient\n        * @param  _value  The amount of tokens to be transferred\n        * @return Whether the transfer was successful or not\n        */\n    function transfer(address _to, uint256 _value) public {}\n\n    /** @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n        * @param  _from   The address of the sender\n        * @param  _to     The address of the recipient\n        * @param  _value  The amount of tokens to be transferred\n        * @return Whether the transfer was successful or not\n        */\n    function transferFrom(address _from, address _to, uint256 _value) public {}\n\n    /** @notice `msg.sender` approves `_addr` to spend `_value` tokens\n        * @param  _spender The address of the account able to transfer the tokens\n        * @param  _value   The amount of wei to be approved for transfer\n        * @return Whether the approval was successful or not\n        */\n    function approve(address _spender, uint256 _value) public {}\n\n    /** @param  _owner   The address of the account owning tokens\n        * @param  _spender The address of the account able to transfer the tokens\n        * @return Amount of remaining tokens allowed to spend\n        */\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    uint public decimals;\n    string public name;\n}"
    }
  }
}