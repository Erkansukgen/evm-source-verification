{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/abc.sol":{"content":"//OK\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2020-06-05\r\n*/\r\n\r\n//https://etherscan.io/address/0x7a250d5630b4cf539739df2c5dacb4c659f2488d\r\n\r\n// pragma solidity = 0.7.0;\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary ECDSA {\r\n  \r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n        } else if (signature.length == 64) {\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                let vs := mload(add(signature, 0x40))\r\n                r := mload(add(signature, 0x20))\r\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\r\n                v := add(shr(255, vs), 27)\r\n            }\r\n        } else {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\ncontract UniswapV2Library {\r\n    // using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        uint hashvalue = uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            )));\r\n        pair = address(uint160(hashvalue));     //todo: test\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    // function quote(uint amountA, uint reserveA, uint reserveB) public pure returns (uint amountB) {\r\n    //     require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\r\n    //     require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n    //     amountB = amountA * (reserveB) / reserveA;\r\n    // }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn * (997);\r\n        uint numerator = amountInWithFee * (reserveOut);\r\n        uint denominator = reserveIn * (1000) + (amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    // function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure returns (uint amountIn) {\r\n    //     require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n    //     require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n    //     uint numerator = reserveIn * (amountOut) * (1000);\r\n    //     uint denominator = reserveOut.sub(amountOut) * (997);\r\n    //     amountIn = (numerator / denominator) + (1);\r\n    // }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // // performs chained getAmountIn calculations on any number of pairs\r\n    // function getAmountsIn(address factory, uint amountOut, address[] memory path) public view returns (uint[] memory amounts) {\r\n    //     require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n    //     amounts = new uint[](path.length);\r\n    //     amounts[amounts.length - 1] = amountOut;\r\n    //     for (uint i = path.length - 1; i > 0; i--) {\r\n    //         (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n    //         amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n    //     }\r\n    // }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\n// library TransferHelper {\r\ncontract TransferHelper is UniswapV2Library {\r\n    // function safeApprove(address token, address to, uint value) internal {\r\n    //     // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n    //     (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n    //     require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    // }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    // function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n    //     // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n    //     (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n    //     require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    // }\r\n\r\n    // function safeTransferETH(address to, uint value) internal {\r\n    //     (bool success,) = to.call{value:value}(new bytes(0));\r\n    //     require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    // }\r\n}\r\n\r\n//支付相关的接口\r\ninterface IPay\r\n{\r\n    // function deposit() payable external returns (bool);                             //存入eth，再转换成weth，变成this的weth\r\n    // function depositToken(address _token, uint _amount) external returns (bool); //不需要，直接转账就好，因为没做记录\r\n    // function withdraw(uint _amount) external returns (bool);                        //一般用不着，this上应该没有 eth \r\n    function withdrawToken(address _token) external returns (bool);   //这个需要，把所有的token，包括weth都提取出来 取eth 也要先转账\r\n}\r\n\r\ncontract UniswapBase is TransferHelper, IPay {\r\n  \r\n    address public SuperAdmin;                       //备用管理员\r\n\r\n    modifier onlySuperAdmin {\r\n        require(msg.sender == SuperAdmin, \"1\");\r\n        _;                     \r\n    }\r\n\r\n    function setSuperAdmin(address _newAddress) public  onlySuperAdmin {\r\n        require(_newAddress != address(0), \"2\");\r\n        SuperAdmin = _newAddress;\r\n    }\r\n\r\n    mapping(address => bool) public AdminList;      //admin 要使用群体，因为某个地址可能执行tx太多，堵塞了，例如gas太低，别人不打包，后续就无法执行！！！\r\n    modifier onlyAdmin {\r\n        require(AdminList[msg.sender] || msg.sender == SuperAdmin, \"3\");         //特殊情况下创始人可以执行 Owner 的权限\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address _admin, bool _ok)  external  onlyAdmin {\r\n       AdminList[_admin] = _ok;\r\n    }\r\n      \r\n    // 不需要，都是自己调用！ NO 如果合约有恶意代码，也是需要的\r\n    bool private unlocked = true;           //避免重入。有调用外部合约的时候，可以谨慎使用！\r\n    modifier lock() {\r\n        require(unlocked == true, '4');\r\n        unlocked = false;\r\n        _;\r\n        unlocked = true;\r\n    }\r\n\r\n    event OnWithdraw(address indexed _token, address indexed _user, uint _amount);\r\n\r\n    function withdrawToken(address _token) override external lock onlyAdmin returns (bool) {   \r\n        if (_token == address(0)) {                               //其实不需要单独出来，同样的处理应该可以\r\n            uint eb = address(this).balance;\r\n            require(eb > 0, \"5\");\r\n            payable(msg.sender).transfer(eb);\r\n            emit OnWithdraw(_token, msg.sender, eb);\r\n            return true;\r\n        }\r\n        \r\n        uint b = IERC20(_token).balanceOf(address(this));\r\n        require (b > 0, \"6\");\r\n        safeTransfer(_token, msg.sender, b);\r\n        emit OnWithdraw(_token, msg.sender, b);\r\n        return true;\r\n    }  \r\n    \r\n}\r\n\r\ninterface IUniswapV2Pair { \r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n\r\n//回调接口 要实现！\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\n//支持两种调用，通过官方route，以及我自己的\r\n\r\ncontract UniswapV2Caller1 is UniswapBase, IUniswapV2Callee {\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    //https://bscscan.com/address/0x05ff2b0db69458a0750badebc4f9e13add608c7f#code\r\n    //   address public  WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;  \r\n    // address public  factory = 0xBCfCcbde45cE874adCB698cC183deBcF17952812;\r\n\r\n    //https://rinkeby.etherscan.io/address/0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D#readContract\r\n    // address public  WETH = 0xc778417E063141139Fce010982780140Aa0cD5Ab;  //0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    // address public  factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n\r\n    //https://etherscan.io/address/0x7a250d5630b4cf539739df2c5dacb4c659f2488d#readContract\r\n    address constant public  WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address constant public  factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n\r\n    // constructor(address _superAdmin, address _factory, address _weth)  {\r\n    //     factory = _factory;\r\n    //     WETH = _weth;                               //https://rinkeby.etherscan.io/address/0x7a250d5630b4cf539739df2c5dacb4c659f2488d#readContract\r\n\r\n    constructor(address _superAdmin)  {\r\n        SuperAdmin = _superAdmin;\r\n        AdminList[msg.sender] = true;\r\n        SigCaller = msg.sender;\r\n    }    \r\n\r\n    function getBlcockNow() external view returns (uint _blockNumber, uint _blockTime) {\r\n        return (block.number,  block.timestamp);\r\n    }\r\n\r\n    //gas 开销一般是35万，这里写100万. gwei 是gasprice的价格 1gwei =  1e9\r\n    uint constant public  GasAmount = 1000 * 1e3;  \r\n    \r\n    function getGasFee(uint _gaspriceGwei) public pure returns (uint) {\r\n        // return tx.gasprice * GasAmount;        \r\n        return _gaspriceGwei * 1e9 * GasAmount;     //1 gwei = 1e9       \r\n    }\r\n    \r\n    //计算这条路径投入这些钱能够赚多少！ 不使用这个function 也可以计算，但没有blocknumber time  OK\r\n    //todo: 正式版本要改为 private 或者删除\r\n    function calWinAmount(uint amountIn,  address[] calldata path) \r\n        external  view  returns (uint _amountOut, uint _blockNumber, uint _blockTime)\r\n    {\r\n        //有可能异常，所以调用此function需要try        \r\n        require(path.length >= 3 && path[0] == path[path.length - 1], \"7\");   // {     ////必须要形成闭环，才能无风险套利\r\n        uint[] memory amounts = getAmountsOut(amountIn, path);\r\n        _amountOut = amounts[amounts.length - 1];\r\n        return (_amountOut, block.number, block.timestamp);\r\n    }\r\n\r\n    address public SigCaller;           //签名者\r\n    // uint public TimeOut = 20;           //超时秒数，默认为20秒。以后根据实际情况调整。 只有这个时间段内能够使用！ 测试的时候可以搞大点\r\n    uint public TimeOut = 20000;           //todo: test\r\n    bool public ValidateSig = true;     //是否需要认证\r\n\r\n    function setCaller(address _caller, uint _timeout, bool _validateSig) external onlyAdmin {\r\n        SigCaller = _caller;\r\n        TimeOut = _timeout;\r\n        ValidateSig = _validateSig;\r\n    }\r\n\r\n    //OK todo 正式版本 要把 public 改回 private\r\n    function checkSig(bytes32 h, bytes memory sig) public view returns (bool) {\r\n    // function checkSig(bytes32 h, bytes memory sig) private view returns (bool) {\r\n        if (!ValidateSig) {\r\n            return true;\r\n        }\r\n\r\n        address caller = ECDSA.recover(h, sig);\r\n        require(caller == SigCaller, \"C1\");                     //必须指定账号签名\r\n\r\n        uint Time = uint(h);                                    // 传当前时间值\r\n        // require(Time <= block.timestamp, \"C2\");                 //1, 过期就无法使用了  这个条件不要，更方便！\r\n        require(block.timestamp <= Time + TimeOut, \"C3\");       //2, 过期就无法使用了\r\n\r\n        return true;\r\n    }\r\n\r\n    //不用输入金额，自动计算最佳金额，避免多次调用rpc，这点对于币安等不能架节点的来说特别好。 _gaspriceGwei 取平均值的两倍就好\r\n    // amountAddMin 是可以获利的最低金额, 这个数据可以作为 winWithOutToken 的参数，如果是 0 表示没办法套利。\r\n    // 这种方式套利，三个交易对，每个交易对损失 0.3% 的手续费，总共 0.9% 的手续费，所以价差至少要达到 1% 才有机会。所以这种机会相当小！一天能做两三单就不错了！\r\n    function calWinMaxAmount(address[] calldata path, uint _gaspriceGwei, bytes32 h, bytes memory sig) \r\n        external  view  returns (uint amountAddMin, uint _amountIn, uint _amountOut, uint _blockNumber, uint _blockTime)\r\n    {\r\n        require(path.length >= 3 && path[0] == path[path.length - 1], \"7\");   // {     ////必须要形成闭环，才能无风险套利\r\n        require(checkSig(h, sig), \"C0\");\r\n\r\n        // uint EthFee = getGasFee(_gaspriceGwei);     //套利的最小盈利金额\r\n        //假设价格波动10%，已经非常非常大了，套利金额就是盈利金额 * 10 ， 如果能赚钱，则继续检查更高金额。\r\n        uint AmountIn0 =  getGasFee(_gaspriceGwei) * 10;\r\n        if (path[0] == WETH) {\r\n            // uint AmountIn0 =  EthFee * 10;\r\n        }\r\n        else {\r\n            address[] memory WethPath =  new address[](2);\r\n            WethPath[0] = WETH;\r\n            WethPath[1] = path[0];\r\n            uint[] memory wethamounts = getAmountsOut(AmountIn0, WethPath);\r\n            AmountIn0 = wethamounts[1];        //得到最小的套利输入金额\r\n        }\r\n        \r\n        //有可能异常，所以调用此function需要try        \r\n        uint[] memory amounts = getAmountsOut(AmountIn0, path);\r\n        uint AmountOut0 = amounts[amounts.length - 1];   //输出值，删除这个变量就不会变量定义超标.\r\n        if (AmountOut0 <= AmountIn0) {\r\n            //亏损, 不用继续了 如果价格剧烈波动，可能导致这个判断错误，例如波动了50%，而这里只有10%。 这个不用管，一百年遇到到一次。\r\n            return (0, AmountIn0, AmountOut0, block.number, block.timestamp);  \r\n        }\r\n\r\n        (_amountIn, _amountOut) = getMaxAmount(AmountIn0, AmountOut0, path);\r\n        return (AmountIn0 / 10, _amountIn, _amountOut,  block.number, block.timestamp);\r\n    }\r\n\r\n    //多次尝试，得到最佳数据 public for test    //OK\r\n    function getMaxAmount(uint AmountIn0, uint AmountOut0, address[] calldata path) public view returns (uint _AmountIn, uint _AmountOut) {\r\n    // function getMaxAmount(uint AmountIn0, uint AmountOut0, address[] calldata path) private view returns (uint _AmountIn, uint _AmountOut) {\r\n        require(AmountIn0 < AmountOut0, \"Y\");\r\n        uint AmountIn00 = AmountIn0;\r\n        uint AmountIn1 = AmountIn0;\r\n        uint AmountOut1 = AmountOut0;\r\n\r\n        do {\r\n            AmountIn0 = AmountIn1;\r\n            AmountOut0 = AmountOut1;\r\n\r\n            // todo: 这个可以做的更精确，或者动态. 当前值比初始值越大，增长越缓慢。暂不处理，不需要那么精细。\r\n\r\n            if (AmountIn00 * 100 < AmountIn0) {\r\n                AmountIn1 = AmountIn0 * 12 / 10;        //1.2倍，理论上最多损失10%\r\n            }\r\n            else if (AmountIn00 * 10 < AmountIn0) {\r\n                AmountIn1 = AmountIn0 * 3 / 2;          //1.5倍, 最多损失25%\r\n            }\r\n            else {\r\n                AmountIn1 = AmountIn0 * 2;              //2.0倍, 最多损失50%\r\n            }\r\n            \r\n            //有可能异常，所以调用此function需要try        \r\n            uint[] memory AS = getAmountsOut(AmountIn1, path);\r\n            AmountOut1 = AS[AS.length - 1];           \r\n        }   //执行直到输入盈利下降为止。\r\n        // while ((AmountIn1 < AmountOut1) && (AmountIn0 < AmountOut0) && (AmountOut1 - AmountIn1 > AmountOut0 - AmountIn0));\r\n        while ((AmountIn1 < AmountOut1) && (AmountIn0 < AmountOut0) && (AmountOut1 + AmountIn0 > AmountOut0 + AmountIn1));\r\n\r\n        return (AmountIn0, AmountOut0);         //取金额下降的前一组数据，可能不是最大的，但必然接近最大的。\r\n    }\r\n\r\n\r\n    // function calWinAmount2(uint amountIn,  address[] calldata path) \r\n        //     external  view  returns (uint[] memory amounts )\r\n        // {\r\n        //     //有可能异常，所以调用此function需要try        \r\n        //     require(path.length >= 3 && path[0] == path[path.length - 1], \"123\");   // {     ////必须要形成闭环，才能无风险套利\r\n        //     amounts = getAmountsOut(amountIn, path);\r\n        //     return amounts;\r\n        // }\r\n        \r\n        // function calWinAmount3(address[] calldata path) \r\n        //     external  pure  returns ( address[] memory NextPath)\r\n        // {\r\n        //     //有可能异常，所以调用此function需要try        \r\n        //     require(path.length >= 3 && path[0] == path[path.length - 1], \"123\");   // {     ////必须要形成闭环，才能无风险套利\r\n            \r\n        //     NextPath = new address[](path.length - 1);\r\n        //     for(uint i = 1; i < path.length; i++) {\r\n        //         NextPath[i - 1] = path[i];\r\n        //     }\r\n        // }\r\n    \r\n        // function calWinAmount4(uint amountIn,  address[] calldata path) \r\n        //     external  view  returns (uint[] memory NextAmounts )\r\n        // {\r\n        //     //有可能异常，所以调用此function需要try        \r\n        //     require(path.length >= 3 && path[0] == path[path.length - 1], \"123\");   // {     ////必须要形成闭环，才能无风险套利\r\n        //     uint[] memory amounts = getAmountsOut(amountIn, path);\r\n\r\n        //     NextAmounts =  new uint[](amounts.length - 1);\r\n        //     for(uint i = 1; i < amounts.length; i++) {\r\n        //         NextAmounts[i - 1] = amounts[i];\r\n        //     }        \r\n    // }\r\n\r\n    address[]   private WT_Path;         //4, 路径临时变量 A->B->C->A Token有4个，交易对有3个AB，BC，CA。\r\n    uint[]      private WT_Amounts;      //各个路径中的输出金额\r\n    uint        private Event_Id = 0;\r\n\r\n    event OnUniswapV2Call1(address sender, uint amount0,  uint amount1,   bytes data);\r\n    event OnUniswapV2Call2(address token,  uint amountIn, uint amountOut, uint eventId); \r\n\r\n    //回调接口，无资本套利 OK\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external override\r\n    {\r\n        //如果3个交易对（4个Token，重复一个），需要执行两次，\r\n        require(sender == address(this), \"8\");                                      //sender 是自己，Pair 的调用者（Router）\r\n        emit OnUniswapV2Call1(sender, amount0, amount1, data);\r\n\r\n        //下面第一步和第二步，可以替换成其他交易所调用，可以跨交易所套利。\r\n        \r\n        //1, 把借来的资金转账\r\n        address token2 = WT_Path[1];\r\n        require(IERC20(token2).balanceOf(address(this)) == WT_Amounts[1], \"9\");   //要有资金啊！\r\n        address pair2 = pairFor(factory, token2, WT_Path[2]);\r\n        // IERC20(token2).transfer(pair2,  WT_Amounts[1]);\r\n        safeTransfer(token2, pair2,  WT_Amounts[1]);\r\n\r\n        //2, 剩余的path，调用 _swap \r\n        address[] memory NextPath = new address[](WT_Path.length - 1);\r\n        for(uint i = 1; i < WT_Path.length; i++) {\r\n            NextPath[i - 1] = WT_Path[i];\r\n        }\r\n        uint[] memory NextAmounts =  new uint[](WT_Amounts.length - 1);\r\n        for(uint i = 1; i < WT_Amounts.length; i++) {\r\n            NextAmounts[i - 1] = WT_Amounts[i];\r\n        }\r\n        _swap(NextAmounts, NextPath, address(this));                             //no data\r\n        // _swap(NextAmounts, NextPath, tx.origin);                                    //直接把钱打到调用者那里！或许更安全 但是会出错！！！\r\n\r\n        //3, 把获得的token，需要的[WT_Amounts[0]]转给第一个pair，多余的[WT_Amounts[WT_Amounts.Length - 1] - WT_Amounts[0]]token就是套利的余额\r\n        address token1 = WT_Path[0];\r\n        address pair1 = pairFor(factory, WT_Path[0], WT_Path[1]);\r\n        // IERC20(token1).transfer(pair1,  WT_Amounts[0]);\r\n        safeTransfer(token1, pair1,  WT_Amounts[0]);\r\n\r\n        //4， 清理(释放空间) 和 事件 处理\r\n        Event_Id ++;\r\n        emit OnUniswapV2Call2(token1, WT_Amounts[0], WT_Amounts[WT_Amounts.length - 1], Event_Id);         //通过事件把消息打印出来 msg.sender 是Pair\r\n\r\n        delete WT_Path;\r\n        delete WT_Amounts;\r\n    }\r\n\r\n    event OnWithDrawToAdmin(address sender, uint amount);\r\n\r\n    //没钱套利，采用闪电贷， 配合回调 function uniswapV2Call  OK\r\n    function winWithOutToken(uint amountIn,  address[] calldata path, uint deadline, uint amountAddMin, bytes calldata data, bool isToMe)\r\n        // bytes32 h, bytes memory sig)     //不需要，有 onlyAdmin 限制\r\n        external  ensure(deadline) onlyAdmin lock\r\n    {\r\n        require(amountIn > 0, \"10\");\r\n        // require(checkSig(h, sig), \"C0\");\r\n        uint amountMinOut = amountIn + amountAddMin;\r\n        // require(amountMinOut >= amountIn, \"!\");                     //套利必须更大，只是大多少的问题。\r\n        _winWithOutToken(amountIn, path, amountMinOut, data);       //处理完毕后，资产在 this 上 data 是个自定义值\r\n\r\n        if (isToMe) {\r\n            address token1 = path[0];\r\n            uint TA  = IERC20(token1).balanceOf(address(this));\r\n            //转换为eth后提取到 管理员地址\r\n            if (token1 != WETH) {\r\n                address unipair = pairFor(factory, token1, WETH);\r\n                if (unipair != address(0)) {                //有这个交易对才处理，绝大多数情况下是有的。\r\n                    sellTokenForWEth(token1, TA, 1);            \r\n                }\r\n            }\r\n\r\n            TA  = IERC20(WETH).balanceOf(address(this));    //取完 weth\r\n            if (TA > 0) {\r\n                IWETH(WETH).withdraw(TA);\r\n            }            \r\n            TA = address(this).balance;\r\n            if (TA > 0) {\r\n                payable(msg.sender).transfer(TA);           //取完 eth\r\n            }\r\n            emit OnWithDrawToAdmin(msg.sender, TA);\r\n        }\r\n\r\n    }\r\n\r\n    // OK\r\n    function _winWithOutToken(uint amountIn, address[] calldata path, uint amountMinOut, bytes calldata data) private\r\n    {\r\n        require(data.length > 0, \"11\");                                                  //这样才能回调 uniswapV2Call , 也可以在合约中写死\r\n        require(path.length >= 4 && path[0] == path[path.length - 1], \"12\");             //必须要形成闭环，才能无风险套利\r\n\r\n        WT_Path = path;                                                                 //临时变量，保持path\r\n        WT_Amounts = getAmountsOut(amountIn, path);                                     //临时变量，保持path中的各个变换值\r\n\r\n        require(WT_Amounts[WT_Amounts.length - 1] >= amountMinOut, \"13\") ;              //必须能够赚钱，超过 amountMinOut 测试时候，amountMinOut 可以很小\r\n        \r\n        //处理第一个交易对，其他交易对在回调function中处理！\r\n        // WT_PairIndex = 1;\r\n        address[] memory FirstPair = new address[](2);\r\n        FirstPair[0] = path[0];\r\n        FirstPair[1] = path[1];\r\n\r\n        uint[] memory FirstAmount = new uint[](2);\r\n        FirstAmount[0] = WT_Amounts[0];\r\n        FirstAmount[1] = WT_Amounts[1];\r\n\r\n        //调用前，不需要转钱！！！会执行回调uniswapV2Call // if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n        _swapWithOutToken(FirstAmount, FirstPair, address(this), data);\r\n    }\r\n     \r\n    //闪电贷, 可以不用for循环，只有一对 OK\r\n    function _swapWithOutToken(uint[] memory amounts, address[] memory path, address _to, bytes calldata data) internal {\r\n        require(data.length > 0, \"14\");\r\n        for (uint i = 0; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? pairFor(factory, output, path[i + 2]) : _to;\r\n            IUniswapV2Pair(pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, data);\r\n        }\r\n    }\r\n\r\n    // **** SWAP **** OK\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\r\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\r\n                amount0Out, amount1Out, to, new bytes(0)\r\n            );\r\n        }\r\n    }\r\n  \r\n    function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)\r\n    {\r\n        return getAmountsOut(factory, amountIn, path);\r\n    }\r\n\r\n    // 把其他币换算成 weth OK \r\n    function sellTokenForWEth(address _inToken, uint _inTokenAmount, uint _outEthMinAmount) internal returns (uint) {\r\n        //1，处理token的转移\r\n        // transferToken(_inToken, _inTokenAmount);\r\n        // uint allo = IERC20(_inToken).allowance(address(this), UniswapV2Router02);\r\n        // if (allo < _inTokenAmount) {\r\n        //     IERC20(_inToken).approve(UniswapV2Router02, type(uint).max);\r\n        // }\r\n\r\n        //2，执行交易\r\n        address[] memory path = new  address[] (2) ;\r\n        path[0] = _inToken;\r\n        path[1] = WETH;\r\n        // function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        // external returns (uint[] memory amounts);        \r\n        uint[] memory amounts = swapExactTokensForTokens(_inTokenAmount, _outEthMinAmount, path, address(this), block.timestamp + 60);\r\n        // return amounts[amounts.length - 1];\r\n        return amounts[1];        \r\n    }\r\n\r\n    // OK\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] memory path,\r\n        address to,\r\n        uint deadline\r\n    ) private ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\r\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        // TransferHelper.safeTransferFrom(\r\n        //     path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        // );\r\n        safeTransfer(\r\n            path[0], UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n  \r\n\r\n    receive() external payable {\r\n        // weth 转换成 eth， 没有会失败\r\n    }  \r\n\r\n  \r\n}\r\n"}}}