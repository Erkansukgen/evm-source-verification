{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LiquityTroveMaster.sol": {
      "content": "\r\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\n\r\n//remixd -s C:\\Users\\Ben\\PycharmProjects\\LiquityTroves --remix-ide https://remix.ethereum.org\r\npragma solidity 0.6.12;\r\n\r\nabstract contract IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() virtual external view returns (string memory);\r\n    function symbol() virtual external view returns (string memory);\r\n    function decimals() virtual external view returns (uint8);\r\n    function totalSupply() virtual external view returns (uint);\r\n    function balanceOf(address owner) virtual external view returns (uint);\r\n    function allowance(address owner, address spender) virtual external view returns (uint);\r\n\r\n    function approve(address spender, uint value) virtual external returns (bool);\r\n    function transfer(address to, uint value) virtual external returns (bool);\r\n    function transferFrom(address from, address to, uint value) virtual external returns (bool);\r\n}\r\n\r\n\r\nabstract contract ITroveManager\r\n{\r\n    function liquidateTroves(uint _n) virtual external;\r\n}\r\n\r\nabstract contract IBancorNetwork {\r\n\r\n    // deprecated, backward compatibility\r\n    function convertFor(\r\n        IERC20[] memory _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) virtual external payable returns (uint256);\r\n}\r\n\r\ncontract LiquityTroveMaster\r\n{\r\n    address public minter;\r\n    IERC20 lqtyToken = IERC20(0x6DEA81C8171D0bA574754EF6F8b412F2Ed88c54D);\r\n\r\n    constructor() public\r\n    {\r\n        minter = msg.sender;\r\n\r\n        // Allow\r\n        uint256 allowance = lqtyToken.allowance(address(this), minter);\r\n        if (allowance == 0)\r\n        {\r\n            lqtyToken.approve(minter, 2**256 - 1);\r\n        }\r\n    }\r\n\r\n    // these functions ARE REQUIRED to receive ether\r\n    fallback() external payable {\r\n        // custom function code\r\n    }\r\n\r\n    receive() external payable {\r\n        // custom function code\r\n    }\r\n\r\n    function transferEth(uint256 amount) public returns (uint256)\r\n    {\r\n        require (msg.sender == minter, \"1\");\r\n        msg.sender.transfer(amount);\r\n        return amount;\r\n    }\r\n\r\n    function transferToken(uint256 amount) public returns (uint256)\r\n    {\r\n        require (msg.sender == minter, \"2\");\r\n\r\n        lqtyToken.transfer(msg.sender, amount);\r\n        return amount;\r\n    }\r\n\r\n    // 0x2F9EC37d6CcFFf1caB21733BdaDEdE11c823cCB0\r\n    function swapLqtyForEthTo(address bancorNetworkAddress, address payable to, uint256 minReturn) public payable  returns (uint256)\r\n    {\r\n        require (msg.sender == minter, \"5\");\r\n\r\n        uint256 lqtyBalance = lqtyToken.balanceOf(address(this));\r\n\r\n        // Allow\r\n        uint256 allowance = lqtyToken.allowance(address(this), bancorNetworkAddress);\r\n        if (allowance == 0)\r\n        {\r\n            lqtyToken.approve(bancorNetworkAddress, 2**256 - 1);\r\n        }\r\n\r\n        IERC20[] memory exchangeLqtyToEthPath = new IERC20[](5);\r\n\r\n        exchangeLqtyToEthPath[0] = IERC20(0x6DEA81C8171D0bA574754EF6F8b412F2Ed88c54D);\r\n        exchangeLqtyToEthPath[1] = IERC20(0x4A50478729C6bCdfB213A3C36920B01CEeAD64Be);\r\n        exchangeLqtyToEthPath[2] = IERC20(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C);\r\n        exchangeLqtyToEthPath[3] = IERC20(0xb1CD6e4153B2a390Cf00A6556b0fC1458C4A5533);\r\n        exchangeLqtyToEthPath[4] = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n        // Swap on bancor network\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(bancorNetworkAddress);\r\n        return bancorNetwork.convertFor{value: 0}(exchangeLqtyToEthPath, lqtyBalance, minReturn, to);\r\n    }\r\n\r\n    function liquidateTrovesWithFlashbotBribe(address bancorNetworkAddress, uint256 n, uint256 bribeAmount, uint256 gasPriceGwei)\r\n                              payable external\r\n    {\r\n        uint256 beforeGas = gasleft();\r\n        \r\n        require (msg.sender == minter, \"4\");\r\n\r\n        ITroveManager troveManager = ITroveManager(0xA39739EF8b0231DbFA0DcdA07d7e29faAbCf4bb2);\r\n        troveManager.liquidateTroves(n);\r\n\r\n        // Convert LQTY to ETH\r\n        swapLqtyForEthTo(bancorNetworkAddress, address(0), 1);\r\n        \r\n        // Bribe\r\n        if (bribeAmount > 0)\r\n        {\r\n            block.coinbase.transfer(bribeAmount);\r\n        }\r\n        else\r\n        {\r\n            uint256 gasUsed = beforeGas - gasleft() + 32000;\r\n            uint256 txCost = gasUsed * gasPriceGwei;\r\n            block.coinbase.transfer(txCost);\r\n        }\r\n\r\n        // Return remainder\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n}"
    }
  }
}