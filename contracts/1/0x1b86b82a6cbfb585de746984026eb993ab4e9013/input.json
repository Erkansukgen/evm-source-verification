{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Controllable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./Governable.sol\";\n\ncontract Controllable is Governable {\n    constructor(address _storage) public Governable(_storage) {}\n\n    modifier onlyController() {\n        require(store.isController(msg.sender), \"Not a controller\");\n        _;\n    }\n\n    modifier onlyControllerOrGovernance() {\n        require(\n            (store.isController(msg.sender) || store.isGovernance(msg.sender)),\n            \"The caller must be controller or governance\"\n        );\n        _;\n    }\n\n    function controller() public view virtual returns (address) {\n        return store.controller();\n    }\n}\n"},"contracts/Governable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./Storage.sol\";\n\ncontract Governable {\n    Storage public store;\n\n    constructor(address _store) public {\n        require(_store != address(0), \"new storage shouldn't be empty\");\n        store = Storage(_store);\n    }\n\n    modifier onlyGovernance() {\n        require(store.isGovernance(msg.sender), \"Not governance\");\n        _;\n    }\n\n    function setStorage(address _store) public onlyGovernance {\n        require(_store != address(0), \"new storage shouldn't be empty\");\n        store = Storage(_store);\n    }\n\n    function governance() public view virtual returns (address) {\n        return store.governance();\n    }\n}\n"},"contracts/Interfaces/external/IUniswapV3SwapRouter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IUniswapV3SwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n"},"contracts/Storage.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ncontract Storage {\n    address public governance;\n    address public controller;\n\n    constructor() public {\n        governance = msg.sender;\n    }\n\n    modifier onlyGovernance() {\n        require(isGovernance(msg.sender), \"Not governance\");\n        _;\n    }\n\n    function setGovernance(address _governance) public onlyGovernance {\n        require(_governance != address(0), \"new governance shouldn't be empty\");\n        governance = _governance;\n    }\n\n    function setController(address _controller) public onlyGovernance {\n        require(_controller != address(0), \"new controller shouldn't be empty\");\n        controller = _controller;\n    }\n\n    function isGovernance(address account) public view returns (bool) {\n        return account == governance;\n    }\n\n    function isController(address account) public view returns (bool) {\n        return account == controller;\n    }\n}\n"},"contracts/exchange/Uniswap/v3/UniswapV3ExchangeAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental \"ABIEncoderV2\";\n\nimport { BytesLib } from \"./lib/BytesLib.sol\";\nimport { IUniswapV3SwapRouter } from \"../../../Interfaces/external/IUniswapV3SwapRouter.sol\";\nimport \"../../../Controllable.sol\";\n\n/**\n * @title UniswapV3TradeAdapter\n * @author Set Protocol\n *\n * Exchange adapter for Uniswap V3 SwapRouter that encodes trade data\n */\ncontract UniswapV3ExchangeAdapter is Controllable {\n    using BytesLib for bytes;\n\n    /* ============= Constants ================= */\n\n    // signature of exactInput SwapRouter function\n    string internal constant EXACT_INPUT =\n        \"exactInput((bytes,address,uint256,uint256,uint256))\";\n\n    /* ============ State Variables ============ */\n\n    // Address of Uniswap V3 SwapRouter contract\n    address public immutable swapRouter;\n\n    mapping(address => address[]) public assetsBuyPath;\n    mapping(address => address[]) public assetsSellPath;\n    mapping(address => uint24[]) public assetsBuyFees;\n    mapping(address => uint24[]) public assetsSellFees;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Set state variables\n     *\n     * @param _swapRouter    Address of Uniswap V3 SwapRouter\n     */\n    constructor(address _swapRouter, address _storage)\n        public\n        Controllable(_storage)\n    {\n        swapRouter = _swapRouter;\n    }\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * Return calldata for Uniswap V3 SwapRouter\n     *\n     * @param  _sourceToken              Address of source token to be sold\n     * @param  _destinationToken         Address of destination token to buy\n     * @param  _destinationAddress       Address that assets should be transferred to\n     * @param  _sourceQuantity           Amount of source token to sell\n     * @param  _minDestinationQuantity   Min amount of destination token to buy\n     * @param  _data                     Uniswap V3 path. Equals the output of the generateDataParam function\n     *\n     * @return address                   Target contract address\n     * @return uint256                   Call value\n     * @return bytes                     Trade calldata\n     */\n    function getTradeCalldata(\n        address _sourceToken,\n        address _destinationToken,\n        address _destinationAddress,\n        uint256 _sourceQuantity,\n        uint256 _minDestinationQuantity,\n        bytes calldata _data\n    )\n        external\n        view\n        returns (\n            address,\n            uint256,\n            bytes memory\n        )\n    {\n        address sourceFromPath = _data.toAddress(0);\n        require(\n            _sourceToken == sourceFromPath,\n            \"UniswapV3ExchangeAdapter: source token path mismatch\"\n        );\n\n        address destinationFromPath = _data.toAddress(_data.length - 20);\n        require(\n            _destinationToken == destinationFromPath,\n            \"UniswapV3ExchangeAdapter: destination token path mismatch\"\n        );\n\n        IUniswapV3SwapRouter.ExactInputParams\n            memory params = IUniswapV3SwapRouter.ExactInputParams(\n                _data,\n                _destinationAddress,\n                block.timestamp,\n                _sourceQuantity,\n                _minDestinationQuantity\n            );\n\n        bytes memory callData = abi.encodeWithSignature(EXACT_INPUT, params);\n        return (swapRouter, 0, callData);\n    }\n\n    /**\n     * Returns the address to approve source tokens to for trading. This is the Uniswap SwapRouter address\n     *\n     * @return address             Address of the contract to approve tokens to\n     */\n    function getSpender() external view returns (address) {\n        return swapRouter;\n    }\n\n    function generateDataParam(\n        address sourceToken,\n        address destinationToken,\n        bool buy\n    ) external returns (bytes memory) {\n        bytes memory data = \"\";\n        if (buy) {\n            data = generateDataParam(\n                assetsBuyPath[destinationToken],\n                assetsBuyFees[destinationToken]\n            );\n        } else {\n            data = generateDataParam(\n                assetsSellPath[sourceToken],\n                assetsSellFees[sourceToken]\n            );\n        }\n        return data;\n    }\n\n    /**\n     * Returns the appropriate _data argument for getTradeCalldata. Equal to the encodePacked path with the\n     * fee of each hop between it, e.g [token1, fee1, token2, fee2, token3]. Note: _fees.length == _path.length - 1\n     *\n     * @param _path array of addresses to use as the path for the trade\n     * @param _fees array of uint24 representing the pool fee to use for each hop\n     */\n    function generateDataParam(address[] memory _path, uint24[] memory _fees)\n        internal\n        returns (bytes memory)\n    {\n        bytes memory data = \"\";\n        for (uint256 i = 0; i < _path.length - 1; i++) {\n            data = abi.encodePacked(data, _path[i], _fees[i]);\n        }\n\n        // last encode has no fee associated with it since _fees.length == _path.length - 1\n        return abi.encodePacked(data, _path[_path.length - 1]);\n    }\n\n    function updateAssetsBuyPath(address _asset, address[] memory _path)\n        external\n        onlyControllerOrGovernance\n    {\n        require(_asset != address(0), \"asset should not be equal to null\");\n        assetsBuyPath[_asset] = _path;\n    }\n\n    function updateAssetsSellPath(address _asset, address[] memory _path)\n        external\n        onlyControllerOrGovernance\n    {\n        require(_asset != address(0), \"asset should not be equal to null\");\n        assetsSellPath[_asset] = _path;\n    }\n\n    function updateAssetsBuyFee(address _asset, uint24[] memory _fees)\n        external\n        onlyControllerOrGovernance\n    {\n        require(_asset != address(0), \"asset should not be equal to null\");\n        assetsBuyFees[_asset] = _fees;\n    }\n\n    function updateAssetsSellFee(address _asset, uint24[] memory _fees)\n        external\n        onlyControllerOrGovernance\n    {\n        require(_asset != address(0), \"asset should not be equal to null\");\n        assetsSellFees[_asset] = _fees;\n    }\n}\n"},"contracts/exchange/Uniswap/v3/lib/BytesLib.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (address)\n    {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint24)\n    {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"}}}