{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/ether2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/* ! merlioneth.sol | (c) 2020 Develop by ghost29a (http://29a.dev) | License: MIT\r\n...../  /\\         /  /\\         /  /\\         /  /\\       ___        /  /\\         /  /\\    \r\n    /  /::|       /  /::\\       /  /::\\       /  /:/      /__/\\      /  /::\\       /  /::|   \r\n   /  /:|:|      /  /:/\\:\\     /  /:/\\:\\     /  /:/       \\__\\:\\    /  /:/\\:\\     /  /:|:|   \r\n  /  /:/|:|__   /  /::\\ \\:\\   /  /::\\ \\:\\   /  /:/        /  /::\\  /  /:/  \\:\\   /  /:/|:|__ \r\n /__/:/_|::::\\ /__/:/\\:\\ \\:\\ /__/:/\\:\\_\\:\\ /__/:/      __/  /:/\\/ /__/:/ \\__\\:\\ /__/:/ |:| /\\\r\n \\__\\/  /~~/:/ \\  \\:\\ \\:\\_\\/ \\__\\/~|::\\/:/ \\  \\:\\     /__/\\/:/~~  \\  \\:\\ /  /:/ \\__\\/  |:|/:/\r\n       /  /:/   \\  \\:\\ \\:\\      |  |:|::/   \\  \\:\\    \\  \\::/      \\  \\:\\  /:/      |  |:/:/ \r\n      /  /:/     \\  \\:\\_\\/      |  |:|\\/     \\  \\:\\    \\  \\:\\       \\  \\:\\/:/       |__|::/  \r\n     /__/:/       \\  \\:\\        |__|:|~       \\  \\:\\    \\__\\/        \\  \\::/        /__/:/   \r\n     \\__\\/         \\__\\/         \\__\\|         \\__\\/                  \\__\\/         \\__\\/    v1.0 \r\n\r\n\r\nURL : https://merlioneth.com\r\nHashtag: #merlioneth\r\n*/\r\npragma solidity 0.6.8;\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Merlioneth is Ownable {\r\n    using Counters for Counters.Counter;\r\n     address public ownerWallet;\r\n      Counters.Counter public currUserID;\r\n      Counters.Counter public counterDays;\r\n      uint REGISTRATION_FEE=0.025 ether;\r\n      uint public global_balance_lotery=0 ether;\r\n      uint block_Dayly_old=0;\r\n      uint blockday=5760;\r\n      struct UserStruct {\r\n        bool isExist;\r\n        uint id;\r\n        uint balanceUser;\r\n        uint referrerID;\r\n        uint referredUsers;\r\n        bool isEngine1Active;\r\n        bool isEngine2Active;\r\n        bool isEngine3Active;\r\n    }\r\n     struct EngineUserStruct {\r\n        bool isExist;\r\n        uint id;\r\n       uint payment_received;\r\n       uint payment_received_plus;\r\n    }\r\n    struct SmartpotWinnerStruct {\r\n        bool isExist;\r\n        address winner;\r\n        uint time;\r\n    }\r\n    struct SmartpotGlobalWinnerStruct {\r\n        bool isExist;\r\n        bool isWinner;\r\n        uint prize;\r\n        uint ticketWin;\r\n        address winner;\r\n        uint time;\r\n    }\r\n    mapping (address => UserStruct) public users;\r\n    mapping (uint => address) public userList;\r\n    mapping (uint =>uint) smartpotTiketsGlobal;\r\n    uint ticket_price= 0.025 ether;\r\n    uint ticket_price10= 0.23 ether;\r\n    uint ticket_price50= 1 ether;\r\n    uint currTicketID=1;\r\n    uint beforeticketID=0;\r\n   \r\n    mapping (address => EngineUserStruct) public engine1users;\r\n    mapping (uint => address) public engine1userList;\r\n    mapping (uint => SmartpotWinnerStruct) public engine1Winners;\r\n    uint engine1_royalty=0.004 ether;\r\n    uint engine1_price=0.2 ether;\r\n    uint engine1_ref_dir=0.020 ether;\r\n    uint engine1_smart_pot=0.024 ether;\r\n    uint engine1_smartcontract=0.016 ether;\r\n    uint engine1_user_global=0.020 ether;\r\n    mapping(uint => uint) engine1_winer_smartpot;\r\n    uint public engine1currUserID = 0;\r\n    uint public engine1activeUserID = 0;\r\n    uint public engine1_balance_lotery=0 ether;\r\n    uint public engine1_index_winner=0;\r\n\r\n    \r\n    mapping (address => EngineUserStruct) public engine2users;\r\n    mapping (uint => address) public engine2userList;\r\n    mapping (uint => SmartpotWinnerStruct) public engine2Winners;\r\n    uint engine2_royalty=0.01 ether;\r\n    uint engine2_price=0.5 ether;\r\n    uint engine2_ref_dir=0.065 ether;\r\n    uint engine2_smart_pot=0.070 ether;\r\n    uint engine2_smartcontract=0.04 ether;\r\n    uint engine2_user_global=0.065 ether;\r\n    mapping(uint => uint) engine2_winer_smartpot;\r\n    uint public engine2currUserID = 0;\r\n    uint public engine2activeUserID = 0;\r\n    uint public engine2_balance_lotery=0 ether;\r\n    uint public engine2_index_winner=0;\r\n   \r\n    mapping (address => EngineUserStruct) public engine3users;\r\n    mapping (uint => address) public engine3userList;\r\n    mapping (uint => SmartpotWinnerStruct) public engine3Winners;\r\n    uint engine3_royalty=0.02 ether;\r\n    uint engine3_price=1 ether;\r\n    uint engine3_ref_dir=0.20 ether;\r\n    uint engine3_smart_pot=0.12 ether;\r\n    uint engine3_smartcontract=0.08 ether;\r\n    uint engine3_user_global=0.20 ether;\r\n    mapping(uint => uint) engine3_winer_smartpot;\r\n    uint public engine3currUserID = 0;\r\n    uint public engine3activeUserID = 0;\r\n    uint public engine3_balance_lotery=0 ether;\r\n    uint public engine3_index_winner=0;\r\n   \r\n    uint _stack = 0;\r\n    mapping (uint => uint32) public commitBlock;\r\n \r\n    struct SmartpotStruct {\r\n    uint userID;    \r\n    uint referredUsers;\r\n    }\r\n    mapping (uint => mapping (uint => uint)) smartpotListOne;\r\n    uint _indexSmartpotOne=1;\r\n    uint public currentSmartpotOne=0;\r\n    SmartpotStruct[] public smartpot_one;\r\n    uint public countSmartpotOne=0;\r\n  \r\n    mapping (uint => mapping (uint => uint)) smartpotListTwo;\r\n    uint _indexSmartpotTwo=1;\r\n    uint public currentSmartpotTwo=0;\r\n    SmartpotStruct[] public smartpot_two;\r\n    uint public countSmartpotTwo=0;\r\n   \r\n    mapping (uint => mapping (uint => uint)) smartpotListThree;\r\n    uint _indexSmartpotThree=1;\r\n    uint public currentSmartpotThree=0;\r\n    SmartpotStruct[] public smartpot_three;\r\n    uint public countSmartpotThree=0;\r\n   \r\n    uint public block_Smartpot = 0;\r\n    uint[] winnersSmartpots;\r\n    mapping (uint => SmartpotGlobalWinnerStruct) public GlobalSPWinners;\r\n    uint public global_index_winner=0;\r\n   \r\n    event regLevel(address indexed _user, address indexed _referrer, uint _time);\r\n    event regEngineEntry(address indexed _user,uint _level,   uint _time);\r\n    event getEnginePayment(address indexed _user,address indexed _receiver, uint _level, uint _time);\r\n    \r\n    event paySmartPotEngineOne(address indexed _user,uint _prize,uint _nrosmartpot, uint _time);\r\n    event paySmartPotEngineTwo(address indexed _user,uint _prize,uint _nrosmartpot, uint _time);\r\n    event paySmartPotEngineThree(address indexed _user,uint _prize,uint _nrosmartpot, uint _time);\r\n    event getTicket(address indexed _user,uint _idTicket,uint _time);\r\n    event paySmartpotGlobal(address indexed _user,uint _ticketWinner,uint _prize, uint _time);\r\n    event WithdrawEth(address indexed _user,uint _amount, uint _time);\r\n  \r\n      constructor() public {\r\n        ownerWallet = msg.sender;\r\n     \r\n        engine1_winer_smartpot[1]=1.5 ether;\r\n        engine1_winer_smartpot[2]=1 ether;\r\n        engine1_winer_smartpot[3]=0.5 ether;\r\n        engine2_winer_smartpot[1]=3 ether;\r\n        engine2_winer_smartpot[2]=2 ether;\r\n        engine2_winer_smartpot[3]=1 ether;\r\n        engine3_winer_smartpot[1]=4 ether;\r\n        engine3_winer_smartpot[2]=3 ether;\r\n        engine3_winer_smartpot[3]=2 ether;\r\n        UserStruct memory userStruct;\r\n     \r\n        currUserID.increment();\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID.current(),\r\n            balanceUser:0 ether,\r\n            referrerID: 0,\r\n            referredUsers:0,\r\n            isEngine1Active:true,\r\n            isEngine2Active:true,\r\n            isEngine3Active:true\r\n        });\r\n        users[ownerWallet] = userStruct;\r\n        userList[currUserID.current()] = ownerWallet;\r\n\r\n        EngineUserStruct memory engine1userStruct;\r\n        engine1currUserID++;\r\n        engine1userStruct = EngineUserStruct({\r\n            isExist:true,\r\n            id:engine1currUserID,\r\n            payment_received:0,\r\n            payment_received_plus:0\r\n        });\r\n        engine1activeUserID=engine1currUserID;\r\n        engine1users[msg.sender] = engine1userStruct;\r\n        engine1userList[engine1currUserID]=msg.sender;\r\n    \r\n        EngineUserStruct memory engine2userStruct;\r\n        engine2currUserID++;\r\n        engine2userStruct = EngineUserStruct({\r\n            isExist:true,\r\n            id:engine2currUserID,\r\n            payment_received:0,\r\n            payment_received_plus:0\r\n        });\r\n        engine2activeUserID=engine2currUserID;\r\n        engine2users[msg.sender] = engine2userStruct;\r\n        engine2userList[engine2currUserID]=msg.sender;\r\n      \r\n        EngineUserStruct memory engine3userStruct;\r\n        engine3currUserID++;\r\n        engine3userStruct = EngineUserStruct({\r\n            isExist:true,\r\n            id:engine3currUserID,\r\n            payment_received:0,\r\n            payment_received_plus:0\r\n        });\r\n        engine3activeUserID=engine3currUserID;\r\n        engine3users[msg.sender] = engine3userStruct;\r\n        engine3userList[engine3currUserID]=msg.sender;\r\n\r\n     \r\n         winnersSmartpots.push(0);\r\n         winnersSmartpots.push(0);\r\n         winnersSmartpots.push(0);\r\n      \r\n         block_Smartpot=block.number;\r\n         block_Dayly_old=block.number;\r\n      }\r\n       function registrationUser(uint _referrerID) public payable {\r\n        require(!isContract(msg.sender),\"Address is Contract\"); \r\n        require(!users[msg.sender].isExist, \"User Exists\");\r\n        require(_referrerID > 0 && _referrerID <= currUserID.current(), 'Incorrect referral ID');\r\n        require(msg.value == REGISTRATION_FEE, 'Incorrect Value');\r\n        UserStruct memory userStruct;\r\n       \r\n        currUserID.increment();\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID.current(),\r\n            balanceUser: 0 ether,\r\n            referrerID: _referrerID,\r\n            referredUsers:0,\r\n            isEngine1Active:false,\r\n            isEngine2Active:false,\r\n            isEngine3Active:false\r\n        });\r\n       users[msg.sender] = userStruct;\r\n       userList[currUserID.current()]=msg.sender;    \r\n       users[userList[users[msg.sender].referrerID]].referredUsers++;\r\n       global_balance_lotery+=REGISTRATION_FEE;\r\n       smartpotTiketsGlobal[currTicketID]=currUserID.current();\r\n       emit getTicket(msg.sender,currTicketID,now);\r\n       currTicketID++;\r\n       emit regLevel(msg.sender, userList[_referrerID], now);\r\n       \r\n    }\r\n   \r\n       function buyEngineOne() public payable {\r\n       require(users[msg.sender].isExist, \"User Not Registered\");\r\n       require(!users[msg.sender].isEngine1Active, \"Already in Engine\");\r\n       require(msg.value == engine1_price, 'Incorrect Value');\r\n       \r\n      \r\n       uint idreferer = users[msg.sender].referrerID;\r\n       uint idUser=users[msg.sender].id;\r\n       add_smartpot_one(idreferer);\r\n       address referer = userList[idreferer];\r\n       \r\n       \r\n        if(engine1users[referer].payment_received_plus+1<=2)\r\n        {\r\n            users[referer].balanceUser+=engine1_ref_dir;\r\n            engine1users[referer].payment_received_plus+=1;\r\n            emit getEnginePayment(msg.sender,referer, 1, now);\r\n        }else{\r\n            if(engine1users[referer].payment_received+5<=60){\r\n                users[referer].balanceUser+=engine1_ref_dir;\r\n                engine1users[referer].payment_received+=5;\r\n                emit getEnginePayment(msg.sender,referer, 1, now);\r\n                if(engine1users[referer].payment_received>=60)\r\n                    {\r\n                        users[referer].isEngine1Active=false;\r\n                        engine1users[referer].isExist=false;\r\n                    }\r\n            }else{\r\n                global_balance_lotery+=engine1_ref_dir;\r\n            }\r\n           \r\n        }\r\n       \r\n        engine1_balance_lotery+=engine1_smart_pot;\r\n       \r\n        if(engine1_balance_lotery>=3 ether){\r\n            payWinnerSmartpotOne();\r\n        }\r\n       \r\n        users[ownerWallet].balanceUser+=engine1_smartcontract;\r\n       \r\n        EngineUserStruct memory userStruct;\r\n        engine1currUserID++;\r\n        userStruct = EngineUserStruct({\r\n            isExist:true,\r\n            id:engine1currUserID,\r\n            payment_received:0,\r\n            payment_received_plus:0\r\n        });\r\n        engine1users[msg.sender] = userStruct;\r\n        engine1userList[engine1currUserID]=msg.sender;\r\n      \r\n        users[msg.sender].isEngine1Active=true;\r\n      \r\n       smartpotTiketsGlobal[currTicketID]=idUser;\r\n       emit getTicket(msg.sender,currTicketID,now);\r\n       currTicketID++;\r\n       \r\n     \r\n       emit regEngineEntry(msg.sender, 1, now);\r\n    }\r\n      function buyEngineTwo() public payable {\r\n       require(users[msg.sender].isExist, \"User Not Registered\");\r\n       require(!users[msg.sender].isEngine2Active, \"Already in Engine\");\r\n       require(msg.value == engine2_price, 'Incorrect Value');\r\n       \r\n      \r\n       uint idreferer = users[msg.sender].referrerID;\r\n       uint idUser=users[msg.sender].id;\r\n       add_smartpot_two(idreferer);\r\n       address referer = userList[idreferer];\r\n       \r\n        \r\n        if(engine2users[referer].payment_received_plus+1<=2)\r\n        {\r\n            users[referer].balanceUser+=engine2_ref_dir;\r\n            engine2users[referer].payment_received_plus+=1;\r\n            emit getEnginePayment(msg.sender,referer, 1, now);\r\n            \r\n        }else{\r\n            if(engine2users[referer].payment_received+6<=65){\r\n                 users[referer].balanceUser+=engine2_ref_dir;\r\n                 engine2users[referer].payment_received+=6;\r\n                 emit getEnginePayment(msg.sender,referer, 1, now);\r\n               \r\n                if(engine2users[referer].payment_received>=65)\r\n                    {\r\n                        users[referer].isEngine2Active=false;\r\n                        engine2users[referer].isExist=false;\r\n                    }\r\n            }else{\r\n                  global_balance_lotery+=engine2_ref_dir;\r\n            }\r\n        }\r\n      \r\n        engine2_balance_lotery+=engine2_smart_pot;\r\n       \r\n        if(engine2_balance_lotery>=6 ether){\r\n            payWinnerSmartpotTwo();\r\n        }\r\n       \r\n        users[ownerWallet].balanceUser+=engine2_smartcontract;\r\n     \r\n        EngineUserStruct memory userStruct;\r\n        engine2currUserID++;\r\n        userStruct = EngineUserStruct({\r\n            isExist:true,\r\n            id:engine2currUserID,\r\n            payment_received:0,\r\n            payment_received_plus:0\r\n        });\r\n        engine2users[msg.sender] = userStruct;\r\n        engine2userList[engine2currUserID]=msg.sender;\r\n      \r\n        users[msg.sender].isEngine2Active=true;\r\n        \r\n       smartpotTiketsGlobal[currTicketID]=idUser;\r\n       emit getTicket(msg.sender,currTicketID,now);\r\n       currTicketID++;\r\n       smartpotTiketsGlobal[currTicketID]=idUser;\r\n       emit getTicket(msg.sender,currTicketID,now);\r\n       currTicketID++;\r\n       \r\n     \r\n       emit regEngineEntry(msg.sender, 2, now);\r\n    }\r\n      function buyEngineThree() public payable {\r\n       require(users[msg.sender].isExist, \"User Not Registered\");\r\n       require(!users[msg.sender].isEngine3Active, \"Already in Engine\");\r\n       require(msg.value == engine3_price, 'Incorrect Value');\r\n       \r\n      \r\n       uint idreferer = users[msg.sender].referrerID;\r\n       uint idUser=users[msg.sender].id;\r\n       add_smartpot_three(idreferer);\r\n       address referer = userList[idreferer];\r\n       \r\n         \r\n        if(engine3users[referer].payment_received_plus+1<=3)\r\n        {\r\n            users[referer].balanceUser+=engine3_ref_dir;\r\n            engine3users[referer].payment_received_plus+=1;\r\n            emit getEnginePayment(msg.sender,referer, 1, now);\r\n            \r\n        }else{\r\n            if(engine3users[referer].payment_received+10<=70){\r\n                 users[referer].balanceUser+=engine3_ref_dir;\r\n                 engine3users[referer].payment_received+=10;\r\n                 emit getEnginePayment(msg.sender,referer, 1, now);\r\n                if(engine3users[referer].payment_received>=70)\r\n                {\r\n                    users[referer].isEngine3Active=false;\r\n                    engine3users[referer].isExist=false;\r\n                }\r\n            }else{\r\n                global_balance_lotery+=engine3_ref_dir;\r\n            }\r\n        }\r\n     \r\n        engine3_balance_lotery+=engine3_smart_pot;\r\n      \r\n        if(engine3_balance_lotery>=9 ether){\r\n            payWinnerSmartpotThree();\r\n        }\r\n    \r\n        users[ownerWallet].balanceUser+=engine3_smartcontract;\r\n       \r\n        EngineUserStruct memory userStruct;\r\n        engine3currUserID++;\r\n        userStruct = EngineUserStruct({\r\n            isExist:true,\r\n            id:engine3currUserID,\r\n            payment_received:0,\r\n            payment_received_plus:0\r\n        });\r\n        engine3users[msg.sender] = userStruct;\r\n        engine3userList[engine3currUserID]=msg.sender;\r\n      \r\n        users[msg.sender].isEngine3Active=true;\r\n       \r\n       smartpotTiketsGlobal[currTicketID]=idUser;\r\n       emit getTicket(msg.sender,currTicketID,now);\r\n       currTicketID++;\r\n        smartpotTiketsGlobal[currTicketID]=idUser;\r\n       emit getTicket(msg.sender,currTicketID,now);\r\n       currTicketID++;\r\n        smartpotTiketsGlobal[currTicketID]=idUser;\r\n       emit getTicket(msg.sender,currTicketID,now);\r\n       currTicketID++;\r\n       \r\n       emit regEngineEntry(msg.sender, 3, now);\r\n    }\r\n    function buyTicketOne() public payable{\r\n        require(users[msg.sender].isExist, \"User Not Registered\");\r\n        require(msg.value == ticket_price, 'Incorrect Value');\r\n        smartpotTiketsGlobal[currTicketID]=users[msg.sender].id;\r\n        global_balance_lotery+=msg.value;\r\n        emit getTicket(msg.sender,currTicketID,now);\r\n        currTicketID++;\r\n    }\r\n    function buyTicketTen() public payable{\r\n        require(users[msg.sender].isExist, \"User Not Registered\");\r\n        require(msg.value == ticket_price10, 'Incorrect Value');\r\n        global_balance_lotery+=msg.value;\r\n        for(uint i=0;i<10;i++){\r\n            smartpotTiketsGlobal[currTicketID]=users[msg.sender].id;\r\n            emit getTicket(msg.sender,currTicketID,now);\r\n            currTicketID++;\r\n        }\r\n        \r\n    }\r\n    function buyTicketFifty() public payable{\r\n        require(users[msg.sender].isExist, \"User Not Registered\");\r\n        require(msg.value == ticket_price50, 'Incorrect Value');\r\n        global_balance_lotery+=msg.value;\r\n        for(uint i=0;i<50;i++){\r\n            smartpotTiketsGlobal[currTicketID]=users[msg.sender].id;\r\n            emit getTicket(msg.sender,currTicketID,now);\r\n            currTicketID++;\r\n        }\r\n    }\r\n   \r\n    function donation_smartpot_global() public payable{\r\n        require(msg.value > 0, 'Incorrect Value');\r\n        global_balance_lotery+=msg.value;\r\n    }\r\n   \r\n    function smartpot_global_run() internal {\r\n        uint prize=global_balance_lotery;\r\n        for(uint i=0;i<5;i++){\r\n            uint winnerSmartpotGlobal=getrandom(SafeMath.sub(currTicketID,beforeticketID));\r\n            \r\n            uint idWinner = smartpotTiketsGlobal[winnerSmartpotGlobal+beforeticketID];\r\n            address addwinner = userList[idWinner];\r\n            SmartpotGlobalWinnerStruct memory smartpotwinnerStruct;\r\n            global_index_winner++;\r\n            if(users[addwinner].referredUsers>=2 && users[addwinner].isEngine1Active && users[addwinner].isEngine2Active && users[addwinner].isEngine3Active){\r\n                    users[addwinner].balanceUser+=prize;\r\n                    emit paySmartpotGlobal(addwinner,winnerSmartpotGlobal+beforeticketID,prize,now);\r\n                    global_balance_lotery=global_balance_lotery-prize;\r\n                    smartpotwinnerStruct = SmartpotGlobalWinnerStruct({\r\n                                isExist: true,\r\n                                isWinner:true,\r\n                                prize:prize,\r\n                                ticketWin:winnerSmartpotGlobal+beforeticketID,\r\n                                winner: addwinner,\r\n                                time:now\r\n                        });\r\n                    GlobalSPWinners[global_index_winner] = smartpotwinnerStruct;\r\n                    i=5;\r\n            }else{\r\n                    smartpotwinnerStruct = SmartpotGlobalWinnerStruct({\r\n                                isExist: true,\r\n                                isWinner:false,\r\n                                prize:prize,\r\n                                ticketWin:winnerSmartpotGlobal+beforeticketID,\r\n                                winner: addwinner,\r\n                                time:now\r\n                        });\r\n                    GlobalSPWinners[global_index_winner] = smartpotwinnerStruct;\r\n                prize= SafeMath.div(prize,2);\r\n                emit paySmartpotGlobal(addwinner,winnerSmartpotGlobal+beforeticketID,0, now);\r\n            }\r\n        }\r\n        beforeticketID=currTicketID;\r\n    }\r\n    function getrandom(uint zise) internal returns (uint) {\r\n        commitBlock[_stack]=uint32(block.number);\r\n        uint a = uint(keccak256(abi.encodePacked(blockhash(commitBlock[_stack]), SafeMath.add(commitBlock[_stack],_stack++),now,msg.sender))) % zise;\r\n        return a;\r\n    }\r\n     function add_smartpot_one(uint iduser) internal {\r\n            countSmartpotOne++;\r\n            if(smartpotListOne[currentSmartpotOne][iduser]==0){\r\n                SmartpotStruct memory smartpotStruct;\r\n                smartpotStruct.userID = iduser;\r\n                smartpotStruct.referredUsers = 1;\r\n                smartpot_one.push(smartpotStruct);\r\n                smartpotListOne[currentSmartpotOne][iduser]=_indexSmartpotOne;\r\n                _indexSmartpotOne++;\r\n            }else{\r\n               uint _indexuser=smartpotListOne[currentSmartpotOne][iduser];\r\n               smartpot_one[_indexuser-1].referredUsers++;\r\n            }\r\n    }\r\n     function add_smartpot_two(uint iduser) internal {\r\n            countSmartpotTwo++;\r\n            if(smartpotListTwo[currentSmartpotTwo][iduser]==0){\r\n                SmartpotStruct memory smartpotStruct;\r\n                smartpotStruct.userID = iduser;\r\n                smartpotStruct.referredUsers = 1;\r\n                smartpot_two.push(smartpotStruct);\r\n                smartpotListTwo[currentSmartpotTwo][iduser]=_indexSmartpotTwo;\r\n                _indexSmartpotTwo++;\r\n            }else{\r\n               uint _indexuser=smartpotListTwo[currentSmartpotTwo][iduser];\r\n               smartpot_two[_indexuser-1].referredUsers++;\r\n            }\r\n    }\r\n    function add_smartpot_three(uint iduser) internal {\r\n            countSmartpotThree++;\r\n            if(smartpotListThree[currentSmartpotThree][iduser]==0){\r\n                SmartpotStruct memory smartpotStruct;\r\n                smartpotStruct.userID = iduser;\r\n                smartpotStruct.referredUsers = 1;\r\n                smartpot_three.push(smartpotStruct);\r\n                smartpotListThree[currentSmartpotThree][iduser]=_indexSmartpotThree;\r\n                _indexSmartpotThree++;\r\n            }else{\r\n               uint _indexuser=smartpotListThree[currentSmartpotThree][iduser];\r\n               smartpot_three[_indexuser-1].referredUsers++;\r\n            }\r\n    }\r\n    function new_smartpotOne() internal{\r\n        delete smartpot_one;\r\n        _indexSmartpotOne=1;\r\n        countSmartpotOne=0;\r\n        currentSmartpotOne++;\r\n        engine1_balance_lotery=0 ether;\r\n    }\r\n     function new_smartpotTwo() internal{\r\n        delete smartpot_two;\r\n        _indexSmartpotTwo=1;\r\n        countSmartpotTwo=0;\r\n        currentSmartpotTwo++;\r\n        engine2_balance_lotery=0 ether;\r\n    }\r\n     function new_smartpotThree() internal{\r\n        delete smartpot_three;\r\n        _indexSmartpotThree=1;\r\n        countSmartpotThree=0;\r\n        currentSmartpotThree++;\r\n        engine3_balance_lotery=0 ether;\r\n    }\r\n     function payWinnerSmartpotOne() internal {\r\n        quickSort(smartpot_one,int(0), int(smartpot_one.length - 1));\r\n        //Pagando ganadores\r\n        for(uint i=0;i<3;i++){\r\n            address adduserwin = userList[winnersSmartpots[i]];\r\n            users[adduserwin].balanceUser+=engine1_winer_smartpot[i+1];\r\n            SmartpotWinnerStruct memory smartpotwinnerStruct;\r\n            engine1_index_winner++;\r\n            smartpotwinnerStruct = SmartpotWinnerStruct({\r\n                        isExist: true,\r\n                        winner: adduserwin,\r\n                        time:now\r\n                });\r\n            engine1Winners[engine1_index_winner] = smartpotwinnerStruct;\r\n            emit paySmartPotEngineOne(adduserwin,engine1_winer_smartpot[i+1],currentSmartpotOne, now);\r\n        }\r\n        new_smartpotOne();\r\n    }\r\n    function payWinnerSmartpotTwo() internal {\r\n        quickSort(smartpot_two,int(0), int(smartpot_two.length - 1));\r\n        //Pagando ganadores\r\n        for(uint i=0;i<3;i++){\r\n            address adduserwin = userList[winnersSmartpots[i]];\r\n            users[adduserwin].balanceUser+=engine2_winer_smartpot[i+1];\r\n            SmartpotWinnerStruct memory smartpotwinnerStruct;\r\n            engine2_index_winner++;\r\n            smartpotwinnerStruct = SmartpotWinnerStruct({\r\n                        isExist: true,\r\n                        winner: adduserwin,\r\n                        time:now\r\n                });\r\n            engine2Winners[engine2_index_winner] = smartpotwinnerStruct;\r\n            emit paySmartPotEngineTwo(adduserwin,engine2_winer_smartpot[i+1],currentSmartpotTwo, now);\r\n        }\r\n   \r\n        new_smartpotTwo();\r\n    }\r\n    function payWinnerSmartpotThree() internal {\r\n        quickSort(smartpot_three,int(0), int(smartpot_three.length - 1));\r\n\r\n        for(uint i=0;i<3;i++){\r\n            address adduserwin = userList[winnersSmartpots[i]];\r\n            users[adduserwin].balanceUser+=engine3_winer_smartpot[i+1];\r\n            SmartpotWinnerStruct memory smartpotwinnerStruct;\r\n            engine3_index_winner++;\r\n            smartpotwinnerStruct = SmartpotWinnerStruct({\r\n                        isExist: true,\r\n                        winner: adduserwin,\r\n                        time:now\r\n                });\r\n            engine3Winners[engine3_index_winner] = smartpotwinnerStruct;\r\n            emit paySmartPotEngineThree(adduserwin,engine3_winer_smartpot[i+1],currentSmartpotThree, now);\r\n        }\r\n\r\n        new_smartpotThree();\r\n    }\r\n    function quickSort(SmartpotStruct[] memory arr,int left, int right) internal{\r\n        int i = left;\r\n        int j = right;\r\n        if(i==j) return;\r\n        uint pivot = arr[uint(left + (right - left) / 2)].referredUsers;\r\n        while (i <= j) {\r\n            while (arr[uint(i)].referredUsers < pivot) i++;\r\n            while (pivot < arr[uint(j)].referredUsers) j--;\r\n            if (i <= j) {\r\n                (arr[uint(i)].referredUsers, arr[uint(j)].referredUsers) = (arr[uint(j)].referredUsers, arr[uint(i)].referredUsers);\r\n                (arr[uint(i)].userID, arr[uint(j)].userID) = (arr[uint(j)].userID, arr[uint(i)].userID);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n        if (left < j)\r\n            quickSort(arr,left, j);\r\n        if (i < right)\r\n            quickSort(arr,i, right);\r\n        \r\n        winnersSmartpots[0]=arr[arr.length - 1].userID;\r\n        winnersSmartpots[1]=arr[arr.length - 2].userID;\r\n        winnersSmartpots[2]=arr[arr.length - 3].userID;\r\n    }\r\n    function ownerKill(address payable addr) public onlyOwner {\r\n     selfdestruct(addr);\r\n    }\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n   \r\n    function Withdraw() public {\r\n        require(!isContract(msg.sender),\"Address is Contract\"); \r\n        require(users[msg.sender].isExist, \"User Not Registered\");\r\n        require(users[msg.sender].balanceUser > 0 ether, \"Insufficient balance\");\r\n        uint amount = users[msg.sender].balanceUser;\r\n        bool sent=false;\r\n        (sent, ) = msg.sender.call{value: amount}(\"\");\r\n        if(sent){\r\n            users[msg.sender].balanceUser = 0 ether;\r\n        }\r\n        emit WithdrawEth(msg.sender,amount,now);\r\n    }\r\n    function searchWinnerSmartPotGlobal() public {\r\n        require(!isContract(msg.sender),\"Address is Contract\"); \r\n        require(block.number>block_Smartpot+86400,\"15 days did not pass\");\r\n        smartpot_global_run();\r\n        block_Smartpot=block_Smartpot+86400;\r\n    }\r\n    function payDailyRoyalty() public {\r\n        require(!isContract(msg.sender),\"Address is Contract\"); \r\n        require(block.number>block_Dayly_old+blockday,\"1 day did not pass\");\r\n             counterDays.increment();\r\n             for(uint i=1;i<=engine1currUserID;i++){\r\n                 address engine1user=engine1userList[i];\r\n                 if(users[engine1user].isEngine1Active){\r\n                    users[engine1user].balanceUser+=engine1_royalty;\r\n                    engine1users[engine1user].payment_received+=1;\r\n                 }\r\n             }\r\n         \r\n             for(uint i=1;i<=engine2currUserID;i++){\r\n                 address engine2user=engine2userList[i];\r\n                 if(users[engine2user].isEngine2Active){\r\n                    users[engine2user].balanceUser+=engine2_royalty;\r\n                    engine2users[engine2user].payment_received+=1;\r\n                 }\r\n             }\r\n        \r\n             for(uint i=1;i<=engine3currUserID;i++){\r\n                 address engine3user=engine3userList[i];\r\n                 if(users[engine3user].isEngine3Active){\r\n                    users[engine3user].balanceUser+=engine3_royalty;\r\n                    engine3users[engine3user].payment_received+=1;\r\n                 }\r\n             }\r\n             if(counterDays.current()%5==0){\r\n                 block_Dayly_old=block_Dayly_old+(blockday*3);\r\n             }else{\r\n                 block_Dayly_old+=blockday;\r\n             }\r\n    }\r\n}\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n"
    }
  }
}