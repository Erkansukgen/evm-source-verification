{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/IERC20.sol":{"content":"pragma solidity >=0.4.22;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"browser/proxyarb.sol":{"content":"pragma solidity >=0.4.22;\r\nimport \"./IERC20.sol\";\r\n\r\ncontract ProxyArb {\r\n\tmapping(address => bool) whitelist;\r\n\taddress owner;\r\n\r\n\tconstructor() public  {\r\n        owner = msg.sender;\r\n\t\twhitelist[owner] =  true;\r\n    }\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction changeOwner(address _newOwner) public onlyOwner {\r\n\t\towner = _newOwner;\r\n\t}\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(isWhitelisted(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function addAdmin(address _address) public onlyOwner {\r\n        whitelist[_address] = true;\r\n    }\r\n\r\n    function removeAdmin(address _address) public onlyOwner {\r\n        whitelist[_address] = false;\r\n    }\r\n\r\n    function isWhitelisted(address _address) internal view returns(bool) {\r\n        return whitelist[_address];\r\n    }\r\n\t\r\n\tfunction withdraw(uint256 amountOut) public payable onlyOwner {\r\n\t\trequire(address(this).balance >= amountOut, \"out of balance\");\t\r\n\t\tmsg.sender.transfer(amountOut);\r\n    }\r\n\t\r\n\tfunction withdrawToken(address token_address, uint256 amountOut) public payable onlyOwner {\r\n\t\tIERC20 tokenERC20 = IERC20(token_address);\r\n\t\trequire(tokenERC20.balanceOf(address(this)) >= amountOut, \"out of balance\");\r\n\t\ttokenERC20.transfer(msg.sender, amountOut);\r\n    }\t\r\n\r\n\treceive() external payable {\r\n\t}\r\n\t\r\n\tfallback() external payable onlyWhitelisted {\r\n\t\tassembly {\r\n\t\t\tlet ptr := mload(0x40)\r\n\t\t\tlet target := div(calldataload(4), 0x01000000000000000000000000)\r\n\t\t\tlet datasize := sub(calldatasize(), 0x18)\r\n\t\t\tcalldatacopy(ptr, 0x18, datasize)\r\n\t\t\tlet result := delegatecall(gas(), target, ptr, datasize, 0, 0)\r\n\t\t\tlet size := returndatasize()\r\n\t\t\treturndatacopy(ptr, 0, size)\r\n\t\t\tswitch result\r\n\t\t\tcase 0 { revert(ptr, size) }\r\n\t\t\tcase 1 { return(ptr, size) }\r\n\t\t}\r\n\t}\r\n}"}}}