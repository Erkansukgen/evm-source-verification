{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/3_Ballot.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-05-05\n*/\n\npragma solidity 0.5.16; /*\n\n\n___________________________________________________________________\n  _      _                                        ______           \n  |  |  /          /                                /              \n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\n\n\n\n ██████╗ ██╗██╗     ██╗     ██╗ ██████╗ ███╗   ██╗    ███╗   ███╗ ██████╗ ███╗   ██╗███████╗██╗   ██╗\n ██╔══██╗██║██║     ██║     ██║██╔═══██╗████╗  ██║    ████╗ ████║██╔═══██╗████╗  ██║██╔════╝╚██╗ ██╔╝\n ██████╔╝██║██║     ██║     ██║██║   ██║██╔██╗ ██║    ██╔████╔██║██║   ██║██╔██╗ ██║█████╗   ╚████╔╝ \n ██╔══██╗██║██║     ██║     ██║██║   ██║██║╚██╗██║    ██║╚██╔╝██║██║   ██║██║╚██╗██║██╔══╝    ╚██╔╝  \n ██████╔╝██║███████╗███████╗██║╚██████╔╝██║ ╚████║    ██║ ╚═╝ ██║╚██████╔╝██║ ╚████║███████╗   ██║   \n ╚═════╝ ╚═╝╚══════╝╚══════╝╚═╝ ╚═════╝ ╚═╝  ╚═══╝    ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝   ╚═╝   \n                                                                                            \n\n\n-------------------------------------------------------------------\n Copyright (c) 2020 onwards Billion Money Inc. ( https://billionmoney.live )\n-------------------------------------------------------------------\n */\n\n\n\n//*******************************************************************//\n//------------------ Contract to Manage Ownership -------------------//\n//*******************************************************************//\n    \ncontract owned {\n    address payable public owner;\n    address payable internal newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address payable _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\n\n\n//*******************************************************************//\n//------------------         PAX interface        -------------------//\n//*******************************************************************//\n\n interface paxInterface\n {\n    function transfer(address _to, uint256 _amount) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\n }\n\ninterface oldContractInerface\n{\n    function userInfos(address user) external view returns(bool,uint32,uint32);\n    function findFreeReferrer(address _user) external view returns(address);\n    function userAddressByID(uint id) external view returns(address payable);\n    function viewUserLevelExpired(address _user, uint _level) external view returns(uint);\n    function totalDivCollection() external view returns(uint128);\n    function thisMonthEnd() external view returns(uint32);\n    function nextMemberFillIndex(uint) external view returns(uint32);\n    function nextMemberFillBox(uint) external view returns(uint32); \n    function autoPoolLevel(uint _lvl, uint _index) external view returns (uint32, uint32);     \n}\n\n\n//*******************************************************************//\n//------------------        MAIN contract         -------------------//\n//*******************************************************************//\n\ncontract billionMoney is owned {\n\n    address public specialAddress1;\n    address public specialAddress2;\n    bool stopSwap;\n    uint[10] autoPoolCount;  // This variable is only useful for fetching auto pool records from old contract, once all records fetched it has no use\n    \n    address public paxTokenAddress; \n    uint32 public levelLifeTime = 15552000;  // =180 days;\n    uint32 public lastIDCount = 0;\n    uint32 public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID\n    \n    address public oldBMContractAddress;\n    uint16 public lastIDofOldContract;\n    uint8 public maxDownLimit = 2;\n    uint32 public oneMonthDuration = 2592000; // = 30 days\n    uint32 public thisMonthEnd;\n\n    struct userInfo {\n        address[] referral;\n        uint32 id;\n        uint32 referrerID;\n        uint16 directCount;\n        bool joined;       \n        mapping(uint => uint) levelExpired;\n    }\n\n    mapping(uint => uint128) public priceOfLevel;\n    mapping(uint => uint128) public distForLevel;\n    mapping(uint => uint128) public autoPoolDist;\n    mapping(uint => uint128) public uniLevelDistPart;\n    uint128 public totalDivCollection;\n    uint128 public globalDivDistPart = 0.6 ether;\n    uint128 public systemDistPart = 1 ether;\n    \n\n    struct divPoolRecord\n    {\n        uint128 totalDividendCollection;\n        uint128 totalEligibleCount;\n    }\n    divPoolRecord[] public divPoolRecords;\n    mapping ( address => uint16) public eligibleUser; // if val > 0 then user is eligible from this divPoolRecords;\n    mapping(uint16 => mapping ( address => bool)) public dividendReceived; // dividend index => user => true/false\n    mapping(uint16 => bool) directUpdated;\n\n    struct autoPool\n    {\n        uint32 userID;\n        uint32 autoPoolParent;\n    }\n    mapping(uint8 => autoPool[]) public autoPoolLevel;  // users lavel records under auto pool scheme\n    mapping(address => mapping(uint8 => uint32)) public autoPoolIndex; //to find index of user inside auto pool\n    uint32[10] public nextMemberFillIndex;  // which auto pool index is in top of queue to fill in \n    uint32[10] public nextMemberFillBox;   // 3 downline to each, so which downline need to fill in\n\n    uint[10][10] public autoPoolSubDist;\n\n    \n\n    mapping (address => userInfo) public userInfos;\n    mapping (uint32 => address payable) public userAddressByID;\n\n    mapping(address => uint128) public totalGainInMainNetwork; //Main lavel income system income will go here with owner mapping\n    mapping(address => uint128) public totalGainInUniLevel; \n    mapping(address => uint128) public totalGainInAutoPool;\n    mapping(address => uint128) public netTotalUserWithdrawable;  //Dividend is not included in it\n\n\n    event regLevelEv(address indexed _userWallet, uint indexed _userID, uint indexed _referrerID, uint _time, address _refererWallet, uint _originalReferrer);\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\n    event paidForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\n    event lostForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\n    event payDividendEv(uint timeNow,uint payAmount,address paitTo);\n    event updateAutoPoolEv(uint timeNow,uint autoPoolLevelIndex,uint userIndexInAutoPool, address user);\n    event autoPoolPayEv(uint timeNow,address paidTo,uint paidForLevel, uint paidAmount, address paidAgainst);\n    event paidForUniLevelEv(uint timeNow,address PaitTo,uint Amount);\n    \n    constructor(address payable ownerAddress) public {\n        owner = ownerAddress;\n\n        emit OwnershipTransferred(address(0), owner);\n\n        priceOfLevel[1] = 20 ether;\n        priceOfLevel[2] = 20 ether;\n        priceOfLevel[3] = 40 ether;\n        priceOfLevel[4] = 140 ether;\n        priceOfLevel[5] = 600 ether;\n        priceOfLevel[6] = 5000 ether;\n        priceOfLevel[7] = 5500 ether;\n        priceOfLevel[8] = 10000 ether;\n        priceOfLevel[9] = 20000 ether;\n        priceOfLevel[10] = 40000 ether;\n\n        distForLevel[1] = 10 ether;\n        distForLevel[2] = 15 ether;\n        distForLevel[3] = 30 ether;\n        distForLevel[4] = 120 ether;\n        distForLevel[5] = 500 ether;\n        distForLevel[6] = 4700 ether;\n        distForLevel[7] = 5000 ether;\n        distForLevel[8] = 9000 ether;\n        distForLevel[9] = 18000 ether;\n        distForLevel[10] = 35000 ether;\n\n        autoPoolDist[1] = 4 ether;\n        autoPoolDist[2] = 5 ether;\n        autoPoolDist[3] = 10 ether;\n        autoPoolDist[4] = 20 ether;\n        autoPoolDist[5] = 100 ether;\n        autoPoolDist[6] = 300 ether;\n        autoPoolDist[7] = 500 ether;\n        autoPoolDist[8] = 1000 ether;\n        autoPoolDist[9] = 2000 ether;\n        autoPoolDist[10] = 5000 ether;        \n\n        uniLevelDistPart[1] = 1 ether;\n        uniLevelDistPart[2] = 0.6 ether;\n        uniLevelDistPart[3] = 0.4 ether;\n\n        for (uint i = 4 ; i < 11; i++)\n        {\n           uniLevelDistPart[i] =  0.2 ether;\n        } \n\n        autoPool memory temp;\n        for (uint8 i = 11 ; i < 21; i++)\n        {\n           uniLevelDistPart[i] =  0.1 ether;\n           uint8 a = i-11;\n           autoPoolLevel[a].push(temp);\n           uint distPart = autoPoolDist[a+1];\n           autoPoolSubDist[a][0] = distPart * 1250 / 10000;\n           autoPoolSubDist[a][1] = distPart * 1250 / 10000;\n           autoPoolSubDist[a][2] = distPart * 1000 / 10000;\n           autoPoolSubDist[a][3] = distPart * 750 / 10000;\n           autoPoolSubDist[a][4] = distPart * 750 / 10000;\n           autoPoolSubDist[a][5] = distPart * 750 / 10000;\n           autoPoolSubDist[a][6] = distPart * 750 / 10000;\n           autoPoolSubDist[a][7] = distPart * 1000 / 10000;\n           autoPoolSubDist[a][8] = distPart * 1250 / 10000;                                                                             \n           autoPoolSubDist[a][9] = distPart * 1250 / 10000;\n        } \n\n    }\n\n    function () external {\n        revert();\n    }\n\n    function regUser(uint32 _referrerID) public returns(bool)\n    {\n        if (_referrerID > lastIDofOldContract )\n        {\n            _regUser(_referrerID);\n        }\n        else\n        {\n            _regUser2(_referrerID);\n        }\n    }\n\n\n\n    function _regUser(uint32 _referrerID) internal returns(bool) \n    {\n        //this saves gas while using this multiple times\n        address msgSender = msg.sender; \n        uint32 originalReferrer = _referrerID;\n\n        //checking all conditions\n        require(!userInfos[msgSender].joined, 'User exist');\n        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) _referrerID = defaultRefID;\n        uint128 fct = 1;\n        _referrerID = userInfos[findFreeReferrer(userAddressByID[_referrerID])].id;\n\n\n        //transferring PAX tokens from smart user to smart contract for level 1\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[1]),\"token transfer failed\");\n        }\n        else\n        {\n            fct = 0;\n        }\n        \n        //update variables\n        userInfo memory UserInfo;\n        lastIDCount++;\n\n        UserInfo = userInfo({\n            joined: true,\n            id: lastIDCount,\n            referrerID: _referrerID,\n            directCount: 0,\n            referral: new address[](0)\n        });\n\n        userInfos[msgSender] = UserInfo;\n        userAddressByID[lastIDCount] = msg.sender;\n\n        userInfos[msgSender].levelExpired[1] = now + levelLifeTime;\n\n        userInfos[userAddressByID[_referrerID]].referral.push(msgSender);\n        userInfos[userAddressByID[originalReferrer]].directCount++;\n        totalGainInMainNetwork[owner] += systemDistPart * fct;\n        netTotalUserWithdrawable[owner] += systemDistPart * fct;\n\n        if(thisMonthEnd < now) startNextMonth();\n\n        uint16 lastDivPoolIndex = uint16(divPoolRecords.length -1);\n        divPoolRecords[lastDivPoolIndex].totalDividendCollection += globalDivDistPart * fct;\n        totalDivCollection += globalDivDistPart * fct;\n\n        address usr = userAddressByID[originalReferrer];\n        if(eligibleUser[usr] == 0 && userInfos[usr].directCount == 10)\n        {\n            eligibleUser[usr] = lastDivPoolIndex + 1;\n            divPoolRecords[lastDivPoolIndex].totalEligibleCount++;\n        }\n\n        require(payForLevel(1, msgSender,fct),\"pay for level fail\");\n        emit regLevelEv(msgSender, lastIDCount, _referrerID, now,userAddressByID[_referrerID], originalReferrer );\n        emit levelBuyEv(msgSender, 1, priceOfLevel[1] * fct, now);\n        require(updateNPayAutoPool(1,msgSender,fct),\"auto pool update fail\");\n        return true;\n    }\n\n\n    function _regUser2(uint32 _referrerID) internal returns(bool) \n    {\n        //this saves gas while using this multiple times\n        address msgSender = msg.sender; \n        uint32 originalReferrer = _referrerID;\n\n        updateFromOld(_referrerID);\n\n        //checking all conditions\n        require(!userInfos[msgSender].joined, 'User exist');\n        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) \n        {\n            _referrerID = defaultRefID;\n        }\n        else\n        {\n            _referrerID = userInfos[oldContractInerface(oldBMContractAddress).findFreeReferrer(userAddressByID[_referrerID])].id;\n        }\n        uint128 fct = 1;\n        \n\n\n        //transferring PAX tokens from smart user to smart contract for level 1\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[1]),\"token transfer failed\");\n        }\n        else\n        {\n            fct = 0;\n        }\n        \n        //update variables\n        userInfo memory UserInfo;\n        lastIDCount++;\n\n        UserInfo = userInfo({\n            joined: true,\n            id: lastIDCount,\n            referrerID: _referrerID,\n            directCount: 0,\n            referral: new address[](0)\n        });\n\n        userInfos[msgSender] = UserInfo;\n        userAddressByID[lastIDCount] = msg.sender;\n\n        userInfos[msgSender].levelExpired[1] = now + levelLifeTime;\n\n        userInfos[userAddressByID[_referrerID]].referral.push(msgSender);\n        userInfos[userAddressByID[originalReferrer]].directCount++;\n\n        totalGainInMainNetwork[owner] += systemDistPart * fct;\n        netTotalUserWithdrawable[owner] += systemDistPart * fct;\n\n        if(thisMonthEnd < now) startNextMonth();\n\n        uint lastDivPoolIndex = divPoolRecords.length -1;\n        divPoolRecords[lastDivPoolIndex].totalDividendCollection += globalDivDistPart * fct;\n        totalDivCollection += globalDivDistPart * fct;\n\n        address usr = userAddressByID[originalReferrer];\n        if(eligibleUser[usr] == 0 && userInfos[usr].directCount == 10)\n        {\n                eligibleUser[usr] = uint16(lastDivPoolIndex + 1);\n                divPoolRecords[lastDivPoolIndex].totalEligibleCount++;\n        }\n\n        require(payForLevel(1, msgSender,fct),\"pay for level fail\");\n        emit regLevelEv(msgSender, lastIDCount, _referrerID, now,userAddressByID[_referrerID], originalReferrer );\n        emit levelBuyEv(msgSender, 1, priceOfLevel[1] * fct, now);\n        require(updateNPayAutoPool(1,msgSender,fct),\"auto pool update fail\");\n        return true;\n    }\n\n\n\n\n    function viewCurrentMonthDividend() public view returns(uint256 amount, uint256 indexCount)\n    {\n        uint256 length = divPoolRecords.length;\n        return (divPoolRecords[length-1].totalDividendCollection,length);\n    }\n\n\n    function buyLevel(uint8 _level) public returns(bool){\n        \n        //this saves gas while using this multiple times\n        address msgSender = msg.sender;  \n\n        updateFromOld(userInfos[msgSender].id);\n      \n        \n        //checking conditions\n        require(userInfos[msgSender].joined, 'User not exist'); \n        uint128 fct=1;\n        require(_level >= 1 && _level <= 10, 'Incorrect level');\n        \n        //transfer tokens\n        if(!(msgSender==specialAddress1 || msgSender == specialAddress2)){\n            require( paxInterface(paxTokenAddress).transferFrom(msgSender, address(this), priceOfLevel[_level]),\"token transfer failed\");\n        }\n        else\n        {\n            fct = 0;\n        }\n        \n        \n        //updating variables\n        if(_level == 1) {\n            userInfos[msgSender].levelExpired[1] += levelLifeTime;\n        }\n        else {\n            for(uint l =_level - 1; l > 0; l--) require(userInfos[msgSender].levelExpired[l] >= now, 'Buy the previous level');\n\n            if(userInfos[msgSender].levelExpired[_level] == 0) userInfos[msgSender].levelExpired[_level] = now + levelLifeTime;\n            else userInfos[msgSender].levelExpired[_level] += levelLifeTime;\n        }\n\n        require(payForLevel(_level, msgSender,fct),\"pay for level fail\");\n        emit levelBuyEv(msgSender, _level, priceOfLevel[_level] * fct, now);\n        require(updateNPayAutoPool(_level,msgSender,fct),\"auto pool update fail\");\n        return true;\n    }\n    \n\n    function payForLevel(uint _level, address _user,uint128 fct) internal returns (bool){\n        address referer;\n\n\n        uint32 _id = userInfos[_user].referrerID;\n        if(_id <=lastIDofOldContract ) updateFromOld(_id );\n        if(_level == 1 || _level == 6) {\n            referer = userAddressByID[_id ];\n            payForUniLevel(_id,fct);\n            totalGainInMainNetwork[owner] += systemDistPart * fct;\n            netTotalUserWithdrawable[owner] += systemDistPart * fct;\n        }\n        else if(_level == 2 || _level == 7) {\n            referer = userAddressByID[_id];\n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id];          \n        }\n        else if(_level == 3 || _level == 8) {\n            referer = userAddressByID[_id];\n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id]; \n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id];             \n        }\n        else if(_level == 4 || _level == 9) {\n            referer = userAddressByID[_id];\n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id]; \n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id];\n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id];            \n        }\n        else if(_level == 5 || _level == 10) {\n            referer = userAddressByID[_id];\n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id]; \n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id];\n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id];\n            _id = userInfos[referer].referrerID;\n            if(_id<=lastIDofOldContract ) updateFromOld(_id );              \n            referer = userAddressByID[_id];            \n        }\n\n\n        if(!userInfos[referer].joined) referer = userAddressByID[defaultRefID];\n\n       \n        if(userInfos[referer].levelExpired[_level] >= now) {\n            totalGainInMainNetwork[referer] += distForLevel[_level] * fct;\n            netTotalUserWithdrawable[referer] += distForLevel[_level] * fct;\n            emit paidForLevelEv(referer, msg.sender, _level, distForLevel[_level] * fct, now);\n\n        }\n        else{\n\n            emit lostForLevelEv(referer, msg.sender, _level, distForLevel[_level] * fct, now);\n            payForLevel(_level, referer,fct);\n\n        }\n        return true;\n    }\n\n    function findFreeReferrer(address _user) public view returns(address) {\n        if(userInfos[_user].referral.length < maxDownLimit) return _user;\n\n        address[] memory referrals = new address[](126);\n        referrals[0] = userInfos[_user].referral[0];\n        referrals[1] = userInfos[_user].referral[1];\n\n        address freeReferrer;\n        bool noFreeReferrer = true;\n\n        for(uint i = 0; i < 126; i++) {\n            if(userInfos[referrals[i]].referral.length == maxDownLimit) {\n                if(i < 62) {\n                    referrals[(i+1)*2] = userInfos[referrals[i]].referral[0];\n                    referrals[(i+1)*2+1] = userInfos[referrals[i]].referral[1];\n                }\n            }\n            else {\n                noFreeReferrer = false;\n                freeReferrer = referrals[i];\n                break;\n            }\n        }\n\n        require(!noFreeReferrer, 'No Free Referrer');\n\n        return freeReferrer;\n    }\n\n    function payForUniLevel(uint32 _referrerID, uint128 fct) internal returns(bool)\n    {\n        uint256 endID = 21;\n        for (uint i = 0 ; i < endID; i++)\n        {\n            address usr = userAddressByID[_referrerID];\n            _referrerID = userInfos[usr].referrerID;\n            if(_referrerID<=lastIDofOldContract ) updateFromOld(_referrerID );\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\n            uint128 Amount = uniLevelDistPart[i + 1 ]  * fct;\n            totalGainInUniLevel[usr] += Amount;\n            netTotalUserWithdrawable[usr] += Amount;\n            emit paidForUniLevelEv(now,usr, Amount);\n        }\n        return true;\n    }\n\n    event withdrawMyGainEv(uint timeNow,address caller,uint totalAmount);\n    function withdrawMyDividendNAll() public returns(uint)\n    {\n        address payable caller = msg.sender;\n        require(userInfos[caller].joined, 'User not exist');\n        uint from = eligibleUser[caller];\n        uint128 totalAmount;\n        if(from > 0)\n        {\n            from --;\n            uint lastDivPoolIndex = divPoolRecords.length;\n            if( lastDivPoolIndex > 1 )\n            {\n                lastDivPoolIndex = lastDivPoolIndex -2;\n\n                for(uint i=0;i<150;i++)\n                {\n                    if(lastDivPoolIndex < i) break;\n                    uint16 curIndex = uint16(lastDivPoolIndex - i);\n                    if( curIndex >= from && !dividendReceived[curIndex][caller] )\n                    {\n                        totalAmount +=  ( divPoolRecords[curIndex].totalDividendCollection * 10000000000 /  divPoolRecords[curIndex].totalEligibleCount ) / 10000000000;\n                        dividendReceived[curIndex][caller] = true;\n                    }\n\n                }\n            }\n        }\n        if(totalAmount > 0)\n        {\n            totalDivCollection -= totalAmount;\n            emit payDividendEv(now, totalAmount, caller);\n        }\n        totalAmount = totalAmount + netTotalUserWithdrawable[caller];\n        netTotalUserWithdrawable[caller] = 0;\n        totalGainInAutoPool[caller] = 0;\n        totalGainInMainNetwork[caller] = 0;\n        totalGainInUniLevel[caller] = 0;\n        require(paxInterface(paxTokenAddress).transfer(msg.sender, totalAmount),\"token transfer failed\");\n        emit withdrawMyGainEv(now, caller, totalAmount);\n        \n    }\n\n    function viewMyDividendPotential(address user) public view returns(uint256 totalDivPotential, uint16 lastUnPaidIndex)\n    {\n        if (eligibleUser[user] > 0 )\n        {\n            uint16 i;\n            uint16 lastIndex = uint16(divPoolRecords.length -1);\n            for(i=1;i<50;i++)\n            {\n                lastUnPaidIndex = lastIndex - i;\n                if(dividendReceived[lastUnPaidIndex][user] == true) break;\n                totalDivPotential = totalDivPotential + ( divPoolRecords[lastUnPaidIndex].totalDividendCollection * 10000000000 /  divPoolRecords[lastUnPaidIndex].totalEligibleCount);               \n            }\n            return (totalDivPotential, lastUnPaidIndex + 1);\n        }\n        return (0,0);\n    }\n\n    function viewTimestampSinceJoined(address usr) public view returns(uint256[10] memory timeSinceJoined )\n    {\n        if(userInfos[usr].joined)\n        {\n            for(uint256 i=0;i<10;i++)\n            {\n                uint256 t = userInfos[usr].levelExpired[i+1];\n                if(t>now)\n                {\n                    timeSinceJoined[i] = (t-now);\n                }\n            }\n        }\n        return timeSinceJoined;\n    }\n\n    \n    \n    function divPoolAllLevel() public view returns (uint256[10] memory divPoolArray)\n    {\n        for(uint256 i=0;i<10;i++)\n        {\n            divPoolArray[i] = divPoolRecords[i].totalDividendCollection;\n        }\n        return divPoolArray;\n    }\n    \n\n    function startNextMonth() internal returns(bool)\n    {\n        require(thisMonthEnd < now,\"month end not reached\");\n        thisMonthEnd = uint32(now + oneMonthDuration);\n        divPoolRecord memory temp;\n        temp.totalEligibleCount = 1;\n        divPoolRecords.push(temp);\n        uint lastDivPoolIndex = divPoolRecords.length -1;\n        if (lastDivPoolIndex > 0)\n        {\n            divPoolRecords[lastDivPoolIndex].totalEligibleCount = divPoolRecords[lastDivPoolIndex -1].totalEligibleCount;\n        }\n        return (true);\n    }\n\n    function updateNPayAutoPool(uint8 _level,address _user, uint128 fct) internal returns (bool)\n    {\n        uint8 a = _level -1;\n        uint len = autoPoolLevel[a].length;\n        autoPool memory temp;\n        temp.userID = userInfos[_user].id;\n        temp.autoPoolParent = nextMemberFillIndex[a];       \n        autoPoolLevel[a].push(temp);        \n        uint idx = nextMemberFillIndex[a];\n\n        address payable usr = userAddressByID[autoPoolLevel[a][idx].userID];\n        if(usr == address(0)) usr = userAddressByID[defaultRefID];\n        for(uint i=0;i<10;i++)\n        {\n            uint128 amount = uint128(autoPoolSubDist[a][i]  * fct);\n            totalGainInAutoPool[usr] += amount;\n            netTotalUserWithdrawable[usr] += amount;\n            emit autoPoolPayEv(now, usr,a+1, amount, _user);\n            idx = autoPoolLevel[a][idx].autoPoolParent; \n            usr = userAddressByID[autoPoolLevel[a][idx].userID];\n            if(usr == address(0)) usr = userAddressByID[defaultRefID];\n        }\n\n        if(nextMemberFillBox[a] == 0)\n        {\n            nextMemberFillBox[a] = 1;\n        }   \n        else if (nextMemberFillBox[a] == 1)\n        {\n            nextMemberFillBox[a] = 2;\n        }\n        else\n        {\n            nextMemberFillIndex[a]++;\n            nextMemberFillBox[a] = 0;\n        }\n        autoPoolIndex[_user][_level - 1] = uint32(len);\n        emit updateAutoPoolEv(now, _level, len, _user);\n        return true;\n    }\n\n\n    function viewUserReferral(address _user) public view returns(address[] memory) {\n        return userInfos[_user].referral;\n    }\n\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\n        return userInfos[_user].levelExpired[_level];\n    }\n\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n    \n    \n    /*======================================\n    =            ADMIN FUNCTIONS           =\n    ======================================*/\n    \n    function changePAXaddress(address newPAXaddress) onlyOwner public returns(string memory){\n        //if owner makes this 0x0 address, then it will halt all the operation of the contract. This also serves as security feature.\n        //so owner can halt it in any problematic situation. Owner can then input correct address to make it all come back to normal.\n        paxTokenAddress = newPAXaddress;\n        return(\"PAX address updated successfully\");\n    }\n    \n    function changeDefaultRefID(uint32 newDefaultRefID) onlyOwner public returns(string memory){\n        //this ref ID will be assigned to user who joins without any referral ID.\n        defaultRefID = newDefaultRefID;\n        return(\"Default Ref ID updated successfully\");\n    }\n\n\n    //Below functions are only for swaping purpose\n\n    function setLastIDCount(uint32 _lastIDCountOfOldContract) public onlyOwner returns(bool)\n    {\n        require(lastIDCount == 0, \"can't run twice\");\n        lastIDCount = _lastIDCountOfOldContract;\n        lastIDofOldContract = uint16(_lastIDCountOfOldContract);\n        return true;\n    }\n\n    function updateAddresses(address _paxTokenAddress,address _oldBMContractAddress,address _specialAddress1,address _specialAddress2 ) public onlyOwner returns (bool)\n    {\n        require(!stopSwap , \"can't run now was for swaping only\");\n        paxTokenAddress = _paxTokenAddress;\n        oldBMContractAddress = _oldBMContractAddress;\n        specialAddress1 = _specialAddress1;\n        specialAddress2 = _specialAddress2;\n        return true;\n    }\n\n    function adjustDirectCount(uint16 _ID, uint16 _directCount, uint16 _eligibleCount) onlyOwner public returns(bool)\n    {\n        address usr = oldContractInerface(oldBMContractAddress).userAddressByID(_ID); \n        require(_ID <= lastIDofOldContract, \"invalid ID\");\n        require(!directUpdated[_ID], \"already updated for this ID\");\n        userInfos[usr].directCount = _directCount;\n        eligibleUser[usr] = _eligibleCount;\n        directUpdated[_ID] = true;\n        return true;\n    }\n\n    function updateFromOld(uint32 id) public returns (bool)\n    {\n        if( userAddressByID[id] == address(0) && id <= lastIDofOldContract )\n        {\n            userInfo memory tmp;\n            address payable usr = oldContractInerface(oldBMContractAddress).userAddressByID(id);\n            (tmp.joined,tmp.id,tmp.referrerID) = oldContractInerface(oldBMContractAddress).userInfos(usr);\n            userInfos[usr] = tmp;\n            userAddressByID[id] = usr;\n            uint _levelExpired;\n            for(uint i = 1; i <= 10; i++) {\n                _levelExpired = oldContractInerface(oldBMContractAddress).viewUserLevelExpired(usr, i);\n                userInfos[usr].levelExpired[i] = _levelExpired;\n            }             \n\n        }\n        return true;\n    }\n\n    function setDividendPoolData(uint128 _totalDividendCollection, uint128 _totalDividendCollection2 ) public onlyOwner returns(bool)\n    {\n        require(totalDivCollection == 0, \"can't run twice\");\n        divPoolRecord memory temp;\n        temp.totalDividendCollection = _totalDividendCollection;\n        divPoolRecords.push(temp);\n        divPoolRecord memory temp2;\n        temp2.totalDividendCollection = _totalDividendCollection2;\n        divPoolRecords.push(temp);        \n        return (true);\n    }\n\n\n    function setGlobalVariables() public onlyOwner returns(bool)\n    {\n        require(thisMonthEnd==0, \"can't be called twice\");\n        totalDivCollection = oldContractInerface(oldBMContractAddress).totalDivCollection();\n        thisMonthEnd = oldContractInerface(oldBMContractAddress).thisMonthEnd();\n        for(uint i =0; i < 10; i++)\n        {\n            nextMemberFillIndex[i] = oldContractInerface(oldBMContractAddress).nextMemberFillIndex(i);\n            nextMemberFillBox[i] = oldContractInerface(oldBMContractAddress).nextMemberFillBox(i);\n        }\n        return true;\n    }\n\n    function setAutoPool(uint8 level, uint recordCount) public onlyOwner returns(bool)\n    {\n        require(level <= 10 && level > 0, \"invalid level\");\n        require(!stopSwap , \"run time is over\");\n        uint8 a = level -1;\n        uint tmp = autoPoolCount[a];\n        autoPool memory temp;\n        for (uint i = autoPoolCount[a]; i<tmp + recordCount; i++)\n        {\n            (uint32 _id,uint32 _referrerID) = oldContractInerface(oldBMContractAddress).autoPoolLevel(a ,i);\n            if(_id > 1 )\n            {\n                temp.userID = _id;\n                temp.autoPoolParent = _referrerID;\n                autoPoolLevel[a].push(temp);\n                autoPoolIndex[userAddressByID[_id]][a] = uint32(autoPoolLevel[a].length -1);\n            }\n        }\n        autoPoolCount[a] = tmp + recordCount; \n        return true;\n    }\n    \n    function swapSetupFinished() public onlyOwner returns(bool)\n    {\n        stopSwap = true;\n        return true;\n    }\n    \n\n\n\n\n}"
    }
  }
}