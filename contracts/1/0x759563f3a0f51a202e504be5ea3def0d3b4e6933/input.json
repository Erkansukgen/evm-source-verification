{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/BANCOR_HELPER/BancorPoolParser.sol.sol":{"content":"pragma solidity ^0.6.12;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IGetBancorData {\n  function getBancorContractAddresByName(string calldata _name) external view returns (address result);\n}\n\ninterface IBancorFormula {\n  function fundCost(uint256 _supply,\n                    uint256 _reserveBalance,\n                    uint32 _reserveRatio,\n                    uint256 _amount)\n    external\n    view returns (uint256);\n}\n\ninterface IBancorConverter {\n  function reserveRatio() external view returns(uint32);\n  function connectorTokens(uint index) external view returns(address);\n  function getConnectorBalance(address _connectorToken) external view returns (uint256);\n  function connectorTokenCount() external view returns (uint16);\n}\n\n\ninterface ISmartToken {\n  function owner() external view returns(address);\n  function totalSupply() external view returns(uint256);\n}\n\ninterface BancorNetworkInterface {\n    function conversionPath(\n      address _sourceToken,\n      address _targetToken\n    ) external view returns (address[] memory);\n\n    function rateByPath(\n        address[] memory _path,\n        uint256 _amount\n    ) external view returns (uint256);\n}\n\ncontract BancorPoolParser {\n  using SafeMath for uint256;\n  IGetBancorData public GetBancorData;\n\n  constructor(address _GetBancorData) public {\n    GetBancorData = IGetBancorData(_GetBancorData);\n  }\n\n  // Works for new Bancor pools\n  // parse total value of pool conenctors\n  function parseConnectorsByPool(address _from, address _to, uint256 poolAmount)\n    external\n    view\n    returns(uint256)\n  {\n     // get common data\n     address converter = ISmartToken(address(_from)).owner();\n     uint16 connectorTokenCount = IBancorConverter(converter).connectorTokenCount();\n     uint256 poolTotalSupply = ISmartToken(address(_from)).totalSupply();\n     uint32 reserveRatio =  IBancorConverter(converter).reserveRatio();\n\n     // get contracts insnance\n     BancorNetworkInterface bancorNetwork = BancorNetworkInterface(\n       GetBancorData.getBancorContractAddresByName(\"BancorNetwork\")\n     );\n     IBancorFormula bancorFormula = IBancorFormula(\n       GetBancorData.getBancorContractAddresByName(\"BancorFormula\")\n     );\n\n     return calculateTotalSum(\n       converter,\n       poolTotalSupply,\n       reserveRatio,\n       connectorTokenCount,\n       bancorNetwork,\n       bancorFormula,\n       _to,\n       poolAmount\n       );\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function DEBUGparseConnectorsByPool(address _from)\n    external\n    view\n    returns(address converter,\n    uint16 connectorTokenCount, \n    uint256 poolTotalSupply\n\n    )\n  {\n     // get common data\n     converter = ISmartToken(address(_from)).owner();\n    connectorTokenCount = IBancorConverter(converter).connectorTokenCount();\n    poolTotalSupply = ISmartToken(address(_from)).totalSupply();\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n  // internal helper\n  function calculateTotalSum(\n    address converter,\n    uint256 poolTotalSupply,\n    uint32 reserveRatio,\n    uint16 connectorTokenCount,\n    BancorNetworkInterface bancorNetwork,\n    IBancorFormula bancorFormula,\n    address _to,\n    uint256 poolAmount\n    )\n    internal\n    view\n    returns(uint256 totalValue)\n  {\n    for(uint16 i = 0; i < connectorTokenCount; i++){\n      // get amount of token in pool by pool input\n      address connectorToken = IBancorConverter(converter).connectorTokens(i);\n      uint256 connectorBalance = IBancorConverter(converter).getConnectorBalance(address(connectorToken));\n      uint256 amountByShare = bancorFormula.fundCost(poolTotalSupply, connectorBalance, reserveRatio, poolAmount);\n\n      // get ratio of pool token\n      address[] memory path = bancorNetwork.conversionPath(address(connectorToken), _to);\n      totalValue = totalValue.add(bancorNetwork.rateByPath(path, amountByShare));\n    }\n  }\n}\n"}}}