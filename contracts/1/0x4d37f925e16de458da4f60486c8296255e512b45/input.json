{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/VasaPowerSwitch.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract VasaPowerSwitch {\n\n    uint256 private _totalMintable;\n    uint256[] private _timeWindows;\n    uint256[][] private _multipliers;\n\n    address private _doubleProxy;\n\n    address private _oldTokenAddress;\n\n    uint256 private _startBlock;\n\n    constructor(address doubleProxyAddress, address oldTokenAddress, uint256 startBlock, uint256 totalMintable, uint256[] memory timeWindows, uint256[] memory multipliers, uint256[] memory dividers) public {\n        _startBlock = startBlock;\n        _doubleProxy = doubleProxyAddress;\n        _oldTokenAddress = oldTokenAddress;\n        _totalMintable = totalMintable;\n        _timeWindows = timeWindows;\n        assert(timeWindows.length == multipliers.length && multipliers.length == dividers.length);\n        for(uint256 i = 0; i < multipliers.length; i++) {\n            _multipliers.push([multipliers[i], dividers[i]]);\n        }\n    }\n\n    function totalMintable() public view returns(uint256) {\n        return block.number > _timeWindows[_timeWindows.length - 1] ? 0 :_totalMintable;\n    }\n\n    function startBlock() public view returns(uint256) {\n        return _startBlock;\n    }\n\n    function doubleProxy() public view returns(address) {\n        return _doubleProxy;\n    }\n\n    function setDoubleProxy(address newDoubleProxy) public {\n        require(IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(msg.sender), \"Unauthorized Action!\");\n        _doubleProxy = newDoubleProxy;\n    }\n\n    function calculateMintable(uint256 amount) public view returns(uint256) {\n        if(amount == 0 || block.number > _timeWindows[_timeWindows.length - 1]) {\n            return 0;\n        }\n        uint256 i = 0;\n        for(i; i < _timeWindows.length; i++) {\n            if(block.number <= _timeWindows[i]) {\n                break;\n            }\n        }\n        uint256 mintable = i >= _timeWindows.length ? 0 : ((amount * _multipliers[i][0]) / _multipliers[i][1]);\n        return mintable > _totalMintable ? _totalMintable : mintable;\n    }\n\n    function length() public view returns(uint256) {\n        return _timeWindows.length;\n    }\n\n    function timeWindow(uint256 i) public view returns(uint256, uint256, uint256) {\n        return (_timeWindows[i], _multipliers[i][0], _multipliers[i][1]);\n    }\n\n    function getContextInfo(uint256 amount) public view returns (uint256 timeWindow, uint256 multiplier, uint256 divider, uint256 mintable) {\n        if(amount == 0 || block.number > _timeWindows[_timeWindows.length - 1]) {\n            return (0, 0, 0, 0);\n        }\n        uint256 i = 0;\n        for(i; i < _timeWindows.length; i++) {\n            if(block.number <= _timeWindows[i]) {\n                break;\n            }\n        }\n        if(i < _timeWindows.length) {\n            timeWindow = _timeWindows[i];\n            multiplier = _multipliers[i][0];\n            divider = _multipliers[i][1];\n        }\n        mintable = i >= _timeWindows.length ? 0 : ((amount * multiplier) / divider);\n        mintable = mintable > _totalMintable ? _totalMintable : mintable;\n    }\n\n    function vasaPowerSwitch(uint256 senderBalanceOf) public {\n        require(block.number >= _startBlock, \"Switch still not started!\");\n\n        IERC20 oldToken = IERC20(_oldTokenAddress);\n\n        uint256 mintableAmount = calculateMintable(senderBalanceOf);\n        require(mintableAmount > 0, \"Zero tokens to mint!\");\n\n        oldToken.transferFrom(msg.sender, address(this), senderBalanceOf);\n        oldToken.burn(senderBalanceOf);\n        _totalMintable -= senderBalanceOf;\n        IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).submit(\"mintAndTransfer\", abi.encode(address(0), 0, mintableAmount, msg.sender));\n    }\n}\n\ninterface IMVDProxy {\n    function getMVDFunctionalitiesManagerAddress() external view returns(address);\n    function submit(string calldata codeName, bytes calldata data) external payable returns(bytes memory returnData);\n}\n\ninterface IMVDFunctionalitiesManager {\n    function isAuthorizedFunctionality(address functionality) external view returns(bool);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function burn(uint256 amount) external;\n}\n\ninterface IDoubleProxy {\n    function proxy() external view returns(address);\n}"
    }
  }
}