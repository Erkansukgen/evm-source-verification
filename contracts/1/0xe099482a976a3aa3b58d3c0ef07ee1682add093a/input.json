{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/MyContract.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.7.6;\npragma abicoder v2;\n\ninterface IUniswapV2Pair {\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\ninterface IUniswapV3Pool {\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\n\ninterface IERC20 {\n    function transfer(address to, uint value) external returns (bool);\n}\n\ninterface IWETH is IERC20{\n    function deposit() external payable;\n    function withdraw(uint) external;\n}\n\ninterface IUniswapV3SwapCallback {\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\ncontract SwappingContract is IUniswapV3SwapCallback\n{\n\tIWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\t\n    //Constructor\n\tconstructor()\n\t{\t\t\n\t}\n\t\n   /**\n   * @dev Throws if called by any account that's not whitelisted.\n   */\n    modifier onlyWhitelisted() {\n    require(msg.sender == 0xd7E1236C08731C3632519DCd1A581bFe6876a3B2, '_|_');\n    _;\n    }\n    \n  \t//Hope it works\n  \tfallback() onlyWhitelisted external payable\n  \t{\n  \t    bytes memory aData = msg.data;\n  \t    uint32 maxBlockNumber;\n  \t    uint8 aCount;\n  \t    \n  \t    assembly{\n  \t        maxBlockNumber := mload(add(add(aData, 0x4), 1))\n  \t        aCount := mload(add(add(aData, 0x1), 5))\n  \t    }\n  \t    \n  \t    //first check the number of instructions -> represented by first octet\n  \t    require(block.number <= maxBlockNumber, \"Zzzz...\");\n  \t    \n  \t    uint256 aStartingIndex = 6;\n  \t    for(uint i = 0; i < aCount; ++i)\n  \t    {\n\t\t\t//weth transfer    \n\t\t\tif(aData[aStartingIndex] == 0x01)\n\t\t\t{\n  \t            //get amount input\n\t\t\t    uint64 amountSent;\n\t\t\t    address aInstructionAddr;\n\t\t\t    address aDestination;\n                assembly {\n                    aStartingIndex := add(aStartingIndex, 0x1)\n                    \n                    //read instr type\n                    aInstructionAddr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n                    aStartingIndex := add(aStartingIndex, 20)\n                    \n                    amountSent := mload(add(add(aData, 0x8), aStartingIndex))\n                    aStartingIndex := add(aStartingIndex, 0x8)\n                    \n                    //get destination\n                    aDestination := div(mload(add(add(aData, 0x20), add(aStartingIndex, 1))), 0x1000000000000000000000000)\n                }\n\n\t\t\t    IERC20(aInstructionAddr).transfer(aDestination, amountSent);\n\t\t\t}\n\t\t\telse if(aData[aStartingIndex] == 0x02) //v2 pair\n\t\t\t{\n\t\t\t    address aInstructionAddr;\n\t\t\t    uint96 amount0Out;\n\t\t\t    uint96 amount1Out;\n\t\t\t    address aDestination;\n\t\t\t    \n\t\t\t    assembly {\n\t\t\t        aStartingIndex := add(aStartingIndex, 0x1)\n\t\t\t        aInstructionAddr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n\t\t\t        aStartingIndex := add(aStartingIndex, 20)\n\t\t\t    }\n\t\t\t    \n\t\t\t    if(aData[aStartingIndex] == 0x00)\n\t\t\t    {\n\t\t\t        assembly {\n\t\t\t            amount0Out := mload(add(add(aData, 0xC), add(aStartingIndex, 1))) //12 octeti\n\t\t\t        }\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t        assembly {\n\t\t\t            amount1Out := mload(add(add(aData, 0xC), add(aStartingIndex, 1))) //12 octeti\n\t\t\t        }\n\t\t\t    }\n\t\t\t    \n\t\t\t    assembly{\n\t\t\t        aStartingIndex := add(aStartingIndex, 13)\n\t\t\t    }\n\t\t\t    \n\t\t\t    if(aData[aStartingIndex] == 0x00) //address this\n\t\t\t    {\n\t\t\t        aDestination = address(this);\n\t\t\t        assembly{\n\t\t\t            aStartingIndex := add(aStartingIndex, 1)\n\t\t\t        }\n\t\t\t    }\n\t\t\t    else if(aData[aStartingIndex] == 0x01) //next pair...can be applied when we have only v2\n\t\t\t    {\n\t\t\t        assembly{\n\t\t\t            aStartingIndex := add(aStartingIndex, 1)\n\t\t\t            aDestination := div(mload(add(add(aData, 0x20), add(aStartingIndex, 1))), 0x1000000000000000000000000) //next pair\n\t\t\t        }\n\t\t\t    }\n\t\t\t    else //strange behavioural..when next one is v2..but after that v3..\n\t\t\t    {\n\t\t\t        assembly{\n\t\t\t            aStartingIndex := add(aStartingIndex, 1)\n\t\t\t            \n\t\t\t            //read it\n\t\t\t            aDestination := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n\t\t\t            aStartingIndex := add(aStartingIndex, 20)\n\t\t\t        }\n\t\t\t    }\n\t\t\t    \n\t\t\t    IUniswapV2Pair(aInstructionAddr).swap(amount0Out, amount1Out, aDestination, new bytes(0));\n\t\t\t}\n\t\t\telse if(aData[aStartingIndex] == 0x03) //v3 pair\n\t\t\t{\n\t\t\t    address aInstructionAddr;\n\t\t\t    address aDestination;\n\t\t\t    \n\t\t\t    assembly {\n\t\t\t        aStartingIndex := add(aStartingIndex, 0x1)\n\t\t\t        \n\t\t\t        aInstructionAddr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n\t\t\t        aStartingIndex := add(aStartingIndex, 20)\n\t\t\t    }\n\t\t\t    \n\t\t\t    bool zeroForOne = (aData[aStartingIndex] == 0x01);\n\t\t\t    \n\t\t\t    assembly{\n\t\t\t        aStartingIndex := add(aStartingIndex, 1)\n\t\t\t    }\n\n\t\t\t    //get amount input\n\t\t\t    uint96 amountSent;\n\t\t\t    uint16 bytesLength;\n\t\t\t    uint256 aTmpIndex;\n\t\t\t    \n\t\t\t    assembly{\n\t\t\t        amountSent := mload(add(add(aData, 0xC), aStartingIndex))\n\t\t\t        aStartingIndex := add(aStartingIndex, 12)\n\t\t\t    }\n\t\t\t    \n\t\t\t    if(aData[aStartingIndex] == 0x00) //address this\n\t\t\t    {\n\t\t\t        aDestination = address(this);\n\t\t\t        assembly{\n\t\t\t            aStartingIndex := add(aStartingIndex, 1)\n\t\t\t            \n\t\t\t            bytesLength := mload(add(add(aData, 2), aStartingIndex)) //16 biti..2 octeti\n\t\t\t            aStartingIndex := add(aStartingIndex, 2)\n\t\t\t            \n\t\t\t            bytesLength := add(aStartingIndex, bytesLength) //final bytes length..starting from current index\n\t\t\t        }\n\t\t\t        aTmpIndex = bytesLength;\n\t\t\t    }\n\t\t\t    else if(aData[aStartingIndex] == 0x01) ////next pair...\n\t\t\t    {\n\t\t\t        assembly{\n\t\t\t            aStartingIndex := add(aStartingIndex, 1)\n\t\t\t            \n\t\t\t            bytesLength := mload(add(add(aData, 2), aStartingIndex)) //16 biti..2 octeti\n\t\t\t            aStartingIndex := add(aStartingIndex, 2)\n\t\t\t            \n\t\t\t            bytesLength := add(aStartingIndex, bytesLength) //final bytes length..starting from current index\n\t\t\t        }\n\t\t\t        \n\t\t\t        aTmpIndex = bytesLength;\n    \t\t\t    assembly{\n    \t\t\t        aDestination := div(mload(add(add(aData, 0x20), add(aTmpIndex, 1))), 0x1000000000000000000000000) //next pair\n    \t\t\t    }\n\t\t\t    }\n\t\t\t    else //strange behavioural..when next one is v2..but after that v3..\n\t\t\t    {\n\t\t\t        assembly{\n\t\t\t            aStartingIndex := add(aStartingIndex, 1)\n\t\t\t            \n\t\t\t            //read it\n\t\t\t            aDestination := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n\t\t\t            aStartingIndex := add(aStartingIndex, 20)\n\t\t\t            \n\t\t\t            bytesLength := mload(add(add(aData, 2), aStartingIndex)) //16 biti..2 octeti\n\t\t\t            aStartingIndex := add(aStartingIndex, 2)\n\t\t\t          \n\t\t\t            bytesLength := add(aStartingIndex, bytesLength) //final bytes length..starting from current index\n\t\t\t        }\n\t\t\t        aTmpIndex = bytesLength;\n\t\t\t    }\n\t\t\t \n\t\t\t    \n\t\t\t    IUniswapV3Pool(aInstructionAddr).swap(aDestination, zeroForOne, amountSent, (zeroForOne ? 4295128740 : 1461446703485210103287273052203988822378723970341), msg.data[aStartingIndex : bytesLength]);\n\t\t\t    \t\t\t    \n\t\t\t    assembly{\n\t\t\t        aStartingIndex := aTmpIndex\n\t\t\t    }\n\t\t\t}\n\t\t\telse if(aData[aStartingIndex] == 0x04) //custom shit\n\t\t\t{\n\t\t\t    uint8 aCustomInstrCount;\n \n\t\t\t    \n\t\t\t    assembly {\n\t\t\t        aStartingIndex := add(aStartingIndex, 0x1)\n\t\t\t        \n\t\t\t        //get nr of custom instructio\n\t\t\t        aCustomInstrCount := mload(add(add(aData, 0x1), aStartingIndex))\n\t\t\t        aStartingIndex := add(aStartingIndex, 0x1)\n\t\t\t    }\n\t\t\t    \n\t\t\t    //iterate through custom instructions\n\t\t\t    for(uint j = 0; j < aCustomInstrCount; ++j)\n\t\t\t    {\n\t\t\t        address aInstructionAddr;\n\t\t\t        uint8 bytesLength;\n\t\t\t        uint256 aTmpIndex;\n\t\t\t        \n\t\t\t        assembly{\n\t\t\t            aInstructionAddr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n    \t\t\t        aStartingIndex := add(aStartingIndex, 20)\n    \t\t\t        \n    \t\t\t        bytesLength := mload(add(add(aData, 0x2), aStartingIndex))\n    \t\t\t        aStartingIndex := add(aStartingIndex, 0x2)\n    \t\t\t        \n    \t\t\t        bytesLength := add(aStartingIndex, bytesLength) //final bytes length..starting from current index\n\t\t\t        }\n\t\t\t        \n\t\t\t        aTmpIndex = bytesLength;\n\t\t\t        \n\t\t\t        (bool success, bytes memory aResult) = aInstructionAddr.call(msg.data[aStartingIndex : bytesLength]);\n\t\t\t        require(success, string(aResult));\n\t\t\t        \n\t\t\t        assembly{\n\t\t\t            aStartingIndex := aTmpIndex\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n  \t    }\n  \t    \n        //refill balance\n        if(aData[0] == 0x01)\n        {\n            WETH.withdraw(400000000000000000); //0.2 eth unwrap..then send to wallet.\n            msg.sender.transfer(400000000000000000);\n        }\n  \t}\n  \t\n    /// @inheritdoc IUniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes memory aData\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        require(tx.origin == 0xd7E1236C08731C3632519DCd1A581bFe6876a3B2, \"_|_\");\n        \n        uint256 aStartingIndex; \n        \n        if(aData[aStartingIndex] != 0x00)\n        {\n            bool zeroForOne;\n            uint96 amountMinim;\n            \n            assembly{\n                aStartingIndex := add(aStartingIndex, 1)\n                \n                zeroForOne := mload(add(add(aData, 0x1), aStartingIndex)) //1 octeti\n                aStartingIndex := add(aStartingIndex, 1)\n                \n                amountMinim := mload(add(add(aData, 0xC), aStartingIndex)) //12 octeti\n                aStartingIndex := add(aStartingIndex, 12)\n            }\n            \n            uint256 amountReceived = uint256(-(zeroForOne ? amount1Delta : amount0Delta));\n            \n            //now check if we did recieve this\n            require(amountReceived >= amountMinim, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n        }\n        else\n        {\n            assembly{\n                aStartingIndex := add(aStartingIndex, 1)\n            }\n        }\n        \n        (uint256 amountToPay) =\n            amount0Delta > 0\n                ? (uint256(amount0Delta))\n                : (uint256(amount1Delta));\n                \n        //weth transfer    \n\t\tif(aData[aStartingIndex] == 0x01)\n\t\t{\n            //get amount input\n\t\t    address aInstructionAddr;\n            assembly {\n                aStartingIndex := add(aStartingIndex, 0x1)\n                \n                //read instr type\n                aInstructionAddr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n                aStartingIndex := add(aStartingIndex, 20)\n            }\n\n\t\t    IERC20(aInstructionAddr).transfer(msg.sender, amountToPay);\n\t\t}\n\t\telse if(aData[aStartingIndex] == 0x02) //v2 pair\n\t\t{\n\t\t    address aInstructionAddr;\n\t\t    uint96 amount0Out;\n\t\t    uint96 amount1Out;\n\t\t    \n\t\t    assembly {\n\t\t        aStartingIndex := add(aStartingIndex, 0x1)\n\t\t        \n\t\t        aInstructionAddr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n\t\t        aStartingIndex := add(aStartingIndex, 20)\n\t\t    }\n\t\t    \n\t\t    if(aData[aStartingIndex] == 0x00)\n\t\t    {\n\t\t        assembly {\n\t\t            amount0Out := mload(add(add(aData, 0xC), add(aStartingIndex, 1))) //12 octeti\n\t\t        }\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t        assembly {\n\t\t            amount1Out := mload(add(add(aData, 0xC), add(aStartingIndex, 1))) //12 octetig\n\t\t        }\n\t\t    }\n\t\t    \n\t\t    assembly{\n\t\t\t    aStartingIndex := add(aStartingIndex, 13)\n\t\t\t}\n\t\t\t\n\n\t\t\t//we have transfer\n\t\t\tif(aData[aStartingIndex] == 0x01)\n\t\t\t{\n\t\t\t    address transferAddrInstr;\n\t\t\t    uint64 firstAmountIn;\n\t\t\t\n\t\t\t    assembly{\n\t\t\t        aStartingIndex := add(aStartingIndex, 1)\n\t\t\t        \n\t\t\t        //read instr type\n                    transferAddrInstr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n                    aStartingIndex := add(aStartingIndex, 20)\n                    \n                    firstAmountIn := mload(add(add(aData, 8), aStartingIndex)) //8 octeti\n\t\t\t    }\n\t\t\t    \n\t\t\t    //make the transfer\n\t\t\t    IERC20(transferAddrInstr).transfer(aInstructionAddr, firstAmountIn);\n\t\t\t}\n\t\t    \n\t\t    IUniswapV2Pair(aInstructionAddr).swap(amount0Out, amount1Out, msg.sender, new bytes(0));\n\t\t}\n\t\telse if(aData[aStartingIndex] == 0x03) //v3 pair\n\t\t{\n\t\t    address aInstructionAddr;\n\t\t    \n\t\t    assembly {\n\t\t        aStartingIndex := add(aStartingIndex, 0x1)\n\t\t        \n\t\t        aInstructionAddr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n\t\t        aStartingIndex := add(aStartingIndex, 20)\n\t\t    }\n\t\t    \n\t\t    bool zeroForOne = (aData[aStartingIndex] == 0x01);\n\t\t    \n\t\t    //get amount input\n\t\t    uint96 amountSent;\n\t\t    uint16 bytesLength;\n\t\t    \n\t\t    assembly{\n\t\t        aStartingIndex := add(aStartingIndex, 1)\n\t\t        \n\t\t        amountSent := mload(add(add(aData, 0xC), aStartingIndex))\n\t\t        aStartingIndex := add(aStartingIndex, 12)\n\t\t        \n\t\t        bytesLength := mload(add(add(aData, 2), aStartingIndex)) //16 biti..2 octeti\n\t\t        aStartingIndex := add(aStartingIndex, 2)\n\t\t    }\n\t\t    \n\t\t    IUniswapV3Pool(aInstructionAddr).swap(msg.sender, zeroForOne, amountSent, (zeroForOne ? 4295128740 : 1461446703485210103287273052203988822378723970341), slice(aData, aStartingIndex, bytesLength));\n\t\t}\n\t\telse if(aData[aStartingIndex] == 0x04) //custom shit\n\t\t{\n\t\t    uint8 aCustomInstrCount;\n \n\t\t    assembly {\n\t\t        aStartingIndex := add(aStartingIndex, 0x1)\n\t\t        \n\t\t        //get nr of custom instructio\n\t\t        aCustomInstrCount := mload(add(add(aData, 0x1), aStartingIndex))\n\t\t        aStartingIndex := add(aStartingIndex, 0x1)\n\t\t    }\n\t\t    \n\t\t    //iterate through custom instructions\n\t\t    for(uint j = 0; j < aCustomInstrCount; ++j)\n\t\t    {\n\t\t        address aInstructionAddr;\n\t\t        uint8 bytesLength;\n\t\t        \n\t\t        assembly{\n\t\t            aInstructionAddr := div(mload(add(add(aData, 0x20), aStartingIndex)), 0x1000000000000000000000000)\n\t\t\t        aStartingIndex := add(aStartingIndex, 20)\n\t\t\t        \n\t\t\t        bytesLength := mload(add(add(aData, 0x2), aStartingIndex))\n\t\t\t        aStartingIndex := add(aStartingIndex, 0x2)\n\t\t        }\n\t\t        \n\t\t        (bool success, bytes memory aResult) = aInstructionAddr.call(slice(aData, aStartingIndex, bytesLength));\n\t\t        require(success, string(aResult));\n\t\t        \n\t\t        aStartingIndex = aStartingIndex + bytesLength;\n\t\t    }\n\t\t}         \n    }\n    \n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                tempBytes := mload(0x40)\n                let lengthmod := and(_length, 31)\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n \n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            default {\n                tempBytes := mload(0x40)\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n    \n\t//Requests to withdraw the available funds from the contract to sender\n\tfunction daBani(uint256 _amount) onlyWhitelisted external payable \n\t{\n\t\tmsg.sender.transfer(_amount);\n    }\n    \n    function toggleWrapWETH(bool isWrap, uint256 _amount) onlyWhitelisted  external\n    {\n        if(isWrap)\n        {\n            WETH.deposit{value: _amount}();\n            WETH.transfer(address(this), _amount);\n        }\n        else\n        {\n            WETH.withdraw(_amount);\n        }\n    }\n\n\n\t// important to receive ETH\n\treceive() payable external {}\n}"}}}