{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/hegic.sol": {
      "content": "pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './lib/SafeMath.sol';\r\n\r\n\r\ninterface IWETH {\r\n    function withdraw(uint) external;\r\n    function deposit() external payable;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    // function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\n\r\n\r\ninterface v2pool{\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface bondindcurve{\r\n    function s(uint256 x0, uint256 x1) external view returns (uint256);\r\n    function buy(uint256 tokenAmount) external payable;\r\n    // function buy(uint256 tokenAmount) external;\r\n    function sell(uint256 tokenAmount) external;\r\n}\r\n\r\n\r\n\r\n\r\ncontract hegicarb {\r\n    using SafeMath for uint;\r\n    \r\n    address payable public owner;\r\n    \r\n    uint256 private commissionshare = 20;\r\n    // main net\r\n    \r\n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n\r\n        // approve the hegic to 2 curves\r\n        IERC20(address(0x584bC13c7D411c00c01A62e8019472dE68768430)).approve(address(0x69493B637c9b1B4D9EB3a2b97B89389467cF0a20), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        IERC20(address(0x584bC13c7D411c00c01A62e8019472dE68768430)).approve(address(0xa9d47c5E5a2b6FE290723e9CBCa5C406Fdf9000b), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n        // approve the usdc to usdc curve\r\n        IERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)).approve(address(0xa9d47c5E5a2b6FE290723e9CBCa5C406Fdf9000b), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n\r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n\r\n    function set_share(uint256 target) external onlyowner{\r\n        commissionshare = target;\r\n    }\r\n\r\n\r\n\r\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\r\n    \r\n        (uint256 arbflag, uint256 amount1, uint256 amount2, uint256 amount3)  = abi.decode(_data, (uint256, uint256, uint256, uint256));\r\n\r\n        if(arbflag == 0){\r\n            // ethcurve, sell the hegic and pay back eth\r\n            // eth -> hegic --> eth\r\n            bondindcurve(address(0x69493B637c9b1B4D9EB3a2b97B89389467cF0a20)).sell(amount1);\r\n            IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).deposit{value: address(this).balance}();\r\n            _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), msg.sender, amount2);\r\n\r\n        }else if(arbflag == 1){\r\n            // ethcurve, buy on hegic and sell on v2\r\n            // eth ---> hegic -> eth\r\n            IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(amount1);\r\n            bondindcurve(address(0x69493B637c9b1B4D9EB3a2b97B89389467cF0a20)).buy{value: amount1}(amount2);\r\n            _safeTransfer(address(0x584bC13c7D411c00c01A62e8019472dE68768430), msg.sender, amount2); // pay back hegic to the pool for eth\r\n        }else if(arbflag == 3){\r\n            // usdc curve, eth -> hegic ----> usdc -> eth\r\n            bondindcurve(address(0xa9d47c5E5a2b6FE290723e9CBCa5C406Fdf9000b)).sell(amount1);\r\n            uint256 usdc_out = IERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)).balanceOf(address(this));\r\n            _safeTransfer(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), address(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0), usdc_out);\r\n            // sell the usdc to usdc - eth pool\r\n            (uint reserve0,uint reserve1) = getpoolreserve(address(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0)); // usdc 0, eth 1\r\n            uint256 ethout = getAmountOut(usdc_out, reserve0, reserve1);\r\n            v2pool(address(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0)).swap(0, ethout, address(this), new bytes(0));\r\n            _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), msg.sender, amount2);\r\n        }else if(arbflag == 2){\r\n            // eth -> usdc ---> hegic -> eth\r\n            bondindcurve(address(0xa9d47c5E5a2b6FE290723e9CBCa5C406Fdf9000b)).buy(amount3); // amount1 target hegic buy amount\r\n            // transfer hegic to hegic -eth pool\r\n            _safeTransfer(address(0x584bC13c7D411c00c01A62e8019472dE68768430), address(0x1273aD5D8f3596A7a39EfDb5a4b8f82E8F003fc3), amount3);\r\n            // sell the hegic to hegic - eth pool\r\n            (uint reserve0,uint reserve1) = getpoolreserve(address(0x1273aD5D8f3596A7a39EfDb5a4b8f82E8F003fc3)); \r\n            uint256 ethout = getAmountOut(amount3, reserve0, reserve1);\r\n            v2pool(address(0x1273aD5D8f3596A7a39EfDb5a4b8f82E8F003fc3)).swap(0, ethout, address(this), new bytes(0));\r\n            _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), msg.sender, amount2);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function arb(address flashloabpool, uint256 flashloanamount, uint256 flag, uint256 arbflag, uint256 payback_amount, uint256 param3) public payable{\r\n        require(block.number <= msg.value, \"s\");\r\n\r\n        uint256 gasstart = gasleft();\r\n\r\n        bytes memory data = abi.encode(arbflag, flashloanamount, payback_amount, param3);\r\n\r\n        if(flag == 0){\r\n            v2pool(flashloabpool).swap(flashloanamount, 0, address(this), data);\r\n        } else if(flag == 1){\r\n\r\n            v2pool(flashloabpool).swap(0, flashloanamount, address(this), data);\r\n        } \r\n\r\n\r\n        if(arbflag == 0 || arbflag == 2 || arbflag == 3){\r\n            uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n            \r\n            require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n            \r\n            _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), msg.sender, weth_balance);\r\n\r\n        }else if(arbflag == 1 ){\r\n\r\n            uint256 eth_balance = address(this).balance;\r\n            \r\n            require(eth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n            \r\n            msg.sender.transfer(eth_balance);\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    } \r\n  \r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    function getpoolreserve(address pooladdr) private returns(uint reserve0, uint reserve1){\r\n        bytes memory returnData;\r\n        (, returnData) = pooladdr.staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n        (reserve0, reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve, hegic - 0, weth 1\r\n\r\n    }\r\n\r\n\r\n    function ethcurve_detect(uint256 lowerbound, uint256 upperbound, uint256 step, uint256 soldamount) public returns(uint256 best_buy_profit, uint256 best_buy_in, uint256 best_eth_out, uint256 best_sell_profit, uint256 best_sell_in, uint256 best_hegic_out){\r\n\r\n        (uint reserve0,uint reserve1) = getpoolreserve(address(0x1273aD5D8f3596A7a39EfDb5a4b8f82E8F003fc3));\r\n        \r\n        uint256 amountin = lowerbound; // this is the hegic amount\r\n        uint256 eth_amount;\r\n        uint256 eth_out;\r\n\r\n\r\n\r\n        // buy on curve and sell on v2\r\n\r\n        while(amountin < upperbound){\r\n\r\n            // buy on curve, the amount eth in\r\n            eth_amount = bondindcurve(address(0x69493B637c9b1B4D9EB3a2b97B89389467cF0a20)).s(soldamount , soldamount + amountin);\r\n\r\n            // sell on v2, eth amountout\r\n            eth_out = getAmountOut(amountin, reserve0, reserve1);\r\n\r\n            if(eth_out < eth_amount){\r\n                break;\r\n            }\r\n\r\n            if(eth_out - eth_amount > best_buy_profit){\r\n                best_buy_profit = eth_out - eth_amount;\r\n                best_buy_in = amountin;\r\n                best_eth_out = eth_out;\r\n                amountin = amountin + step;\r\n            }else{\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n        // buy on v2 and sell on curve\r\n        amountin = lowerbound;\r\n\r\n        while(amountin < soldamount){\r\n\r\n            // buy on v2, eth amountout\r\n            eth_amount = getAmountIn(amountin, reserve1, reserve0);\r\n\r\n            // sell on curve\r\n            eth_out = bondindcurve(address(0x69493B637c9b1B4D9EB3a2b97B89389467cF0a20)).s(soldamount - amountin , soldamount);\r\n\r\n            eth_out = eth_out - eth_out * commissionshare / 100;\r\n\r\n            if(eth_out < eth_amount){\r\n                break;\r\n            }\r\n\r\n            if(eth_out - eth_amount > best_sell_profit){\r\n                best_sell_profit = eth_out - eth_amount;\r\n                best_sell_in = eth_amount;\r\n                best_hegic_out = amountin;\r\n                amountin = amountin + step;\r\n            }else{\r\n                break;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n    // detect the best params for buy on hegic and sell on v2, eth->usdc --> hegic -> eth\r\n    function usdc_hegic_buy(uint256 lowerbound, uint256 upperbound, uint256 soldamount) private returns(uint256 best_buy_profit, uint256 best_usdc_out, uint256 best_eth_in, uint256 hegicamount){\r\n\r\n        (uint reserve0,uint reserve1) = getpoolreserve(address(0x1273aD5D8f3596A7a39EfDb5a4b8f82E8F003fc3)); // hegic 0, eth 1\r\n        (uint reserve2,uint reserve3) = getpoolreserve(address(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0)); // usdc 0, eth 1\r\n\r\n        // uint256 amountin = lowerbound;\r\n        uint256 usdc_in;\r\n        uint256 eth_in;\r\n        uint256 eth_out;\r\n\r\n        while(lowerbound < upperbound){\r\n            uint256 temp = soldamount + lowerbound;\r\n            usdc_in = bondindcurve(address(0xa9d47c5E5a2b6FE290723e9CBCa5C406Fdf9000b)).s(soldamount , temp);\r\n            eth_in = getAmountIn(usdc_in, reserve3, reserve2);\r\n            eth_out = getAmountOut(lowerbound, reserve0, reserve1);\r\n\r\n\r\n            if(eth_out < eth_in){\r\n                break;\r\n            }\r\n\r\n            if(eth_out - eth_in > best_buy_profit){\r\n                best_buy_profit = eth_out - eth_in;\r\n                best_usdc_out = usdc_in;\r\n                best_eth_in = eth_in;\r\n                hegicamount = lowerbound;\r\n                lowerbound = lowerbound + 1e22;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    // detect the best params for buy on v2 and sell on hegic for usdc, eth->hegic --> usdc -> eth\r\n    function usdc_hegic_sell(uint256 lowerbound, uint256 upperbound, uint256 step, uint256 soldamount) private returns(uint256 best_sell_profit, uint256 best_hegic_out, uint256 best_eth_in){\r\n\r\n        (uint reserve0,uint reserve1) = getpoolreserve(address(0x1273aD5D8f3596A7a39EfDb5a4b8f82E8F003fc3)); // hegic 0, eth 1\r\n        (uint reserve2,uint reserve3) = getpoolreserve(address(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0)); // usdc 0, eth 1\r\n\r\n        uint256 amountin = lowerbound;\r\n        uint256 usdc_out;\r\n        uint256 eth_in;\r\n        uint256 eth_out;\r\n\r\n        while(amountin < soldamount){\r\n\r\n            eth_in = getAmountIn(amountin, reserve1, reserve0);\r\n            usdc_out = bondindcurve(address(0xa9d47c5E5a2b6FE290723e9CBCa5C406Fdf9000b)).s(soldamount - amountin , soldamount);\r\n            usdc_out = usdc_out - usdc_out * commissionshare / 100;\r\n            eth_out = getAmountOut(usdc_out, reserve2, reserve3);\r\n\r\n\r\n            if(eth_out < eth_in){\r\n                break;\r\n            }\r\n\r\n            if(eth_out - eth_in > best_sell_profit){\r\n                best_sell_profit = eth_out - eth_in;\r\n                best_hegic_out = amountin;\r\n                best_eth_in = eth_in;\r\n                amountin = amountin + step;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    function usdccurve_detect(uint256 lowerbound, uint256 upperbound, uint256 step, uint256 soldamount) public returns(uint256 best_buy_profit, uint256 best_usdc_out, uint256 best_eth_in,uint256 bestheighcamount, uint256 best_sell_profit, uint256 best_hegic_out, uint256 best_eth_in_2){\r\n\r\n\r\n        // eth -> usdc ---> hegic -> eth\r\n        (best_buy_profit, best_usdc_out, best_eth_in, bestheighcamount) = usdc_hegic_buy(lowerbound, upperbound, soldamount);\r\n\r\n\r\n        // eth -> hegic ---> usdc -> eth\r\n        (best_sell_profit, best_hegic_out, best_eth_in_2) = usdc_hegic_sell(lowerbound, upperbound, step,  soldamount);\r\n\r\n\r\n    }\r\n\r\n\r\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity ^0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"
    }
  }
}