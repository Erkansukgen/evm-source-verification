{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/wrapper.sol":{"content":"pragma solidity 0.6.3;\n \n// Solidity Interface\n \ninterface UniswapExchangeInterface {\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n \n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n \n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n \n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n}\n \ncontract RateCrawlerHelper {\n \n    function getTokenRates(UniswapExchangeInterface uniswapExchangeContract, uint[] memory amounts)\n    public view\n    returns (uint[] memory inputPrices, uint[] memory outputPrices)\n    {\n        inputPrices = new uint[](amounts.length);\n        outputPrices = new uint[](amounts.length);\n        bool didReverted = true;\n \n        for (uint i = 0; i < amounts.length; i++) {\n            (didReverted, inputPrices[i]) = assemblyGetEthToToken(address(uniswapExchangeContract), amounts[i], bytes4(keccak256(\"getEthToTokenInputPrice(uint256)\")));\n            if (didReverted) {\n                inputPrices[i] = 0;\n            }\n            (didReverted, outputPrices[i]) = assemblyGetEthToToken(address(uniswapExchangeContract), amounts[i], bytes4(keccak256(\"getTokenToEthOutputPrice(uint256)\")));\n            if (didReverted) {\n                outputPrices[i] = 0;\n            }\n        }\n    }\n \n    function assemblyGetEthToToken(address exh, uint amount, bytes4 sig)\n    internal view\n    returns (bool, uint)\n    {\n        uint success;\n        uint rate;\n        assembly {\n            let x := mload(0x40)        // \"free memory pointer\"\n            mstore(x, sig)               // function signature\n            mstore(add(x, 0x04), amount)  // src address padded to 32 bytes\n            mstore(0x40, add(x, 0x44))    // set free storage pointer to empty space after output\n \n        // input size = sig + uint\n        // = 4 + 32 = 36 = 0x24\n            success := staticcall(\n            gas(),\n            exh, // contract addr\n            x, // Inputs at location x\n            0x24, // Inputs size bytes\n            add(x, 0x24), // output storage after input\n            0x20) // Output size are (uint, uint) = 64 bytes\n \n            rate := mload(add(x, 0x24))  //Assign output to rate.\n            mstore(0x40, x)    // Set empty storage pointer back to start position\n        }\n \n        return (success != 1, rate);\n    }\n}"}}}