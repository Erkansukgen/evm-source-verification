{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/novo_crud.sol":{"content":"pragma solidity ^0.7.0;\n\ncontract ListHolders {\n    \n    address[] public _holders;\n    \n    address _owner;\n    \n    modifier onlyOwner {\n        require(msg.sender == _owner);\n        _;\n    }\n    \n    mapping (address => bool) isHolder;\n    mapping (address => bool) isPay;\n    \n    constructor(address owner) {\n        _owner = owner;  \n    }\n    \n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, \"\", \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, _c, \"\", \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\n        return strConcat(_a, _b, _c, _d, \"\");\n    }\n\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        uint i = 0;\n        for (i = 0; i < _ba.length; i++) {\n            babcde[k++] = _ba[i];\n        }\n        for (i = 0; i < _bb.length; i++) {\n            babcde[k++] = _bb[i];\n        }\n        for (i = 0; i < _bc.length; i++) {\n            babcde[k++] = _bc[i];\n        }\n        for (i = 0; i < _bd.length; i++) {\n            babcde[k++] = _bd[i];\n        }\n        for (i = 0; i < _be.length; i++) {\n            babcde[k++] = _be[i];\n        }\n        return string(babcde);\n    }    \n    \n    function addressToString(address _addr) private pure returns(string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n    \n        bytes memory str = new bytes(51);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint i = 0; i < 20; i++) {\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\n        }\n        return string(str);\n    }  \n    \n    function addNewHolder() external {\n        require(isHolder[msg.sender] == false, 'isHolder = true');\n        isHolder[msg.sender] = true;\n        _holders.push(msg.sender);\n    }\n    \n    function addNewHolder(address newHolder) external onlyOwner {\n        require(isHolder[newHolder] == false, 'isHolder = true');\n        isHolder[newHolder] = true;\n        _holders.push(newHolder);\n    }\n    \n    function addPay(address newHolder) external onlyOwner {\n        isPay[newHolder] = true;\n    }\n    \n    function deleteHolder(uint index) external onlyOwner {\n        require(index < _holders.length, 'Wrong index');\n        delete _holders[index];   \n    }\n    \n    function getIdProject(address holder) public view returns (uint id) {\n        for(uint i = 0; i < _holders.length; i++) {\n            if(holder == _holders[i]) {\n                id = i;\n            }\n        }\n    }\n    \n    function getNumHolders() external view returns(uint) {\n        return _holders.length;\n    }\n    \n    function getHolder(uint i) external view returns (address, bool, bool) {\n        return (_holders[i], isPay[_holders[i]], isHolder[_holders[i]]);\n    }\n    \n    function getAllHolders() public view returns (string memory holders) {\n        holders = '';\n        for(uint i = 0; i < _holders.length; i++) {\n            if(_holders[i] != address(0)) {\n                holders = strConcat(holders, \"_\", addressToString(_holders[i]));   \n            }\n        }\n    }\n    \n}"}}}