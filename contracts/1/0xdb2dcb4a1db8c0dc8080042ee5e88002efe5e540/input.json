{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"github.com/OpenZeppelin/zeppelin-solidity/contracts/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"github.com/OpenZeppelin/zeppelin-solidity/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"github.com/OpenZeppelin/zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"github.com/OpenZeppelin/zeppelin-solidity/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"},"localhost/DS/DSAuth.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./DSAuthority.sol\";\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"},"localhost/DS/DSAuthority.sol":{"content":"pragma solidity ^0.6.0;\n\n\nabstract contract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\n}\n"},"localhost/DS/DSGuard.sol":{"content":"pragma solidity ^0.6.0;\n\n\nabstract contract DSGuard {\n    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function permit(address src, address dst, bytes32 sig) public virtual;\n\n    function forbid(address src, address dst, bytes32 sig) public virtual;\n}\n\n\nabstract contract DSGuardFactory {\n    function newGuard() public virtual returns (DSGuard guard);\n}\n"},"localhost/DS/DSMath.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"},"localhost/DS/DSNote.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n"},"localhost/DS/DSProxy.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./DSAuth.sol\";\nimport \"./DSNote.sol\";\n\n\nabstract contract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache; // global cache for contracts\n\n    constructor(address _cacheAddr) public {\n        require(setCache(_cacheAddr));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    // use the proxy to execute calldata _data on contract _code\n    function execute(bytes memory _code, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (address target, bytes32 response);\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes32 response);\n\n    //set new cache\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\n}\n\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n"},"localhost/auth/ProxyPermission.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../DS/DSGuard.sol\";\nimport \"../DS/DSAuth.sol\";\n\ncontract ProxyPermission {\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n\n    /// @notice Called in the context of DSProxy to authorize an address\n    /// @param _contractAddr Address which will be authorized\n    function givePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n\n    /// @notice Called in the context of DSProxy to remove authority of an address\n    /// @param _contractAddr Auth address which will be removed from authority list\n    function removePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        \n        // if there is no authority, that means that contract doesn't have permission\n        if (currAuthority == address(0)) {\n            return;\n        }\n\n        DSGuard guard = DSGuard(currAuthority);\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n}\n"},"localhost/compound/helpers/CompoundSaverHelper.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../../interfaces/CEtherInterface.sol\";\nimport \"../../interfaces/CompoundOracleInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\n\nimport \"../../mcd/Discount.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../DS/DSProxy.sol\";\n\nimport \"github.com/OpenZeppelin/zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\n\n/// @title Utlity functions for Compound contracts\ncontract CompoundSaverHelper is DSMath {\n\n    using SafeERC20 for IERC20;\n\n    address payable public constant WALLET_ADDR = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    address public constant COMPOUND_LOGGER = 0x3DD0CDf5fFA28C6847B4B276e2fD256046a44bb7;\n    address public constant COMPOUND_ORACLE = 0xDDc46a3B076aec7ab3Fc37420A8eDd2959764Ec4;\n\n    /// @notice Helper method to payback the Compound debt\n    /// @dev If amount is bigger it will repay the whole debt and send the extra to the _user\n    /// @param _amount Amount of tokens we want to repay\n    /// @param _cBorrowToken Ctoken address we are repaying\n    /// @param _borrowToken Token address we are repaying\n    /// @param _user Owner of the compound position we are paying back\n    function paybackDebt(uint _amount, address _cBorrowToken, address _borrowToken, address payable _user) internal {\n        uint wholeDebt = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(address(this));\n\n        if (_amount > wholeDebt) {\n            if (_borrowToken == ETH_ADDRESS) {\n                _user.transfer((_amount - wholeDebt));\n            } else {\n                IERC20(_borrowToken).safeTransfer(_user, (_amount - wholeDebt));\n            }\n\n            _amount = wholeDebt;\n        }\n\n        approveCToken(_borrowToken, _cBorrowToken);\n\n        if (_borrowToken == ETH_ADDRESS) {\n            CEtherInterface(_cBorrowToken).repayBorrow{value: _amount}();\n        } else {\n            require(CTokenInterface(_cBorrowToken).repayBorrow(_amount) == 0);\n        }\n    }\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getFee(uint _amount, address _user, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        uint fee = SERVICE_FEE;\n\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            uint ethTokenPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cTokenAddr);\n            _gasCost = rmul(_gasCost, ethTokenPrice);\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        if (tokenAddr == ETH_ADDRESS) {\n            WALLET_ADDR.transfer(feeAmount);\n        } else {\n            IERC20(tokenAddr).safeTransfer(WALLET_ADDR, feeAmount);\n        }\n    }\n\n    /// @notice Enters the market for the collatera and borrow tokens\n    /// @param _cTokenAddrColl Collateral address we are entering the market in\n    /// @param _cTokenAddrBorrow Borrow address we are entering the market in\n    function enterMarket(address _cTokenAddrColl, address _cTokenAddrBorrow) internal {\n        address[] memory markets = new address[](2);\n        markets[0] = _cTokenAddrColl;\n        markets[1] = _cTokenAddrBorrow;\n\n        ComptrollerInterface(COMPTROLLER).enterMarkets(markets);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveCToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            IERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n\n    /// @notice Returns the underlying address of the cToken asset\n    /// @param _cTokenAddress cToken address\n    /// @return Token address of the cToken specified\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(uint160(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Returns the maximum amount of collateral available to withdraw\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cCollAddress Collateral we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. collateral amount in that token\n    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n\n        if (liquidityInEth == 0) return usersBalance;\n\n        if (_cCollAddress == CETH_ADDRESS) {\n            if (liquidityInEth > usersBalance) return usersBalance;\n\n            return liquidityInEth;\n        }\n\n        uint ethPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cCollAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        if (liquidityInToken > usersBalance) return usersBalance;\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n\n    /// @notice Returns the maximum amount of borrow amount available\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. borrow amount in that token\n    function getMaxBorrow(address _cBorrowAddress, address _account) public view returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n\n        if (_cBorrowAddress == CETH_ADDRESS) return liquidityInEth;\n\n        uint ethPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cBorrowAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n}\n"},"localhost/compound/saver/CompoundFlashLoanTaker.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../exchange/SaverExchangeCore.sol\";\nimport \"../../utils/GasBurner.sol\";\nimport \"../../flashloan/aave/ILendingPool.sol\";\nimport \"./CompoundSaverProxy.sol\";\nimport \"../../flashloan/FlashLoanLogger.sol\";\nimport \"../../auth/ProxyPermission.sol\";\n\n/// @title Entry point for the FL Repay Boosts, called by DSProxy\ncontract CompoundFlashLoanTaker is CompoundSaverProxy, ProxyPermission, GasBurner {\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address payable public constant COMPOUND_SAVER_FLASH_LOAN = 0x632cfd9245B7A4692F03b3D562Ed01E5cff94898;\n\n    // solhint-disable-next-line const-name-snakecase\n    FlashLoanLogger public constant logger = FlashLoanLogger(\n        0xb9303686B0EE92F92f63973EF85f3105329D345c\n    );\n\n    /// @notice Repays the position with it's own fund or with FL if needed\n    function repayWithLoan(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        address _cCollAddress,\n        address _cBorrowAddress,\n        uint gasCost\n        // uint[5] calldata _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        // address[3] calldata _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        // bytes memory _callData\n    ) public payable burnGas(25) {\n        uint maxColl = getMaxCollateral(_cCollAddress, address(this));\n\n        if (_exchangeData.srcAmount <= maxColl) {\n            repay(_exchangeData, _cCollAddress, _cBorrowAddress, gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exchangeData.srcAmount - maxColl);\n            bytes memory paramsData = abi.encode(_exchangeData, _cCollAddress, _cBorrowAddress, gasCost, true, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cCollAddress), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.logFlashLoan(\"CompoundFlashRepay\", loanAmount, _exchangeData.srcAmount, _cCollAddress);\n        }\n    }\n\n    /// @notice Boosts the position with it's own fund or with FL if needed\n    function boostWithLoan(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        address _cCollAddress,\n        address _cBorrowAddress,\n        uint gasCost\n    ) public payable burnGas(20) {\n        uint maxBorrow = getMaxBorrow(_cBorrowAddress, address(this));\n\n        if (_exchangeData.srcAmount <= maxBorrow) {\n            boost(_exchangeData, _cCollAddress, _cBorrowAddress, gasCost);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_exchangeData.srcAmount - maxBorrow);\n            bytes memory paramsData = abi.encode(_exchangeData, _cCollAddress, _cBorrowAddress, gasCost, false, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_cBorrowAddress), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.logFlashLoan(\"CompoundFlashBoost\", loanAmount, _exchangeData.srcAmount, _cBorrowAddress);\n        }\n\n    }\n\n}\n"},"localhost/compound/saver/CompoundSaverProxy.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../exchange/SaverExchangeCore.sol\";\nimport \"../../loggers/CompoundLogger.sol\";\nimport \"../helpers/CompoundSaverHelper.sol\";\n\n/// @title Contract that implements repay/boost functionality\ncontract CompoundSaverProxy is CompoundSaverHelper, SaverExchangeCore {\n\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\n    /// @dev Called through the DSProxy\n    function repay(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        address _cCollAddress,\n        address _cBorrowAddress,\n        uint gasCost\n        // uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        // address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        // bytes memory _callData\n    ) public payable {\n        enterMarket(_cCollAddress, _cBorrowAddress);\n\n        address payable user = address(uint160(getUserAddress()));\n\n        uint maxColl = getMaxCollateral(_cCollAddress, address(this));\n\n        uint collAmount = (_exchangeData.srcAmount > maxColl) ? maxColl : _exchangeData.srcAmount;\n\n        require(CTokenInterface(_cCollAddress).redeemUnderlying(collAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cCollAddress);\n        address borrowToken = getUnderlyingAddr(_cBorrowAddress);\n\n        (, uint swapAmount) = _sell(_exchangeData);\n\n        swapAmount -= getFee(swapAmount, user, gasCost, _cBorrowAddress);\n\n        paybackDebt(swapAmount, _cBorrowAddress, borrowToken, user);\n\n        // handle 0x fee\n        user.transfer(address(this).balance);\n\n        CompoundLogger(COMPOUND_LOGGER).LogRepay(user, _exchangeData.srcAmount, swapAmount, collToken, borrowToken);\n    }\n\n    /// @notice Borrows token, converts to collateral, and adds to position\n    /// @dev Called through the DSProxy\n    function boost(\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        address _cCollAddress,\n        address _cBorrowAddress,\n        uint gasCost\n        // uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        // address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        // bytes memory _callData\n    ) public payable {\n        enterMarket(_cCollAddress, _cBorrowAddress);\n\n        address payable user = address(uint160(getUserAddress()));\n\n        uint maxBorrow = getMaxBorrow(_cBorrowAddress, address(this));\n        uint borrowAmount = (_exchangeData.srcAmount > maxBorrow) ? maxBorrow : _exchangeData.srcAmount;\n\n        require(CTokenInterface(_cBorrowAddress).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_cCollAddress);\n        address borrowToken = getUnderlyingAddr(_cBorrowAddress);\n\n        borrowAmount -= getFee(borrowAmount, user, gasCost, _cBorrowAddress);\n\n        (, uint swapAmount) = _sell(_exchangeData);\n\n        approveCToken(collToken, _cCollAddress);\n\n        if (collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_cCollAddress).mint(swapAmount) == 0);\n        } else {\n            CEtherInterface(_cCollAddress).mint{value: swapAmount}(); // reverts on fail\n        }\n\n        // handle 0x fee\n        user.transfer(address(this).balance);\n\n        CompoundLogger(COMPOUND_LOGGER).LogBoost(user, _exchangeData.srcAmount, swapAmount, collToken, borrowToken);\n    }\n\n}\n"},"localhost/constants/SaverExchangeConstantAddresses.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract SaverExchangeConstantAddresses {\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    address public constant KYBER_WRAPPER = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;\n    address public constant UNISWAP_WRAPPER = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;\n    address public constant OASIS_WRAPPER = 0x891f5A171f865031b0f3Eb9723bb8f68C901c9FE;\n\n    address public constant DGD_ADDRESS = 0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A;\n\n    // Our contracts\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n}\n"},"localhost/exchange/SaverExchangeCore.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/ExchangeInterfaceV2.sol\";\nimport \"./SaverExchangeHelper.sol\";\n\ncontract SaverExchangeCore is SaverExchangeHelper {\n\n    // first is empty to keep the legacy order in place\n    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\n\n    enum ActionType { SELL, BUY }\n\n    struct ExchangeData {\n        address srcAddr;\n        address destAddr;\n        uint srcAmount;\n        uint destAmount;\n        uint minPrice;\n        ExchangeType exchangeType;\n        address exchangeAddr;\n        bytes callData;\n        uint price0x;\n    }\n\n    /// @notice Internal method that preforms a sell on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and destAmount\n    function _sell(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n        uint tokensLeft = exData.srcAmount;\n\n        // if 0x is selected try first the 0x order\n        if (exData.exchangeType == ExchangeType.ZEROX) {\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n            (success, swapedTokens, tokensLeft) = takeOrder(exData, address(this).balance);\n\n            wrapper = exData.exchangeAddr;\n        }\n\n        // check if we have already swapped with 0x, or tried swapping but failed\n        if (tokensLeft > 0) {\n            uint price;\n\n            (wrapper, price)\n                = getBestPrice(exData.srcAmount, exData.srcAddr, exData.destAddr, exData.exchangeType, ActionType.SELL);\n\n            require(price > exData.minPrice || exData.price0x > exData.minPrice, \"Slippage hit\");\n\n            // if 0x has better prices use 0x\n            if (exData.price0x >= price && exData.exchangeType != ExchangeType.ZEROX) {\n                approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n                (success, swapedTokens, tokensLeft) = takeOrder(exData, address(this).balance);\n            }\n\n            require(price > exData.minPrice, \"On chain slippage hit\");\n\n            // 0x either had worse price or we tried and order fill failed, so call on chain swap\n            if (tokensLeft > 0) {\n                swapedTokens = saverSwap(exData, wrapper, ActionType.SELL);\n            }\n        }\n\n        return (wrapper, swapedTokens);\n    }\n\n    /// @notice Internal method that preforms a buy on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and srcAmount\n    function _buy(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n\n        require(exData.destAmount != 0, \"Dest amount must be specified\");\n\n        // if 0x is selected try first the 0x order\n        if (exData.exchangeType == ExchangeType.ZEROX) {\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n            // TODO: should we use address(this).balance?\n            (success, swapedTokens,) = takeOrder(exData, address(this).balance);\n\n            wrapper = exData.exchangeAddr;\n        }\n\n        // check if we have already swapped with 0x, or tried swapping but failed\n        if (getBalance(exData.destAddr) < exData.destAmount) {\n            uint price;\n\n            (wrapper, price)\n                = getBestPrice(exData.destAmount, exData.srcAddr, exData.destAddr, exData.exchangeType, ActionType.BUY);\n\n            require(price < exData.minPrice || exData.price0x < exData.minPrice, \"Slippage hit\");\n\n            // if 0x has better prices use 0x\n            if (exData.price0x != 0 && exData.price0x <= price && exData.exchangeType != ExchangeType.ZEROX) {\n                approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n                (success, swapedTokens,) = takeOrder(exData, address(this).balance);\n            }\n\n            require(price < exData.minPrice, \"On chain slippage hit\");\n\n            // 0x either had worse price or we tried and order fill failed, so call on chain swap\n            if (getBalance(exData.destAddr) < exData.destAmount) {\n               swapedTokens = saverSwap(exData, wrapper, ActionType.BUY);\n            }\n        }\n\n        // require(getBalance(exData.destAddr) >= exData.destAmount, \"Less then destAmount\");\n\n        return (wrapper, getBalance(exData.destAddr));\n    }\n\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\n    /// @param _exData Exchange data\n    /// @param _0xFee Ether fee needed for 0x order\n    function takeOrder(\n        ExchangeData memory _exData,\n        uint256 _0xFee\n    ) private returns (bool success, uint256, uint256) {\n\n        // solhint-disable-next-line avoid-call-value\n        (success, ) = _exData.exchangeAddr.call{value: _0xFee}(_exData.callData);\n\n        uint256 tokensSwaped = 0;\n        uint256 tokensLeft = _exData.srcAmount;\n\n        if (success) {\n            // check to see if any _src tokens are left over after exchange\n            tokensLeft = getBalance(_exData.srcAddr);\n\n            // convert weth -> eth if needed\n            if (_exData.destAddr == KYBER_ETH_ADDRESS) {\n                TokenInterface(WETH_ADDRESS).withdraw(\n                    TokenInterface(WETH_ADDRESS).balanceOf(address(this))\n                );\n            }\n\n            // get the current balance of the swaped tokens\n            tokensSwaped = getBalance(_exData.destAddr);\n        }\n\n        return (success, tokensSwaped, tokensLeft);\n    }\n\n    /// @notice Returns the best estimated price from 2 exchanges\n    /// @param _amount Amount of source tokens you want to exchange\n    /// @param _srcToken Address of the source token\n    /// @param _destToken Address of the destination token\n    /// @param _exchangeType Which exchange will be used\n    /// @param _type Type of action SELL|BUY\n    /// @return (address, uint) The address of the best exchange and the exchange price\n    function getBestPrice(\n        uint256 _amount,\n        address _srcToken,\n        address _destToken,\n        ExchangeType _exchangeType,\n        ActionType _type\n    ) public returns (address, uint256) {\n\n        if (_exchangeType == ExchangeType.OASIS) {\n            return (OASIS_WRAPPER, getExpectedRate(OASIS_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        if (_exchangeType == ExchangeType.KYBER) {\n            return (KYBER_WRAPPER, getExpectedRate(KYBER_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        if (_exchangeType == ExchangeType.UNISWAP) {\n            return (UNISWAP_WRAPPER, getExpectedRate(UNISWAP_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        uint expectedRateKyber = getExpectedRate(KYBER_WRAPPER, _srcToken, _destToken, _amount, _type);\n        uint expectedRateUniswap = getExpectedRate(UNISWAP_WRAPPER, _srcToken, _destToken, _amount, _type);\n        uint expectedRateOasis = getExpectedRate(OASIS_WRAPPER, _srcToken, _destToken, _amount, _type);\n\n        if (_type == ActionType.SELL) {\n            return getBiggestRate(expectedRateKyber, expectedRateUniswap, expectedRateOasis);\n        } else {\n            return getSmallestRate(expectedRateKyber, expectedRateUniswap, expectedRateOasis);\n        }\n    }\n\n    /// @notice Return the expected rate from the exchange wrapper\n    /// @dev In case of Oasis/Uniswap handles the different precision tokens\n    /// @param _wrapper Address of exchange wrapper\n    /// @param _srcToken From token\n    /// @param _destToken To token\n    /// @param _amount Amount to be exchanged\n    /// @param _type Type of action SELL|BUY\n    function getExpectedRate(\n        address _wrapper,\n        address _srcToken,\n        address _destToken,\n        uint256 _amount,\n        ActionType _type\n    ) public returns (uint256) {\n        bool success;\n        bytes memory result;\n\n        if (_type == ActionType.SELL) {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getSellRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n\n        } else {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getBuyRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n        }\n\n        if (success) {\n            uint rate = sliceUint(result, 0);\n\n            if (_wrapper != KYBER_WRAPPER) {\n                rate = rate * (10**(18 - getDecimals(_destToken)));\n            }\n\n            return rate;\n        }\n\n        return 0;\n    }\n\n    /// @notice Calls wraper contract for exchage to preform an on-chain swap\n    /// @param exData Exchange data struct\n    /// @param _wrapper Address of exchange wrapper\n    /// @param _type Type of action SELL|BUY\n    /// @return swapedTokens For Sell that the destAmount, for Buy thats the srcAmount\n    function saverSwap(ExchangeData memory exData, address _wrapper, ActionType _type) internal returns (uint swapedTokens) {\n        uint ethValue = 0;\n\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\n            ethValue = exData.srcAmount;\n        } else {\n            ERC20(exData.srcAddr).transfer(_wrapper, ERC20(exData.srcAddr).balanceOf(address(this)));\n        }\n\n        if (_type == ActionType.SELL) {\n            swapedTokens = ExchangeInterfaceV2(_wrapper).\n                    sell{value: ethValue}(exData.srcAddr, exData.destAddr, exData.srcAmount);\n        } else {\n            swapedTokens = ExchangeInterfaceV2(_wrapper).\n                    buy{value: ethValue}(exData.srcAddr, exData.destAddr, exData.destAmount);\n        }\n    }\n\n    /// @notice Finds the biggest rate between exchanges, needed for sell rate\n    /// @param _expectedRateKyber Kyber rate\n    /// @param _expectedRateUniswap Uniswap rate\n    /// @param _expectedRateOasis Oasis rate\n    function getBiggestRate(\n        uint _expectedRateKyber,\n        uint _expectedRateUniswap,\n        uint _expectedRateOasis\n    ) internal view returns (address, uint) {\n        if (\n            (_expectedRateUniswap >= _expectedRateKyber) && (_expectedRateUniswap >= _expectedRateOasis)\n        ) {\n            return (UNISWAP_WRAPPER, _expectedRateUniswap);\n        }\n\n        if (\n            (_expectedRateKyber >= _expectedRateUniswap) && (_expectedRateKyber >= _expectedRateOasis)\n        ) {\n            return (KYBER_WRAPPER, _expectedRateKyber);\n        }\n\n        if (\n            (_expectedRateOasis >= _expectedRateKyber) && (_expectedRateOasis >= _expectedRateUniswap)\n        ) {\n            return (OASIS_WRAPPER, _expectedRateOasis);\n        }\n    }\n\n    /// @notice Finds the smallest rate between exchanges, needed for buy rate\n    /// @param _expectedRateKyber Kyber rate\n    /// @param _expectedRateUniswap Uniswap rate\n    /// @param _expectedRateOasis Oasis rate\n    function getSmallestRate(\n        uint _expectedRateKyber,\n        uint _expectedRateUniswap,\n        uint _expectedRateOasis\n    ) internal view returns (address, uint) {\n        if (\n            (_expectedRateUniswap <= _expectedRateKyber) && (_expectedRateUniswap <= _expectedRateOasis)\n        ) {\n            return (UNISWAP_WRAPPER, _expectedRateUniswap);\n        }\n\n        if (\n            (_expectedRateKyber <= _expectedRateUniswap) && (_expectedRateKyber <= _expectedRateOasis)\n        ) {\n            return (KYBER_WRAPPER, _expectedRateKyber);\n        }\n\n        if (\n            (_expectedRateOasis <= _expectedRateKyber) && (_expectedRateOasis <= _expectedRateUniswap)\n        ) {\n            return (OASIS_WRAPPER, _expectedRateOasis);\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"},"localhost/exchange/SaverExchangeHelper.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../constants/SaverExchangeConstantAddresses.sol\";\nimport \"../interfaces/ERC20.sol\";\nimport \"../mcd/Discount.sol\";\n\ncontract SaverExchangeHelper {\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant DGD_ADDRESS = 0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A;\n\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    // TODO: set to constant after testing\n    address public KYBER_WRAPPER = 0x3d1D4D6Bb405b2366434cb7387803c7B662b8d71;\n    address public UNISWAP_WRAPPER = 0xFF92ADA50cDC8009686867b4a470C8769bEdB22d;\n    address public OASIS_WRAPPER = 0x9C499376B41A91349Ff93F99462a65962653e104;\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == DGD_ADDRESS) return 9;\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function pullTokens(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            require(msg.value >= _amount, \"msg.value smaller than amount\");\n        } else {\n            require(\n                ERC20(_tokenAddr).transferFrom(msg.sender, address(this), _amount),\n                \"Not able to withdraw wanted amount\"\n            );\n        }\n    }\n\n    function getBalance(address _tokenAddr) internal view returns (uint balance) {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            balance = address(this).balance;\n        } else {\n            balance = ERC20(_tokenAddr).balanceOf(address(this));\n        }\n    }\n\n    function approve0xProxy(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_tokenAddr).approve(address(ERC20_PROXY_0X), _amount);\n        }\n    }\n\n    function sendLeftover(address _srcAddr, address _destAddr, address payable _to) internal {\n        // send back any leftover ether or tokens\n        if (address(this).balance > 0) {\n            _to.transfer(address(this).balance);\n        }\n\n        if (getBalance(_srcAddr) > 0) {\n            ERC20(_srcAddr).transfer(_to, getBalance(_srcAddr));\n        }\n\n        if (getBalance(_destAddr) > 0) {\n            ERC20(_destAddr).transfer(_to, getBalance(_destAddr));\n        }\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n}\n"},"localhost/flashloan/FlashLoanLogger.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract FlashLoanLogger {\n    event FlashLoan(string actionType, uint256 id, uint256 loanAmount, address sender);\n\n    function logFlashLoan(\n        string calldata _actionType,\n        uint256 _id,\n        uint256 _loanAmount,\n        address _sender\n    ) external {\n        emit FlashLoan(_actionType, _loanAmount, _id, _sender);\n    }\n}\n"},"localhost/flashloan/aave/ILendingPool.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract ILendingPool {\n    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\n\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\n\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\n\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual;\n\tfunction getReserveData(address _reserve)\n        external virtual\n        view\n        returns (\n            uint256 totalLiquidity,\n            uint256 availableLiquidity,\n            uint256 totalBorrowsStable,\n            uint256 totalBorrowsVariable,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 utilizationRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            address aTokenAddress,\n            uint40 lastUpdateTimestamp\n        );\n}\n"},"localhost/interfaces/CEtherInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract CEtherInterface {\n    function mint() external virtual payable;\n    function repayBorrow() external virtual payable;\n}\n"},"localhost/interfaces/CTokenInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract CTokenInterface is ERC20 {\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    function mint() external virtual payable;\n\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrow() external virtual payable;\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrowBehalf(address borrower) external virtual payable;\n\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\n        external virtual\n        returns (uint256);\n\n    function liquidateBorrow(address borrower, address cTokenCollateral) external virtual payable;\n\n    function exchangeRateCurrent() external virtual returns (uint256);\n\n    function supplyRatePerBlock() external virtual returns (uint256);\n\n    function borrowRatePerBlock() external virtual returns (uint256);\n\n    function totalReserves() external virtual returns (uint256);\n\n    function reserveFactorMantissa() external virtual returns (uint256);\n\n    function borrowBalanceCurrent(address account) external virtual returns (uint256);\n\n    function totalBorrowsCurrent() external virtual returns (uint256);\n\n    function getCash() external virtual returns (uint256);\n\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\n\n    function underlying() external virtual returns (address);\n\n    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint, uint);\n}\n"},"localhost/interfaces/CompoundOracleInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract CompoundOracleInterface {\n    function getUnderlyingPrice(address cToken) external view virtual returns (uint);\n}\n"},"localhost/interfaces/ComptrollerInterface.sol":{"content":"pragma solidity ^0.6.0;\n\n\nabstract contract ComptrollerInterface {\n    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\n\n    function exitMarket(address cToken) external virtual returns (uint256);\n\n    function getAssetsIn(address account) external virtual view returns (address[] memory);\n\n    function markets(address account) public virtual view returns (bool, uint256);\n\n    function getAccountLiquidity(address account) external virtual view returns (uint256, uint256, uint256);\n}\n"},"localhost/interfaces/ERC20.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function decimals() external view returns (uint256 digits);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"},"localhost/interfaces/ExchangeInterfaceV2.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface ExchangeInterfaceV2 {\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable returns (uint);\n\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external payable returns(uint);\n\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\n\n    function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\n}\n"},"localhost/interfaces/GasTokenInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract GasTokenInterface is ERC20 {\n    function free(uint256 value) public virtual returns (bool success);\n\n    function freeUpTo(uint256 value) public virtual returns (uint256 freed);\n\n    function freeFrom(address from, uint256 value) public virtual returns (bool success);\n\n    function freeFromUpTo(address from, uint256 value) public virtual returns (uint256 freed);\n}\n"},"localhost/interfaces/TokenInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract TokenInterface {\n    function allowance(address, address) public virtual returns (uint256);\n\n    function balanceOf(address) public virtual returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(address, address, uint256) public virtual returns (bool);\n\n    function deposit() public virtual payable;\n\n    function withdraw(uint256) public virtual;\n}\n"},"localhost/loggers/CompoundLogger.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract CompoundLogger {\n    event Repay(\n        address indexed owner,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        address collAddr,\n        address borrowAddr\n    );\n\n    event Boost(\n        address indexed owner,\n        uint256 borrowAmount,\n        uint256 collateralAmount,\n        address collAddr,\n        address borrowAddr\n    );\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LogRepay(address _owner, uint256 _collateralAmount, uint256 _borrowAmount, address _collAddr, address _borrowAddr)\n        public\n    {\n        emit Repay(_owner, _collateralAmount, _borrowAmount, _collAddr, _borrowAddr);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LogBoost(address _owner, uint256 _borrowAmount, uint256 _collateralAmount, address _collAddr, address _borrowAddr)\n        public\n    {\n        emit Boost(_owner, _borrowAmount, _collateralAmount, _collAddr, _borrowAddr);\n    }\n}\n"},"localhost/mcd/Discount.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract Discount {\n    address public owner;\n    mapping(address => CustomServiceFee) public serviceFees;\n\n    uint256 constant MAX_SERVICE_FEE = 400;\n\n    struct CustomServiceFee {\n        bool active;\n        uint256 amount;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }\n\n    function getCustomServiceFee(address _user) public view returns (uint256) {\n        return serviceFees[_user].amount;\n    }\n\n    function setServiceFee(address _user, uint256 _fee) public {\n        require(msg.sender == owner, \"Only owner\");\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n    }\n\n    function disableServiceFee(address _user) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n    }\n}\n"},"localhost/utils/GasBurner.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../interfaces/GasTokenInterface.sol\";\n\ncontract GasBurner {\n    // solhint-disable-next-line const-name-snakecase\n    GasTokenInterface public constant gasToken = GasTokenInterface(0x0000000000b3F879cb30FE243b4Dfee438691c04);\n\n    modifier burnGas(uint _amount) {\n        uint gst2Amount = _amount;\n\n        if (_amount == 0) {\n            gst2Amount = (gasleft() + 14154) / (2 * 24000 - 6870);\n            gst2Amount = gst2Amount - (gst2Amount / 3); // 33.3% less because of gaslimit != gas_used\n        }\n\n        if (gasToken.balanceOf(address(this)) >= gst2Amount) {\n            gasToken.free(gst2Amount);\n        }\n\n        _;\n    }\n}\n"}}}