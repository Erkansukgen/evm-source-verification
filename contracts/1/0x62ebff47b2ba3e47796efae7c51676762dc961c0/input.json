{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DSA/uniswapV2.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface TokenInterface {\n    function approve(address, uint256) external;\n    function transfer(address, uint) external;\n    function transferFrom(address, address, uint) external;\n    function deposit() external payable;\n    function withdraw(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function decimals() external view returns (uint);\n}\n\ninterface MemoryInterface {\n    function getUint(uint id) external returns (uint num);\n    function setUint(uint id, uint val) external;\n}\n\ninterface EventInterface {\n    function emitEvent(uint connectorType, uint connectorID, bytes32 eventCode, bytes calldata eventData) external;\n}\n\ncontract Stores {\n\n    /**\n     * @dev Return ethereum address\n     */\n    function getEthAddr() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\n    }\n\n    /**\n     * @dev Return memory variable address\n     */\n    function getMemoryAddr() internal pure returns (address) {\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\n    }\n\n    /**\n     * @dev Return InstaEvent Address.\n     */\n    function getEventAddr() internal pure returns (address) {\n        return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\n    }\n\n    /**\n     * @dev Get Uint value from InstaMemory Contract.\n     */\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\n    }\n\n    /**\n     * @dev Set Uint value in InstaMemory Contract.\n     */\n    function setUint(uint setId, uint val) internal {\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\n    }\n\n    /**\n     * @dev emit event on event contract\n     */\n    function emitEvent(bytes32 eventCode, bytes memory eventData) internal {\n        (uint model, uint id) = connectorID();\n        EventInterface(getEventAddr()).emitEvent(model, id, eventCode, eventData);\n    }\n\n    /**\n     * @dev Connector Details.\n     */\n    function connectorID() public pure returns(uint model, uint id) {\n        (model, id) = (1, 30);\n    }\n\n}\n\ncontract DSMath {\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n}\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Factory {\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n  function allPairs(uint) external view returns (address pair);\n  function allPairsLength() external view returns (uint);\n\n  function feeTo() external view returns (address);\n  function feeToSetter() external view returns (address);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ncontract UniswapHelpers is Stores, DSMath {\n    /**\n     * @dev Return WETH address\n     */\n    function getAddressWETH() internal pure returns (address) {\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    }\n\n    /**\n     * @dev Return uniswap v2 router02 Address\n     */\n    function getUniswapAddr() internal pure returns (address) {\n        return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    }\n\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = (_amt / 10 ** (18 - _dec));\n    }\n\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = mul(_amt, 10 ** (18 - _dec));\n    }\n\n    function getTokenBalace(address token) internal view returns (uint256 amt) {\n        amt = token == getEthAddr() ? address(this).balance : TokenInterface(token).balanceOf(address(this));\n    }\n\n    function changeEthAddress(address buy, address sell) internal pure returns(TokenInterface _buy, TokenInterface _sell){\n        _buy = buy == getEthAddr() ? TokenInterface(getAddressWETH()) : TokenInterface(buy);\n        _sell = sell == getEthAddr() ? TokenInterface(getAddressWETH()) : TokenInterface(sell);\n    }\n\n    function convertEthToWeth(TokenInterface token, uint amount) internal {\n        if(address(token) == getAddressWETH()) token.deposit.value(amount)();\n    }\n\n    function convertWethToEth(TokenInterface token, uint amount) internal {\n       if(address(token) == getAddressWETH()) {\n            token.approve(getAddressWETH(), amount);\n            token.withdraw(amount);\n        }\n    }\n\n    function getExpectedBuyAmt(\n        IUniswapV2Router02 router,\n        address[] memory paths,\n        uint sellAmt\n    ) internal view returns(uint buyAmt) {\n        uint[] memory amts = router.getAmountsOut(\n            sellAmt,\n            paths\n        );\n        buyAmt = amts[1];\n    }\n\n    function getExpectedSellAmt(\n        IUniswapV2Router02 router,\n        address[] memory paths,\n        uint buyAmt\n    ) internal view returns(uint sellAmt) {\n        uint[] memory amts = router.getAmountsIn(\n            buyAmt,\n            paths\n        );\n        sellAmt = amts[0];\n    }\n\n    function checkPair(\n        IUniswapV2Router02 router,\n        address[] memory paths\n    ) internal view {\n        address pair = IUniswapV2Factory(router.factory()).getPair(paths[0], paths[1]);\n        require(pair != address(0), \"No-exchange-address\");\n    }\n\n    function getPaths(\n        address buyAddr,\n        address sellAddr\n    ) internal pure returns(address[] memory paths) {\n        paths = new address[](2);\n        paths[0] = address(sellAddr);\n        paths[1] = address(buyAddr);\n    }\n}\n\ncontract LiquidityHelpers is UniswapHelpers {\n\n    function getMinAmount(\n        TokenInterface token,\n        uint amt,\n        uint slippage\n    ) internal view returns(uint minAmt) {\n        uint _amt18 = convertTo18(token.decimals(), amt);\n        minAmt = wmul(_amt18, sub(WAD, slippage));\n        minAmt = convert18ToDec(token.decimals(), minAmt);\n    }\n\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint _amt,\n        uint unitAmt,\n        uint slippage\n    ) internal returns (uint _amtA, uint _amtB, uint _liquidity) {\n        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());\n        (TokenInterface _tokenA, TokenInterface _tokenB) = changeEthAddress(tokenA, tokenB);\n\n        _amtA = _amt == uint(-1) ? getTokenBalace(tokenA) : _amt;\n        _amtB = convert18ToDec(_tokenB.decimals(), wmul(unitAmt, convertTo18(_tokenA.decimals(), _amtA)));\n\n        convertEthToWeth(_tokenA, _amtA);\n        convertEthToWeth(_tokenB, _amtB);\n        _tokenA.approve(address(router), _amtA);\n        _tokenB.approve(address(router), _amtB);\n\n       uint minAmtA = getMinAmount(_tokenA, _amtA, slippage);\n        uint minAmtB = getMinAmount(_tokenB, _amtB, slippage);\n       (_amtA, _amtB, _liquidity) = router.addLiquidity(\n            address(_tokenA),\n            address(_tokenB),\n            _amtA,\n            _amtB,\n            minAmtA,\n            minAmtB,\n            address(this),\n            now + 1\n        );\n    }\n\n    function _removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint _amt,\n        uint unitAmtA,\n        uint unitAmtB\n    ) internal returns (uint _amtA, uint _amtB, uint _uniAmt) {\n        IUniswapV2Router02 router;\n        TokenInterface _tokenA;\n        TokenInterface _tokenB;\n        (router, _tokenA, _tokenB, _uniAmt) = _getRemoveLiquidityData(\n            tokenA,\n            tokenB,\n            _amt\n        );\n        {\n        uint minAmtA = convert18ToDec(_tokenA.decimals(), wmul(unitAmtA, _uniAmt));\n        uint minAmtB = convert18ToDec(_tokenB.decimals(), wmul(unitAmtB, _uniAmt));\n        (_amtA, _amtB) = router.removeLiquidity(\n            address(_tokenA),\n            address(_tokenB),\n            _uniAmt,\n            minAmtA,\n            minAmtB,\n            address(this),\n            now + 1\n        );\n        }\n        convertWethToEth(_tokenA, _amtA);\n        convertWethToEth(_tokenB, _amtB);\n    }\n\n    function _getRemoveLiquidityData(\n        address tokenA,\n        address tokenB,\n        uint _amt\n    ) internal returns (IUniswapV2Router02 router, TokenInterface _tokenA, TokenInterface _tokenB, uint _uniAmt) {\n        router = IUniswapV2Router02(getUniswapAddr());\n        (_tokenA, _tokenB) = changeEthAddress(tokenA, tokenB);\n        address exchangeAddr = IUniswapV2Factory(router.factory()).getPair(address(_tokenA), address(_tokenB));\n        require(exchangeAddr != address(0), \"pair-not-found.\");\n\n        TokenInterface uniToken = TokenInterface(exchangeAddr);\n        _uniAmt = _amt == uint(-1) ? uniToken.balanceOf(address(this)) : _amt;\n        uniToken.approve(address(router), _uniAmt);\n    }\n}\n\ncontract UniswapLiquidity is LiquidityHelpers {\n    event LogDepositLiquidity(\n        address indexed tokenA,\n        address indexed tokenB,\n        uint amtA,\n        uint amtB,\n        uint uniAmount,\n        uint getId,\n        uint setId\n    );\n\n    event LogWithdrawLiquidity(\n        address indexed tokenA,\n        address indexed tokenB,\n        uint amountA,\n        uint amountB,\n        uint uniAmount,\n        uint getId,\n        uint[] setId\n    );\n\n    function emitDeposit(\n        address tokenA,\n        address tokenB,\n        uint _amtA,\n        uint _amtB,\n        uint _uniAmt,\n        uint getId,\n        uint setId\n    ) internal {\n        emit LogDepositLiquidity(\n            tokenA,\n            tokenB,\n            _amtA,\n            _amtB,\n            _uniAmt,\n            getId,\n            setId\n        );\n\n        bytes32 _eventCode = keccak256(\"LogDepositLiquidity(address,address,uint256,uint256,uint256,uint256,uint256)\");\n        bytes memory _eventParam = abi.encode(\n            tokenA,\n            tokenB,\n            _amtA,\n            _amtB,\n            _uniAmt,\n            getId,\n            setId\n        );\n        emitEvent(_eventCode, _eventParam);\n    }\n\n    function emitWithdraw(\n        address tokenA,\n        address tokenB,\n        uint _amtA,\n        uint _amtB,\n        uint _uniAmt,\n        uint getId,\n        uint[] memory setIds\n    ) internal {\n        emit LogWithdrawLiquidity(\n            tokenA,\n            tokenB,\n            _amtA,\n            _amtB,\n            _uniAmt,\n            getId,\n            setIds\n        );\n        bytes32 _eventCode = keccak256(\"LogWithdrawLiquidity(address,address,uint256,uint256,uint256,uint256,uint256[])\");\n        bytes memory _eventParam = abi.encode(\n            tokenA,\n            tokenB,\n            _amtA,\n            _amtB,\n            _uniAmt,\n            getId,\n            setIds\n        );\n        emitEvent(_eventCode, _eventParam);\n    }\n\n    /**\n     * @dev Deposit Liquidity.\n     * @param tokenA tokenA address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param tokenB tokenB address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amtA tokenA amount.\n     * @param unitAmt unit amount of amtB/amtA with slippage.\n     * @param slippage slippage amount.\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\n    */\n    function deposit(\n        address tokenA,\n        address tokenB,\n        uint amtA,\n        uint unitAmt,\n        uint slippage,\n        uint getId,\n        uint setId\n    ) external payable {\n        uint _amt = getUint(getId, amtA);\n\n        (uint _amtA, uint _amtB, uint _uniAmt) = _addLiquidity(\n                                            tokenA,\n                                            tokenB,\n                                            _amt,\n                                            unitAmt,\n                                            slippage\n                                            );\n        setUint(setId, _uniAmt);\n        emitDeposit(tokenA, tokenB, _amtA, _amtB, _uniAmt, getId, setId);\n    }\n\n    /**\n     * @dev Withdraw Liquidity.\n     * @param tokenA tokenA address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param tokenB tokenB address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param uinAmt uni token amount.\n     * @param unitAmtA unit amount of amtA/uinAmt with slippage.\n     * @param unitAmtB unit amount of amtB/uinAmt with slippage.\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\n     * @param setIds Set token amounts at this IDs in `InstaMemory` Contract.\n    */\n    function withdraw(\n        address tokenA,\n        address tokenB,\n        uint uinAmt,\n        uint unitAmtA,\n        uint unitAmtB,\n        uint getId,\n        uint[] calldata setIds\n    ) external payable {\n        uint _amt = getUint(getId, uinAmt);\n\n        (uint _amtA, uint _amtB, uint _uniAmt) = _removeLiquidity(\n            tokenA,\n            tokenB,\n            _amt,\n            unitAmtA,\n            unitAmtB\n        );\n\n        setUint(setIds[0], _amtA);\n        setUint(setIds[1], _amtB);\n        emitWithdraw(tokenA, tokenB, _amtA, _amtB, _uniAmt, getId, setIds);\n    }\n}\n\ncontract UniswapResolver is UniswapLiquidity {\n    event LogBuy(\n        address indexed buyToken,\n        address indexed sellToken,\n        uint256 buyAmt,\n        uint256 sellAmt,\n        uint256 getId,\n        uint256 setId\n    );\n\n    event LogSell(\n        address indexed buyToken,\n        address indexed sellToken,\n        uint256 buyAmt,\n        uint256 sellAmt,\n        uint256 getId,\n        uint256 setId\n    );\n\n    /**\n     * @dev Buy ETH/ERC20_Token.\n     * @param buyAddr buying token address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param sellAddr selling token amount.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param buyAmt buying token amount.\n     * @param unitAmt unit amount of sellAmt/buyAmt with slippage.\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\n    */\n    function buy(\n        address buyAddr,\n        address sellAddr,\n        uint buyAmt,\n        uint unitAmt,\n        uint getId,\n        uint setId\n    ) external payable {\n        uint _buyAmt = getUint(getId, buyAmt);\n        (TokenInterface _buyAddr, TokenInterface _sellAddr) = changeEthAddress(buyAddr, sellAddr);\n        address[] memory paths = getPaths(address(_buyAddr), address(_sellAddr));\n\n        uint _slippageAmt = convert18ToDec(_sellAddr.decimals(),\n            wmul(unitAmt, convertTo18(_buyAddr.decimals(), _buyAmt)));\n\n        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());\n\n        checkPair(router, paths);\n        uint _expectedAmt = getExpectedSellAmt(router, paths, _buyAmt);\n        require(_slippageAmt >= _expectedAmt, \"Too much slippage\");\n\n        convertEthToWeth(_sellAddr, _expectedAmt);\n        _sellAddr.approve(address(router), _expectedAmt);\n\n        uint _sellAmt = router.swapTokensForExactTokens(\n            _buyAmt,\n            _expectedAmt,\n            paths,\n            address(this),\n            now + 1\n        )[0];\n\n        convertWethToEth(_buyAddr, _buyAmt);\n\n        setUint(setId, _sellAmt);\n\n        emit LogBuy(buyAddr, sellAddr, _buyAmt, _sellAmt, getId, setId);\n        bytes32 _eventCode = keccak256(\"LogBuy(address,address,uint256,uint256,uint256,uint256)\");\n        bytes memory _eventParam = abi.encode(buyAddr, sellAddr, _buyAmt, _sellAmt, getId, setId);\n        (uint _type, uint _id) = connectorID();\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\n    }\n\n    /**\n     * @dev Sell ETH/ERC20_Token.\n     * @param buyAddr buying token address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param sellAddr selling token amount.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param sellAmt selling token amount.\n     * @param unitAmt unit amount of buyAmt/sellAmt with slippage.\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\n    */\n    function sell(\n        address buyAddr,\n        address sellAddr,\n        uint sellAmt,\n        uint unitAmt,\n        uint getId,\n        uint setId\n    ) external payable {\n        uint _sellAmt = getUint(getId, sellAmt);\n        (TokenInterface _buyAddr, TokenInterface _sellAddr) = changeEthAddress(buyAddr, sellAddr);\n        address[] memory paths = getPaths(address(_buyAddr), address(_sellAddr));\n\n        if (_sellAmt == uint(-1)) {\n            _sellAmt = sellAddr == getEthAddr() ? address(this).balance : _sellAddr.balanceOf(address(this));\n        }\n\n        uint _slippageAmt = convert18ToDec(_buyAddr.decimals(),\n            wmul(unitAmt, convertTo18(_sellAddr.decimals(), _sellAmt)));\n\n        IUniswapV2Router02 router = IUniswapV2Router02(getUniswapAddr());\n\n        checkPair(router, paths);\n        uint _expectedAmt = getExpectedBuyAmt(router, paths, _sellAmt);\n        require(_slippageAmt <= _expectedAmt, \"Too much slippage\");\n\n        convertEthToWeth(_sellAddr, _sellAmt);\n        _sellAddr.approve(address(router), _sellAmt);\n\n        uint _buyAmt = router.swapExactTokensForTokens(\n            _sellAmt,\n            _expectedAmt,\n            paths,\n            address(this),\n            now + 1\n        )[1];\n\n        convertWethToEth(_buyAddr, _buyAmt);\n\n        setUint(setId, _buyAmt);\n\n        emit LogSell(buyAddr, sellAddr, _buyAmt, _sellAmt, getId, setId);\n        bytes32 _eventCode = keccak256(\"LogSell(address,address,uint256,uint256,uint256,uint256)\");\n        bytes memory _eventParam = abi.encode(buyAddr, sellAddr, _buyAmt, _sellAmt, getId, setId);\n        (uint _type, uint _id) = connectorID();\n        EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\n    }\n}\n\n\ncontract ConnectUniswapV2 is UniswapResolver {\n    string public name = \"UniswapV2-v1\";\n}\n"}}}