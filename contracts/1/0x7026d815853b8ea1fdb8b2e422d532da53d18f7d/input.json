{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/3_Ballot.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2020-12-14\n*/\n\n// SPDX-License-Identifier: SimPL-2.0\npragma solidity >=0.6.11;\n\ninterface ICurve {\n    function get_dy(int128 i, int128 j, uint256 dx) external returns (uint256);\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\n}\n\ninterface ICDaiErc20{\n    function mint(uint256) external returns (uint256);\n    function redeem(uint) external returns (uint);\n    function redeemUnderlying(uint) external returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function borrow(uint256) external returns (uint256);\n    function repayBorrow(uint256) external returns (uint256);\n    function balanceOfUnderlying(address) external returns (uint);\n    function borrowBalanceCurrent(address) external returns (uint256);\n\n    function claimComp(address holder) external;\n}\n\ninterface IUniswapV2Router {\n    function WETH() external pure returns (address);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\nlibrary SafeERC20 {\n   using SafeMath for uint256;\n   using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        if(token.allowance(address(this),spender) < value){\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n        }\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n         \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary Address {\n  \n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract DefiGetTogether {\n\n    using SafeMath for uint;\n    enum DefiStatus {\n        UNUSED,CROWDFUNDING,WAITDART,DARTSUCCESS               \n     }           \n                  \n    uint256 constant MaxUint256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    uint [] private supplySection;  \n    uint public totalInvestor; \n\n    uint public crowdfundNumber; \n    uint public crowdfundPeriod; \n\n    uint public dartNumber;  \n    uint public dartPeriod;   \n    uint public intervalNumber = 11520; \n    uint public minCrowdFundingAmount = 1000;\n    uint public mortgageFactor = 69;\n    uint public maxMortgageFactor = 75;\n    uint public platformCoefficient = 15;\n\n    address private uniSwapContract;    \n    address private curvePoolContract;\n    address private usdtContract;     \n    address private daiContract;      \n    address private cDaiContract;     \n    address private compContract;   \n    address private compComptrollerContract;  \n    address public platformAddr;      \n    address public owner;         \n    address[] public investors;\n    mapping(address => bool) public admins;    \n    mapping(address => uint) public investments; \n    DefiStatus public status = DefiStatus.UNUSED; \n\n    bool private isUniswapWay = false;\n    int128 private curveUsdtIndex = 2;\n    int128 private curveDaiIndex = 0;\n\n    constructor(address _uniSwapContract,address _curvePoolContract,address _usdtContract,address _daiContract,address _cDaiContract,address _compContract,address _compComptrollerContract,address _platformAddr) public{\n        uniSwapContract = _uniSwapContract;\n        curvePoolContract = _curvePoolContract;\n        usdtContract = _usdtContract;\n        daiContract = _daiContract;\n        cDaiContract = _cDaiContract;\n        compContract = _compContract;\n        compComptrollerContract = _compComptrollerContract;\n        platformAddr = _platformAddr;\n        uint power = IERC20(usdtContract).decimals();\n        minCrowdFundingAmount = uint256(minCrowdFundingAmount).mul(10 ** power);\n        owner = msg.sender;\n    }\n\n    function _isContainsInvestors(address _investor) private view returns(bool) {\n        return investments[_investor] != 0;\n    }\n\n     function _isAdmin(address _address) private view returns(bool) {\n        return admins[_address];\n    }\n    \n    function _addInverstorInfo(address _investor, uint _amount) private {\n        if (_isContainsInvestors(_investor)) {\n            investments[_investor] = investments[_investor].add(_amount);\n        } else {\n            investors.push(_investor);\n            investments[_investor] = _amount;\n        }\n    }\n\n    function _deleteAllInvestorInfo() private {\n        for (uint i = 0; i < investors.length; i ++) {\n            delete investments[investors[i]];\n        }\n        delete investors;\n    }\n\n    function _getTotalInvestment() private view returns(uint) {\n        uint amount = 0;\n        for (uint i = 0; i < investors.length; i ++) {\n            amount = amount.add(investments[investors[i]]);\n        }\n        return amount;\n    }\n\n    function _curveSwap(address _address,int128 _from, int128 _to, uint256 _amount) private {\n        SafeERC20.safeApprove(IERC20(_address),curvePoolContract,_amount);\n        ICurve curve = ICurve(curvePoolContract);\n        uint256 min_dy = curve.get_dy(_from, _to, _amount);\n        curve.exchange(_from, _to, _amount, min_dy);\n    }\n\n    function _uniswap(address _from, address _to, uint256 _amount) private {\n        IUniswapV2Router router = IUniswapV2Router(uniSwapContract);\n        SafeERC20.safeApprove(IERC20(_from),address(router),_amount);\n        address[] memory path = new address[](3);\n        path[0] = _from;\n        path[1] = router.WETH();\n        path[2] = _to;\n        uint[] memory amounts = router.getAmountsOut(_amount, path);\n        uint amountOutMin = amounts[amounts.length - 1];\n        router.swapExactTokensForTokens(_amount, amountOutMin, path, address(this), MaxUint256);\n    }\n\n    function _swap(address _from, address _to) private {\n        uint amountIn = IERC20(_from).balanceOf(address(this));\n        if(amountIn > 0){\n        \n            if (((_from == usdtContract && _to == daiContract) || (_from == daiContract && _to == usdtContract)) &&  isUniswapWay == false) {\n        \n                  if (_from == usdtContract) {\n                       _curveSwap(_from,curveUsdtIndex, curveDaiIndex, amountIn);\n                  } else {\n                      _curveSwap(_from,curveDaiIndex, curveUsdtIndex, amountIn);\n                     }\n            } else{\n                _uniswap(_from, _to, amountIn); \n              }\n        }\n    }\n   \n    function _batchTransferPrincipal() private {\n        uint amountUsdt = IERC20(usdtContract).balanceOf(address(this));\n        uint totalInvestment = _getTotalInvestment();\n        require(amountUsdt >= totalInvestment, \"usdt balance no enouth\");\n        for (uint i = 0; i < investors.length; i ++) {\n            address investor = investors[i];\n            uint investment = investments[investor];\n            SafeERC20.safeTransfer(IERC20(usdtContract), investor, investment);\n        }\n    }\n\n    function _batchTransferPrincipalAndIncome() private {\n        uint totalUsdtAmount = IERC20(usdtContract).balanceOf(address(this)); \n        require(totalUsdtAmount > 0, \"batch transfer balance failed\");\n        uint totalInvestment = _getTotalInvestment();\n\n        if (totalUsdtAmount > totalInvestment) {\n            uint income = totalUsdtAmount.sub(totalInvestment);\n            uint totalInvestorsIncome = income.mul(uint256(100).sub(platformCoefficient)).div(uint256(100)).add(totalInvestment);\n            for (uint i = 0; i < investors.length; i ++) {\n                address investor = investors[i];\n                uint investment = investments[investor];\n                uint investorIncome = totalInvestorsIncome.mul(investment).div(totalInvestment);\n                SafeERC20.safeTransfer(IERC20(usdtContract), investor, investorIncome);\n            }\n        } else if (totalUsdtAmount < totalInvestment) {\n            for (uint i = 0; i < investors.length; i ++) {\n                address investor = investors[i];\n                uint investment = investments[investor];\n                uint investorIncome = totalUsdtAmount.mul(investment).div(totalInvestment);\n                SafeERC20.safeTransfer(IERC20(usdtContract), investor, investorIncome);\n            }\n        } else {\n            for (uint i = 0; i < investors.length; i ++) {\n                address investor = investors[i];\n                uint investment = investments[investor];\n                SafeERC20.safeTransfer(IERC20(usdtContract), investor, investment);\n            }\n        }\n\n        uint leftUsdtAmount = IERC20(usdtContract).balanceOf(address(this));\n        if (leftUsdtAmount > 0) {\n            SafeERC20.safeTransfer(IERC20(usdtContract), platformAddr, leftUsdtAmount);\n        }\n    }\n\n    function _getTogetherSupply(uint _count) private {\n        uint _num = IERC20(daiContract).balanceOf(address(this));\n        require(_num > 0,\"invalid param\");\n        for (uint i = 0; i < _count;i++) {\n            SafeERC20.safeApprove(IERC20(daiContract),cDaiContract,_num);\n            require(ICDaiErc20(cDaiContract).mint(_num) == 0,\"supply fail\");\n            supplySection.push(_num);\n            if(i != _count - 1){\n                _num = _num.mul(mortgageFactor).div(100);\n                require(ICDaiErc20(cDaiContract).borrow(_num) == 0,\"borrow fail\");     \n            }\n       }\n    }\n\n    function _getTogetherRedeem() private {\n        uint _totalSupplyCurrrent;\n        uint _totalBorrowCurrrent;\n        uint _value;\n        uint _length = supplySection.length;\n        for(uint i = 0; i < _length ;i++){\n            _totalBorrowCurrrent = ICDaiErc20(cDaiContract).borrowBalanceCurrent(address(this));\n            if(_totalBorrowCurrrent == 0){\n                break;\n            }\n            _totalSupplyCurrrent = ICDaiErc20(cDaiContract).balanceOfUnderlying(address(this));\n            _value = _totalSupplyCurrrent.sub(_totalBorrowCurrrent.mul(100).div(maxMortgageFactor));\n    \n            require(ICDaiErc20(cDaiContract).redeemUnderlying(_value) == 0,\"redeemUnderlying fail\");  \n            \n            if(_value > _totalBorrowCurrrent){\n                _value = _totalBorrowCurrrent;\n            }\n            SafeERC20.safeApprove(IERC20(daiContract),cDaiContract,_value);\n            require(ICDaiErc20(cDaiContract).repayBorrow(_value) == 0,\"repayBorrow fail\"); \n        }\n\n        \n        _value = ICDaiErc20(cDaiContract).balanceOf(address(this));\n        if(_value > 0){\n             require(ICDaiErc20(cDaiContract).redeem(_value) == 0,\"redeem fail\"); \n        }\n      \n    }\n    \n    function repayAllBorrow() external onlyOwner(){\n       uint value;    \n       uint totalBorrowCurrrent = ICDaiErc20(cDaiContract).borrowBalanceCurrent(address(this));\n       uint balance = IERC20(daiContract).balanceOf(address(this));\n       require(balance >= totalBorrowCurrrent ,\"dai balance no enouth\");\n       value = ICDaiErc20(cDaiContract).borrowBalanceCurrent(address(this)); \n       if(value > 0){\n           SafeERC20.safeApprove(IERC20(daiContract),cDaiContract,value);\n           require(ICDaiErc20(cDaiContract).repayBorrow(value) == 0,\"repayBorrow fail\");\n       }\n       \n    }\n\n    function _cleanAllInfo() private {\n        _deleteAllInvestorInfo();\n        delete totalInvestor;\n        delete supplySection;\n        delete crowdfundNumber;  \n        delete crowdfundPeriod;\n        delete dartNumber;\n        delete dartPeriod;\n        status = DefiStatus.UNUSED;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function startCrowdFunding(uint _totalInvestment, uint _crowdfundPeriod) external onlyOwner() {\n        require(status == DefiStatus.UNUSED, \"not unused status\");\n        require(_totalInvestment > 0 && _crowdfundPeriod > 0, \"error crowdFunding time\");\n        status = DefiStatus.CROWDFUNDING;\n        totalInvestor = _totalInvestment;\n        crowdfundNumber = block.number;\n        crowdfundPeriod = _crowdfundPeriod.div(15);\n    }\n    \n    function crowdFunding(uint amount) external {\n        require(status == DefiStatus.CROWDFUNDING, \"not crowdfunding status\");\n        require(amount >= minCrowdFundingAmount,\"not enough amount\");\n        require(block.number < crowdfundNumber.add(crowdfundPeriod), \"crowdfunding time has passed\");\n        SafeERC20.safeTransferFrom(IERC20(usdtContract), msg.sender, address(this), amount);\n        _addInverstorInfo(msg.sender, amount);\n        uint currentAmount = _getTotalInvestment();\n        if (currentAmount >= totalInvestor) {\n            status = DefiStatus.WAITDART;\n        }\n    }\n    \n    function cancelCrowdfunding() external {\n        require(status == DefiStatus.CROWDFUNDING || status == DefiStatus.WAITDART);\n        uint allowInvestmentNumber = crowdfundNumber.add(crowdfundPeriod).add(intervalNumber);\n        require(msg.sender == owner || (_isContainsInvestors(msg.sender) && (block.number > allowInvestmentNumber)));\n        _batchTransferPrincipal();\n        _cleanAllInfo();\n    }\n\n    function startDart(uint count, uint duration) external onlyOwner() {\n        require(status == DefiStatus.WAITDART, \"not wait dart status\");\n        require(count > 0 && duration > 0, \"error startDart time\");\n        _swap(usdtContract, daiContract); \n        _getTogetherSupply(count);\n        status = DefiStatus.DARTSUCCESS;\n        dartNumber = block.number;\n        dartPeriod = duration.div(15);\n    }\n    \n    function startLiquidation() external {\n        require(status == DefiStatus.DARTSUCCESS);\n        uint allowInvestmentNumber = dartNumber.add(dartPeriod).add(intervalNumber);\n        require(msg.sender == owner || (_isContainsInvestors(msg.sender) && (block.number > allowInvestmentNumber)) || _isAdmin(msg.sender));\n        _getTogetherRedeem();\n        _swap(daiContract, usdtContract);\n        _swap(compContract, usdtContract);\n        _batchTransferPrincipalAndIncome();\n        _cleanAllInfo();\n    }\n\n\n    function claimComp() external onlyOwner() {\n        ICDaiErc20(compComptrollerContract).claimComp(address(this));\n        _swap(compContract, usdtContract);\n\n    }\n\n    function setOwner(address _address) external onlyOwner() {\n         owner = _address;\n    }\n\n    function setIsUniswapWay(bool _isUniswapWay) external onlyOwner() {\n        isUniswapWay = _isUniswapWay;\n    }\n\n    function setCurveInfo(address _poolAddr, int128 _usdtIndex, int128 _daiIndex) external onlyOwner() {\n        curvePoolContract = _poolAddr;\n        curveUsdtIndex = _usdtIndex;\n        curveDaiIndex = _daiIndex;\n    }\n\n    function setMinCrowdFundingAmount(uint minAmount) external onlyOwner() {\n        minCrowdFundingAmount = minAmount;\n    }\n\n    function setPlatformIncomeAddress(address _address) external onlyOwner() {\n        platformAddr = _address;\n    }\n\n    function setPlatformCoefficient(uint8 _platformCoefficient) external onlyOwner() {\n        platformCoefficient = _platformCoefficient;\n    }\n\n    function setMortgageFactor(uint _mortgageFactor) external onlyOwner() {\n         mortgageFactor = _mortgageFactor;\n    }\n    \n    function setMaxMortgageFactor(uint _mortgageFactor) external onlyOwner() {\n         maxMortgageFactor = _mortgageFactor;\n    }\n\n    function addAdmin(address _address) external onlyOwner() {\n        admins[_address] = true;\n    }\n\n    function removeAdmin(address _address) external onlyOwner() {\n        delete admins[_address];\n    }\n\n    function investorAmount(address investor) external view returns(uint) {\n        return investments[investor];\n    }\n\n    function currentTotalAmount() external view returns(uint) {\n        return _getTotalInvestment();\n    }\n \n    function currentInvestors()  external view returns(address[] memory,uint[] memory amountArray) {\n        amountArray = new uint[](investors.length);\n        for(uint i = 0; i < investors.length ;i++){\n           amountArray[i] = investments[investors[i]];\n        }\n        return (investors,amountArray);\n    }\n\n}"}}}