{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/buyHYDRA.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n//pragma solidity ^0.7.0;\n\npragma solidity ^0.6.6;\n\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\ninterface IBalancerExchange {\n\n    struct Swap {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint    swapAmount; // tokenInAmount / tokenOutAmount\n        uint    limitReturnAmount; // minAmountOut / maxAmountIn\n        uint    maxPrice;\n    }\n    \n    function multihopBatchSwapExactIn(\n        Swap[][] memory swapSequences,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint totalAmountIn,\n        uint minTotalAmountOut\n    )\n        external payable\n        returns (uint totalAmountOut);\n}\n\n\ncontract Owned {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can do this\");\n        _;\n    }\n\n    function kill()\n        public\n        onlyOwner\n    {\n        selfdestruct(msg.sender);\n    }\n}\n\ncontract Arbitrage is Owned {\n    IBalancerExchange routerBal = IBalancerExchange(0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21);\n    \n    function swapTokens(address pool, address tokenIn, address tokenOut, uint amountIn, uint amountOutMin)\n        public\n        virtual\n        returns (uint amounts)\n    {\n        IBalancerExchange.Swap[][] memory swapSequences = new IBalancerExchange.Swap[][](1);\n        swapSequences[0][0] = IBalancerExchange.Swap({pool: pool, tokenIn: tokenIn, tokenOut: tokenOut, \n                                                                    swapAmount: amountIn, limitReturnAmount: 0, \n                                                                    maxPrice: uint(-1)});\n        amounts = routerBal.multihopBatchSwapExactIn(swapSequences, IERC20(tokenIn), IERC20(tokenOut), amountIn, amountOutMin);\n    }\n\n    receive() external payable {}\n}\n\ncontract ArbitragePrivate is Arbitrage {\n    address _dai;\n    uint public _amountIn;\n    uint public _amountOutMin;\n    address public _pool;\n    address public _tokenIn;\n    address public _tokenOut;\n    uint public test = uint(-1);\n    \n    constructor() public {\n        // mainnet\n        //_weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n        // ropsten\n        //_weth = 0xc778417E063141139Fce010982780140Aa0cD5Ab;\n        _dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        _tokenIn = _dai;\n        _tokenOut = 0x6FCb6408499a7c0f242E32D77EB51fFa1dD28a7E;\n        _pool = 0xF014fC5d0F02C19D617a30a745Ab86A8cA32C92F;\n        _amountIn = 110000 ether;\n        _amountOutMin = 2450000 szabo;\n        TransferHelper.safeApprove(_tokenIn, address(routerBal), uint(-1));\n    }\n    \n    function setParameters(address pool, address tokenIn, address tokenOut, uint amountIn, uint amountOutMin) public onlyOwner {\n        _pool = pool;\n        _tokenIn = tokenIn;\n        _tokenOut = tokenOut;\n        _amountIn = amountIn;\n        _amountOutMin = amountOutMin;\n        TransferHelper.safeApprove(_tokenIn, address(routerBal), uint(-1));\n    }\n\n    function withdrawEther() external onlyOwner {\n        payable(address(owner)).transfer(address(this).balance);\n    }\n    \n    function withdrawTokens(address token) public onlyOwner {\n        uint balance = IERC20(token).balanceOf(address(this));\n        TransferHelper.safeTransfer(token, owner, balance);\n    }\n\n    fallback () external {\n        swapTokens(_pool, _tokenIn, _tokenOut, _amountIn, _amountOutMin);\n    }\n}"}}}