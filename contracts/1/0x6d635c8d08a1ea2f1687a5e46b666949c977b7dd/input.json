{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DssVest.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n//\n// DssVest - Token vesting contract\n//\n// Copyright (C) 2021 Dai Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.6.12;\n\ninterface MintLike {\n    function mint(address, uint256) external;\n}\n\ninterface ChainlogLike {\n    function getAddress(bytes32) external view returns (address);\n}\n\ninterface DaiJoinLike {\n    function exit(address, uint256) external;\n}\n\ninterface VatLike {\n    function hope(address) external;\n    function suck(address, address, uint256) external;\n}\n\ninterface TokenLike {\n    function transferFrom(address, address, uint256) external returns (bool);\n}\n\nabstract contract DssVest {\n\n    uint256 public   constant  TWENTY_YEARS = 20 * 365 days;\n\n    uint256 internal locked;\n\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Init(uint256 indexed id, address indexed usr);\n    event Vest(uint256 indexed id, uint256 amt);\n    event Move(uint256 indexed id, address indexed dst);\n    event File(bytes32 indexed what, uint256 data);\n    event Yank(uint256 indexed id, uint256 end);\n    event Restrict(uint256 indexed id);\n    event Unrestrict(uint256 indexed id);\n\n\n    // --- Auth ---\n    mapping (address => uint256) public wards;\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"DssVest/not-authorized\");\n        _;\n    }\n\n    // --- Mutex  ---\n    modifier lock {\n        require(locked == 0, \"DssVest/system-locked\");\n        locked = 1;\n        _;\n        locked = 0;\n    }\n\n    struct Award {\n        address usr;   // Vesting recipient\n        uint48  bgn;   // Start of vesting period  [timestamp]\n        uint48  clf;   // The cliff date           [timestamp]\n        uint48  fin;   // End of vesting period    [timestamp]\n        address mgr;   // A manager address that can yank\n        uint8   res;   // Restricted\n        uint128 tot;   // Total reward amount\n        uint128 rxd;   // Amount of vest claimed\n    }\n    mapping (uint256 => Award) public awards;\n    uint256 public ids;\n\n    uint256 public cap; // Maximum per-second issuance token rate\n\n    // Getters to access only to the value desired\n    function usr(uint256 _id) external view returns (address) {\n        return awards[_id].usr;\n    }\n\n    function bgn(uint256 _id) external view returns (uint256) {\n        return awards[_id].bgn;\n    }\n\n    function clf(uint256 _id) external view returns (uint256) {\n        return awards[_id].clf;\n    }\n\n    function fin(uint256 _id) external view returns (uint256) {\n        return awards[_id].fin;\n    }\n\n    function mgr(uint256 _id) external view returns (address) {\n        return awards[_id].mgr;\n    }\n\n    function res(uint256 _id) external view returns (uint256) {\n        return awards[_id].res;\n    }\n\n    function tot(uint256 _id) external view returns (uint256) {\n        return awards[_id].tot;\n    }\n\n    function rxd(uint256 _id) external view returns (uint256) {\n        return awards[_id].rxd;\n    }\n\n    /*\n        @dev Base vesting logic contract constructor\n    */\n    constructor() public {\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    /*\n        @dev (Required) Set the per-second token issuance rate.\n        @param what  The tag of the value to change (ex. bytes32(\"cap\"))\n        @param data  The value to update (ex. cap of 1000 tokens/yr == 1000*WAD/365 days)\n    */\n    function file(bytes32 what, uint256 data) external auth lock {\n        if      (what == \"cap\")         cap = data;     // The maximum amount of tokens that can be streamed per-second per vest\n        else revert(\"DssVest/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x > y ? y : x;\n    }\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"DssVest/add-overflow\");\n    }\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"DssVest/sub-underflow\");\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"DssVest/mul-overflow\");\n    }\n    function toUint48(uint256 x) internal pure returns (uint48 z) {\n        require((z = uint48(x)) == x, \"DssVest/uint48-overflow\");\n    }\n    function toUint128(uint256 x) internal pure returns (uint128 z) {\n        require((z = uint128(x)) == x, \"DssVest/uint128-overflow\");\n    }\n\n    /*\n        @dev Govanance adds a vesting contract\n        @param _usr The recipient of the reward\n        @param _tot The total amount of the vest\n        @param _bgn The starting timestamp of the vest\n        @param _tau The duration of the vest (in seconds)\n        @param _eta The cliff duration in seconds (i.e. 1 years)\n        @param _mgr An optional manager for the contract. Can yank if vesting ends prematurely.\n        @return id  The id of the vesting contract\n    */\n    function create(address _usr, uint256 _tot, uint256 _bgn, uint256 _tau, uint256 _eta, address _mgr) external auth lock returns (uint256 id) {\n        require(_usr != address(0),                        \"DssVest/invalid-user\");\n        require(_tot > 0,                                  \"DssVest/no-vest-total-amount\");\n        require(_bgn < add(block.timestamp, TWENTY_YEARS), \"DssVest/bgn-too-far\");\n        require(_bgn > sub(block.timestamp, TWENTY_YEARS), \"DssVest/bgn-too-long-ago\");\n        require(_tau > 0,                                  \"DssVest/tau-zero\");\n        require(_tot / _tau <= cap,                        \"DssVest/rate-too-high\");\n        require(_tau <= TWENTY_YEARS,                      \"DssVest/tau-too-long\");\n        require(_eta <= _tau,                              \"DssVest/eta-too-long\");\n        require(ids < type(uint256).max,                   \"DssVest/ids-overflow\");\n\n        id = ++ids;\n        awards[id] = Award({\n            usr: _usr,\n            bgn: toUint48(_bgn),\n            clf: toUint48(add(_bgn, _eta)),\n            fin: toUint48(add(_bgn, _tau)),\n            tot: toUint128(_tot),\n            rxd: 0,\n            mgr: _mgr,\n            res: 0\n        });\n        emit Init(id, _usr);\n    }\n\n    /*\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim all available rewards\n        @param _id     The id of the vesting contract\n    */\n    function vest(uint256 _id) external {\n        _vest(_id, type(uint256).max);\n    }\n\n    /*\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim rewards\n        @param _id     The id of the vesting contract\n        @param _maxAmt The maximum amount to vest\n    */\n    function vest(uint256 _id, uint256 _maxAmt) external {\n        _vest(_id, _maxAmt);\n    }\n\n    /*\n        @dev Anyone (or only owner of a vesting contract if restricted) calls this to claim rewards\n        @param _id     The id of the vesting contract\n        @param _maxAmt The maximum amount to vest\n    */\n    function _vest(uint256 _id, uint256 _maxAmt) internal lock {\n        Award memory _award = awards[_id];\n        require(_award.usr != address(0), \"DssVest/invalid-award\");\n        require(_award.res == 0 || _award.usr == msg.sender, \"DssVest/only-user-can-claim\");\n        uint256 amt = unpaid(block.timestamp, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd);\n        amt = min(amt, _maxAmt);\n        awards[_id].rxd = toUint128(add(_award.rxd, amt));\n        pay(_award.usr, amt);\n        emit Vest(_id, amt);\n    }\n\n    /*\n        @dev amount of tokens accrued, not accounting for tokens paid\n        @param _id The id of the vesting contract\n    */\n    function accrued(uint256 _id) external view returns (uint256 amt) {\n        Award memory _award = awards[_id];\n        require(_award.usr != address(0), \"DssVest/invalid-award\");\n        amt = accrued(block.timestamp, _award.bgn, _award.fin, _award.tot);\n    }\n\n    /*\n        @dev amount of tokens accrued, not accounting for tokens paid\n        @param _time the timestamp to perform the calculation\n        @param _bgn  the start time of the contract\n        @param _end  the end time of the contract\n        @param _amt  the total amount of the contract\n    */\n    function accrued(uint256 _time, uint48 _bgn, uint48 _fin, uint128 _tot) internal pure returns (uint256 amt) {\n        if (_time < _bgn) {\n            amt = 0;\n        } else if (_time >= _fin) {\n            amt = _tot;\n        } else {\n            amt = mul(_tot, sub(_time, _bgn)) / sub(_fin, _bgn); // 0 <= amt < _award.tot\n        }\n    }\n\n    /*\n        @dev return the amount of vested, claimable GEM for a given ID\n        @param _id The id of the vesting contract\n    */\n    function unpaid(uint256 _id) external view returns (uint256 amt) {\n        Award memory _award = awards[_id];\n        require(_award.usr != address(0), \"DssVest/invalid-award\");\n        amt = unpaid(block.timestamp, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd);\n    }\n\n    /*\n        @dev amount of tokens accrued, not accounting for tokens paid\n        @param _time the timestamp to perform the calculation\n        @param _bgn  the start time of the contract\n        @param _clf  the timestamp of the cliff\n        @param _end  the end time of the contract\n        @param _tot  the total amount of the contract\n        @param _rxd  the number of gems received\n    */\n    function unpaid(uint256 _time, uint48 _bgn, uint48 _clf, uint48 _fin, uint128 _tot, uint128 _rxd) internal pure returns (uint256 amt) {\n        amt = _time < _clf ? 0 : sub(accrued(_time, _bgn, _fin, _tot), _rxd);\n    }\n\n    /*\n        @dev Allows governance or the owner to restrict vesting to the owner only\n        @param _id The id of the vesting contract\n    */\n    function restrict(uint256 _id) external lock {\n        address usr_ = awards[_id].usr;\n        require(usr_ != address(0), \"DssVest/invalid-award\");\n        require(wards[msg.sender] == 1 || usr_ == msg.sender, \"DssVest/not-authorized\");\n        awards[_id].res = 1;\n        emit Restrict(_id);\n    }\n\n    /*\n        @dev Allows governance or the owner to enable permissionless vesting\n        @param _id The id of the vesting contract\n    */\n    function unrestrict(uint256 _id) external lock {\n        address usr_ = awards[_id].usr;\n        require(usr_ != address(0), \"DssVest/invalid-award\");\n        require(wards[msg.sender] == 1 || usr_ == msg.sender, \"DssVest/not-authorized\");\n        awards[_id].res = 0;\n        emit Unrestrict(_id);\n    }\n\n    /*\n        @dev Allows governance or the manager to remove a vesting contract immediately\n        @param _id The id of the vesting contract\n    */\n    function yank(uint256 _id) external {\n        _yank(_id, block.timestamp);\n    }\n\n    /*\n        @dev Allows governance or the manager to remove a vesting contract at a future time\n        @param _id  The id of the vesting contract\n        @param _end A scheduled time to end the vest\n    */\n    function yank(uint256 _id, uint256 _end) external {\n        _yank(_id, _end);\n    }\n\n    /*\n        @dev Allows governance or the manager to end pre-maturely a vesting contract\n        @param _id  The id of the vesting contract\n        @param _end A scheduled time to end the vest\n    */\n    function _yank(uint256 _id, uint256 _end) internal lock {\n        require(wards[msg.sender] == 1 || awards[_id].mgr == msg.sender, \"DssVest/not-authorized\");\n        Award memory _award = awards[_id];\n        require(_award.usr != address(0), \"DssVest/invalid-award\");\n        if (_end < block.timestamp) {\n            _end = block.timestamp;\n        }\n        if (_end < _award.fin) {\n            uint48 end = toUint48(_end);\n            awards[_id].fin = end;\n            if (end < _award.bgn) {\n                awards[_id].bgn = end;\n                awards[_id].clf = end;\n                awards[_id].tot = 0;\n            } else if (end < _award.clf) {\n                awards[_id].clf = end;\n                awards[_id].tot = 0;\n            } else {\n                awards[_id].tot = toUint128(\n                                    add(\n                                        unpaid(_end, _award.bgn, _award.clf, _award.fin, _award.tot, _award.rxd),\n                                        _award.rxd\n                                    )\n                                );\n            }\n        }\n\n        emit Yank(_id, _end);\n    }\n\n    /*\n        @dev Allows owner to move a contract to a different address\n        @param _id  The id of the vesting contract\n        @param _dst The address to send ownership of the contract to\n    */\n    function move(uint256 _id, address _dst) external lock {\n        require(awards[_id].usr == msg.sender, \"DssVest/only-user-can-move\");\n        require(_dst != address(0), \"DssVest/zero-address-invalid\");\n        awards[_id].usr = _dst;\n        emit Move(_id, _dst);\n    }\n\n    /*\n        @dev Return true if a contract is valid\n        @param _id The id of the vesting contract\n    */\n    function valid(uint256 _id) external view returns (bool isValid) {\n        isValid = awards[_id].rxd < awards[_id].tot;\n    }\n\n    /*\n        @dev Override this to implement payment logic.\n        @param _guy The payment target.\n        @param _amt The payment amount. [units are implementation-specific]\n    */\n    function pay(address _guy, uint256 _amt) virtual internal;\n}\n\ncontract DssVestMintable is DssVest {\n\n    MintLike public immutable gem;\n\n    /*\n        @dev This contract must be authorized to 'mint' on the token\n        @param _gem The contract address of the mintable token\n    */\n    constructor(address _gem) public DssVest() {\n        require(_gem != address(0), \"DssVest/Invalid-token-address\");\n        gem = MintLike(_gem);\n    }\n\n    /*\n        @dev Override pay to handle mint logic\n        @param _guy The recipient of the minted token\n        @param _amt The amount of token units to send to the _guy\n    */\n    function pay(address _guy, uint256 _amt) override internal {\n        gem.mint(_guy, _amt);\n    }\n}\n\ncontract DssVestSuckable is DssVest {\n\n    uint256 internal constant RAY = 10**27;\n\n    ChainlogLike public immutable chainlog;\n    VatLike      public immutable vat;\n    DaiJoinLike  public immutable daiJoin;\n\n    /*\n        @dev This contract must be authorized to 'suck' on the vat\n        @param _chainlog The contract address of the MCD chainlog\n    */\n    constructor(address _chainlog) public DssVest() {\n        require(_chainlog != address(0), \"DssVest/Invalid-chainlog-address\");\n        ChainlogLike chainlog_ = chainlog = ChainlogLike(_chainlog);\n        VatLike vat_ = vat = VatLike(chainlog_.getAddress(\"MCD_VAT\"));\n        DaiJoinLike daiJoin_ = daiJoin = DaiJoinLike(chainlog_.getAddress(\"MCD_JOIN_DAI\"));\n\n        vat_.hope(address(daiJoin_));\n    }\n\n    /*\n        @dev Override pay to handle suck logic\n        @param _guy The recipient of the ERC-20 Dai\n        @param _amt The amount of Dai to send to the _guy [WAD]\n    */\n    function pay(address _guy, uint256 _amt) override internal {\n        vat.suck(chainlog.getAddress(\"MCD_VOW\"), address(this), mul(_amt, RAY));\n        daiJoin.exit(_guy, _amt);\n    }\n}\n\n/**\n    Transferrable token DssVest. Can be used to enable streaming payments of\n     any arbitrary token from an address (i.e. CU multisig) to individual\n     contributors.\n */\ncontract DssVestTransferrable is DssVest {\n\n    address   public immutable czar;\n    TokenLike public immutable gem;\n\n    /*\n        @dev This contract must be approved for transfer of the gem on the czar\n        @param _czar The owner of the tokens to be distributed\n        @param _gem  The token to be distributed\n    */\n    constructor(address _czar, address _gem) public DssVest() {\n        require(_czar != address(0), \"DssVest/Invalid-distributor-address\");\n        require(_gem  != address(0), \"DssVest/Invalid-token-address\");\n        czar = _czar;\n        gem  = TokenLike(_gem);\n    }\n\n    /*\n        @dev Override pay to handle transfer logic\n        @param _guy The recipient of the ERC-20 Dai\n        @param _amt The amount of gem to send to the _guy (in native token units)\n    */\n    function pay(address _guy, uint256 _amt) override internal {\n        require(gem.transferFrom(czar, _guy, _amt));\n    }\n}"}}}