{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DFBTCV1Factory.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport \"./libraries/chainlink/AggregatorV3Interface.sol\";\nimport './libraries/IERC20.sol';\nimport './libraries/SafeMath.sol';\nimport './libraries/TransferHelper.sol';\n\ncontract DFBTCV1Factory {\n  using SafeMath for uint256;\n  \n   //*************************POOL Begin************************\n  struct Pools {\n    address _coinAddress;\n    uint _minAmounts;\n    uint _decimalAmount;\n  }\n\n  address[] public poolAddressList;\n  mapping(address => Pools) public poolmap;\n  mapping(address => address) public priceFeedmap;\n  //*************************POOL End**************************\n\n  //*************************User Begin************************\n  struct User {\n    address _eth;\n    uint _startTime;\n    uint _pledgeCycle;\n    uint _curBTC;\n    //uint _btcVal;\n    string _btc;\n    bool _bReceive;\n    //bool _Receive;\n    bool _bExist;\n  }\n\n  address[] public guarantorList;\n  mapping(address => User) public guarantUserMap;\n  mapping(address => mapping(address => uint)) public userAssets;//用户资产\n\n  event e_userTransfer_records(address indexed _eth, address indexed _coin, uint _amount, uint _addtime);\n  //*************************User End**************************\n\n  //************************Order Begin************************\n  struct dfbtcOrderClass {\n      address _from;\n      address _to;\n      string _toBTC;\n      uint _btcAmount;\n      uint _dfbtcAmount;\n      uint _createTime;\n      uint _type;\n      bool _bExist;\n  }\n  \n  mapping(address => dfbtcOrderClass) public dfbtcOrder;\n  event e_dfbtc_order(address indexed _from, address indexed _to, uint indexed _type, string _toBTC, uint _btcAmount, uint _dfbtcAmount, uint _createTime, uint _status);\n//************************Order End**************************\n\n  mapping(uint=>bool) public cycle;\n  uint public btcToDfbtc = 10000;\n  address public btcPriceFeed = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;\n\n  address public aomAddress = 0x060924FB947e37EEE230d0B1A71D9618aEc269fC;\n  address public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public dfbtcAddress = 0x67C8d54F38369571AAe70183b8568494032b5D7C;\n\n  address public onwer;\n  address public coo;\n  address public feeAddress = address(0);\n  uint public fee = 0;\n  uint public ETHAPY = 16;\n  uint public TokenAPY = 9;\n\n  uint public btcVal = 0;\n\n  modifier onlyOnwer {\n    require(onwer == msg.sender, \"dfbtc: The caller must be onwer!!!\");\n    _;\n  }\n  \n  function setAPY(uint ethA, uint tokenA) public onlyOnwer returns (bool) {\n    ETHAPY = ethA;\n    TokenAPY = tokenA;\n    return true;\n  }\n\n  \n  constructor() public {\n    onwer = msg.sender;\n    coo = msg.sender;\n    cycle[30] = true;//30);\n    cycle[90] = true;\n    cycle[180] = true;\n    cycle[360] = true;\n\n    addPoolSet(aomAddress, 10000e18, 1);\n    addPoolSet(ethAddress, 0, 1);\n    addPoolSet(0xdAC17F958D2ee523a2206206994597C13D831ec7, 0, 1e12);//usdt\n    addPoolSet(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, 0, 1e12);//usdc\n    addPoolSet(0x6B175474E89094C44Da98b954EedeAC495271d0F, 0, 1);//dai\n    initPriceFeedmap(ethAddress, 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    initPriceFeedmap(0xdAC17F958D2ee523a2206206994597C13D831ec7, 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D);\n    initPriceFeedmap(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6);\n    initPriceFeedmap(0x6B175474E89094C44Da98b954EedeAC495271d0F, 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9);\n  }\n\n  //*************************POOL Begin************************\n  function getPoolsLength() public view returns (uint) {\n    return poolAddressList.length;\n  }\n\n  function getPoollist() public view returns (address[] memory){\n    return poolAddressList;\n  }\n\n  function addPoolSet(address _cAddress, uint _minVal, uint _deimalVal) public onlyOnwer returns (bool) {\n    Pools memory _tp = Pools({\n    _coinAddress : _cAddress,\n    _minAmounts : _minVal,\n    _decimalAmount : _deimalVal\n    });\n\n    poolAddressList.push(_cAddress);\n    poolmap[_cAddress] = _tp;\n    return true;\n  }\n\n  function editPoolset(address _cAddress, uint _minVal, uint _decimalVal) public onlyOnwer returns (bool) {\n    poolmap[_cAddress]._minAmounts = _minVal;\n    poolmap[_cAddress]._decimalAmount = _decimalVal;\n\n    return true;\n  }\n\n  function initPriceFeedmap(address tokenAddress, address priceAddress) public onlyOnwer returns (bool){\n    priceFeedmap[tokenAddress] = priceAddress;\n    return true;\n  }\n  //*************************POOL End************************\n\n  //*************************USER Begin************************\n  function getGuarantUserCount() public view returns (uint) {\n      return guarantorList.length;\n  }\n  \n  function getUserCanGetBTCAmount(address user) public view returns (uint) {\n    uint totalprice = 0;\n    for(uint i=0; i<poolAddressList.length; i++){\n      uint uerAssets = userAssets[poolAddressList[i]][user];\n      if(poolAddressList[i]!=aomAddress && uerAssets > 0){\n        totalprice = uerAssets.mul(getThePrice(poolAddressList[i])).mul(poolmap[poolAddressList[i]]._decimalAmount).add(totalprice);\n      }\n    }\n    return totalprice.mul(10).div(getThePrice(btcPriceFeed)).div(15);\n  }\n  \n  function liquidationAssets(address user) public onlyOnwer {\n      require(getUserCanGetBTCAmount(user)<guarantUserMap[user]._curBTC, \"dfbtc: The node assets are abundant!!!\");\n      for(uint i=0; i<poolAddressList.length; i++){\n          uint uerAssets = userAssets[poolAddressList[i]][user];\n          if(uerAssets > 0){\n              if(isETH(poolAddressList[i])){\n                  msg.sender.transfer(uerAssets);\n              }else{\n                  TransferHelper.safeTransfer(poolAddressList[i], coo, uerAssets);\n              }\n              \n              userAssets[poolAddressList[i]][user] = 0;\n          }\n        }\n  }\n  \n  function addTokenToPools(address[] memory _tokenList, uint[] memory _valueList, uint ethvalue) private returns (uint) {\n      uint totalprice = 0;\n      for(uint i=0; i<_tokenList.length; i++){\n          require(IERC20(_tokenList[i]).balanceOf(msg.sender)>=_valueList[i], \"dfbtc: Insufficient quantity!!!\");\n          require(IERC20(_tokenList[i]).allowance(msg.sender, address(this))>=_valueList[i], \"dfbtc: There are not enough authorizations!!!\");\n          require(_valueList[i]>=poolmap[_tokenList[i]]._minAmounts, \"dfbtc: Must be greater than the minimum value!!!\");\n          \n          if(_valueList[i]>0){\n              TransferHelper.safeTransferFrom(_tokenList[i], msg.sender, address(this), _valueList[i]);\n              userAssets[_tokenList[i]][msg.sender] = _valueList[i].add(userAssets[_tokenList[i]][msg.sender]);\n              emit e_userTransfer_records(msg.sender, _tokenList[i], _valueList[i], now);\n                  \n              if(_tokenList[i]!=aomAddress){\n                  totalprice = _valueList[i].mul(getThePrice(_tokenList[i])).mul(poolmap[_tokenList[i]]._decimalAmount).add(totalprice);\n              }\n          }\n      }\n      \n      if(ethvalue>0){\n          userAssets[ethAddress][msg.sender] = ethvalue.add(userAssets[ethAddress][msg.sender]);\n          emit e_userTransfer_records(msg.sender, ethAddress, ethvalue, now);\n              \n          totalprice = ethvalue.mul(getThePrice(ethAddress)).mul(poolmap[ethAddress]._decimalAmount).add(totalprice);\n      }\n  \n      return totalprice.div(getThePrice(btcPriceFeed));\n  }\n  \n  function addGuarantorNode(address[] memory _tokenList, uint[] memory _valueList, uint _pledgeCycle, string memory _btcAddress) public payable returns (bool){\n      require(_tokenList.length>0, \"dfbtc: Array length must be greater than 0!!!\");\n      require(_tokenList.length==_valueList.length, \"dfbtc: Array length must be equal!!!\");\n      require(cycle[_pledgeCycle], \"dfbtc: The period value is not within the set range!\");\n      require(!guarantUserMap[msg.sender]._bExist, \"dfbtc: Guarantor already exists!\");\n  \n      uint btcVal_ = addTokenToPools(_tokenList, _valueList, msg.value);\n\n      User memory _user = User({\n        _eth : msg.sender,\n        _startTime : now,\n        _pledgeCycle : _pledgeCycle*1 days,\n        _curBTC : 0,\n        _btc : _btcAddress,\n        _bReceive : true,\n        _bExist : true\n      });\n\n      guarantorList.push(msg.sender);\n      guarantUserMap[msg.sender] = _user;\n\n      IERC20(dfbtcAddress).mint(address(this), uint(btcVal_).mul(btcToDfbtc));\n\n      return true;\n  }\n  \n  function addGuarantorNodeAssets(address[] memory _tokenList, uint[] memory _valueList) public payable returns (bool) {\n      require(guarantUserMap[msg.sender]._bExist, \"dfbtc: Guarantor not exists!!!\");\n      require(_tokenList.length>0, \"dfbtc: Array length must be greater than 0!!!\");\n      require(_tokenList.length==_valueList.length, \"dfbtc: Array length must be equal!!!\");\n      \n      uint btcVal_ = addTokenToPools(_tokenList, _valueList, msg.value);\n      //guarantUserMap[msg.sender]._btcVal = btcVal_;\n\n      IERC20(dfbtcAddress).mint(address(this), uint(btcVal_).mul(btcToDfbtc));\n\n      return true;\n  }\n  \n  function redeemAssets(address tokenAddress) public returns(bool){\n    require(guarantUserMap[msg.sender]._bExist, \"dfbtc: Guarantor not exists!!!\");\n    require(!dfbtcOrder[msg.sender]._bExist, \"dfbtc: Order exists!!!\");\n    require(guarantUserMap[msg.sender]._curBTC==0, \"dfbtc: There is currently btc in custody!!!\");\n    require(now >= (guarantUserMap[msg.sender]._startTime.sub(guarantUserMap[msg.sender]._pledgeCycle)), \"dfbtc: There is currently btc in custody!!!\");\n    require(userAssets[tokenAddress][msg.sender] > 0, \"dfbtc: Your assets is zero!!!\");\n    \n    if(isETH(tokenAddress)){\n      msg.sender.transfer(userAssets[tokenAddress][msg.sender].add(userAssets[tokenAddress][msg.sender].mul(ETHAPY).div(100)));\n    }else{\n      TransferHelper.safeTransfer(tokenAddress, msg.sender, userAssets[tokenAddress][msg.sender].add(userAssets[tokenAddress][msg.sender].mul(TokenAPY).div(100)));\n    }\n    uint totalprice = getThePrice(tokenAddress).mul(userAssets[tokenAddress][msg.sender]);\n    IERC20(dfbtcAddress).burn(totalprice.div(getThePrice(btcPriceFeed)).mul(btcToDfbtc));\n    return true;\n  }\n  //*************************USER End************************\n  function safeTransferToOtherPools(address tokenAddress, address toAdddress, uint transferValue) public {\n    require((onwer == msg.sender || coo == msg.sender), \"dfbtc: You are not owner!!!\");\n    if(isETH(tokenAddress)){\n         address(uint160(toAdddress)).transfer(transferValue);\n    }else{\n         TransferHelper.safeTransfer(tokenAddress, toAdddress, transferValue);\n    }\n  }\n  //***********************Order Start***********************\n  function getGuarantorUserForOrder(address _usera, uint btcAmount, bool bBurn) public view returns (address, string memory){\n      address retVal = address(0);\n      string memory btcA = \"\";\n      for(uint i=0; i<guarantorList.length; i++){\n          if(_usera!= guarantorList[i]){\n              if((!dfbtcOrder[guarantorList[i]]._bExist) || (now >= (dfbtcOrder[msg.sender]._createTime + 1 days))){\n                 if(bBurn){\n                      if(guarantUserMap[guarantorList[i]]._curBTC>=btcAmount){\n                          retVal = guarantorList[i];\n                          btcA = guarantUserMap[guarantorList[i]]._btc;\n                          break;\n                      }\n                  }else{\n                      if((getUserCanGetBTCAmount(guarantorList[i]).sub(guarantUserMap[guarantorList[i]]._curBTC))>=btcAmount){\n                          retVal = guarantorList[i];\n                          btcA = guarantUserMap[guarantorList[i]]._btc;\n                          break;\n                      }\n                  }\n              }\n              \n          }\n      }\n      \n      return (retVal, btcA);\n  }\n  \n  function createTransferBTCOrder(address _gua) public {\n    require(guarantUserMap[_gua]._bExist, \"dfbtc: Guarantor not exist!!!\");\n    require(msg.sender!=_gua, \"dfbtc: Can't be the same person!!!\");\n    if(dfbtcOrder[msg.sender]._bExist){\n        require(now >= (dfbtcOrder[msg.sender]._createTime + 1 days), \"dfbtc: Time more than 1 days!!!\");\n    }\n    if(dfbtcOrder[_gua]._bExist){\n        require(now >= (dfbtcOrder[_gua]._createTime + 1 days), \"dfbtc: Time more than 1 days!!!\");\n    }\n    require(guarantUserMap[msg.sender]._bExist, \"dfbtc: You are not guarantor!!!\");\n    require(guarantUserMap[msg.sender]._curBTC>0, \"dfbtc: You has not BTC!!!\");\n    require((getUserCanGetBTCAmount(_gua).sub(guarantUserMap[_gua]._curBTC))>=guarantUserMap[msg.sender]._curBTC, \"dfbtc: Guarantor has not enough assets!!!\");\n\n    dfbtcOrderClass memory _order = dfbtcOrderClass({\n        _from : msg.sender,\n        _to : _gua,\n        _toBTC : guarantUserMap[_gua]._btc,\n        _btcAmount : guarantUserMap[msg.sender]._curBTC,\n        _dfbtcAmount : 0,\n        _createTime : now,\n        _type : 3,\n        _bExist : true\n    });\n\n    dfbtcOrder[_gua] = _order;\n    dfbtcOrder[msg.sender] = _order;\n    \n    emit e_dfbtc_order(msg.sender, _gua, 3, _order._toBTC, _order._btcAmount, _order._dfbtcAmount, _order._createTime, 1);\n  }\n  \n  function confirmTransferOrderSuccess(address guarant) public {\n      require((onwer == msg.sender || coo == msg.sender), \"dfbtc: You are not owner!!!\");\n      require(guarantUserMap[guarant]._bExist, \"dfbtc: Guarantor not exists!\");\n      require(dfbtcOrder[guarant]._bExist, \"dfbtc: Order not exists!\");\n      require(dfbtcOrder[guarant]._to==guarant, \"dfbtc: The user are not guarantor of this order!\");\n      require(dfbtcOrder[guarant]._type==3, \"dfbtc: The type of order is not 1!\");\n      \n      dfbtcOrder[guarant]._bExist = false;\n      dfbtcOrder[dfbtcOrder[guarant]._from]._bExist = false;\n\n      guarantUserMap[guarant]._curBTC = guarantUserMap[guarant]._curBTC.add(dfbtcOrder[guarant]._btcAmount);\n      guarantUserMap[dfbtcOrder[guarant]._from]._curBTC = 0;\n      \n      emit e_dfbtc_order(dfbtcOrder[msg.sender]._from, guarant, 3, dfbtcOrder[guarant]._toBTC, dfbtcOrder[guarant]._btcAmount, dfbtcOrder[guarant]._dfbtcAmount, now, 2);\n  }\n  \n  function createOrder(uint _btcAmount, address _gua) public {\n    require(guarantUserMap[_gua]._bExist, \"dfbtc: Guarantor not exist!!!\");\n    require(msg.sender!=_gua, \"dfbtc: Can't be the same person!!!\");\n    if(dfbtcOrder[_gua]._bExist){\n        require(now >= (dfbtcOrder[_gua]._createTime + 1 days), \"dfbtc: Time more than 1 days!!!\");\n    }\n    require((getUserCanGetBTCAmount(_gua).sub(guarantUserMap[_gua]._curBTC))>=_btcAmount, \"dfbtc: Guarantor has not enough assets!!!\");\n\n    uint dfbtcVal = _btcAmount.mul(btcToDfbtc);\n    if(fee>0){\n      uint feeVal = dfbtcVal.mul(fee).div(100);\n      dfbtcVal = dfbtcVal.sub(feeVal);\n    }\n\n    dfbtcOrderClass memory _order = dfbtcOrderClass({\n        _from : msg.sender,\n        _to : _gua,\n        _toBTC : guarantUserMap[_gua]._btc,\n        _btcAmount : _btcAmount,\n        _dfbtcAmount : dfbtcVal,\n        _createTime : now,\n        _type : 1,\n        _bExist : true\n    });\n\n    dfbtcOrder[_gua] = _order;\n    dfbtcOrder[msg.sender] = _order;\n    \n    emit e_dfbtc_order(msg.sender, _gua, 1, _order._toBTC, _btcAmount, _order._dfbtcAmount, _order._createTime, 1);\n  }\n  \n  function confirmOrderSuccess(address guarant) public {\n      require((onwer == msg.sender || coo == msg.sender), \"dfbtc: You are not owner!!!\");\n      require(guarantUserMap[guarant]._bExist, \"dfbtc: Guarantor not exists!\");\n      require(dfbtcOrder[guarant]._bExist, \"dfbtc: Order not exists!\");\n      require(dfbtcOrder[guarant]._to==guarant, \"dfbtc: The user are not guarantor of this order!\");\n      require(dfbtcOrder[guarant]._type==1, \"dfbtc: The type of order is not 1!\");\n      \n      dfbtcOrder[guarant]._bExist = false;\n      dfbtcOrder[dfbtcOrder[guarant]._from]._bExist = false;\n\n      btcVal = btcVal.add(dfbtcOrder[guarant]._btcAmount);\n      guarantUserMap[guarant]._curBTC = guarantUserMap[guarant]._curBTC.add(dfbtcOrder[guarant]._btcAmount);\n      \n      uint dfbtcVal = dfbtcOrder[guarant]._btcAmount.mul(btcToDfbtc);\n      if(fee>0){\n        uint feeVal = dfbtcVal.mul(fee).div(100);\n        TransferHelper.safeTransfer(dfbtcAddress, feeAddress, feeVal);\n        dfbtcVal = dfbtcVal.sub(feeVal);\n      }\n      TransferHelper.safeTransfer(dfbtcAddress, dfbtcOrder[guarant]._from, dfbtcVal);\n      emit e_dfbtc_order(dfbtcOrder[msg.sender]._from, guarant, 1, dfbtcOrder[guarant]._toBTC, dfbtcOrder[guarant]._btcAmount, dfbtcOrder[guarant]._dfbtcAmount, now, 2);\n  }\n  \n  function createBurnOrder(address _gauarant, string memory _btc, uint _btcAmount) public {\n    require(guarantUserMap[_gauarant]._bExist, \"dfbtc: Guarantor not exist!!!\");\n    if(dfbtcOrder[_gauarant]._bExist){\n        require(now >= (dfbtcOrder[_gauarant]._createTime + 1 days), \"dfbtc: Time more than 1 days!!!\");\n    }\n    require(msg.sender!=_gauarant, \"dfbtc: Can't be the same person!!!\");\n    require(guarantUserMap[_gauarant]._curBTC>=_btcAmount, \"dfbtc: Guarantor has not enough amount!!!\");\n    require(IERC20(dfbtcAddress).balanceOf(msg.sender)>=_btcAmount.mul(btcToDfbtc), \"dfbtc: Insufficient quantity!!!\");\n    \n    uint dfbtcVal = _btcAmount.mul(btcToDfbtc);\n    if(fee>0){\n      uint feeVal = dfbtcVal.mul(fee).div(100);\n      dfbtcVal = dfbtcVal.sub(feeVal);\n      TransferHelper.safeTransfer(dfbtcAddress, feeAddress, feeVal);\n    }\n    \n    dfbtcOrderClass memory _order = dfbtcOrderClass({\n        _from : _gauarant,\n        _to : msg.sender,\n        _toBTC : _btc,\n        _btcAmount : dfbtcVal.div(btcToDfbtc),\n        _dfbtcAmount : dfbtcVal,\n        _createTime : now,\n        _type : 2,\n        _bExist : true\n    });\n    \n    dfbtcOrder[_gauarant] = _order;\n    dfbtcOrder[msg.sender] = _order;\n    \n    TransferHelper.safeTransferFrom(dfbtcAddress, msg.sender, address(this), _btcAmount.mul(btcToDfbtc));\n    emit e_dfbtc_order(_gauarant, msg.sender, 2, _btc, _order._btcAmount, _order._dfbtcAmount, _order._createTime, 1);\n  }\n  \n  function confirmBurnOrderSuccess(address user) public {\n    require((onwer == msg.sender || coo == msg.sender), \"dfbtc: You are not owner!!!\");\n    require(dfbtcOrder[user]._bExist, \"dfbtc: Order not exists!\");\n    require(dfbtcOrder[user]._to==user, \"dfbtc: You are not user of this order!\");\n    require(dfbtcOrder[user]._type==2, \"dfbtc: The type of order is not 2!\");\n\n    dfbtcOrder[user]._bExist = false;\n    dfbtcOrder[dfbtcOrder[user]._from]._bExist = false;\n\n    btcVal = btcVal.sub(dfbtcOrder[user]._btcAmount);\n    guarantUserMap[dfbtcOrder[user]._from]._curBTC = guarantUserMap[dfbtcOrder[user]._from]._curBTC.sub(dfbtcOrder[user]._btcAmount);\n\n    emit e_dfbtc_order(dfbtcOrder[user]._from, user, 2, dfbtcOrder[user]._toBTC, dfbtcOrder[user]._btcAmount, dfbtcOrder[user]._dfbtcAmount, now, 2);\n  }\n  \n  function dowithBurnOrderFailerMoreDays(address user) public {\n    require(msg.sender==onwer||msg.sender==coo, \"dfbtc: only manager can run this function!!!\");\n    require(dfbtcOrder[user]._bExist, \"dfbtc: Order not exists!\");\n    require(dfbtcOrder[user]._to==user, \"dfbtc: You are not a guarantor!\");\n    require(dfbtcOrder[user]._type==2, \"dfbtc: The type of order is not 2!\");\n    require(now >= (dfbtcOrder[user]._createTime + 1 days), \"dfbtc: Time more than 1 days!!!\");\n    uint tot = getThePrice(btcPriceFeed).mul(dfbtcOrder[user]._btcAmount);\n    dfbtcOrder[user]._bExist = false;\n    dfbtcOrder[dfbtcOrder[user]._from]._bExist = false;\n    btcVal = btcVal.sub(dfbtcOrder[user]._btcAmount);\n    guarantUserMap[dfbtcOrder[user]._from]._curBTC = guarantUserMap[dfbtcOrder[user]._from]._curBTC.sub(dfbtcOrder[user]._btcAmount);\n    dowithGuarantAssets(dfbtcOrder[user]._from, user, tot);\n    emit e_dfbtc_order(dfbtcOrder[user]._from, user, 2, dfbtcOrder[user]._toBTC, dfbtcOrder[user]._btcAmount, dfbtcOrder[user]._dfbtcAmount, now, 4);\n  }\n  \n  function dowithGuarantAssets(address fromUser, address user, uint tot) private {\n    require(tot>0, \"dfbtc: Assets must more than 0!!!\");\n    for(uint i=0; i<poolAddressList.length; i++){\n      if(tot == 0){\n        break;\n      }\n      uint uerAssets = userAssets[poolAddressList[i]][fromUser];\n      if(poolAddressList[i]!=aomAddress && uerAssets>0){\n        uint tokenPrice = getThePrice(poolAddressList[i]);\n        uint tokenAmount = tot.div(tokenPrice);\n        uint userTot = uerAssets.mul(tokenPrice);\n        uint needTransfer = 0;\n        if(userTot>=tot){\n          needTransfer = tokenAmount;\n          tot = 0;\n        }else{\n          needTransfer = uerAssets;\n          tot = tot.sub(userTot);\n        }\n        if(isETH(poolAddressList[i])){\n          address(uint160(user)).transfer(needTransfer);\n        }else{\n          TransferHelper.safeTransfer(poolAddressList[i], user, needTransfer);\n        }\n        userAssets[poolAddressList[i]][fromUser] = userAssets[poolAddressList[i]][fromUser].sub(needTransfer);\n      }\n    }\n  }\n  //*************************Order End************************\n\n  function getThePrice(address _wjhy) public view returns (uint){//(uint80, int, uint, uint, uint80) {\n    //0x9326BFA02ADD2366b30bacB125260Af641031331\n    AggregatorV3Interface priceFeed;\n    if(_wjhy == btcPriceFeed){\n      priceFeed = AggregatorV3Interface(btcPriceFeed);\n    }else{\n      priceFeed = AggregatorV3Interface(priceFeedmap[_wjhy]);\n    }\n    //priceFeed = AggregatorV3Interface(_wjhy);\n    (\n    uint80 roundID,\n    int price,\n    uint startedAt,\n    uint timeStamp,\n    uint80 answeredInRound\n    ) = priceFeed.latestRoundData();\n    return uint(price);//(roundID, price, startedAt, timeStamp, answeredInRound);\n  }\n\n  function isETH(address _coinaddress) public view returns (bool) {\n    if(ethAddress == _coinaddress){\n      return true;\n    }else{\n      return false;\n    }\n  }\n\n  function setBtcPriceFeed(address pf) public onlyOnwer returns (bool) {\n    btcPriceFeed = pf;\n    return true;\n  }\n\n  function setCycle(uint _value) public onlyOnwer returns (bool) {\n    cycle[_value] = true;\n    return true;\n  }\n\n  function setAOMAddress(address _newAddress) public onlyOnwer returns (bool){\n    aomAddress = _newAddress;\n    return true;\n  }\n\n  function setDfbtcAddress(address _newAddress) public onlyOnwer returns (bool){\n    dfbtcAddress = _newAddress;\n    return true;\n  }\n\n  function setOnwer(address _onwer) public {\n    require(msg.sender == onwer, 'dfbtc: FORBIDDEN');\n    onwer = _onwer;\n  }\n  \n  function setCoo(address _Coo) public {\n    require(msg.sender == onwer, 'dfbtc: FORBIDDEN');\n    coo = _Coo;\n  }\n\n  function isContract(address addr) public view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addr) }\n    return size > 0;\n  }\n\n  function getBalanceByAddress(address _coinAddress, address _userAddress) public view returns (uint) {\n    if(isETH(_coinAddress)){\n      return _userAddress.balance;\n    }\n    require(isContract(_coinAddress), \"dfbtc: Not a contract address!\");\n    return IERC20(_coinAddress).balanceOf(_userAddress);\n  }\n\n  function getDFBTCTotal() public view returns (uint) {\n    return IERC20(dfbtcAddress).totalSupply();\n  }\n\n  function setFee(address _feeAddress, uint _fee) public onlyOnwer returns (bool) {\n    feeAddress = _feeAddress;\n    fee = _fee;\n    return true;\n  }\n}\n"
    },
    "libraries/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function mint(address _to, uint256 _amount) external returns (bool);\n    function burn(uint value) external;\n}\n"
    },
    "libraries/SafeMath.sol": {
      "content": "pragma solidity =0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    assert(c / _a == _b);\n    return c;\n  }\n\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    return _a / _b;\n  }\n\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    assert(_b <= _a);\n    return _a - _b;\n  }\n\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n}"
    },
    "libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.16;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n}\n"
    },
    "libraries/chainlink/AggregatorV3Interface.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    }
  }
}