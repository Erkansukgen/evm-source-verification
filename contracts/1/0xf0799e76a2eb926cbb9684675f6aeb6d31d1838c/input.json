{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Handler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.6;\n\n\ncontract Handler{\n    address[] private GenOneHolders;\n    uint[] private GenOneHolderTokenAmount;\n    uint private Gen1ToEthRatio = 1;\n    GenOneDex private genOneDexInstance;\n    GenOneToken private genOneTokenInstance;\n    GenTwoToken private genTwoTokenInstance;\n    bool private allowRedeem = false;\n    bool airdropDone = false;\n    address[] private GenTwoHolders;\n    uint[] private GenTwoHolderTokenAmount;\n    address [] private GenTwoRedeemedUsers;\n    bool step2CalledSuccessfully = false;\n    bool step3CalledSuccessfully = false;\n    uint decimals;\n    uint totalSupply; // calibrated for 200000000000000000000000000000 (or roughly 2 times the circulating supply of eth\n    \n\n    constructor(string memory _name, string memory _symbol, uint _decimals, uint _totalSupply) payable{\n        decimals = _decimals;\n        totalSupply = _totalSupply;\n        step1(_name, _symbol, _decimals, _totalSupply);\n        //step2() will also be called due to its financial incentive nature, but we don't have to call it here\n        //step3() will also be called due to its financial incentive nature, but we don't have to call it here\n    }\n    \n    function payMe() public payable returns(bool success) {\n        return true;\n    }\n\n    function loadIncentiveEth(uint weiAmount) public payable{\n        require (weiAmount == msg.value, \"ethAmount does not equal msg.value\");\n    }\n    \n    //private methods that do stuff with the gen1 token or the GenOneDex\n    function step1(string memory _name, string memory _symbol, uint _decimals, uint _totalSupply) private{\n         genOneDexInstance = new GenOneDex(payable(address(this))); //deploy a GenOneDex contract instance\n         genOneTokenInstance = new GenOneToken(_name, _symbol, _decimals, _totalSupply, (address(genOneDexInstance)));//deploy gen1 erc-20 with owner address being the instance of the GenOneDex deployed\n         genOneDexInstance.addTokenInstanceAddress(genOneTokenInstance);\n         genOneDexInstance.allowTrading(true); //call GenOneDex to allow trading \n    }\n    \n    //public methods that are time sensitive\n\n    //half an ether for the first person to call this function when its available\n    function step2(address ethAddress) public payable{\n        require(block.timestamp >= 1640927700, \"too early to call\");\n        require(step2CalledSuccessfully == false, \"step 2 called successfully not false\");\n        require((address(this).balance) >= 200000000 gwei, \"handler does not have enough balance to pay out\");\n        payable(msg.sender).transfer(200000000 gwei);\n        genOneDexInstance.allowTrading(false);\n        GenOneHolders = genOneDexInstance.returnGenOneHolders();\n        GenOneHolderTokenAmount = genOneDexInstance.returnGenOneHolderTokenAmount();\n        genOneDexInstance.removeLiquidity(); //RUGPULL - remove all eth and gen1 token fraction that the GenOneDex has and send it to the handler, allow users to burn their gen1 tokens by sending to burn address\n        step2CalledSuccessfully = true;\n    }\n    \n    //half an ether for the first person to call this function when its available\n    function step3(address ethAddress) public {\n        require(block.timestamp > 1641015000, \"too early to call\");\n        require(step3CalledSuccessfully == false);\n        require((address(this).balance) >= 400000000 gwei);\n        payable(msg.sender).transfer(400000000 gwei);\n        genTwoTokenInstance = new GenTwoToken(\"Generation_B\", \"GENB\", decimals, totalSupply, address(this)); //deploy new tokens after new tax year\n        //airdrop new tokens after tax year (locked on airdrop arrival)\n        for(uint256 i=0; i < GenOneHolders.length; i++){\n            genTwoTokenInstance.transfer(GenOneHolders[i], GenOneHolderTokenAmount[i]);\n        }\n        genTwoTokenInstance.turnOnRedeem();\n        allowRedeem = true; //allow gen2 holders to use redeem method to redeem against gen1 rugpulled eth (need to have first sent gen2 token to handler address) \n        airdropDone = true;\n        step3CalledSuccessfully = true;\n    }\n    \n    //will only work once per wallet address so make sure to send all your gen 2 tokens to the handler\n    //method will fail if user did not first send their Gen 2 tokens to the handler\n    function redeemGenTwo() public {\n        require(((block.timestamp > 1641015000) && (block.timestamp < 1643691600)), \"too early or too late to call\");\n        //make sure this contract has a positive balance\n        require(address(this).balance > 0);\n        //make sure that step3 has been called already\n        require(step3CalledSuccessfully == true);\n        //make sure the person calling this redeem function had gen1 tokens\n        require(findHolderAmountIndex(msg.sender) >= 0);\n        //make sure the person calling this redeem function also has not redeemed before\n        require(inGenTwoRedeemedUsers(msg.sender) == false);\n         \n        if(genTwoTokenInstance.checkBalance(msg.sender) < GenOneHolderTokenAmount[uint(findHolderAmountIndex(msg.sender))]){\n            //helper\n            int senderIndex = findHolderAmountIndex(msg.sender);\n            uint256 senderIndexUint = uint256(senderIndex);\n            payable(msg.sender).transfer((((99*(GenOneHolderTokenAmount[senderIndexUint]  - (genTwoTokenInstance.checkBalance(msg.sender))))/100) * Gen1ToEthRatio));\n        }\n\n        GenTwoRedeemedUsers.push(msg.sender);\n        \n    }\n\n    function devRedeem() public {\n        require(block.timestamp > 1643778000, \"too early to call\");\n        require(address(this).balance > 0);\n        require(msg.sender == address(0xd0fE3391600CbD0b8C055c27Fb269a74ae8f5ba9));\n        payable(msg.sender).transfer(address(this).balance);//send remaining ether to dev wallet \n    }\n    \n    function getAirdropDone() public returns (bool){\n        require(msg.sender == address(genTwoTokenInstance));\n        return airdropDone;\n\n    }\n\n    function findHolderAmountIndex(address _address) public returns (int){  \n        for(uint256 i=0; i < GenOneHolders.length; i++){\n            if(GenOneHolders[i]==_address){\n                return int(i);\n            }\n        }\n        return -1;\n    }\n\n    function inGenTwoRedeemedUsers(address _address) public returns (bool){\n        for(uint256 i=0; i < GenTwoRedeemedUsers.length; i++){\n            if(GenTwoRedeemedUsers[i]==_address){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getGenOneDex() public returns (address payable){\n        return payable(address(genOneDexInstance));\n    }\n\n    function getGenTwoToken() public returns (address){\n        return address(genTwoTokenInstance);\n    }\n    \n}\n\ncontract GenOneDex {\n    address[] private GenOneHolders;\n    uint[] private GenOneHolderTokenAmount;\n    bool private allowTradingFlag = false;\n    address payable handlerContract;\n    GenOneToken private tokenInstance;\n    uint Gen1ToWeiRatio = 1;\n    uint gen1TokensRemaining = 2000000000000000000000000000;\n    \n    constructor(address payable _handlerContract){\n        handlerContract = _handlerContract;\n    }\n\n    \n    function allowTrading(bool value) public{\n        require(msg.sender == handlerContract);\n        allowTradingFlag = value;\n    }\n    \n    function addTokenInstanceAddress(GenOneToken _tokenInstance) public{\n        require(msg.sender == handlerContract);\n        tokenInstance = _tokenInstance;\n    }\n\n    function removeLiquidity() public payable{\n        require(msg.sender == handlerContract, \"remove liquidity called by non handler contract\");\n        require(address(this).balance > 0, \"dex balance is empty\");\n        require(Handler(handlerContract).payMe{value:address(this).balance}(), \"dex sending all eth to handler fail for unknown reason\");//send all the eth to the handler contract\n        tokenInstance.flagLiquidityRemoved(true);\n        tokenInstance.transfer(address(0), gen1TokensRemaining);//burn the remaining gen1 tokens in the GenOneDex instance\n\n    }\n\n\n    function exchangeETHForGenOne(uint weiAmountIn) public payable returns (bool value) {\n        require(msg.value == weiAmountIn, \"msg.value and weiAmountIn don't match\");\n        require(allowTradingFlag, \"trading flag isn't set to true\");\n        require((GenOneToken(tokenInstance).transfer(msg.sender, weiAmountIn)),\"failing transfer\");\n        GenOneHolders.push(msg.sender);\n        GenOneHolderTokenAmount.push(weiAmountIn);\n        gen1TokensRemaining = gen1TokensRemaining - (weiAmountIn);\n        return true;\n    } \n\n\n    function returnGenOneHolders() public view returns (address[] memory){\n        return GenOneHolders;\n    }\n    \n    function returnGenOneHolderTokenAmount() public view returns(uint[] memory) {\n        return GenOneHolderTokenAmount;\n    }\n\n}\n\n\ncontract GenTwoToken{\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n    uint256 public totalSupply;\n    address private ownerHandler;\n    bool allowRedeem = false;\n    \n\n    // Keep track balances and allowances approved\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // Events - fire events on state changes etc\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor(string memory _name, string memory _symbol, uint _decimals, uint _totalSupply, address _ownerHandler) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply; \n        balanceOf[_ownerHandler] = totalSupply;\n        ownerHandler = _ownerHandler;\n\n    }\n\n    /// @notice transfer amount of tokens to an address\n    /// @param _to receiver of token\n    /// @param _value amount value of token to send\n    /// @return success as true, for transfer \n    function transfer(address _to, uint256 _value) external returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /// @dev internal helper transfer function with required safety checks\n    /// @param _from, where funds coming the sender\n    /// @param _to receiver of token\n    /// @param _value amount value of token to send\n    // Internal function transfer can only be called by this contract\n    //  Emit Transfer Event event \n    function _transfer(address _from, address _to, uint256 _value) internal {\n        if(Handler(ownerHandler).getAirdropDone()){\n            require(_to == address(ownerHandler));\n            require(allowRedeem);\n            balanceOf[_from] = balanceOf[_from] - (_value);\n            balanceOf[_to] = balanceOf[_to] + (_value);\n        }\n        else{\n            require (_from == address(ownerHandler));\n            balanceOf[_from] = balanceOf[_from] - (_value);\n            balanceOf[_to] = balanceOf[_to] + (_value);\n        }\n        \n    }\n\n\n    /// @notice transfer by approved person from original address of an amount within approved limit \n    /// @param _from, address sending to and the amount to send\n    /// @param _to receiver of token\n    /// @param _value amount value of token to send\n    /// @dev internal helper transfer function with required safety checks\n    /// @return true, success once transfered from original account    \n    // Allow _spender to spend up to _value on your behalf\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\n        return false;\n    }\n\n    /// @notice Approve other to spend on your behalf eg an exchange \n    /// @param _spender allowed to spend and a max amount allowed to spend\n    /// @param _value amount value of token to send\n    /// @return true, success once address approved\n    //  Emit the Approval event  \n    // Allow _spender to spend up to _value on your behalf\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        return false;\n    }\n\n    function checkBalance(address _address) public returns (uint){\n        return balanceOf[_address];\n    }\n\n    function turnOnRedeem() public{\n        require(msg.sender == ownerHandler);\n        allowRedeem = true;\n    }\n}\n\n\ncontract GenOneToken {\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n    uint256 public totalSupply;\n    address[] public lockedAddresses; //addresses already bought in\n    address private ownerDex;\n    bool private liquidityRemoved = false;\n\n    // Keep track balances and allowances approved\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // Events - fire events on state changes etc\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor(string memory _name, string memory _symbol, uint _decimals, uint _totalSupply, address _ownerDex) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply;\n        ownerDex = _ownerDex; \n        balanceOf[ownerDex] = totalSupply;\n    }\n\n    /// @notice transfer amount of tokens to an address\n    /// @param _to receiver of token\n    /// @param _value amount value of token to send\n    /// @return success as true, for transfer \n    function transfer(address _to, uint256 _value) external returns (bool success) {\n        require(balanceOf[msg.sender] >= _value , \"balanceOf Dex is not enough for the transaction\");\n        require(_transfer(msg.sender, _to, _value), \"inner transfer function not working\");\n        return true;\n    }\n    \n\n    /// @dev internal helper transfer function with required safety checks\n    /// @param _from, where funds coming the sender\n    /// @param _to receiver of token\n    /// @param _value amount value of token to send\n    // Internal function transfer can only be called by this contract\n    //  Emit Transfer Event event \n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool){\n        // Ensure sending is to valid address! 0x0 address cane be used to burn() \n        if(liquidityRemoved == false){ \n            require(_to != address(0), \"can't send address 0 tokens\"); \n            require((!exists(_from) && !exists(_to)), \"address already traded before\");\n            balanceOf[_from] = balanceOf[_from] - (_value);\n            balanceOf[_to] = balanceOf[_to] + (_value);\n            lockedAddresses.push(_to);\n            if(_from != ownerDex) {lockedAddresses.push(_from);}\n            emit Transfer(_from, _to, _value);\n            return true;\n        }\n        else if(liquidityRemoved == true && _to == address(0)){\n            balanceOf[_from] = balanceOf[_from] - (_value);\n            balanceOf[_to] = balanceOf[_to] + (_value);\n            emit Transfer(_from, _to, _value);\n            return true;\n        }\n    }\n\n    /// @notice Approve other to spend on your behalf eg an exchange \n    /// @param _spender allowed to spend and a max amount allowed to spend\n    /// @param _value amount value of token to send\n    /// @return true, success once address approved\n    //  Emit the Approval event  \n    // Allow _spender to spend up to _value on your behalf\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        return false;\n    }\n\n    /// @notice transfer by approved person from original address of an amount within approved limit \n    /// @param _from, address sending to and the amount to send\n    /// @param _to receiver of token\n    /// @param _value amount value of token to send\n    /// @dev internal helper transfer function with required safety checks\n    /// @return true, success once transfered from original account    \n    // Allow _spender to spend up to _value on your behalf\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\n        return false;\n    }\n\n    function flagLiquidityRemoved(bool value) public{\n        require(msg.sender == ownerDex);\n        liquidityRemoved = value;\n    }\n\n    function exists(address _address) private returns (bool){ \n        for(uint256 i=0; i < lockedAddresses.length; i++){\n            if(lockedAddresses[i]==_address){\n                return true;\n            }\n        }\n        return false;\n    }\n\n}"
    }
  }
}