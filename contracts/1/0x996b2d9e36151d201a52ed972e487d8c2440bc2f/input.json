{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/WhitelistedAggregatorProxy.sol":{"content":"pragma solidity 0.6.2;\ncontract Owned {\n\n  address payable public owner;\n  address private pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address _to)\n    external\n    onlyOwner()\n  {\n    pendingOwner = _to;\n\n    emit OwnershipTransferRequested(owner, _to);\n  }\n\n  /**\n   * @dev Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n  {\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = owner;\n    owner = msg.sender;\n    pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @dev Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only callable by owner\");\n    _;\n  }\n\n}\ncontract Whitelisted is Owned {\n\n  bool public whitelistEnabled;\n  mapping(address => bool) public whitelisted;\n\n  event AddedToWhitelist(address user);\n  event RemovedFromWhitelist(address user);\n  event WhitelistEnabled();\n  event WhitelistDisabled();\n\n  constructor()\n    public\n  {\n    whitelistEnabled = true;\n  }\n\n  /**\n   * @notice Adds an address to the whitelist\n   * @param _user The address to whitelist\n   */\n  function addToWhitelist(address _user) external onlyOwner() {\n    whitelisted[_user] = true;\n    emit AddedToWhitelist(_user);\n  }\n\n  /**\n   * @notice Removes an address from the whitelist\n   * @param _user The address to remove\n   */\n  function removeFromWhitelist(address _user) external onlyOwner() {\n    delete whitelisted[_user];\n    emit RemovedFromWhitelist(_user);\n  }\n\n  /**\n   * @notice makes the whitelist check enforced\n   */\n  function enableWhitelist()\n    external\n    onlyOwner()\n  {\n    whitelistEnabled = true;\n\n    emit WhitelistEnabled();\n  }\n\n  /**\n   * @notice makes the whitelist check unenforced\n   */\n  function disableWhitelist()\n    external\n    onlyOwner()\n  {\n    whitelistEnabled = false;\n\n    emit WhitelistDisabled();\n  }\n\n  /**\n   * @dev reverts if the caller is not whitelisted\n   */\n  modifier isWhitelisted() {\n    require(whitelisted[msg.sender] || !whitelistEnabled, \"Not whitelisted\");\n    _;\n  }\n}\ninterface HistoricAggregatorInterface {\n  function latestAnswer() external returns (int256);\n  function latestTimestamp() external returns (uint256);\n  function latestRound() external returns (uint256);\n  function getAnswer(uint256 roundId) external returns (int256);\n  function getTimestamp(uint256 roundId) external returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\ninterface AggregatorInterface is HistoricAggregatorInterface {\n  function decimals() external returns (uint8);\n  function getRoundData(uint256 _roundId)\n    external\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    );\n  function latestRoundData()\n    external\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    );\n}\ncontract AggregatorProxy is AggregatorInterface, Owned {\n\n  AggregatorInterface public aggregator;\n\n  constructor(address _aggregator) public Owned() {\n    setAggregator(_aggregator);\n  }\n\n  /**\n   * @notice Reads the current answer from aggregator delegated to.\n   */\n  function latestAnswer()\n    external\n    virtual\n    override\n    returns (int256)\n  {\n    return _latestAnswer();\n  }\n\n  /**\n   * @notice Reads the last updated height from aggregator delegated to.\n   */\n  function latestTimestamp()\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _latestTimestamp();\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param _roundId the answer number to retrieve the answer for\n   */\n  function getAnswer(uint256 _roundId)\n    external\n    virtual\n    override\n    returns (int256)\n  {\n    return _getAnswer(_roundId);\n  }\n\n  /**\n   * @notice get block timestamp when an answer was last updated\n   * @param _roundId the answer number to retrieve the updated timestamp for\n   */\n  function getTimestamp(uint256 _roundId)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _getTimestamp(_roundId);\n  }\n\n  /**\n   * @notice get the latest completed round where the answer was updated\n   */\n  function latestRound()\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _latestRound();\n  }\n\n  /**\n   * @notice get data about a round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorInterface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @param _roundId the round ID to retrieve the round data for\n   * @return roundId is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorInterface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorInterface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function getRoundData(uint256 _roundId)\n    external\n    virtual\n    override\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    return _getRoundData(_roundId);\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorInterface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @return roundId is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorInterface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorInterface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    external\n    virtual\n    override\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    return _latestRoundData();\n  }\n\n  /**\n   * @notice represents the number of decimals the aggregator responses represent.\n   */\n  function decimals()\n    external\n    override\n    returns (uint8)\n  {\n    return aggregator.decimals();\n  }\n\n  /**\n   * @notice Allows the owner to update the aggregator address.\n   * @param _aggregator The new address for the aggregator contract\n   */\n  function setAggregator(address _aggregator)\n    public\n    onlyOwner()\n  {\n    aggregator = AggregatorInterface(_aggregator);\n  }\n\n  /*\n   * Internal\n   */\n\n  function _latestAnswer()\n    internal\n    returns (int256)\n  {\n    return aggregator.latestAnswer();\n  }\n\n  function _latestTimestamp()\n    internal\n    returns (uint256)\n  {\n    return aggregator.latestTimestamp();\n  }\n\n  function _getAnswer(uint256 _roundId)\n    internal\n    returns (int256)\n  {\n    return aggregator.getAnswer(_roundId);\n  }\n\n  function _getTimestamp(uint256 _roundId)\n    internal\n    returns (uint256)\n  {\n    return aggregator.getTimestamp(_roundId);\n  }\n\n  function _latestRound()\n    internal\n    returns (uint256)\n  {\n    return aggregator.latestRound();\n  }\n\n  function _getRoundData(uint256 _roundId)\n    internal\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    return aggregator.getRoundData(_roundId);\n  }\n\n  function _latestRoundData()\n    internal\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    return aggregator.latestRoundData();\n  }\n}\ncontract WhitelistedAggregatorProxy is AggregatorProxy, Whitelisted {\n\n  constructor(address _aggregator) public AggregatorProxy(_aggregator) {\n  }\n\n  /**\n   * @notice Reads the current answer from aggregator delegated to.\n   * @dev overridden function to add the isWhitelisted() modifier\n   */\n  function latestAnswer()\n    external\n    override\n    isWhitelisted()\n    returns (int256)\n  {\n    return _latestAnswer();\n  }\n\n  /**\n   * @notice Reads the last updated height from aggregator delegated to.\n   * @dev overridden function to add the isWhitelisted() modifier\n   */\n  function latestTimestamp()\n    external\n    override\n    isWhitelisted()\n    returns (uint256)\n  {\n    return _latestTimestamp();\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param _roundId the answer number to retrieve the answer for\n   * @dev overridden function to add the isWhitelisted() modifier\n   */\n  function getAnswer(uint256 _roundId)\n    external\n    override\n    isWhitelisted()\n    returns (int256)\n  {\n    return _getAnswer(_roundId);\n  }\n\n  /**\n   * @notice get block timestamp when an answer was last updated\n   * @param _roundId the answer number to retrieve the updated timestamp for\n   * @dev overridden function to add the isWhitelisted() modifier\n   */\n  function getTimestamp(uint256 _roundId)\n    external\n    override\n    isWhitelisted()\n    returns (uint256)\n  {\n    return _getTimestamp(_roundId);\n  }\n\n  /**\n   * @notice get the latest completed round where the answer was updated\n   * @dev overridden function to add the isWhitelisted() modifier\n   */\n  function latestRound()\n    external\n    override\n    isWhitelisted()\n    returns (uint256)\n  {\n    return _latestRound();\n  }\n\n  /**\n   * @notice get data about a round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorInterface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @param _roundId the round ID to retrieve the round data for\n   * @return roundId is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorInterface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorInterface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function getRoundData(uint256 _roundId)\n    external\n    isWhitelisted()\n    override\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    return _getRoundData(_roundId);\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorInterface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @return roundId is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorInterface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorInterface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    external\n    isWhitelisted()\n    override\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    return _latestRoundData();\n  }\n\n}"}}}