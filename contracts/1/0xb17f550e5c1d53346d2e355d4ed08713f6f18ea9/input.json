{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BundleExecutor.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\tfunction name() external view returns (string memory);\n\n\tfunction symbol() external view returns (string memory);\n\n\tfunction decimals() external view returns (uint8);\n\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction balanceOf(address owner) external view returns (uint256);\n\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\n\tfunction approve(address spender, uint256 value) external returns (bool);\n\n\tfunction transfer(address to, uint256 value) external returns (bool);\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) external returns (bool);\n}\n\ninterface IWETH is IERC20 {\n\tfunction deposit() external payable;\n\n\tfunction withdraw(uint256) external;\n}\n\n// This contract simply calls multiple targets sequentially, ensuring WETH balance before and after\n\ncontract FlashBotsMultiCall {\n\taddress private immutable owner;\n\taddress private immutable executor;\n\tIWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n\tmodifier onlyExecutor() {\n\t\trequire(msg.sender == executor);\n\t\t_;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\tconstructor(address _executor) public payable {\n\t\towner = msg.sender;\n\t\texecutor = _executor;\n\t\tif (msg.value > 0) {\n\t\t\tWETH.deposit{value: msg.value}();\n\t\t}\n\t}\n\n\treceive() external payable {}\n\n\tfunction uniswapWeth(\n\t\tuint256 _wethAmountToFirstMarket,\n\t\tuint256 _ethAmountToCoinbase,\n\t\taddress[] memory _targets,\n\t\tbytes[] memory _payloads\n\t) external payable onlyExecutor {\n\t\trequire(_targets.length == _payloads.length);\n\t\tuint256 _wethBalanceBefore = WETH.balanceOf(address(this));\n\t\tWETH.transfer(_targets[0], _wethAmountToFirstMarket);\n\t\tfor (uint256 i = 0; i < _targets.length; i++) {\n\t\t\t(bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\n\t\t\trequire(_success);\n\t\t\t_response;\n\t\t}\n\n\t\tuint256 _wethBalanceAfter = WETH.balanceOf(address(this));\n\t\trequire(_wethBalanceAfter > _wethBalanceBefore + _ethAmountToCoinbase);\n\t\tif (_ethAmountToCoinbase == 0) return;\n\n\t\tuint256 _ethBalance = address(this).balance;\n\t\tif (_ethBalance < _ethAmountToCoinbase) {\n\t\t\tWETH.withdraw(_ethAmountToCoinbase - _ethBalance);\n\t\t}\n\t\tblock.coinbase.transfer(_ethAmountToCoinbase);\n\t}\n\n\tfunction call(\n\t\taddress payable _to,\n\t\tuint256 _value,\n\t\tbytes calldata _data\n\t) external payable onlyOwner returns (bytes memory) {\n\t\trequire(_to != address(0));\n\t\t(bool _success, bytes memory _result) = _to.call{value: _value}(_data);\n\t\trequire(_success);\n\t\treturn _result;\n\t}\n}\n"}}}