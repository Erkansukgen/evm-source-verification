{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/DefiTerminal2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.7.0;\npragma experimental ABIEncoderV2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IDMMExchangeRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] calldata poolsPath,\n        IERC20[] calldata path\n    ) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] calldata poolsPath,\n        IERC20[] calldata path\n    ) external view returns (uint256[] memory amounts);\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint) external;\n}\n\ninterface ISwapRouter  {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n\ncontract Ownable {\n  address public owner;\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\ncontract Protocols is Ownable {\n   \n   mapping(string => address) public _router;\n   \n   event AddProtocol(string indexed protocolId, address router);\n   event RemoveProtocol(string indexed protocolId);\n   \n   function addProtocol(string memory protocolId, address router) onlyOwner public returns (bool){\n       require(router != address(0));\n      _router[protocolId] = router;\n       emit AddProtocol(protocolId, router);\n       return true;\n   }\n   \n   function deleteProtocol(string memory protocolId) onlyOwner public returns(bool){\n       require(_router[protocolId] != address(0));\n       delete _router[protocolId];\n       emit RemoveProtocol(protocolId);\n       return true;\n   }\n}\n\ncontract FireSalamander2 is Protocols{\n     \n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // Wrapped Ether Contract\n    address public LCX = 0x037A54AaB062628C9Bbae1FDB1583c195585fe41;  // LCX Token Smart Contract\n\n    event SwapFS(address indexed tokenIn, address indexed tokenOut, uint amountIn, uint amountOut);\n    \n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    function unwrapWETH(uint256 amountMinimum, address recipient) internal  {\n        uint256 balanceWETH = IWETH(WETH).balanceOf(address(this));\n        require(balanceWETH >= amountMinimum, 'Insufficient WETH');\n\n        if (balanceWETH > 0) {\n            IWETH(WETH).withdraw(balanceWETH);\n            TransferHelper.safeTransferETH(recipient, balanceWETH);\n        }\n    }\n   \n    function swapUni(string memory protocolId, address[] calldata path, uint amountIn, uint amountOutMin, address recipient, uint deadline) public payable returns (bool) {\n        require(_router[protocolId] != address(0));\n        address router = _router[protocolId];\n        uint[] memory amountOut;\n        if(path[0] == WETH){\n         amountOut = IUniswapV2Router02(router).swapExactETHForTokens{value: amountIn}(amountOutMin, path, recipient, deadline);\n        }else if(path[path.length -1] == WETH){\n         IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n         IERC20(path[0]).approve(router, amountIn);\n         amountOut = IUniswapV2Router02(router).swapExactTokensForETH(amountIn, amountOutMin, path, recipient, deadline);\n        }else{\n         IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n         IERC20(path[0]).approve(router, amountIn);\n         amountOut = IUniswapV2Router02(router).swapExactTokensForTokens(amountIn, amountOutMin, path, recipient, deadline);\n        }\n        emit SwapFS(path[0], path[path.length -1], amountIn, amountOut[amountOut.length -1]);\n        return true;\n    }\n    \n    function swapKyberDmm(string memory protocolId, address[] calldata pools, IERC20[] calldata path, uint amountIn, uint amountOutMin, address recipient, uint deadline) public payable returns (bool) {\n        require(_router[protocolId] != address(0));\n        address router = _router[protocolId];\n        uint[] memory amountOut;\n        if(address(path[0]) == WETH){\n          amountOut = IDMMExchangeRouter(router).swapExactETHForTokens{value: amountIn}(amountOutMin, pools, path, recipient, deadline);\n        }else if(address(path[path.length -1]) == WETH){\n         IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n         IERC20(path[0]).approve(router, amountIn);\n         amountOut = IDMMExchangeRouter(router).swapExactTokensForETH(amountIn, amountOutMin, pools, path, recipient, deadline);\n        }else{\n         IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n         IERC20(path[0]).approve(router, amountIn);\n         amountOut = IDMMExchangeRouter(router).swapExactTokensForTokens(amountIn, amountOutMin, pools, path, recipient, deadline);\n        }\n        emit SwapFS(address(path[0]), address(path[path.length -1]), amountIn, amountOut[amountOut.length -1]);\n        return true;\n    }\n    \n    function swapUniV3Single(string memory protocolId, ISwapRouter.ExactInputSingleParams memory params) public payable returns (bool) {\n        require(_router[protocolId] != address(0));\n        address router = _router[protocolId];\n        address recipient;\n        uint amountOut;\n        if(params.tokenIn == WETH){\n           amountOut = ISwapRouter(router).exactInputSingle{value: params.amountIn }(params);\n        }else{\n            if(params.tokenOut == WETH){\n                recipient = params.recipient;\n                params.recipient = address(this);\n            }\n            IERC20(params.tokenIn).transferFrom(msg.sender, address(this), params.amountIn);\n            IERC20(params.tokenIn).approve(router, params.amountIn);\n            amountOut = ISwapRouter(router).exactInputSingle(params);\n            if(params.tokenOut == WETH){\n                unwrapWETH(amountOut, recipient);\n            }\n        }\n        emit SwapFS(params.tokenIn, params.tokenOut, params.amountIn, amountOut);\n        return true;\n    }\n    \n    function swapUniV3(string memory protocolId, address tokenIn, address tokenOut, ISwapRouter.ExactInputParams memory params) public payable returns (bool) {\n        require(_router[protocolId] != address(0));\n        address router = _router[protocolId];\n        address recipient;\n        uint amountOut;\n        if(tokenIn == WETH){\n            amountOut = ISwapRouter(router).exactInput{value: params.amountIn }(params);\n        }else{\n          if(tokenOut == WETH){\n                recipient = params.recipient;\n                params.recipient = address(this);\n            }\n            IERC20(tokenIn).transferFrom(msg.sender, address(this), params.amountIn);\n            IERC20(tokenIn).approve(router, params.amountIn);\n            amountOut = ISwapRouter(router).exactInput(params);\n            if(tokenOut == WETH){\n                unwrapWETH(amountOut, recipient);\n            }\n        }\n        emit SwapFS(tokenIn, tokenOut, params.amountIn, amountOut);\n        return true;\n    }\n}\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    }
  }
}