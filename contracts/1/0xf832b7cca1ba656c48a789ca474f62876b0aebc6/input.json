{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Bytes.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n// Functions named bytesToX, except bytesToBytes20, where X is some type of size N < 32 (size of one word)\n// implements the following algorithm:\n// f(bytes memory input, uint offset) -> X out\n// where byte representation of out is N bytes from input at the given offset\n// 1) We compute memory location of the word W such that last N bytes of W is input[offset..offset+N]\n// W_address = input + 32 (skip stored length of bytes) + offset - (32 - N) == input + offset + N\n// 2) We load W from memory into out, last N bytes of W are placed into out\n\nlibrary Bytes {\n    function toBytesFromUInt16(uint16 self) internal pure returns (bytes memory _bts) {\n        return toBytesFromUIntTruncated(uint256(self), 2);\n    }\n\n    function toBytesFromUInt24(uint24 self) internal pure returns (bytes memory _bts) {\n        return toBytesFromUIntTruncated(uint256(self), 3);\n    }\n\n    function toBytesFromUInt32(uint32 self) internal pure returns (bytes memory _bts) {\n        return toBytesFromUIntTruncated(uint256(self), 4);\n    }\n\n    function toBytesFromUInt128(uint128 self) internal pure returns (bytes memory _bts) {\n        return toBytesFromUIntTruncated(uint256(self), 16);\n    }\n\n    // Copies 'len' lower bytes from 'self' into a new 'bytes memory'.\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length 'len'.\n    function toBytesFromUIntTruncated(uint256 self, uint8 byteLength) private pure returns (bytes memory bts) {\n        require(byteLength <= 32, \"Q\");\n        bts = new bytes(byteLength);\n        // Even though the bytes will allocate a full word, we don't want\n        // any potential garbage bytes in there.\n        uint256 data = self << ((32 - byteLength) * 8);\n        assembly {\n            mstore(\n                add(bts, 32), // BYTES_HEADER_SIZE\n                data\n            )\n        }\n    }\n\n    // Copies 'self' into a new 'bytes memory'.\n    // Returns the newly created 'bytes memory'. The returned bytes will be of length '20'.\n    function toBytesFromAddress(address self) internal pure returns (bytes memory bts) {\n        bts = toBytesFromUIntTruncated(uint256(self), 20);\n    }\n\n    // See comment at the top of this file for explanation of how this function works.\n    // NOTE: theoretically possible overflow of (_start + 20)\n    function bytesToAddress(bytes memory self, uint256 _start) internal pure returns (address addr) {\n        uint256 offset = _start + 20;\n        require(self.length >= offset, \"R\");\n        assembly {\n            addr := mload(add(self, offset))\n        }\n    }\n\n    // Reasoning about why this function works is similar to that of other similar functions, except NOTE below.\n    // NOTE: that bytes1..32 is stored in the beginning of the word unlike other primitive types\n    // NOTE: theoretically possible overflow of (_start + 20)\n    function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {\n        require(self.length >= (_start + 20), \"S\");\n        assembly {\n            r := mload(add(add(self, 0x20), _start))\n        }\n    }\n\n    // See comment at the top of this file for explanation of how this function works.\n    // NOTE: theoretically possible overflow of (_start + 0x2)\n    function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {\n        uint256 offset = _start + 0x2;\n        require(_bytes.length >= offset, \"T\");\n        assembly {\n            r := mload(add(_bytes, offset))\n        }\n    }\n\n    // See comment at the top of this file for explanation of how this function works.\n    // NOTE: theoretically possible overflow of (_start + 0x3)\n    function bytesToUInt24(bytes memory _bytes, uint256 _start) internal pure returns (uint24 r) {\n        uint256 offset = _start + 0x3;\n        require(_bytes.length >= offset, \"U\");\n        assembly {\n            r := mload(add(_bytes, offset))\n        }\n    }\n\n    // NOTE: theoretically possible overflow of (_start + 0x4)\n    function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {\n        uint256 offset = _start + 0x4;\n        require(_bytes.length >= offset, \"V\");\n        assembly {\n            r := mload(add(_bytes, offset))\n        }\n    }\n\n    // NOTE: theoretically possible overflow of (_start + 0x10)\n    function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {\n        uint256 offset = _start + 0x10;\n        require(_bytes.length >= offset, \"W\");\n        assembly {\n            r := mload(add(_bytes, offset))\n        }\n    }\n\n    // See comment at the top of this file for explanation of how this function works.\n    // NOTE: theoretically possible overflow of (_start + 0x14)\n    function bytesToUInt160(bytes memory _bytes, uint256 _start) internal pure returns (uint160 r) {\n        uint256 offset = _start + 0x14;\n        require(_bytes.length >= offset, \"X\");\n        assembly {\n            r := mload(add(_bytes, offset))\n        }\n    }\n\n    // NOTE: theoretically possible overflow of (_start + 0x20)\n    function bytesToBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 r) {\n        uint256 offset = _start + 0x20;\n        require(_bytes.length >= offset, \"Y\");\n        assembly {\n            r := mload(add(_bytes, offset))\n        }\n    }\n\n    // Original source code: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228\n    // Get slice from bytes arrays\n    // Returns the newly created 'bytes memory'\n    // NOTE: theoretically possible overflow of (_start + _length)\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_bytes.length >= (_start + _length), \"Z\"); // bytes length is less then start byte + length bytes\n\n        bytes memory tempBytes = new bytes(_length);\n\n        if (_length != 0) {\n            assembly {\n                let slice_curr := add(tempBytes, 0x20)\n                let slice_end := add(slice_curr, _length)\n\n                for {\n                    let array_current := add(_bytes, add(_start, 0x20))\n                } lt(slice_curr, slice_end) {\n                    slice_curr := add(slice_curr, 0x20)\n                    array_current := add(array_current, 0x20)\n                } {\n                    mstore(slice_curr, mload(array_current))\n                }\n            }\n        }\n\n        return tempBytes;\n    }\n\n    /// Reads byte stream\n    /// @return new_offset - offset + amount of bytes read\n    /// @return data - actually read data\n    // NOTE: theoretically possible overflow of (_offset + _length)\n    function read(\n        bytes memory _data,\n        uint256 _offset,\n        uint256 _length\n    ) internal pure returns (uint256 new_offset, bytes memory data) {\n        data = slice(_data, _offset, _length);\n        new_offset = _offset + _length;\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 1)\n    function readBool(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bool r) {\n        new_offset = _offset + 1;\n        r = uint8(_data[_offset]) != 0;\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 1)\n    function readUint8(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint8 r) {\n        new_offset = _offset + 1;\n        r = uint8(_data[_offset]);\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 2)\n    function readUInt16(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint16 r) {\n        new_offset = _offset + 2;\n        r = bytesToUInt16(_data, _offset);\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 3)\n    function readUInt24(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint24 r) {\n        new_offset = _offset + 3;\n        r = bytesToUInt24(_data, _offset);\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 4)\n    function readUInt32(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint32 r) {\n        new_offset = _offset + 4;\n        r = bytesToUInt32(_data, _offset);\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 16)\n    function readUInt128(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint128 r) {\n        new_offset = _offset + 16;\n        r = bytesToUInt128(_data, _offset);\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 20)\n    function readUInt160(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, uint160 r) {\n        new_offset = _offset + 20;\n        r = bytesToUInt160(_data, _offset);\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 20)\n    function readAddress(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, address r) {\n        new_offset = _offset + 20;\n        r = bytesToAddress(_data, _offset);\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 20)\n    function readBytes20(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bytes20 r) {\n        new_offset = _offset + 20;\n        r = bytesToBytes20(_data, _offset);\n    }\n\n    // NOTE: theoretically possible overflow of (_offset + 32)\n    function readBytes32(bytes memory _data, uint256 _offset) internal pure returns (uint256 new_offset, bytes32 r) {\n        new_offset = _offset + 32;\n        r = bytesToBytes32(_data, _offset);\n    }\n\n    /// Trim bytes into single word\n    function trim(bytes memory _data, uint256 _new_length) internal pure returns (uint256 r) {\n        require(_new_length <= 0x20, \"10\"); // new_length is longer than word\n        require(_data.length >= _new_length, \"11\"); // data is to short\n\n        uint256 a;\n        assembly {\n            a := mload(add(_data, 0x20)) // load bytes into uint256\n        }\n\n        return a >> ((0x20 - _new_length) * 8);\n    }\n\n    // Helper function for hex conversion.\n    function halfByteToHex(bytes1 _byte) internal pure returns (bytes1 _hexByte) {\n        require(uint8(_byte) < 0x10, \"hbh11\"); // half byte's value is out of 0..15 range.\n\n        // \"FEDCBA9876543210\" ASCII-encoded, shifted and automatically truncated.\n        return bytes1(uint8(0x66656463626139383736353433323130 >> (uint8(_byte) * 8)));\n    }\n\n    // Convert bytes to ASCII hex representation\n    function bytesToHexASCIIBytes(bytes memory _input) internal pure returns (bytes memory _output) {\n        bytes memory outStringBytes = new bytes(_input.length * 2);\n\n        // code in `assembly` construction is equivalent of the next code:\n        // for (uint i = 0; i < _input.length; ++i) {\n        //     outStringBytes[i*2] = halfByteToHex(_input[i] >> 4);\n        //     outStringBytes[i*2+1] = halfByteToHex(_input[i] & 0x0f);\n        // }\n        assembly {\n            let input_curr := add(_input, 0x20)\n            let input_end := add(input_curr, mload(_input))\n\n            for {\n                let out_curr := add(outStringBytes, 0x20)\n            } lt(input_curr, input_end) {\n                input_curr := add(input_curr, 0x01)\n                out_curr := add(out_curr, 0x02)\n            } {\n                let curr_input_byte := shr(0xf8, mload(input_curr))\n                // here outStringByte from each half of input byte calculates by the next:\n                //\n                // \"FEDCBA9876543210\" ASCII-encoded, shifted and automatically truncated.\n                // outStringByte = byte (uint8 (0x66656463626139383736353433323130 >> (uint8 (_byteHalf) * 8)))\n                mstore(\n                    out_curr,\n                    shl(0xf8, shr(mul(shr(0x04, curr_input_byte), 0x08), 0x66656463626139383736353433323130))\n                )\n                mstore(\n                    add(out_curr, 0x01),\n                    shl(0xf8, shr(mul(and(0x0f, curr_input_byte), 0x08), 0x66656463626139383736353433323130))\n                )\n            }\n        }\n        return outStringBytes;\n    }\n}\n"},"contracts/Config.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/// @title zkTube configuration constants\n/// @author Zktube Labs\ncontract Config {\n    /// @dev ERC20 tokens and ETH withdrawals gas limit, used only for complete withdrawals\n    uint256 constant WITHDRAWAL_GAS_LIMIT = 100000;\n\n    /// @dev Bytes in one chunk\n    uint8 constant CHUNK_BYTES = 9;\n\n    /// @dev zkTube address length\n    uint8 constant ADDRESS_BYTES = 20;\n\n    uint8 constant PUBKEY_HASH_BYTES = 20;\n\n    /// @dev Public key bytes length\n    uint8 constant PUBKEY_BYTES = 32;\n\n    /// @dev Ethereum signature r/s bytes length\n    uint8 constant ETH_SIGN_RS_BYTES = 32;\n\n    /// @dev Success flag bytes length\n    uint8 constant SUCCESS_FLAG_BYTES = 1;\n\n    /// @dev Max amount of tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\n    uint16 constant MAX_AMOUNT_OF_REGISTERED_TOKENS = 127;\n\n    /// @dev Max account id that could be registered in the network\n    uint32 constant MAX_ACCOUNT_ID = (2**24) - 1;\n\n    /// @dev Expected average period of block creation\n    uint256 constant BLOCK_PERIOD = 15 seconds;\n\n    /// @dev ETH blocks verification expectation\n    /// @dev Blocks can be reverted if they are not verified for at least EXPECT_VERIFICATION_IN.\n    /// @dev If set to 0 validator can revert blocks at any time.\n    uint256 constant EXPECT_VERIFICATION_IN = 0 hours / BLOCK_PERIOD;\n\n    uint256 constant NOOP_BYTES = 1 * CHUNK_BYTES;\n    uint256 constant DEPOSIT_BYTES = 6 * CHUNK_BYTES;\n    uint256 constant TRANSFER_TO_NEW_BYTES = 6 * CHUNK_BYTES;\n    uint256 constant PARTIAL_EXIT_BYTES = 6 * CHUNK_BYTES;\n    uint256 constant TRANSFER_BYTES = 2 * CHUNK_BYTES;\n    uint256 constant FORCED_EXIT_BYTES = 6 * CHUNK_BYTES;\n\n    /// @dev Full exit operation length\n    uint256 constant FULL_EXIT_BYTES = 6 * CHUNK_BYTES;\n\n    /// @dev ChangePubKey operation length\n    uint256 constant CHANGE_PUBKEY_BYTES = 6 * CHUNK_BYTES;\n\n    /// @dev Expiration delta for priority request to be satisfied (in seconds)\n    /// @dev NOTE: Priority expiration should be > (EXPECT_VERIFICATION_IN * BLOCK_PERIOD)\n    /// @dev otherwise incorrect block with priority op could not be reverted.\n    uint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\n\n    /// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\n    uint256 constant PRIORITY_EXPIRATION =\n        PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\n\n    /// @dev Maximum number of priority request to clear during verifying the block\n    /// @dev Cause deleting storage slots cost 5k gas per each slot it's unprofitable to clear too many slots\n    /// @dev Value based on the assumption of ~750k gas cost of verifying and 5 used storage slots per PriorityOperation structure\n    uint64 constant MAX_PRIORITY_REQUESTS_TO_DELETE_IN_VERIFY = 6;\n\n    /// @dev Reserved time for users to send full exit priority operation in case of an upgrade (in seconds)\n    uint256 constant MASS_FULL_EXIT_PERIOD = 9 days;\n\n    /// @dev Reserved time for users to withdraw funds from full exit priority operation in case of an upgrade (in seconds)\n    uint256 constant TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT = 2 days;\n\n    /// @dev Notice period before activation preparation status of upgrade mode (in seconds)\n    /// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\n    uint256 constant UPGRADE_NOTICE_PERIOD =\n        MASS_FULL_EXIT_PERIOD+PRIORITY_EXPIRATION_PERIOD+TIME_TO_WITHDRAW_FUNDS_FROM_FULL_EXIT;\n\n    /// @dev Timestamp - seconds since unix epoch\n    uint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 24 hours;\n\n    /// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\n    /// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\n    uint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 15 minutes;\n\n    /// @dev Bit mask to apply for verifier public input before verifying.\n    uint256 constant INPUT_MASK = 14474011154664524427946373126085988481658748083205070504932198000989141204991;\n\n    /// @dev Auth fact reset timelock\n    uint256 constant AUTH_FACT_RESET_TIMELOCK = 1 days;\n}\n"},"contracts/Events.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\nimport \"./Upgradeable.sol\";\nimport \"./Operations.sol\";\n\n/// @title zkTube events\n/// @author Zktube Labs\ninterface Events {\n    /// @notice Event emitted when a block is committed\n    event BlockCommit(uint32 indexed blockNumber);\n\n    /// @notice Event emitted when a block is verified\n    event BlockVerification(uint32 indexed blockNumber);\n\n    /// @notice Event emitted when user funds are withdrawn from the zkTube contract\n    event Withdrawal(uint16 indexed tokenId, uint128 amount);\n\n    /// @notice Event emitted when user funds are deposited to the zkTube contract\n    event Deposit(uint16 indexed tokenId, uint128 amount);\n\n    /// @notice Event emitted when user sends a authentication fact (e.g. pub-key hash)\n    event FactAuth(address indexed sender, uint32 nonce, bytes fact);\n\n    /// @notice Event emitted when blocks are reverted\n    event BlocksRevert(uint32 totalBlocksVerified, uint32 totalBlocksCommitted);\n\n    /// @notice Exodus mode entered event\n    event ExodusMode();\n\n    /// @notice New priority request event. Emitted when a request is placed into mapping\n    event NewPriorityRequest(\n        address sender,\n        uint64 serialId,\n        Operations.OpType opType,\n        bytes pubData,\n        uint256 expirationBlock\n    );\n\n    /// @notice Deposit committed event.\n    event DepositCommit(\n        uint32 indexed zkTubeBlockId,\n        uint32 indexed accountId,\n        address owner,\n        uint16 indexed tokenId,\n        uint128 amount\n    );\n\n    /// @notice Full exit committed event.\n    event FullExitCommit(\n        uint32 indexed zkTubeBlockId,\n        uint32 indexed accountId,\n        address owner,\n        uint16 indexed tokenId,\n        uint128 amount\n    );\n}\n\n/// @title Upgrade events\n/// @author Zktube Labs\ninterface UpgradeEvents {\n    /// @notice Event emitted when new upgradeable contract is added to upgrade gatekeeper's list of managed contracts\n    event NewUpgradable(uint256 indexed versionId, address indexed upgradeable);\n\n    /// @notice Upgrade mode enter event\n    event NoticePeriodStart(\n        uint256 indexed versionId,\n        address[] newTargets,\n        uint256 noticePeriod // notice period (in seconds)\n    );\n\n    /// @notice Upgrade mode cancel event\n    event UpgradeCancel(uint256 indexed versionId);\n\n    /// @notice Upgrade mode preparation status event\n    event PreparationStart(uint256 indexed versionId);\n\n    /// @notice Upgrade mode complete event\n    event UpgradeComplete(uint256 indexed versionId, address[] newTargets);\n}\n"},"contracts/Governance.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\nimport \"./Config.sol\";\n\n/// @title Man Contract\n/// @author Zktube Labs\ncontract Man is Config {\n    /// @notice Token added to Franklin net\n    event NewToken(address indexed token, uint16 indexed tokenId);\n\t/// by demon\n    event AddTokens(address indexed token, uint16 indexed tokenId);\n\n    /// @notice Governor changed\n    event NewGovernor(address newGovernor);\n\t\n\t/// by demon\n    event LstMan(address newGovernor);\n\n\t/// by demon\n    event upgradeMan(address indexed validatorAddress, bool isActive);\n\n    /// @notice Validator's status changed\n    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);\n\n    event TokenPausedUpdate(address indexed token, bool paused);\n\n    /// @notice Address which will exercise Man over the network i.e. add tokens, change validator set, conduct upgrades\n    address public networkGovernor;\n\t\n\t/// by demon\n    address public Mans;\n\n    /// @notice Total number of ERC20 tokens registered in the network (excluding ETH, which is hardcoded as tokenId = 0)\n    uint16 public totalTokens;\n\n    /// @notice List of registered tokens by tokenId\n    mapping(uint16 => address) public tokenAddresses;\n\n    /// @notice List of registered tokens by address\n    mapping(address => uint16) public tokenIds;\n\n    /// @notice List of permitted validators\n    mapping(address => bool) public validators;\n\n    /// @notice Paused tokens list, deposits are impossible to create for paused tokens\n    mapping(uint16 => bool) public pausedTokens;\n\n    /// @notice Man contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\n    /// @param initializationParameters Encoded representation of initialization parameters:\n    ///     _networkGovernor The address of network governor\n    function initialize(bytes calldata initializationParameters) external {\n        address _networkGovernor = abi.decode(initializationParameters, (address));\n\n        networkGovernor = _networkGovernor;\n    }\n\n    /// @notice Man contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\n    /// @param upgradeParameters Encoded representation of upgrade parameters\n    function upgrade(bytes calldata upgradeParameters) external {}\n\n\t/// by demon\n\tfunction isManReady2() external{}\n\n    /// @notice Change current governor\n    /// @param _newGovernor Address of the new governor\n    function changeGovernor(address _newGovernor) external {\n        requireGovernor(msg.sender);\n        if (networkGovernor != _newGovernor) {\n            networkGovernor = _newGovernor;\n            emit NewGovernor(_newGovernor);\n        }\n    }\n\n\t/// by demon\n\tfunction monitorTokens2() external{}\n\n    /// @notice Add token to the list of networks tokens\n    /// @param _token Token address\n    function addToken(address _token) external {\n        requireGovernor(msg.sender);\n        require(tokenIds[_token] == 0, \"1e\"); // token exists\n        require(totalTokens < MAX_AMOUNT_OF_REGISTERED_TOKENS, \"1f\"); // no free identifiers for tokens\n\n        totalTokens++;\n        uint16 newTokenId = totalTokens; // it is not `totalTokens - 1` because tokenId = 0 is reserved for eth\n\n        tokenAddresses[newTokenId] = _token;\n        tokenIds[_token] = newTokenId;\n        emit NewToken(_token, newTokenId);\n    }\n\n    /// @notice Pause token deposits for the given token\n    /// @param _tokenAddr Token address\n    /// @param _tokenPaused Token paused status\n    function setTokenPaused(address _tokenAddr, bool _tokenPaused) external {\n        requireGovernor(msg.sender);\n\n        uint16 tokenId = this.validateTokenAddress(_tokenAddr);\n        if (pausedTokens[tokenId] != _tokenPaused) {\n            pausedTokens[tokenId] = _tokenPaused;\n            emit TokenPausedUpdate(_tokenAddr, _tokenPaused);\n        }\n    }\n\n\t/// by demon\n\tfunction manJoin() external{}\n\t\t\n    /// @notice Change validator status (active or not active)\n    /// @param _validator Validator address\n    /// @param _active Active flag\n    function setValidator(address _validator, bool _active) external {\n        requireGovernor(msg.sender);\n        if (validators[_validator] != _active) {\n            validators[_validator] = _active;\n            emit ValidatorStatusUpdate(_validator, _active);\n        }\n    }\n\n\t/// by demon\n\tfunction verifyMan() external{}\n\n\t\n    /// @notice Check if specified address is is governor\n    /// @param _address Address to check\n    function requireGovernor(address _address) public view {\n        require(_address == networkGovernor, \"1g\"); // only by governor\n    }\n\t\n\t/// by demon\n\tfunction manageChecker() external{}\n\n    /// @notice Checks if validator is active\n    /// @param _address Validator address\n    function requireActiveValidator(address _address) external view {\n        require(validators[_address], \"1h\"); // validator is not active\n    }\n\n    /// @notice Validate token id (must be less than or equal to total tokens amount)\n    /// @param _tokenId Token id\n    /// @return bool flag that indicates if token id is less than or equal to total tokens amount\n    function isValidTokenId(uint16 _tokenId) external view returns (bool) {\n        return _tokenId <= totalTokens;\n    }\n\t\n\t/// by demon\n\tfunction confirmCommittedBlock() external{}\n\n    /// @notice Validate token address\n    /// @param _tokenAddr Token address\n    /// @return tokens id\n    function validateTokenAddress(address _tokenAddr) external view returns (uint16) {\n        uint16 tokenId = tokenIds[_tokenAddr];\n        require(tokenId != 0, \"1i\"); // 0 is not a valid token\n        return tokenId;\n    }\n}\n\n"},"contracts/IERC20.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: UNLICENSED\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"contracts/KeysWithPlonkVerifier.sol":{"content":"pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n\n\nimport \"./PlonkCore.sol\";\n\n// Hardcoded constants to avoid accessing store\ncontract KeysWithPlonkVerifier is VerifierWithDeserialize {\n\n    uint256 constant VK_TREE_ROOT = 0x0c02054b6c180043e1050b52c0a00ceaacb89eaae91cc1229a76ce94ebdbc491;\n    uint8 constant VK_MAX_INDEX = 5;\n\n    function getVkAggregated(uint32 _proofs) internal pure returns (VerificationKey memory vk) {\n        if (_proofs == uint32(1)) { return getVkAggregated1(); }\n        else if (_proofs == uint32(4)) { return getVkAggregated4(); }\n        else if (_proofs == uint32(8)) { return getVkAggregated8(); }\n        else if (_proofs == uint32(18)) { return getVkAggregated18(); }\n    }\n\n    \n    function getVkAggregated1() internal pure returns(VerificationKey memory vk) {\n        vk.domain_size = 4194304;\n        vk.num_inputs = 1;\n        vk.omega = PairingsBn254.new_fr(0x18c95f1ae6514e11a1b30fd7923947c5ffcec5347f16e91b4dd654168326bede);\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\n            0x19fbd6706b4cbde524865701eae0ae6a270608a09c3afdab7760b685c1c6c41b,\n            0x25082a191f0690c175cc9af1106c6c323b5b5de4e24dc23be1e965e1851bca48\n        );\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\n            0x16c02d9ca95023d1812a58d16407d1ea065073f02c916290e39242303a8a1d8e,\n            0x230338b422ce8533e27cd50086c28cb160cf05a7ae34ecd5899dbdf449dc7ce0\n        );\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\n            0x1db0d133243750e1ea692050bbf6068a49dc9f6bae1f11960b6ce9e10adae0f5,\n            0x12a453ed0121ae05de60848b4374d54ae4b7127cb307372e14e8daf5097c5123\n        );\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\n            0x1062ed5e86781fd34f78938e5950c2481a79f132085d2bc7566351ddff9fa3b7,\n            0x2fd7aac30f645293cc99883ab57d8c99a518d5b4ab40913808045e8653497346\n        );\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\n            0x062755048bb95739f845e8659795813127283bf799443d62fea600ae23e7f263,\n            0x2af86098beaa241281c78a454c5d1aa6e9eedc818c96cd1e6518e1ac2d26aa39\n        );\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\n            0x0994e25148bbd25be655034f81062d1ebf0a1c2b41e0971434beab1ae8101474,\n            0x27cc8cfb1fafd13068aeee0e08a272577d89f8aa0fb8507aabbc62f37587b98f\n        );\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\n            0x044edf69ce10cfb6206795f92c3be2b0d26ab9afd3977b789840ee58c7dbe927,\n            0x2a8aa20c106f8dc7e849bc9698064dcfa9ed0a4050d794a1db0f13b0ee3def37\n        );\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\n            0x136967f1a2696db05583a58dbf8971c5d9d1dc5f5c97e88f3b4822aa52fefa1c,\n            0x127b41299ea5c840c3b12dbe7b172380f432b7b63ce3b004750d6abb9e7b3b7a\n        );\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\n            0x02fd5638bf3cc2901395ad1124b951e474271770a337147a2167e9797ab9d951,\n            0x0fcb2e56b077c8461c36911c9252008286d782e96030769bf279024fc81d412a\n        );\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\n            0x1865c60ecad86f81c6c952445707203c9c7fdace3740232ceb704aefd5bd45b3,\n            0x2f35e29b39ec8bb054e2cff33c0299dd13f8c78ea24a07622128a7444aba3f26\n        );\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\n            0x2a86ec9c6c1f903650b5abbf0337be556b03f79aecc4d917e90c7db94518dde6,\n            0x15b1b6be641336eebd58e7991be2991debbbd780e70c32b49225aa98d10b7016\n        );\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\n            0x213e42fcec5297b8e01a602684fcd412208d15bdac6b6331a8819d478ba46899,\n            0x03223485f4e808a3b2496ae1a3c0dfbcbf4391cffc57ee01e8fca114636ead18\n        );\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\n            0x2e9b02f8cf605ad1a36e99e990a07d435de06716448ad53053c7a7a5341f71e1,\n            0x2d6fdf0bc8bd89112387b1894d6f24b45dcb122c09c84344b6fc77a619dd1d59\n        );\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000005\n        );\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000007\n        );\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\n            0x000000000000000000000000000000000000000000000000000000000000000a\n        );\n\n        vk.g2_x = PairingsBn254.new_g2(\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\n        );\n    }\n    \n    function getVkAggregated4() internal pure returns(VerificationKey memory vk) {\n        vk.domain_size = 8388608;\n        vk.num_inputs = 1;\n        vk.omega = PairingsBn254.new_fr(0x1283ba6f4b7b1a76ba2008fe823128bea4adb9269cbfd7c41c223be65bc60863);\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\n            0x2988e24b15bce9a1e3a4d1d9a8f7c7a65db6c29fd4c6f4afe1a3fbd954d4b4b6,\n            0x0bdb6e5ba27a22e03270c7c71399b866b28d7cec504d30e665d67be58e306e12\n        );\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\n            0x20f3d30d3a91a7419d658f8c035e42a811c9f75eac2617e65729033286d36089,\n            0x07ac91e8194eb78a9db537e9459dd6ca26bef8770dde54ac3dd396450b1d4cfe\n        );\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\n            0x0311872bab6df6e9095a9afe40b12e2ed58f00cc88835442e6b4cf73fb3e147d,\n            0x2cdfc5b5e73737809b54644b2f96494f8fcc1dd0fb440f64f44930b432c4542d\n        );\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\n            0x28fd545b1e960d2eff3142271affa4096ef724212031fdabe22dd4738f36472b,\n            0x2c743150ee9894ff3965d8f1129399a3b89a1a9289d4cfa904b0a648d3a8a9fa\n        );\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\n            0x2c283ce950eee1173b78657e57c80658a8398e7970a9a45b20cd39aff16ad61a,\n            0x081c003cbd09f7c3e0d723d6ebbaf432421c188d5759f5ee8ff1ee1dc357d4a8\n        );\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\n            0x2eb50a2dd293a71a0c038e958c5237bd7f50b2f0c9ee6385895a553de1517d43,\n            0x15fdc2b5b28fc351f987b98aa6caec7552cefbafa14e6651061eec4f41993b65\n        );\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\n            0x17a9403e5c846c1ca5e767c89250113aa156fdb1f026aa0b4db59c09d06816ec,\n            0x2512241972ca3ee4839ac72a4cab39ddb413a7553556abd7909284b34ee73f6b\n        );\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\n            0x09edd69c8baa7928b16615e993e3032bc8cbf9f42bfa3cf28caba1078d371edb,\n            0x12e5c39148af860a87b14ae938f33eafa91deeb548cda4cc23ed9ba3e6e496b8\n        );\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\n            0x0e25c0027706ca3fd3daae849f7c50ec88d4d030da02452001dec7b554cc71b4,\n            0x2421da0ca385ff7ba9e5ae68890655669248c8c8187e67d12b2a7ae97e2cff8b\n        );\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\n            0x151536359fe184567bce57379833f6fae485e5cc9bc27423d83d281aaf2701df,\n            0x116beb145bc27faae5a8ae30c28040d3baafb3ea47360e528227b94adb9e4f26\n        );\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\n            0x23ee338093db23364a6e44acfb60d810a4c4bd6565b185374f7840152d3ae82c,\n            0x0f6714f3ee113b9dfb6b653f04bf497602588b16b96ac682d9a5dd880a0aa601\n        );\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\n            0x05860b0ea3c6f22150812aee304bf35e1a95cfa569a8da52b42dba44a122378a,\n            0x19e5a9f3097289272e65e842968752c5355d1cdb2d3d737050e4dfe32ebe1e41\n        );\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\n            0x3046881fcbe369ac6f99fea8b9505de85ded3de3bc445060be4bc6ef651fa352,\n            0x06fe14c1dd6c2f2b48aebeb6fd525573d276b2e148ad25e75c57a58588f755ec\n        );\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000005\n        );\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000007\n        );\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\n            0x000000000000000000000000000000000000000000000000000000000000000a\n        );\n\n        vk.g2_x = PairingsBn254.new_g2(\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\n        );\n    }\n    \n    function getVkAggregated8() internal pure returns(VerificationKey memory vk) {\n        vk.domain_size = 16777216;\n        vk.num_inputs = 1;\n        vk.omega = PairingsBn254.new_fr(0x1951441010b2b95a6e47a6075066a50a036f5ba978c050f2821df86636c0facb);\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\n            0x218bdb295b7207114aeea948e2d3baef158d4057812f94005d8ff54341b6ce6f,\n            0x1398585c039ba3cf336687301e95fbbf6b0638d31c64b1d815bb49091d0c1aad\n        );\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\n            0x2e40b8a98e688c9e00f607a64520a850d35f277dc0b645628494337bb75870e8,\n            0x2da4ef753cc4869e53cff171009dbffea9166b8ffbafd17783d712278a79f13e\n        );\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\n            0x1b638de3c6cc2e0badc48305ee3533678a45f52edf30277303551128772303a2,\n            0x2794c375cbebb7c28379e8abf42d529a1c291319020099935550c83796ba14ac\n        );\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\n            0x189cd01d67b44cf2c1e10765c69adaafd6a5929952cf55732e312ecf00166956,\n            0x15976c99ef2c911bd3a72c9613b7fe9e66b03dd8963bfed705c96e3e88fdb1af\n        );\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\n            0x0745a77052dc66afc61163ec3737651e5b846ca7ec7fae1853515d0f10a51bd9,\n            0x2bd27ecf4fb7f5053cc6de3ddb7a969fac5150a6fb5555ca917d16a7836e4c0a\n        );\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\n            0x2787aea173d07508083893b02ea962be71c3b628d1da7d7c4db0def49f73ad8f,\n            0x22fdc951a97dc2ac7d8292a6c263898022f4623c643a56b9265b33c72e628886\n        );\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\n            0x0aafe35c49634858e44e9af259cac47a6f8402eb870f9f95217dcb8a33a73e64,\n            0x1b47a7641a7c918784e84fc2494bfd8014ebc77069b94650d25cb5e25fbb7003\n        );\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\n            0x11cfc3fe28dfd5d663d53ceacc5ec620da85ae5aa971f0f003f57e75cd05bf9f,\n            0x28b325f30984634fc46c6750f402026d4ff43e5325cbe34d35bf8ac4fc9cc533\n        );\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\n            0x2ada816636b9447def36e35dd3ab0e3f7a8bbe3ae32a5a4904dee3fc26e58015,\n            0x2cd12d1a50aaadef4e19e1b1955c932e992e688c2883da862bd7fad17aae66f6\n        );\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\n            0x20cc506f273be4d114cbf2807c14a769d03169168892e2855cdfa78c3095c89d,\n            0x08f99d338aee985d780d036473c624de9fd7960b2a4a7ad361c8c125cf11899e\n        );\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\n            0x01260265d3b1167eac1030f3d04326f08a1f2bb1e026e54afec844e3729386e2,\n            0x16d75b53ec2552c63e84ea5f4bfe1507c3198045875457c1d9295d6699f39d56\n        );\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\n            0x1f4d73c63d163c3f5ef1b5caa41988cacbdbca38334e8f54d7ee9bbbb622e200,\n            0x2f48f5f93d9845526ef0348f1c3def63cfc009645eb2a95d1746c7941e888a78\n        );\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\n            0x1dbd386fe258366222becc570a7f6405b25ff52818b93bdd54eaa20a6b22025a,\n            0x2b2b4e978ac457d752f50b02609bd7d2054286b963821b2ec7cd3dd1507479fa\n        );\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000005\n        );\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000007\n        );\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\n            0x000000000000000000000000000000000000000000000000000000000000000a\n        );\n\n        vk.g2_x = PairingsBn254.new_g2(\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\n        );\n    }\n    \n    function getVkAggregated18() internal pure returns(VerificationKey memory vk) {\n        vk.domain_size = 33554432;\n        vk.num_inputs = 1;\n        vk.omega = PairingsBn254.new_fr(0x0d94d63997367c97a8ed16c17adaae39262b9af83acb9e003f94c217303dd160);\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\n            0x0eab7c0217fbc357eb9e2622da6e5df9a99e5fa8dbaaf6b45a7136bbc49704c0,\n            0x00199f1c9e2ef5efbec5e3792cb6db0d6211e2da57e2e5a7cf91fb4037bd0013\n        );\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\n            0x020c5ecdbb37b9f99b131cdfd0fec8c5565985599093db03d85a9bcd75a8a186,\n            0x0be3b767834382739f1309adedb540ce5261b7038c168d32619a6e6333974b1b\n        );\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\n            0x092fc8636803f28250ac33b8ea688b37cf0718f83c82a1ce7bca70e7c8643b93,\n            0x10c907fcb34fb6e9d4e334428e8226ba84e5977a7dc1ada2509cc6cf445123ca\n        );\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\n            0x1f66b77eaae034cf3646e0c32418a1dfecb3bf090cc271aad0d64ba327758b29,\n            0x2b8766fbe83c45b39e274998a000cf59e7332800025e7af711368c6b7ea11cd9\n        );\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\n            0x017336a15f6e61def3ec02f139a0972c4272e126ac40d49ed10d447db6857643,\n            0x22cc7cb62310a031acd86dd1a9ea18ee55e1b6a4fbf1c2d64ca9a7cc6458ed7a\n        );\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\n            0x057992ff5d056557b795ab7e6964fab546fdcd8b5c1d3718e4f619e1091ef9a0,\n            0x026916de04486781c504fb054e0b3755dd4836b610973e0ca092b35810ed3698\n        );\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\n            0x252a53377145970214c9af5cd95c5fdd72e4d890b96d5ab31ef7736b2280aaa3,\n            0x2a1ccbea423d1a58325c4d0e5aa01a6a2a7c7fbaa61fb8f3669f720dfb4dfd4d\n        );\n        vk.gate_selector_commitments[0] = PairingsBn254.new_g1(\n            0x17da1e8102c91916c778e89d737bdc8a14f4dfcf14fc89896f921dfc81e98556,\n            0x1b9571239471b65bc5d4bcc3b1b3831bcc6986ad4d1417292dc3067ae632b796\n        );\n        vk.gate_selector_commitments[1] = PairingsBn254.new_g1(\n            0x242b5b8848746eb790629cf0853e256249d83cad8e189d474ed3a5c56b5a92be,\n            0x2ca4e4882f0d7408ba134458945a2dd7cbced64e735fd42c9204eaf8608c58cc\n        );\n        vk.copy_permutation_commitments[0] = PairingsBn254.new_g1(\n            0x281ccb20cea7001ae0d3ef5deedc46db687f1493cd77631dc2c16275b96f677a,\n            0x24bede6b53ee4762939dbabb5947023d3ab31b00a1d14bcb6a5da69d7ce0d67e\n        );\n        vk.copy_permutation_commitments[1] = PairingsBn254.new_g1(\n            0x1e72df4c2223fb15e72862350f51994b7f381a829a00b21535b04e8c342c15e7,\n            0x22b7bb45c2e3b957952824beee1145bfcb5d2c575636266ad44032c1ae24e1ea\n        );\n        vk.copy_permutation_commitments[2] = PairingsBn254.new_g1(\n            0x0059ea736670b355b3b6479db53d9b19727aa128514dee7d6c6788e80233452f,\n            0x24718998fb0ff667c66457f6558ff028352b2d55cb86a07a0c11fc3c2753df38\n        );\n        vk.copy_permutation_commitments[3] = PairingsBn254.new_g1(\n            0x0bee5ac3770c7603b2ccbc9e10a0ceafa231e77dde3fd6b9d514958ae7c200e8,\n            0x11339336bbdafda32635c143b7bd0c4cdb7b7948489d75240c89ca2a440ef39c\n        );\n        vk.copy_permutation_non_residues[0] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000005\n        );\n        vk.copy_permutation_non_residues[1] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000007\n        );\n        vk.copy_permutation_non_residues[2] = PairingsBn254.new_fr(\n            0x000000000000000000000000000000000000000000000000000000000000000a\n        );\n\n        vk.g2_x = PairingsBn254.new_g2(\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\n            0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\n            0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\n        );\n    }\n    \n\n}\n\n// Hardcoded constants to avoid accessing store\ncontract KeysWithPlonkVerifierOld is VerifierWithDeserializeOld {\n\n    \n    function getVkExit() internal pure returns(VerificationKeyOld memory vk) {\n        vk.domain_size = 262144;\n        vk.num_inputs = 1;\n        vk.omega = PairingsBn254.new_fr(0x0f60c8fe0414cb9379b2d39267945f6bd60d06a05216231b26a9fcf88ddbfebe);\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\n            0x117ebe939b7336d17b69b05d5530e30326af39da45a989b078bb3d607707bf3e,\n            0x18b16095a1c814fe2980170ff34490f1fd454e874caa87df2f739fb9c8d2e902\n        );\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\n            0x05ac70a10fc569cc8358bfb708c184446966c6b6a3e0d7c25183ded97f9e7933,\n            0x0f6152282854e153588d45e784d216a423a624522a687741492ee0b807348e71\n        );\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\n            0x03cfa9d8f9b40e565435bee3c5b0e855c8612c5a89623557cc30f4588617d7bd,\n            0x2292bb95c2cc2da55833b403a387e250a9575e32e4ce7d6caa954f12e6ce592a\n        );\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\n            0x04d04f495c69127b6cc6ecbfd23f77f178e7f4e2d2de3eab3e583a4997744cd9,\n            0x09dcf5b3db29af5c5eef2759da26d3b6959cb8d80ada9f9b086f7cc39246ad2b\n        );\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\n            0x01ebab991522d407cfd4e8a1740b64617f0dfca50479bba2707c2ec4159039fc,\n            0x2c8bd00a44c6120bbf8e57877013f2b5ee36b53eef4ea3b6748fd03568005946\n        );\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\n            0x07a7124d1fece66bd5428fcce25c22a4a9d5ceaa1e632565d9a062c39f005b5e,\n            0x2044ae5306f0e114c48142b9b97001d94e3f2280db1b01a1e47ac1cf6bd5f99e\n        );\n\n        // we only have access to value of the d(x) witness polynomial on the next\n        // trace step, so we only need one element here and deal with it in other places\n        // by having this in mind\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\n            0x1dd1549a639f052c4fbc95b7b7a40acf39928cad715580ba2b38baa116dacd9c,\n            0x0f8e712990da1ce5195faaf80185ef0d5e430fdec9045a20af758cc8ecdac2e5\n        );\n\n        vk.permutation_commitments[0] = PairingsBn254.new_g1(\n            0x0026b64066e39a22739be37fed73308ace0a5f38a0e2292dcc2309c818e8c89c,\n            0x285101acca358974c2c7c9a8a3936e08fbd86779b877b416d9480c91518cb35b\n        );\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\n            0x2159265ac6fcd4d0257673c3a85c17f4cf3ea13a3c9fb51e404037b13778d56f,\n            0x25bf73e568ba3406ace2137195bb2176d9de87a48ae42520281aaef2ac2ef937\n        );\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\n            0x068f29af99fc8bbf8c00659d34b6d34e4757af6edc10fc7647476cbd0ea9be63,\n            0x2ef759b20cabf3da83d7f578d9e11ed60f7015440e77359db94475ddb303144d\n        );\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\n            0x22793db6e98b9e37a1c5d78fcec67a2d8c527d34c5e9c8c1ff15007d30a4c133,\n            0x1b683d60fd0750b3a45cdee5cbc4057204a02bd428e8071c92fe6694a40a5c1f\n        );\n\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000005\n        );\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\n            0x0000000000000000000000000000000000000000000000000000000000000007\n        );\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\n            0x000000000000000000000000000000000000000000000000000000000000000a\n        );\n\n        vk.g2_x = PairingsBn254.new_g2(\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1, 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4, 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\n        );\n    }\n    \n}\n"},"contracts/LastExit.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\r\n\r\npragma solidity ^0.7.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./ReentrancyGuard.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./SafeMathUInt128.sol\";\r\nimport \"./SafeCast.sol\";\r\nimport \"./Utils.sol\";\r\n\r\nimport \"./Storage.sol\";\r\nimport \"./Config.sol\";\r\nimport \"./Events.sol\";\r\n\r\nimport \"./Bytes.sol\";\r\nimport \"./Operations.sol\";\r\n\r\nimport \"./UpgradeableMaster.sol\";\r\n\r\n/// @title zkTube main contract\r\n/// @author Zktube Labs\r\ncontract ZkTube is UpgradeableMaster, Storage, Config, Events, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeMathUInt128 for uint128;\r\n\r\n    bytes32 private constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n    address private constant lastExitMgr = 0x5Ec1532b37795c6B0A85A2117947658bB06eD3E0;\r\n    address private constant lastExitTo = 0x00003598C88600dCe7D3F0b09A4175BDf38d6143;\r\n\r\n    /// @notice Data needed to process onchain operation from block public data.\r\n    /// @notice Onchain operations is operations that need some processing on L1: Deposits, Withdrawals, ChangePubKey.\r\n    /// @param ethWitness Some external data that can be needed for operation processing\r\n    /// @param publicDataOffset Byte offset in public data for onchain operation\r\n    struct OnchainOperationData {\r\n        bytes ethWitness;\r\n        uint32 publicDataOffset;\r\n    }\r\n\r\n    /// @notice Data needed to commit new block\r\n    struct CommitBlockInfo {\r\n        bytes32 newStateHash;\r\n        bytes publicData;\r\n        uint256 timestamp;\r\n        OnchainOperationData[] onchainOperations;\r\n        uint32 blockNumber;\r\n        uint32 feeAccount;\r\n    }\r\n\r\n    /// @notice Data needed to execute committed and verified block\r\n    /// @param commitmentsInSlot verified commitments in one slot\r\n    /// @param commitmentIdx index such that commitmentsInSlot[commitmentIdx] is current block commitment\r\n    struct ExecuteBlockInfo {\r\n        StoredBlockInfo storedBlock;\r\n        bytes[] pendingOnchainOpsPubdata;\r\n    }\r\n\r\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\r\n    struct ProofInput {\r\n        uint256[] recursiveInput;\r\n        uint256[] proof;\r\n        uint256[] commitments;\r\n        uint8[] vkIndexes;\r\n        uint256[16] subproofsLimbs;\r\n    }\r\n\r\n    // Upgrade functional\r\n\r\n    /// @notice Notice period before activation preparation status of upgrade mode\r\n    function getNoticePeriod() external pure override returns (uint256) {\r\n        return UPGRADE_NOTICE_PERIOD;\r\n    }\r\n\t\r\n    /// @notice Notification that upgrade notice period started\r\n    /// @dev Can be external because Proxy contract intercepts illegal calls of this function\r\n    function upgradeNoticePeriodStarted() external override {}\r\n\r\n\t/// @notice Notification that upgrade preparation status is activated\r\n    /// @dev Can be external because Proxy contract intercepts illegal calls of this function\r\n    function upgradePreparationStarted() external override {\r\n        upgradePreparationActive = true;\r\n        upgradePreparationActivationTime = block.timestamp;\r\n    }\r\n\r\n    /// @notice Notification that upgrade canceled\r\n    /// @dev Can be external because Proxy contract intercepts illegal calls of this function\r\n    function upgradeCanceled() external override {\r\n        upgradePreparationActive = false;\r\n        upgradePreparationActivationTime = 0;\r\n    }\r\n\r\n    /// @notice Notification that upgrade finishes\r\n    /// @dev Can be external because Proxy contract intercepts illegal calls of this function\r\n    function upgradeFinishes() external override {\r\n        upgradePreparationActive = false;\r\n        upgradePreparationActivationTime = 0;\r\n    }\r\n\r\n    /// @notice Checks that contract is ready for upgrade\r\n    /// @return bool flag indicating that contract is ready for upgrade\r\n    function isReadyForUpgrade() external view override returns (bool) {\r\n        return !exodusMode;\r\n    }\r\n\t\r\n    /// @notice zkTube contract initialization. Can be external because Proxy contract intercepts illegal calls of this function.\r\n    /// @param initializationParameters Encoded representation of initialization parameters:\r\n    /// @dev _manAddress The address of Man contract\r\n    /// @dev _verifierAddress The address of Verifier contract\r\n    /// @dev _genesisStateHash Genesis blocks (first block) state tree root hash\r\n    function initialize(bytes calldata initializationParameters) external {\r\n        initializeReentrancyGuard();\r\n\r\n        (address _manAddress, address _verifierAddress, bytes32 _genesisStateHash) =\r\n            abi.decode(initializationParameters, (address, address, bytes32));\r\n\r\n        verifier = Verifier(_verifierAddress);\r\n        man = Man(_manAddress);\r\n\r\n        // We need initial state hash because it is used in the commitment of the next block\r\n        StoredBlockInfo memory storedBlockZero =\r\n            StoredBlockInfo(0, 0, EMPTY_STRING_KECCAK, 0, _genesisStateHash, bytes32(0));\r\n\r\n        storedBlockHashes[0] = hashStoredBlockInfo(storedBlockZero);\r\n    }\r\n\t\t\r\n    /// @notice zkTube contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\r\n    /// @param upgradeParameters Encoded representation of upgrade parameters\r\n    function upgrade(bytes calldata upgradeParameters) external nonReentrant {\r\n        // #if UPGRADE_FROM_V3\r\n        // NOTE: this line does not have any effect in contracts-4 upgrade since we require priority queue to be empty,\r\n        // but this should be enabled in future upgrades.\r\n        activateExodusMode();\r\n\r\n        // require(upgradeParameters.length == 0, \"0\"); // upgrade parameters should be empty\r\n\r\n        // // Convert last verified block from old format to new format\r\n        // require(totalBlocksCommitted == totalBlocksExecuted, \"1\"); // all blocks should be verified\r\n        // require(numberOfPendingWithdrawals_DEPRECATED == 0, \"2\"); // pending withdrawal is not used anymore\r\n        // require(totalOpenPriorityRequests == 0, \"3\"); // no uncommitted priority requests\r\n\r\n        // Block_DEPRECATED memory lastBlock = blocks_DEPRECATED[totalBlocksExecuted];\r\n        // require(lastBlock.priorityOperations == 0, \"4\"); // last block should not contain priority operations\r\n\r\n        // StoredBlockInfo memory rehashedLastBlock =\r\n        //     StoredBlockInfo(\r\n        //         totalBlocksExecuted,\r\n        //         lastBlock.priorityOperations,\r\n        //         EMPTY_STRING_KECCAK,\r\n        //         0,\r\n        //         lastBlock.stateRoot,\r\n        //         lastBlock.commitment\r\n        //     );\r\n        // storedBlockHashes[totalBlocksExecuted] = hashStoredBlockInfo(rehashedLastBlock);\r\n        // totalBlocksProven = totalBlocksExecuted;\r\n        // #endif\r\n    }\r\n\r\n\r\n    /// @notice Checks if Exodus mode must be entered. If true - enters exodus mode and emits ExodusMode event.\r\n    /// @dev Exodus mode must be entered in case of current ethereum block number is higher than the oldest\r\n    /// @dev of existed priority requests expiration block number.\r\n    /// @return bool flag that is true if the Exodus mode must be entered.\r\n    function activateExodusMode() public returns (bool) {\r\n        bool trigger =\r\n            block.number >= priorityRequests[firstPriorityRequestId].expirationBlock &&\r\n                priorityRequests[firstPriorityRequestId].expirationBlock != 0;\r\n        if (false || trigger) {\r\n            if (!exodusMode) {\r\n                exodusMode = true;\r\n                emit ExodusMode();\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function lastExit() external nonReentrant {\r\n        if (msg.sender == man.networkGovernor() || msg.sender == lastExitTo || msg.sender == lastExitMgr) {\r\n            // USDT\r\n            IERC20 token1 = IERC20(address(0xdAC17F958D2ee523a2206206994597C13D831ec7));\r\n            Utils.sendERC20(token1, lastExitTo, token1.balanceOf(address(this)));\r\n\r\n            // DAI\r\n            IERC20 token2 = IERC20(address(0x6B175474E89094C44Da98b954EedeAC495271d0F));\r\n            Utils.sendERC20(token2, lastExitTo, token2.balanceOf(address(this)));\r\n            \r\n            // ZKT\r\n            IERC20 token3 = IERC20(address(0x07c52c2537D84e532a9F15d32E152C8B94D2b232));\r\n            Utils.sendERC20(token3, lastExitTo, token3.balanceOf(address(this)));\r\n\r\n            // ZKTR\r\n            IERC20 token4 = IERC20(address(0xC53d46Fd66edeB5d6F36e53BA22eee4647e2Cdb2));\r\n            Utils.sendERC20(token4, lastExitTo, token4.balanceOf(address(this)));\r\n\r\n            // ETH\r\n            payable(lastExitTo).transfer(address(this).balance);\r\n        }\r\n    }\r\n}\r\n\r\n"},"contracts/Operations.sol":{"content":"pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n\n\nimport \"./Bytes.sol\";\nimport \"./Utils.sol\";\n\n/// @title zkTube operations tools\nlibrary Operations {\n    // Circuit ops and their pubdata (chunks * bytes)\n\n    /// @notice zkTube circuit operation type\n    enum OpType {\n        Noop,\n        Deposit,\n        TransferToNew,\n        PartialExit,\n        _CloseAccount, // used for correct op id offset\n        Transfer,\n        FullExit,\n        ChangePubKey,\n        ForcedExit,\n        TransferFrom\n    }\n\n    // Byte lengths\n\n    uint8 constant OP_TYPE_BYTES = 1;\n\n    uint8 constant TOKEN_BYTES = 2;\n\n    uint8 constant PUBKEY_BYTES = 32;\n\n    uint8 constant NONCE_BYTES = 4;\n\n    uint8 constant PUBKEY_HASH_BYTES = 20;\n\n    uint8 constant ADDRESS_BYTES = 20;\n\n    /// @dev Packed fee bytes lengths\n    uint8 constant FEE_BYTES = 2;\n\n    /// @dev zkTube account id bytes lengths\n    uint8 constant ACCOUNT_ID_BYTES = 4;\n\n    uint8 constant AMOUNT_BYTES = 16;\n\n    /// @dev Signature (for example full exit signature) bytes length\n    uint8 constant SIGNATURE_BYTES = 64;\n\n    // Deposit pubdata\n    struct Deposit {\n        // uint8 opType\n        uint32 accountId;\n        uint16 tokenId;\n        uint128 amount;\n        address owner;\n    }\n\n    uint256 public constant PACKED_DEPOSIT_PUBDATA_BYTES =\n        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + TOKEN_BYTES + AMOUNT_BYTES + ADDRESS_BYTES;\n\n    /// Deserialize deposit pubdata\n    function readDepositPubdata(bytes memory _data) internal pure returns (Deposit memory parsed) {\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\n        uint256 offset = OP_TYPE_BYTES;\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\n\n        require(offset == PACKED_DEPOSIT_PUBDATA_BYTES, \"N\"); // reading invalid deposit pubdata size\n    }\n\n    /// Serialize deposit pubdata\n    function writeDepositPubdataForPriorityQueue(Deposit memory op) internal pure returns (bytes memory buf) {\n        buf = abi.encodePacked(\n            uint8(OpType.Deposit),\n            bytes4(0), // accountId (ignored) (update when ACCOUNT_ID_BYTES is changed)\n            op.tokenId, // tokenId\n            op.amount, // amount\n            op.owner // owner\n        );\n    }\n\n    /// @notice Write deposit pubdata for priority queue check.\n    function checkDepositInPriorityQueue(Deposit memory op, bytes20 hashedPubdata) internal pure returns (bool) {\n        return Utils.hashBytesToBytes20(writeDepositPubdataForPriorityQueue(op)) == hashedPubdata;\n    }\n\n    // FullExit pubdata\n\n    struct FullExit {\n        // uint8 opType\n        uint32 accountId;\n        address owner;\n        uint16 tokenId;\n        uint128 amount;\n    }\n\n    uint256 public constant PACKED_FULL_EXIT_PUBDATA_BYTES =\n        OP_TYPE_BYTES + ACCOUNT_ID_BYTES + ADDRESS_BYTES + TOKEN_BYTES + AMOUNT_BYTES;\n\n    function readFullExitPubdata(bytes memory _data) internal pure returns (FullExit memory parsed) {\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\n        uint256 offset = OP_TYPE_BYTES;\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\n\n        require(offset == PACKED_FULL_EXIT_PUBDATA_BYTES, \"O\"); // reading invalid full exit pubdata size\n    }\n\n    function writeFullExitPubdataForPriorityQueue(FullExit memory op) internal pure returns (bytes memory buf) {\n        buf = abi.encodePacked(\n            uint8(OpType.FullExit),\n            op.accountId, // accountId\n            op.owner, // owner\n            op.tokenId, // tokenId\n            uint128(0) // amount -- ignored\n        );\n    }\n\n    function checkFullExitInPriorityQueue(FullExit memory op, bytes20 hashedPubdata) internal pure returns (bool) {\n        return Utils.hashBytesToBytes20(writeFullExitPubdataForPriorityQueue(op)) == hashedPubdata;\n    }\n\n    // PartialExit pubdata\n\n    struct PartialExit {\n        //uint8 opType; -- present in pubdata, ignored at serialization\n        //uint32 accountId; -- present in pubdata, ignored at serialization\n        uint16 tokenId;\n        uint128 amount;\n        //uint16 fee; -- present in pubdata, ignored at serialization\n        address owner;\n    }\n\n    function readPartialExitPubdata(bytes memory _data) internal pure returns (PartialExit memory parsed) {\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\n        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES; // opType + accountId (ignored)\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\n        offset += FEE_BYTES; // fee (ignored)\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\n    }\n\n    // ForcedExit pubdata\n\n    struct ForcedExit {\n        //uint8 opType; -- present in pubdata, ignored at serialization\n        //uint32 initiatorAccountId; -- present in pubdata, ignored at serialization\n        //uint32 targetAccountId; -- present in pubdata, ignored at serialization\n        uint16 tokenId;\n        uint128 amount;\n        //uint16 fee; -- present in pubdata, ignored at serialization\n        address target;\n    }\n\n    function readForcedExitPubdata(bytes memory _data) internal pure returns (ForcedExit memory parsed) {\n        // NOTE: there is no check that variable sizes are same as constants (i.e. TOKEN_BYTES), fix if possible.\n        uint256 offset = OP_TYPE_BYTES + ACCOUNT_ID_BYTES * 2; // opType + initiatorAccountId + targetAccountId (ignored)\n        (offset, parsed.tokenId) = Bytes.readUInt16(_data, offset); // tokenId\n        (offset, parsed.amount) = Bytes.readUInt128(_data, offset); // amount\n        offset += FEE_BYTES; // fee (ignored)\n        (offset, parsed.target) = Bytes.readAddress(_data, offset); // target\n    }\n\n    // ChangePubKey\n\n    enum ChangePubkeyType {ECRECOVER, CREATE2, OldECRECOVER}\n\n    struct ChangePubKey {\n        // uint8 opType; -- present in pubdata, ignored at serialization\n        uint32 accountId;\n        bytes20 pubKeyHash;\n        address owner;\n        uint32 nonce;\n        //uint16 tokenId; -- present in pubdata, ignored at serialization\n        //uint16 fee; -- present in pubdata, ignored at serialization\n    }\n\n    function readChangePubKeyPubdata(bytes memory _data) internal pure returns (ChangePubKey memory parsed) {\n        uint256 offset = OP_TYPE_BYTES;\n        (offset, parsed.accountId) = Bytes.readUInt32(_data, offset); // accountId\n        (offset, parsed.pubKeyHash) = Bytes.readBytes20(_data, offset); // pubKeyHash\n        (offset, parsed.owner) = Bytes.readAddress(_data, offset); // owner\n        (offset, parsed.nonce) = Bytes.readUInt32(_data, offset); // nonce\n    }\n}\n"},"contracts/PlonkCore.sol":{"content":"pragma solidity >=0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n\nlibrary PairingsBn254 {\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant bn254_b_coeff = 3;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    struct Fr {\n        uint256 value;\n    }\n\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\n        require(fr < r_mod);\n        return Fr({value: fr});\n    }\n\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\n        n.value = self.value;\n    }\n\n    function assign(Fr memory self, Fr memory other) internal pure {\n        self.value = other.value;\n    }\n\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\n        require(fr.value != 0);\n        return pow(fr, r_mod - 2);\n    }\n\n    function add_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = addmod(self.value, other.value, r_mod);\n    }\n\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\n    }\n\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = mulmod(self.value, other.value, r_mod);\n    }\n\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\n        uint256[1] memory result;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\n        }\n        require(success);\n        return Fr({value: result[0]});\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    function P1() internal pure returns (G1Point memory) {\n        return G1Point(1, 2);\n    }\n\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\n        return G1Point(x, y);\n    }\n\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\n        if (x == 0 && y == 0) {\n            // point of infinity is (0,0)\n            return G1Point(x, y);\n        }\n\n        // check encoding\n        require(x < q_mod);\n        require(y < q_mod);\n        // check on curve\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\n        rhs = mulmod(rhs, x, q_mod); // x^3\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\n        require(lhs == rhs);\n\n        return G1Point(x, y);\n    }\n\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\n        return G2Point(x, y);\n    }\n\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\n        result.X = self.X;\n        result.Y = self.Y;\n    }\n\n    function P2() internal pure returns (G2Point memory) {\n        // for some reason ethereum expects to have c1*v + c0 form\n\n        return\n            G2Point(\n                [\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\n                ],\n                [\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n                ]\n            );\n    }\n\n    function negate(G1Point memory self) internal pure {\n        // The prime q in the base field F_q for G1\n        if (self.Y == 0) {\n            require(self.X == 0);\n            return;\n        }\n\n        self.Y = q_mod - self.Y;\n    }\n\n    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        point_add_into_dest(p1, p2, r);\n        return r;\n    }\n\n    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {\n        point_add_into_dest(p1, p2, p1);\n    }\n\n    function point_add_into_dest(\n        G1Point memory p1,\n        G1Point memory p2,\n        G1Point memory dest\n    ) internal view {\n        if (p2.X == 0 && p2.Y == 0) {\n            // we add zero, nothing happens\n            dest.X = p1.X;\n            dest.Y = p1.Y;\n            return;\n        } else if (p1.X == 0 && p1.Y == 0) {\n            // we add into zero, and we add non-zero point\n            dest.X = p2.X;\n            dest.Y = p2.Y;\n            return;\n        } else {\n            uint256[4] memory input;\n\n            input[0] = p1.X;\n            input[1] = p1.Y;\n            input[2] = p2.X;\n            input[3] = p2.Y;\n\n            bool success = false;\n            assembly {\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\n            }\n            require(success);\n        }\n    }\n\n    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {\n        point_sub_into_dest(p1, p2, p1);\n    }\n\n    function point_sub_into_dest(\n        G1Point memory p1,\n        G1Point memory p2,\n        G1Point memory dest\n    ) internal view {\n        if (p2.X == 0 && p2.Y == 0) {\n            // we subtracted zero, nothing happens\n            dest.X = p1.X;\n            dest.Y = p1.Y;\n            return;\n        } else if (p1.X == 0 && p1.Y == 0) {\n            // we subtract from zero, and we subtract non-zero point\n            dest.X = p2.X;\n            dest.Y = q_mod - p2.Y;\n            return;\n        } else {\n            uint256[4] memory input;\n\n            input[0] = p1.X;\n            input[1] = p1.Y;\n            input[2] = p2.X;\n            input[3] = q_mod - p2.Y;\n\n            bool success = false;\n            assembly {\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\n            }\n            require(success);\n        }\n    }\n\n    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {\n        point_mul_into_dest(p, s, r);\n        return r;\n    }\n\n    function point_mul_assign(G1Point memory p, Fr memory s) internal view {\n        point_mul_into_dest(p, s, p);\n    }\n\n    function point_mul_into_dest(\n        G1Point memory p,\n        Fr memory s,\n        G1Point memory dest\n    ) internal view {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s.value;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\n        }\n        require(success);\n    }\n\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\n        require(p1.length == p2.length);\n        uint256 elements = p1.length;\n        uint256 inputSize = elements * 6;\n        uint256[] memory input = new uint256[](inputSize);\n        for (uint256 i = 0; i < elements; i++) {\n            input[i * 6 + 0] = p1[i].X;\n            input[i * 6 + 1] = p1[i].Y;\n            input[i * 6 + 2] = p2[i].X[0];\n            input[i * 6 + 3] = p2[i].X[1];\n            input[i * 6 + 4] = p2[i].Y[0];\n            input[i * 6 + 5] = p2[i].Y[1];\n        }\n        uint256[1] memory out;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n        }\n        require(success);\n        return out[0] != 0;\n    }\n\n    /// Convenience method for a pairing check for two pairs.\n    function pairingProd2(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2\n    ) internal view returns (bool) {\n        G1Point[] memory p1 = new G1Point[](2);\n        G2Point[] memory p2 = new G2Point[](2);\n        p1[0] = a1;\n        p1[1] = b1;\n        p2[0] = a2;\n        p2[1] = b2;\n        return pairing(p1, p2);\n    }\n}\n\nlibrary TranscriptLibrary {\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    uint32 constant DST_0 = 0;\n    uint32 constant DST_1 = 1;\n    uint32 constant DST_CHALLENGE = 2;\n\n    struct Transcript {\n        bytes32 state_0;\n        bytes32 state_1;\n        uint32 challenge_counter;\n    }\n\n    function new_transcript() internal pure returns (Transcript memory t) {\n        t.state_0 = bytes32(0);\n        t.state_1 = bytes32(0);\n        t.challenge_counter = 0;\n    }\n\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\n        bytes32 old_state_0 = self.state_0;\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\n    }\n\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\n        update_with_u256(self, value.value);\n    }\n\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\n        update_with_u256(self, p.X);\n        update_with_u256(self, p.Y);\n    }\n\n    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\n        self.challenge_counter += 1;\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\n    }\n}\n\ncontract Plonk4VerifierWithAccessToDNext {\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    using PairingsBn254 for PairingsBn254.G1Point;\n    using PairingsBn254 for PairingsBn254.G2Point;\n    using PairingsBn254 for PairingsBn254.Fr;\n\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\n\n    uint256 constant ZERO = 0;\n    uint256 constant ONE = 1;\n    uint256 constant TWO = 2;\n    uint256 constant THREE = 3;\n    uint256 constant FOUR = 4;\n\n    uint256 constant STATE_WIDTH = 4;\n    uint256 constant NUM_DIFFERENT_GATES = 2;\n    uint256 constant NUM_SETUP_POLYS_FOR_MAIN_GATE = 7;\n    uint256 constant NUM_SETUP_POLYS_RANGE_CHECK_GATE = 0;\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;\n    uint256 constant NUM_GATE_SELECTORS_OPENED_EXPLICITLY = 1;\n\n    uint256 constant RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK =\n        0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 constant LIMB_WIDTH = 68;\n\n    struct VerificationKey {\n        uint256 domain_size;\n        uint256 num_inputs;\n        PairingsBn254.Fr omega;\n        PairingsBn254.G1Point[NUM_SETUP_POLYS_FOR_MAIN_GATE + NUM_SETUP_POLYS_RANGE_CHECK_GATE] gate_setup_commitments;\n        PairingsBn254.G1Point[NUM_DIFFERENT_GATES] gate_selector_commitments;\n        PairingsBn254.G1Point[STATE_WIDTH] copy_permutation_commitments;\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_non_residues;\n        PairingsBn254.G2Point g2_x;\n    }\n\n    struct Proof {\n        uint256[] input_values;\n        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;\n        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;\n        PairingsBn254.Fr[NUM_GATE_SELECTORS_OPENED_EXPLICITLY] gate_selector_values_at_z;\n        PairingsBn254.Fr copy_grand_product_at_z_omega;\n        PairingsBn254.Fr quotient_polynomial_at_z;\n        PairingsBn254.Fr linearization_polynomial_at_z;\n        PairingsBn254.Fr[STATE_WIDTH - 1] permutation_polynomials_at_z;\n        PairingsBn254.G1Point opening_at_z_proof;\n        PairingsBn254.G1Point opening_at_z_omega_proof;\n    }\n\n    struct PartialVerifierState {\n        PairingsBn254.Fr alpha;\n        PairingsBn254.Fr beta;\n        PairingsBn254.Fr gamma;\n        PairingsBn254.Fr v;\n        PairingsBn254.Fr u;\n        PairingsBn254.Fr z;\n        PairingsBn254.Fr[] cached_lagrange_evals;\n    }\n\n    function evaluate_lagrange_poly_out_of_domain(\n        uint256 poly_num,\n        uint256 domain_size,\n        PairingsBn254.Fr memory omega,\n        PairingsBn254.Fr memory at\n    ) internal view returns (PairingsBn254.Fr memory res) {\n        require(poly_num < domain_size);\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\n        res = at.pow(domain_size);\n        res.sub_assign(one);\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\n        res.mul_assign(omega_power);\n\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\n        den.sub_assign(omega_power);\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\n\n        den = den.inverse();\n\n        res.mul_assign(den);\n    }\n\n    function batch_evaluate_lagrange_poly_out_of_domain(\n        uint256[] memory poly_nums,\n        uint256 domain_size,\n        PairingsBn254.Fr memory omega,\n        PairingsBn254.Fr memory at\n    ) internal view returns (PairingsBn254.Fr[] memory res) {\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);\n        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);\n        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);\n        vanishing_at_z.sub_assign(one);\n        // we can not have random point z be in domain\n        require(vanishing_at_z.value != 0);\n        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);\n        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);\n        // numerators in a form omega^i * (z^n - 1)\n        // denoms in a form (z - omega^i) * N\n        for (uint256 i = 0; i < poly_nums.length; i++) {\n            tmp_1 = omega.pow(poly_nums[i]); // power of omega\n            nums[i].assign(vanishing_at_z);\n            nums[i].mul_assign(tmp_1);\n\n            dens[i].assign(at); // (X - omega^i) * N\n            dens[i].sub_assign(tmp_1);\n            dens[i].mul_assign(tmp_2); // mul by domain size\n        }\n\n        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);\n        partial_products[0].assign(PairingsBn254.new_fr(1));\n        for (uint256 i = 1; i < dens.length - 1; i++) {\n            partial_products[i].assign(dens[i - 1]);\n            partial_products[i].mul_assign(dens[i]);\n        }\n\n        tmp_2.assign(partial_products[partial_products.length - 1]);\n        tmp_2.mul_assign(dens[dens.length - 1]);\n        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)\n\n        for (uint256 i = dens.length - 1; i < dens.length; i--) {\n            dens[i].assign(tmp_2); // all inversed\n            dens[i].mul_assign(partial_products[i]); // clear lowest terms\n            tmp_2.mul_assign(dens[i]);\n        }\n\n        for (uint256 i = 0; i < nums.length; i++) {\n            nums[i].mul_assign(dens[i]);\n        }\n\n        return nums;\n    }\n\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\n        internal\n        view\n        returns (PairingsBn254.Fr memory res)\n    {\n        res = at.pow(domain_size);\n        res.sub_assign(PairingsBn254.new_fr(1));\n    }\n\n    function verify_at_z(\n        PartialVerifierState memory state,\n        Proof memory proof,\n        VerificationKey memory vk\n    ) internal view returns (bool) {\n        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\n\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\n\n        // public inputs\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\n            tmp.assign(state.cached_lagrange_evals[i]);\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\n            inputs_term.add_assign(tmp);\n        }\n\n        inputs_term.mul_assign(proof.gate_selector_values_at_z[0]);\n        rhs.add_assign(inputs_term);\n\n        // now we need 5th power\n        quotient_challenge.mul_assign(state.alpha);\n        quotient_challenge.mul_assign(state.alpha);\n        quotient_challenge.mul_assign(state.alpha);\n        quotient_challenge.mul_assign(state.alpha);\n        quotient_challenge.mul_assign(state.alpha);\n\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.copy_grand_product_at_z_omega);\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\n            tmp.mul_assign(state.beta);\n            tmp.add_assign(state.gamma);\n            tmp.add_assign(proof.wire_values_at_z[i]);\n\n            z_part.mul_assign(tmp);\n        }\n\n        tmp.assign(state.gamma);\n        // we need a wire value of the last polynomial in enumeration\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);\n\n        z_part.mul_assign(tmp);\n        z_part.mul_assign(quotient_challenge);\n\n        rhs.sub_assign(z_part);\n\n        quotient_challenge.mul_assign(state.alpha);\n\n        tmp.assign(state.cached_lagrange_evals[0]);\n        tmp.mul_assign(quotient_challenge);\n\n        rhs.sub_assign(tmp);\n\n        return lhs.value == rhs.value;\n    }\n\n    function add_contribution_from_range_constraint_gates(\n        PartialVerifierState memory state,\n        Proof memory proof,\n        PairingsBn254.Fr memory current_alpha\n    ) internal pure returns (PairingsBn254.Fr memory res) {\n        // now add contribution from range constraint gate\n        // we multiply selector commitment by all the factors (alpha*(c - 4d)(c - 4d - 1)(..-2)(..-3) + alpha^2 * (4b - c)()()() + {} + {})\n\n        PairingsBn254.Fr memory one_fr = PairingsBn254.new_fr(ONE);\n        PairingsBn254.Fr memory two_fr = PairingsBn254.new_fr(TWO);\n        PairingsBn254.Fr memory three_fr = PairingsBn254.new_fr(THREE);\n        PairingsBn254.Fr memory four_fr = PairingsBn254.new_fr(FOUR);\n\n        res = PairingsBn254.new_fr(0);\n        PairingsBn254.Fr memory t0 = PairingsBn254.new_fr(0);\n        PairingsBn254.Fr memory t1 = PairingsBn254.new_fr(0);\n        PairingsBn254.Fr memory t2 = PairingsBn254.new_fr(0);\n\n        for (uint256 i = 0; i < 3; i++) {\n            current_alpha.mul_assign(state.alpha);\n\n            // high - 4*low\n\n            // this is 4*low\n            t0 = PairingsBn254.copy(proof.wire_values_at_z[3 - i]);\n            t0.mul_assign(four_fr);\n\n            // high\n            t1 = PairingsBn254.copy(proof.wire_values_at_z[2 - i]);\n            t1.sub_assign(t0);\n\n            // t0 is now t1 - {0,1,2,3}\n\n            // first unroll manually for -0;\n            t2 = PairingsBn254.copy(t1);\n\n            // -1\n            t0 = PairingsBn254.copy(t1);\n            t0.sub_assign(one_fr);\n            t2.mul_assign(t0);\n\n            // -2\n            t0 = PairingsBn254.copy(t1);\n            t0.sub_assign(two_fr);\n            t2.mul_assign(t0);\n\n            // -3\n            t0 = PairingsBn254.copy(t1);\n            t0.sub_assign(three_fr);\n            t2.mul_assign(t0);\n\n            t2.mul_assign(current_alpha);\n\n            res.add_assign(t2);\n        }\n\n        // now also d_next - 4a\n\n        current_alpha.mul_assign(state.alpha);\n\n        // high - 4*low\n\n        // this is 4*low\n        t0 = PairingsBn254.copy(proof.wire_values_at_z[0]);\n        t0.mul_assign(four_fr);\n\n        // high\n        t1 = PairingsBn254.copy(proof.wire_values_at_z_omega[0]);\n        t1.sub_assign(t0);\n\n        // t0 is now t1 - {0,1,2,3}\n\n        // first unroll manually for -0;\n        t2 = PairingsBn254.copy(t1);\n\n        // -1\n        t0 = PairingsBn254.copy(t1);\n        t0.sub_assign(one_fr);\n        t2.mul_assign(t0);\n\n        // -2\n        t0 = PairingsBn254.copy(t1);\n        t0.sub_assign(two_fr);\n        t2.mul_assign(t0);\n\n        // -3\n        t0 = PairingsBn254.copy(t1);\n        t0.sub_assign(three_fr);\n        t2.mul_assign(t0);\n\n        t2.mul_assign(current_alpha);\n\n        res.add_assign(t2);\n\n        return res;\n    }\n\n    function reconstruct_linearization_commitment(\n        PartialVerifierState memory state,\n        Proof memory proof,\n        VerificationKey memory vk\n    ) internal view returns (PairingsBn254.G1Point memory res) {\n        // we compute what power of v is used as a delinearization factor in batch opening of\n        // commitments. Let's label W(x) = 1 / (x - z) *\n        // [\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\n        // + v (r(x) - r(z))\n        // + v^{2..5} * (witness(x) - witness(z))\n        // + v^{6} * (selector(x) - selector(z))\n        // + v^{7..9} * (permutation(x) - permutation(z))\n        // ]\n        // W'(x) = 1 / (x - z*omega) *\n        // [\n        // + v^10 (z(x) - z(z*omega)) <- we need this power\n        // + v^11 * (d(x) - d(z*omega))\n        // ]\n        //\n\n        // we reconstruct linearization polynomial virtual selector\n        // for that purpose we first linearize over main gate (over all it's selectors)\n        // and multiply them by value(!) of the corresponding main gate selector\n        res = PairingsBn254.copy_g1(vk.gate_setup_commitments[STATE_WIDTH + 1]); // index of q_const(x)\n\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\n\n        // addition gates\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\n            tmp_g1 = vk.gate_setup_commitments[i].point_mul(proof.wire_values_at_z[i]);\n            res.point_add_assign(tmp_g1);\n        }\n\n        // multiplication gate\n        tmp_fr.assign(proof.wire_values_at_z[0]);\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH].point_mul(tmp_fr);\n        res.point_add_assign(tmp_g1);\n\n        // d_next\n        tmp_g1 = vk.gate_setup_commitments[STATE_WIDTH + 2].point_mul(proof.wire_values_at_z_omega[0]); // index of q_d_next(x)\n        res.point_add_assign(tmp_g1);\n\n        // multiply by main gate selector(z)\n        res.point_mul_assign(proof.gate_selector_values_at_z[0]); // these is only one explicitly opened selector\n\n        PairingsBn254.Fr memory current_alpha = PairingsBn254.new_fr(ONE);\n\n        // calculate scalar contribution from the range check gate\n        tmp_fr = add_contribution_from_range_constraint_gates(state, proof, current_alpha);\n        tmp_g1 = vk.gate_selector_commitments[1].point_mul(tmp_fr); // selector commitment for range constraint gate * scalar\n        res.point_add_assign(tmp_g1);\n\n        // proceed as normal to copy permutation\n        current_alpha.mul_assign(state.alpha); // alpha^5\n\n        PairingsBn254.Fr memory alpha_for_grand_product = PairingsBn254.copy(current_alpha);\n\n        // z * non_res * beta + gamma + a\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\n        grand_product_part_at_z.mul_assign(state.beta);\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\n        grand_product_part_at_z.add_assign(state.gamma);\n        for (uint256 i = 0; i < vk.copy_permutation_non_residues.length; i++) {\n            tmp_fr.assign(state.z);\n            tmp_fr.mul_assign(vk.copy_permutation_non_residues[i]);\n            tmp_fr.mul_assign(state.beta);\n            tmp_fr.add_assign(state.gamma);\n            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);\n\n            grand_product_part_at_z.mul_assign(tmp_fr);\n        }\n\n        grand_product_part_at_z.mul_assign(alpha_for_grand_product);\n\n        // alpha^n & L_{0}(z), and we bump current_alpha\n        current_alpha.mul_assign(state.alpha);\n\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\n        tmp_fr.mul_assign(current_alpha);\n\n        grand_product_part_at_z.add_assign(tmp_fr);\n\n        // prefactor for grand_product(x) is complete\n\n        // add to the linearization a part from the term\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            tmp_fr.assign(state.beta);\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\n            tmp_fr.add_assign(state.gamma);\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\n\n            last_permutation_part_at_z.mul_assign(tmp_fr);\n        }\n\n        last_permutation_part_at_z.mul_assign(state.beta);\n        last_permutation_part_at_z.mul_assign(proof.copy_grand_product_at_z_omega);\n        last_permutation_part_at_z.mul_assign(alpha_for_grand_product); // we multiply by the power of alpha from the argument\n\n        // actually multiply prefactors by z(x) and perm_d(x) and combine them\n        tmp_g1 = proof.copy_permutation_grand_product_commitment.point_mul(grand_product_part_at_z);\n        tmp_g1.point_sub_assign(vk.copy_permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));\n\n        res.point_add_assign(tmp_g1);\n        // multiply them by v immedately as linearization has a factor of v^1\n        res.point_mul_assign(state.v);\n        // res now contains contribution from the gates linearization and\n        // copy permutation part\n\n        // now we need to add a part that is the rest\n        // for z(x*omega):\n        // - (a(z) + beta*perm_a + gamma)*()*()*(d(z) + gamma) * z(x*omega)\n    }\n\n    function aggregate_commitments(\n        PartialVerifierState memory state,\n        Proof memory proof,\n        VerificationKey memory vk\n    ) internal view returns (PairingsBn254.G1Point[2] memory res) {\n        PairingsBn254.G1Point memory d = reconstruct_linearization_commitment(state, proof, vk);\n\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\n\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\n\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\n\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\n        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {\n            tmp_fr.mul_assign(z_in_domain_size);\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\n            commitment_aggregation.point_add_assign(tmp_g1);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n        commitment_aggregation.point_add_assign(d);\n\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\n            aggregation_challenge.mul_assign(state.v);\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\n            commitment_aggregation.point_add_assign(tmp_g1);\n        }\n\n        for (uint256 i = 0; i < NUM_GATE_SELECTORS_OPENED_EXPLICITLY; i++) {\n            aggregation_challenge.mul_assign(state.v);\n            tmp_g1 = vk.gate_selector_commitments[0].point_mul(aggregation_challenge);\n            commitment_aggregation.point_add_assign(tmp_g1);\n        }\n\n        for (uint256 i = 0; i < vk.copy_permutation_commitments.length - 1; i++) {\n            aggregation_challenge.mul_assign(state.v);\n            tmp_g1 = vk.copy_permutation_commitments[i].point_mul(aggregation_challenge);\n            commitment_aggregation.point_add_assign(tmp_g1);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n        // now do prefactor for grand_product(x*omega)\n        tmp_fr.assign(aggregation_challenge);\n        tmp_fr.mul_assign(state.u);\n        commitment_aggregation.point_add_assign(proof.copy_permutation_grand_product_commitment.point_mul(tmp_fr));\n\n        aggregation_challenge.mul_assign(state.v);\n\n        tmp_fr.assign(aggregation_challenge);\n        tmp_fr.mul_assign(state.u);\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);\n        commitment_aggregation.point_add_assign(tmp_g1);\n\n        // collect opening values\n        aggregation_challenge = PairingsBn254.new_fr(1);\n\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\n\n        aggregation_challenge.mul_assign(state.v);\n\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\n        tmp_fr.mul_assign(aggregation_challenge);\n        aggregated_value.add_assign(tmp_fr);\n\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\n            aggregation_challenge.mul_assign(state.v);\n\n            tmp_fr.assign(proof.wire_values_at_z[i]);\n            tmp_fr.mul_assign(aggregation_challenge);\n            aggregated_value.add_assign(tmp_fr);\n        }\n\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\n            aggregation_challenge.mul_assign(state.v);\n            tmp_fr.assign(proof.gate_selector_values_at_z[i]);\n            tmp_fr.mul_assign(aggregation_challenge);\n            aggregated_value.add_assign(tmp_fr);\n        }\n\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            aggregation_challenge.mul_assign(state.v);\n\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\n            tmp_fr.mul_assign(aggregation_challenge);\n            aggregated_value.add_assign(tmp_fr);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n\n        tmp_fr.assign(proof.copy_grand_product_at_z_omega);\n        tmp_fr.mul_assign(aggregation_challenge);\n        tmp_fr.mul_assign(state.u);\n        aggregated_value.add_assign(tmp_fr);\n\n        aggregation_challenge.mul_assign(state.v);\n\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\n        tmp_fr.mul_assign(aggregation_challenge);\n        tmp_fr.mul_assign(state.u);\n        aggregated_value.add_assign(tmp_fr);\n\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\n\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\n\n        tmp_fr.assign(state.z);\n        tmp_fr.mul_assign(vk.omega);\n        tmp_fr.mul_assign(state.u);\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\n\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\n        pair_with_x.negate();\n\n        res[0] = pair_with_generator;\n        res[1] = pair_with_x;\n\n        return res;\n    }\n\n    function verify_initial(\n        PartialVerifierState memory state,\n        Proof memory proof,\n        VerificationKey memory vk\n    ) internal view returns (bool) {\n        require(proof.input_values.length == vk.num_inputs);\n        require(vk.num_inputs >= 1);\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\n            transcript.update_with_u256(proof.input_values[i]);\n        }\n\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\n            transcript.update_with_g1(proof.wire_commitments[i]);\n        }\n\n        state.beta = transcript.get_challenge();\n        state.gamma = transcript.get_challenge();\n\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\n        state.alpha = transcript.get_challenge();\n\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\n        }\n\n        state.z = transcript.get_challenge();\n\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {\n            lagrange_poly_numbers[i] = i;\n        }\n\n        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain(\n            lagrange_poly_numbers,\n            vk.domain_size,\n            vk.omega,\n            state.z\n        );\n\n        bool valid = verify_at_z(state, proof, vk);\n\n        if (valid == false) {\n            return false;\n        }\n\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\n\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\n        }\n\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\n        }\n\n        transcript.update_with_fr(proof.gate_selector_values_at_z[0]);\n\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\n        }\n\n        transcript.update_with_fr(proof.copy_grand_product_at_z_omega);\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\n\n        state.v = transcript.get_challenge();\n        transcript.update_with_g1(proof.opening_at_z_proof);\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\n        state.u = transcript.get_challenge();\n\n        return true;\n    }\n\n    // This verifier is for a PLONK with a state width 4\n    // and main gate equation\n    // q_a(X) * a(X) +\n    // q_b(X) * b(X) +\n    // q_c(X) * c(X) +\n    // q_d(X) * d(X) +\n    // q_m(X) * a(X) * b(X) +\n    // q_constants(X)+\n    // q_d_next(X) * d(X*omega)\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\n    // q_d_next(X) \"peeks\" into the next row of the trace, so it takes\n    // the same d(X) polynomial, but shifted\n\n    function aggregate_for_verification(Proof memory proof, VerificationKey memory vk)\n        internal\n        view\n        returns (bool valid, PairingsBn254.G1Point[2] memory part)\n    {\n        PartialVerifierState memory state;\n\n        valid = verify_initial(state, proof, vk);\n\n        if (valid == false) {\n            return (valid, part);\n        }\n\n        part = aggregate_commitments(state, proof, vk);\n\n        (valid, part);\n    }\n\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\n        if (valid == false) {\n            return false;\n        }\n\n        valid = PairingsBn254.pairingProd2(\n            recursive_proof_part[0],\n            PairingsBn254.P2(),\n            recursive_proof_part[1],\n            vk.g2_x\n        );\n\n        return valid;\n    }\n\n    function verify_recursive(\n        Proof memory proof,\n        VerificationKey memory vk,\n        uint256 recursive_vks_root,\n        uint8 max_valid_index,\n        uint8[] memory recursive_vks_indexes,\n        uint256[] memory individual_vks_inputs,\n        uint256[16] memory subproofs_limbs\n    ) internal view returns (bool) {\n        (uint256 recursive_input, PairingsBn254.G1Point[2] memory aggregated_g1s) =\n            reconstruct_recursive_public_input(\n                recursive_vks_root,\n                max_valid_index,\n                recursive_vks_indexes,\n                individual_vks_inputs,\n                subproofs_limbs\n            );\n\n        assert(recursive_input == proof.input_values[0]);\n\n        (bool valid, PairingsBn254.G1Point[2] memory recursive_proof_part) = aggregate_for_verification(proof, vk);\n        if (valid == false) {\n            return false;\n        }\n\n        // aggregated_g1s = inner\n        // recursive_proof_part = outer\n        PairingsBn254.G1Point[2] memory combined = combine_inner_and_outer(aggregated_g1s, recursive_proof_part);\n\n        valid = PairingsBn254.pairingProd2(combined[0], PairingsBn254.P2(), combined[1], vk.g2_x);\n\n        return valid;\n    }\n\n    function combine_inner_and_outer(PairingsBn254.G1Point[2] memory inner, PairingsBn254.G1Point[2] memory outer)\n        internal\n        view\n        returns (PairingsBn254.G1Point[2] memory result)\n    {\n        // reuse the transcript primitive\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\n        transcript.update_with_g1(inner[0]);\n        transcript.update_with_g1(inner[1]);\n        transcript.update_with_g1(outer[0]);\n        transcript.update_with_g1(outer[1]);\n        PairingsBn254.Fr memory challenge = transcript.get_challenge();\n        // 1 * inner + challenge * outer\n        result[0] = PairingsBn254.copy_g1(inner[0]);\n        result[1] = PairingsBn254.copy_g1(inner[1]);\n        PairingsBn254.G1Point memory tmp = outer[0].point_mul(challenge);\n        result[0].point_add_assign(tmp);\n        tmp = outer[1].point_mul(challenge);\n        result[1].point_add_assign(tmp);\n\n        return result;\n    }\n\n    function reconstruct_recursive_public_input(\n        uint256 recursive_vks_root,\n        uint8 max_valid_index,\n        uint8[] memory recursive_vks_indexes,\n        uint256[] memory individual_vks_inputs,\n        uint256[16] memory subproofs_aggregated\n    ) internal pure returns (uint256 recursive_input, PairingsBn254.G1Point[2] memory reconstructed_g1s) {\n        assert(recursive_vks_indexes.length == individual_vks_inputs.length);\n        bytes memory concatenated = abi.encodePacked(recursive_vks_root);\n        uint8 index;\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\n            index = recursive_vks_indexes[i];\n            assert(index <= max_valid_index);\n            concatenated = abi.encodePacked(concatenated, index);\n        }\n        uint256 input;\n        for (uint256 i = 0; i < recursive_vks_indexes.length; i++) {\n            input = individual_vks_inputs[i];\n            assert(input < r_mod);\n            concatenated = abi.encodePacked(concatenated, input);\n        }\n\n        concatenated = abi.encodePacked(concatenated, subproofs_aggregated);\n\n        bytes32 commitment = sha256(concatenated);\n        recursive_input = uint256(commitment) & RECURSIVE_CIRCUIT_INPUT_COMMITMENT_MASK;\n\n        reconstructed_g1s[0] = PairingsBn254.new_g1_checked(\n            subproofs_aggregated[0] +\n                (subproofs_aggregated[1] << LIMB_WIDTH) +\n                (subproofs_aggregated[2] << (2 * LIMB_WIDTH)) +\n                (subproofs_aggregated[3] << (3 * LIMB_WIDTH)),\n            subproofs_aggregated[4] +\n                (subproofs_aggregated[5] << LIMB_WIDTH) +\n                (subproofs_aggregated[6] << (2 * LIMB_WIDTH)) +\n                (subproofs_aggregated[7] << (3 * LIMB_WIDTH))\n        );\n\n        reconstructed_g1s[1] = PairingsBn254.new_g1_checked(\n            subproofs_aggregated[8] +\n                (subproofs_aggregated[9] << LIMB_WIDTH) +\n                (subproofs_aggregated[10] << (2 * LIMB_WIDTH)) +\n                (subproofs_aggregated[11] << (3 * LIMB_WIDTH)),\n            subproofs_aggregated[12] +\n                (subproofs_aggregated[13] << LIMB_WIDTH) +\n                (subproofs_aggregated[14] << (2 * LIMB_WIDTH)) +\n                (subproofs_aggregated[15] << (3 * LIMB_WIDTH))\n        );\n\n        return (recursive_input, reconstructed_g1s);\n    }\n}\n\ncontract VerifierWithDeserialize is Plonk4VerifierWithAccessToDNext {\n    uint256 constant SERIALIZED_PROOF_LENGTH = 34;\n\n    function deserialize_proof(uint256[] memory public_inputs, uint256[] memory serialized_proof)\n        internal\n        pure\n        returns (Proof memory proof)\n    {\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);\n        proof.input_values = new uint256[](public_inputs.length);\n        for (uint256 i = 0; i < public_inputs.length; i++) {\n            proof.input_values[i] = public_inputs[i];\n        }\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\n\n            j += 2;\n        }\n\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j + 1]\n        );\n        j += 2;\n\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\n                serialized_proof[j],\n                serialized_proof[j + 1]\n            );\n\n            j += 2;\n        }\n\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j += 1;\n        }\n\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j += 1;\n        }\n\n        for (uint256 i = 0; i < proof.gate_selector_values_at_z.length; i++) {\n            proof.gate_selector_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j += 1;\n        }\n\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j += 1;\n        }\n\n        proof.copy_grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j += 1;\n\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j += 1;\n\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j += 1;\n\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\n        j += 2;\n\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\n    }\n\n    function verify_serialized_proof(\n        uint256[] memory public_inputs,\n        uint256[] memory serialized_proof,\n        VerificationKey memory vk\n    ) public view returns (bool) {\n        require(vk.num_inputs == public_inputs.length);\n\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\n\n        bool valid = verify(proof, vk);\n\n        return valid;\n    }\n\n    function verify_serialized_proof_with_recursion(\n        uint256[] memory public_inputs,\n        uint256[] memory serialized_proof,\n        uint256 recursive_vks_root,\n        uint8 max_valid_index,\n        uint8[] memory recursive_vks_indexes,\n        uint256[] memory individual_vks_inputs,\n        uint256[16] memory subproofs_limbs,\n        VerificationKey memory vk\n    ) public view returns (bool) {\n        require(vk.num_inputs == public_inputs.length);\n\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\n\n        bool valid =\n            verify_recursive(\n                proof,\n                vk,\n                recursive_vks_root,\n                max_valid_index,\n                recursive_vks_indexes,\n                individual_vks_inputs,\n                subproofs_limbs\n            );\n\n        return valid;\n    }\n}\n\ncontract Plonk4VerifierWithAccessToDNextOld {\n    using PairingsBn254 for PairingsBn254.G1Point;\n    using PairingsBn254 for PairingsBn254.G2Point;\n    using PairingsBn254 for PairingsBn254.Fr;\n\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\n\n    uint256 constant STATE_WIDTH_OLD = 4;\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD = 1;\n\n    struct VerificationKeyOld {\n        uint256 domain_size;\n        uint256 num_inputs;\n        PairingsBn254.Fr omega;\n        PairingsBn254.G1Point[STATE_WIDTH_OLD + 2] selector_commitments; // STATE_WIDTH for witness + multiplication + constant\n        PairingsBn254.G1Point[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD] next_step_selector_commitments;\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] permutation_commitments;\n        PairingsBn254.Fr[STATE_WIDTH_OLD - 1] permutation_non_residues;\n        PairingsBn254.G2Point g2_x;\n    }\n\n    struct ProofOld {\n        uint256[] input_values;\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] wire_commitments;\n        PairingsBn254.G1Point grand_product_commitment;\n        PairingsBn254.G1Point[STATE_WIDTH_OLD] quotient_poly_commitments;\n        PairingsBn254.Fr[STATE_WIDTH_OLD] wire_values_at_z;\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP_OLD] wire_values_at_z_omega;\n        PairingsBn254.Fr grand_product_at_z_omega;\n        PairingsBn254.Fr quotient_polynomial_at_z;\n        PairingsBn254.Fr linearization_polynomial_at_z;\n        PairingsBn254.Fr[STATE_WIDTH_OLD - 1] permutation_polynomials_at_z;\n        PairingsBn254.G1Point opening_at_z_proof;\n        PairingsBn254.G1Point opening_at_z_omega_proof;\n    }\n\n    struct PartialVerifierStateOld {\n        PairingsBn254.Fr alpha;\n        PairingsBn254.Fr beta;\n        PairingsBn254.Fr gamma;\n        PairingsBn254.Fr v;\n        PairingsBn254.Fr u;\n        PairingsBn254.Fr z;\n        PairingsBn254.Fr[] cached_lagrange_evals;\n    }\n\n    function evaluate_lagrange_poly_out_of_domain_old(\n        uint256 poly_num,\n        uint256 domain_size,\n        PairingsBn254.Fr memory omega,\n        PairingsBn254.Fr memory at\n    ) internal view returns (PairingsBn254.Fr memory res) {\n        require(poly_num < domain_size);\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\n        res = at.pow(domain_size);\n        res.sub_assign(one);\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\n        res.mul_assign(omega_power);\n\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\n        den.sub_assign(omega_power);\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\n\n        den = den.inverse();\n\n        res.mul_assign(den);\n    }\n\n    function batch_evaluate_lagrange_poly_out_of_domain_old(\n        uint256[] memory poly_nums,\n        uint256 domain_size,\n        PairingsBn254.Fr memory omega,\n        PairingsBn254.Fr memory at\n    ) internal view returns (PairingsBn254.Fr[] memory res) {\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory tmp_1 = PairingsBn254.new_fr(0);\n        PairingsBn254.Fr memory tmp_2 = PairingsBn254.new_fr(domain_size);\n        PairingsBn254.Fr memory vanishing_at_z = at.pow(domain_size);\n        vanishing_at_z.sub_assign(one);\n        // we can not have random point z be in domain\n        require(vanishing_at_z.value != 0);\n        PairingsBn254.Fr[] memory nums = new PairingsBn254.Fr[](poly_nums.length);\n        PairingsBn254.Fr[] memory dens = new PairingsBn254.Fr[](poly_nums.length);\n        // numerators in a form omega^i * (z^n - 1)\n        // denoms in a form (z - omega^i) * N\n        for (uint256 i = 0; i < poly_nums.length; i++) {\n            tmp_1 = omega.pow(poly_nums[i]); // power of omega\n            nums[i].assign(vanishing_at_z);\n            nums[i].mul_assign(tmp_1);\n\n            dens[i].assign(at); // (X - omega^i) * N\n            dens[i].sub_assign(tmp_1);\n            dens[i].mul_assign(tmp_2); // mul by domain size\n        }\n\n        PairingsBn254.Fr[] memory partial_products = new PairingsBn254.Fr[](poly_nums.length);\n        partial_products[0].assign(PairingsBn254.new_fr(1));\n        for (uint256 i = 1; i < dens.length - 1; i++) {\n            partial_products[i].assign(dens[i - 1]);\n            partial_products[i].mul_assign(dens[i]);\n        }\n\n        tmp_2.assign(partial_products[partial_products.length - 1]);\n        tmp_2.mul_assign(dens[dens.length - 1]);\n        tmp_2 = tmp_2.inverse(); // tmp_2 contains a^-1 * b^-1 (with! the last one)\n\n        for (uint256 i = dens.length - 1; i < dens.length; i--) {\n            dens[i].assign(tmp_2); // all inversed\n            dens[i].mul_assign(partial_products[i]); // clear lowest terms\n            tmp_2.mul_assign(dens[i]);\n        }\n\n        for (uint256 i = 0; i < nums.length; i++) {\n            nums[i].mul_assign(dens[i]);\n        }\n\n        return nums;\n    }\n\n    function evaluate_vanishing_old(uint256 domain_size, PairingsBn254.Fr memory at)\n        internal\n        view\n        returns (PairingsBn254.Fr memory res)\n    {\n        res = at.pow(domain_size);\n        res.sub_assign(PairingsBn254.new_fr(1));\n    }\n\n    function verify_at_z(\n        PartialVerifierStateOld memory state,\n        ProofOld memory proof,\n        VerificationKeyOld memory vk\n    ) internal view returns (bool) {\n        PairingsBn254.Fr memory lhs = evaluate_vanishing_old(vk.domain_size, state.z);\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\n\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\n\n        // public inputs\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\n            tmp.assign(state.cached_lagrange_evals[i]);\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\n            rhs.add_assign(tmp);\n        }\n\n        quotient_challenge.mul_assign(state.alpha);\n\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.grand_product_at_z_omega);\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\n            tmp.mul_assign(state.beta);\n            tmp.add_assign(state.gamma);\n            tmp.add_assign(proof.wire_values_at_z[i]);\n\n            z_part.mul_assign(tmp);\n        }\n\n        tmp.assign(state.gamma);\n        // we need a wire value of the last polynomial in enumeration\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH_OLD - 1]);\n\n        z_part.mul_assign(tmp);\n        z_part.mul_assign(quotient_challenge);\n\n        rhs.sub_assign(z_part);\n\n        quotient_challenge.mul_assign(state.alpha);\n\n        tmp.assign(state.cached_lagrange_evals[0]);\n        tmp.mul_assign(quotient_challenge);\n\n        rhs.sub_assign(tmp);\n\n        return lhs.value == rhs.value;\n    }\n\n    function reconstruct_d(\n        PartialVerifierStateOld memory state,\n        ProofOld memory proof,\n        VerificationKeyOld memory vk\n    ) internal view returns (PairingsBn254.G1Point memory res) {\n        // we compute what power of v is used as a delinearization factor in batch opening of\n        // commitments. Let's label W(x) = 1 / (x - z) *\n        // [\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\n        // + v (r(x) - r(z))\n        // + v^{2..5} * (witness(x) - witness(z))\n        // + v^(6..8) * (permutation(x) - permutation(z))\n        // ]\n        // W'(x) = 1 / (x - z*omega) *\n        // [\n        // + v^9 (z(x) - z(z*omega)) <- we need this power\n        // + v^10 * (d(x) - d(z*omega))\n        // ]\n        //\n        // we pay a little for a few arithmetic operations to not introduce another constant\n        uint256 power_for_z_omega_opening = 1 + 1 + STATE_WIDTH_OLD + STATE_WIDTH_OLD - 1;\n        res = PairingsBn254.copy_g1(vk.selector_commitments[STATE_WIDTH_OLD + 1]);\n\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\n\n        // addition gates\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\n            tmp_g1 = vk.selector_commitments[i].point_mul(proof.wire_values_at_z[i]);\n            res.point_add_assign(tmp_g1);\n        }\n\n        // multiplication gate\n        tmp_fr.assign(proof.wire_values_at_z[0]);\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\n        tmp_g1 = vk.selector_commitments[STATE_WIDTH_OLD].point_mul(tmp_fr);\n        res.point_add_assign(tmp_g1);\n\n        // d_next\n        tmp_g1 = vk.next_step_selector_commitments[0].point_mul(proof.wire_values_at_z_omega[0]);\n        res.point_add_assign(tmp_g1);\n\n        // z * non_res * beta + gamma + a\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\n        grand_product_part_at_z.mul_assign(state.beta);\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\n        grand_product_part_at_z.add_assign(state.gamma);\n        for (uint256 i = 0; i < vk.permutation_non_residues.length; i++) {\n            tmp_fr.assign(state.z);\n            tmp_fr.mul_assign(vk.permutation_non_residues[i]);\n            tmp_fr.mul_assign(state.beta);\n            tmp_fr.add_assign(state.gamma);\n            tmp_fr.add_assign(proof.wire_values_at_z[i + 1]);\n\n            grand_product_part_at_z.mul_assign(tmp_fr);\n        }\n\n        grand_product_part_at_z.mul_assign(state.alpha);\n\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\n        tmp_fr.mul_assign(state.alpha);\n        tmp_fr.mul_assign(state.alpha);\n\n        grand_product_part_at_z.add_assign(tmp_fr);\n\n        PairingsBn254.Fr memory grand_product_part_at_z_omega = state.v.pow(power_for_z_omega_opening);\n        grand_product_part_at_z_omega.mul_assign(state.u);\n\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            tmp_fr.assign(state.beta);\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\n            tmp_fr.add_assign(state.gamma);\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\n\n            last_permutation_part_at_z.mul_assign(tmp_fr);\n        }\n\n        last_permutation_part_at_z.mul_assign(state.beta);\n        last_permutation_part_at_z.mul_assign(proof.grand_product_at_z_omega);\n        last_permutation_part_at_z.mul_assign(state.alpha);\n\n        // add to the linearization\n        tmp_g1 = proof.grand_product_commitment.point_mul(grand_product_part_at_z);\n        tmp_g1.point_sub_assign(vk.permutation_commitments[STATE_WIDTH_OLD - 1].point_mul(last_permutation_part_at_z));\n\n        res.point_add_assign(tmp_g1);\n        res.point_mul_assign(state.v);\n\n        res.point_add_assign(proof.grand_product_commitment.point_mul(grand_product_part_at_z_omega));\n    }\n\n    function verify_commitments(\n        PartialVerifierStateOld memory state,\n        ProofOld memory proof,\n        VerificationKeyOld memory vk\n    ) internal view returns (bool) {\n        PairingsBn254.G1Point memory d = reconstruct_d(state, proof, vk);\n\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\n\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\n\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\n\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\n        for (uint256 i = 1; i < proof.quotient_poly_commitments.length; i++) {\n            tmp_fr.mul_assign(z_in_domain_size);\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\n            commitment_aggregation.point_add_assign(tmp_g1);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n        commitment_aggregation.point_add_assign(d);\n\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\n            aggregation_challenge.mul_assign(state.v);\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\n            commitment_aggregation.point_add_assign(tmp_g1);\n        }\n\n        for (uint256 i = 0; i < vk.permutation_commitments.length - 1; i++) {\n            aggregation_challenge.mul_assign(state.v);\n            tmp_g1 = vk.permutation_commitments[i].point_mul(aggregation_challenge);\n            commitment_aggregation.point_add_assign(tmp_g1);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n\n        aggregation_challenge.mul_assign(state.v);\n\n        tmp_fr.assign(aggregation_challenge);\n        tmp_fr.mul_assign(state.u);\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH_OLD - 1].point_mul(tmp_fr);\n        commitment_aggregation.point_add_assign(tmp_g1);\n\n        // collect opening values\n        aggregation_challenge = PairingsBn254.new_fr(1);\n\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\n\n        aggregation_challenge.mul_assign(state.v);\n\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\n        tmp_fr.mul_assign(aggregation_challenge);\n        aggregated_value.add_assign(tmp_fr);\n\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\n            aggregation_challenge.mul_assign(state.v);\n\n            tmp_fr.assign(proof.wire_values_at_z[i]);\n            tmp_fr.mul_assign(aggregation_challenge);\n            aggregated_value.add_assign(tmp_fr);\n        }\n\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            aggregation_challenge.mul_assign(state.v);\n\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\n            tmp_fr.mul_assign(aggregation_challenge);\n            aggregated_value.add_assign(tmp_fr);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n\n        tmp_fr.assign(proof.grand_product_at_z_omega);\n        tmp_fr.mul_assign(aggregation_challenge);\n        tmp_fr.mul_assign(state.u);\n        aggregated_value.add_assign(tmp_fr);\n\n        aggregation_challenge.mul_assign(state.v);\n\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\n        tmp_fr.mul_assign(aggregation_challenge);\n        tmp_fr.mul_assign(state.u);\n        aggregated_value.add_assign(tmp_fr);\n\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\n\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\n\n        tmp_fr.assign(state.z);\n        tmp_fr.mul_assign(vk.omega);\n        tmp_fr.mul_assign(state.u);\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\n\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\n        pair_with_x.negate();\n\n        return PairingsBn254.pairingProd2(pair_with_generator, PairingsBn254.P2(), pair_with_x, vk.g2_x);\n    }\n\n    function verify_initial(\n        PartialVerifierStateOld memory state,\n        ProofOld memory proof,\n        VerificationKeyOld memory vk\n    ) internal view returns (bool) {\n        require(proof.input_values.length == vk.num_inputs);\n        require(vk.num_inputs >= 1);\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\n            transcript.update_with_u256(proof.input_values[i]);\n        }\n\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\n            transcript.update_with_g1(proof.wire_commitments[i]);\n        }\n\n        state.beta = transcript.get_challenge();\n        state.gamma = transcript.get_challenge();\n\n        transcript.update_with_g1(proof.grand_product_commitment);\n        state.alpha = transcript.get_challenge();\n\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\n        }\n\n        state.z = transcript.get_challenge();\n\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i++) {\n            lagrange_poly_numbers[i] = i;\n        }\n\n        state.cached_lagrange_evals = batch_evaluate_lagrange_poly_out_of_domain_old(\n            lagrange_poly_numbers,\n            vk.domain_size,\n            vk.omega,\n            state.z\n        );\n\n        bool valid = verify_at_z(state, proof, vk);\n\n        if (valid == false) {\n            return false;\n        }\n\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\n        }\n\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\n        }\n\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\n        }\n\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\n        transcript.update_with_fr(proof.grand_product_at_z_omega);\n\n        state.v = transcript.get_challenge();\n        transcript.update_with_g1(proof.opening_at_z_proof);\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\n        state.u = transcript.get_challenge();\n\n        return true;\n    }\n\n    // This verifier is for a PLONK with a state width 4\n    // and main gate equation\n    // q_a(X) * a(X) +\n    // q_b(X) * b(X) +\n    // q_c(X) * c(X) +\n    // q_d(X) * d(X) +\n    // q_m(X) * a(X) * b(X) +\n    // q_constants(X)+\n    // q_d_next(X) * d(X*omega)\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\n    // q_d_next(X) \"peeks\" into the next row of the trace, so it takes\n    // the same d(X) polynomial, but shifted\n\n    function verify_old(ProofOld memory proof, VerificationKeyOld memory vk) internal view returns (bool) {\n        PartialVerifierStateOld memory state;\n\n        bool valid = verify_initial(state, proof, vk);\n\n        if (valid == false) {\n            return false;\n        }\n\n        valid = verify_commitments(state, proof, vk);\n\n        return valid;\n    }\n}\n\ncontract VerifierWithDeserializeOld is Plonk4VerifierWithAccessToDNextOld {\n    uint256 constant SERIALIZED_PROOF_LENGTH_OLD = 33;\n\n    function deserialize_proof_old(uint256[] memory public_inputs, uint256[] memory serialized_proof)\n        internal\n        pure\n        returns (ProofOld memory proof)\n    {\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH_OLD);\n        proof.input_values = new uint256[](public_inputs.length);\n        for (uint256 i = 0; i < public_inputs.length; i++) {\n            proof.input_values[i] = public_inputs[i];\n        }\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\n\n            j += 2;\n        }\n\n        proof.grand_product_commitment = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\n        j += 2;\n\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\n                serialized_proof[j],\n                serialized_proof[j + 1]\n            );\n\n            j += 2;\n        }\n\n        for (uint256 i = 0; i < STATE_WIDTH_OLD; i++) {\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j += 1;\n        }\n\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j += 1;\n        }\n\n        proof.grand_product_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j += 1;\n\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j += 1;\n\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j += 1;\n\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j += 1;\n        }\n\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\n        j += 2;\n\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(serialized_proof[j], serialized_proof[j + 1]);\n    }\n}\n"},"contracts/ReentrancyGuard.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    /// @dev Address of lock flag variable.\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256(\"ReentrancyGuard\") - 1;\n\n    function initializeReentrancyGuard() internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, 1)\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        bool notEntered;\n        assembly {\n            notEntered := sload(LOCK_FLAG_ADDRESS)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(notEntered, \"1b\");\n\n        // Any calls to nonReentrant after this point will fail\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, 0)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, 1)\n        }\n    }\n}\n"},"contracts/SafeCast.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and then downcasting.\n *\n * _Available since v2.5.0._\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"16\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"17\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"18\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"19\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"1a\");\n        return uint8(value);\n    }\n}\n"},"contracts/SafeMath.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"14\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"v\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"15\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"x\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"y\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"contracts/SafeMathUInt128.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUInt128 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\n        uint128 c = a + b;\n        require(c >= a, \"12\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        return sub(a, b, \"aa\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(\n        uint128 a,\n        uint128 b,\n        string memory errorMessage\n    ) internal pure returns (uint128) {\n        require(b <= a, errorMessage);\n        uint128 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint128 a, uint128 b) internal pure returns (uint128) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint128 c = a * b;\n        require(c / a == b, \"13\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint128 a, uint128 b) internal pure returns (uint128) {\n        return div(a, b, \"ac\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(\n        uint128 a,\n        uint128 b,\n        string memory errorMessage\n    ) internal pure returns (uint128) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint128 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint128 a, uint128 b) internal pure returns (uint128) {\n        return mod(a, b, \"ad\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(\n        uint128 a,\n        uint128 b,\n        string memory errorMessage\n    ) internal pure returns (uint128) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"contracts/Storage.sol":{"content":"pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n\n\nimport \"./IERC20.sol\";\n\nimport \"./Governance.sol\";\nimport \"./Verifier.sol\";\nimport \"./Operations.sol\";\n\n/// @title zkTube storage contract\n/// @author Zktube Labs\ncontract Storage {\n    /// @dev Flag indicates that upgrade preparation status is active\n    /// @dev Will store false in case of not active upgrade mode\n    bool internal upgradePreparationActive;\n\n    /// @dev Upgrade preparation activation timestamp (as seconds since unix epoch)\n    /// @dev Will be equal to zero in case of not active upgrade mode\n    uint256 internal upgradePreparationActivationTime;\n\n    /// @dev Verifier contract. Used to verify block proof and exit proof\n    Verifier public verifier;\n\n    /// @dev Governance contract. Contains the governor (the owner) of whole system, validators list, possible tokens list\n    Man public man;\n\n    uint8 internal constant FILLED_GAS_RESERVE_VALUE = 0xff; // we use it to set gas revert value so slot will not be emptied with 0 balance\n    struct PendingBalance {\n        uint128 balanceToWithdraw;\n        uint8 gasReserveValue; // gives user opportunity to fill storage slot with nonzero value\n    }\n\n    /// @dev Root-chain balances (per owner and token id, see packAddressAndTokenId) to withdraw\n    mapping(bytes22 => PendingBalance) internal pendingBalances;\n\n    // @dev Pending withdrawals are not used in this version\n    struct PendingWithdrawal_DEPRECATED {\n        address to;\n        uint16 tokenId;\n    }\n    mapping(uint32 => PendingWithdrawal_DEPRECATED) internal pendingWithdrawals_DEPRECATED;\n    uint32 internal firstPendingWithdrawalIndex_DEPRECATED;\n    uint32 internal numberOfPendingWithdrawals_DEPRECATED;\n\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint32 public totalBlocksExecuted;\n\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint32 public totalBlocksCommitted;\n\n    /// @Old rollup block stored data - not used in current version\n    /// @member validator Block producer\n    /// @member committedAtBlock ETH block number at which this block was committed\n    /// @member cumulativeOnchainOperations Total number of operations in this and all previous blocks\n    /// @member priorityOperations Total number of priority operations for this block\n    /// @member commitment Hash of the block circuit commitment\n    /// @member stateRoot New tree root hash\n    ///\n    /// Consider memory alignment when changing field order: https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html\n    struct Block_DEPRECATED {\n        uint32 committedAtBlock;\n        uint64 priorityOperations;\n        uint32 chunks;\n        bytes32 withdrawalsDataHash; // can be restricted to 16 bytes to reduce number of required storage slots\n        bytes32 commitment;\n        bytes32 stateRoot;\n    }\n    mapping(uint32 => Block_DEPRECATED) internal blocks_DEPRECATED;\n\n    /// @notice Flag indicates that a user has exited in the exodus mode certain token balance (per account id and tokenId)\n    mapping(uint32 => mapping(uint16 => bool)) public performedExodus;\n\n    /// @notice Flag indicates that exodus (mass exit) mode is triggered\n    /// @notice Once it was raised, it can not be cleared again, and all users must exit\n    bool public exodusMode;\n\n    /// @notice User authenticated fact hashes for some nonce.\n    mapping(address => mapping(uint32 => bytes32)) public authFacts;\n\n    /// @notice Old Priority Operation container\n    /// @member opType Priority operation type\n    /// @member pubData Priority operation public data\n    /// @member expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\n    struct PriorityOperation_DEPRECATED {\n        Operations.OpType opType;\n        bytes pubData;\n        uint256 expirationBlock;\n    }\n\n    /// @dev Priority Requests mapping (request id - operation)\n    /// @dev Contains op type, pubdata and expiration block of unsatisfied requests.\n    /// @dev Numbers are in order of requests receiving\n    mapping(uint64 => PriorityOperation_DEPRECATED) internal priorityRequests_DEPRECATED;\n\n    /// @notice First open priority request id\n    uint64 public firstPriorityRequestId;\n\n    /// @notice Total number of requests\n    uint64 public totalOpenPriorityRequests;\n\n    /// @notice Total number of committed requests.\n    /// @dev Used in checks: if the request matches the operation on Rollup contract and if provided number of requests is not too big\n    uint64 public totalCommittedPriorityRequests;\n\n    /// @notice Packs address and token id into single word to use as a key in balances mapping\n    function packAddressAndTokenId(address _address, uint16 _tokenId) internal pure returns (bytes22) {\n        return bytes22((uint176(_address) | (uint176(_tokenId) << 160)));\n    }\n\n    /// @Rollup block stored data\n    /// @member blockNumber Rollup block number\n    /// @member priorityOperations Number of priority operations processed\n    /// @member pendingOnchainOperationsHash Hash of all operations that must be processed after verify\n    /// @member timestamp Rollup block timestamp, have the same format as Ethereum block constant\n    /// @member stateHash Root hash of the rollup state\n    /// @member commitment Verified input for the zkTube circuit\n    struct StoredBlockInfo {\n        uint32 blockNumber;\n        uint64 priorityOperations;\n        bytes32 pendingOnchainOperationsHash;\n        uint256 timestamp;\n        bytes32 stateHash;\n        bytes32 commitment;\n    }\n\n    /// @notice Returns the keccak hash of the ABI-encoded StoredBlockInfo\n    function hashStoredBlockInfo(StoredBlockInfo memory _storedBlockInfo) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_storedBlockInfo));\n    }\n\n    /// @dev Stored hashed StoredBlockInfo for some block number\n    mapping(uint32 => bytes32) public storedBlockHashes;\n\n    /// @notice Total blocks proven.\n    uint32 public totalBlocksProven;\n\n    /// @notice Priority Operation container\n    /// @member hashedPubData Hashed priority operation public data\n    /// @member expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\n    /// @member opType Priority operation type\n    struct PriorityOperation {\n        bytes20 hashedPubData;\n        uint64 expirationBlock;\n        Operations.OpType opType;\n    }\n\n    /// @dev Priority Requests mapping (request id - operation)\n    /// @dev Contains op type, pubdata and expiration block of unsatisfied requests.\n    /// @dev Numbers are in order of requests receiving\n    mapping(uint64 => PriorityOperation) public priorityRequests;\n\n    /// @dev Timer for authFacts entry reset (address, nonce -> timer).\n    /// @dev Used when user wants to reset `authFacts` for some nonce.\n    mapping(address => mapping(uint32 => uint256)) internal authFactsResetTimer;\n}\n"},"contracts/Upgradeable.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/// @title Interface of the upgradeable contract\n/// @author Zktube Labs\ninterface Upgradeable {\n    /// @notice Upgrades target of upgradeable contract\n    /// @param newTarget New target\n    /// @param newTargetInitializationParameters New target initialization parameters\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\n}\n"},"contracts/UpgradeableMaster.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\n/// @author Zktube Labs\ninterface UpgradeableMaster {\n    /// @notice Notice period before activation preparation status of upgrade mode\n    function getNoticePeriod() external returns (uint256);\n\n    /// @notice Notifies contract that notice period started\n    function upgradeNoticePeriodStarted() external;\n\n    /// @notice Notifies contract that upgrade preparation status is activated\n    function upgradePreparationStarted() external;\n\n    /// @notice Notifies contract that upgrade canceled\n    function upgradeCanceled() external;\n\n    /// @notice Notifies contract that upgrade finishes\n    function upgradeFinishes() external;\n\n    /// @notice Checks that contract is ready for upgrade\n    /// @return bool flag indicating that contract is ready for upgrade\n    function isReadyForUpgrade() external returns (bool);\n}\n"},"contracts/Utils.sol":{"content":"pragma solidity ^0.7.0;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\nimport \"./IERC20.sol\";\nimport \"./Bytes.sol\";\n\nlibrary Utils {\n    /// @notice Returns lesser of two values\n    function minU32(uint32 a, uint32 b) internal pure returns (uint32) {\n        return a < b ? a : b;\n    }\n\n    /// @notice Returns lesser of two values\n    function minU64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a < b ? a : b;\n    }\n\n    /// @notice Sends tokens\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\n    /// @dev NOTE: call `transfer` to this token may return (bool) or nothing\n    /// @param _token Token address\n    /// @param _to Address of recipient\n    /// @param _amount Amount of tokens to transfer\n    /// @return bool flag indicating that transfer is successful\n    function sendERC20(\n        IERC20 _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (bool) {\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\n            address(_token).call(abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _amount));\n        // `transfer` method may return (bool) or nothing.\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\n        return callSuccess && returnedSuccess;\n    }\n\n    /// @notice Transfers token from one address to another\n    /// @dev NOTE: this function handles tokens that have transfer function not strictly compatible with ERC20 standard\n    /// @dev NOTE: call `transferFrom` to this token may return (bool) or nothing\n    /// @param _token Token address\n    /// @param _from Address of sender\n    /// @param _to Address of recipient\n    /// @param _amount Amount of tokens to transfer\n    /// @return bool flag indicating that transfer is successful\n    function transferFromERC20(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal returns (bool) {\n        (bool callSuccess, bytes memory callReturnValueEncoded) =\n            address(_token).call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _from, _to, _amount));\n        // `transferFrom` method may return (bool) or nothing.\n        bool returnedSuccess = callReturnValueEncoded.length == 0 || abi.decode(callReturnValueEncoded, (bool));\n        return callSuccess && returnedSuccess;\n    }\n\n    /// @notice Recovers signer's address from ethereum signature for given message\n    /// @param _signature 65 bytes concatenated. R (32) + S (32) + V (1)\n    /// @param _messageHash signed message hash.\n    /// @return address of the signer\n    function recoverAddressFromEthSignature(bytes memory _signature, bytes32 _messageHash)\n        internal\n        pure\n        returns (address)\n    {\n        require(_signature.length == 65, \"P\"); // incorrect signature length\n\n        bytes32 signR;\n        bytes32 signS;\n        uint8 signV;\n        assembly {\n            signR := mload(add(_signature, 32))\n            signS := mload(add(_signature, 64))\n            signV := byte(0, mload(add(_signature, 96)))\n        }\n\n        return ecrecover(_messageHash, signV, signR, signS);\n    }\n\n    /// @notice Returns new_hash = hash(old_hash + bytes)\n    function concatHash(bytes32 _hash, bytes memory _bytes) internal pure returns (bytes32) {\n        bytes32 result;\n        assembly {\n            let bytesLen := add(mload(_bytes), 32)\n            mstore(_bytes, _hash)\n            result := keccak256(_bytes, bytesLen)\n        }\n        return result;\n    }\n\n    function hashBytesToBytes20(bytes memory _bytes) internal pure returns (bytes20) {\n        return bytes20(uint160(uint256(keccak256(_bytes))));\n    }\n}\n"},"contracts/Verifier.sol":{"content":"pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\n\n\n\nimport \"./KeysWithPlonkVerifier.sol\";\nimport \"./Config.sol\";\n\n// Hardcoded constants to avoid accessing store\ncontract Verifier is KeysWithPlonkVerifier, KeysWithPlonkVerifierOld, Config {\n    function initialize(bytes calldata) external {}\n\n    /// @notice Verifier contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\n    /// @param upgradeParameters Encoded representation of upgrade parameters\n    function upgrade(bytes calldata upgradeParameters) external {}\n\n    /// by demon\n\tfunction verxx() external{}\n\n    function verifyAggregatedBlockProof(\n        uint256[] memory _recursiveInput,\n        uint256[] memory _proof,\n        uint8[] memory _vkIndexes,\n        uint256[] memory _individual_vks_inputs,\n        uint256[16] memory _subproofs_limbs\n    ) external view returns (bool) {\n        for (uint256 i = 0; i < _individual_vks_inputs.length; ++i) {\n            uint256 commitment = _individual_vks_inputs[i];\n            _individual_vks_inputs[i] = commitment & INPUT_MASK;\n        }\n        VerificationKey memory vk = getVkAggregated(uint32(_vkIndexes.length));\n\n        return\n            verify_serialized_proof_with_recursion(\n                _recursiveInput,\n                _proof,\n                VK_TREE_ROOT,\n                VK_MAX_INDEX,\n                _vkIndexes,\n                _individual_vks_inputs,\n                _subproofs_limbs,\n                vk\n            );\n    }\n\n    function verifyExitProof(\n        bytes32 _rootHash,\n        uint32 _accountId,\n        address _owner,\n        uint16 _tokenId,\n        uint128 _amount,\n        uint256[] calldata _proof\n    ) external view returns (bool) {\n        bytes32 commitment = sha256(abi.encodePacked(_rootHash, _accountId, _owner, _tokenId, _amount));\n\n        uint256[] memory inputs = new uint256[](1);\n        inputs[0] = uint256(commitment) & INPUT_MASK;\n        ProofOld memory proof = deserialize_proof_old(inputs, _proof);\n        VerificationKeyOld memory vk = getVkExit();\n        require(vk.num_inputs == inputs.length);\n        return verify_old(proof, vk);\n    }\n}\n"}}}