{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/VNFTMulti.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n      \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IChiToken {\n\n    function balanceOf(address account) external view returns (uint256);\n    \n    function freeUpTo(uint256 value) external returns (uint256 freed);\n    \n    function freeFromUpTo(address from, uint256 value)\n        external\n        returns (uint256 freed);\n}\n\ninterface IVNFT {\n    function fatality(uint256 _deadId, uint256 _tokenId) external;\n    function buyAccesory(uint256 nftId, uint256 itemId) external;\n    function claimMiningRewards(uint256 nftId) external;\n    function addCareTaker(uint256 _tokenId, address _careTaker) external;\n    function careTaker(uint256 _tokenId, address _user)\n        external\n        view\n        returns (address _careTaker);\n    function ownerOf(uint256 _tokenId) external view returns (address _owner);\n    function itemPrice(uint256 itemId) external view returns (uint256 _amount);\n}\n\ncontract VNFTMulti {\n\n    IVNFT public vnft;\n    IERC20 public muse;\n    IChiToken public constant chi = IChiToken(\n        0x0000000000004946c0e9F43F4Dee607b0eF1fA1c\n    );\n    \n    address public owner;\n    bool public paused;\n    \n    constructor(IVNFT _vnft, IERC20 _muse) public {\n        vnft = _vnft;\n        muse = _muse;\n        owner = msg.sender;\n    }\n    \n    modifier notPaused() {\n        require(!paused, \"PAUSED\");\n        _;\n    }\n    \n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Only owner can call this function\");\n        _;\n    }\n    \n    modifier discountCHI(bool shouldBurn) {\n        uint256 gasStart = gasleft();\n        _;\n    \n        if(shouldBurn){\n              uint256 tokensToBurn = (21000 +\n                    (gasStart - gasleft()) +\n                    16 *\n                    msg.data.length +\n                    14154) / 41947;\n    \n             if (chi.balanceOf(address(this)) > 0)\n                    chi.freeUpTo(tokensToBurn);\n                    //if not, try to burn from the users own wallet\n              else chi.freeFromUpTo(msg.sender, tokensToBurn);\n        }\n    }\n\n    function claimMultiple(uint256[] calldata ids, bool shouldBurn) \n        external \n        notPaused \n        discountCHI(shouldBurn)\n    {\n        for (uint256 i = 0; i < ids.length; i++) {\n              require(vnft.ownerOf(ids[i]) == msg.sender, \"Only owner of VNFT can claim\");\n              vnft.claimMiningRewards(ids[i]);\n        }\n        require(muse.transfer(msg.sender, muse.balanceOf(address(this))));\n    }\n    \n    function feedMultiple(uint museCost, uint256[] calldata ids, uint256[] calldata itemIds, bool shouldBurn)\n        external\n        notPaused\n        discountCHI(shouldBurn)\n    {\n        require(\n              muse.transferFrom(msg.sender, address(this), museCost),\n              \"Not enough muse to Feed\"\n        );\n        for (uint256 i = 0; i < ids.length; i++) {\n              vnft.buyAccesory(ids[i], itemIds[i]);\n        }\n    }\n\n    function claimAndFeed(uint256[] calldata ids, uint256[] calldata itemIds, bool shouldBurn) \n        external \n        notPaused \n        discountCHI(shouldBurn)\n    {\n        for (uint256 i = 0; i < ids.length; i++) {\n        require(vnft.ownerOf(ids[i]) == msg.sender, \"Only owner of VNFT can claim\");\n              vnft.claimMiningRewards(ids[i]);\n        }\n    for (uint256 i = 0; i < ids.length; i++) {\n              vnft.buyAccesory(ids[i], itemIds[i]);\n        }\n        require(muse.transfer(msg.sender, muse.balanceOf(address(this))));\n    }\n    \n    function setVNFT(IVNFT _vnft) public onlyOwner {\n        vnft = _vnft;\n    }\n    \n    function setMUSE(IERC20 _muse) public onlyOwner {\n        muse = _muse;\n    }\n    \n    function setPause(bool _paused) public onlyOwner {\n        paused = _paused;\n    }\n    \n    function approveContractMax() public onlyOwner {\n        require(muse.approve(address(vnft), uint(-1)), \"MUSE:approve\");\n    }\n    \n    function withdraw(IERC20 token) public onlyOwner{\n        require(token.transfer(msg.sender, token.balanceOf(address(this))));\n    }\n}"}}}