{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RBTStake.sol":{"content":"pragma solidity ^0.6.0;\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256 r) {\r\n        require(m != 0, \"SafeMath: to ceil number shall not be zero\");\r\n        return (a + m - 1) / m * m;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\ncontract RBTStake is Owned{\r\n    using SafeMath for uint256;\r\n    \r\n    address private saleContract;\r\n    address private tokenAddress;\r\n    \r\n    uint256 public rewardClaimDate; // will be set by sale contract once cliff is started there\r\n    uint256 public cliffPeriodStarted;\r\n    \r\n    event SaleContractSet(address by, address saleAddress);\r\n    event UserTokensStaked(address by, address user, uint256 tokensPurchased);\r\n    event RewardClaimDateSet(address by, uint256 rewardClaimDate);\r\n    event RewardsClaimed(address by, uint256 rewards);\r\n    \r\n    struct StakedTokens{\r\n        uint256 tokens;\r\n        uint256 stakeDate;\r\n    }\r\n    \r\n    mapping(address => StakedTokens) public purchasedRBT;\r\n    mapping(address => uint256) public rewardRBT;\r\n    \r\n    modifier onlySaleContract{\r\n        require(msg.sender == saleContract, \"UnAuthorized\");\r\n        _;\r\n    }\r\n    \r\n    modifier isPurchaser{\r\n        require(purchasedRBT[msg.sender].tokens > 0 , \"UnAuthorized\");\r\n        _;\r\n    }\r\n    \r\n    modifier isClaimable{\r\n        require(block.timestamp >= rewardClaimDate, \"reward claim date has not reached\");\r\n        require(rewardClaimDate > 0, \"cannot claim reward. cliff period has not started\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address _tokenAddress) public{\r\n        tokenAddress = _tokenAddress;\r\n    }\r\n    \r\n    function SetSaleContract(address _saleContract) external onlyOwner{\r\n        require(_saleContract != address(0), \"Invalid address\");\r\n        require(saleContract == address(0), \"address already set\");\r\n        \r\n        saleContract = _saleContract;\r\n        \r\n        emit SaleContractSet(msg.sender, _saleContract);\r\n    }\r\n    \r\n    function StakeTokens(address _ofUser, uint256 _tokens) external onlySaleContract returns(bool){\r\n        purchasedRBT[_ofUser].tokens = purchasedRBT[_ofUser].tokens.add(_tokens);\r\n        purchasedRBT[_ofUser].stakeDate = block.timestamp;\r\n        emit UserTokensStaked(msg.sender, _ofUser, _tokens);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function SetRewardClaimDate(uint256 _rewardClaimDate) external onlySaleContract returns(bool){\r\n        rewardClaimDate = _rewardClaimDate;\r\n        cliffPeriodStarted = block.timestamp;\r\n        RewardClaimDateSet(msg.sender, _rewardClaimDate);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function ClaimReward() external isPurchaser isClaimable {\r\n        uint256 rewards = _calculateReward(cliffPeriodStarted, msg.sender);\r\n        require(rewards > 0, \"nothing pending to be claimed\");\r\n        require(rewardRBT[msg.sender] == 0, \"already claimed\");\r\n        \r\n        rewardRBT[msg.sender] = rewards;\r\n        \r\n        IERC20(tokenAddress).transfer(msg.sender, rewards);\r\n        \r\n        emit RewardsClaimed(msg.sender, rewards);\r\n    }\r\n    \r\n    function _calculateReward(uint256 toDate, address _user) internal view returns(uint256) {\r\n        uint256 totalStakeTime = (toDate.sub(purchasedRBT[_user].stakeDate)).div(1 days); // in days\r\n        uint256 rewardsAvailable = (totalStakeTime.mul(30).mul(purchasedRBT[_user].tokens)).div(365 * 100); // to take percentage div by 100\r\n        return  rewardsAvailable;\r\n    }\r\n    \r\n    function pendingReward(address _user) external view returns(uint256){\r\n        uint256 reward;\r\n        if(block.timestamp > cliffPeriodStarted && cliffPeriodStarted > 0)\r\n            reward =  _calculateReward(cliffPeriodStarted, _user); \r\n        else\r\n            reward = _calculateReward(block.timestamp, _user);\r\n        return reward.sub(rewardRBT[_user]);\r\n    }\r\n    \r\n    function isRewardClaimable() external view returns(bool){\r\n        return (block.timestamp >= rewardClaimDate && rewardClaimDate != 0);\r\n    }\r\n    \r\n    function getBackExtraTokens() external onlyOwner{\r\n        uint256 tokens = IERC20(tokenAddress).balanceOf(address(this));\r\n        require(IERC20(tokenAddress).transfer(owner, tokens), \"No tokens in contract\");\r\n    }\r\n    \r\n}"}}}