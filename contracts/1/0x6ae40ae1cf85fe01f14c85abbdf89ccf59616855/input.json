{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "oms/OraclePrice.sol": {
      "content": "// File: contracts/v6/interface/KeeperCompatibleInterface.sol\n\n// SPDX-License-Identifier: Unlicensed\npragma solidity =0.6.12;\n\ninterface KeeperCompatibleInterface {\n\n  /**\n   * @notice checks if the contract requires work to be done.\n   * @param checkData data passed to the contract when checking for upkeep.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with,\n   * if upkeep is needed.\n   */\n  function checkUpkeep(\n    bytes calldata checkData\n  )\n    external\n    returns (\n      bool upkeepNeeded,\n      bytes memory performData\n    );\n\n  /**\n   * @notice Performs work on the contract. Executed by the keepers, via the registry.\n   * @param performData is the data which was passed back from the checkData\n   * simulation.\n   */\n  function performUpkeep(\n    bytes calldata performData\n  ) external;\n}\n\n// File: contracts/v6/interface/IOmsPolicy.sol\n\npragma solidity =0.6.12;\n\ninterface IOmsPolicy {\n    function setTargetPrice(uint256 _targetPrice) external;\n    function targetPrice() external view returns (uint256);\n}\n\n// File: contracts/v6/interface/EACAggregatorProxy.sol\n\npragma solidity =0.6.12;\n\ninterface EACAggregatorProxy {\n    function latestAnswer() external view returns (int256); \n    function decimals() external view returns (uint8);\n}\n\n// File: contracts/v6/library/SafeMath.sol\n\npragma solidity =0.6.12;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n \nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/v6/common/Context.sol\n\npragma solidity =0.6.12;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: contracts/v6/common/Ownable.sol\n\npragma solidity =0.6.12;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n    address private _previousOwner;\n    uint256 private _lockTime;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n     /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/v6/OraclePrice.sol\n\npragma solidity =0.6.12;\npragma experimental ABIEncoderV2;\n\n\n\n\n\n\ncontract OraclePrice is Ownable, KeeperCompatibleInterface {\n    using SafeMath for uint256;\n\n    struct PriceLog {\n        int256 lastUpdatedPrice;\n    }\n\n    struct AverageLog {\n        int256 averageMovement;\n        int256 referenceRate;\n    }\n\n    struct OracleInfo {\n        address oracleAddress;\n        bool isActive;\n        bytes32 symbolHash;\n        int256 lastPrice; \n    }\n    \n    event LogTargetPriceUpdated(uint256 indexed performUpkeepCycle, uint256 timestampSec, int256 averageMovement, uint256 oldReferenceRate, uint256 newReferenceRate);\n    event LogReferenceRateDataUsed(uint256 indexed performUpkeepCycle, uint256 timestampSec, address oracleAddress, int256 oldPrice, int256 newPrice);\n\n    // Storing all the details of oracle address\n    OracleInfo[] public oracleInfo;\n\n    // OmsPolicy contract address\n    address public policyContract;\n\n    // More than this much time must pass between keepers operations.\n    uint public immutable interval;\n\n    // Block timestamp of last Keepers operations.\n    uint public lastTimeStamp;\n\n    // The number of keepers cycles since inception\n    uint public counter;\n\n    // PriceLog represents last price of each currency\n    mapping (address => PriceLog) public priceLog;\n\n    // AverageLog represents last average and ref rate of currency\n    AverageLog public averageLog;\n    \n    constructor(OracleInfo[] memory _oracles, address _policyContract, uint _updateInterval) public {\n        policyContract = _policyContract;\n        \n        for(uint256 i=0; i<_oracles.length; i++) {\n            OracleInfo memory oracle = _oracles[i];\n            oracleInfo.push(OracleInfo({\n                oracleAddress: oracle.oracleAddress,\n                isActive: oracle.isActive,\n                symbolHash: oracle.symbolHash,\n                lastPrice: 0\n            }));\n        }\n\n        interval = _updateInterval;\n        lastTimeStamp = 0;\n        counter = 0;\n    }\n\n    function getOracleInfoCount() public view returns (uint256) {\n        return oracleInfo.length;\n    }\n    \n    /**\n     * @param _oracleId index number of oracle address.\n     * Fetching updated price of perticular oracles from chainlink. \n     */\n    function getOraclePriceInUsd(uint256 _oracleId) public view returns (int256) {\n        OracleInfo storage oracle = oracleInfo[_oracleId];\n        int256 latestPrice = EACAggregatorProxy(oracle.oracleAddress).latestAnswer();\n        return latestPrice;\n    }\n\n    function checkUpkeep(bytes calldata checkData) external override returns (bool upkeepNeeded, bytes memory performData) {\n        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;\n    }\n\n    function performUpkeep(bytes calldata performData) external override {\n        bool upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;\n        require(upkeepNeeded == true, \"Can Not call this method at this time\");\n\n        lastTimeStamp = block.timestamp;\n        counter = counter + 1;\n\n        updateTargetPrice();\n    }\n\n    // calculate average movement and ReferenceRate from all currency price \n    function calculateReferenceRate() internal returns(uint256) {\n        uint256 oracleInfoCount = oracleInfo.length;\n        \n        int256 sumPrice = 0;\n        int256 decimals = 1e18;\n        uint256 activeOracle = 0;\n        for(uint256 i=0; i<oracleInfoCount; i++) {\n            OracleInfo storage oracle = oracleInfo[i];\n            if(oracle.isActive == true) {\n                PriceLog storage pricelog = priceLog[oracle.oracleAddress];\n                sumPrice = addUnderFlow(sumPrice, divUnderFlow(mulUnderFlow(subUnderFlow(oracle.lastPrice, pricelog.lastUpdatedPrice), 100000), oracle.lastPrice));\n                if(pricelog.lastUpdatedPrice == 0) {\n                    sumPrice = 0;\n                }\n\n                emit LogReferenceRateDataUsed(counter, lastTimeStamp, oracle.oracleAddress, pricelog.lastUpdatedPrice, oracle.lastPrice);\n                \n                pricelog.lastUpdatedPrice = oracle.lastPrice;\n                activeOracle = activeOracle.add(1);\n            }\n        }\n\n        int256 avgMovement = divUnderFlow(sumPrice, int256(activeOracle));\n        if(averageLog.referenceRate == 0) {\n            averageLog.referenceRate = decimals;\n        }\n        int256 refRate = divUnderFlow(mulUnderFlow(averageLog.referenceRate, addUnderFlow(decimals, divUnderFlow(mulUnderFlow(decimals, avgMovement), 100000))), decimals);\n\n        averageLog.averageMovement = avgMovement;\n        averageLog.referenceRate = refRate;\n\n        return uint256(refRate);\n    }\n    \n    /**\n     * Fetching updated price from all oracles and calculating ref rate to update \n     * Target price.\n     */\n    function updateTargetPrice() internal {\n        uint256 length = oracleInfo.length;\n        for(uint256 i=0; i<length; i++) {\n            OracleInfo storage oracle = oracleInfo[i];\n            if(oracle.isActive == true) {\n                int256 latestPrice = EACAggregatorProxy(oracle.oracleAddress).latestAnswer();\n                uint8 decimals = EACAggregatorProxy(oracle.oracleAddress).decimals();\n                uint256 restDec = SafeMath.sub(18, uint256(decimals));\n                latestPrice = int256(SafeMath.mul(uint256(latestPrice), 10**restDec));\n                oracle.lastPrice = latestPrice;\n            }\n        }\n    \n        uint256 oldTargetPrice = IOmsPolicy(policyContract).targetPrice();\n        uint256 newTargetPrice = calculateReferenceRate();\n\n        IOmsPolicy(policyContract).setTargetPrice(newTargetPrice);\n        \n        emit LogTargetPriceUpdated(counter, lastTimeStamp, averageLog.averageMovement, oldTargetPrice, newTargetPrice);\n    }\n    \n    /**\n     * @param _pid index number of oracle address.\n     * @param _oracle updated oracle address.\n     * @param _isActive true if oracle is active otherwise inactive.\n     * @param _symbolHash symbolHash of crypto currency.\n     */\n    function updateOracle(uint256 _pid, address _oracle, bool _isActive, bytes32 _symbolHash) public onlyOwner {\n        OracleInfo storage oracle = oracleInfo[_pid];\n        require(oracle.oracleAddress != address(0), \"No Oracle Found\");\n        oracle.oracleAddress = _oracle;\n        oracle.isActive = _isActive;\n        oracle.symbolHash = _symbolHash;\n    }\n\n    /**\n     * @param _oracle new oracle address to add in structure.\n     * @param _isActive true if oracle is active otherwise inactive.\n     * @param _symbolHash symbolHash of crypto currency.\n     */\n    function addOracle(address _oracle, bool _isActive, bytes32 _symbolHash) public onlyOwner {\n        oracleInfo.push(OracleInfo({\n                oracleAddress: _oracle,\n                isActive: _isActive,\n                symbolHash: _symbolHash,\n                lastPrice: 0\n            }));\n    }\n    \n    /**\n     * @param _policy new policy address.\n     */\n    function updatePolicy(address _policy) public onlyOwner {\n        policyContract = _policy;\n    }\n\n    /**\n    * @dev Subtracts two int256 variables.\n    */\n    function subUnderFlow(int256 a, int256 b)\n            internal\n            pure\n            returns (int256)\n    {\n        int256 c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Adds two int256 variables and fails on overflow.\n     */\n    function addUnderFlow(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 c = a + b;\n        return c;\n    }\n\n    /**\n    * @dev Division of two int256 variables and fails on overflow.\n     */\n    function divUnderFlow(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        require(b != 0, \"div overflow\");\n\n        // Solidity already throws when dividing by 0.\n        return a / b;\n    }\n\n    /**\n     * @dev Multiplies two int256 variables and fails on overflow.\n     */\n    function mulUnderFlow(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 c = a * b;\n        return c;\n    }\n}\n"
    }
  }
}