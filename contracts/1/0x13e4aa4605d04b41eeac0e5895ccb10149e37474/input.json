{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/interfaces/v3pool.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n\n}\n"},"contracts/inxtarb.sol":{"content":"pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './interfaces/v3pool.sol';\r\n\r\ninterface IWETH {\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\n\r\ninterface swapcontract{\r\n    function swap(uint256 _amount) external;\r\n}\r\n\r\n\r\ninterface v3quoter{\r\n  function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountOut);\r\n}\r\n\r\n\r\ninterface auth{\r\n    function checkauth() external;\r\n}\r\n\r\ncontract inxtarb {\r\n\r\n    address payable public owner;\r\n\r\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\r\n    \r\n    v3quoter quoter = v3quoter(quoter_addr);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        \r\n        IERC20(address(0xa8006C4ca56F24d6836727D106349320dB7fEF82)).approve(address(0xD09fA188c6F2a3b0eA6C3533E8C54d539c097337), \r\n                    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n    }\r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n    \r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n    function approvetoken(address token, address target) external onlyowner{\r\n        IERC20(token).approve(target, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n    }\r\n\r\n\r\n\r\n\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata _data\r\n    ) external {\r\n        \r\n\r\n        if(msg.sender == address(0x6F7328C2188B0A61c6d76165C272B8cB2DbC2f94)){\r\n\r\n            // swap old token to new token\r\n            swapcontract(address(0xD09fA188c6F2a3b0eA6C3533E8C54d539c097337)).swap(uint256(-amount0Delta));\r\n\r\n            // sell the new token\r\n            v3pool(address(0xb79376C03E654FeDE2f6530F0cEB81d2408482db)).swap(address(this), true, int256(-amount0Delta), \r\n            4295128739 + 1, _data);\r\n\r\n        }\r\n\r\n\r\n        if(msg.sender == address(0xb79376C03E654FeDE2f6530F0cEB81d2408482db)){\r\n            (uint256 wethin, uint256 minbenefit, address authcontract) = abi.decode(_data, (uint256, uint256, address));\r\n\r\n            uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n\r\n            if(minbenefit != 0){\r\n                require(weth_balance >= wethin + minbenefit, \"shit\"); // mev case\r\n            }else{\r\n                auth(address(authcontract)).checkauth();\r\n            }\r\n\r\n\r\n            // send back weth to the first pool\r\n            _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), owner, weth_balance - wethin);\r\n\r\n\r\n            // send back the new inxt token\r\n            _safeTransfer(address(0x4A8f5F96D5436e43112c2fBC6a9f70DA9e4E16D4), msg.sender, uint256(amount0Delta));\r\n\r\n\r\n            // send back weth to the first pool\r\n            _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0x6F7328C2188B0A61c6d76165C272B8cB2DbC2f94), wethin);\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function inxt_arb_mev(uint256 amountin, uint256 minbenefit) public payable{\r\n        \r\n        require(block.number <= msg.value, \"s\");\r\n\r\n        bytes memory data = abi.encode(amountin, minbenefit, 0);\r\n\r\n        v3pool(address(0x6F7328C2188B0A61c6d76165C272B8cB2DbC2f94)).swap(address(this), false, int256(amountin), \r\n            1461446703485210103287273052203988822378723970342 - 1, data);    \r\n\r\n    }\r\n\r\n\r\n\r\n    function inxt_arb_mem(uint256 amountin, uint256 minbenefit, address authcontract) public{\r\n\r\n        uint256 oldinxt_out = cal_v3out(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0xa8006C4ca56F24d6836727D106349320dB7fEF82), uint24(3000), amountin);\r\n\r\n        uint256 v3_weth_out = cal_v3out(address(0x4A8f5F96D5436e43112c2fBC6a9f70DA9e4E16D4), address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), uint24(3000), oldinxt_out);   \r\n\r\n        require(v3_weth_out >= amountin + minbenefit, \"shit\");\r\n\r\n        bytes memory data = abi.encode(amountin, 0, authcontract);\r\n\r\n        // require(auth(address(authcontract)).checkauth(), \"fuck\");\r\n\r\n        v3pool(address(0x6F7328C2188B0A61c6d76165C272B8cB2DbC2f94)).swap(address(this), false, int256(amountin), \r\n            1461446703485210103287273052203988822378723970342 - 1, data);    \r\n\r\n    }\r\n\r\n\r\n\r\n    function cal_v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\r\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\r\n    }\r\n\r\n\r\n    function detect(uint256 lowerbound, uint256 upperbound, uint256 step) public returns(uint256 bestprofit, uint256 bestin){\r\n\r\n        uint256 amountin = lowerbound;\r\n        uint256 v3out;\r\n\r\n        //oldinxtnum = IERC20(address(0xa8006C4ca56F24d6836727D106349320dB7fEF82)).balanceOf(address(0x6F7328C2188B0A61c6d76165C272B8cB2DbC2f94));\r\n        //newinxtnum = IERC20(address(0x4A8f5F96D5436e43112c2fBC6a9f70DA9e4E16D4)).balanceOf(address(0xb79376C03E654FeDE2f6530F0cEB81d2408482db));\r\n\r\n        while(amountin < upperbound){\r\n            // mint number\r\n            uint256 oldinxt_out = cal_v3out(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0xa8006C4ca56F24d6836727D106349320dB7fEF82), uint24(3000), amountin);\r\n\r\n            uint256 v3_weth_out = cal_v3out(address(0x4A8f5F96D5436e43112c2fBC6a9f70DA9e4E16D4), address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), uint24(3000), oldinxt_out);\r\n\r\n\r\n            if(v3_weth_out < amountin){\r\n                break;\r\n            }\r\n\r\n            if(v3_weth_out - amountin > bestprofit){\r\n                bestprofit = v3_weth_out - amountin;\r\n                bestin = amountin;\r\n                amountin = amountin + step;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n}"}}}