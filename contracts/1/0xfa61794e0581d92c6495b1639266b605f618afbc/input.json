{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DMEX_Base.sol":{"content":"pragma solidity ^0.4.19;\r\n\r\n/* Interface for ERC20 Tokens */\r\ncontract Token {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\n/* Interface for pTokens contract */\r\ncontract pToken {\r\n    function redeem(uint256 _value, string memory _btcAddress) public returns (bool _success);\r\n}\r\n\r\ninterface IAMB {\r\n    function messageSender() external view returns (address);\r\n    function maxGasPerTx() external view returns (uint256);\r\n    function transactionHash() external view returns (bytes32);\r\n    function messageId() external view returns (bytes32);\r\n    function messageSourceChainId() external view returns (bytes32);\r\n    function messageCallStatus(bytes32 _messageId) external view returns (bool);\r\n    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);\r\n    function failedMessageReceiver(bytes32 _messageId) external view returns (address);\r\n    function failedMessageSender(bytes32 _messageId) external view returns (address);\r\n    function requireToPassMessage(address _contract, bytes _data, uint256 _gas) external returns (bytes32);\r\n    function requireToConfirmMessage(address _contract, bytes _data, uint256 _gas) external returns (bytes32);\r\n    function sourceChainId() external view returns (uint256);\r\n    function destinationChainId() external view returns (uint256);\r\n}\r\n\r\ninterface DMEXXDAI {\r\n    function depositTokenForUser(address token, uint128 amount, address user);\r\n}\r\n\r\n// The DMEX base Contract\r\ncontract DMEX_Base {\r\n    address public owner; // holds the address of the contract owner\r\n    mapping (address => bool) public admins; // mapping of admin addresses\r\n    address public AMBBridgeContract;\r\n    address public DMEX_XDAI_CONTRACT;\r\n\r\n    uint256 public inactivityReleasePeriod; // period in blocks before a user can use the withdraw() function\r\n\r\n    bool public destroyed = false; // contract is destoryed\r\n    uint256 public destroyDelay = 1000000; // number of blocks after destroy, the contract is still active (aprox 6 monthds)\r\n    uint256 public destroyBlock;\r\n\r\n    uint256 public ambInstructionGas = 2000000;\r\n\r\n    mapping (bytes32 => bool) public processedMessages; // records processed bridge messages, so the same message is not executed twice\r\n\r\n    \r\n    /**\r\n     *\r\n     *  BALNCE FUNCTIONS\r\n     *\r\n     **/\r\n\r\n    // Deposit ETH to contract\r\n    function deposit() payable {\r\n        if (destroyed) revert();\r\n        \r\n        sendDepositInstructionToAMBBridge(msg.sender, address(0), msg.value);\r\n    }\r\n\r\n    // Deposit token to contract\r\n    function depositToken(address token, uint128 amount) {\r\n        if (destroyed) revert();\r\n        if (!Token(token).transferFrom(msg.sender, this, amount)) throw; // attempts to transfer the token to this contract, if fails throws an error\r\n        sendDepositInstructionToAMBBridge(msg.sender, token, amount);\r\n    }\r\n\r\n    // Deposit token to contract for a user\r\n    function depositTokenForUser(address token, uint128 amount, address user) {    \r\n        if (destroyed) revert();    \r\n\r\n        if (!Token(token).transferFrom(msg.sender, this, amount)) throw; // attempts to transfer the token to this contract, if fails throws an error\r\n        sendDepositInstructionToAMBBridge(user, token, amount);\r\n    }\r\n\r\n\r\n    function pTokenRedeem(address token, uint256 amount, string destinationAddress) onlyAMBBridge returns (bool success) {\r\n        if (!pToken(token).redeem(amount, destinationAddress)) revert();\r\n        bytes32 msgId = IAMB(AMBBridgeContract).messageId();\r\n        processedMessages[msgId] = true;\r\n        emit pTokenRedeemEvent(token, msg.sender, amount, destinationAddress);\r\n    }\r\n\r\n\r\n    function sendDepositInstructionToAMBBridge(address user, address token, uint256 amount) internal\r\n    {\r\n        bytes4 methodSelector = DMEXXDAI(0).depositTokenForUser.selector;\r\n        bytes memory data = abi.encodeWithSelector(methodSelector, token, amount, user);\r\n\r\n        uint256 gas = ambInstructionGas;\r\n\r\n        // send AMB bridge instruction\r\n        bytes32 msgId = IAMB(AMBBridgeContract).requireToPassMessage(DMEX_XDAI_CONTRACT, data, gas);\r\n\r\n        emit Deposit(token, user, amount, msgId); // fires the deposit event\r\n    }    \r\n \r\n\r\n\r\n    // Withdrawal function used by the server to execute withdrawals\r\n    function withdrawForUser(\r\n        address token, // the address of the token to be withdrawn\r\n        uint256 amount, // the amount to be withdrawn\r\n        address user // address of the user\r\n    ) onlyAMBBridge returns (bool success) {\r\n        if (token == address(0)) { // checks if the withdrawal is in ETH or Tokens\r\n            if (!user.send(amount)) throw; // sends ETH\r\n        } else {\r\n            if (!Token(token).transfer(user, amount)) throw; // sends tokens\r\n        }\r\n\r\n        bytes32 msgId = IAMB(AMBBridgeContract).messageId();\r\n        processedMessages[msgId] = true;\r\n        emit Withdraw(token, user, amount, msgId); // fires the withdraw event\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     *\r\n     *  HELPER FUNCTIONS\r\n     *\r\n     **/\r\n\r\n    // Event fired when the owner of the contract is changed\r\n    event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Allows only the owner of the contract to execute the function\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // Changes the owner of the contract\r\n    function setOwner(address newOwner) onlyOwner {\r\n        SetOwner(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    // Owner getter function\r\n    function getOwner() returns (address out) {\r\n        return owner;\r\n    }\r\n\r\n    // Adds or disables an admin account\r\n    function setAdmin(address admin, bool isAdmin) onlyOwner {\r\n        admins[admin] = isAdmin;\r\n    }\r\n\r\n\r\n    // Allows for admins only to call the function\r\n    modifier onlyAdmin {\r\n        if (msg.sender != owner && !admins[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    // Allows for AMB Bridge only to call the function\r\n    modifier onlyAMBBridge {\r\n        if (msg.sender != AMBBridgeContract) throw;\r\n\r\n        bytes32 msgId = IAMB(AMBBridgeContract).messageId();\r\n        require(!processedMessages[msgId], \"Error: message already processed\");\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        throw;\r\n    }\r\n\r\n    function assert(bool assertion) {\r\n        if (!assertion) throw;\r\n    }\r\n\r\n    // Safe Multiply Function - prevents integer overflow \r\n    function safeMul(uint a, uint b) returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    // Safe Subtraction Function - prevents integer overflow \r\n    function safeSub(uint a, uint b) returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    // Safe Addition Function - prevents integer overflow \r\n    function safeAdd(uint a, uint b) returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     *\r\n     *  ADMIN FUNCTIONS\r\n     *\r\n     **/\r\n    // Deposit event fired when a deposit takes place\r\n    event Deposit(address indexed token, address indexed user, uint256 amount, bytes32 msgId);\r\n\r\n    // Withdraw event fired when a withdrawal id executed\r\n    event Withdraw(address indexed token, address indexed user, uint256 amount, bytes32 msgId);\r\n    \r\n    // pTokenRedeemEvent event fired when a pToken withdrawal is executed\r\n    event pTokenRedeemEvent(address indexed token, address indexed user, uint256 amount, string destinationAddress);\r\n\r\n    // Change inactivity release period event\r\n    event InactivityReleasePeriodChange(uint256 value);\r\n\r\n    // Fee account changed event\r\n    event FeeAccountChanged(address indexed newFeeAccount);\r\n\r\n\r\n\r\n    // Constructor function, initializes the contract and sets the core variables\r\n    function DMEX_Base(uint256 inactivityReleasePeriod_, address AMBBridgeContract_, address DMEX_XDAI_CONTRACT_) {\r\n        owner = msg.sender;\r\n        inactivityReleasePeriod = inactivityReleasePeriod_;\r\n        AMBBridgeContract = AMBBridgeContract_;\r\n        DMEX_XDAI_CONTRACT = DMEX_XDAI_CONTRACT_;\r\n    }\r\n\r\n    // Sets the inactivity period before a user can withdraw funds manually\r\n    function destroyContract() onlyOwner returns (bool success) {\r\n        if (destroyed) throw;\r\n        destroyBlock = block.number;\r\n\r\n        return true;\r\n    }\r\n\r\n    // Sets the inactivity period before a user can withdraw funds manually\r\n    function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {\r\n        if (expiry > 1000000) throw;\r\n        inactivityReleasePeriod = expiry;\r\n\r\n        emit InactivityReleasePeriodChange(expiry);\r\n        return true;\r\n    }\r\n\r\n    // Returns the inactivity release perios\r\n    function getInactivityReleasePeriod() view returns (uint256)\r\n    {\r\n        return inactivityReleasePeriod;\r\n    }\r\n\r\n\r\n    function releaseFundsAfterDestroy(address token, uint256 amount) onlyOwner returns (bool success) {\r\n        if (!destroyed) throw;\r\n        if (safeAdd(destroyBlock, destroyDelay) > block.number) throw; // destroy delay not yet passed\r\n\r\n        if (token == address(0)) { // checks if withdrawal is a token or ETH, ETH has address 0x00000... \r\n            if (!msg.sender.send(amount)) throw; // send ETH\r\n        } else {\r\n            if (!Token(token).transfer(msg.sender, amount)) throw; // Send token\r\n        }\r\n    }\r\n\r\n    function setAmbInstructionGas(uint256 newGas) onlyOwner {\r\n        ambInstructionGas = newGas;\r\n    }\r\n}"}}}