{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/artifacts/AzSwap.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IPancakeRouter {\r\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);    \r\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n  function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path,\r\n          address to, uint deadline) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path,\r\n      address to, uint deadline) external;\r\n}\r\n\r\ncontract AzSwap {\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'AzSwap: EXPIRED');\r\n        _;\r\n    }\r\n    //address of the PCS V2 router\r\n      address owner;\r\n\r\n  constructor()\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n    address private constant PANCAKE_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    \r\n    //address of WETH token.  This is needed because some times it is better to trade through WETH.  \r\n    //you might get a better price using WETH.  \r\n    //example trading from token A to WETH then WETH to token B might result in a better price\r\n    //wbnb\r\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    \r\n    \r\n    function buyToken(address _tokenOut, uint _amountOutMin, address _to, uint deadline) external payable ensure(deadline) {\r\n      address[] memory path;\r\n      path = new address[](2);\r\n      path[0] = WETH;\r\n      path[1] = _tokenOut;\r\n\r\n      IPancakeRouter(PANCAKE_V2_ROUTER).swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(_amountOutMin, path, _to, block.timestamp);\r\n    }\r\n    function multiTxBuyTokenPayable(address _tokenOut, address[] calldata _toAddresses, uint[] calldata amountIns, uint slippage,bool honeyPotCheck, uint honeyPotAmountIn, uint deadline) external payable ensure(deadline) {\r\n      require(msg.sender == owner,'only owner could call this function');\r\n      multiTxBuyTokenImpl(_tokenOut, _toAddresses, amountIns, slippage, honeyPotCheck, honeyPotAmountIn);\r\n    }\r\n\r\n    function multiTxBuyToken(address _tokenOut, address[] calldata _toAddresses, uint[] calldata amountIns, uint slippage, bool honeyPotCheck, uint honeyPotAmountIn, uint deadline) external ensure(deadline) {\r\n      require(msg.sender == owner,'only owner could call this function');\r\n      multiTxBuyTokenImpl(_tokenOut, _toAddresses, amountIns, slippage, honeyPotCheck, honeyPotAmountIn);\r\n    }\r\n\r\n    function multiTxBuyTokenImpl(address _tokenOut, address[] calldata _toAddresses, uint[] calldata amountIns, uint slippage, bool honeyPotCheck, uint honeyPotAmountIn) private {\r\n      address[] memory path;\r\n      path = new address[](2);\r\n      path[0] = WETH;\r\n      path[1] = _tokenOut;\r\n\r\n\r\n      address[] memory amountsInPath;\r\n      amountsInPath = new address[](2);\r\n      amountsInPath[0] = _tokenOut;\r\n      amountsInPath[1] = WETH;\r\n      if(honeyPotCheck)\r\n      {\r\n        uint highTaxOrHoneyPotCheckResult = isHighTaxOrHoneyPot(_tokenOut, honeyPotAmountIn, slippage);\r\n        require(highTaxOrHoneyPotCheckResult != 1,\"Cancelling Transaction, Token Buy High Tax\");\r\n        require(highTaxOrHoneyPotCheckResult == 0,\"Counld not sell tokens, probably honeypot or Black Listing the Buyer Address\");\r\n      }\r\n      for (uint i=0; i<_toAddresses.length; i++) {\r\n        uint minAmountToGet = getMinAmountIn(_tokenOut, amountIns[i], slippage);\r\n        buyToken(_tokenOut, _toAddresses[i], amountIns[i], minAmountToGet);\r\n      }\r\n    }\r\n    function getMinAmountIn(address _tokenOut, uint amountIn, uint slippage) private view returns (uint)\r\n    {\r\n            address[] memory amountsInPath;\r\n      amountsInPath = new address[](2);\r\n      amountsInPath[0] = _tokenOut;\r\n      amountsInPath[1] = WETH;\r\n\r\n        uint minAmountToGet = 0;\r\n        if(slippage > 0)\r\n        {\r\n          (uint[] memory amounts) = IPancakeRouter(PANCAKE_V2_ROUTER).getAmountsIn(amountIn,amountsInPath);\r\n          minAmountToGet = (slippage * amounts[0]) / 100;\r\n        }\r\n        return minAmountToGet;\r\n    }\r\n\r\n    function buyToken(address _tokenOut, address _toAddress, uint amountIn, uint minAmountToGet) private \r\n    {\r\n      address[] memory buyPath;\r\n      buyPath = new address[](2);\r\n      buyPath[0] = WETH;\r\n      buyPath[1] = _tokenOut;\r\n\r\n      IPancakeRouter(PANCAKE_V2_ROUTER).swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountIn}(minAmountToGet, buyPath, _toAddress, block.timestamp);\r\n    }\r\n\r\n    function trySellContractTokens(address tokenToSell, uint tokensToSell) private \r\n    {\r\n      address[] memory sellPath;\r\n      sellPath = new address[](2);\r\n      sellPath[0] = tokenToSell;\r\n      sellPath[1] =  WETH;\r\n      IERC20(tokenToSell).approve(PANCAKE_V2_ROUTER, tokensToSell);\r\n      IPancakeRouter(PANCAKE_V2_ROUTER).swapExactTokensForETHSupportingFeeOnTransferTokens(tokensToSell, 0, sellPath, owner, block.timestamp);\r\n    }\r\n\r\n    function tokenHighTaxIsApplied(address _tokenOut, address _toAddress, uint _minAmountExpected) private view returns (bool)\r\n    {\r\n      uint balance = IERC20(_tokenOut).balanceOf(_toAddress);\r\n      return (balance < _minAmountExpected);\r\n    }\r\n\r\n    function isHighTaxOrHoneyPot(address _tokenOut, uint honeyPotAmountIn, uint slippage) private returns (uint)\r\n    {\r\n      uint minAmountToGet = getMinAmountIn(_tokenOut, honeyPotAmountIn, slippage);\r\n\r\n      buyToken(_tokenOut, address(this), honeyPotAmountIn, slippage);\r\n      uint balance = IERC20(_tokenOut).balanceOf(address(this));\r\n      \r\n      //if we received less tokens than the minAmount that the router was supposed to get for us, \r\n      //it means we were taxed by the token\r\n      if(balance < minAmountToGet)\r\n        return 1;\r\n      //IERC20(_tokenOut).transfer(owner, balance);\r\n\r\n      trySellContractTokens(_tokenOut, balance);\r\n      return 0;\r\n    }\r\n    fallback() external payable {\r\n        // custom function code\r\n    }\r\n\r\n    receive() external payable {\r\n        // custom function code\r\n    }\r\n}"
    }
  }
}