{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/DS/DSMath.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"},"localhost/constants/SaverExchangeConstantAddresses.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract SaverExchangeConstantAddresses {\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    address public constant KYBER_WRAPPER = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;\n    address public constant UNISWAP_WRAPPER = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;\n    address public constant OASIS_WRAPPER = 0x891f5A171f865031b0f3Eb9723bb8f68C901c9FE;\n\n    address public constant DGD_ADDRESS = 0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A;\n\n    // Our contracts\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n}\n"},"localhost/exchange/SaverExchange.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/GasTokenInterface.sol\";\nimport \"./SaverExchangeCore.sol\";\nimport \"../DS/DSMath.sol\";\nimport \"../loggers/ExchangeLogger.sol\";\n\ncontract SaverExchange is SaverExchangeCore, DSMath {\n\n    uint256 public constant SERVICE_FEE = 800; // 0.125% Fee\n\n    // solhint-disable-next-line const-name-snakecase\n    ExchangeLogger public constant logger = ExchangeLogger(0xf7CE9aa00bc4f4c413E4B4a613e889C1Ad01883e);\n    GasTokenInterface gasToken = GasTokenInterface(0x0000000000b3F879cb30FE243b4Dfee438691c04);\n\n    address public owner;\n    uint public burnAmount;\n\n    constructor() public {\n        owner = msg.sender;\n        burnAmount = 10;\n    }\n    \n    // for testing only\n    function setWrapper(address _newWrapper, uint _type) public {\n        require(owner == msg.sender);\n        \n        if (_type == 1) {\n            OASIS_WRAPPER = _newWrapper;\n        } else if (_type == 2) {\n            KYBER_WRAPPER = _newWrapper;\n        } else {\n            UNISWAP_WRAPPER = _newWrapper;\n        }\n    }\n\n    /// @notice Takes a src amount of tokens and converts it into the dest token\n    /// @dev Takes fee from the _srcAmount before the exchange\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    function sell(ExchangeData memory exData) public payable {\n        if (gasToken.balanceOf(address(this)) >= burnAmount) {\n            gasToken.free(burnAmount);\n        }\n\n        // transfer tokens from the user\n        pullTokens(exData.srcAddr, exData.srcAmount);\n\n        // take fee\n        uint dfsFee = takeFee(exData.srcAmount, exData.srcAddr);\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\n\n        // Perform the exchange\n        (address wrapper, uint destAmount) = _sell(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, msg.sender);\n\n        // log the event\n        logger.logSwap(exData.srcAddr, exData.destAddr, exData.srcAmount, destAmount, wrapper);\n    }\n\n    /// @notice Takes a dest amount of tokens and converts it from the src token\n    /// @dev Send always more than needed for the swap, extra will be returned\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    function buy(ExchangeData memory exData) public payable {\n        if (gasToken.balanceOf(address(this)) >= burnAmount) {\n            gasToken.free(burnAmount);\n        }\n\n        // transfer tokens from the user\n        pullTokens(exData.srcAddr, exData.srcAmount);\n\n        uint dfsFee = takeFee(exData.srcAmount, exData.srcAddr);\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\n\n        // Perform the exchange\n        (address wrapper, uint srcAmount) = _buy(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, msg.sender);\n\n        // log the event\n        logger.logSwap(exData.srcAddr, exData.destAddr, srcAmount, exData.destAmount, wrapper);\n    }\n\n    /// @notice Takes a feePercentage and sends it to wallet\n    /// @param _amount Dai amount of the whole trade\n    /// @param _token Address of the token\n    /// @return feeAmount Amount in Dai owner earned on the fee\n    function takeFee(uint256 _amount, address _token) internal returns (uint256 feeAmount) {\n        uint256 fee = SERVICE_FEE;\n\n        if (Discount(DISCOUNT_ADDRESS).isCustomFeeSet(msg.sender)) {\n            fee = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(msg.sender);\n        }\n\n        if (fee == 0) {\n            feeAmount = 0;\n        } else {\n            feeAmount = _amount / SERVICE_FEE;\n            if (_token == KYBER_ETH_ADDRESS) {\n                WALLET_ID.transfer(feeAmount);\n            } else {\n                ERC20(_token).transfer(WALLET_ID, feeAmount);\n            }\n        }\n    }\n\n    /// @notice Changes the amount of gas token we burn for each call\n    /// @dev Only callable by the owner\n    /// @param _newBurnAmount New amount of gas tokens to be burned\n    function changeBurnAmount(uint _newBurnAmount) public {\n        require(owner == msg.sender);\n\n        burnAmount = _newBurnAmount;\n    }\n\n}\n"},"localhost/exchange/SaverExchangeCore.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/ExchangeInterfaceV2.sol\";\nimport \"./SaverExchangeHelper.sol\";\n\ncontract SaverExchangeCore is SaverExchangeHelper {\n\n    // first is empty to keep the legacy order in place\n    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\n\n    enum ActionType { SELL, BUY }\n\n    struct ExchangeData {\n        address srcAddr;\n        address destAddr;\n        uint srcAmount;\n        uint destAmount;\n        uint minPrice;\n        ExchangeType exchangeType;\n        address exchangeAddr;\n        bytes callData;\n        uint256 price0x;\n    }\n\n    /// @notice Internal method that preforms a sell on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and destAmount\n    function _sell(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n        uint tokensLeft = exData.srcAmount;\n\n        // if 0x is selected try first the 0x order\n        if (exData.exchangeType == ExchangeType.ZEROX) {\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n            (success, swapedTokens, tokensLeft) = takeOrder(exData, address(this).balance);\n\n            wrapper = exData.exchangeAddr;\n        }\n\n        // check if we have already swapped with 0x, or tried swapping but failed\n        if (tokensLeft > 0) {\n            uint price;\n\n            (wrapper, price)\n                = getBestPrice(exData.srcAmount, exData.srcAddr, exData.destAddr, exData.exchangeType, ActionType.SELL);\n\n            require(price > exData.minPrice || exData.price0x > exData.minPrice, \"Slippage hit\");\n\n            // if 0x has better prices use 0x\n            if (exData.price0x >= price && exData.exchangeType != ExchangeType.ZEROX) {\n                approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n                (success, swapedTokens, tokensLeft) = takeOrder(exData, address(this).balance);\n            }\n\n            require(price > exData.minPrice, \"On chain slippage hit\");\n\n            // 0x either had worse price or we tried and order fill failed, so call on chain swap\n            if (tokensLeft > 0) {\n                swapedTokens = saverSwap(exData, wrapper, ActionType.SELL);\n            }\n        }\n\n        return (wrapper, swapedTokens);\n    }\n\n    /// @notice Internal method that preforms a buy on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and srcAmount\n    function _buy(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n\n        require(exData.destAmount != 0, \"Dest amount must be specified\");\n\n        // if 0x is selected try first the 0x order\n        if (exData.exchangeType == ExchangeType.ZEROX) {\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n            // TODO: should we use address(this).balance?\n            (success, swapedTokens,) = takeOrder(exData, address(this).balance);\n\n            wrapper = exData.exchangeAddr;\n        }\n\n        // check if we have already swapped with 0x, or tried swapping but failed\n        if (getBalance(exData.destAddr) < exData.destAmount) {\n            uint price;\n\n            (wrapper, price)\n                = getBestPrice(exData.destAmount, exData.srcAddr, exData.destAddr, exData.exchangeType, ActionType.BUY);\n\n            require(price < exData.minPrice || exData.price0x < exData.minPrice, \"Slippage hit\");\n\n            // if 0x has better prices use 0x\n            if (exData.price0x != 0 && exData.price0x <= price && exData.exchangeType != ExchangeType.ZEROX) {\n                approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n                (success, swapedTokens,) = takeOrder(exData, address(this).balance);\n            }\n\n            require(price < exData.minPrice, \"On chain slippage hit\");\n\n            // 0x either had worse price or we tried and order fill failed, so call on chain swap\n            if (getBalance(exData.destAddr) < exData.destAmount) {\n               swapedTokens = saverSwap(exData, wrapper, ActionType.BUY);\n            }\n        }\n\n        // require(getBalance(exData.destAddr) >= exData.destAmount, \"Less then destAmount\");\n\n        return (wrapper, getBalance(exData.destAddr));\n    }\n\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\n    /// @param _exData Exchange data\n    /// @param _0xFee Ether fee needed for 0x order\n    function takeOrder(\n        ExchangeData memory _exData,\n        uint256 _0xFee\n    ) private returns (bool success, uint256, uint256) {\n\n        // solhint-disable-next-line avoid-call-value\n        (success, ) = _exData.exchangeAddr.call{value: _0xFee}(_exData.callData);\n\n        uint256 tokensSwaped = 0;\n        uint256 tokensLeft = _exData.srcAmount;\n\n        if (success) {\n            // check to see if any _src tokens are left over after exchange\n            tokensLeft = getBalance(_exData.srcAddr);\n\n            // convert weth -> eth if needed\n            if (_exData.destAddr == KYBER_ETH_ADDRESS) {\n                TokenInterface(WETH_ADDRESS).withdraw(\n                    TokenInterface(WETH_ADDRESS).balanceOf(address(this))\n                );\n            }\n\n            // get the current balance of the swaped tokens\n            tokensSwaped = getBalance(_exData.destAddr);\n        }\n\n        return (success, tokensSwaped, tokensLeft);\n    }\n\n    /// @notice Returns the best estimated price from 2 exchanges\n    /// @param _amount Amount of source tokens you want to exchange\n    /// @param _srcToken Address of the source token\n    /// @param _destToken Address of the destination token\n    /// @param _exchangeType Which exchange will be used\n    /// @param _type Type of action SELL|BUY\n    /// @return (address, uint) The address of the best exchange and the exchange price\n    function getBestPrice(\n        uint256 _amount,\n        address _srcToken,\n        address _destToken,\n        ExchangeType _exchangeType,\n        ActionType _type\n    ) public returns (address, uint256) {\n\n        if (_exchangeType == ExchangeType.OASIS) {\n            return (OASIS_WRAPPER, getExpectedRate(OASIS_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        if (_exchangeType == ExchangeType.KYBER) {\n            return (KYBER_WRAPPER, getExpectedRate(KYBER_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        if (_exchangeType == ExchangeType.UNISWAP) {\n            return (UNISWAP_WRAPPER, getExpectedRate(UNISWAP_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        uint expectedRateKyber = getExpectedRate(KYBER_WRAPPER, _srcToken, _destToken, _amount, _type);\n        uint expectedRateUniswap = getExpectedRate(UNISWAP_WRAPPER, _srcToken, _destToken, _amount, _type);\n        uint expectedRateOasis = getExpectedRate(OASIS_WRAPPER, _srcToken, _destToken, _amount, _type);\n\n        if (_type == ActionType.SELL) {\n            return getBiggestRate(expectedRateKyber, expectedRateUniswap, expectedRateOasis);\n        } else {\n            return getSmallestRate(expectedRateKyber, expectedRateUniswap, expectedRateOasis);\n        }\n    }\n\n    /// @notice Return the expected rate from the exchange wrapper\n    /// @dev In case of Oasis/Uniswap handles the different precision tokens\n    /// @param _wrapper Address of exchange wrapper\n    /// @param _srcToken From token\n    /// @param _destToken To token\n    /// @param _amount Amount to be exchanged\n    /// @param _type Type of action SELL|BUY\n    function getExpectedRate(\n        address _wrapper,\n        address _srcToken,\n        address _destToken,\n        uint256 _amount,\n        ActionType _type\n    ) public returns (uint256) {\n        bool success;\n        bytes memory result;\n\n        if (_type == ActionType.SELL) {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getSellRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n\n        } else {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getBuyRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n        }\n\n        if (success) {\n            uint rate = sliceUint(result, 0);\n\n            if (_wrapper != KYBER_WRAPPER) {\n                rate = rate * (10**(18 - getDecimals(_destToken)));\n            }\n\n            return rate;\n        }\n\n        return 0;\n    }\n\n    /// @notice Calls wraper contract for exchage to preform an on-chain swap\n    /// @param exData Exchange data struct\n    /// @param _wrapper Address of exchange wrapper\n    /// @param _type Type of action SELL|BUY\n    /// @return swapedTokens For Sell that the destAmount, for Buy thats the srcAmount\n    function saverSwap(ExchangeData memory exData, address _wrapper, ActionType _type) internal returns (uint swapedTokens) {\n        uint ethValue = 0;\n\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\n            ethValue = exData.srcAmount;\n        } else {\n            ERC20(exData.srcAddr).transfer(_wrapper, ERC20(exData.srcAddr).balanceOf(address(this)));\n        }\n\n        if (_type == ActionType.SELL) {\n            swapedTokens = ExchangeInterfaceV2(_wrapper).\n                    sell{value: ethValue}(exData.srcAddr, exData.destAddr, exData.srcAmount);\n        } else {\n            swapedTokens = ExchangeInterfaceV2(_wrapper).\n                    buy{value: ethValue}(exData.srcAddr, exData.destAddr, exData.destAmount);\n        }\n    }\n\n    /// @notice Finds the biggest rate between exchanges, needed for sell rate\n    /// @param _expectedRateKyber Kyber rate\n    /// @param _expectedRateUniswap Uniswap rate\n    /// @param _expectedRateOasis Oasis rate\n    function getBiggestRate(\n        uint _expectedRateKyber,\n        uint _expectedRateUniswap,\n        uint _expectedRateOasis\n    ) internal view returns (address, uint) {\n        if (\n            (_expectedRateUniswap >= _expectedRateKyber) && (_expectedRateUniswap >= _expectedRateOasis)\n        ) {\n            return (UNISWAP_WRAPPER, _expectedRateUniswap);\n        }\n\n        if (\n            (_expectedRateKyber >= _expectedRateUniswap) && (_expectedRateKyber >= _expectedRateOasis)\n        ) {\n            return (KYBER_WRAPPER, _expectedRateKyber);\n        }\n\n        if (\n            (_expectedRateOasis >= _expectedRateKyber) && (_expectedRateOasis >= _expectedRateUniswap)\n        ) {\n            return (OASIS_WRAPPER, _expectedRateOasis);\n        }\n    }\n\n    /// @notice Finds the smallest rate between exchanges, needed for buy rate\n    /// @param _expectedRateKyber Kyber rate\n    /// @param _expectedRateUniswap Uniswap rate\n    /// @param _expectedRateOasis Oasis rate\n    function getSmallestRate(\n        uint _expectedRateKyber,\n        uint _expectedRateUniswap,\n        uint _expectedRateOasis\n    ) internal view returns (address, uint) {\n        if (\n            (_expectedRateUniswap <= _expectedRateKyber) && (_expectedRateUniswap <= _expectedRateOasis)\n        ) {\n            return (UNISWAP_WRAPPER, _expectedRateUniswap);\n        }\n\n        if (\n            (_expectedRateKyber <= _expectedRateUniswap) && (_expectedRateKyber <= _expectedRateOasis)\n        ) {\n            return (KYBER_WRAPPER, _expectedRateKyber);\n        }\n\n        if (\n            (_expectedRateOasis <= _expectedRateKyber) && (_expectedRateOasis <= _expectedRateUniswap)\n        ) {\n            return (OASIS_WRAPPER, _expectedRateOasis);\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"},"localhost/exchange/SaverExchangeHelper.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"../constants/SaverExchangeConstantAddresses.sol\";\nimport \"../interfaces/ERC20.sol\";\nimport \"../mcd/Discount.sol\";\n\ncontract SaverExchangeHelper {\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant DGD_ADDRESS = 0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A;\n\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    // TODO: set to constant after testing\n    address public KYBER_WRAPPER = 0x3d1D4D6Bb405b2366434cb7387803c7B662b8d71;\n    address public UNISWAP_WRAPPER = 0xFF92ADA50cDC8009686867b4a470C8769bEdB22d;\n    address public OASIS_WRAPPER = 0x9C499376B41A91349Ff93F99462a65962653e104;\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == DGD_ADDRESS) return 9;\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function pullTokens(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            require(msg.value >= _amount, \"msg.value smaller than amount\");\n        } else {\n            require(\n                ERC20(_tokenAddr).transferFrom(msg.sender, address(this), _amount),\n                \"Not able to withdraw wanted amount\"\n            );\n        }\n    }\n\n    function getBalance(address _tokenAddr) internal view returns (uint balance) {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            balance = address(this).balance;\n        } else {\n            balance = ERC20(_tokenAddr).balanceOf(address(this));\n        }\n    }\n\n    function approve0xProxy(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_tokenAddr).approve(address(ERC20_PROXY_0X), _amount);\n        }\n    }\n\n    function sendLeftover(address _srcAddr, address _destAddr, address payable _to) internal {\n        // send back any leftover ether or tokens\n        if (address(this).balance > 0) {\n            _to.transfer(address(this).balance);\n        }\n\n        if (getBalance(_srcAddr) > 0) {\n            ERC20(_srcAddr).transfer(_to, getBalance(_srcAddr));\n        }\n\n        if (getBalance(_destAddr) > 0) {\n            ERC20(_destAddr).transfer(_to, getBalance(_destAddr));\n        }\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n}\n"},"localhost/interfaces/ERC20.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function decimals() external view returns (uint256 digits);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"},"localhost/interfaces/ExchangeInterfaceV2.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface ExchangeInterfaceV2 {\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable returns (uint);\n\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external payable returns(uint);\n\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\n\n    function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\n}\n"},"localhost/interfaces/GasTokenInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract GasTokenInterface is ERC20 {\n    function free(uint256 value) public virtual returns (bool success);\n\n    function freeUpTo(uint256 value) public virtual returns (uint256 freed);\n\n    function freeFrom(address from, uint256 value) public virtual returns (bool success);\n\n    function freeFromUpTo(address from, uint256 value) public virtual returns (uint256 freed);\n}\n"},"localhost/interfaces/TokenInterface.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract TokenInterface {\n    function allowance(address, address) public virtual returns (uint256);\n\n    function balanceOf(address) public virtual returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(address, address, uint256) public virtual returns (bool);\n\n    function deposit() public virtual payable;\n\n    function withdraw(uint256) public virtual;\n}\n"},"localhost/loggers/ExchangeLogger.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract ExchangeLogger {\n    event Swap(\n        address src,\n        address dest,\n        uint256 amountSold,\n        uint256 amountBought,\n        address wrapper\n    );\n\n    function logSwap(\n        address _src,\n        address _dest,\n        uint256 _amountSold,\n        uint256 _amountBought,\n        address _wrapper\n    ) public {\n        emit Swap(_src, _dest, _amountSold, _amountBought, _wrapper);\n    }\n}\n"},"localhost/mcd/Discount.sol":{"content":"pragma solidity ^0.6.0;\n\n\ncontract Discount {\n    address public owner;\n    mapping(address => CustomServiceFee) public serviceFees;\n\n    uint256 constant MAX_SERVICE_FEE = 400;\n\n    struct CustomServiceFee {\n        bool active;\n        uint256 amount;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }\n\n    function getCustomServiceFee(address _user) public view returns (uint256) {\n        return serviceFees[_user].amount;\n    }\n\n    function setServiceFee(address _user, uint256 _fee) public {\n        require(msg.sender == owner, \"Only owner\");\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n    }\n\n    function disableServiceFee(address _user) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n    }\n}\n"}}}