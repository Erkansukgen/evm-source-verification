{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "StrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\ninterface LosslessController {\n    function admin() external returns(address);\n\n    function isAddressProtected(address token, address protectedAddress) external view returns (bool);\n}\n\ninterface Guardian {\n    function protectionAdmin(address token) external returns (address);\n\n    function setProtectedAddress(address token, address guardedAddress) external;\n\n    function removeProtectedAddresses(address token, address protectedAddress) external;\n}\n\nabstract contract StrategyBase {\n    Guardian public guardian;\n    LosslessController public controller;\n\n    // --- EVENTS ---\n\n    event GuardianSet(address indexed newGuardian);\n    event Paused(address indexed token, address indexed protectedAddress);\n    event Unpaused(address indexed token, address indexed protectedAddress);\n\n    constructor(Guardian _guardian, LosslessController _controller) {\n        guardian = _guardian;\n        controller = _controller;\n    }\n\n    // --- MODIFIERS ---\n\n    modifier onlyProtectionAdmin(address token) {\n        require(msg.sender == guardian.protectionAdmin(token), \"LOSSLESS: Not protection admin\");\n        _;\n    }\n\n    // --- METHODS ---\n\n    // @dev In case guardian is changed, this allows not to redeploy strategy and just update it.\n    function setGuardian(Guardian newGuardian) external {\n        require(msg.sender == controller.admin(), \"LOSSLESS: Not lossless admin\");\n        guardian = newGuardian;\n        emit GuardianSet(address(newGuardian));\n    }\n}"
    },
    "TreasuryProtectionStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"./StrategyBase.sol\";\n\ncontract TreasuryProtectionStrategy is StrategyBase {\n    mapping(address => Protection) private protectedAddresses;\n\n    struct Whitelist {\n        mapping(address => bool) whitelist;\n    }\n\n    struct Protection {\n        mapping(address => Whitelist) protection; \n    }\n\n    event WhitelistAddresses(address token, address protectedAddress, address[] whitelist, bool state);\n    event RemovedWhitelistAddresses(address token, address[] addressesToRemove);\n\n    constructor(Guardian _guardian, LosslessController _controller) StrategyBase(_guardian, _controller) {}\n\n    // --- VIEWS ---\n\n    function isAddressWhitelisted(address token, address protectedAddress, address whitelistedAddress) public view returns(bool) {\n        return protectedAddresses[token].protection[protectedAddress].whitelist[whitelistedAddress];\n    }\n\n    // @dev Called by controller to check if transfer is allowed to happen.\n    function isTransferAllowed(address token, address sender, address recipient, uint256 amount) external view {\n        require(isAddressWhitelisted(token, sender, recipient), \"LOSSLESS: not whitelisted\");\n    }\n\n    // --- METHODS ---\n\n    // @dev Called by project owners. Sets a whitelist for protected address.\n    function setProtectedAddress(address token, address protectedAddress, address[] calldata whitelist) external onlyProtectionAdmin(token) {\n        setWhitelistState(token, protectedAddress, whitelist, true);\n        guardian.setProtectedAddress(token, protectedAddress);\n    }\n\n    // @dev Called by project owners. Adds or removes addresses for the whitelist of the protected address.\n    function setWhitelistState(address token, address protectedAddress, address[] calldata addresses, bool state) public onlyProtectionAdmin(token) {\n        for(uint8 i = 0; i < addresses.length; i++) {\n            protectedAddresses[token].protection[protectedAddress].whitelist[addresses[i]] = state;\n        }\n        emit WhitelistAddresses(token, protectedAddress, addresses, state);\n    }\n}"
    }
  }
}