{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SanityWrapper_v1.1.sol": {
      "content": "pragma solidity 0.6.6;\n\ninterface ERC20 {\n    function transferFrom(address _from, address _to, uint _value) external returns (bool);\n    function transfer(address _to, uint _value) external returns (bool);\n    function decimals() external view returns (uint);\n    function balanceOf(address _owner) external view returns (uint256);\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ninterface IConversionRates {\n    function getFeedRate(ERC20 token, bool buy) external view returns (uint);\n    function getRefPrice(ERC20 token) external view returns (uint);\n}\n\ninterface ISanityRates {\n    function getSanityRate(ERC20 src, ERC20 dest) external view returns (uint256);\n}\n\ncontract Utils {\n\n    ERC20 internal constant ETH_TOKEN_ADDRESS = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    uint  constant internal PRECISION = (10**18);\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n    uint  constant internal MAX_DECIMALS = 18;\n    uint  constant internal ETH_DECIMALS = 18;\n    mapping(ERC20=>uint) public decimals;\n\n    \n    function setDecimals(ERC20 token) internal {\n        decimals[token] = token.decimals();\n    }\n\n    function getDecimals(ERC20 token) internal view returns(uint) {\n        uint tokenDecimals = decimals[token];\n        // technically, there might be token with decimals 0\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        if(tokenDecimals == 0) return token.decimals();\n\n        return tokenDecimals;\n    }\n    \n    function calcRateFromQty(uint256 srcAmount, uint256 destAmount, uint256 srcDecimals, uint256 dstDecimals) internal pure returns (uint256) {\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\n        }\n    }\n    \n}\n\ncontract PermissionGroups{\n    \n    address public admin;\n    address public pendingAdmin;\n    \n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"onlyAdmin\");\n        _;\n    }\n\n    function transferAdmin(address newAdmin) external onlyAdmin {\n        require(newAdmin != address(0),\"newAdmin == address(0)\");\n        pendingAdmin = newAdmin;\n    }\n\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender,\"pendingAdmin != msg.sender\");\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n}\n\ncontract AssetManager is PermissionGroups{\n    \n    receive() external payable{}\n    fallback() external payable{}\n    \n    function withdrawEth(address payable _to, uint _value) external onlyAdmin{\n        require(_to != address(0));\n        _to.transfer(_value);\n    }\n    \n    function withdrawToken(address token, address to, uint value) external onlyAdmin{ \n        require(to != address(0));\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'withdrawToken: TRANSFER_FAILED');\n    }\n    \n}\n\ncontract Config is AssetManager,Utils{\n    \n    ERC20[] internal listedTokens;\n    mapping(ERC20=>TokenData) public tokenData;\n    \n    struct TokenData {\n        bool listed; \n    //    uint sanityType; // 0 origin , 1, uniswap v2 \n        \n        uint reasonableDiffInBps;\n    }\n    \n    string constant public VERSION = \"SanityWrapper v1.1\";\n    IConversionRates constant public myConversionRates = IConversionRates(0x75e58a2e1391A22110D72EbD2B059a80126a6b92);\n    ISanityRates constant public sanityRatesContract = ISanityRates(0xeb3111C71af052717A9A8C6c1F424EF6dFeb251E); \n    \n    function addTokens(ERC20[] calldata _addingTokens) external onlyAdmin {\n        for(uint i=0; i<_addingTokens.length; i++) {\n            addToken(_addingTokens[i]);\n        }\n    }\n    \n    function addToken(ERC20 token) private {\n        require(!tokenData[token].listed,\"token listed\");\n        tokenData[token].listed = true;\n    //    tokenData[token].sanityType = 1;\n        tokenData[token].reasonableDiffInBps = 25;\n        listedTokens.push(token);\n        \n        setDecimals(token);\n    }\n    \n    function removeTokens(ERC20[] calldata _removingTokens) external onlyAdmin {\n        for(uint i=0; i<_removingTokens.length; i++) {\n            removeToken(_removingTokens[i]);\n        }\n    }\n    \n    function removeToken(ERC20 token) private {\n        require(listedTokens.length > 0,\"listedTokens.length <= 0\");\n        require(tokenData[token].listed,\"token not listed\");\n        tokenData[token].listed = false;\n    //    tokenData[token].sanityType = 0;\n        tokenData[token].reasonableDiffInBps = 0;\n        \n        for (uint i = 0; i < listedTokens.length; i++) {\n            if (listedTokens[i] == token) {\n                listedTokens[i] = listedTokens[listedTokens.length -1];\n                listedTokens.pop();\n                break;\n            }\n        }\n\n    }\n    \n    function getListedTokens() public view returns(ERC20[] memory) {\n        return listedTokens;\n    }\n    \n    function setReasonableDiff(ERC20[] calldata srcs, uint[] calldata diff) external onlyAdmin {\n        require(srcs.length == diff.length);\n        for (uint i = 0; i < srcs.length; i++) {\n            require(tokenData[srcs[i]].listed,\"token is not listed\");\n            require(diff[i] <= 100 * 100);\n            tokenData[srcs[i]].reasonableDiffInBps = diff[i];\n        }\n    }\n    \n    // function setMyConversionRates(IConversionRates _myConversionRates) external onlyAdmin {\n    //     myConversionRates = _myConversionRates;\n    // }\n\n}\n\n\ncontract UniPrice is Config{\n    \n    address constant public wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant public uniswapFactory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    \n    function getUniSellPrice(ERC20 src) public view returns (uint refPrice) {\n        (uint reserveIn, uint reserveOut) = getReserves(uniswapFactory,address(src),wethAddress);\n        refPrice = calcRateFromQty(reserveIn, reserveOut, getDecimals(src), ETH_DECIMALS);\n      // calcRateFromQty(srcAmount, destAmount, uint256 srcDecimals, uint256 dstDecimals)\n    }\n    \n    function getUniBuyPrice(ERC20 dest) public view returns (uint refPrice) {\n        (uint reserveIn, uint reserveOut) = getReserves(uniswapFactory,wethAddress,address(dest));\n        refPrice = calcRateFromQty(reserveIn, reserveOut, ETH_DECIMALS, getDecimals(dest));\n    }\n    \n    function getReserves(address factory, address tokenIn, address tokenOut) internal view returns (uint, uint){\n        address uni_pair_addr =  IUniswapV2Factory(factory).getPair(tokenIn,tokenOut);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(uni_pair_addr).getReserves();\n        (uint reserveIn, uint reserveOut) = tokenIn < tokenOut ? (reserve0, reserve1) : (reserve1, reserve0);\n        return (reserveIn,reserveOut);\n    }\n    \n}\n\n\ncontract SanityWrapper is UniPrice {\n    \n    uint constant internal TRUE_NUMBER = uint(-1);\n    uint constant internal FALSE_NUMBER = 0;\n    \n    function getSanityRate(ERC20 src, ERC20 dest) external view returns(uint) {\n        ERC20 token = src != ETH_TOKEN_ADDRESS ? src:dest;\n        \n        if (tokenData[token].listed) {\n            uint reasonableDiffInBps = tokenData[token].reasonableDiffInBps;\n            return getExtSanityRate(src,dest,reasonableDiffInBps);\n        }\n        else {\n            return sanityRatesContract.getSanityRate(src,dest); \n        }\n\n    }\n\n    function getExtSanityRate(ERC20 src, ERC20 dest, uint reasonableDiffInBps) public view returns(uint) {\n        uint ratesFeedPrice;\n        uint uniRefPrice;\n        \n        if (src == ETH_TOKEN_ADDRESS) {\n            ratesFeedPrice = myConversionRates.getFeedRate(dest,true);\n            uniRefPrice = getUniBuyPrice(dest);\n        }\n        else {\n            ratesFeedPrice = myConversionRates.getFeedRate(src,false);\n            uniRefPrice = getUniSellPrice(src);\n        }\n        \n        if ( ratesFeedPrice > uniRefPrice * (10000+reasonableDiffInBps)/10000 ) {\n            return FALSE_NUMBER;\n        }\n        else {\n            return TRUE_NUMBER;\n        }\n            \n    }\n    \n}\n\n\n\n"
    }
  }
}