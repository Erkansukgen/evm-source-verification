{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/presale.sol":{"content":"//\"SPDX-License-Identifier: UNLICENSED\"\n\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ninterface ERC20Interface {\n    function transfer(address to, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n    function totalSupply() external view returns (uint);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\ncontract PreSale {\n    using SafeMath for uint;\n    \n    ERC20Interface contractAddress;\n    address public tokenOwner;\n    uint public end;\n    uint public tokenRate;\n    uint public availableTokens;\n    uint public userId;\n    \n    constructor(ERC20Interface _contractAddress, address _tokenOwner)\n        public {\n        contractAddress = _contractAddress;\n        tokenOwner = _tokenOwner;\n    }\n    \n    function start(\n        uint duration,\n        uint _tokenRate,\n        uint _availableTokens)\n        external\n        onlyAdmin() \n        icoNotActive() {\n        require(duration > 0, 'duration should be > 0');\n        uint totalSupply = contractAddress.totalSupply();\n        require(_availableTokens > 0 && _availableTokens <= totalSupply, 'totalSupply should be > 0 and <= totalSupply');\n        end = duration + now; \n        tokenRate = _tokenRate;\n        availableTokens = _availableTokens;\n    }\n    \n    function buy()\n        payable\n        external\n        icoActive() {\n        uint quantity = msg.value * tokenRate;\n        require(msg.value >0,'value must be above zero');\n        require(quantity <= availableTokens, 'Not enough tokens left for sale');\n        if(userId <= 49){\n            uint bonus1 = quantity.mul(30).div(100);\n            uint userGet1 = quantity.add(bonus1);\n            availableTokens = availableTokens.sub(userGet1);\n            contractAddress.transferFrom(tokenOwner,msg.sender, userGet1); \n        }\n         else if(userId > 49 && userId <= 99){\n            uint bonus2 = quantity.mul(20).div(100);\n            uint userGet2 = quantity.add(bonus2);\n            availableTokens = availableTokens.sub(userGet2);\n            contractAddress.transferFrom(tokenOwner,msg.sender, userGet2);\n        }\n        else if(userId > 99 && userId <= 149){\n            uint bonus3 = quantity.mul(10).div(100);\n            uint userGet3 = quantity.add(bonus3);\n            availableTokens = availableTokens.sub(userGet3);\n            contractAddress.transferFrom(tokenOwner,msg.sender, userGet3);\n        }\n        else{\n            availableTokens = availableTokens.sub(quantity);\n            contractAddress.transferFrom(tokenOwner,msg.sender, quantity);\n        }\n        userId = userId.add(1);\n    }\n    \n    \n    function withdraw(\n        address payable to,\n        uint amount)\n        external\n        onlyAdmin(){\n        to.transfer(amount);    \n    }\n    \n    function addressBalance() view public returns(uint) {\n       return address(this).balance;\n    }\n    \n    modifier icoActive() {\n        require(end > 0 && now < end && availableTokens > 0, \"ICO must be active\");\n        _;\n    }\n    \n    modifier icoNotActive() {\n        require(end == 0, 'ICO should not be active');\n        _;\n    }\n    \n    modifier onlyAdmin() {\n        require(msg.sender == tokenOwner, 'only admin');\n        _;\n    }\n    \n}\n"}}}