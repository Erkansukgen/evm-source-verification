{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Hyflate/Hyflate.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.8;\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./Pausable.sol\";\ncontract ERC20 is IERC20, Ownable, Pausable {\n    using SafeMath for uint256;\n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowed;\n    event Mint(address indexed minter, address indexed account, uint256 amount);\n    event Burn(address indexed burner, address indexed account, uint256 amount);\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 totalSupply\n    ) public {\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n        _balances[msg.sender] = totalSupply;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    function transfer(address _to, uint256 _value)\n        public\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        require(_to != address(0), \"ERC20: to address is not valid\");\n        require(_value <= _balances[msg.sender], \"ERC20: insufficient balance\");\n        _balances[msg.sender] = SafeMath.sub(_balances[msg.sender], _value);\n        _balances[_to] = SafeMath.add(_balances[_to], _value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    function balanceOf(address _owner)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _balances[_owner];\n    }\n    function approve(address _spender, uint256 _value)\n        public\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        _allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override whenNotPaused returns (bool) {\n        require(_from != address(0), \"ERC20: from address is not valid\");\n        require(_to != address(0), \"ERC20: to address is not valid\");\n        require(_value <= _balances[_from], \"ERC20: insufficient balance\");\n        require(\n            _value <= _allowed[_from][msg.sender],\n            \"ERC20: from not allowed\"\n        );\n        _balances[_from] = SafeMath.sub(_balances[_from], _value);\n        _balances[_to] = SafeMath.add(_balances[_to], _value);\n        _allowed[_from][msg.sender] = SafeMath.sub(\n            _allowed[_from][msg.sender],\n            _value\n        );\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n    function allowance(address _owner, address _spender)\n        public\n        view\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        return _allowed[_owner][_spender];\n    }\n    function mintTo(address _to, uint256 _amount)\n        public\n        whenNotPaused\n        onlyOwner\n    {\n        require(_to != address(0), \"ERC20: to address is not valid\");\n        require(_amount > 0, \"ERC20: amount is not valid\");\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_to] = _balances[_to].add(_amount);\n        emit Mint(msg.sender, _to, _amount);\n    }\n    function burnFrom(address _from, uint256 _amount)\n        public\n        whenNotPaused\n        onlyOwner\n    {\n        require(_from != address(0), \"ERC20: from address is not valid\");\n        require(_balances[_from] >= _amount, \"ERC20: insufficient balance\");\n        _balances[_from] = _balances[_from].sub(_amount);\n        _totalSupply = _totalSupply.sub(_amount);\n        emit Burn(msg.sender, _from, _amount);\n    }\n}\n\n\n\n\n\n\n"},"contracts/Hyflate/IERC20.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.8;\n\ninterface IERC20 {\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"contracts/Hyflate/Ownable.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.8;\n\ncontract Ownable {\n  address private _owner;\n  constructor() public {\n    _owner = msg.sender;\n  }\n  modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n  }\n  function owner(\n  ) public view returns (address) {\n    return _owner;\n  }\n  function isOwner(\n  ) public view returns (bool) {\n    return msg.sender == _owner;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n"},"contracts/Hyflate/Pausable.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.8;\nimport \"./Ownable.sol\";\ncontract Pausable is Ownable {\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n    modifier whenNotPaused()\n    {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n    constructor() internal {}\n    function paused(\n    ) public view returns (bool)\n    {\n        return _paused;\n    }\n    function pause(\n    ) public\n        onlyOwner\n        whenNotPaused\n    {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n    function unpause(\n    ) public\n        onlyOwner\n        whenPaused\n    {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"},"contracts/Hyflate/SafeMath.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.8;\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n"}}}