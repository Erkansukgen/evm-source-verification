{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/MultiSigWallet.sol": {
      "content": "pragma solidity ^0.8.6;\n\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//SPDX-License-Identifier: None\ncontract MultiSigWallet {\n\n    address public _owner;\n    mapping(address => uint8) public _owners;\n    address [] ownerlist;\n    \n    uint constant MIN_SIGNATURES = 2;\n    uint private _transactionIdx;\n\n    struct Transaction {\n      address from;\n      address payable to; \n      uint amount;\n      uint8 signatureCount;\n      bool isActive;\n      address tokenAddr;\n    }\n\n    mapping (uint => Transaction) public _transactions;\n   \n    mapping (uint => mapping (address => uint8)) public signatures;\n    \n    uint[] public pendingTxIds;\n    uint public pendingTxCnt;\n    uint public totalTxCnt;\n    modifier isOwner() {\n        require(msg.sender == _owner);\n        _;\n    }\n\n    modifier validOwner() {\n        require(msg.sender == _owner || _owners[msg.sender] == 1);\n        _;\n    }\n\n    event DepositFunds(address from, uint amount);\n    event TransactionCreated(address from, address to, uint amount, uint transactionId);\n    event TransactionCompleted(address from, address to, uint amount, uint transactionId);\n    event MultiTransactionCompleted(address from, address to, uint amount, uint[] transactionId);\n    event TransactionSigned(address by, uint transactionId);\n    event multiTransactionSigned(address by, uint[] transactionId);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function addOwner(address owner)\n        isOwner\n        public {\n            ownerlist.push(owner);\n        _owners[owner] = 1;\n    }\n\n    function removeOwner(address owner)\n        isOwner\n        public {\n           \n        _owners[owner] = 0;\n    }\n\n    receive() external payable {\n        emit DepositFunds(msg.sender, msg.value);\n    }\n\n    \n\n    function transferTo(address payable to, uint amount)\n        public  returns (uint ){\n        require(address(this).balance >= amount);\n        uint transactionId = _transactionIdx++;\n\n        \n        _transactions[transactionId] = Transaction(msg.sender,to,amount,0,true,address(0x0));\n       \n        totalTxCnt++;\n        pendingTxCnt++;\n        pendingTxIds.push(transactionId);\n        \n        signatures[transactionId][msg.sender] = 1;\n        _transactions[transactionId].signatureCount++;\n        emit TransactionCreated(msg.sender, to, amount, transactionId);\n        return transactionId;\n    }\n    \n    function transferTokenTo(address tokenAddress,address payable to, uint amount)\n        public  returns (uint ){\n        IERC20 token = IERC20(tokenAddress);    \n        uint tokenBalance = token.balanceOf(address(this));    \n        require(tokenBalance >= amount);\n        uint transactionId = _transactionIdx++;\n\n        \n        _transactions[transactionId] = Transaction(msg.sender,to,amount,0,true,tokenAddress);\n       \n        totalTxCnt++;\n        pendingTxCnt++;\n        pendingTxIds.push(transactionId);\n        \n        signatures[transactionId][msg.sender] = 1;\n        _transactions[transactionId].signatureCount++;\n        emit TransactionCreated(msg.sender, to, amount, transactionId);\n        return transactionId;\n    }    \n\n    function getPendingTransactions()\n      public\n      view\n      returns (address [] memory, address [] memory, uint [] memory, uint [] memory,address [] memory) {\n          uint getPendTxLength = pendingTxIds.length;\n          address[] memory fromAddress = new address[](getPendTxLength);\n          address[] memory toAddress = new address[](getPendTxLength);\n          uint[] memory userAmount = new uint[](getPendTxLength);\n          uint[] memory userSignatureCount = new uint[](getPendTxLength);\n          address[] memory tokenAddr = new address[](getPendTxLength);\n          uint i;\n          for(i = 0; i < getPendTxLength; i++){\n                fromAddress[i] = _transactions[i].from;\n                toAddress[i] = _transactions[i].to;\n                userAmount[i] = _transactions[i].amount;\n                userSignatureCount[i] = _transactions[i].signatureCount;\n                tokenAddr[i] = _transactions[i].tokenAddr;\n          }\n        return (fromAddress, toAddress, userAmount, userSignatureCount,tokenAddr);\n    }\n    \n   \n    function signTransaction(uint transactionId)\n      validOwner\n      public {\n\n      Transaction storage transaction = _transactions[transactionId];\n      address tokenAddress  = transaction.tokenAddr;\n      // Transaction must exist\n      require(address(0x0) != transaction.from);\n      // Creator cannot sign the transaction\n      require(msg.sender != transaction.from);\n      // Cannot sign a transaction more than once\n      require(signatures[transactionId][msg.sender] != 1);\n\n      signatures[transactionId][msg.sender] = 1;\n      transaction.signatureCount++;\n\n      emit TransactionSigned(msg.sender, transactionId);\n\n      if (transaction.signatureCount >= MIN_SIGNATURES) {\n          if(tokenAddress==address(0x0)){\n              require(address(this).balance >= transaction.amount);\n              transaction.to.transfer(transaction.amount);\n          }\n          else {\n              IERC20 token = IERC20(tokenAddress);    \n              uint tokenBalance = token.balanceOf(address(this)); \n              require(tokenBalance >= transaction.amount);\n              token.transfer(transaction.to,transaction.amount);\n          }\n       emit  TransactionCompleted(transaction.from, transaction.to, transaction.amount, transactionId);\n        deleteTransaction(transactionId);\n      }\n    }\n\n\n function signTransactionMulti(uint[] memory transactionIds)\n      validOwner\n      public {\n        require(transactionIds.length>0,\"Transaction Id required\");\n        for(uint i=0; i<transactionIds.length; i++) {\n            uint transactionId = transactionIds[i];\n          Transaction storage transaction = _transactions[transactionId];\n          address tokenAddress  = transaction.tokenAddr;\n          // Transaction must exist\n          if(address(0x0) == transaction.from){ return; }\n          // Creator cannot sign the transaction\n          if(msg.sender == transaction.from){ return; }\n          // Cannot sign a transaction more than once\n          if(signatures[transactionId][msg.sender] == 1){ return; }\n    \n          signatures[transactionId][msg.sender] = 1;\n          transaction.signatureCount++;\n    \n         \n    \n          if (transaction.signatureCount >= MIN_SIGNATURES) {\n              if(tokenAddress==address(0x0)){\n                  if(address(this).balance < transaction.amount){ return; }\n                  transaction.to.transfer(transaction.amount);\n              }\n              else {\n                  IERC20 token = IERC20(tokenAddress);    \n                  uint tokenBalance = token.balanceOf(address(this)); \n                  if(tokenBalance < transaction.amount){ return; }\n                  token.transfer(transaction.to,transaction.amount);\n              }\n           \n            deleteTransaction(transactionId);\n          }\n        }\n         emit multiTransactionSigned(msg.sender, transactionIds);\n       // emit  MultiTransactionCompleted(transaction.from, transaction.to, transaction.amount, transactionIds);\n    }\n\n    function deleteTransaction(uint transactionId)\n      validOwner\n      public {\n     _transactions[transactionId].isActive = false;\n     reestPendingTx(transactionId);\n     pendingTxCnt--;\n    }\n\n    \n   function reestPendingTx(uint removetxId) internal {\n       uint[] memory collect = pendingTxIds;\n       delete pendingTxIds;\n       for(uint i=0; i < collect.length;i++){\n            if(collect[i] != removetxId){\n                pendingTxIds.push(collect[i]);\n            }\n       }\n   }\n\n\n    function walletBalance()\n      public \n      view\n      returns (uint) {\n      return address(this).balance;\n    }\n    \n    \n    function showOwnerList()\n      public\n      view\n      returns (address [] memory, uint [] memory) {\n          uint ownerlistLength = ownerlist.length;\n          address[] memory ownersAddress = new address[](ownerlistLength);\n          uint[] memory ownerStatus = new uint[](ownerlistLength);\n\n          \n          for(uint i = 0; i < ownerlistLength; i++) {\n                ownersAddress[i] = ownerlist[i];\n                ownerStatus[i] = _owners[ownerlist[i]];\n          }\n        return (ownersAddress, ownerStatus);\n    }\n    \n    function withdrawEthByOwner(uint amount,address payable to)\n        isOwner\n        public {\n        require(address(this).balance >= amount);\n        to.transfer(amount);\n    }\n    \n    function withdrawTokenByOwner(address tokenAddress,uint amount,address payable to)\n        isOwner\n        public {\n          IERC20 token = IERC20(tokenAddress);    \n          uint tokenBalance = token.balanceOf(address(this)); \n          require(tokenBalance >= amount);\n          token.transfer(to,amount);\n    }\n  \n}"
    }
  }
}