{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/contracts/IERC20.sol":{"content":"pragma solidity ^0.6.0;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"localhost/contracts/IUniswapExchange.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\n\n\ninterface IUniswapExchange {\n    // Protocol Functions\n    function tokenAddress() external view returns (address);\n\n    function factoryAddress() external view returns (address);\n\n    // ERC20 Functions (Keep track of liquidity providers)\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256);\n\n    // Pricing functions\n    function getEthToTokenInputPrice(uint256 eth_sold)\n        external\n        view\n        returns (uint256);\n\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\n        external\n        view\n        returns (uint256);\n\n    function getTokenToEthInputPrice(uint256 tokens_sold)\n        external\n        view\n        returns (uint256);\n\n    function getTokenToEthOutputPrice(uint256 eth_bought)\n        external\n        view\n        returns (uint256);\n\n    // Add Liquidity\n    function setup(address token_addr) external;\n\n    function addLiquidity(\n        uint256 min_liquidity,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline)\n        external\n        returns (uint256);\n\n    //Eth/Token Swap\n    //Sell all ETH\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)\n        external\n        payable\n        returns (uint256);\n\n    function ethToTokenTransferInput(\n        uint256 min_tokens,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256);\n\n    //Sell some ETH and get refund\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)\n        external\n        payable\n        returns (uint256);\n\n    function ethToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256);\n\n    //Token/Eth Swap\n    //Sell all tokens\n    function tokenToEthSwapInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function tokenToEthTransferInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256);\n\n    //Sell some tokens and get refund\n    function tokenToEthSwapOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function tokenToEthTransferOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256);\n\n    //Token/Token Swap\n    function tokenToTokenSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address token_addr\n    ) external returns (uint256);\n\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256);\n\n    function tokenToTokenSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address token_addr\n    ) external returns (uint256);\n\n    function tokenToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256);\n\n    //Token/Exchange Swap\n    function tokenToExchangeSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address exchange_addr\n    ) external returns (uint256);\n\n    function tokenToExchangeTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    ) external returns (uint256);\n\n    function tokenToExchangeSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address exchange_addr\n    ) external returns (uint256);\n\n    function tokenToExchangeTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    ) external returns (uint256);\n}\n"},"localhost/contracts/UniswapOTC.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\n\nimport \"./IUniswapExchange.sol\";\nimport \"./IERC20.sol\";\n\n\ncontract UniswapOTC {\n    address owner; //OTC owner, earns fee\n    address client; //OTC client, manages funds and limit price\n\n    address public exchangeAddress;\n    address public tokenAddress;\n\n    IERC20 token;\n    IUniswapExchange exchange;\n\n    //Min volume values\n    uint256 public minEthLimit;\n    uint256 public maxTokenPerEth;\n\n    uint256 public minTokens; //Limit price set by client\n    uint256 public totalPurchased;\n    uint256 public totalFees;\n\n    mapping(address => bool) triggerAddresses; //Bot trigger permissions\n\n    event OTCPurchase(uint256 tokens_bought, uint256 fee);      //Purchased\n    event OTCDeposit(uint256 minTokens, uint256 etherAmount);   //Reset limit price\n\n    constructor(address _exchangeAddress, address _client, uint256 _minEthLimit, uint256 _maxTokenPerEth) public {\n        exchange = IUniswapExchange(_exchangeAddress);\n        exchangeAddress = exchangeAddress;\n        tokenAddress = exchange.tokenAddress();\n        token = IERC20(tokenAddress);\n        totalPurchased = 0;\n        totalFees = 0;\n        owner = msg.sender;\n        client = _client;\n        minEthLimit = _minEthLimit;\n        maxTokenPerEth = _maxTokenPerEth;\n        minTokens = 0; //Initialize at 0\n    }\n\n    /**\n     * @dev OTC Provider. Gives right to fee withdrawal.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized\");\n        _;\n    }\n\n    /**\n     * @dev OTC Client. Manages funds and limit price.\n     */\n    modifier onlyClient() {\n        require(msg.sender == client, \"Unauthorized\");\n        _;\n    }\n\n    /**\n     * @dev Authorized Purchase Trigger addresses for mempool bot.\n     */\n    modifier onlyTrigger() {\n        require(msg.sender == owner || triggerAddresses[msg.sender], \"Unauthorized\");\n        _;\n    }\n\n    /**\n     * @dev Add Trigger address.\n     */\n    function setTriggerAddress(address _address, bool _authorized)\n        public\n        onlyOwner\n    {\n        triggerAddresses[_address] = _authorized;\n    }\n\n    /**\n     * @dev Fund contract and set limit price (in the form of min purchased tokens).\n     * Excess value is refunded to sender in the case of a re-balancing.\n     */\n    function setMinTokens(uint256 _minTokens, uint256 _etherAmount)\n        public\n        payable\n        onlyClient\n    {\n        require(_etherAmount >= minEthLimit, \"Insufficient ETH volume\");\n        require((_minTokens / _etherAmount) <= maxTokenPerEth, \"Excessive token per ETH\");\n        require(_etherAmount <= address(this).balance, \"Insufficient funds!\");\n        //Set min tokens.\n        minTokens = _minTokens;\n        //Refund excess balance\n        uint256 excess_balance = address(this).balance - _etherAmount;\n\n        emit OTCDeposit(_minTokens, _etherAmount);\n        payable(msg.sender).transfer(excess_balance);\n    }\n\n\n    /**\n     * @dev Return if purchase would be autherized at current prices\n     */\n    function canPurchase()\n        public\n        view\n        returns (bool)\n    {\n        uint256 eth_balance = address(this).balance;\n\n        uint256 tokens_bought = exchange.getEthToTokenInputPrice(eth_balance);\n        //Only buy less than or equal to limit price\n        return tokens_bought >= minTokens;\n    }\n\n    /**\n     * @dev Trigger Uniswap contract, drains entire contract's ETH balance.\n     *      Computes fee as minimum of either the estimated slippage (best case) or\n     *      spread from limit price (when slippage would be above limit price).\n     */\n    function sendPurchase(uint256 deadline)\n        public\n        onlyTrigger\n        returns (uint256, uint256)\n    {\n        uint256 eth_balance = address(this).balance;\n\n        uint256 tokens_bought = exchange.getEthToTokenInputPrice(eth_balance);\n        //Only buy less than or equal to limit price\n        require(tokens_bought >= minTokens, \"Purchase above limit price!\");\n        //Call Uniswap contract\n        exchange.ethToTokenSwapInput.value(eth_balance)(\n            tokens_bought,\n            deadline\n        );\n\n        //Fee Calculation as next purchase opportunity cost\n        //tokens_bought > tokens_bought_after\n        uint256 tokens_bought_after = exchange.getEthToTokenInputPrice(\n            eth_balance\n        );\n\n        uint256 fee;\n        if (tokens_bought_after >= minTokens) {\n            fee = tokens_bought - tokens_bought_after; //Upper threshold performance fee\n        } else {\n            //fee = tokens_bought - minTokens\n            fee = tokens_bought - minTokens; //Fee reduced to fit limit price\n        }\n\n        emit OTCPurchase(tokens_bought, fee);\n\n        totalPurchased += tokens_bought;\n        totalFees += fee;\n\n        return (tokens_bought, fee);\n    }\n\n    /**\n     * @dev Withdraw OTC provider fee tokens.\n     */\n    function withdrawFeeTokens() public onlyOwner {\n        require(totalFees > 0, \"No fees!\");\n\n        //Substract fees\n        uint256 feeTransfer = totalFees;\n\n        totalFees = totalFees - feeTransfer; //Update set to 0\n        totalPurchased = totalPurchased - feeTransfer; //Update token balance\n\n        token.transfer(msg.sender, feeTransfer);\n    }\n\n    /**\n     * @dev Withdraw OTC client purchased tokens.\n     */\n    function withdrawClientTokens() public onlyClient {\n        require(totalPurchased > 0, \"No tokens!\");\n\n        token = IERC20(exchange.tokenAddress());\n\n        //Substract fees\n        uint256 clientTokens = totalPurchased - totalFees;\n        totalPurchased = totalPurchased - clientTokens;\n\n        token.transfer(msg.sender, clientTokens);\n    }\n\n    /**\n     * @dev Withdraw OTC client ether.\n     */\n    function withdrawEther() public onlyClient {\n        uint256 eth_balance = address(this).balance;\n        payable(msg.sender).transfer(eth_balance);\n    }\n\n    /**\n     * @dev Get eth balance\n     */\n    function ethBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev Get token balance\n     */\n    function tokenBalance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n}\n"}}}