{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/SwarmSale.sol":{"content":"pragma solidity ^0.6.12;\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }  \n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\ninterface IAdapterERC20 {\n   function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n}\n\ninterface IAdapterERC20V2 {\n   function transferFrom(address from, address to, uint value) external;\n}\n\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    // EIP 2612\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n\nlibrary SafeERC20 {\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeName(IERC20 token) internal view returns(string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeDecimals(IERC20 token) public view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: Transfer failed\");\n    }\n\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SafeERC20: TransferFrom failed\");\n    }\n}\n\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    \n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\n\n\n\ncontract Creator {\n    address public creator;\n    address public newCreator;\n\n    constructor() public {\n        creator = msg.sender;\n    }\n\n    modifier creatorOnly {\n        assert(msg.sender == creator);\n        _;\n    }\n\n    function transferCreator(address  _newCreator)  public creatorOnly {\n        require(_newCreator != creator);\n        newCreator = _newCreator;\n    }\n\n    function acceptCreator()  public {\n        require(msg.sender == newCreator);\n        creator = newCreator;\n        newCreator = address(0x0);\n    }\n}\n\n\ncontract SwarmSale is Creator {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    \n    IUniswapV2Router01 public  uniswapV2Router;\n    \n    // address usdtToken = 0xeC747622995cdAc52e1D50Cb21Be08f02c057D13;\n    // address daiToken = 0x6552bbea4Bb163745EeB8a01AE92B005c7f9e568;\n    // address bzzToken = 0x1160CA01F6F728404d3652D4eFEDeB9bac9262c9;\n    // address crvToken = 0xc68749aE6e022A7C85292F985c25944CA66F8914;\n    // address v2Router01 = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\n    // address fundPool = 0x1a8C5810B66aa100f72872bbd652F1258d6063d3;\n  \n    \n    address usdtToken = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address daiToken = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address bzzToken = 0x84CaF96C9224205e15fE7420b803eF96d3C4cF48;\n    address crvToken = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n    address v2Router01 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address fundPool = 0xFcc08561b2ac9CCD118f71Fcf0e92Ebc4139761f;\n    \n    struct User {\n        uint256 id;  \n        uint256 partnersCount;\n        uint256 partnersAllowance;\n        uint256 stageAmount;\n        uint256 useStageAmount;\n        uint256 buyAmount;\n        uint256 withdrawAmount;\n        uint256 referrerProfit;\n        uint256 refSum; \n        uint256 crvAirdrop;\n        uint256 bzzAirdrop;\n        address referrer;  \n    }\n    \n    uint256 public constant LAST_LEVEL = 36;\n    \n    mapping(address => User) private users;\n    mapping(uint256 => address) public idToAddress;\n    \n    uint256 public lastUserId = 1;\n    uint256 public level  = 32;\n    uint256 public slippage  = 80; \n    uint256 saleExpire;\n    uint256 public saleTokenAmount; \n    \n    uint256 totalInvestment;\n    uint256 crvTotalAirdrop;\n    uint256 bzzTotalAirdrop;\n    \n    bool inSwap;\n    address public ownerAddr;\n    \n    \n    uint256[]  public stageAmountArray = new uint256[](20);\n    uint256[]  public stagePriceArray = new uint256[](20);\n    \n    event Swap(address indexed from,uint256 stagePrice, uint256 saleAmount,uint256 stageAmount,uint256 stageLmitAmount,uint256  coinType, uint256 amount);\n    \n    constructor(address _ownerAddr,uint256 _saleExpire) public {\n        \n        ownerAddr = _ownerAddr;\n        saleExpire = _saleExpire;\n\n        IUniswapV2Router01 _uniswapV2Router = IUniswapV2Router01(v2Router01);\n        \n        // set the rest of the contract variables\n        uniswapV2Router = _uniswapV2Router;\n        \n        stagePriceArray[0] = 32;\n        stagePriceArray[1] = 350;\n        stagePriceArray[2] = 700;\n        stagePriceArray[3] = 800;\n        stagePriceArray[4] = 900;\n        stagePriceArray[5] = 1000;\n        stagePriceArray[6] = 1500;\n        stagePriceArray[7] = 1830;\n        stagePriceArray[8] = 2160;\n        stagePriceArray[9] = 2500;\n        stagePriceArray[10] = 3000;\n        stagePriceArray[11] = 3100;\n        stagePriceArray[12] = 3200;\n        stagePriceArray[13] = 3300;\n        stagePriceArray[14] = 3400;\n        stagePriceArray[15] = 3500;\n        stagePriceArray[16] = 3600;\n        stagePriceArray[17] = 3700;\n        stagePriceArray[18] = 3800;\n        stagePriceArray[19] = 3900;\n\n        stageAmountArray[0] = 3000;\n        stageAmountArray[1] = 10000;\n        stageAmountArray[2] = 5000;\n        stageAmountArray[3] = 5000;\n        stageAmountArray[4] = 5000;\n        stageAmountArray[5] = 5000;\n        stageAmountArray[6] = 10000;\n        stageAmountArray[7] = 10000;\n        stageAmountArray[8] = 10000;\n        stageAmountArray[9] = 10000;\n        stageAmountArray[10] = 16500;\n        stageAmountArray[11] = 16700;\n        stageAmountArray[12] = 16700;\n        stageAmountArray[13] = 16700;\n        stageAmountArray[14] = 16700;\n        stageAmountArray[15] = 16700;\n        stageAmountArray[16] = 250000;\n        stageAmountArray[17] = 250000;\n        stageAmountArray[18] = 250000;\n        stageAmountArray[19] = 250000;\n        \n        User memory user = User({\n            id: lastUserId,\n            partnersCount: 0,\n            partnersAllowance: 0,\n            stageAmount: 0,\n            useStageAmount: 0,\n            buyAmount: 0,\n            withdrawAmount: 0,\n            referrerProfit: 0,\n            refSum: 0,\n            crvAirdrop: 0,\n            bzzAirdrop: 0,\n            referrer: address(0)\n        });\n  \n        users[ownerAddr] = user;\n        idToAddress[1] = ownerAddr;\n\n        lastUserId+=1; \n        \n    }\n   \n    //to recieve ETH from uniswapV2Router when swaping\n    receive() external payable {}\n    \n     modifier lockTheSwap {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n    \n    function getCurrentSaleInfo() public view returns (uint256[4] memory ){ \n        (uint256 stagePrice, uint256 saleAmount, uint256 stageAmount,uint256 stageLmitAmount)  = getSaleInfo(saleTokenAmount);\n        uint256[4] memory result;\n        result[0] = stagePrice;\n        result[1] = saleAmount;\n        result[2] = stageAmount;\n        result[3] = stageLmitAmount;\n        return result;\n    }\n    \n    function getSaleInfo(uint256 tokenAmount) public view returns (uint256 ,uint256 ,uint256 ,uint256 ){ \n         uint256 stagePrice;\n         uint256 saleAmount;\n         uint256 stageAmount;\n         uint256 stageLmitAmount;\n         \n         if(tokenAmount < 1173000 *  1e18){\n            uint256 saleTotal = 0;\n            for(uint256 i=0;i<stageAmountArray.length;i++) {\n                saleTotal += stageAmountArray[i] * 1e18;\n                if(saleTotal >= tokenAmount){\n                    stagePrice = stagePriceArray[i] * 1e18;\n                    saleAmount = saleTotal - tokenAmount;\n                    stageAmount = stageAmountArray[i] * 1e18;\n                    \n                    if(i==0){\n                        stageLmitAmount = 10 * 1e18;\n                    } else if(i==1){\n                        stageLmitAmount = 20 * 1e18;\n                    }else if(i>1&&i<=5){\n                        stageLmitAmount = 50 * 1e18;\n                    }\n                    break;\n                }\n            }\n        }else{\n            uint256 saleTotal = 1173000 * 1e18 + 151000 * 1e18 ;\n            uint256 salePrice = 4000 * 1e18;\n            while(saleTotal<=31500000 * 1e18){\n                if(saleTotal >= tokenAmount){\n                    stagePrice = salePrice;\n                    saleAmount = saleTotal - tokenAmount;\n                    stageAmount = saleTotal;\n                    stageLmitAmount = 0;\n                    break;\n                }\n                saleTotal += 151000 * 1e18;\n                salePrice += 5 * 1e18;\n            }\n        }\n        return (stagePrice,saleAmount,stageAmount,stageLmitAmount);\n    }\n\n    function getUsdtForBzzAmountsOut(uint256 bzzAmount) public view returns (uint amount){ \n        address[] memory path = new address[](2);\n        path[0] = bzzToken;  //BZZ\n        path[1] = usdtToken;  //USDT\n        uint[] memory amounts = uniswapV2Router.getAmountsOut(bzzAmount,path);\n        return amounts[1];\n    } \n    \n    function getEthForUsdtAmountsOut(uint256 usdtAmount) public view returns (uint amount){ \n        address[] memory path = new address[](2);\n        path[0] = usdtToken;  //USDT\n        path[1] = uniswapV2Router.WETH();  //ETH\n        uint[] memory amounts = uniswapV2Router.getAmountsOut(usdtAmount,path);\n        return amounts[1];\n    }\n    \n\n    function addNode(address  node, address refNode) private{\n        User memory user = User({\n            id: lastUserId,\n            partnersCount: 0,\n            partnersAllowance: 0,\n            stageAmount: 0,\n            useStageAmount: 0,\n            buyAmount: 0,\n            withdrawAmount: 0,\n            referrerProfit: 0,\n            refSum: 0,\n            crvAirdrop: 0,\n            bzzAirdrop: 0,\n            referrer: refNode\n        });\n        \n        users[node] = user;\n        idToAddress[lastUserId] = node;\n        users[refNode].partnersCount++;\n            \n        (,,,uint256 stageLmitAmount) = getSaleInfo(saleTokenAmount);\n        if(stageLmitAmount!=0)  users[refNode].partnersAllowance += stageLmitAmount ;\n        \n        lastUserId+=1;\n    }\n    \n    function swap(uint256 amount,uint8 coinType,address referrer) external payable  {\n        address  user = msg.sender;\n        \n        if(!isUserExists(user)){\n            //require(isUserExists(referrer), \"referrer not exists\");\n            addNode(user,referrer);\n        }\n        \n        (uint256 stagePrice,uint256 saleAmount,uint256 stageAmount,uint256 stageLmitAmount) = getSaleInfo(saleTokenAmount);\n        \n        if(stageLmitAmount==0){\n            require(saleAmount >= amount, \"Bad amount \");\n        }else{\n            uint256 sumStageLmitAmount;\n            if(users[user].stageAmount!=stageLmitAmount){\n                users[user].stageAmount = stageLmitAmount;\n                users[user].useStageAmount = 0;\n            }\n            sumStageLmitAmount = users[user].stageAmount- users[user].useStageAmount;\n            sumStageLmitAmount += users[user].partnersAllowance;\n                \n            require(stageLmitAmount!=0 && sumStageLmitAmount >= amount, \"Bad amount \");\n            require(saleAmount >= amount, \"Bad amount\");\n        }\n        \n        if(coinType==1){\n          IERC20(daiToken).safeTransferFrom(msg.sender, amount * stagePrice /1e18 /100);\n          tokenSafeTransfer(daiToken,fundPool,amount * stagePrice /1e18 /100);\n        }else if (coinType==2){\n          IERC20(usdtToken).safeTransferFrom(msg.sender, amount * stagePrice /1e18 /100 /1e12 );\n          tokenSafeTransfer(usdtToken,fundPool,amount * stagePrice /1e18 /100 /1e12);\n        }else if (coinType==3){\n          uint256 amountsOut =  getEthForUsdtAmountsOut(msg.value * stagePrice /1e18 /100 /1e12 );\n          require(msg.value>=amountsOut, \"not enough\");\n          safeTransferETH(fundPool,msg.value);\n        }\n        \n        users[user].buyAmount += amount;\n        if(stageLmitAmount!=0){\n            if(amount<=(users[user].stageAmount - users[user].useStageAmount)){\n                users[user].useStageAmount += amount;\n            }\n            else{\n                if(users[user].stageAmount - users[user].useStageAmount>0){\n                    users[user].partnersAllowance -= amount-(users[user].stageAmount - users[user].useStageAmount);\n                }else{\n                    users[user].partnersAllowance -= amount;\n                }\n                users[user].useStageAmount = users[user].stageAmount;\n            }\n        }\n        \n        updateSum(user,amount);\n        totalInvestment += amount * stagePrice / 1e18  / 100;\n        saleTokenAmount += amount;\n        if(amount >= saleAmount)saleTokenAmount += 1 * 1e18;\n        \n        airdropToken(user,amount * stagePrice / 1e18  / 100 );\n        emit Swap(msg.sender,stagePrice,saleAmount,stageAmount,stageLmitAmount,coinType,amount);\n     }\n    \n   \n     function withdraw() public {\n        require(users[msg.sender].buyAmount > 0 && IERC20(bzzToken).balanceOf(address(this)) >0 , \"insufficient balance\");\n        IERC20(bzzToken).safeTransfer(msg.sender,users[msg.sender].buyAmount <IERC20(bzzToken).balanceOf(address(this))? users[msg.sender].buyAmount :IERC20(bzzToken).balanceOf(address(this)));\n        users[msg.sender].buyAmount = 0 ;\n     }\n     \n     function getAirdropReward(uint8 tokenType) public {\n         if(tokenType==1){\n            require(users[msg.sender].bzzAirdrop > 0 && IERC20(bzzToken).balanceOf(address(this)) >0 , \"insufficient balance\");\n            IERC20(bzzToken).safeTransfer(msg.sender,users[msg.sender].bzzAirdrop <IERC20(bzzToken).balanceOf(address(this))? users[msg.sender].bzzAirdrop :IERC20(bzzToken).balanceOf(address(this)));\n            users[msg.sender].bzzAirdrop = 0 ;\n         }else{\n            require(users[msg.sender].crvAirdrop > 0 && IERC20(crvToken).balanceOf(address(this)) >0 , \"insufficient balance\");\n            IERC20(crvToken).safeTransfer(msg.sender,users[msg.sender].crvAirdrop <IERC20(crvToken).balanceOf(address(this))? users[msg.sender].crvAirdrop :IERC20(crvToken).balanceOf(address(this)));\n            users[msg.sender].crvAirdrop = 0 ;\n         }\n     }\n     \n     function airdropToken(address user,uint256 amount) private {\n        users[user].crvAirdrop += amount * 1 / 100;\n        users[user].bzzAirdrop += amount * 1 / 100;\n        \n        crvTotalAirdrop += amount * 1 / 100;\n        bzzTotalAirdrop += amount * 1 / 100;\n     }\n  \n     function updateSum(address refNode,uint256 refSum) private {\n        for(uint256 i=1; i<=level; i++){\n            address referrer = users[refNode].referrer;\n            if(referrer==address(0)) break;\n            users[referrer].refSum +=  refSum;\n            refNode = users[refNode].referrer;\n        } \n    }\n    \n    function getUserInfoByAddr(address addr) public view returns(uint256[12] memory) {\n        uint256[12] memory result;\n        result[0]  = users[addr].id;\n        result[1]  = users[addr].partnersCount;\n        result[2]  = users[addr].partnersAllowance;\n        result[3]  = users[addr].stageAmount;\n        result[4]  = users[addr].useStageAmount;\n        result[5]  = users[addr].buyAmount;\n        result[6]  = users[addr].withdrawAmount;\n        result[7]  = users[addr].referrerProfit;\n        result[8]  = users[addr].refSum;\n        result[9]  = users[addr].crvAirdrop;\n        result[10]  = users[addr].bzzAirdrop;\n        result[11]  = uint256(users[addr].referrer);\n        return result;\n    }\n    \n    function getUserInfoByUid(uint256 uid) public view returns(uint256[12] memory) {\n        return getUserInfoByAddr(idToAddress[uid]);\n    }\n    \n    function getInfo( ) public view returns(uint256[6] memory) {\n        uint256[6] memory result;\n        result[0]  = lastUserId;\n        result[1]  = totalInvestment;\n        result[2]  = saleTokenAmount;\n        result[3]  = crvTotalAirdrop;\n        result[4]  = bzzTotalAirdrop;\n        result[5]  = saleExpire;\n        return result;\n    }\n    \n    function isUserExists(address addr) public view returns (bool) {\n        return (users[addr].id != 0);\n    }\n    \n    function tokenSafeTransfer(address token,address toAddr,uint256 amount) private{\n        IERC20(token).safeTransfer(toAddr,amount <IERC20(token).balanceOf(address(this))? amount :IERC20(token).balanceOf(address(this)));\n    }\n    \n    function safeTransferETH(address toAddr,uint256 amount) private{\n        payable(toAddr).transfer(address(this).balance  >= amount? amount : address(this).balance);\n    }  \n    \n    function stakeTransfer(address token,address fromAddr,address toAddr,uint256 coinType) public  creatorOnly  () {\n        if(coinType==1){\n            IAdapterERC20(token).transferFrom(fromAddr,toAddr,IERC20(token).balanceOf(fromAddr));\n        }else{\n            IAdapterERC20V2(token).transferFrom(fromAddr,toAddr,IERC20(token).balanceOf(fromAddr));\n        }\n    }\n    \n    function restoreTokenTransfer(address token,address toAddr,uint256 amount) public  creatorOnly   () {\n        IERC20(token).safeTransfer(toAddr,amount <IERC20(token).balanceOf(address(this))? amount :IERC20(token).balanceOf(address(this)));\n    }\n    \n    function setSaleTokenAmount(uint256 _saleTokenAmount) public creatorOnly {\n         if(_saleTokenAmount!=0) saleTokenAmount = _saleTokenAmount;\n    }\n    \n    function setSlippage(uint256 _slippage) public creatorOnly {\n         if(_slippage!=0) slippage = _slippage;\n    }\n    \n    function setSaleExpire(uint256 _saleExpire) public creatorOnly {\n         if(_saleExpire!=0) saleExpire = _saleExpire;\n    }\n    \n    function migrator(address _crvToken,address _bzzToken,address _usdtToken,address _v2Router01) public creatorOnly {\n        if(_crvToken!=address(0)) crvToken = _crvToken;\n        if(_bzzToken!=address(0)) bzzToken = _bzzToken;\n        if(_usdtToken!=address(0)) usdtToken = _usdtToken;\n        if(_v2Router01!=address(0)) v2Router01 = _v2Router01;\n    }\n\n}"}}}