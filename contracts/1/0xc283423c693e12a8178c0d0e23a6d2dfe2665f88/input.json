{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/metroverse.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.10;\r\n\r\ninterface IMetroverse {\r\n    function mintNFT(uint256 amount, bool stake) external payable;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n}\r\n\r\ncontract Slave {\r\n    address constant metroverse = address(0x0e9d6552b85BE180d941f1cA73Ae3E318D2D4F1F);\r\n\r\n    constructor() payable {\r\n        if(msg.value >= 0.2 ether) {\r\n            IMetroverse(metroverse).mintNFT{value: 0.2 ether}(2, false);\r\n        } else if(msg.value >= 0.1 ether) {\r\n            IMetroverse(metroverse).mintNFT{value: 0.1 ether}(1, false);\r\n        }\r\n        IMetroverse(metroverse).setApprovalForAll(tx.origin, true);\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n}\r\n\r\ncontract Main {\r\n    address immutable owner;\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    function mint() external payable {\r\n        uint256 balance = address(this).balance;\r\n        while(balance >= 0.1 ether) {\r\n            if(balance >= 0.1 ether) {\r\n                new Slave{value: balance}();\r\n            }\r\n            balance = address(this).balance;\r\n        }\r\n    }\r\n    \r\n    function rescue() external {\r\n        payable(tx.origin).transfer(address(this).balance);\r\n    }\r\n}"
    }
  }
}