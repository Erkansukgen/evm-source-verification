{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"arbitrage_bot.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IKyberNetworkProxy {\r\n\r\n\r\n    function tradeWithHintAndFee(\r\n        IERC20 src,\r\n        uint256 srcAmount,\r\n        IERC20 dest,\r\n        address payable destAddress,\r\n        uint256 maxDestAmount,\r\n        uint256 minConversionRate,\r\n        address payable platformWallet,\r\n        uint256 platformFeeBps,\r\n        bytes calldata hint\r\n    ) external payable returns (uint256 destAmount);\r\n\r\n    \r\n}\r\n\r\ninterface UniswapRouter {\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function WETH() external pure returns (address);\r\n}\r\n\r\n\r\n\r\ninterface IContractRegistry {\r\n    function addressOf(\r\n        bytes32 contractName\r\n    ) external view returns(address);\r\n}\r\n\r\ninterface IBancorNetwork {\r\n    function convertByPath(\r\n        address[] memory _path, \r\n        uint256 _amount, \r\n        uint256 _minReturn, \r\n        address _beneficiary, \r\n        address _affiliateAccount, \r\n        uint256 _affiliateFee\r\n    ) external payable returns (uint256);\r\n\r\n    function rateByPath(\r\n        address[] memory _path, \r\n        uint256 _amount\r\n    ) external view returns (uint256);\r\n\r\n    function conversionPath(\r\n        IERC20 _sourceToken, \r\n        IERC20 _targetToken\r\n    ) external view returns (address[] memory);\r\n}\r\n\r\ncontract arbitrageBot {\r\n    \r\n    address owner;\r\n    \r\n    UniswapRouter public UNIROUTER = UniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    UniswapRouter public SUSHIROUTER = UniswapRouter(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n    IContractRegistry contractRegistry = IContractRegistry(0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4);\r\n    IKyberNetworkProxy Kyber = IKyberNetworkProxy(0x9AAb3f75489902f3a48495025729a0AF77d4b11e);\r\n    bytes32 bancorNetworkName = 'BancorNetwork'; // \"BancorNetwork\"\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function getBancorNetworkContract() public view returns(address){\r\n        return contractRegistry.addressOf(bancorNetworkName);\r\n    }\r\n    \r\n    function sushiToKyber(address token) payable owneronly public{\r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path1 = new address[](2);\r\n        path1[0] = SUSHIROUTER.WETH();\r\n        path1[1] = address(token1);\r\n        \r\n        SUSHIROUTER.swapExactETHForTokens{value: msg.value }( 0 ,path1, address(this), block.timestamp);\r\n\r\n        token1.approve(address(Kyber), token1.balanceOf(address(this)));\r\n        \r\n        Kyber.tradeWithHintAndFee(\r\n            token1,\r\n            token1.balanceOf(address(this)), \r\n            IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),\r\n            payable(msg.sender), \r\n            9999999999999999999999999999999, \r\n            0, \r\n            payable(0x0), \r\n            0, \r\n            '' \r\n        );\r\n    }\r\n    \r\n    function kyberToSushi(address token) payable owneronly public{\r\n        \r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(token1);\r\n        path2[1] = SUSHIROUTER.WETH();\r\n\r\n        Kyber.tradeWithHintAndFee{value: msg.value}(\r\n            IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),\r\n            msg.value, \r\n            token1, \r\n            payable(address(this)), \r\n            9999999999999999999999999999999, \r\n            0, \r\n            payable(0x0), \r\n            0, \r\n            '' \r\n        );\r\n        \r\n        token1.approve(address(SUSHIROUTER), token1.balanceOf(address(this)));\r\n        \r\n        SUSHIROUTER.swapExactTokensForETH( token1.balanceOf(address(this)) , 0 , path2 , msg.sender , block.timestamp );\r\n    }\r\n    \r\n    function bancorToSushi(address token) payable owneronly public{\r\n        \r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(token1);\r\n        path2[1] = SUSHIROUTER.WETH();\r\n        \r\n        IERC20 _sourceToken = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(getBancorNetworkContract());\r\n        address[] memory path = bancorNetwork.conversionPath(\r\n            _sourceToken,\r\n            token1\r\n        );\r\n        uint minReturn = bancorNetwork.rateByPath(\r\n            path,\r\n            msg.value\r\n        );\r\n        \r\n        bancorNetwork.convertByPath{value: msg.value }(\r\n            path,\r\n            msg.value,\r\n            minReturn,\r\n            address(this),\r\n            address(0x0),\r\n            0\r\n        );\r\n        \r\n        token1.approve(address(SUSHIROUTER), token1.balanceOf(address(this)));\r\n        \r\n        SUSHIROUTER.swapExactTokensForETH( token1.balanceOf(address(this)) , 0 , path2 , msg.sender , block.timestamp );\r\n    }\r\n    \r\n    function sushiToBancor(address token) payable owneronly public{\r\n        \r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path1 = new address[](2);\r\n        path1[0] = SUSHIROUTER.WETH();\r\n        path1[1] = address(token1);\r\n        \r\n        SUSHIROUTER.swapExactETHForTokens{value: msg.value }( 0 ,path1, address(this), block.timestamp);\r\n        \r\n        IERC20 _sourceToken = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(getBancorNetworkContract());\r\n        \r\n        address[] memory path = bancorNetwork.conversionPath(\r\n            token1,\r\n            _sourceToken\r\n        );\r\n        // uint minReturn = bancorNetwork.rateByPath(\r\n        //     path,\r\n        //     token1.balanceOf(address(this))\r\n        // );\r\n        \r\n        token1.approve(address(bancorNetwork), token1.balanceOf(address(this)));\r\n        \r\n        \r\n        bancorNetwork.convertByPath(\r\n            path,\r\n            token1.balanceOf(address(this)),\r\n            0,\r\n            msg.sender,\r\n            address(0x0),\r\n            0\r\n        );\r\n    }\r\n    \r\n    function kyberToBancor(address token) payable owneronly public{\r\n        \r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(token1);\r\n        path2[1] = UNIROUTER.WETH();\r\n\r\n        Kyber.tradeWithHintAndFee{value: msg.value}(\r\n            IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),\r\n            msg.value, \r\n            token1, \r\n            payable(address(this)), \r\n            9999999999999999999999999999999, \r\n            0, \r\n            payable(0x0), \r\n            0, \r\n            '' \r\n        );\r\n        \r\n        IERC20 _sourceToken = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(getBancorNetworkContract());\r\n        \r\n        address[] memory path = bancorNetwork.conversionPath(\r\n            token1,\r\n            _sourceToken\r\n        );\r\n        uint minReturn = bancorNetwork.rateByPath(\r\n            path,\r\n            token1.balanceOf(address(this))\r\n        );\r\n        \r\n        token1.approve(address(bancorNetwork), token1.balanceOf(address(this)));\r\n        \r\n        \r\n        bancorNetwork.convertByPath(\r\n            path,\r\n            token1.balanceOf(address(this)),\r\n            minReturn,\r\n            msg.sender,\r\n            address(0x0),\r\n            0\r\n        );\r\n    }\r\n    \r\n    function bancorToKyber(address token) payable owneronly public{\r\n        \r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(token1);\r\n        path2[1] = UNIROUTER.WETH();\r\n        \r\n        IBancorNetwork bancorNetwork = IBancorNetwork(getBancorNetworkContract());\r\n        address[] memory path = bancorNetwork.conversionPath(\r\n            IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),\r\n            token1\r\n        );\r\n        // uint minReturn = bancorNetwork.rateByPath(\r\n        //     path,\r\n        //     msg.value\r\n        // );\r\n        \r\n        bancorNetwork.convertByPath{value: msg.value }(\r\n            path,\r\n            msg.value,\r\n            0,\r\n            address(this),\r\n            address(0x0),\r\n            0\r\n        );\r\n        \r\n        token1.approve(address(Kyber), token1.balanceOf(address(this)));\r\n        \r\n        Kyber.tradeWithHintAndFee(\r\n            token1,\r\n            token1.balanceOf(address(this)), \r\n            IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),\r\n            payable(msg.sender), \r\n            9999999999999999999999999999999, \r\n            0, \r\n            payable(0x0), \r\n            0, \r\n            '' \r\n        );\r\n    }\r\n    \r\n    function uniToKyber(address token) payable owneronly public{\r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path1 = new address[](2);\r\n        path1[0] = UNIROUTER.WETH();\r\n        path1[1] = address(token1);\r\n        \r\n        UNIROUTER.swapExactETHForTokens{value: msg.value }( 0 ,path1, address(this), block.timestamp);\r\n\r\n        token1.approve(address(Kyber), token1.balanceOf(address(this)));\r\n        \r\n        Kyber.tradeWithHintAndFee(\r\n            token1,\r\n            token1.balanceOf(address(this)), \r\n            IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),\r\n            payable(msg.sender), \r\n            9999999999999999999999999999999, \r\n            0, \r\n            payable(0x0), \r\n            0, \r\n            '' \r\n        );\r\n    }\r\n    \r\n    function kyberToUni(address token) payable owneronly public{\r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(token1);\r\n        path2[1] = UNIROUTER.WETH();\r\n\r\n        Kyber.tradeWithHintAndFee{value: msg.value}(\r\n            IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),\r\n            msg.value, \r\n            token1, \r\n            payable(address(this)), \r\n            9999999999999999999999999999999, \r\n            0, \r\n            payable(0x0), \r\n            0, \r\n            '' \r\n        );\r\n        \r\n        token1.approve(address(UNIROUTER), token1.balanceOf(address(this)));\r\n        \r\n        UNIROUTER.swapExactTokensForETH( token1.balanceOf(address(this)) , 0 , path2 , msg.sender , block.timestamp );\r\n        \r\n    }\r\n    \r\n    \r\n    function uniToBancor(address token) payable owneronly public{\r\n        \r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path1 = new address[](2);\r\n        path1[0] = UNIROUTER.WETH();\r\n        path1[1] = address(token1);\r\n        \r\n        UNIROUTER.swapExactETHForTokens{value: msg.value }( 0 ,path1, address(this), block.timestamp);\r\n        \r\n        IERC20 _sourceToken = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(getBancorNetworkContract());\r\n        \r\n        address[] memory path = bancorNetwork.conversionPath(\r\n            token1,\r\n            _sourceToken\r\n        );\r\n        uint minReturn = bancorNetwork.rateByPath(\r\n            path,\r\n            token1.balanceOf(address(this))\r\n        );\r\n        \r\n        token1.approve(address(bancorNetwork), token1.balanceOf(address(this)));\r\n        \r\n        \r\n        bancorNetwork.convertByPath(\r\n            path,\r\n            token1.balanceOf(address(this)),\r\n            minReturn,\r\n            msg.sender,\r\n            address(0x0),\r\n            0\r\n        );\r\n        \r\n    }\r\n    \r\n    function bancorToUni(address token) payable owneronly public{\r\n        \r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(token1);\r\n        path2[1] = UNIROUTER.WETH();\r\n        \r\n        IBancorNetwork bancorNetwork = IBancorNetwork(getBancorNetworkContract());\r\n        address[] memory path = bancorNetwork.conversionPath(\r\n            IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE),\r\n            token1\r\n        );\r\n        uint minReturn = bancorNetwork.rateByPath(\r\n            path,\r\n            msg.value\r\n        );\r\n        \r\n        bancorNetwork.convertByPath{value: msg.value }(\r\n            path,\r\n            msg.value,\r\n            minReturn,\r\n            address(this),\r\n            address(0x0),\r\n            0\r\n        );\r\n        \r\n        token1.approve(address(UNIROUTER), token1.balanceOf(address(this)));\r\n        \r\n        UNIROUTER.swapExactTokensForETH( token1.balanceOf(address(this)) , 0 , path2 , msg.sender , block.timestamp );\r\n    }\r\n    \r\n    function uniToSushi(address token) payable owneronly public{\r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path1 = new address[](2);\r\n        path1[0] = UNIROUTER.WETH();\r\n        path1[1] = address(token1);\r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(token1);\r\n        path2[1] = UNIROUTER.WETH();\r\n        \r\n        UNIROUTER.swapExactETHForTokens{value: msg.value }( 0 ,path1, address(this), block.timestamp);\r\n        \r\n        token1.approve(address(SUSHIROUTER), token1.balanceOf(address(this)));\r\n        \r\n        SUSHIROUTER.swapExactTokensForETH( token1.balanceOf(address(this)) , 0 , path2 , msg.sender , block.timestamp );\r\n    }\r\n    \r\n    function sushiToUni(address token) payable owneronly public{\r\n        IERC20 token1 = IERC20(token);\r\n        \r\n        address[] memory path1 = new address[](2);\r\n        path1[0] = UNIROUTER.WETH();\r\n        path1[1] = address(token1);\r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = address(token1);\r\n        path2[1] = UNIROUTER.WETH();\r\n        \r\n        SUSHIROUTER.swapExactETHForTokens{value: msg.value }( 0 ,path1, address(this), block.timestamp);\r\n        \r\n        token1.approve(address(UNIROUTER), token1.balanceOf(address(this)));\r\n        \r\n        UNIROUTER.swapExactTokensForETH( token1.balanceOf(address(this)) , 0 , path2 , msg.sender , block.timestamp );\r\n    }\r\n    \r\n    \r\n    \r\n    function transfer(address token, uint _amount) owneronly public {\r\n        IERC20 token1 = IERC20(token);\r\n        token1.transfer(msg.sender,_amount);\r\n    }\r\n    \r\n    \r\n    modifier owneronly(){\r\n        require(msg.sender==owner);\r\n        _;\r\n    }\r\n    \r\n    function setOwner(address _new) owneronly public{\r\n        owner = _new;\r\n    }\r\n    \r\n    function withdrawETH(address to) owneronly public{\r\n        uint amount = address(this).balance;\r\n        payable(to).transfer(amount);\r\n    }\r\n    \r\n    function destruct() owneronly public{\r\n        selfdestruct(payable(owner));\r\n    }\r\n    \r\n    \r\n    fallback () external payable { }\r\n    receive () external payable { }\r\n    \r\n    \r\n}"}}}