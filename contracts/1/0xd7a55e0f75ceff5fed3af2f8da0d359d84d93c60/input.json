{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"vault.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Pausable.sol\n\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// File: @openzeppelin/contracts/cryptography/ECDSA.sol\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n// File: contracts/interfaces/IERC721.sol\n\npragma solidity ^0.6.1;\n\n\ninterface IERC721 {\n  function transferFrom(address from, address to, uint256 tokenId) external;\n}\n\n// File: contracts/interfaces/IERC721PreMinteable.sol\n\npragma solidity ^0.6.1;\n\ninterface IERC721PreMinteable {\n    function issueToken(address beneficiary, uint256 optionId, uint256 issuedId) external;\n}\n\n// File: contracts/Vault.sol\n\npragma solidity ^0.6.1;\n\n\n\n\n\n\n\n\ncontract Vault is Ownable, Pausable {\n    using Address for address;\n    using ECDSA for bytes32;\n\n    bytes4 public constant ERC721_RECEIVED = 0x150b7a02;\n\n    mapping(address => bool) public contractWhitelist;\n    mapping(address => bool) public adminWhitelist;\n    mapping(address => bool) public supervisorWhitelist;\n    mapping(bytes32 => bool) public messageProcessed;\n\n    event Deposited(address indexed _owner, address indexed _contract, uint256 indexed _tokenId, bytes _userId);\n    event Withdrawn(address _beneficiary, address indexed _contract, uint256 indexed _tokenId, bytes _userId);\n    event Issued(\n        address _beneficiary,\n        address indexed _contract,\n        uint256 indexed _optionId,\n        uint256 indexed _issuedId,\n        bytes _userId\n    );\n\n    event ContractSet(address indexed _contract, bool _allowed, address indexed _caller);\n    event AdminSet(address indexed _admin, bool _allowed, address indexed _caller);\n    event SupervisorSet(address indexed _supervisor, bool _allowed, address indexed _caller);\n\n\n    /**\n    * @dev Modifier to check whether a caller is an admin\n    */\n    modifier onlyAdmin() {\n        require(adminWhitelist[msg.sender], \"Caller is not an admin\");\n        _;\n    }\n\n    /**\n    * @dev Modifier to check whether a caller is a supervisor\n    */\n    modifier onlySupervisor() {\n        require(supervisorWhitelist[msg.sender], \"Caller is not a supervisor\");\n        _;\n    }\n\n     /**\n     * @dev Called by the owner to pause, triggers stopped state.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Called by the owner to unpause, returns to normal state.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n    * @dev Add or remove an address to the supervisor whitelist\n    * @param _supervisor - Address to be allowed or not\n    * @param _allowed - Whether the contract will be allowed or not\n    */\n    function setSupervisor(address _supervisor, bool _allowed) external onlyOwner {\n        if (_allowed) {\n            require(!supervisorWhitelist[_supervisor], \"The supervisor is already whitelisted\");\n        } else {\n            require(supervisorWhitelist[_supervisor], \"The supervisor is not whitelisted\");\n        }\n\n        supervisorWhitelist[_supervisor] = _allowed;\n        emit SupervisorSet(_supervisor, _allowed, msg.sender);\n    }\n\n    /**\n    * @dev Add or remove a contract to the contract whitelist\n    * @param _contract - Contract to be allowed or not\n    * @param _allowed - Whether the contract will be allowed or not\n    */\n    function setContract(address _contract, bool _allowed) external onlyOwner {\n        if (_allowed) {\n            require(!contractWhitelist[_contract], \"The contract is already whitelisted\");\n            require(_contract.isContract(), \"The address provided is not a contract\");\n        } else {\n            require(contractWhitelist[_contract], \"The contract is not whitelisted\");\n            // require(_contract.balanceOf(address(this)) == 0, \"The vault has tokens of this contract\");\n        }\n\n        contractWhitelist[_contract] = _allowed;\n        emit ContractSet(_contract, _allowed, msg.sender);\n    }\n\n    /**\n    * @dev Add or remove an address to the admin whitelist\n    * @param _admin - Address to be allowed or not\n    * @param _allowed - Whether the contract will be allowed or not\n    */\n    function setAdmin(address _admin, bool _allowed) external onlyOwner {\n        _setAdmin(_admin, _allowed);\n    }\n\n    /**\n    * @dev Remove an address to the admin whitelist\n    * @param _admin - Address to be removed\n    */\n    function removeAdmin(address _admin) external onlySupervisor {\n        _setAdmin(_admin, false);\n    }\n\n     /**\n    * @dev Add or remove an address to the admin whitelist\n    * @param _admin - Address to be allowed or not\n    * @param _allowed - Whether the contract will be allowed or not\n    */\n    function _setAdmin(address _admin, bool _allowed) internal {\n        if (_allowed) {\n            require(!adminWhitelist[_admin], \"The admin is already whitelisted\");\n        } else {\n            require(adminWhitelist[_admin], \"The admin is not whitelisted\");\n        }\n\n        adminWhitelist[_admin] = _allowed;\n\n        emit AdminSet(_admin, _allowed, msg.sender);\n    }\n\n    /**\n    * @notice Handle the receipt of an NFT\n    * @dev The ERC721 smart contract calls this function on the recipient\n    * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n    * otherwise the caller will revert the transaction. The selector to be\n    * returned can be obtained as `this.onERC721Received.selector`. This\n    * function MAY throw to revert and reject the transfer.\n    * Note: the ERC721 contract address is always the message sender.\n    * @param _from - The address which previously owned the token\n    * @param _tokenId - The NFT identifier which is being transferred\n    * @param _data - Additional data with no specified format\n    * @return bytes4 - `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    */\n    function onERC721Received(\n        address /*_operator*/,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external whenNotPaused returns(bytes4) {\n        require(contractWhitelist[msg.sender], \"The contract is not whitelisted\");\n\n        emit Deposited(_from, msg.sender, _tokenId, _data);\n\n        return ERC721_RECEIVED;\n    }\n\n    /**\n    * @dev Withdraw an NFT\n    * @param _beneficiary - Beneficiary's address\n    * @param _contract - NFT contract' address\n    * @param _tokenId - Token id\n    * @param _userId - User id\n    */\n    function withdraw(\n        address _beneficiary,\n        address _contract,\n        uint256 _tokenId,\n        bytes calldata _userId\n    ) external onlyAdmin {\n        _withdraw(_beneficiary, _contract, _tokenId, _userId);\n    }\n\n    /**\n    * @dev Withdraw an NFT by committing a valid signature\n    * @param _beneficiary - Beneficiary's address\n    * @param _contract - NFT contract' address\n    * @param _tokenId - Token id\n    * @param _expires - Expiration of the signature\n    * @param _userId - User id\n    * @param _signature - Signature\n    */\n    function withdraw(\n        address _beneficiary,\n        address  _contract,\n        uint256 _tokenId,\n        uint256 _expires,\n        bytes calldata _userId,\n        bytes calldata _signature\n    ) external {\n        require(_expires >= block.timestamp, \"Expired signature\");\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                _beneficiary,\n                _contract,\n                _tokenId,\n                _expires,\n                _userId\n            )\n        ).toEthSignedMessageHash();\n\n        _validateMessageAndSignature(messageHash, _signature);\n\n        _withdraw(_beneficiary, _contract, _tokenId, _userId);\n    }\n\n    /**\n    * @dev Withdraw many NFTs\n    * @param _beneficiary - Beneficiary's address\n    * @param _contracts - NFT contract' addresses\n    * @param _tokenIds - Token ids\n    * @param _userId - User id\n    */\n    function withdrawMany(\n        address _beneficiary,\n        address[] calldata _contracts,\n        uint256[] calldata _tokenIds,\n        bytes calldata _userId\n    ) external onlyAdmin {\n        require(\n            _contracts.length == _tokenIds.length,\n            \"Contracts and token ids must have the same length\"\n        );\n\n        _withdrawMany(_beneficiary, _contracts, _tokenIds, _userId);\n    }\n\n    /**\n    * @dev Withdraw many NFTs by committing a valid signature\n    * @param _beneficiary - Beneficiary's address\n    * @param _contracts - NFT contract' addresses\n    * @param _tokenIds - Token ids\n    * @param _expires - Expiration of the signature\n    * @param _userId - User id\n    * @param _signature - Signature\n    */\n    function withdrawMany(\n        address _beneficiary,\n        address[] calldata _contracts,\n        uint256[] calldata _tokenIds,\n        uint256 _expires,\n        bytes calldata _userId,\n        bytes calldata _signature\n    ) external {\n        require(_expires >= block.timestamp, \"Expired signature\");\n        require(\n            _contracts.length == _tokenIds.length,\n            \"Contracts and token ids must have the same length\"\n        );\n\n        bytes memory transferData;\n\n        for (uint256 i = 0; i < _contracts.length; i++) {\n            transferData = abi.encodePacked(\n                transferData,\n                abi.encode(\n                    _contracts[i],\n                    _tokenIds[i]\n                )\n            );\n        }\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                _beneficiary,\n                transferData,\n                _expires,\n                _userId\n            )\n        )\n        .toEthSignedMessageHash();\n\n        _validateMessageAndSignature(messageHash, _signature);\n\n        _withdrawMany(_beneficiary, _contracts, _tokenIds, _userId);\n    }\n\n    /**\n    * @dev Withdraw many NFTs\n    * @param _beneficiary - Beneficiary's address\n    * @param _contracts - NFT contract' addresses\n    * @param _tokenIds - Token ids\n    * @param _userId - User id\n    */\n    function _withdrawMany(\n        address _beneficiary,\n        address[] memory _contracts,\n        uint256[] memory _tokenIds,\n        bytes memory _userId\n    ) internal whenNotPaused {\n        for (uint256 i = 0; i < _contracts.length; i++) {\n            _withdraw(_beneficiary, _contracts[i], _tokenIds[i], _userId);\n        }\n    }\n\n    /**\n    * @dev Withdraw an NFT\n    * @param _beneficiary - Beneficiary's address\n    * @param _contract - NFT contract' address\n    * @param _tokenId - Token id\n    * @param _userId - User id\n    */\n    function _withdraw(\n        address _beneficiary,\n        address _contract,\n        uint256 _tokenId,\n        bytes memory _userId\n    ) internal whenNotPaused {\n        IERC721(_contract).transferFrom(address(this), _beneficiary, _tokenId);\n\n        emit Withdrawn(_beneficiary, _contract, _tokenId, _userId);\n    }\n\n    /**\n    * @dev Withdraw an NFT by minting it\n    * @param _beneficiary - Beneficiary's address\n    * @param _contract - NFT contract' address\n    * @param _optionId - Option id\n    * @param _issuedId - Issued id\n    * @param _userId - User id\n    */\n    function issueToken(\n        address _beneficiary,\n        address _contract,\n        uint256 _optionId,\n        uint256 _issuedId,\n        bytes calldata _userId\n    ) external onlyAdmin {\n        _issueToken(\n            _beneficiary,\n            _contract,\n            _optionId,\n            _issuedId,\n            _userId\n        );\n    }\n\n    /**\n    * @dev Withdraw NFTs by minting them\n    * @param _beneficiary - Beneficiary's address\n    * @param _contracts - NFT contract' addresses\n    * @param _optionIds - Option ids\n    * @param _issuedIds - Issued ids\n    * @param _userId - User id\n    */\n    function issueManyTokens(\n        address _beneficiary,\n        address[] calldata _contracts,\n        uint256[] calldata _optionIds,\n        uint256[] calldata _issuedIds,\n        bytes calldata _userId\n    ) external onlyAdmin {\n        require(\n            _contracts.length == _optionIds.length,\n            \"Contracts and option ids must have the same length\"\n        );\n        require(\n            _optionIds.length == _issuedIds.length,\n            \"Option ids and issued ids must have the same length\"\n        );\n\n        _issueManyTokens(\n            _beneficiary,\n            _contracts,\n            _optionIds,\n            _issuedIds,\n            _userId\n        );\n    }\n\n    /**\n    * @dev Withdraw an NFT by minting it committing a valid signature\n    * @param _beneficiary - Beneficiary's address\n    * @param _contract - NFT contract' address\n    * @param _optionId - Option id\n    * @param _issuedId - Issued id\n    * @param _expires - Expiration of the signature\n    * @param _userId - User id\n    * @param _signature - Signature\n    */\n    function issueToken(\n        address _beneficiary,\n        address _contract,\n        uint256 _optionId,\n        uint256 _issuedId,\n        uint256 _expires,\n        bytes calldata _userId,\n        bytes calldata _signature\n    ) external {\n        require(_expires >= block.timestamp, \"Expired signature\");\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                _beneficiary,\n                _contract,\n                _optionId,\n                _issuedId,\n                _expires,\n                _userId\n            )\n        ).toEthSignedMessageHash();\n\n        _validateMessageAndSignature(messageHash, _signature);\n\n        _issueToken(\n            _beneficiary,\n            _contract,\n            _optionId,\n            _issuedId,\n            _userId\n        );\n    }\n\n    /**\n    * @dev Withdraw NFTs by minting them\n    * @param _beneficiary - Beneficiary's address\n    * @param _contracts - NFT contract' addresses\n    * @param _optionIds - Option ids\n    * @param _issuedIds - Issued ids\n    * @param _expires - Expiration of the signature\n    * @param _userId - User id\n    * @param _signature - Signature\n    */\n    function issueManyTokens(\n        address _beneficiary,\n        address[] calldata _contracts,\n        uint256[] calldata _optionIds,\n        uint256[] calldata _issuedIds,\n        uint256 _expires,\n        bytes calldata _userId,\n        bytes calldata _signature\n    ) external {\n        require(_expires >= block.timestamp, \"Expired signature\");\n        require(\n            _contracts.length == _optionIds.length,\n            \"Contracts and option ids must have the same length\"\n        );\n        require(\n            _optionIds.length == _issuedIds.length,\n            \"Option ids and issued ids must have the same length\"\n        );\n\n\n        bytes memory mintData;\n\n        for (uint256 i = 0; i < _contracts.length; i++) {\n            mintData = abi.encodePacked(\n                mintData,\n                abi.encode(\n                    _contracts[i],\n                    _optionIds[i],\n                    _issuedIds[i]\n                )\n            );\n        }\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(\n                _beneficiary,\n                mintData,\n                _expires,\n                _userId\n            )\n        )\n        .toEthSignedMessageHash();\n\n        _validateMessageAndSignature(messageHash, _signature);\n\n        _issueManyTokens(\n            _beneficiary,\n            _contracts,\n            _optionIds,\n            _issuedIds,\n            _userId\n        );\n    }\n\n    /**\n    * @dev Withdraw NFTs by minting them\n    * @param _beneficiary - Beneficiary's address\n    * @param _contracts - NFT contract' addresses\n    * @param _optionIds - Option ids\n    * @param _issuedIds - Issued ids\n    * @param _userId - User id\n    */\n    function _issueManyTokens(\n        address _beneficiary,\n        address[] memory _contracts,\n        uint256[] memory _optionIds,\n        uint256[] memory _issuedIds,\n        bytes memory _userId\n    ) internal whenNotPaused {\n        for (uint256 i = 0; i < _contracts.length; i++) {\n            _issueToken(\n                _beneficiary,\n                _contracts[i],\n                _optionIds[i],\n                _issuedIds[i],\n                _userId\n            );\n        }\n    }\n\n    /**\n    * @dev Withdraw an NFT by minting it\n    * @notice that the mint is based on an option and issued id.\n    * The contract should implement the `issueToken` signature\n    * @param _beneficiary - Beneficiary's address\n    * @param _contract - NFT contract' address\n    * @param _optionId - Option id\n    * @param _issuedId - Issued id\n    * @param _userId - User id\n    */\n    function _issueToken(\n        address _beneficiary,\n        address _contract,\n        uint256 _optionId,\n        uint256 _issuedId,\n        bytes memory _userId\n    ) internal whenNotPaused {\n        IERC721PreMinteable(_contract).issueToken(_beneficiary, _optionId, _issuedId);\n\n        emit Issued(_beneficiary, _contract, _optionId, _issuedId, _userId);\n    }\n\n    /**\n    * @dev Validates that a message has not been processed, and signed by an authorized admin\n    * @notice that will revert if any of the condition fails\n    * @param _messageHash - Message\n    * @param _signature - Signature\n    */\n    function _validateMessageAndSignature(bytes32 _messageHash, bytes memory _signature) internal {\n        require(!messageProcessed[_messageHash], \"The message has been processed\");\n        messageProcessed[_messageHash] = true;\n\n        address signer = _messageHash.recover(_signature);\n        require(adminWhitelist[signer], \"Unauthorized admin signature\");\n    }\n}"}}}