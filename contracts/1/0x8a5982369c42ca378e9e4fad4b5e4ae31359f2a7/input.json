{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CloneFactory.sol":{"content":"// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\n\n/*\nThe MIT License (MIT)\nCopyright (c) 2018 Murray Software, LLC.\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n//solhint-disable max-line-length\n//solhint-disable no-inline-assembly\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address payable result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), targetBytes)\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}\n"},"ComWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport \"./MasterWallet.sol\";\nimport \"./CloneFactory.sol\";\n\ncontract ComWallet is CloneFactory {\n\n    address payable [] public wallets;\n    address public coldWalletAddr;\n    address public deployerAddr;\n    address public ownerAddr;\n    address payable public implementationAddr;\n    bool public locked;\n\n    event WalletCreatedEvent(\n        address addr\n    );\n    event OwnerChanged(\n        address indexed previousAddr,\n        address indexed newAddr\n    );\n    event DeployerChanged(\n        address indexed previousAddr,\n        address indexed newAddr\n    );\n    event ColdWalletChanged(\n        address indexed previousAddr,\n        address indexed newAddr\n    );\n\n    modifier onlyDeployer() {\n    require(msg.sender == deployerAddr,\n    \"Only deployer can call this!\"\n    );\n    _;\n    }\n    modifier onlyOwner() {\n    require(msg.sender == ownerAddr,\n    \"Only owner can call this!\"\n    );\n    _;\n    }\n\n    constructor(address payable _implementationAddr) {\n        ownerAddr = msg.sender;\n        deployerAddr = msg.sender;\n        coldWalletAddr = msg.sender;\n        implementationAddr = _implementationAddr;\n        MasterWallet(implementationAddr).Init(address(this));\n        wallets.push(implementationAddr);\n        locked = false;\n    }\n\n    function changeOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0));\n        emit OwnerChanged(ownerAddr, _newOwner);\n        ownerAddr = _newOwner;\n    }\n\n    function changeDeployer(address _newDeployer) external onlyOwner{\n        require(_newDeployer != address(0));\n        emit DeployerChanged(deployerAddr, _newDeployer);\n        deployerAddr = _newDeployer;\n    }\n\n    function changeColdWallet(address _newColdWallet) external onlyOwner{\n        require(_newColdWallet != address(0));\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        emit ColdWalletChanged(coldWalletAddr, _newColdWallet);\n        coldWalletAddr = _newColdWallet;\n        locked = false;\n    }\n\n    function createWallet() external onlyDeployer {\n        address payable wallet = createClone(implementationAddr);\n        MasterWallet(wallet).Init(address(this));\n        wallets.push(wallet);\n        emit WalletCreatedEvent(wallet);\n    }\n\n    function createMultipleWallet(uint256 amount) external onlyDeployer {\n        for (uint256 index = 0; index < amount; index++) {\n        address payable wallet = createClone(implementationAddr);\n        MasterWallet(wallet).Init(address(this));\n        wallets.push(wallet);\n        emit WalletCreatedEvent(wallet);\n        }\n    }\n\n    function getDeployer() public view returns (address){\n        return deployerAddr;\n    }\n\n    function getColdWallet() public view returns (address){\n        return coldWalletAddr;\n    }\n\n    function getOwner() public view returns (address){\n        return ownerAddr;\n    }\n    function getLocked() public view returns (bool){\n        return locked;\n    }\n    function getWallet(uint id) public view returns (address){\n        return wallets[id];\n    }\n}\n"},"ERC20Interface.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\n/**\n * Contract that exposes the needed erc20 token functions\n */\n\nabstract contract ERC20Interface {\n  // Send _value amount of tokens to address _to\n  function transfer(address _to, uint256 _value)\n    public\n    virtual\n    returns (bool success);\n\n  // Get the account balance of another account with address _owner\n  function balanceOf(address _owner)\n    public\n    virtual\n    view\n    returns (uint256 balance);\n}\n"},"MasterWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport \"./ERC20Interface.sol\";\nimport \"./ComWallet.sol\";\n\ncontract MasterWallet {\n\n    address public factoryAddr;\n    bool public initialized = false;\n\n    event FlushToken(\n        address indexed fromAddr,\n        address indexed toAddr\n    );\n    event FlushETH(\n        address indexed fromAddr,\n        address indexed toAddr\n    );\n    event Deposited(\n        address from,\n        uint256 amount\n    );\n\n    modifier onlyUninitialized {\n        require(!initialized, 'Contract already initialized');\n        _;\n    }\n    modifier onlyInitialized {\n        require(initialized, 'Contract Not initialized');\n        _;\n    }\n    function Init(address _factoryAddr) external onlyUninitialized{\n        factoryAddr = _factoryAddr;\n        initialized = true;\n    }\n\n    function flushToken(address tokenContractAddress) external onlyInitialized {\n        ComWallet comWallet = ComWallet(factoryAddr);\n        bool locked = comWallet.getLocked();\n        require(!locked, \"Reentrant call\");\n        address deployer = comWallet.getDeployer();\n        address coldWallet = comWallet.getColdWallet();\n        require(deployer == msg.sender, 'Only deployer!');\n        ERC20Interface token =  ERC20Interface(tokenContractAddress);\n        uint256 amount = token.balanceOf(address(this));\n        token.transfer(coldWallet, amount);\n        emit FlushToken(address(this), coldWallet);\n    }\n\n    function flushETH() external onlyInitialized{\n        ComWallet comWallet = ComWallet(factoryAddr);\n        bool locked = comWallet.getLocked();\n        require(!locked, \"Reentrant call\");\n        address deployer = comWallet.getDeployer();\n        address coldWallet = comWallet.getColdWallet();\n        require(deployer == msg.sender, 'Only deployer!');\n\n        uint256 value = address(this).balance;\n        if (value == 0) {\n          return;\n        }\n        (bool success, ) = coldWallet.call{ value: value }('');\n        require(success, 'Flush failed');\n        emit FlushETH(address(this), coldWallet);\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n}\n"}}}