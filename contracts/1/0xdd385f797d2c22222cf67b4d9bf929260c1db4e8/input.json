{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/BitslerBalanceChecker.sol":{"content":"pragma solidity ^0.6.0;\n\nabstract contract Token {\n  function balanceOf(address) public virtual view returns (uint);\n}\n\ncontract BitslerBalanceChecker {\n  /* Fallback function, don't accept any ETH */\n  fallback() external {}\n  function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n  function tokenBalance(address user, address token) internal view returns (uint) {\n    if(!isContract(token)) {\n        return 0;\n    }\n    return Token(token).balanceOf(user);\n  }\n\n  function balances(address[] calldata users, address tokens) external view returns (uint[] memory) {\n    uint[] memory addrBalances = new uint[](users.length);\n    require(users.length < 1000, \"Limit addresses to 1000 per call\");\n    for(uint i = 0; i < users.length; i++) {\n        uint addrIdx = i;\n        if (address(tokens) != address(0x0)) { \n          addrBalances[addrIdx] = tokenBalance(address(users[i]), address(tokens));\n        } else {\n          addrBalances[addrIdx] = address(users[i]).balance; // ETH balance    \n        }\n    }\n    return addrBalances;\n  }\n}"}}}