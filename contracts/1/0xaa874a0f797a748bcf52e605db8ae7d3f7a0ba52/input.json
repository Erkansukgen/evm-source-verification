{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\ncontract Proxy {\n\taddress implementation_;\n\taddress public admin;\n\n\tconstructor(address impl) {\n\t\timplementation_ = impl;\n\t\tadmin = msg.sender;\n\t}\n\n\treceive() external payable {}\n\n\tfunction setImplementation(address newImpl) public {\n\t\trequire(msg.sender == admin);\n\t\timplementation_ = newImpl;\n\t}\n\n\tfunction implementation() public view returns (address impl) {\n\t\timpl = implementation_;\n\t}\n\n\tfunction transferOwnership(address newOwner) external {\n\t\trequire(msg.sender == admin);\n\t\tadmin = newOwner;\n\t}\n\n\t/**\n\t * @dev Delegates the current call to `implementation`.\n\t *\n\t * This function does not return to its internall call site, it will return directly to the external caller.\n\t */\n\tfunction _delegate(address implementation__) internal virtual {\n\t\tassembly {\n\t\t\t// Copy msg.data. We take full control of memory in this inline assembly\n\t\t\t// block because it will not return to Solidity code. We overwrite the\n\t\t\t// Solidity scratch pad at memory position 0.\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\n\t\t\t// Call the implementation.\n\t\t\t// out and outsize are 0 because we don't know the size yet.\n\t\t\tlet result := delegatecall(gas(), implementation__, 0, calldatasize(), 0, 0)\n\n\t\t\t// Copy the returned data.\n\t\t\treturndatacopy(0, 0, returndatasize())\n\n\t\t\tswitch result\n\t\t\t// delegatecall returns 0 on error.\n\t\t\tcase 0 {\n\t\t\t\trevert(0, returndatasize())\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn(0, returndatasize())\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n\t * and {_fallback} should delegate.\n\t */\n\tfunction _implementation() internal view returns (address) {\n\t\treturn implementation_;\n\t}\n\n\t/**\n\t * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n\t * function in the contract matches the call data.\n\t */\n\tfallback() external payable virtual {\n\t\t_delegate(_implementation());\n\t}\n}\n"
    }
  }
}