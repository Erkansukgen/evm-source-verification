{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"inariHelper.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n/*\n▄▄█    ▄   ██   █▄▄▄▄ ▄█ \n██     █  █ █  █  ▄▀ ██ \n██ ██   █ █▄▄█ █▀▀▌  ██ \n▐█ █ █  █ █  █ █  █  ▐█ \n ▐ █  █ █    █   █    ▐ \n   █   ██   █   ▀   \n           ▀          */\n/// 🦊🌾 Special thanks to Keno / Boring / Gonpachi / Karbon for review and continued inspiration.\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\n/// License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\n    bytes4 private constant SIG_APPROVE = 0x095ea7b3; // approve(address,address,uint256)\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\n    /// Returns '0' as fallback value.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to check.\n    /// @return amount The token amount.\n    function safeBalanceOf(address token, address to) internal view returns (uint256 amount) {\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\n        return success && data.length >= 32 ? amount = abi.decode(data, (uint256)) : amount = 0;\n    } \n    \n    /// @notice Provides a safe ERC20.approve version for different ERC-20 implementations.\n    /// @param token The address of the ERC-20 token.\n    /// @param to The address of the user to grant spending right.\n    /// @param amount The token amount to grant spending right over.\n    function safeApprove(\n        IERC20 token, \n        address to, \n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_APPROVE, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Approve failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n\ncontract TestBridge {\n    using BoringERC20 for IERC20;\n    /// @notice Helper function to approve this contract to spend tokens and enable strategies.\n    function bridgeToken(IERC20[] calldata token, address[] calldata to, uint256 amount) external {\n        for (uint256 i = 0; i < token.length; i++) {\n            if (amount == 0) { \n                token[i].safeApprove(to[i], type(uint256).max); // max approve `to` spender to pull `token` from this contract\n            } else {\n                token[i].safeApprove(to[i], amount); // approve `to` spender to pull `token` `amount` from this contract\n            }\n        }\n    }\n}"}}}