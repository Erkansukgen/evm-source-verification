{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Raffle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\ncontract Raffle is Ownable {\n    receive() external payable {}\n    function withdraw() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n    function raffle(address[] memory addresses) external onlyOwner {\n        uint numberOfUsers = addresses.length;\n        require(numberOfUsers > 0, \"Addresses not passed\");\n        uint totalBalance = address(this).balance;\n        require(totalBalance > 0, \"Zero balance in contract\");\n        uint sharePerOne = totalBalance/numberOfUsers;\n        for(uint i = 0; i < numberOfUsers; i++) {\n            payable(addresses[i]).transfer(sharePerOne);\n        }\n    }\n}"}}}