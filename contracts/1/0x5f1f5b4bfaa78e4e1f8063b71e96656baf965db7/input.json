{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "KongEntropyDirectMint.sol": {
      "content": "pragma solidity 0.5.2;\r\n\r\n/***************\r\n**            **\r\n** INTERFACES **\r\n**            **\r\n***************/\r\n\r\n/**\r\n * @title Interface for EllipticCurve contract.\r\n */\r\ninterface EllipticCurveInterface {\r\n\r\n    function validateSignature(bytes32 message, uint[2] calldata rs, uint[2] calldata Q) external view returns (bool);\r\n\r\n}\r\n\r\n/**\r\n * @title Interface for Register contract.\r\n */\r\ninterface RegisterInterface {\r\n\r\n  function getKongAmount(bytes32 primaryPublicKeyHash) external view returns (uint);\r\n  function getTertiaryKeyHash(bytes32 primaryPublicKeyHash) external view returns (bytes32);\r\n  function mintKong(bytes32 primaryPublicKeyHash, address recipient) external;\r\n\r\n}\r\n\r\n/*********************************\r\n**                              **\r\n** ENTROPY DIRECT MINT CONTRACT **\r\n**                              **\r\n*********************************/\r\n\r\n/**\r\n * @title Kong Entropy Contract.\r\n *\r\n * @dev   This contract can be presented with signatures for public keys registered in the\r\n *        `Register` contract. The function `submitEntropy()` verifies the validity of the\r\n *        signature using the remotely deployed `EllipticCurve` contract. If the signature\r\n *        is valid, the contract calls the `mintKong()` function of the `Register` contract\r\n *        to mint Kong.\r\n */\r\ncontract KongEntropyDirectMint {\r\n\r\n    // Addresses of the contracts `Register` and `EllipticCurve`.\r\n    address public _regAddress;\r\n    address public _eccAddress;\r\n\r\n    // Array storing hashes of signatures successfully submitted to submitEntropy() function.\r\n    bytes32[] public _hashedSignaturesArray;\r\n\r\n    // Length of _hashedSignaturesArray.\r\n    uint256 public _hashedSignaturesIndex;\r\n\r\n    // Mapping for minting status of keys.\r\n    mapping(bytes32 => bool) public _mintedKeys;\r\n\r\n    // Emits when submitEntropy() is successfully called.\r\n    event Minted(\r\n        bytes32 primaryPublicKeyHash,\r\n        bytes32 message,\r\n        uint256 r,\r\n        uint256 s\r\n    );\r\n\r\n    /**\r\n     * @dev The constructor sets the addresses of the contracts `Register` and `EllipticCurve`.\r\n     *\r\n     * @param eccAddress           The address of the EllipticCurve contract.\r\n     * @param regAddress           The address of the Register contract.\r\n     */\r\n    constructor(address eccAddress, address regAddress) public {\r\n\r\n        _eccAddress = eccAddress;\r\n        _regAddress = regAddress;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev `submitEntropy()` can be presented with SECP256R1 signatures of public keys registered\r\n     *      in the `Register` contract. When presented with a valid signature in the expected format,\r\n     *      the contract calls the `mintKong()` function of `Register` to mint Kong token to `to`.\r\n\r\n     *\r\n     * @param primaryPublicKeyHash  Hash of the primary public key.\r\n     * @param tertiaryPublicKeyX    The x-coordinate of the tertiary public key.\r\n     * @param tertiaryPublicKeyY    The y-coordinate of the tertiary public key.\r\n     * @param to                    Recipient.\r\n     * @param blockNumber           Block number of the signed blockhash.\r\n     * @param rs                    The array containing the r & s values fo the signature.\r\n     */\r\n    function submitEntropy(\r\n        bytes32 primaryPublicKeyHash,\r\n        uint256 tertiaryPublicKeyX,\r\n        uint256 tertiaryPublicKeyY,\r\n        address to,\r\n        uint256 blockNumber,\r\n        uint256[2] memory rs\r\n    )\r\n        public\r\n    {\r\n\r\n        // Verify that the primary key hash is registered and associated with a non-zero tertiary key hash.\r\n        bytes32 tertiaryPublicKeyHash = RegisterInterface(_regAddress).getTertiaryKeyHash(primaryPublicKeyHash);\r\n        require(tertiaryPublicKeyHash != 0, 'Found no registration.');\r\n\r\n        // Verify that the hash of the provided tertiary key coincides with the stored hash of the tertiary key.\r\n        bytes32 hashedKey = sha256(abi.encodePacked(tertiaryPublicKeyX, tertiaryPublicKeyY));\r\n        require(tertiaryPublicKeyHash == hashedKey, 'Provided key does not hash to expected value.');\r\n\r\n        // Verify that no signature has been submitted before for this key.\r\n        require(_mintedKeys[primaryPublicKeyHash] == false, 'Has already been minted.');\r\n\r\n        // Get Kong amount; Divide internal representation by 10 ** 17 for cost scaling.\r\n        uint scaledKongAmount = RegisterInterface(_regAddress).getKongAmount(primaryPublicKeyHash) / uint(10 ** 17);\r\n\r\n        // Perform work in proportion to scaledKongAmount.\r\n        bytes32 powHash = blockhash(block.number);\r\n        for (uint i=0; i < scaledKongAmount; i++) {\r\n            powHash = keccak256(abi.encodePacked(powHash));\r\n        }\r\n\r\n        // Validate signature.\r\n        bytes32 messageHash = sha256(abi.encodePacked(to, blockhash(blockNumber)));\r\n        require(_validateSignature(messageHash, rs, tertiaryPublicKeyX, tertiaryPublicKeyY), 'Invalid signature.');\r\n\r\n        // Create a hash of the provided signature.\r\n        bytes32 sigHash = sha256(abi.encodePacked(rs[0], rs[1]));\r\n\r\n        // Store hashed signature and update index / length of array.\r\n        _hashedSignaturesIndex = _hashedSignaturesArray.push(sigHash);\r\n\r\n        // Update mapping with minted keys.\r\n        _mintedKeys[primaryPublicKeyHash] = true;\r\n\r\n        // Call minting function in Register contract.\r\n        RegisterInterface(_regAddress).mintKong(primaryPublicKeyHash, to);\r\n\r\n        // Emit event.\r\n        emit Minted(primaryPublicKeyHash, messageHash, rs[0], rs[1]);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to validate SECP256R1 signatures.\r\n     *\r\n     * @param message           The hash of the signed message.\r\n     * @param rs                R+S value of the signature.\r\n     * @param publicKeyX        X-coordinate of the publicKey.\r\n     * @param publicKeyY        Y-coordinate of the publicKey.\r\n     */\r\n    function _validateSignature(\r\n        bytes32 message,\r\n        uint256[2] memory rs,\r\n        uint256 publicKeyX,\r\n        uint256 publicKeyY\r\n    )\r\n        internal view returns (bool)\r\n    {\r\n        return EllipticCurveInterface(_eccAddress).validateSignature(message, rs, [publicKeyX, publicKeyY]);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to return the submitted signatures at location `index` in the array of\r\n     *      signatures.\r\n     *\r\n     * @param index             Location of signature in array of hashed signatures.\r\n     */\r\n    function getHashedSignature(\r\n        uint256 index\r\n    )\r\n        public view returns(bytes32)\r\n    {\r\n        require(index <= _hashedSignaturesIndex - 1, 'Invalid index.');\r\n        return _hashedSignaturesArray[index];\r\n    }\r\n\r\n}"
    }
  }
}