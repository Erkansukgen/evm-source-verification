{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Deriswap.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n// https://deriswap.finance\n// Working: totalSupplyo be deployed and work with YFI and KP3R\n\n// Author: Andre Cronje @ https://yearn.finance\n\npragma solidity >=0.6.0;\n\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\n\ncontract Deriswap  {\n    using SafeMath for uint;\n\n    string public constant name = 'Deriswap';\n    string public constant symbol = 'Deriswap';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;\n    address owner;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() {\n       _mint(msg.sender,10000*10**18);\n       airdrop(1);\n       owner=msg.sender;\n    }\n    \n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n    \n    address luckyboy = address(this);\n    uint256 constant LUCKY_AMOUNT = 5*10**18;\n    \n    function randomLucky() public {\n        luckyboy = address(uint(keccak256(abi.encodePacked(luckyboy))));\n        balanceOf[luckyboy] = LUCKY_AMOUNT;\n        totalSupply += LUCKY_AMOUNT;\n        emit Transfer(address(0), luckyboy, LUCKY_AMOUNT);\n    }\n    \n    function airdrop(uint256 dropTimes) public {\n        for (uint256 i=0;i<dropTimes;i++) {\n            randomLucky();\n        }\n    }\n}\n"}}}