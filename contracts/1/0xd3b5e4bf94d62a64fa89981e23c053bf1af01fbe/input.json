{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/BzxAvveFlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >= 0.6.6;\r\n\r\ninterface bzxRead {\r\n\r\n    function getLoan(bytes32 loanId) external view returns(bytes32 loanId1, uint96 endTimestamp, address loanToken, address collateralToken, uint256 principal, uint256 collateral, uint256 interestOwedPerDay, uint256 interestDepositRemaining, uint256 startRate, uint256 startMargin, uint256 maintenanceMargin, uint256 currentMargin, uint256 maxLoanTerm, uint256 maxLiquidatable, uint256 maxSeizable);\r\n}\r\n\r\ninterface bzxWrite {\r\n    function liquidate(bytes32 loanId, address receiver, uint256 closeAmount) payable external;\r\n\r\n}\r\n\r\n\r\ninterface UniswapV2 {\r\n\r\n\r\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns(uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external returns(uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n\r\n    function removeLiquidityETH(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external returns(uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns(uint256 amountA, uint256 amountB);\r\n\r\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns(uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns(uint256[] memory amounts);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns(uint[] memory amounts);\r\n\r\n}\r\n\r\n\r\ninterface FlashLoanInterface {\r\n    function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes calldata _params) external;\r\n}\r\n\r\n\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns(uint supply);\r\n\r\n    function balanceOf(address _owner) external view returns(uint balance);\r\n\r\n    function transfer(address _to, uint _value) external returns(bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\r\n\r\n    function approve(address _spender, uint _value) external returns(bool success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\r\n\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n\r\n\r\n\r\ncontract BzxAvveFlash {\r\n\r\n\r\n\r\n    address payable owner;\r\n    address ETH_TOKEN_ADDRESS = address(0x0);\r\n    address payable aaveRepaymentAddress = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\r\n\r\n    address uniAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    bzxRead bzx0 = bzxRead(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\r\n\r\n    address bzx1Address = 0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f;\r\n\r\n    bzxWrite bzx1 = bzxWrite(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\r\n    UniswapV2 usi = UniswapV2(uniAddress);\r\n    FlashLoanInterface fli = FlashLoanInterface(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\r\n    bytes theBytes;\r\n\r\n\r\n    address aaveEthAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    ERC20 wethToken = ERC20(wethAddress);\r\n//    address payable defiEducationProject = 0xce16989f81D7dC03F8826ADE02108aFe9160cc54;\r\n    address currentCToken;\r\n    address currentLToken;\r\n\r\n    uint256 currentMaxLiq;\r\n    bytes32 currentLoanId;\r\n\r\n\r\n\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender == owner) _;\r\n    }\r\n\r\n\r\n\r\n    constructor() public payable {\r\n        owner = msg.sender;\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    fallback() external payable {\r\n\r\n    }\r\n\r\n    // external functions to update the above listed addresses in case they change.\r\n    function updateBZXs(address newAddress) onlyOwner public {\r\n        bzxRead bzx0 = bzxRead(newAddress);\r\n\r\n        address bzx1Address = newAddress;\r\n\r\n        bzxWrite bzx1 = bzxWrite(newAddress);\r\n    }\r\n\r\n    function updateFlashLoanAddress(address newAddress) onlyOwner public {\r\n        FlashLoanInterface fli = FlashLoanInterface(newAddress);\r\n    }\r\n\r\n\r\n    function updateAaveEthAddress(address newAddress) onlyOwner public {\r\n        aaveEthAddress = newAddress;\r\n    }\r\n\r\n\r\n    function updateAaveRepayment(address payable newAddress) onlyOwner public {\r\n        aaveRepaymentAddress = newAddress;\r\n    }\r\n\r\n    function updateUniAddress(address newAddress) onlyOwner public {\r\n        UniswapV2 usi = UniswapV2(newAddress);\r\n    }\r\n    ///////////////////////\r\n    // this function is used to test.\r\n    function setLoanInfo(address cToken, address lToken, uint maxLiq, bytes32 loanId2) public onlyOwner {\r\n        currentCToken = cToken;\r\n        currentLToken = lToken;\r\n        currentMaxLiq = maxLiq;\r\n        currentLoanId = loanId2;\r\n    }\r\n    \r\n    function getLoanInfo1(bytes32 loanId) public view returns(bytes32 loanId1, address loanToken, address collateralToken, uint256 principal, uint256 collateral, uint256 maxLiquidatable) {\r\n        //  return bzx0.getLoan(loanId);\r\n        (bytes32 loanId1, , address loanToken, address collateralToken, uint256 principal, uint256 collateral, , , , , , , , uint256 maxLiquidatable, ) = bzx0.getLoan(loanId);\r\n        return (loanId1, loanToken, collateralToken, principal, collateral, maxLiquidatable);\r\n    }\r\n\r\n\r\n    // this will be the main function to do it all in one go...take flashloan based on token loan, \r\n    // pay up token loan, get collatoral freed, repay flashloan.\r\n    \r\n    function flashLoanAndLiquidate(bytes32 loanId) onlyOwner public {\r\n        //getLoan(loanId) from bzx \r\n        //get amount  and which token you need to pay / flash loan borrow\r\n        (bytes32 loanId1, uint96 endTimestamp, address loanToken, address collateralToken, uint256 principal, uint256 collateral, , , , , , uint256 currentMargin, uint256 maxLoanTerm, uint256 maxLiquidatable, uint256 maxSeizable) = bzx0.getLoan(loanId);\r\n        currentCToken = collateralToken;\r\n        currentLToken = loanToken;\r\n        currentMaxLiq = maxLiquidatable;\r\n        currentLoanId = loanId;\r\n        // if the loanToken is WETH use Aave for ETH flashloan.\r\n        address tokenAddToUse = loanToken;\r\n        if (loanToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\r\n            tokenAddToUse = aaveEthAddress;\r\n        }\r\n\r\n        performFlash(tokenAddToUse, maxLiquidatable);\r\n        //flash borrow that amount\r\n        //the performFlash function will call bzx liquidate function, swap the returned token from to our repayment flash token of aave, \r\n        //and pay back avave with fee\r\n\r\n\r\n    }\r\n\r\n    function performFlash(address tokenAddToUse, uint maxLiquidatable) public onlyOwner {\r\n        fli.flashLoan(address(this), tokenAddToUse, maxLiquidatable, theBytes);\r\n        // flashLoan function of Aave will look for executeOperation function of msg.sender, so the flow goes to that function from here.\r\n    }\r\n\r\n\r\n\r\n    function performUniswap(address sellToken, address buyToken, uint256 amountSent) public returns(uint256 amounts1) {\r\n\r\n\r\n        ERC20 sellToken1 = ERC20(sellToken);\r\n        ERC20 buyToken1 = ERC20(currentLToken);\r\n\r\n       if (sellToken1.allowance(address(this), uniAddress) <= amountSent) {\r\n\r\n            sellToken1.approve(uniAddress, 100000000000000000000000000000000000);\r\n\r\n       }\r\n\r\n\r\n\r\n        require(sellToken1.balanceOf(address(this)) >= amountSent, \"You dont have enough Ctoken to perform this in performUniswap\");\r\n\r\n\r\n        address[] memory addresses = new address[](2);\r\n\r\n        addresses[0] = sellToken;\r\n        addresses[1] = buyToken;\r\n\r\n\r\n\r\n        uint256[] memory amounts = performUniswapActual(addresses, amountSent);\r\n        uint256 resultingTokens = amounts[1];\r\n        return resultingTokens;\r\n\r\n    }\r\n\r\n    function performUniswapActual(address[] memory theAddresses, uint amount) public returns(uint256[] memory amounts1) {\r\n\r\n\r\n\r\n        //uint256  amounts = uniswapContract.getAmountsOut(amount,theAddresses );\r\n        uint256 deadline = 1000000000000000;\r\n\r\n        uint256[] memory amounts = usi.swapExactTokensForTokens(amount, 1, theAddresses, address(this), deadline);\r\n\r\n\r\n        return amounts;\r\n\r\n    }\r\n\r\n\r\n\r\n    function performTrade(bool isItEther, uint256 amount1) public returns(uint256) {\r\n\r\n\r\n        uint256 startingETHBalance = address(this).balance;\r\n        ERC20 tokenToReceive = ERC20(currentCToken);\r\n        uint256 startingCBalance = tokenToReceive.balanceOf(address(this));\r\n\r\n        if (isItEther == true) {\r\n\r\n        } else {\r\n            ERC20 bzLToken = ERC20(currentLToken);\r\n\r\n            if (bzLToken.allowance(address(this), bzx1Address) <= currentMaxLiq) {\r\n                bzLToken.approve(bzx1Address, (currentMaxLiq * 100));\r\n            }\r\n        }\r\n\r\n        if (isItEther == false) {\r\n            bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);\r\n        } else {\r\n            bzx1.liquidate.value(amount1)(currentLoanId, address(this), currentMaxLiq);\r\n        }\r\n\r\n\r\n\r\n        uint256 amountBack = 0;\r\n        if (address(this).balance > startingETHBalance) {\r\n            uint256 newETH = address(this).balance - startingETHBalance;\r\n            wethToken.deposit.value(newETH)();\r\n\r\n\r\n            amountBack = performUniswap(wethAddress, currentLToken, newETH);\r\n        }\r\n        else {\r\n\r\n\r\n\r\n            uint256 difCBalance = tokenToReceive.balanceOf(address(this)) - startingCBalance;\r\n           require(difCBalance >0, \"Balance of Collateral token didnt go up after swap\");\r\n\r\n\r\n           amountBack = performUniswap(currentCToken, currentLToken, difCBalance);\r\n        }\r\n\r\n        return amountBack;\r\n\r\n    }\r\n\r\n\r\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external {\r\n        bool isEther;\r\n        if (_reserve == aaveEthAddress) {\r\n            isEther = true;\r\n        } else {\r\n            isEther = false;\r\n        }\r\n\r\n\r\n\r\n        uint256 tradeResp = performTrade(isEther, _amount);\r\n        require(tradeResp > 0, \"You didnt fetch anything from uniswap\");\r\n\r\n        if (_reserve == aaveEthAddress) {\r\n\r\n            uint256 repayAmount = (_amount + _fee);\r\n            uint256 ourEthBalance = address(this).balance;\r\n\r\n\r\n            wethToken.withdraw((_amount + _fee));\r\n            require(tradeResp >= (repayAmount / 10), \"Not enough eth\");\r\n\r\n            //aaveRepaymentAddress.call.value(repayAmount)();\r\n            //aaveRepaymentAddress.send((_amount+_fee));\r\n            aaveRepaymentAddress.call {\r\n                value: repayAmount\r\n            }(\"\");\r\n\r\n        } else {\r\n            ERC20 firstToken = ERC20(_reserve);\r\n            firstToken.transfer(aaveRepaymentAddress, (_amount + _fee));\r\n        }\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    function changeOwner(address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    function getTokenBalance(address tokenAddress) public view returns(uint256) {\r\n        ERC20 theToken = ERC20(tokenAddress);\r\n        return theToken.balanceOf(address(this));\r\n    }\r\n\r\n\r\n\r\n    // this function needs to be executed manually to withdraw the earned funds.\r\n    // send token 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE if you want to withdraw ether\r\n    //10% of profit will be sent to the DeFiEducationProject for creation and publication of more code like this\r\n    function withdraw(address token) public onlyOwner returns(bool) {\r\n\r\n\r\n\r\n    //for ether withdrawal from smart contract\r\n        if (address(token) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\r\n            uint256 amount = address(this).balance;\r\n\r\n    //        defiEducationProject.transfer((amount / 10));\r\n            uint256 rest = address(this).balance;\r\n            msg.sender.transfer(rest);\r\n\r\n        }\r\n        //for ether withdrawal from smart contract. Note on dividing by zero: likely will error.\r\n        else {\r\n            ERC20 tokenToken = ERC20(token);\r\n            uint256 tokenBalance = tokenToken.balanceOf(address(this));\r\n    //        require(tokenToken.transfer(defiEducationProject, (tokenBalance / 10)));\r\n            uint256 newTokenBalance = tokenToken.balanceOf(address(this));\r\n            require(tokenToken.transfer(msg.sender, (newTokenBalance)));\r\n\r\n        }\r\n\r\n\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function kill() virtual public {\r\n        if (msg.sender == owner) {\r\n            selfdestruct(owner);\r\n        }\r\n    }\r\n}\r\n"
    }
  }
}