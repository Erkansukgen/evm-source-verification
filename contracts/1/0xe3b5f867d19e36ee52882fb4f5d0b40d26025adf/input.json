{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/interfaces/v3pool.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    /*\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n    */\n\n}\n"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n \n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  \n}"},"contracts/sohmarb.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/v3pool.sol';\nimport './lib/SafeMath.sol';\n\n\ninterface IWETH {\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n}\n\n\n\ninterface v3quoter{\n  function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n}\n\n\ninterface v2pool{\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\ninterface olystaking{\n    function unstake( uint _amount, bool _trigger ) external;\n    function stake( uint _amount, address _recipient ) external returns ( bool );\n    function claim ( address _recipient ) external;\n}\n\n\ncontract ohmarb {\n    using SafeMath for uint;\n    \n    address payable public owner;\n    \n    \n    // main net\n    \n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n    \n    \n    \n    v3quoter quoter = v3quoter(quoter_addr);\n\n    constructor() public {\n        owner = msg.sender;\n        \n        // approve sohm and ohm of the staking contract\n        IERC20(address(0x383518188C0C6d7730D91b2c03a03C837814a899)).approve(address(0xFd31c7d00Ca47653c6Ce64Af53c1571f9C36566a), \n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            \n        IERC20(address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F)).approve(address(0xFd31c7d00Ca47653c6Ce64Af53c1571f9C36566a), \n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n\n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        require(tx.origin == address(0x295CCeE94016D96b81b28e4913Aa16d5a260D2a8), \"shit\");\n        (uint256 flag) = abi.decode(_data, (uint256));\n        \n        if(flag == 0){\n            // stake arb, amount0Delta is the amount of sohm we need to provide\n            // get how much eth we need to swap that amount of ohm out\n            bytes memory returnData;\n    \n            // dai-eth\n            (, returnData) = address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f).staticcall(abi.encodeWithSelector(0x0902f1ac));\n            (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve, dai - 0 eth - 1\n            // ohm-dai\n            (, returnData) = address(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c).staticcall(abi.encodeWithSelector(0x0902f1ac));\n            (uint reserve2,uint reserve3, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve, ohm - 0, dai - 1\n\n            uint256 dai_in = getAmountIn(uint256(amount0Delta), reserve3, reserve2);\n            uint256 eth_in = getAmountIn(uint256(dai_in), reserve1, reserve0);\n\n            IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f), eth_in);\n            v2pool(address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f)).swap(dai_in, 0, address(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c), new bytes(0));\n            v2pool(address(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c)).swap(uint256(amount0Delta), 0, address(this), new bytes(0));\n            \n            olystaking(address(0xFd31c7d00Ca47653c6Ce64Af53c1571f9C36566a)).stake(uint256(amount0Delta), address(this));\n            olystaking(address(0xFd31c7d00Ca47653c6Ce64Af53c1571f9C36566a)).claim(address(this));\n            \n            // transfer sohm back to the pool\n            IERC20(address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F)).transfer(msg.sender, uint256(amount0Delta));\n        }else{\n            // stake arb, amount1Delta is the amount of weth we need to provide, amount0Delta is the amount of sohm out in negative\n            // get how much eth we need to swap that amount of ohm out\n            bytes memory returnData;\n    \n            // dai-eth\n            (, returnData) = address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f).staticcall(abi.encodeWithSelector(0x0902f1ac));\n            (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve, dai - 0 eth - 1\n            // ohm-dai\n            (, returnData) = address(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c).staticcall(abi.encodeWithSelector(0x0902f1ac));\n            (uint reserve2,uint reserve3, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve, ohm - 0, dai - 1\n\n            uint256 dai_out = getAmountOut(uint256(-amount0Delta), reserve2, reserve3);\n            uint256 eth_out = getAmountOut(uint256(dai_out), reserve0, reserve1);\n\n            olystaking(address(0xFd31c7d00Ca47653c6Ce64Af53c1571f9C36566a)).unstake(uint256(-amount0Delta), false);\n            \n            IERC20(address(0x383518188C0C6d7730D91b2c03a03C837814a899)).transfer(address(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c), uint256(-amount0Delta));\n            v2pool(address(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c)).swap(0, dai_out, address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f), new bytes(0));\n            v2pool(address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f)).swap(0, eth_out, address(this), new bytes(0));\n            \n            // transfer eth back to the pool\n            IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, uint256(amount1Delta));\n        }\n\n\n    }\n\n\n\n    function stake_arb(uint256 weth_out) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }     \n        uint256 gasstart = gasleft();\n        \n        bytes memory data = abi.encode(0);\n        \n        // sohm - weth pool, flash swap weth out\n        v3pool(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920)).swap(address(this), true, int256(-weth_out), \n        4295128739 + 1, data);\n        \n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\n        \n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance);\n       \n    }\n\n\n    function unstake_arb(uint256 sohm_out) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }     \n        uint256 gasstart = gasleft();\n        \n        bytes memory data = abi.encode(1);\n        \n        // sohm - weth pool, flash swap weth out\n        v3pool(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920)).swap(address(this), false, int256(-sohm_out), \n        1461446703485210103287273052203988822378723970342 - 1, data);\n        \n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        require(weth_balance > tx.gasprice * (gasstart - gasleft()), \"i\");\n        \n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance);\n       \n    }\n\n\n    function stake_arb_mem(uint256 weth_out, uint256 minweth) public {\n        \n        // at least swap that amount of weth out\n        uint256 check = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920));\n        require(check >= minweth, \"s\");\n\n        bytes memory data = abi.encode(0);\n        \n        // sohm - weth pool, flash swap weth out\n        v3pool(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920)).swap(address(this), true, int256(-weth_out), \n        4295128739 + 1, data);\n        \n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        require(weth_balance > 0, \"i\");\n        \n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance);\n       \n    }\n\n\n\n    function unstake_arb_mem(uint256 sohm_out, uint256 sohmamount) public{\n        \n        // at least swap that amount of weth out\n        uint256 check = IERC20(address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F)).balanceOf(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920));\n        require(check >= sohmamount, \"s\");\n        \n        bytes memory data = abi.encode(1);\n        \n        // sohm - weth pool, flash swap weth out\n        v3pool(address(0x0bb5FD9b4E16607D32C4E5aC625AC5381c605920)).swap(address(this), false, int256(-sohm_out), \n        1461446703485210103287273052203988822378723970342 - 1, data);\n        \n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        require(weth_balance > 0, \"i\");\n        \n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, weth_balance);\n       \n    }\n\n\n\n\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    } \n  \n\n    function v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\n    }\n\n    function stake_best(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestprofit, uint256 bestin){\n        uint256 amountin;\n        uint256 v2_dai_out;\n        uint256 v2_ohm_out;\n        uint256 v3_eth_out;\n        \n        // save some time to just use getreserve once\n        bytes memory returnData;\n\n        // dai-eth\n        (, returnData) = address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n        // ohm-dai\n        (, returnData) = address(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve2,uint reserve3, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n\n\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            v2_dai_out = getAmountOut(amountin, reserve1, reserve0);\n            v2_ohm_out = getAmountOut(v2_dai_out, reserve3, reserve2);\n\n            v3_eth_out = v3out(address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F), address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), 10000, v2_ohm_out);\n            \n            \n            if(v3_eth_out < amountin){\n                break;\n            }\n            \n            \n            if((v3_eth_out - amountin) > bestprofit){\n                bestprofit = v3_eth_out - amountin;\n                bestin = amountin;\n                lowerbound = lowerbound + step;\n            }else{\n                break;\n            }\n        }\n    }\n\n\n\n    function unstake_best(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestprofit, uint256 bestin, uint256 sohmout){\n        uint256 amountin;\n        uint256 v2_dai_out;\n        uint256 v2_eth_out;\n        uint256 v3_sohm_out;\n        \n        // save some time to just use getreserve once\n        bytes memory returnData;\n\n        // dai-eth\n        (, returnData) = address(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n        // ohm-dai\n        (, returnData) = address(0x34d7d7Aaf50AD4944B70B320aCB24C95fa2def7c).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve2,uint reserve3, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n\n\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n\n            v3_sohm_out = v3out(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0x04F2694C8fcee23e8Fd0dfEA1d4f5Bb8c352111F), 10000, amountin);\n            \n            v2_dai_out = getAmountOut(v3_sohm_out, reserve2, reserve3);\n            v2_eth_out = getAmountOut(v2_dai_out, reserve0, reserve1);\n            \n            if(v2_eth_out < amountin){\n                break;\n            }\n            \n            \n            if((v2_eth_out - amountin) > bestprofit){\n                bestprofit = v2_eth_out - amountin;\n                bestin = amountin;\n                sohmout = v3_sohm_out;\n                lowerbound = lowerbound + step;\n            }else{\n                break;\n            }\n        }\n    }\n\n\n    \n\n}"}}}