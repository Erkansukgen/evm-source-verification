{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/odar_file_v1.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\ncontract odar_file {\n    uint256 public current_id;\n    address payable public operator;\n    address payable public hashtag_contract;\n    uint256 public price_wei;\n\n    struct file_struct {\n        string hashtag;\n        string file_name;\n        string version;\n        uint256 added;\n        }\n\n    mapping(string => file_struct) public file;\n\n    struct latest_struct {\n        string lv_checksum;\n    }\n\n    mapping(string => latest_struct) public latest_version;\n\n    struct id_struct {\n        string fc;\n    }\n\n    mapping(uint256 => id_struct) public index;\n\n    // ini\n    constructor() public {\n    operator = msg.sender;\n    current_id = 0;\n    price_wei = 3000000000000000;\n    hashtag_contract = 0xEFA93054C9CD0394cF7F76c7cA7250900899861c; \n    }\n\n    // operator functions\n\n    function opO(address payable nop) public { // change operator\n        require(msg.sender == operator, \"Only operator can call this function\");\n        operator = nop;\n    }\n\n    function opP(uint256 np) public {\n        require(msg.sender == operator, \"Only operator can call this function\");\n        price_wei = np;\n    }\n\n    function opW(address payable r) public {\n        require(msg.sender == operator, \"Only operator can call this function\");\n        r.transfer(address(this).balance);\n    }\n    \n    function opHTC(address payable c) public {\n        require(msg.sender == operator, \"Only operator can call this function\");\n        hashtag_contract = c;\n    }\n\n    // public functions \n    \n    function getOwner (string memory hashtag) public returns (address) {\n        hashtag = _toLower(hashtag);\n        bytes memory payload = abi.encodeWithSignature(\"getOwner(string)\", hashtag); \n        (bool success, bytes memory result)= hashtag_contract.call(payload);\n        address hashtag_owner = abi.decode(result, (address));\n        return hashtag_owner;\n    }\n\n    function registerFile (\n        string memory hashtag,\n        string memory new_checksum,\n        string memory new_file_name,\n        string memory new_version,\n        address payable comm_address\n    ) public payable {\n        hashtag = _toLower(hashtag);\n        bytes memory payload = abi.encodeWithSignature(\"getOwner(string)\", hashtag); \n        (bool success, bytes memory result)= hashtag_contract.call(payload);\n        address hashtag_owner = abi.decode(result, (address));\n        require(msg.sender == hashtag_owner, \"Only hashtag owner can link file with the hashtag\"); \n        require(file[new_checksum].added == 0, \"File with this checksum already registered\"); \n    \n        if (msg.sender != operator) {\n            require(\n                msg.value >= price_wei,\n                \"Fee too low. Check price_wei variable to get the price.\"\n            );\n        }\n        \n        current_id++;\n        index[current_id].fc = new_checksum;\n        file[new_checksum].hashtag = hashtag;\n        file[new_checksum].file_name = new_file_name; \n        file[new_checksum].version = new_version;\n        file[new_checksum].added = now;\n\n        //udpate latest version\n        latest_version[hashtag].lv_checksum = new_checksum; \n\n        //send commission\n        if (comm_address != address(0) && msg.sender != operator) {\n            comm_address.transfer(msg.value / 2);\n        }\n    }\n\n    // internal \n\n    function _toLower(string memory str) internal pure returns (string memory) {\n        bytes memory bStr = bytes(str);\n        bytes memory bLower = new bytes(bStr.length);\n        for (uint i = 0; i < bStr.length; i++) {\n            // Uppercase character...\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\n                // So we add 32 to make it lowercase\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\n            } else {\n                bLower[i] = bStr[i];\n            }\n        }\n        return string(bLower);\n    }\n}"}}}