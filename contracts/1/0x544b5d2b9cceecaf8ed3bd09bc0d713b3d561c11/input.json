{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"AirnextToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.7.0 <=0.8.7;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\ncontract AirnextToken is Context, IERC20, IERC20Metadata {\r\n    mapping (address => uint256) internal _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint256 public _threshold; // Variable seuil pour un gros transfert\r\n    \r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n  \r\n    address  addressAdminAirnext;\r\n    address  addressTokenSale;\r\n    address  addressTeam;\r\n    address  addressMarketing;\r\n    \r\n    address  immutable manager;  \r\n    \r\n    // 45% pour les ventes de jeton\r\n    uint256  constant tsSupply = 103500000 * multiple; \r\n    // 45% pour Airnext\r\n    uint256  constant AirnextSupply = 103500000 * multiple;\r\n    //5% pour la addressTeam\r\n    uint256  constant addressTeamSupply = 11500000 * multiple; \r\n    //5% pour le addressMarketing  11500000 AIRN\r\n    uint256  constant marketSupply = 11500000 * multiple; \r\n    \r\n    // multiple de 10*5 en rapport avec la décimal\r\n    uint256 public constant multiple = 10**5; \r\n   \r\n    // Liste de tous les tableaux gros transferts. \r\n    mapping (address => mapping(address => Latency)) public BigTransfers;\r\n    \r\n    \r\n    // Initialisation des états REJET, EN ATTENTE ET VALIDE\r\n    enum State{REJECTED, PENDING, VALIDATED} \r\n    \r\n    event error(address _sender, string value);\r\n    \r\n    struct Latency {\r\n        uint256 _amount;\r\n        mapping (address => bool) TransferEvent; \r\n        uint loading;\r\n        bool completed;\r\n        State currState;\r\n    }\r\n    \r\n\r\n    constructor(address _addressAdminAirnext, address _addressTokenSale, address _addressTeam, address _addressMarketing) {\r\n        _name = \"Airnext\";\r\n        _symbol = \"AIRN\";\r\n        \r\n        addressAdminAirnext = _addressAdminAirnext;\r\n        addressTokenSale = _addressTokenSale;\r\n        addressTeam = _addressTeam;\r\n        addressMarketing = _addressMarketing;\r\n        \r\n        manager = msg.sender;\r\n        \r\n        _mint(_addressAdminAirnext, AirnextSupply);\r\n        _mint(_addressTokenSale, tsSupply);\r\n        _mint(_addressTeam, addressTeamSupply);\r\n        _mint(_addressMarketing, marketSupply);\r\n        \r\n        // Referencer le seuil\r\n        _threshold = 500000 * multiple;\r\n    }\r\n  \r\n  \r\n    // Décimals du Token AirN\r\n    function decimals() public pure override returns(uint8){ \r\n        return 5;\r\n    }\r\n    \r\n      // Choisir le minimum de seuil pour un gros transfert\r\n    function setMinimumThreshold(uint256 threshold) external { \r\n     require (msg.sender == addressAdminAirnext || msg.sender == manager );\r\n      _threshold = threshold * multiple;\r\n    }\r\n    \r\n    // Changer les adresses des administrateurs pools\r\n    function changeAddressPool(address _addressAdminAirnext, address _addressTokenSale, address _addressTeam, address _addressMarketing) \r\n    external returns(bool) {\r\n        \r\n        require(msg.sender == addressAdminAirnext || msg.sender == manager) ;\r\n        \r\n        addressAdminAirnext = _addressAdminAirnext;\r\n        addressTokenSale = _addressTokenSale;\r\n        addressTeam = _addressTeam;\r\n        addressMarketing = _addressMarketing;\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n    \r\n    function transfer(address payable recipient, uint256 _amount) public override returns (bool) {\r\n         \r\n        Latency storage bigTransfers = BigTransfers[msg.sender][recipient];\r\n        \r\n        if(bigTransfers.loading  > 0 && bigTransfers.loading < block.timestamp ){\r\n            bigTransfers.currState = State.REJECTED;\r\n        }\r\n        \r\n        require(_balances[msg.sender] >= _amount);\r\n        require(bigTransfers.currState != State.PENDING, \"You already have a pending transfer\");\r\n        if(_amount >= _threshold && (msg.sender == addressAdminAirnext || msg.sender == addressTokenSale || msg.sender == addressMarketing || msg.sender == addressTeam))\r\n        \r\n        {\r\n             _createTransferLatency(msg.sender, recipient, _amount); // Créer une instance d'un gros transfert. \r\n                \r\n        }\r\n       \r\n        else {\r\n            \r\n            _transfer(msg.sender, recipient, _amount); // Transfert qui au-dessous du seuil d'un gros transfert\r\n            \r\n        }\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n    // Validation du gros transfert par les administrateurs wallets. \r\n    function validateTransfer(address _sender, address _recipient) external returns(bool) { \r\n      Latency storage thisBigTransfers = BigTransfers[_sender][_recipient];\r\n      \r\n      require (thisBigTransfers._amount > 0, 'Ligne de tableau non valide');\r\n      require (msg.sender == addressAdminAirnext || msg.sender == addressTokenSale || msg.sender == addressTeam); \r\n      require (block.timestamp <= thisBigTransfers.loading);\r\n      require (thisBigTransfers.TransferEvent[msg.sender] == false);\r\n      \r\n      \r\n      thisBigTransfers.TransferEvent[msg.sender] = true;\r\n      \r\n      bool  adminAirnextValidation = thisBigTransfers.TransferEvent[addressAdminAirnext];\r\n      bool  tokenSaleValidation = thisBigTransfers.TransferEvent[addressTokenSale];\r\n      bool  tokenTeamValidation = thisBigTransfers.TransferEvent[addressTeam];\r\n      \r\n      // 2 administrateurs sur 3 doient valider la transactions.\r\n      if( adminAirnextValidation && tokenSaleValidation || tokenTeamValidation && tokenSaleValidation || tokenTeamValidation && adminAirnextValidation )\r\n          \r\n          {\r\n                    thisBigTransfers.completed = true;\r\n                    thisBigTransfers.currState = State.VALIDATED; // Appel de l'index et emission de l'état du transfer\r\n                    transferLatency(_sender, _recipient);\r\n                    return true;\r\n          }\r\n       else if (block.timestamp <= thisBigTransfers.loading && (adminAirnextValidation || tokenTeamValidation || tokenSaleValidation))\r\n       \r\n       {\r\n           thisBigTransfers.currState = State.PENDING;\r\n           thisBigTransfers.completed = false;\r\n           return true;\r\n           \r\n       } \r\n       \r\n       else {\r\n                     thisBigTransfers.completed = false; \r\n                     thisBigTransfers.currState = State.REJECTED; // Appel de l'index et emission de l'état du transfer\r\n                     return false;\r\n       \r\n            } \r\n     \r\n    }\r\n    \r\n     function _isHolding(address _sender, address _recipient) internal returns(bool) {\r\n      Latency storage newBigTransfers = BigTransfers[_sender][_recipient]; // Ajout d'une ligne sur le mapping du gros transfert  \r\n        if (newBigTransfers._amount > 0 && newBigTransfers.currState == State.PENDING) {\r\n              emit error(_sender, \"You already have a pending transfer\"); // si la transaction existe et que le status est en attente, alors le message d'erreur apparait\r\n              return true;\r\n        } \r\n      return false;\r\n    }\r\n\r\n    \r\n    // Les administrateurs refusent le gros transfert\r\n    function refuseTransfer(address _sender, address _recipient) public returns(bool){ \r\n     Latency storage thisBigTransfers = BigTransfers[_sender][_recipient];\r\n     \r\n       require (thisBigTransfers._amount > 0, 'Ligne de tableau non valide');\r\n       require (msg.sender == addressAdminAirnext || msg.sender == addressTokenSale || msg.sender == addressTeam);\r\n       thisBigTransfers.TransferEvent[msg.sender] = false;\r\n       \r\n      bool  adminAirnextValidation = thisBigTransfers.TransferEvent[addressAdminAirnext];\r\n      bool  tokenSaleValidation = thisBigTransfers.TransferEvent[addressTokenSale];\r\n      bool  tokenTeamValidation = thisBigTransfers.TransferEvent[addressTeam];\r\n       \r\n       if(!adminAirnextValidation && !tokenSaleValidation || !tokenTeamValidation && !tokenSaleValidation || !tokenTeamValidation && !adminAirnextValidation)\r\n          \r\n        {\r\n           thisBigTransfers.completed = false;\r\n           thisBigTransfers.currState = State.REJECTED;\r\n           \r\n        }\r\n        \r\n        \r\n       return false; \r\n    }\r\n  \r\n    // Création d'une instance d'un gros transfert. \r\n     function _createTransferLatency(address _sender, address  payable _recipient, uint256 _amount) internal returns(bool) {\r\n         Latency storage newBigTransfers = BigTransfers[_sender][_recipient]; // Ajout d'une ligne sur le mapping du gros transfert  \r\n      \r\n              \r\n                newBigTransfers._amount = _amount;\r\n                newBigTransfers.completed = false;\r\n                newBigTransfers.loading = block.timestamp + 86400 ; // 24h = 86400\r\n                newBigTransfers.currState = State.PENDING;\r\n                newBigTransfers.TransferEvent[addressAdminAirnext] = false;\r\n                newBigTransfers.TransferEvent[addressTokenSale] = false;\r\n                newBigTransfers.TransferEvent[addressTeam] = false;\r\n\r\n                return true;\r\n    }\r\n\r\n    // Envoie de la transaction du gros transfert par le sender.\r\n    function transferLatency(address _sender, address _recipient) public returns(bool){ \r\n          Latency storage otherBigTransfers = BigTransfers[_sender][_recipient];\r\n          \r\n          require (otherBigTransfers._amount > 0, 'Ligne de tableau non valide');\r\n          require(_balances[_sender] > 0 && _balances[_sender] >= otherBigTransfers._amount);\r\n          \r\n          if(otherBigTransfers.completed == true && block.timestamp <= otherBigTransfers.loading) {\r\n              \r\n            _balances[_recipient] += otherBigTransfers._amount; // balances[to] = balances[to] + tokens\r\n            _balances[_sender] -= otherBigTransfers._amount; // balances[to] = balances[to] + tokens\r\n              \r\n            emit Transfer(_sender, _recipient,otherBigTransfers._amount);\r\n            otherBigTransfers.currState = State.VALIDATED; //Appel de l'index et emission de l'état du transfer\r\n            return true;\r\n              \r\n          }\r\n              \r\n          else {\r\n                    otherBigTransfers.currState = State.REJECTED; //Appel de l'index et emission de l'état du transfer\r\n                    return false;\r\n         }\r\n    }\r\n    \r\n    \r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    \r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    \r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n}\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        \r\n        \r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        \r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n    \r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}"},"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <=0.8.7;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <=0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address payable recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <=0.8.7;\n\nimport \"../IERC20.sol\";\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"}}}