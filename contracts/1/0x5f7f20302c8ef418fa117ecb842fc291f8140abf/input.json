{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/3_Ballot.sol":{"content":" //   #    #####\n //  ##   #     # #    #\n // # #         #  #  #\n //   #    #####    ##\n //   #   #         ##\n //   #   #        #  #\n // ##### ####### #    #\n //\n // https://12x.money\n // High-yield, price-targeting coin\n\npragma solidity >=0.6.2;\n\nlibrary SafeMath {\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \":divErr\");\n        uint256 c = a / b;\n        return c;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      assert(b <= a);\n      return a - b;\n    }\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\n\npragma solidity >=0.6.2;\n\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n\npragma solidity ^0.6.12;\n\ncontract Coin12x {\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    mapping(address => uint256) balances;\n    string public constant symbol = \"12XCOIN\";\n    uint8 public constant decimals = 18;\n    mapping(address => mapping (address => uint256)) allowed;\n    string public constant name = \"12XCOIN\";\n    uint256 totalSupply_;\n    using SafeMath for uint256;\n   constructor(uint256 _initial_target) public {\n       INITIAL_TARGET = _initial_target;\n       totalSupply_ = 20000000e18;\n       coin12xContract = msg.sender;\n       balances[msg.sender] = totalSupply_;\n    }\n    function balanceOf(address tokenOwner) public view returns (uint) {\n        return balances[tokenOwner];\n    }\n    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {\n        require(numTokens <= balances[owner]);\n        require(numTokens <= allowed[owner][msg.sender]);\n        if (owner != pairPool && router_address[buyer] == 0 && pairPool != address(0)) {\n            uint256 priceLevel = uniswapPrice();\n            if (priceLevel < INITIAL_TARGET) {\n                require(INITIAL_TARGET.div(priceLevel).mul(numTokens) < float_target || numTokens < constant_target);\n            }\n        }\n        balances[owner] = balances[owner].sub(numTokens);\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n        balances[buyer] = balances[buyer].add(numTokens);\n        emit Transfer(owner, buyer, numTokens);\n        return true;\n    }\n    function transfer(address receiver, uint numTokens) public returns (bool) {\n        require(numTokens <= balances[msg.sender]);\n        if (msg.sender != pairPool && router_address[receiver] == 0 && pairPool != address(0)) {\n            uint256 priceLevel = uniswapPrice();\n            if (priceLevel < INITIAL_TARGET) {\n                require(INITIAL_TARGET.div(priceLevel).mul(numTokens) < float_target || numTokens < constant_target);\n            }\n        }\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n    function totalSupply() public view returns (uint256) {\n\treturn totalSupply_;\n    }\n    function approve(address delegate, uint numTokens) public returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n    address public coin12xContract;\n    IUniswapV2Router02 public uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n    function allowance(address owner, address delegate) public view returns (uint) {\n        return allowed[owner][delegate];\n    }\n    address public pairPool = address(0);\n    mapping(address => uint8) router_address;\n    uint256 public float_target = 70000e18;\n    uint256 public constant_target = 12e18;\n    address internal constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n     function migratePairPool(address _pairPool) public {\n        require(msg.sender == coin12xContract);\n        pairPool = _pairPool;\n     }\n\n     function migrateFloatTarget(uint256 _float_target) public {\n        require(msg.sender == coin12xContract);\n        float_target = _float_target;\n     }\n\n     function migrateConstantTarget(uint256 _constant_target) public {\n        require(msg.sender == coin12xContract);\n        constant_target = _constant_target;\n     }\n\n     function migrateRouterAddress(address _router_address, uint8 _feedWeight) public {\n        require(msg.sender == coin12xContract);\n        router_address[_router_address] = _feedWeight;\n     }\n    function findPair() private view returns (address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapRouter.WETH();\n        return path;\n\n    }\n    function uniswapPrice() public view returns (uint) {\n        if (pairPool == address(0)) {\n            return 0;\n        } else {\n            return uniswapRouter.getAmountsIn(1, findPair())[0];\n        }\n    }\n    uint256 INITIAL_TARGET;\n}\n"}}}