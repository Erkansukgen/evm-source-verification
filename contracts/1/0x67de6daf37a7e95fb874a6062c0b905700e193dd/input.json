{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/SandwichV7.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n}\n\ninterface IWETH {\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface Gastoken {\n    function free(uint256 value) external returns (bool success);\n    function freeUpTo(uint256 value) external returns (uint256 freed);\n    function freeFrom(address from, uint256 value) external returns (bool success);\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n    function mint(uint256 value) external;\n}\n\ncontract Sandwich {\n\n    // No sstore or sload\n\n    constructor() {}\n    receive() external payable {}\n    fallback() external payable {}\n\n    modifier onlyOwner {\n        require(msg.sender == address(0x8C14877fe86b23FCF669350d056cDc3F2fC27029));\n        _;\n    }\n\n    function mintGastoken(address gasTokenAddress, uint _amount) external {\n        Gastoken(gasTokenAddress).mint(_amount);\n    }\n\n    function withdrawERC20(address _token, uint _amount) external onlyOwner {\n        IERC20(_token).transfer(msg.sender, _amount);\n    }\n\n    function approveMax(address router, address token) external onlyOwner {\n        IERC20(token).approve(router, type(uint).max);\n    }\n\n    function _swapExactWETHToTokens(\n        uint amountToFree,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        IUniswapV2Pair p,\n        bool whichToken\n    ) external onlyOwner {\n        // require(IERC20(inputToken).transfer(address(p), inputAmount), \"Transfer to pair failed\");\n        // inputToken.call(abi.encodeWithSelector(0xa9059cbb, address(p), inputAmount)); // transfer()\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).call(abi.encodeWithSelector(0xa9059cbb, address(p), inputAmount)); // WETH.transfer()\n        // Last trade, check for slippage here\n        if (whichToken) { // Check what token are we buying, 0 or 1 ?\n            // 1\n            // p.swap(0, outputAmount, recipient, \"\");\n            address(p).call(abi.encodeWithSelector(0x0902f1ac, 0, outputAmount, address(this), \"\")); // Pair.swap() - this brought gas down from 86k to 42k. What's happening?\n        } else {\n            // 0\n            // p.swap(outputAmount, 0, recipient, \"\");\n            address(p).call(abi.encodeWithSelector(0x0902f1ac, outputAmount, 0, address(this), \"\")); // Pair.swap() - this brought gas down from 86k to 42k. What's happening?\n        }\n        if(amountToFree > 0) {\n            // require(Gastoken(0x0000000000b3F879cb30FE243b4Dfee438691c04).free(amountToFree));\n            address(0x0000000000b3F879cb30FE243b4Dfee438691c04).call(abi.encodeWithSelector(0xd8ccd0f3, amountToFree)); // GST2.free()\n        }\n    }\n\n    function _swapExactTokensToWETHAndBribe(\n        uint amountToFree,\n        address inputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        uint256 minOutAmount, // only used if outputAmount is zero\n        IUniswapV2Pair p,\n        bool whichToken,\n        uint bribeAmount,\n        uint bribePercentage\n    ) external {\n        if(amountToFree > 0) {\n            address(0x0000000000b3F879cb30FE243b4Dfee438691c04).call(abi.encodeWithSelector(0xd8ccd0f3, amountToFree)); // GST2.free()\n        }\n        // uint startBalance = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this));\n        (, bytes memory data) = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).call(abi.encodeWithSelector(0x70a08231, address(this))); // WETH.balanceOf(address);\n        uint startBalance = abi.decode(data, (uint256));\n        // Last trade, check for slippage here\n        if(inputAmount == 0) {\n            // inputAmount = IERC20(inputToken).balanceOf(address(this)) - 1; // Leave 1 token in wallet to prevent storage refund\n            (, data) = inputToken.call(abi.encodeWithSelector(0x70a08231, address(this))); // inputToken.balanceOf(address);\n            inputAmount = abi.decode(data, (uint256)) - 1;\n        } // Might be unexpected if it's a deflationary token. But leave this option\n        // require(IERC20(inputToken).transfer(address(p), inputAmount), \"Transfer to pair failed\");\n        // inputToken.call(abi.encodeWithSelector(0x23b872dd, address(this), address(p), inputAmount));\n        inputToken.call(abi.encodeWithSelector(0xa9059cbb, address(p), inputAmount)); // inputToken.transfer(address,uint256)\n\n        if(outputAmount == 0) {\n            if (whichToken) { // Check what token are we buying, 0 or 1 ?\n                // 1\n                // (uint256 reserveIn, uint256 reserveOut,) = p.getReserves();\n                (, data) = address(p).call(abi.encodeWithSelector(0x0902f1ac));\n                (uint256 reserveIn, uint256 reserveOut,) = abi.decode(data, (uint256, uint256, uint32));\n                inputAmount = inputAmount * 997; // Calculate after fee\n                inputAmount = (inputAmount * reserveOut)/(reserveIn * 1000 + inputAmount); // Calculate outputNeeded\n                // p.swap(0, inputAmount, recipient, \"\"); // Swapping\n                address(p).call(abi.encodeWithSelector(0x0902f1ac, 0, inputAmount, address(this), \"\"));\n            } else {\n                // 0\n                // (uint256 reserveOut, uint256 reserveIn,) = p.getReserves();\n                (, data) = address(p).call(abi.encodeWithSelector(0x0902f1ac));\n                (uint256 reserveOut, uint256 reserveIn,) = abi.decode(data, (uint256, uint256, uint32));\n                inputAmount = inputAmount * 997; // Calculate after fee\n                inputAmount = (inputAmount * reserveOut)/(reserveIn * 1000 + inputAmount); // Calculate outputNeeded\n                // p.swap(inputAmount, 0, recipient, \"\"); // Swapping\n                address(p).call(abi.encodeWithSelector(0x0902f1ac, inputAmount, 0, address(this), \"\"));\n            }\n        } else {\n            if (whichToken) {\n                // p.swap(0, outputAmount, recipient, \"\");\n                address(p).call(abi.encodeWithSelector(0x0902f1ac, 0, outputAmount, address(this), \"\"));\n            } else {\n                // p.swap(outputAmount, 0, recipient, \"\");\n                address(p).call(abi.encodeWithSelector(0x0902f1ac, outputAmount, 0, address(this), \"\"));\n            }\n        }\n\n        // uint balance = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this));\n        (, data) = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).call(abi.encodeWithSelector(0x70a08231, address(this))); // WETH.balanceOf(address);\n        uint balance = abi.decode(data, (uint256));\n        // uint balance = abi.decode(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).call(abi.encodeWithSelector(0x70a08231, address(this)))[1], (uint256));\n        uint profit = balance - startBalance - minOutAmount; // This reverts if not profitable\n        if (bribeAmount == 0) {\n            bribeAmount = profit * bribePercentage / 100;\n        }\n\n        // Should remove this equals sign, but helpful for testing when there's nothing to sandwich\n        require(profit >= bribeAmount, \"Not enough money to pay bribe\"); // however, we may not have enough for the bribe\n        // IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).withdraw(bribeAmount);\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).call(abi.encodeWithSelector(0x2e1a7d4d, bribeAmount)); // WETH.withdraw(uint256);\n        block.coinbase.call{value: bribeAmount}(new bytes(0));\n    }\n}"
    }
  }
}