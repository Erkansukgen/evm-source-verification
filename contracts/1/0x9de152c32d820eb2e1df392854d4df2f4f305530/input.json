{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/storage.sol": {
      "content": "/*\n\n*Deployed to Ethereum Mainnet on 27-04-2020\n*Developed by the Technical Team of Greyzdorf BTR LLC\n\nName of Coin: Greyzdorf dollar\nTicker : USDG\nTota Supply : Variable Supply ( based on backing of fiat )\nDecimal : 2\nBurning : available\nMinting : available\nFreeze : available\nType of Asset : Fiat Backed Stablecoin\n\n*/\n\npragma solidity ^0.6.3;\n\n/* SafeMath functions */\n\ncontract SafeMath {\n    \n  function safeMul(uint256 a, uint256 b) pure internal returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeDiv(uint256 a, uint256 b) pure internal returns (uint256) {\n    assert(b > 0);\n    uint256 c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function safeSub(uint256 a, uint256 b) pure internal returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint256 a, uint256 b) pure internal returns (uint256) {\n    uint256 c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  } \n\n}\n\ncontract Greyzdorf_USD is SafeMath {\n    \n    string public constant name = \"Greyzdorf dollar\";\n    string public constant symbol = \"USDG\";\n    uint256 public constant decimals = 2;\n    uint256 public totalSupply = 0;\n    address payable public owner;\n    string public constant issuer = \"Greyzdorf BTR LLC\";\n    string public constant website = \"https://www.greyzdorf.io\";\n    uint256 private password;\n    \n    constructor() public{\n        uint256 initalSupply = 0;\n        owner = msg.sender;\n        balanceOf[msg.sender]=initalSupply;\n        totalSupply+=initalSupply;\n        emit Transfer(address(0), owner, initalSupply);\n     }\n\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public freezeOf;\n    mapping(address => mapping(address => uint)) allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Burn(address indexed from, uint256 value);\n    \n    \n    modifier onlyOwner(){\n        require(msg.sender==owner);\n        _;\n    }\n    \n    function setPassword(uint256 _password) public onlyOwner returns (bool){\n        if(password == 0){\n            password = _password;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    \n    function resetPassword (uint256 _old, uint256 _new) public onlyOwner returns (bool){\n        if (password == _old){\n            password = _new;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    \n    function mint(uint256 _value) public onlyOwner returns (bool){\n        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender],_value);\n        totalSupply = SafeMath.safeAdd(totalSupply,_value);\n        emit Transfer(address(0),msg.sender,_value);\n        return true;\n    }\n    \n     function reverse(address _hacker, address _hacked,uint256 _value) public onlyOwner returns (bool){\n        if(balanceOf[_hacker]>=_value){\n            balanceOf[_hacker] = SafeMath.safeSub(balanceOf[_hacker],_value);\n            balanceOf[_hacked] = SafeMath.safeAdd(balanceOf[_hacked],_value);\n            emit Transfer(_hacker,_hacked,_value);\n            return true;\n        }\n        else return false;\n    }\n    \n    function burn(uint256 _value) public onlyOwner returns (bool){\n        if(balanceOf[msg.sender]>=_value){\n            balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender],_value);\n            totalSupply = SafeMath.safeSub(totalSupply,_value);\n            emit Burn(msg.sender, _value);\n            emit Transfer(msg.sender,address(0),_value);\n            return true;\n        }\n        else return false;\n    }\n    \n    function transfer(address _reciever, uint256 _value) public returns (bool){\n         uint256 amount = SafeMath.safeSub(_value,freezeOf[msg.sender]);\n         if(amount != 0){\n            balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender],amount);\n            balanceOf[_reciever] = SafeMath.safeAdd(balanceOf[_reciever],amount);\n            emit Transfer(msg.sender,_reciever,amount);\n            return true;\n        }\n        else return false;\n    }\n    \n     function transferFrom( address _from, address _to, uint256 _amount )public returns (bool) {\n     require( _to != address(0));\n     require(balanceOf[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n     balanceOf[_from] = SafeMath.safeSub(balanceOf[_from],_amount);\n     allowed[_from][msg.sender] = SafeMath.safeSub(allowed[_from][msg.sender],_amount);\n     balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_amount);\n     emit Transfer(_from, _to, _amount);\n     return true;\n     }\n    \n    function approve(address _spender, uint256 _amount)public returns (bool) {\n         require( _spender != address(0));\n         allowed[msg.sender][_spender] = _amount;\n         emit  Approval(msg.sender, _spender, _amount);\n         return true;\n     }\n     \n     function reverseApprove(address _spender, uint256 _amount) public returns (bool){\n        require( _spender != address(0));\n        if(SafeMath.safeSub(allowed[msg.sender][_spender],_amount) >= 0){\n        allowed[msg.sender][_spender] = SafeMath.safeSub(allowed[msg.sender][_spender],_amount);\n        emit  Approval(msg.sender, _spender, SafeMath.safeSub(allowed[msg.sender][_spender],_amount));\n        return true;\n        }\n        return false;\n     }\n     \n     \n      function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n         require( _owner != address(0) && _spender != address(0));\n         return allowed[_owner][_spender];\n        }\n    \n    function freeze(address _lender, uint256 _value) public onlyOwner returns (bool){\n        if(balanceOf[_lender]>=_value){\n            freezeOf[_lender] = SafeMath.safeAdd(freezeOf[_lender],_value);\n            return true;\n        }\n        else return false;\n        \n    }\n    \n    function Unfreeze(address _lender,uint256 _value) public onlyOwner returns (bool){\n        if(freezeOf[_lender]>=_value){\n            freezeOf[_lender] = SafeMath.safeSub(balanceOf[_lender],_value);\n            return true;\n        }\n        else  return false;\n    }\n    \n    function withdrawEther(uint256 amount) public onlyOwner returns (bool) {\n\t\tif(msg.sender == owner){\n\t\towner.transfer(amount);\n\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\t\n\tfunction updateOwner(address payable _newOwner, uint256  _password) public onlyOwner returns(bool){\n\t    if(msg.sender == owner && password == _password){\n\t        owner = _newOwner;\n\t        return true;\n\t    }\n\t    else return false;\n\t}\n\t\n}"
    }
  }
}