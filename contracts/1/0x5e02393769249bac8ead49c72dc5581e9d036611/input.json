{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LearnDeFi.sol": {
      "content": "// File: contracts/LDFToken.sol\r\n\r\npragma solidity 0.7.0;\r\n\r\ncontract LDFToken {\r\n    string  public name = \"Learn DeFi \";\r\n    string  public symbol = \"LDF\";\r\n    uint256 public totalSupply = 1000000000000000000000;// 1 million tokens\r\n    uint8   public decimals = 18;\r\n    address public owner;\r\n\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    constructor()  {\r\n         owner = msg.sender;\r\n        balanceOf[msg.sender] = totalSupply;\r\n        allowance[address(this)][owner] = 1000;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= balanceOf[_from]);\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/LearnDeFi.sol\r\n\r\npragma solidity 0.7.0;\r\n\r\ncontract LearnDeFi {\r\n     event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n    string public name = \"Learn DeFi\";\r\n    address public owner;\r\n    LDFToken public ldfToken;\r\n    uint256 public _balances;\r\n    address public learnDeFiAddress;\r\n    address[] public stakers;\r\n    mapping(address => uint) balance;\r\n    mapping (address => uint) public stakingBalance;\r\n    mapping(address => bool) public hasStaked;\r\n    mapping(address => bool) public isStaking;\r\n    mapping (address => uint) public releaseTime;\r\n    uint public constant _TIMELOCK = 90 days;\r\n    constructor (LDFToken _ldfToken )  {\r\n        ldfToken = _ldfToken;\r\n        owner = msg.sender;\r\n        learnDeFiAddress = address(this);\r\n    }\r\nreceive() payable external{\r\n        icoLDF();\r\n    }\r\n  function icoLDF() public payable {\r\n      ldfToken.transfer(msg.sender,msg.value);\r\n    } \r\n    function withDrawlLDF (uint256 amount) public  {\r\n        require(msg.sender == owner);\r\n        ldfToken.transfer(owner,amount);\r\n    }\r\n    function withDrawlETH(uint256 amount) public  {\r\n        require(msg.sender == owner);\r\n        msg.sender.transfer(amount);   \r\n    }\r\n    function isStaker(address _address)public view \r\n    returns (bool,uint256)\r\n    {\r\n        for (uint256 i = 0; i < stakers.length;i++)\r\n        {\r\n            if (_address == stakers[i]) return (true,i);\r\n        }\r\n        return (false,0);\r\n    }\r\n    function approveStake(address _owner,address spender,uint256 amount) public\r\n    returns (address,uint256)\r\n    {\r\n        ldfToken.approve(spender,amount);\r\n        emit Approval(_owner, spender, amount);\r\n        return (spender,amount);\r\n    }\r\n    function addStaker(address _staker,uint256 amount) public \r\n    {       \r\n            ldfToken.transferFrom(_staker,learnDeFiAddress,amount);\r\n            stakers.push(_staker);\r\n            stakingBalance[_staker] = stakingBalance[_staker] += amount;\r\n            releaseTime[msg.sender] = block.timestamp + _TIMELOCK;\r\n    }\r\n    function checkBalanceOf(uint256 amount) public view\r\n    returns(bool)\r\n    {\r\n            uint256 balances ;\r\n            balances = ldfToken.balanceOf(msg.sender);\r\n           require(amount <= balances);\r\n           return true;\r\n    }\r\n    function checkAllowance(uint256 amount) public view\r\n    returns(bool)\r\n    {\r\n         uint256 allowances;\r\n         allowances = ldfToken.allowance(msg.sender,learnDeFiAddress);\r\n         require(amount <= allowances);\r\n         return true;\r\n    }   \r\n    function removeStaker(address _staker,uint256 amount) public \r\n    {\r\n        (bool _isStakeHolder,uint256 s) = isStaker(_staker);\r\n        {   \r\n            require(_isStakeHolder);\r\n            require(block.timestamp > releaseTime[_staker],\"Your staked LDF is still locked\");\r\n            stakingBalance[msg.sender] = stakingBalance[msg.sender]-= amount;\r\n            ldfToken.transfer(msg.sender,amount);\r\n            stakers[s] = stakers[stakers.length -1];\r\n            stakers.pop();\r\n        }\r\n    }\r\n    function stakeOf(address _staker) public view\r\n    returns(uint256)\r\n    {\r\n        return stakingBalance[_staker];\r\n    }\r\n}"
    }
  }
}