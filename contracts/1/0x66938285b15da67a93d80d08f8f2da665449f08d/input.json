{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/AXLPresale.sol": {
      "content": "// BSC\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal{\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero.\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n    \n    // sends ETH or an erc20 token\n    function safeTransferBaseToken(address token, address payable to, uint value, bool isERC20) internal {\n        if (!isERC20) {\n            to.transfer(value);\n        } else {\n            (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n            require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n        }\n    }\n}\n\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds.\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    \n    function decimals() external view returns (uint8);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ncontract AXLPresale is ReentrancyGuard {\n    using SafeMath for uint256;\n\n\n    struct PresaleInfo {\n        address sale_token; // Sale token\n        uint256 token_rate; // 1 base token = ? s_tokens, fixed price\n        uint256 raise_min; // Maximum base token BUY amount per buyer\n        uint256 raise_max; // The amount of presale tokens up for presale\n        uint256 softcap; // Minimum raise amount\n        uint256 hardcap; // Maximum raise amount\n        uint256 presale_start;\n        uint256 presale_end;\n    }\n\n    struct PresaleStatus {\n        bool force_failed; // Set this flag to force fail the presale\n        uint256 raised_amount; // Total base currency raised (usually ETH)\n        uint256 sold_amount; // Total presale tokens sold\n        uint256 token_withdraw; // Total tokens withdrawn post successful presale\n        uint256 base_withdraw; // Total base tokens withdrawn on presale failure\n        uint256 num_buyers; // Number of unique participants\n    }\n\n    struct BuyerInfo {\n        uint256 base; // Total base token (usually ETH) deposited by user, can be withdrawn on presale failure\n        uint256 sale; // Num presale tokens a user owned, can be withdrawn on presale success\n    }\n    \n    struct TokenInfo {\n        string name;\n        string symbol;\n        uint256 totalsupply;\n        uint256 decimal;\n    }\n  \n    address owner;\n\n    PresaleInfo public presale_info;\n    PresaleStatus public status;\n    TokenInfo public tokeninfo;\n\n    uint256 persaleSetting;\n\n    mapping(address => BuyerInfo) public buyers;\n\n    event UserDepsitedSuccess(address, uint256);\n    event UserWithdrawSuccess(uint256);\n    event UserWithdrawTokensSuccess(uint256);\n\n    address deadaddr = 0x000000000000000000000000000000000000dEaD;\n    uint256 public lock_delay;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Not presale owner.\");\n        _;\n    }\n\n    constructor() public{\n        owner = msg.sender;\n    }\n\n    function init_private (\n        address _sale_token,\n        uint256 _token_rate,\n        uint256 _raise_min, \n        uint256 _raise_max, \n        uint256 _softcap, \n        uint256 _hardcap,\n        uint256 _presale_start,\n        uint256 _presale_end\n        ) public onlyOwner {\n\n        require(persaleSetting == 0, \"Already setted\");\n        require(_sale_token != address(0), \"Zero Address\");\n        \n        presale_info.sale_token = address(_sale_token);\n        presale_info.token_rate = _token_rate;\n        presale_info.raise_min = _raise_min;\n        presale_info.raise_max = _raise_max;\n        presale_info.softcap = _softcap;\n        presale_info.hardcap = _hardcap;\n\n        presale_info.presale_end = _presale_end;\n        presale_info.presale_start =  _presale_start;\n        \n        //Set token token info\n        tokeninfo.name = IERC20(presale_info.sale_token).name();\n        tokeninfo.symbol = IERC20(presale_info.sale_token).symbol();\n        tokeninfo.decimal = IERC20(presale_info.sale_token).decimals();\n        tokeninfo.totalsupply = IERC20(presale_info.sale_token).totalSupply();\n\n        persaleSetting = 1;\n    }\n\n    function presaleStatus() public view returns (uint256) {\n        if ((block.timestamp > presale_info.presale_end) && (status.raised_amount < presale_info.softcap)) {\n            return 3; // Failure\n        }\n        if (status.raised_amount >= presale_info.hardcap) {\n            return 2; // Wonderful - reached to Hardcap\n        }\n        if ((block.timestamp > presale_info.presale_end) && (status.raised_amount >= presale_info.softcap)) {\n            return 2; // SUCCESS - Presale ended with reaching Softcap\n        }\n        if ((block.timestamp >= presale_info.presale_start) && (block.timestamp <= presale_info.presale_end)) {\n            return 1; // ACTIVE - Deposits enabled, now in Presale\n        }\n            return 0; // QUED - Awaiting start block\n    }\n    \n    // Accepts msg.value for eth or _amount for ERC20 tokens\n    function userDeposit () public payable nonReentrant {\n        require(presaleStatus() == 1, \"Not Active\");\n        require(presale_info.raise_min <= msg.value, \"Balance is insufficent\");\n        require(presale_info.raise_max >= msg.value, \"Balance is too much\");\n\n        BuyerInfo storage buyer = buyers[msg.sender];\n\n        uint256 amount_in = msg.value;\n        uint256 allowance = presale_info.raise_max.sub(buyer.base);\n        uint256 remaining = presale_info.hardcap - status.raised_amount;\n\n        allowance = allowance > remaining ? remaining : allowance;\n        if (amount_in > allowance) {\n            amount_in = allowance;\n        }\n\n        uint256 tokensSold = amount_in.mul(presale_info.token_rate);\n\n        require(tokensSold > 0, \"ZERO TOKENS\");\n        require(status.raised_amount * presale_info.token_rate <= IERC20(presale_info.sale_token).balanceOf(address(this)), \"Token remain error\");\n        \n        if (buyer.base == 0) {\n            status.num_buyers++;\n        }\n        buyers[msg.sender].base = buyers[msg.sender].base.add(amount_in);\n        buyers[msg.sender].sale = buyers[msg.sender].sale.add(tokensSold);\n        status.raised_amount = status.raised_amount.add(amount_in);\n        status.sold_amount = status.sold_amount.add(tokensSold);\n        \n        // return unused ETH\n        if (amount_in < msg.value) {\n            msg.sender.transfer(msg.value.sub(amount_in));\n        }\n        \n        emit UserDepsitedSuccess(msg.sender, msg.value);\n    }\n    \n    // withdraw presale tokens\n    // percentile withdrawls allows fee on transfer or rebasing tokens to still work\n    function userWithdrawTokens () public nonReentrant {\n        require(presaleStatus() == 2, \"Not succeeded\"); // Success\n        require(block.timestamp >= presale_info.presale_end + lock_delay, \"Token Locked.\"); // Lock duration check\n        \n        BuyerInfo storage buyer = buyers[msg.sender];\n        uint256 remaintoken = status.sold_amount.sub(status.token_withdraw);\n        require(remaintoken >= buyer.sale, \"Nothing to withdraw.\");\n        \n        TransferHelper.safeTransfer(address(presale_info.sale_token), msg.sender, buyer.sale);\n        \n        status.token_withdraw = status.token_withdraw.add(buyer.sale);\n        buyers[msg.sender].sale = 0;\n        buyers[msg.sender].base = 0;\n        \n        emit UserWithdrawTokensSuccess(buyer.sale);\n    }\n    \n    // On presale failure\n    // Percentile withdrawls allows fee on transfer or rebasing tokens to still work\n    function userWithdrawBaseTokens () public nonReentrant {\n        require(presaleStatus() == 3, \"Not failed.\"); // FAILED\n        \n        // Refund\n        BuyerInfo storage buyer = buyers[msg.sender];\n        \n        uint256 remainingBaseBalance = address(this).balance;\n        \n        require(remainingBaseBalance >= buyer.base, \"Nothing to withdraw.\");\n\n        status.base_withdraw = status.base_withdraw.add(buyer.base);\n        \n        address payable reciver = payable(msg.sender);\n        reciver.transfer(buyer.base);\n\n        if(msg.sender == owner) {\n            ownerWithdrawTokens();\n            // return;\n        }\n\n        buyer.base = 0;\n        buyer.sale = 0;\n        \n        emit UserWithdrawSuccess(buyer.base);\n        // TransferHelper.safeTransferBaseToken(address(presale_info.base_token), msg.sender, tokensOwed, false);\n    }\n    \n    // On presale failure\n    // Allows the owner to withdraw the tokens they sent for presale\n    function ownerWithdrawTokens () private onlyOwner {\n        require(presaleStatus() == 3, \"Only failed status.\"); // FAILED\n        TransferHelper.safeTransfer(address(presale_info.sale_token), owner, IERC20(presale_info.sale_token).balanceOf(address(this)));\n        \n        emit UserWithdrawSuccess(IERC20(presale_info.sale_token).balanceOf(address(this)));\n    }\n\n    function purchaseICOCoin () public nonReentrant onlyOwner {\n        require(presaleStatus() == 2, \"Not succeeded\"); // Success\n        \n        address payable reciver = payable(owner);\n        reciver.transfer(address(this).balance);\n    }\n\n    function getTimestamp () public view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function setLockDelay (uint256 delay) public onlyOwner {\n        lock_delay = delay;\n    }\n\n    function remainingBurn() public onlyOwner {\n        require(presaleStatus() == 2, \"Not succeeded\"); // Success\n        require(presale_info.hardcap * presale_info.token_rate >= status.sold_amount, \"Nothing to burn\");\n        \n        //uint256 rushTokenAmount = IERC20(presale_info.sale_token).balanceOf(address(this)) - status.sold_amount * (10 ** tokeninfo.decimal);\n        uint256 rushTokenAmount = presale_info.hardcap * presale_info.token_rate - status.sold_amount;\n\n        TransferHelper.safeTransfer(address(presale_info.sale_token), address(deadaddr), rushTokenAmount);\n    }\n}"
    }
  }
}