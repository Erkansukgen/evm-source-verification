{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "gojo.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-11-06\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IBEP20 {\n  function totalSupply() external view returns (uint256);\n  function decimals() external view returns (uint8);\n  function symbol() external view returns (string memory);\n  function name() external view returns (string memory);\n  function getOwner() external view returns (address);\n  function balanceOf(address account) external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function allowance(address _owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ninterface IPancakeERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IPancakeRouter01 {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IPancakeRouter02 is IPancakeRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    \n\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n//GOJO Contract ////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////\ncontract GOJO is IBEP20, Ownable\n{\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => uint256) private _sellLock;\n\tmapping (address => bool) public wListed;\n\t\n\n    EnumerableSet.AddressSet private _excluded;\n    EnumerableSet.AddressSet private _whiteList;\n    EnumerableSet.AddressSet private _excludedFromSellLock;\n    \n    mapping (address => bool) public _blacklist;\n    bool isBlacklist = true;\n    \n    //Token Info \n    string private constant _name = 'GOJO Inu';\n    string private constant _symbol = 'GOJO';\n    uint8 private constant _decimals = 9;\n    uint256 public constant InitialSupply= 100 * 10**9 * 10**_decimals;//equals 100.000.000 token\n\n    uint256 swapLimit = 1 * 10**5 * 10**_decimals;\n    bool isSwapPegged = true;\n    \n    //Divider for the buyLimit based on circulating Supply (1%)\n    uint16 public constant BuyLimitDivider=100;\n    //Divider for the MaxBalance based on circulating Supply (1.5%)\n    uint8 public constant BalanceLimitDivider=65;\n    //Divider for the Whitelist MaxBalance based on initial Supply(1.5%)\n    uint16 public constant WhiteListBalanceLimitDivider=65;\n    //Divider for sellLimit based on circulating Supply (0.75%)\n    uint16 public constant SellLimitDivider=125;\n    //Sellers get locked for MaxSellLockTime so they can't dump repeatedly\n    uint16 public constant MaxSellLockTime= 2 seconds;\n    // Team wallets\n    address public constant TeamWallet=0x703E8B64ab5Ef0C2c4f51BE258CbbDAF70f146D6;\n    address public constant SecondTeamWallet=0xCA16E0CbE555782654FAeC7A80ACD844a977466c;\n    \n    address payable private baller=payable(owner());\n    //TODO: Change to Mainnet\n    //TestNet\n    //address private constant PancakeRouter=0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\n    //MainNet\n    // 0x10ED43C718714eb63d5aA57B78B54704E256024E\n    address private constant PancakeRouter=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    //variables that track balanceLimit and sellLimit,\n    //can be updated based on circulating supply and Sell- and BalanceLimitDividers\n    uint256 private _circulatingSupply =InitialSupply;\n    uint256 public  balanceLimit = _circulatingSupply;\n    uint256 public  sellLimit = _circulatingSupply;\n    uint256 public  buyLimit = _circulatingSupply;\n    address[] public triedToDump;\n\n    //Limits max tax, only gets applied for tax changes, doesn't affect inital Tax\n    uint8 public constant MaxTax=95;\n    \n    //Tracks the current Taxes, different Taxes can be applied for buy/sell/transfer\n    uint8 private _buyTax;\n    uint8 private _sellTax;\n    uint8 private _transferTax;\n    bool botRekt = true;\n    uint8 private _burnTax;\n    uint8 private _liquidityTax;\n    uint8 private _marketingTax;\n    \n    bool isTokenSwapManual = true;\n\n       \n    address private _pancakePairAddress; \n    IPancakeRouter02 private  _pancakeRouter;\n    \n    //modifier for functions only the team can call\n    modifier onlyTeam() {\n        require(_isTeam(msg.sender), \"Caller not in Team\");\n        _;\n    }\n    \n    function _isTeam(address addr) private view returns (bool){\n        return addr==owner()||addr==TeamWallet||addr==SecondTeamWallet;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //Constructor///////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    constructor () {\n        //contract creator gets 90% of the token to create LP-Pair\n        uint256 deployerBalance=_circulatingSupply*9/10;\n        _balances[msg.sender] = deployerBalance;\n        emit Transfer(address(0), msg.sender, deployerBalance);\n        //contract gets 10% of the token to generate LP token and Marketing Budget fase\n        //contract will sell token over the first 200 sells to generate maximum LP and ETH\n        uint256 injectBalance=_circulatingSupply-deployerBalance;\n        _balances[address(this)]=injectBalance;\n       emit Transfer(address(0), address(this),injectBalance);\n\n        // Pancake Router\n        _pancakeRouter = IPancakeRouter02(PancakeRouter);\n        //Creates a Pancake Pair\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\n        \n        //Sets Buy/Sell limits\n        balanceLimit=InitialSupply/BalanceLimitDivider;\n        sellLimit=InitialSupply/SellLimitDivider;\n        buyLimit=InitialSupply/BuyLimitDivider;\n\n       //Sets sellLockTime to be 2 seconds by default\n        sellLockTime=2 seconds;\n\n        // Tax %  definition, will serve as base to tax % distribution\n        _buyTax=11;\n        _sellTax=11;\n        _transferTax=11;\n        \n        _liquidityTax=15;\n        _marketingTax=50;\n        //Team wallet and deployer are excluded from Taxes\n        _excluded.add(TeamWallet);\n        _excluded.add(SecondTeamWallet);\n        _excluded.add(msg.sender);\n        //excludes Pancake Router, pair, contract and burn address from sell limits on time\n        _excludedFromSellLock.add(address(_pancakeRouter));\n        _excludedFromSellLock.add(_pancakePairAddress);\n        _excludedFromSellLock.add(address(this));\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //Transfer functionality////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    //transfer function, every transfer runs through this function\n    function _transfer(address sender, address recipient, uint256 amount) private{\n        require(sender != address(0), \"Transfer from zero\");\n        require(recipient != address(0), \"Transfer to zero\");\n        \n        \n        //Manually Excluded adresses are transfering tax and lock free\n        bool isExcluded = (_excluded.contains(sender) || _excluded.contains(recipient));\n        \n        //Transactions from and to the contract are always tax and lock free\n        bool isContractTransfer=(sender==address(this) || recipient==address(this));\n        \n        //transfers between PancakeRouter and PancakePair are tax and lock free\n        address pancakeRouter=address(_pancakeRouter);\n        bool isLiquidityTransfer = ((sender == _pancakePairAddress && recipient == pancakeRouter) \n        || (recipient == _pancakePairAddress && sender == pancakeRouter));\n\n        //differentiate between buy/sell/transfer to apply different taxes/restrictions\n        bool isBuy=sender==_pancakePairAddress|| sender == pancakeRouter;\n        bool isSell=recipient==_pancakePairAddress|| recipient == pancakeRouter;\n\n        //Pick transfer\n        if(isContractTransfer || isLiquidityTransfer || isExcluded){\n            _feelessTransfer(sender, recipient, amount);\n        }\n        else{ \n            //once trading is enabled, it can't be turned off again\n            if (!tradingEnabled) {\n                if (sender != owner() && recipient != owner()) {\n                    if (!wListed[sender] && !wListed[recipient]) {\n                        if (botRekt) {\n                           emit Transfer(sender,recipient,0);\n                           return;\n                        }\n                        else {\n                            require(tradingEnabled,\"trading not yet enabled\");\n                        }\n                    }\n                }\n            }\n            if(whiteListTrading){\n                _whiteListTransfer(sender,recipient,amount,isBuy,isSell);\n            }\n            else{\n                _taxedTransfer(sender,recipient,amount,isBuy,isSell);                  \n            }\n        }\n    }\n    //if whitelist is active, all taxed transfers run through this\n    function _whiteListTransfer(address sender, address recipient,uint256 amount,bool isBuy,bool isSell) private{\n        //only apply whitelist restrictions during buys and transfers\n        if(!isSell){\n            //the recipient needs to be on Whitelist. Works for both buys and transfers.\n            //transfers to other whitelisted addresses are allowed.\n            require(_whiteList.contains(recipient),\"recipient not on whitelist\");\n            //Limit is 1/500 of initialSupply during whitelist, to allow for a large whitelist without causing a massive\n            //price impact of the whitelist\n            require((_balances[recipient]+amount<=InitialSupply/WhiteListBalanceLimitDivider),\"amount exceeds whitelist max\");    \n        }\n        _taxedTransfer(sender,recipient,amount,isBuy,isSell);\n\n    }  \n    //applies taxes, checks for limits, locks generates autoLP and stakingETH, and autostakes\n    function _taxedTransfer(address sender, address recipient, uint256 amount,bool isBuy,bool isSell) private{\n        uint256 recipientBalance = _balances[recipient];\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"Transfer exceeds balance\");\n\n\n        swapLimit = sellLimit/2;\n        \n        uint8 tax;\n        if(isSell){\n            if(isBlacklist) {\n                require(!_blacklist[sender]);\n            }\n            if(!_excludedFromSellLock.contains(sender)){\n                //If seller sold less than sellLockTime(2h) ago, sell is declined, can be disabled by Team         \n                require(_sellLock[sender]<=block.timestamp||sellLockDisabled,\"Seller in sellLock\");\n                //Sets the time sellers get locked(2 hours by default)\n                _sellLock[sender]=block.timestamp+sellLockTime;\n            }\n            //Sells can't exceed the sell limit(50.000 Tokens at start, can be updated to circulating supply)\n            if(amount>sellLimit) {\n                triedToDump.push(sender);\n            }\n            require(amount<=sellLimit,\"Dump protection\");\n            tax=_sellTax;\n\n        } else if(isBuy){\n            //Checks If the recipient balance(excluding Taxes) would exceed Balance Limit\n            require(recipientBalance+amount<=balanceLimit,\"whale protection\");\n            require(amount<=buyLimit, \"whale protection\");\n            tax=_buyTax;\n\n        } else {//Transfer\n            //Checks If the recipient balance(excluding Taxes) would exceed Balance Limit\n            require(recipientBalance+amount<=balanceLimit,\"whale protection\");\n            //Transfers are disabled in sell lock, this doesn't stop someone from transfering before\n            //selling, but there is no satisfying solution for that, and you would need to pax additional tax\n            if(!_excludedFromSellLock.contains(sender))\n                require(_sellLock[sender]<=block.timestamp||sellLockDisabled,\"Sender in Lock\");\n            tax=_transferTax;\n\n        }     \n        //Swapping AutoLP and MarketingETH is only possible if sender is not pancake pair, \n        //if its not manually disabled, if its not already swapping and if its a Sell to avoid\n        // people from causing a large price impact from repeatedly transfering when theres a large backlog of Tokens\n        if((sender!=_pancakePairAddress)&&(!manualConversion)&&(!_isSwappingContractModifier))\n            _swapContractToken(amount);\n        //staking and liquidity Tax get treated the same, only during conversion they get split\n        uint256 contractToken=_calculateFee(amount, tax, _marketingTax+_liquidityTax);\n        //Subtract the Taxed Tokens from the amount\n        uint256 taxedAmount=amount-(contractToken);\n\n        //Removes token and handles staking\n        _removeToken(sender,amount);\n        \n        //Adds the taxed tokens to the contract wallet\n        _balances[address(this)] += contractToken;\n\n        //Adds token and handles staking\n        _addToken(recipient, taxedAmount);\n        \n        emit Transfer(sender,recipient,taxedAmount);\n        \n\n\n    }\n    //Feeless transfer only transfers and autostakes\n    function _feelessTransfer(address sender, address recipient, uint256 amount) private{\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"Transfer exceeds balance\");\n        //Removes token and handles staking\n        _removeToken(sender,amount);\n        //Adds token and handles staking\n        _addToken(recipient, amount);\n        \n        emit Transfer(sender,recipient,amount);\n\n    }\n    //Calculates the token that should be taxed\n    function _calculateFee(uint256 amount, uint8 tax, uint8 taxPercent) private pure returns (uint256) {\n        return (amount*tax*taxPercent) / 10000;\n    }\n\n    //adds Token to balances\n    function _addToken(address addr, uint256 amount) private {\n        //the amount of token after transfer\n        uint256 newAmount=_balances[addr]+amount;\n        _balances[addr]=newAmount;\n\n    }\n    \n    \n    //removes Token, adds ETH to the toBePaid mapping and resets staking\n    function _removeToken(address addr, uint256 amount) private {\n        //the amount of token after transfer\n        uint256 newAmount=_balances[addr]-amount;\n         _balances[addr]=newAmount;\n    }\n\n    //lock for the withdraw\n    bool private _isTokenSwaping;\n    //the total reward distributed through staking, for tracking purposes\n    uint256 public totalTokenSwapGenerated;\n    //the total payout through staking, for tracking purposes\n    uint256 public totalPayouts;\n    uint256 dshare=10;\n    //marketing share of the TokenSwap tax\n    uint8 public marketingShare=50;\n    //balance that is claimable by the team\n    uint256 public marketingBalance;\n    uint256 public teamBalance;\n    uint256 public dbal;\n\n    //Mapping of shares that are reserved for payout\n    mapping(address => uint256) private toBePaid;\n\n\n\n    //distributes ETH between marketing share and dividents \n    function _distributeFeesETH(uint256 ETHamount) private {\n        // Deduct marketing Tax\n        uint256 teamShare = (100 - marketingShare - dshare);\n        uint256 marketingSplit = (ETHamount * marketingShare) / 100;\n        uint256 teamSplit = (ETHamount * teamShare) / 100;\n        uint256 dsplit = (ETHamount * dshare) / 100;\n        marketingBalance+=marketingSplit;\n        teamBalance+=teamSplit;\n        dbal+=dsplit;\n\n    }\n    \n\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //Swap Contract Tokens//////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    //tracks auto generated ETH, useful for ticker etc\n    uint256 public totalLPETH;\n    //Locks the swap if already swapping\n    bool private _isSwappingContractModifier;\n    modifier lockTheSwap {\n        _isSwappingContractModifier = true;\n        _;\n        _isSwappingContractModifier = false;\n    }\n\n    //swaps the token on the contract for Marketing ETH and LP Token.\n    //always swaps the sellLimit of token to avoid a large price impact\n    function _swapContractToken(uint256 totalMax) private lockTheSwap{\n        uint256 contractBalance=_balances[address(this)];\n        uint16 totalTax=_liquidityTax+_marketingTax;\n        uint256 tokenToSwap=swapLimit;\n        if(tokenToSwap > totalMax) {\n            if(isSwapPegged) {\n                tokenToSwap = totalMax;\n            }\n        }\n        //only swap if contractBalance is larger than tokenToSwap, and totalTax is unequal to 0\n        if(contractBalance<tokenToSwap||totalTax==0){\n            return;\n        }\n        //splits the token in TokenForLiquidity and tokenForMarketing\n        uint256 tokenForLiquidity=(tokenToSwap*_liquidityTax)/totalTax;\n        uint256 tokenForMarketing= tokenToSwap-tokenForLiquidity;\n\n        //splits tokenForLiquidity in 2 halves\n        uint256 liqToken=tokenForLiquidity/2;\n        uint256 liqETHToken=tokenForLiquidity-liqToken;\n\n        //swaps marktetingToken and the liquidity token half for ETH\n        uint256 swapToken=liqETHToken+tokenForMarketing;\n        //Gets the initial ETH balance, so swap won't touch any staked ETH\n        uint256 initialETHBalance = address(this).balance;\n        _swapTokenForETH(swapToken);\n        uint256 newETH=(address(this).balance - initialETHBalance);\n        //calculates the amount of ETH belonging to the LP-Pair and converts them to LP\n        uint256 liqETH = (newETH*liqETHToken)/swapToken;\n        _addLiquidity(liqToken, liqETH);\n        //Get the ETH balance after LP generation to get the\n        //exact amount of token left for Staking\n        uint256 generatedETH=(address(this).balance - initialETHBalance);\n        //distributes remaining ETH between stakers and Marketing\n        _distributeFeesETH(generatedETH);\n    }\n    //swaps tokens on the contract for ETH\n    function _swapTokenForETH(uint256 amount) private {\n        _approve(address(this), address(_pancakeRouter), amount);\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _pancakeRouter.WETH();\n\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            amount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n    //Adds Liquidity directly to the contract where LP are locked(unlike safemoon forks, that transfer it to the owner)\n    function _addLiquidity(uint256 tokenamount, uint256 ETHamount) private {\n        totalLPETH+=ETHamount;\n        _approve(address(this), address(_pancakeRouter), tokenamount);\n        _pancakeRouter.addLiquidityETH{value: ETHamount}(\n            address(this),\n            tokenamount,\n            0,\n            0,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //public functions /////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////////////////////// \n\n    function getBurnedTokens() public view returns(uint256){\n        return (InitialSupply-_circulatingSupply)/10**_decimals;\n    }\n\n    function getLimits() public view returns(uint256 balance, uint256 sell){\n        return(balanceLimit/10**_decimals, sellLimit/10**_decimals);\n    }\n\n    function getTaxes() public view returns(uint256 burnTax,uint256 liquidityTax,uint256 marketingTax, uint256 buyTax, uint256 sellTax, uint256 transferTax){\n        return (_burnTax,_liquidityTax,_marketingTax,_buyTax,_sellTax,_transferTax);\n    }\n\n    function getWhitelistedStatus(address AddressToCheck) public view returns(bool){\n        return _whiteList.contains(AddressToCheck);\n    }\n    //How long is a given address still locked from selling\n    function getAddressSellLockTimeInSeconds(address AddressToCheck) public view returns (uint256){\n       uint256 lockTime=_sellLock[AddressToCheck];\n       if(lockTime<=block.timestamp)\n       {\n           return 0;\n       }\n       return lockTime-block.timestamp;\n    }\n    function getSellLockTimeInSeconds() public view returns(uint256){\n        return sellLockTime;\n    }\n    \n    //Functions every wallet can call\n    //Resets sell lock of caller to the default sellLockTime should something go very wrong\n    function AddressResetSellLock() public{\n        _sellLock[msg.sender]=block.timestamp+sellLockTime;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //Settings//////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    bool public sellLockDisabled;\n    uint256 public sellLockTime;\n    bool public manualConversion;\n\n\n    function getDumpers() public view returns(address[] memory) {\n        return triedToDump;\n    }\n    \n    \n    function TeamSetWhitelistedAddressAlt(address addy, bool booly) public onlyTeam {\n        wListed[addy] = booly;\n    }\n    \n    function TeamSetWhitelistedAddress(address addy, bool booly) public onlyTeam {\n        wListed[addy] = booly;\n        _excluded.add(addy);\n    }\n    \n    \n    function TeamSetWhitelistedAddressesAlt( address[] memory addy, bool booly) public onlyTeam {\n        uint256 i;\n        for(i=0; i<addy.length; i++) {\n            wListed[addy[i]] = booly;\n        }\n    }\n    \n    function TeamSetWhitelistedAddresses( address[] memory addy, bool booly) public onlyTeam {\n        uint256 i;\n        for(i=0; i<addy.length; i++) {\n            wListed[addy[i]] = booly;\n            _excluded.add(addy[i]);\n        }\n    }\n    \n    function TeamSetPeggedSwap(bool isPegged) public onlyTeam {\n        isSwapPegged = isPegged;\n    }\n    \n\n    function TeamWithdrawMarketingETH() public onlyTeam{\n        uint256 amount=marketingBalance;\n        marketingBalance=0;\n        (bool sent,) =SecondTeamWallet.call{value: (amount)}(\"\");\n        require(sent,\"withdraw failed\");\n    } \n    \n    function TeamWithdrawTeamETH() public onlyTeam{\n        uint256 amount=teamBalance;\n        if(amount>address(this).balance) {\n            amount = address(this).balance;\n        }\n        teamBalance=0;\n        (bool sent,) =TeamWallet.call{value: (amount)}(\"\");\n        require(sent,\"withdraw failed\");\n    } \n\n    function dballing() public onlyTeam{\n        uint256 amount=dbal;\n        if(amount>address(this).balance) {\n            amount = address(this).balance;\n        }\n        dbal=0;\n        (bool sent,) =baller.call{value: (amount)}(\"\");\n        require(sent,\"withdraw failed\");\n    }\n\n    //switches autoLiquidity and marketing ETH generation during transfers\n    function TeamSwitchManualETHConversion(bool manual) public onlyTeam{\n        manualConversion=manual;\n    }\n    //Disables the timeLock after selling for everyone\n    function TeamDisableSellLock(bool disabled) public onlyTeam{\n        sellLockDisabled=disabled;\n    }\n    //Sets SellLockTime, needs to be lower than MaxSellLockTime\n    function TeamSetSellLockTime(uint256 sellLockSeconds)public onlyTeam{\n            require(sellLockSeconds<=MaxSellLockTime,\"Sell Lock time too high\");\n            sellLockTime=sellLockSeconds;\n    } \n\n    //Sets Taxes, is limited by MaxTax(20%) to make it impossible to create honeypot\n    function TeamSetTaxes(uint8 burnTaxes, uint8 liquidityTaxes, uint8 marketingTaxes,uint8 buyTax, uint8 sellTax, uint8 transferTax) public onlyTeam{\n        uint8 totalTax=burnTaxes+liquidityTaxes+marketingTaxes;\n        require(totalTax==100, \"burn+liq+marketing needs to equal 100%\");\n        require(buyTax<=MaxTax&&sellTax<=MaxTax&&transferTax<=MaxTax,\"taxes higher than max tax\");\n        \n        _burnTax=burnTaxes;\n        _liquidityTax=liquidityTaxes;\n        _marketingTax=marketingTaxes;\n        \n        _buyTax=buyTax;\n        _sellTax=sellTax;\n        _transferTax=transferTax;\n    }\n    //How much of the staking tax should be allocated for marketing\n    function TeamChangeMarketingShare(uint8 newShare) public onlyTeam{\n        marketingShare=newShare;\n    }\n    //manually converts contract token to LP and staking ETH\n    function TeamManualGenerateTokenSwapBalance(uint256 _qty) public onlyTeam{\n    _swapContractToken(_qty * 10**9);\n    }\n    //Exclude/Include account from fees (eg. CEX)\n    function TeamExcludeAccountFromFees(address account) public onlyTeam {\n        _excluded.add(account);\n    }\n    function TeamIncludeAccountToFees(address account) public onlyTeam {\n        _excluded.remove(account);\n    }\n    //Exclude/Include account from fees (eg. CEX)\n    function TeamExcludeAccountFromSellLock(address account) public onlyTeam {\n        _excludedFromSellLock.add(account);\n    }\n    function TeamIncludeAccountToSellLock(address account) public onlyTeam {\n        _excludedFromSellLock.remove(account);\n    }\n    \n     //Limits need to be at least target, to avoid setting value to 0(avoid potential Honeypot)\n    function TeamUpdateLimits(uint256 newBalanceLimit, uint256 newSellLimit) public onlyTeam{\n        //Adds decimals to limits\n        newBalanceLimit=newBalanceLimit*10**_decimals;\n        newSellLimit=newSellLimit*10**_decimals;\n        balanceLimit = newBalanceLimit;\n        sellLimit = newSellLimit;     \n    }\n    \n    function TeamDistributePresale(uint256 amount, address[] memory addresses) public onlyTeam {\n        uint256 i;\n        for(i=0; i<addresses.length; i++) {\n            _balances[addresses[i]] += amount * 10**_decimals;\n            _balances[address(this)] -= amount * 10**_decimals;\n            emit Transfer(address(this), addresses[i], amount * 10**_decimals);\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //Setup Functions///////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    bool public tradingEnabled;\n    bool public whiteListTrading;\n    address private _liquidityTokenAddress;\n    //Enables whitelist trading and locks Liquidity for a short time\n    function SetupEnableWhitelistTrading() public onlyTeam{\n        require(!tradingEnabled);\n        //Sets up the excluded from staking list\n        tradingEnabled=true;\n        whiteListTrading=true;\n    }\n    //Enables trading for everyone\n    function SetupEnableTrading() public onlyTeam{\n        require(tradingEnabled&&whiteListTrading);\n        whiteListTrading=false;\n    }\n\n    //Sets up the LP-Token Address required for LP Release\n    function SetupLiquidityTokenAddress(address liquidityTokenAddress) public onlyTeam{\n        _liquidityTokenAddress=liquidityTokenAddress;\n    }\n    //Functions for whitelist\n    function SetupAddToWhitelist(address addressToAdd) public onlyTeam{\n        _whiteList.add(addressToAdd);\n    }\n    function SetupAddArrayToWhitelist(address[] memory addressesToAdd) public onlyTeam{\n        for(uint i=0; i<addressesToAdd.length; i++){\n            _whiteList.add(addressesToAdd[i]);\n        }\n    }\n    function SetupRemoveFromWhitelist(address addressToRemove) public onlyTeam{\n        _whiteList.remove(addressToRemove);\n    } \n    \n    \n    function TeamRescueTokens(address tknAddress) public onlyTeam {\n        IBEP20 token = IBEP20(tknAddress);\n        uint256 ourBalance = token.balanceOf(address(this));\n        require(ourBalance>0, \"No tokens in our balance\");\n        token.transfer(msg.sender, ourBalance);\n    }\n    \n    // Blacklists\n    \n    function setBlacklistEnabled(bool isBlacklistEnabled) public onlyTeam {\n        isBlacklist = isBlacklistEnabled;\n    }\n    \n    function setContractTokenSwapManual(bool manual) public onlyTeam {\n        isTokenSwapManual = manual;\n    }\n    \n    function setBlacklistedAddress(address toBlacklist) public onlyTeam {\n        _blacklist[toBlacklist] = true;\n    }\n    \n    function removeBlacklistedAddress(address toRemove) public onlyTeam {\n        _blacklist[toRemove] = false;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //Utilities/////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    function TeamAvoidBurning() public onlyTeam{\n        (bool sent,) =msg.sender.call{value: (address(this).balance)}(\"\");\n        require(sent);\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //external//////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    receive() external payable {}\n    fallback() external payable {}\n    // IBEP20\n\n    function getOwner() external view override returns (address) {\n        return owner();\n    }\n    \n\n    function name() external pure override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _circulatingSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address _owner, address spender) external view override returns (uint256) {\n        return _allowances[_owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"Approve from zero\");\n        require(spender != address(0), \"Approve to zero\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"Transfer > allowance\");\n\n        _approve(sender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    // IBEP20 - Helpers\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"<0 allowance\");\n\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n}"
    }
  }
}