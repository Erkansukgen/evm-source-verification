{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 9999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/StandardToken.sol": {
      "content": "// Sources flattened with hardhat v2.0.3 https://hardhat.org\n\n/**\n * SPDX-License-Identifier: LGPL-3.0-or-later\n *\n */\npragma solidity ^0.6.0;\n\nabstract contract AbstractERC20 {\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal virtual;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual;\n}\n\nabstract contract AbstractERC2612 is AbstractERC20 {\n    bytes32 public constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string private _version;\n\n    mapping(address => uint256) public nonces;\n\n    /**\n     * @notice Initialize EIP712 Domain Separator\n     * @param version     version of contract\n     * @param name        name of contract\n     */\n    function _initDomainSeparator(string memory version, string memory name)\n        internal\n    {\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        _version = version;\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(bytes(name)), // name\n                keccak256(bytes(version)), // version\n                chainId, // chainid\n                address(this) // this address\n            )\n        );\n    }\n\n    function _permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        require(owner != address(0), \"ERC2612/Invalid-address-0\");\n        require(deadline >= now, \"ERC2612/Expired-time\");\n\n        // @TODO: Gas Testing\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n\n\n        address recovered = ecrecover(digest, v, r, s);\n        require(\n            recovered != address(0) && recovered == owner,\n            \"ERC2612/Invalid-Signature\"\n        );\n\n        _approve(owner, spender, value);\n    }\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID)\n        external\n        view\n        returns (bool);\n}\n\n\ninterface IERC2767 is IERC165 {\n    /// @notice Gets number votes required for achieving consensus\n    /// @dev Should cost less than 30000 gas\n    /// @return Required number of votes for achieving consensus\n    function quorumVotes() external view returns (uint256);\n\n    /// @notice The address of the Governance ERC20 token\n    function token() external view returns (address);\n}\n\n\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return The address of the owner.\n    function owner() external view returns (address);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @param newOwner The address of the new owner of the contract\n    function transferOwnership(address newOwner) external;\n}\n\ncontract Authority is IERC173 {\n    address private _owner;\n\n    modifier onlyAuthority() {\n        require(_owner == msg.sender, \"Authority/Not-Authorized\");\n        _;\n    }\n\n    function owner() external override view returns (address) {\n        return _owner;\n    }\n\n    function initialize(address newOwner) internal {\n        _owner = newOwner;\n        emit OwnershipTransferred(address(0), newOwner);\n    }\n\n    function transferOwnership(address newOwner)\n        external\n        override\n        onlyAuthority\n    {\n        _owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n\n\nlibrary Address {\n    function isContract(address target) internal view returns (bool result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := gt(extcodesize(target), 0)\n        }\n    }\n}\n\n\ncontract AddressChecker {\n    using Address for address;\n\n    function check(address target) external view returns (bool result) {\n        result = target.isContract();\n    }\n}\n\n\ninterface IERC1271 {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\"))\n    // bytes4 internal constant MAGICVALUE = 0x20c13b0b;\n\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n\n    function isValidSignature(bytes calldata _data, bytes calldata _signature) external view returns (bytes4);\n}\n\n\ncontract IdentityMock is IERC1271 {\n    mapping(address => bool) public owners;\n\n    bytes4 internal constant MAGICVALUE = bytes4(\n        keccak256(\"isValidSignature(bytes,bytes)\")\n    );\n    bytes4 internal constant NOT_MAGICVALUE = 0xffffffff;\n\n    constructor() public {\n        owners[msg.sender] = true;\n    }\n\n    function isValidSignature(bytes memory digest, bytes memory signature)\n        external\n        override\n        view\n        returns (bytes4)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n            v := and(mload(add(signature, 65)), 255)\n        }\n        if (v < 27) v += 27;\n\n        // digest bytes to bytes32\n        bytes32 _digest;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _digest := mload(add(digest, 32))\n        }\n        address recovered = ecrecover(_digest, v, r, s);\n\n        if (recovered == address(0) || owners[recovered] == false) {\n            return NOT_MAGICVALUE;\n        }\n        return MAGICVALUE;\n    }\n}\n\n\nlibrary SafeMath {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant RAD = 1e45;\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"Math/Add-Overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"Math/Sub-Overflow\");\n    }\n\n    function sub(\n        uint256 x,\n        uint256 y,\n        string memory message\n    ) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, message);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || ((z = x * y) / y) == x, \"Math/Mul-Overflow\");\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y > 0, \"Math/Div-Overflow\");\n        z = x / y;\n    }\n\n    function mod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y != 0, \"Math/Mod-Overflow\");\n        z = x % y;\n    }\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    function toWAD(uint256 wad, uint256 decimal)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        require(decimal < 18, \"Math/Too-high-decimal\");\n        z = mul(wad, 10**(18 - decimal));\n    }\n}\n\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function balanceOf(address target) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\n\n\ninterface IERC2612 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n\n\n\n\ncontract StandardToken is Authority, AbstractERC2612, IERC165, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    constructor (\n        string memory contractVersion,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 tokenDecimals\n    ) public {\n        Authority.initialize(msg.sender);\n        _initDomainSeparator(contractVersion, tokenName);\n\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        _decimals = tokenDecimals;\n    }\n\n    function name() external override view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external override view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external override view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address spender, uint256 value)\n        external\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function balanceOf(address target)\n        external\n        override\n        view\n        returns (uint256)\n    {\n        return _balances[target];\n    }\n\n    function allowance(address owner, address spender)\n        external\n        override\n        view\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address to, uint256 value)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(\n            value,\n            \"ERC20/Not-Enough-Allowance\"\n        );\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @notice Update allowance with a signed permit\n     * @param owner       Token owner's address (Authorizer)\n     * @param spender     Spender's address\n     * @param value       Amount of allowance\n     * @param deadline    Expiration time, seconds since the epoch\n     * @param v           v of the signature\n     * @param r           r of the signature\n     * @param s           s of the signature\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        _permit(owner, spender, value, deadline, v, r, s);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        override\n        view\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC20).interfaceId || // ERC20\n            interfaceID == type(IERC165).interfaceId || // ERC165\n            interfaceID == type(IERC173).interfaceId || // ERC173\n            interfaceID == type(IERC2612).interfaceId; // ERC2612\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        require(to != address(this), \"ERC20/Not-Allowed-Transfer\");\n        _balances[from] = _balances[from].sub(\n            value,\n            \"ERC20/Not-Enough-Balance\"\n        );\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal override {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n}\n\nlibrary Bytes {\n    function mergeSignature(\n        uint8 r,\n        bytes32 s,\n        bytes32 v\n    ) internal pure returns (bytes memory signature) {\n        signature = new bytes(65);\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(signature, 32), r)\n            mstore(add(signature, 64), s)\n            mstore(add(signature, 65), v)\n        }\n\n        return signature;\n    }\n\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        )\n    {\n        if (sig.length == 65) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // first 32 bytes, after the length prefix.\n                r := mload(add(sig, 32))\n                // second 32 bytes.\n                s := mload(add(sig, 64))\n                // final byte (first byte of the next 32 bytes).\n                v := byte(0, mload(add(sig, 96)))\n            }\n        } else if (sig.length == 64) {\n            bytes32 vs;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // first 32 bytes, after the length prefix.\n                r := mload(add(sig, 32))\n                // second 32 bytes.\n                vs := mload(add(sig, 64))\n            }\n            s = vs & 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n            v = 27 + uint8(uint256(vs) >> 255);\n        }\n\n        return (v, r, s);\n    }\n}\n\n"
    }
  }
}