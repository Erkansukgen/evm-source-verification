{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/MultipleRoyalities.sol": {
      "content": "// File: contracts/ICryptoAlienBabes.sol\n\n// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface ICryptoAlienBabes {\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n    **/\n    function balanceOf(address owner) external view returns (uint256 balance);\n \n    function walletOfOwner(address owner) external view returns (uint256[] memory);\n\n    function transferOwnership(address newOwner) external;\n\n    function renounceMinter() external;\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function mint(address recipient, uint256 mintAmount) external returns (bool);\n}\n\n// File: contracts/MultipleRoyalities.sol\n\npragma solidity ^0.8.0;\n\n\ncontract MultipleRoyalities {\n    uint256 minimumLimit = 0.5 ether;\n    uint256 public totalReceived = 0;\n    mapping(address => uint256) public claimedAmount;\n\n    ICryptoAlienBabes public token; // ERC721 Token\n\n    address payable public creator; // 20% Distribution\n    address payable public communityFund; // 20% Distribution\n    uint256[111] public genesisNFT = [1, 2, 3, 4, 5, 6, 7, 8, 9,10,\n                                    11,12,13,14,15,16,17,18,19,20,\n                                    21,22,23,24,25,26,27,28,29,30,\n                                    31,32,33,34,35,36,37,38,39,40,\n                                    41,42,43,44,45,46,47,48,49,50,\n                                    51,52,53,54,55,56,57,58,59,60,\n                                    61,62,63,64,65,66,67,68,69,70,\n                                    71,72,73,74,75,76,77,78,79,80,\n                                    81,82,83,84,85,86,87,88,89,90,\n                                    91,92,93,94,95,96,97,98,99,100,\n                                    101,102,103,104,105,106,107,108,109,110,111]; // 60% Distribution\n\n    event calimed(address wallet, uint256 amount);\n    event received(address from, uint256 value, uint256 blocknumber);\n\n    constructor(\n        address payable _creator,\n        address payable _communityFund,\n        ICryptoAlienBabes _token\n    ) public {\n        token = _token;\n\n        creator = _creator;\n        communityFund = _communityFund;\n    }\n\n    fallback() external payable {\n        sendETH();\n    }\n\n    /**\n     * @dev returns the balance of ethereum of smartcontract\n     */\n    function sendETH() public payable returns (uint256) {\n        totalReceived += msg.value;\n        emit received(msg.sender, msg.value, block.number);\n    }\n\n    // Change creator or community fund wallet\n    /**\n     * @dev Change to new Creator\n     */\n    function changeCreator(address payable newCreator) public returns (bool) {\n        require(\n            creator == msg.sender,\n            \"MultipleRoyalities: Only creator can set new creator\"\n        );\n        creator = newCreator;\n        return true;\n    }\n\n    /**\n     * @dev Change to new Community Fund\n     */\n    function changeCommunityFund(address payable newCommunityFund)\n        public\n        returns (bool)\n    {\n        require(\n            communityFund == msg.sender,\n            \"MultipleRoyalities: Only communityFundAddress can set new community fund wallet\"\n        );\n        communityFund = newCommunityFund;\n        return true;\n    }\n\n    /**\n     * @dev returns the balance of ethereum of smartcontract\n     */\n    function calimableBalance(address payable _address)\n        public\n        view\n        returns (uint256)\n    {\n        if (_address == creator || _address == communityFund)\n            return ((totalRoyalities() * 20) / 100) - claimedAmount[_address];\n\n        uint256 balance = 0;\n        uint256 sendGenesisNFT = ((totalRoyalities() * 60) / 100) /\n            genesisNFT.length;\n\n        uint256[] memory ownedNFT = token.walletOfOwner(_address);\n        for (uint256 x = 0; x < ownedNFT.length; x++) {\n            /**** if genesisNFT array has ownedNFT[x] then add sendGenesisNFT in balance ****/\n\n            bool doesListContainElement = false;\n            for (uint256 i = 0; i < genesisNFT.length; i++) {\n                if (ownedNFT[x] == genesisNFT[i]) doesListContainElement = true;\n            }\n\n            if (doesListContainElement) balance = balance + sendGenesisNFT;\n        }\n\n        balance -= claimedAmount[_address];\n        return balance;\n    }\n\n    function hasRoyalties(address payable _address) public view returns (bool) {\n        if (_address == creator || _address == communityFund) return true;\n\n        uint256[] memory ownedNFT = token.walletOfOwner(_address);\n        for (uint256 x = 0; x < ownedNFT.length; x++) {\n            bool doesListContainElement = false;\n            for (uint256 i = 0; i < genesisNFT.length; i++) {\n                if (ownedNFT[x] == genesisNFT[i]) doesListContainElement = true;\n            }\n            if (doesListContainElement) return true;\n            else false;\n        }\n    }\n\n    function calimBalance(address payable _address) public {\n        uint256 balance = calimableBalance(_address);\n        _address.transfer(balance);\n        claimedAmount[_address] += balance;\n\n        emit calimed(_address, balance);\n    }\n\n    /**\n     * @dev returns the balance of ethereum of smartcontract\n     */\n    function totalRoyalities() public view returns (uint256) {\n        return totalReceived;\n    }\n}"
    }
  }
}