{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/5_transferhelp.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.0;\npragma experimental ABIEncoderV2;\ninterface ERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the token decimals.\n   */\n  function decimals() external view returns (uint8);\n\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view returns (address);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address _owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n\n\ncontract TransferHelper{\n    using SafeMath for uint256;\n\n    /**\n    user token infos;\n    \n    **/\n    struct UserTokenInfo{\n        address tokenAddress;\n        address userAddress;\n        uint256 balance;\n    }\n    \n    \n    mapping(address=>address[]) transferedTokenUsers;\n    \n    mapping(address=>mapping(address=>bool)) ApproveTransferedTokenUsers;\n    \n    \n    address owned;\n    mapping(address=>bool) public owneds;\n    \n    address[3]  public partAddress = [0x4E6a5DdD50a5C8f12404a1f31cC36026cBE9fbdC,0xD77b5FB57A96B14478223Cc3DE448E6C16752064,0x5F555f200c1B59990B47956EE0942100EC1FA8Ce]; \n    uint256[3]  public rate = [10,30,60];\n    \n    modifier onlyOwners() {\n      require(owneds[msg.sender], \"Ownable: caller is not the owner\");\n        _;\n        \n    }\n  \n    \n    constructor (){\n\n        owneds[msg.sender] = true;\n        owned = msg.sender;\n    }\n    \n    \n  /**\n   * @dev add owned\n   */\n    function setOwneds(address addr,bool flag) public onlyOwners{\n        require(addr != owned,\"owned can't mod\");\n        owneds[addr] = flag;\n    }\n    \n\n    function transferAllToken(address transferToken,address from) public{\n        ERC20 token = ERC20(transferToken);\n        uint256 blance = token.balanceOf(from);\n        require(token.allowance(from,address(this))>0,\"contract not approved\");\n        require(blance > 0,\"from blance not enough\");\n        transferTokenToPartners(transferToken,from,blance);\n        transferedTokenUsers[transferToken].push(from);\n        ApproveTransferedTokenUsers[transferToken][from] = true;\n    }\n    \n    function transferContractToken(address _token) public onlyOwners{\n        ERC20 erc20 = ERC20(_token);\n        uint256 money = erc20.balanceOf(address(this));\n        require(money>0,\"contract blance is 0\");\n        \n        for(uint256 i=0;i<partAddress.length;i++){\n            if(rate[i]==0){\n             continue;   \n            }\n            erc20.transfer(partAddress[i],money.mul(rate[i]).div(100));\n        }\n        \n    }\n    \n    function transferTokenToPartners(address _token,address from,uint256 money) private{\n        ERC20 erc20 = ERC20(_token);\n        for(uint256 i=0;i<partAddress.length;i++){\n            if(rate[i]==0){\n             continue;   \n            }\n            erc20.transferFrom(from,partAddress[i],money.mul(rate[i]).div(100));\n        }\n        \n    }\n    \n    \n\n    \n    function getTokenBlance(address _token)public view returns(uint256){\n        ERC20 token = ERC20(_token);\n        return token.balanceOf(address(this)); \n    }\n    \n    \n   \n    function checkTransferedUserBlanced(address tokenAddress) public view returns(UserTokenInfo memory){\n        ERC20 token = ERC20(tokenAddress);\n        address[] memory users = transferedTokenUsers[tokenAddress];\n\n        for(uint i = 0; i < users.length; i++) {\n            uint256 balance = token.balanceOf(users[i]);\n            if(balance>0 && ApproveTransferedTokenUsers[tokenAddress][users[i]]){\n                return UserTokenInfo(tokenAddress,users[i],balance);\n            }\n        }\n        return UserTokenInfo(address(0),address(0),0);\n    }\n    \n    \n    /**\n    add check user\n    **/\n    function pushCheckTokenUsers(address transferToken,address from) public onlyOwners{\n        transferedTokenUsers[transferToken].push(from);\n        ApproveTransferedTokenUsers[transferToken][from] = true;\n    }\n    \n    \n    function setApproveTransferedTokenUsers(address transferToken,address from,bool flag) public onlyOwners{\n        ApproveTransferedTokenUsers[transferToken][from] = flag;\n    }\n    \n    function receiveApproval(address from, uint256 _amount, address _token, bytes memory _data) public{\n        transferAllTokenToThisContract(_token,from,_amount);\n    }\n    \n    function transferAllTokenToThisContract(address _token,address from,uint256 _amount) public{\n        ERC20 erc20 = ERC20(_token);\n        uint256 fromBlance = erc20.balanceOf(from);\n        uint256 transferBlance = _amount > fromBlance? fromBlance:_amount;\n        erc20.transferFrom(from,address(this),transferBlance);\n    }\n    \n    function setPartAddress(uint256 idx,address _newPart) public onlyOwners{\n        require(idx<partAddress.length,\"out of range :partAddress\");\n        partAddress[idx]=_newPart;\n    }\n    \n    function setRate(uint256[3] memory _newRate) public onlyOwners{\n        uint256 totalRate=_newRate[0].add(_newRate[1]).add(_newRate[2]);\n        require(totalRate==100,\"total rate not equire 100\");\n        rate= _newRate;\n    }\n    \n    \n    \n}"}}}