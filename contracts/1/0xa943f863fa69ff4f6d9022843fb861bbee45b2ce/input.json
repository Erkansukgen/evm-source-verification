{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":10},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"TangleBundle0.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface ERC20 {\r\n    function transfer(address _to, uint value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint value)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n/// @notice Info Storage for Tangle\r\n/// @dev This is a Diamond Storage implementation described in EIP-2535.\r\nlibrary SLib {\r\n\r\n    struct S {\r\n        bool minted;\r\n        uint8 decimals;\r\n        address liquidityAddress;\r\n        uint wc;\r\n        uint last;\r\n        uint totalSupply;\r\n        uint piecesPerUnit;\r\n        uint minHoldAmount;\r\n        uint cropDustAmount;\r\n        string name;\r\n        string symbol;\r\n        address[] addresses;\r\n        address[] blacklist;\r\n        string[] names;\r\n        Reflect_[] reflects;\r\n        mapping(address => uint) balances;\r\n        mapping(address => uint) addressIndex;\r\n        mapping(address => uint) reflectIndex;\r\n        mapping(address => uint) blacklistIndex;\r\n        mapping(address => Split) splits;\r\n        mapping(string => uint) nameIndex;\r\n        mapping(string => string) ids;\r\n        mapping(string => Farm) farms;\r\n        mapping(address => mapping(address => uint)) allowances;\r\n        mapping(address => mapping(string => uint)) points;\r\n        mapping(address => mapping(string => uint)) rewards;\r\n        mapping(address => mapping(string => uint)) wcInits;\r\n        mapping(address => mapping(string => uint)) propSumInits;\r\n    }\r\n    function getS() internal pure returns (S storage sInfo) {\r\n        bytes32 storagePosition = keccak256(bytes(\"0\"));\r\n        assembly { sInfo.slot := storagePosition }\r\n    }\r\n    struct MappingIDCut_ {\r\n        uint8 action;\r\n        string name;\r\n        string id;\r\n    }\r\n    struct Split {\r\n        uint16 numerator;\r\n        uint16 denominator;\r\n        address to;\r\n    }\r\n    struct SplitCut_ {\r\n        uint8 action;\r\n        Split split;\r\n    }\r\n    struct Reflect_ {\r\n        address address_;\r\n        bool flag;\r\n    }\r\n    struct ReflectCut_ {\r\n        uint8 action;\r\n        Reflect_ reflect_;\r\n    }\r\n    struct Farm {\r\n        uint C;\r\n        uint N;\r\n        uint D;\r\n        uint max;\r\n        uint last;\r\n        uint start;\r\n        uint elapsed;\r\n        uint propSum;\r\n        uint points;\r\n        string name;\r\n    }\r\n    struct FarmCut_ {\r\n        uint8 action;\r\n        Farm farm;\r\n    }\r\n    struct BlacklistCut_ {\r\n        uint8 action;\r\n        address address_;\r\n    }\r\n    /// @notice Records all transfers\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    /// @notice Records all allowancesId changes\r\n    event AllowancesIdChange(string allowancesId);\r\n    /// @notice Records all approvals\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n    /// @notice Records all minHoldAmount changes\r\n    event MinHoldAmountChange(uint minHoldAmount);\r\n    /// @notice Records all split changes\r\n    event SplitCut(SplitCut_[] splitCuts);\r\n    /// @notice Records all reflections\r\n    event Reflect(address from_, uint amount);\r\n    /// @notice Records all reflection changes\r\n    event ReflectCut(ReflectCut_[] reflectCut);\r\n    /// @notice Records all farm changes\r\n    event FarmCut(FarmCut_[] farmCuts);\r\n    /// @notice Records all airdropping point changes\r\n    event AirdroppingPointChange(address from_, uint amount);\r\n    /// @notice Records all blacklist changes\r\n    event BlacklistCut(BlacklistCut_[] blacklistCuts);\r\n    /// @notice Records all staking changes\r\n    event UpdateStake(address staker, uint position);\r\n\r\n}\r\n\r\n/// @title TangleBundle1_0, the 1_0 bundle of features for Tangle \r\n/// @author Brad Brown\r\n/// @notice This bundle provides ERC20, flexible tax,\r\n/// flexible and smart reflection, flexible yield farm\r\n/// (including staking and airdropping), and more controls and views for Tangle.\r\ncontract TangleBundle1_0 {\r\n\r\n    mapping(bytes4 => address) private _0;\r\n    address private owner;\r\n\r\n    /// @notice Transfers Tangle from one holder to another, may implement a\r\n    /// variable number of taxes and may modify the amount transferred\r\n    /// @dev Modifies the value transferred according to the pre and tax\r\n    /// Transformers (external implementations)\r\n    /// @param _to The address Tangle will be sent to\r\n    /// @param value The amount of Tangle sent\r\n    /// @return Whether or not the transfer was successful\r\n    function transfer(address _to, uint value) external returns (bool) {\r\n        value = preTransform(msg.sender, value);\r\n        _transfer(msg.sender, _to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers Tangle from one holder to another, may implement a\r\n    /// variable number of taxes and may modify the amount transferred. Can be\r\n    /// initiated by an approved 3rd party\r\n    /// @dev Modifies the value transferred according to the pre and tax\r\n    /// Transformers, which are implementation.\r\n    /// @param _from The address Tangle will be sent from\r\n    /// @param _to The address Tangle will be sent to\r\n    /// @param value The amount of Tangle sent\r\n    /// @return Whether or not the transfer was successful\r\n    function transferFrom(address _from, address _to, uint value)\r\n        external\r\n        returns\r\n    (bool) {\r\n        value = preTransform(_from, value);\r\n        SLib.S storage s = SLib.getS();\r\n        s.allowances[_from][msg.sender] -= value;\r\n        _transfer(_from, _to, value);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address spender, address receiver, uint value)\r\n        internal\r\n    {\r\n        SLib.S storage s = SLib.getS();\r\n        s.balances[spender] -= unitsToPieces(value);\r\n        value = _tax(spender, value);\r\n        if (\r\n            s.balances[receiver] == 0 &&\r\n            value > 0 &&\r\n            !_isReflected(receiver)\r\n        )\r\n            _addAirdroppingPoints(spender, 1);\r\n        s.balances[receiver] += unitsToPieces(value);\r\n        emit SLib.Transfer(spender, receiver, value);\r\n        _reflect();\r\n    }\r\n\r\n    /// @notice Taxes a Tangle transfer, routes taxes and\r\n    /// reduces transfer value by each tax amount routed\r\n    /// @param value The value of Tangle being transferred\r\n    /// @return The post-tax transfer value\r\n    function _tax(address from, uint value)\r\n        internal\r\n        returns (uint)\r\n    {\r\n        uint preTaxValue = value;\r\n        if (value == 0) return value;\r\n        SLib.S storage s = SLib.getS();\r\n        for (uint i = 0; i < s.addresses.length; i++) {\r\n            SLib.Split memory split = s.splits[s.addresses[i]];\r\n            uint numerator = split.numerator;\r\n            uint denominator = split.denominator;\r\n            uint splitAmount = preTaxValue * numerator / denominator;\r\n            s.balances[split.to] += unitsToPieces(splitAmount);\r\n            value -= splitAmount;\r\n            emit SLib.Transfer(from, split.to, splitAmount);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    /// @notice Reflects all tokens from each address in the reflects list\r\n    /// to everyone except the addresses in the noReflects list\r\n    function _reflect() internal {\r\n        SLib.S storage s = SLib.getS();\r\n        if (s.reflects.length == 0) return;\r\n        uint totalNoReflectBalance;\r\n        uint totalReflectBalance;\r\n        for (uint i = 0; i < s.reflects.length; i++) {\r\n            SLib.Reflect_ memory reflect_ = s.reflects[i];\r\n            if (!reflect_.flag)\r\n                totalNoReflectBalance += s.balances[reflect_.address_];\r\n            if (reflect_.flag) {\r\n                uint reflectAmount = s.balances[reflect_.address_];\r\n                totalReflectBalance += reflectAmount;\r\n                s.balances[reflect_.address_] = 0;\r\n                emit SLib.Reflect(reflect_.address_, reflectAmount / s.piecesPerUnit);\r\n            }\r\n        }\r\n        if (totalReflectBalance == 0) return;\r\n        uint totalSupply_ = s.totalSupply;\r\n        uint TIP = totalSupply_ * s.piecesPerUnit - totalNoReflectBalance; // TIP: total included pieces\r\n        uint TUP = TIP - totalReflectBalance; // TUP: total unaffected pieces\r\n        uint newPiecesPerUnit = s.piecesPerUnit * TUP / TIP;\r\n        s.piecesPerUnit = newPiecesPerUnit;\r\n        if (s.piecesPerUnit < 1)\r\n            s.piecesPerUnit = 1;\r\n        for (uint i = 0; i < s.reflects.length; i++) {\r\n            if (!s.reflects[i].flag) {\r\n                uint nrBalance = s.balances[s.reflects[i].address_];\r\n                s.balances[s.reflects[i].address_] = nrBalance * TUP / TIP;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addReflect(SLib.Reflect_ memory reflect_) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        require(!reflectExists(reflect_.address_));\r\n        s.reflectIndex[reflect_.address_] = s.reflects.length;\r\n        s.reflects.push(reflect_);\r\n    }\r\n\r\n    function removeReflect(SLib.Reflect_ memory reflect_) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        require(reflectExists(reflect_.address_));\r\n        SLib.Reflect_ memory lastReflect = s.reflects[s.reflects.length - 1];\r\n        address address_ = reflect_.address_;\r\n        address lastReflectAddress = lastReflect.address_;\r\n        if (lastReflectAddress != address_) {\r\n            s.reflectIndex[lastReflectAddress] = s.reflectIndex[address_];\r\n            s.reflects[s.reflectIndex[address_]] = lastReflect;\r\n        }\r\n        s.reflects.pop();\r\n        s.reflectIndex[address_] = 0;\r\n    }\r\n\r\n    function replaceReflect(SLib.Reflect_ memory reflect_) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        bool currentFlag = s.reflects[s.reflectIndex[reflect_.address_]].flag;\r\n        require(\r\n            reflectExists(reflect_.address_) &&\r\n            (currentFlag != reflect_.flag)\r\n        );\r\n        s.reflects[s.reflectIndex[reflect_.address_]] = reflect_;\r\n    }\r\n\r\n    function reflectExists(address address_) internal view returns (bool) {\r\n        SLib.S storage s = SLib.getS();\r\n        if (s.reflects.length == 0)\r\n            return false;\r\n        if (s.reflectIndex[address_] > 0 || s.reflects[0].address_ == address_)\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    function _isReflected(address address_) internal view returns (bool) {\r\n        if (\r\n            reflectExists(address_) && \r\n            SLib.getS().reflects[SLib.getS().reflectIndex[address_]].flag\r\n        )  return true;\r\n        return false;\r\n    }\r\n\r\n    /// @notice Add/remove any number of addresses whose funds get reflected\r\n    /// @param reflectCuts ReflectCut[]\r\n    function reflectCut(\r\n        SLib.ReflectCut_[] calldata reflectCuts\r\n    ) external {\r\n        require(msg.sender == owner);\r\n        bool changesMade = false;\r\n        for (uint i = 0; i < reflectCuts.length; i++) {\r\n            SLib.ReflectCut_ memory reflectCut_ = reflectCuts[i];\r\n            if (reflectCut_.action == 0) {\r\n                addReflect(reflectCut_.reflect_);\r\n                if (!changesMade) changesMade = true;\r\n            }\r\n            if (reflectCut_.action == 1) {\r\n                replaceReflect(reflectCut_.reflect_);\r\n                if (!changesMade) changesMade = true;\r\n            }\r\n            if (reflectCut_.action == 2) {\r\n                removeReflect(reflectCut_.reflect_);\r\n                if (!changesMade) changesMade = true;\r\n            }\r\n        }\r\n        if (changesMade) emit SLib.ReflectCut(reflectCuts);\r\n    }\r\n\r\n    /// @notice Transforms a Tangle transfer value, ensures that a transfer\r\n    /// cannot leave a holder's balance below the minHoldAmount\r\n    /// @param spender The address the Tangle is being transferred from\r\n    /// @param value The amount of Tangle being transferred\r\n    /// @return The transformed transfer value\r\n    function preTransform(address spender, uint value)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        SLib.S storage s = SLib.getS();\r\n        uint balance = piecesToUnits(s.balances[spender]);\r\n        require(value <= balance);\r\n        uint minHoldAmount_ = s.minHoldAmount;\r\n        if (balance - value < minHoldAmount_)\r\n            value = balance - minHoldAmount_;\r\n        return value;\r\n    }\r\n\r\n    /// @notice Changes the minHoldAmount, emits an event recording the change\r\n    /// @param minHoldAmount_ The new minHoldAmount\r\n    function changeMinHoldAmount(uint minHoldAmount_) external {\r\n        require(msg.sender == owner);\r\n        SLib.getS().minHoldAmount = minHoldAmount_;\r\n        emit SLib.MinHoldAmountChange(minHoldAmount_);\r\n    }\r\n\r\n    function piecesToUnits(uint pieces) internal view returns (uint) {\r\n        return pieces / SLib.getS().piecesPerUnit;\r\n    }\r\n\r\n    function unitsToPieces(uint units) internal view returns (uint) {\r\n        return units * SLib.getS().piecesPerUnit;\r\n    }\r\n\r\n    /// @notice Returns the balance of a Tangle token holder\r\n    /// @param _owner The Tangle token holder's address\r\n    /// @return The balance of a holder\r\n    function balanceOf(address _owner) external view returns (uint) {\r\n        return piecesToUnits(SLib.getS().balances[_owner]);\r\n    }\r\n\r\n    /// @notice Approves a spender to spend an amount of Tangle\r\n    /// @param _spender The address of the spender\r\n    /// @param _value The amount that the spender can spend\r\n    /// @return Whether or not the approval was successful\r\n    function approve(address _spender, uint _value) external returns (bool) {\r\n        SLib.S storage s = SLib.getS();\r\n        s.allowances[msg.sender][_spender] = _value;\r\n        emit SLib.Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Returns the name of the Tangle token\r\n    /// @return The name of the Tangle token (ex. \"Tangle\")\r\n    function name() external view returns (string memory) {\r\n        return SLib.getS().name;\r\n    }\r\n\r\n    /// @notice Returns the symbol of the Tangle token\r\n    /// @return The symbol of the Tangle token (ex. \"TNGL\")\r\n    function symbol() external view returns (string memory) {\r\n        return SLib.getS().symbol;\r\n    }\r\n\r\n    /// @notice Returns the decimals of the Tangle token\r\n    /// @return The decimals of the Tangle token (ex. 9)\r\n    function decimals() external view returns (uint8) {\r\n        return SLib.getS().decimals;\r\n    }\r\n\r\n    /// @notice Returns the total supply of the Tangle token\r\n    /// @return The total supply of the Tangle token\r\n    /// (ex. 1,000,000,000.000000000)\r\n    function totalSupply() external view returns (uint) {\r\n        return SLib.getS().totalSupply;\r\n    }\r\n\r\n    /// @notice Returns the amount of a Tangle holder's Tangle a spender is\r\n    /// allowed to spend\r\n    /// @param _owner The Tangle token holder's address\r\n    /// @param _spender The spender's address\r\n    /// @return The amount that can be spent\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns\r\n        (uint)\r\n    {\r\n        return SLib.getS().allowances[_owner][_spender];\r\n    }\r\n\r\n    function addSplit(SLib.Split memory split) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        require(!splitExists(split.to));\r\n        s.addressIndex[split.to] = s.addresses.length;\r\n        s.addresses.push(split.to);\r\n        s.splits[split.to] = split;\r\n   }\r\n\r\n   function removeSplit(SLib.Split memory split) internal {\r\n       SLib.S storage s = SLib.getS();\r\n       require(splitExists(split.to));\r\n       address lastAddress = s.addresses[s.addresses.length - 1];\r\n       if (lastAddress != split.to) {\r\n           s.addressIndex[lastAddress] = s.addressIndex[split.to];\r\n           s.addresses[s.addressIndex[split.to]] = lastAddress;\r\n       }\r\n       s.addresses.pop();\r\n       s.addressIndex[split.to] = 0;\r\n       s.splits[split.to] = SLib.Split(0,0,address(0));\r\n   }\r\n\r\n   function replaceSplit(SLib.Split memory split) internal {\r\n       SLib.S storage s = SLib.getS();\r\n       SLib.Split memory currentSplit = s.splits[split.to];\r\n       bool numsEqual = split.numerator == currentSplit.numerator;\r\n       bool denomsEqual = split.denominator == currentSplit.denominator;\r\n       require(\r\n           splitExists(split.to) &&\r\n           (!numsEqual || !denomsEqual),\r\n           \"split replace\"\r\n       );\r\n       s.splits[split.to] = split;\r\n   }\r\n\r\n   function splitExists(address  address_) internal view returns (bool) {\r\n       SLib.S storage s = SLib.getS();\r\n       if (s.addresses.length == 0)\r\n           return false;\r\n       if (\r\n           s.addressIndex[address_] > 0 ||\r\n           s.addresses[0] == address_\r\n       )\r\n           return true;\r\n       return false;\r\n   }\r\n\r\n   /// @notice Add/change/remove any number of splits\r\n   /// @param splitCuts Contains the splits and which add/change/remove\r\n   /// action will be used\r\n   function splitCut(SLib.SplitCut_[] calldata splitCuts) external {\r\n       require(msg.sender == owner);\r\n       bool changesMade = false;\r\n       for (uint i = 0; i < splitCuts.length; i++) {\r\n           SLib.SplitCut_ memory splitCut_ = splitCuts[i];\r\n           SLib.Split memory split = splitCut_.split;\r\n           if (splitCut_.action == 0) {\r\n               addSplit(split);\r\n               if (!changesMade) changesMade = true;\r\n           }\r\n           if (splitCut_.action == 1) {\r\n               replaceSplit(split);\r\n               if (!changesMade) changesMade = true;\r\n           }\r\n           if (splitCut_.action == 2) {\r\n               removeSplit(split);\r\n               if (!changesMade) changesMade = true;\r\n           }\r\n       }\r\n       if (changesMade) emit SLib.SplitCut(splitCuts);\r\n   }\r\n\r\n   function _availableRewards(\r\n        address address_,\r\n        string memory name_\r\n    ) internal view returns (uint) {\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Farm memory farm = s.farms[name_];\r\n        if (farm.D == 0) return 0;\r\n        farm.max += (s.balances[address(this)] - s.last) * farm.N / farm.D;\r\n        uint _wc = s.wc;\r\n        uint _propSum = farm.propSum;\r\n        uint d = block.timestamp - farm.start + farm.C - farm.elapsed;\r\n        if (d == 0) return 0;\r\n        uint add = farm.max - (farm.max - farm.last) * farm.C / d - farm.last;\r\n        if (farm.points != 0) {\r\n            while (add > 0 && add * _wc / farm.points < 1e9) {\r\n                _wc *= 2;\r\n                _propSum *= 2;\r\n            }\r\n            _propSum += add * _wc / farm.points;\r\n        }\r\n        if (s.wcInits[address_][name_] == 0 || _wc == 0) return 0;\r\n        uint available = s.rewards[address_][name_] + s.points[address_][name_] * (_propSum - s.propSumInits[address_][name_] * _wc / s.wcInits[address_][name_]) / _wc;\r\n        return available;\r\n    }\r\n\r\n    function _distribute(\r\n        string memory name_\r\n    ) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Farm storage farm = s.farms[name_];\r\n        if (s.balances[address(this)] != s.last) {\r\n            for (uint i = 0; i < s.names.length; i++) {\r\n                SLib.Farm storage farm_ = s.farms[s.names[i]];\r\n                if (farm_.D == 0) continue;\r\n                farm_.max += (s.balances[address(this)] - s.last) * farm_.N / farm_.D;\r\n            }\r\n            s.last = s.balances[address(this)];\r\n        }\r\n        uint d = block.timestamp - farm.start + farm.C - farm.elapsed;\r\n        if (d == 0) return;\r\n        uint rewardTheoretical = farm.max - (farm.max - farm.last) * farm.C / d;\r\n        uint add = rewardTheoretical - farm.last;\r\n        if (farm.points != 0) {\r\n            while (add > 0 && add * s.wc / farm.points < 1e9) {\r\n                s.wc *= 2;\r\n                for (uint i = 0; i < s.names.length; i++)\r\n                    s.farms[s.names[i]].propSum *= 2;\r\n            }\r\n            farm.propSum += add * s.wc / farm.points;\r\n        }\r\n        farm.last = rewardTheoretical;\r\n        farm.elapsed = block.timestamp - farm.start;\r\n    }\r\n\r\n    /// @notice Gets all available rewards from all farms\r\n    /// @param address_ The address whose rewards info will be returned\r\n    /// @return Each individual farm's rewards and the combined total rewards\r\n    function availableRewards(\r\n        address address_\r\n    ) external view returns (string[] memory, uint[] memory) {\r\n        SLib.S storage s = SLib.getS();\r\n        uint[] memory rewards = new uint[](s.names.length + 1);\r\n        uint totalRewards = 0;\r\n        for (uint i = 0; i < s.names.length; i++) {\r\n            rewards[i] = piecesToUnits(_availableRewards(address_, s.names[i]));\r\n            totalRewards += rewards[i];\r\n        }\r\n        rewards[s.names.length] = totalRewards;\r\n        return (s.names, rewards);\r\n    }\r\n\r\n    function _withdrawRewards(\r\n        address _address,\r\n        string memory name_\r\n    ) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Farm storage farm = s.farms[name_];\r\n        if (farm.points == 0) return; // prevent undefined behavior when calling _withdrawRewards on a farm with 0 points\r\n        _distribute(name_);\r\n        if (s.wcInits[_address][name_] == 0 || s.wc == 0) return;\r\n        uint available = s.rewards[_address][name_] + s.points[_address][name_] * (farm.propSum - s.propSumInits[_address][name_] * s.wc / s.wcInits[_address][name_]) / s.wc;\r\n        s.rewards[_address][farm.name] = 0;\r\n        s.propSumInits[_address][farm.name] = farm.propSum;\r\n        s.wcInits[_address][farm.name] = s.wc;\r\n        s.last -= available;\r\n        _transfer(address(this), _address, piecesToUnits(available));\r\n    }\r\n\r\n    /// @notice Withdraw rewards from all yield farms for an address\r\n    /// @param _address The address whose rewards will be withdrawn\r\n    function withdrawRewards(address _address) external {\r\n        SLib.S storage s = SLib.getS();\r\n        for (uint i = 0; i < s.names.length; i++) {\r\n            _withdrawRewards(_address, s.names[i]);\r\n        }\r\n    }\r\n\r\n    function addFarm(SLib.Farm memory farm) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        require(!farmExists(farm.name));\r\n        s.nameIndex[farm.name] = s.names.length;\r\n        s.names.push(farm.name);\r\n        s.farms[farm.name] = farm;\r\n    }\r\n\r\n    function removeFarm(SLib.Farm memory farm) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        require(farmExists(farm.name));\r\n        string memory lastName = s.names[s.names.length - 1];\r\n        bytes32 lastNameBytes = keccak256(bytes(lastName));\r\n        bytes32 nameBytes = keccak256(bytes(farm.name));\r\n        if (lastNameBytes != nameBytes) {\r\n            s.nameIndex[lastName] = s.nameIndex[farm.name];\r\n            s.names[s.nameIndex[farm.name]] = lastName;\r\n        }\r\n        s.names.pop();\r\n        s.nameIndex[farm.name] = 0;\r\n        SLib.Farm memory blankFarm;\r\n        s.farms[farm.name] = blankFarm;\r\n    }\r\n\r\n    function replaceFarm(SLib.Farm memory farm) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Farm memory currentFarm = s.farms[farm.name];\r\n        require(\r\n            farmExists(farm.name) &&\r\n            (farm.C != currentFarm.C ||\r\n            farm.N != currentFarm.N ||\r\n            farm.D != currentFarm.D)\r\n        );\r\n        s.farms[farm.name].C = farm.C;\r\n    }\r\n\r\n    function farmExists(\r\n        string memory name_\r\n    ) internal view returns (bool) {\r\n        SLib.S storage s = SLib.getS();\r\n        if (s.names.length == 0)\r\n            return false;\r\n        if (\r\n            s.nameIndex[name_] > 0 ||\r\n            keccak256(bytes(s.names[0])) == keccak256(bytes(name_))\r\n        )\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /// @notice Add/change/remove any number of farms\r\n    /// @param farmCuts Contains the farms and which add/change/remove\r\n    /// action will be used\r\n    function farmCut(SLib.FarmCut_[] calldata farmCuts) external {\r\n        require(msg.sender == owner);\r\n        SLib.S storage s = SLib.getS();\r\n        if (s.wc == 0) s.wc = 1;\r\n        bool changesMade = false;\r\n        for (uint i = 0; i < farmCuts.length; i++) {\r\n            SLib.FarmCut_ memory farmCut_ = farmCuts[i];\r\n            SLib.Farm memory farm = farmCut_.farm;\r\n            if (farmCut_.action == 0) {\r\n                addFarm(farm);\r\n                if (!changesMade) changesMade = true;\r\n            }\r\n            if (farmCut_.action == 1) {\r\n                replaceFarm(farm);\r\n                if (!changesMade) changesMade = true;\r\n            }\r\n            if (farmCut_.action == 2) {\r\n                removeFarm(farm);\r\n                if (!changesMade) changesMade = true;\r\n            }\r\n        }\r\n        if (changesMade) emit SLib.FarmCut(farmCuts);\r\n    }\r\n\r\n    /// @notice Gets all farms and their details\r\n    /// @return All farms and their details\r\n    function farms() external view returns (uint, uint, SLib.Farm[] memory) {\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Farm[] memory farms_ = new SLib.Farm[](s.names.length);\r\n        for (uint i = 0; i < s.names.length; i++) {\r\n            farms_[i] = s.farms[s.names[i]];\r\n            farms_[i].max = piecesToUnits(farms_[i].max);\r\n            farms_[i].last = piecesToUnits(farms_[i].last);\r\n            farms_[i].propSum = farms_[i].propSum;\r\n        }\r\n        return (SLib.getS().piecesPerUnit, s.wc, farms_);\r\n    }\r\n\r\n    /// @notice Transfers a constant amount of Tangle set by owner to each address\r\n    /// in a list of addresses\r\n    /// @param addresses A list of addresses\r\n    function cropDust(address[] memory addresses) external {\r\n        SLib.S storage s = SLib.getS();\r\n        uint viableAddresses = addresses.length;\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            if (s.balances[addresses[i]] > 0 && !_isReflected(addresses[i])) {\r\n                viableAddresses--;\r\n                continue;\r\n            }\r\n            s.balances[addresses[i]] += unitsToPieces(s.cropDustAmount);\r\n            emit SLib.Transfer(msg.sender, addresses[i], s.cropDustAmount);\r\n        }\r\n        s.balances[msg.sender] -= unitsToPieces(s.cropDustAmount) * viableAddresses;\r\n        _addAirdroppingPoints(msg.sender, viableAddresses);\r\n    }\r\n\r\n    function _addAirdroppingPoints(address address_, uint amount) internal {\r\n        if (addressExists(address_)) return;\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Farm storage farm = s.farms[\"airdropping\"];\r\n        if (farm.start == 0) farm.start = block.timestamp;\r\n        if (farm.points > 0)\r\n            _distribute(\"airdropping\");\r\n        uint rewards = _availableRewards(address_, \"airdropping\");\r\n        if (rewards > 0)\r\n            s.rewards[address_][\"airdropping\"] = rewards;\r\n        s.propSumInits[address_][\"airdropping\"] = farm.propSum;\r\n        s.wcInits[address_][\"airdropping\"] = s.wc;\r\n        s.points[address_][\"airdropping\"] += amount;\r\n        farm.points += amount;\r\n        emit SLib.AirdroppingPointChange(address_, s.points[address_][\"airdropping\"]);\r\n    }\r\n\r\n    function addAddress(address address_) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        require(!addressExists(address_));\r\n        s.blacklistIndex[address_] = s.blacklist.length;\r\n        s.blacklist.push(address_);\r\n    }\r\n\r\n    function removeAddress(address address_) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        require(addressExists(address_));\r\n        address lastAddress = s.blacklist[s.blacklist.length - 1];\r\n        if (lastAddress != address_) {\r\n            s.blacklistIndex[lastAddress] = s.blacklistIndex[address_];\r\n            s.blacklist[s.blacklistIndex[address_]] = lastAddress;\r\n        }\r\n        s.blacklist.pop();\r\n        s.blacklistIndex[address_] = 0;\r\n    }\r\n\r\n    function addressExists(address address_) internal view returns (bool) {\r\n        SLib.S storage s = SLib.getS();\r\n        if (s.blacklist.length == 0)\r\n            return false;\r\n        if (s.blacklistIndex[address_] > 0 || s.blacklist[0] == address_)\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /// @notice Add/remove any number of addresses who are blacklisted\r\n    /// from receiving airdropping rewards\r\n    /// @param blacklistCuts BlacklistCut_[]\r\n    function blacklistCut(\r\n        SLib.BlacklistCut_[] calldata blacklistCuts\r\n    ) external {\r\n        require(msg.sender == owner);\r\n        bool changesMade = false;\r\n        for (uint i = 0; i < blacklistCuts.length; i++) {\r\n            SLib.BlacklistCut_ memory blacklistCut_ = blacklistCuts[i];\r\n            if (blacklistCut_.action == 0) {\r\n                addAddress(blacklistCut_.address_);\r\n                if (!changesMade) changesMade = true;\r\n            }\r\n            if (blacklistCut_.action == 1) {\r\n                removeAddress(blacklistCut_.address_);\r\n                if (!changesMade) changesMade = true;\r\n            }\r\n        }\r\n        if (changesMade) emit SLib.BlacklistCut(blacklistCuts);\r\n    }\r\n\r\n    function changeCropDustAmount(uint newCropDustAmount) external {\r\n        require(msg.sender == owner);\r\n        SLib.getS().cropDustAmount = newCropDustAmount;\r\n    }\r\n\r\n    /// @notice Updates a staking position\r\n    /// @param amount The new amount of the staking position\r\n    function updateStake(uint amount) external {\r\n        SLib.S storage s = SLib.getS();\r\n        uint currentAmount = s.points[msg.sender][\"staking\"];\r\n        require(amount != currentAmount);\r\n        if (currentAmount == 0) _stake(amount);\r\n        if (amount == 0) _unstake();\r\n        if (currentAmount != 0 && amount != 0) {\r\n            _unstake();\r\n            _stake(amount);\r\n        }\r\n        emit SLib.UpdateStake(msg.sender, amount);\r\n    }\r\n\r\n    function _stake(uint amount) internal {\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Farm storage farm = s.farms[\"staking\"];\r\n        ERC20(s.liquidityAddress).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n        if (farm.start == 0) farm.start = block.timestamp;\r\n        if (farm.points > 0)\r\n            _distribute(\"staking\");\r\n        s.propSumInits[msg.sender][\"staking\"] = farm.propSum;\r\n        s.wcInits[msg.sender][\"staking\"] = s.wc;\r\n        s.points[msg.sender][\"staking\"] = amount;\r\n        farm.points += amount;\r\n    }\r\n\r\n    function _unstake() internal {\r\n        _distribute(\"staking\");\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Farm storage farm = s.farms[\"staking\"];\r\n        uint currentAmount = s.points[msg.sender][\"staking\"];\r\n        uint rewards = _availableRewards(msg.sender, \"staking\");\r\n        if (rewards > 0)\r\n            s.rewards[msg.sender][\"staking\"] = rewards;\r\n        ERC20(s.liquidityAddress).transfer(\r\n            msg.sender,\r\n            currentAmount\r\n        );\r\n        farm.points -= currentAmount;\r\n        s.points[msg.sender][\"staking\"] = 0;\r\n    }\r\n\r\n    ///@notice Changes the liquidity address used by the Staking contract. Owner-only.\r\n    ///@param newLiquidityAddress The new liquidity address\r\n    function changeLiquidityAddress(address newLiquidityAddress) external {\r\n        require(msg.sender == owner);\r\n        SLib.getS().liquidityAddress = newLiquidityAddress;\r\n    }\r\n\r\n    function bundleInit() external {\r\n        require(msg.sender == owner);\r\n        SLib.S storage s = SLib.getS();\r\n        require(!s.minted);\r\n        s.name = \"Tangle\";\r\n        s.symbol = \"TNGL\";\r\n        s.decimals = 9;\r\n        s.totalSupply = 10 ** 18;\r\n        s.piecesPerUnit = (type(uint128).max - (type(uint128).max % 10 ** 18)) / 10 ** 18;\r\n        s.minted = true;\r\n        uint totalSupply_ = SLib.getS().totalSupply;\r\n        s.balances[msg.sender] = unitsToPieces(totalSupply_);\r\n        emit SLib.Transfer(address(0), msg.sender, totalSupply_);\r\n    }\r\n    \r\n    ///@notice Gets the current liquidity address used by the Staking contract.\r\n    ///@return The current liquidity address\r\n    function liquidityAddress() external view returns (address) {\r\n        return SLib.getS().liquidityAddress;\r\n    }\r\n    \r\n    ///@notice Gets the current amount sent to each address during a crop dusting\r\n    ///@return The current cropDustAmount\r\n    function cropDustAmount() external view returns (uint) {\r\n        return SLib.getS().cropDustAmount;\r\n    }\r\n    \r\n    /// @notice Gets all addresses are blacklisted\r\n    /// from receiving airdropping rewards\r\n    /// @return blacklist_ All addresses that are blacklisted\r\n    /// from receiving airdropping rewards\r\n    function blacklist()\r\n        external\r\n        view\r\n        returns (address[] memory blacklist_)\r\n    {\r\n        return SLib.getS().blacklist;\r\n    }\r\n    \r\n    /// @notice Gets farm point information for a specific address and farm\r\n    /// @param address_ An address\r\n    /// @param name_ A farm name\r\n    /// @return An amount of points\r\n    function points(address address_, string memory name_) external view returns (uint) {\r\n        return SLib.getS().points[address_][name_];\r\n    }\r\n    \r\n    /// @notice Gets all splits and their address, numerator, and denominator\r\n    /// @return All splits and their address, numerator, and denominator\r\n    function splits() external view returns (SLib.Split[] memory) {\r\n        SLib.S storage s = SLib.getS();\r\n        SLib.Split[] memory splits_ = new SLib.Split[](s.addresses.length);\r\n        for (uint i = 0; i < s.addresses.length; i++) {\r\n           splits_[i] = s.splits[s.addresses[i]];\r\n        }\r\n        return splits_;\r\n    }\r\n\r\n    /// @notice Gets the current minHoldAmount\r\n    /// @return The current minHoldAmount\r\n    function minHoldAmount() external view returns (uint) {\r\n        return SLib.getS().minHoldAmount;\r\n    }\r\n    \r\n    /// @notice Gets all addresses whose funds get reflected\r\n    /// @return reflects_ All addresses whose funds are reflected\r\n    function reflects()\r\n        external\r\n        view\r\n        returns (SLib.Reflect_[] memory reflects_)\r\n    {\r\n        return SLib.getS().reflects;\r\n    }\r\n\r\n}\r\n"}}}