{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/EAToken.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-only\n/**\n * EAToken\n * v1.0\n */\npragma solidity ^0.6.4;\n\nimport \"./ERC20Basic.sol\";\nimport \"./SafeMath256.sol\";\nimport \"./Ownable.sol\";\nimport \"./Pausable.sol\";\n\ncontract EAToken is ERC20Basic, Ownable, Pausable {\n    using SafeMath256 for uint256;\n\n    // ERC20 params\n    string private _name = \"EATokenV1.0\";\n    string private _symbol = \"EA\";\n    uint8 private _decimals = 6;\n    uint256 private _totalSupply;\n    mapping(address => uint256) internal balances;\n    address[] private _ctl;\n\n    event Mint(address indexed to, uint256 amount);\n\n    /// move tokens\n    function _move(address from, address to, uint256 value) private {\n        require(value <= balances[from], \"EAToken: [_move] balance not enough\");\n        require(to != address(0), \"EAToken: [_move] to[address] is illegal\");\n\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n    }\n\n    /// transfer token\n    function transfer(address to, uint256 value) public whenNotPaused override returns (bool) {\n        _move(msg.sender, to, value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /// erc20 interface\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /// erc20 interface\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /// erc20 interface\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /// erc20 interface\n    function balanceOf(address _owner) public override view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /// erc20 interface\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// get gameCtl\n    function gameCtl() public view returns (address[] memory) {\n        return _ctl;\n    }\n\n    /// set gameCtl\n    function setGameCtl(address[] calldata _gc) external onlyOwner {\n        _ctl = _gc;\n    }\n\n    // check ctl\n    function _isCtl(address _addr) private view returns(bool) {\n        for(uint i = 0; i < _ctl.length; i++) {\n            if (_ctl[i] == _addr) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// pay forward\n    function payF(address _account, uint256 _value) external {\n        require(_isCtl(msg.sender), \"EAToken: must use game ctl\");\n        _move(_account, msg.sender, _value);\n    }\n\n    /// mint\n    function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {\n        _totalSupply = _totalSupply.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n}\n"},"localhost/ERC20Basic.sol":{"content":"pragma solidity ^0.6.4;\n\n/**\n * @title ERC20Basic\n * @dev EA\n */\ninterface ERC20Basic {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address _who) external view returns (uint256);\n  function transfer(address _to, uint256 _value) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"},"localhost/Ownable.sol":{"content":"pragma solidity ^0.6.4;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Ownable: [onlyOwner]\");\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0), \"Ownable: [_transferOwnership] _newOwner illegal\");\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n"},"localhost/Pausable.sol":{"content":"pragma solidity ^0.6.4;\n\nimport \"./Ownable.sol\";\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused, \"Pausable: not paused\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused, \"Pausable: paused\");\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() public onlyOwner whenNotPaused {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() public onlyOwner whenPaused {\n    paused = false;\n    emit Unpause();\n  }\n}\n"},"localhost/SafeMath256.sol":{"content":"pragma solidity ^0.6.4;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\n */\nlibrary SafeMath256 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}}