{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Dequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"https://github.com/uniswap/uniswap-v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"https://github.com/uniswap/uniswap-v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\n\ncontract DequestBase {\n    \n    address public owner;\n    address public uniswapRouter;\n    address public tokenAddr;\n    uint8 public constant LAST_LEVEL = 8;\n    mapping(address => User) public users;\n    mapping(uint256 => address) public idToAddress;\n    uint256 public lastUserId = 100101;\n    mapping(uint8 => uint256) public levelPrice;\n    uint8 public state;\n    mapping(uint8 => uint256) public stats;\n    address investor;\n    address public signer;\n    \n    struct User {\n        uint256 id;\n        address referrer;\n        uint256 partnersCount;\n        \n        mapping(uint8 => bool) activeX3Levels;\n        mapping(uint8 => bool) activeX6Levels;\n        \n        mapping(uint8 => X3) x3Matrix;\n        mapping(uint8 => X6) x6Matrix;\n    }\n    \n    struct X3 {\n        address currentReferrer;\n        address[] referrals;\n        bool blocked;\n        uint256 reinvestCount;\n        uint256 estEarn;\n    }\n    \n    struct X6 {\n        address currentReferrer;\n        address[] firstLevelReferrals;\n        address[] secondLevelReferrals;\n        bool blocked;\n        uint256 reinvestCount;\n        uint256 estEarn;\n\n        address closedPart;\n    }\n    \n    event Registration(address indexed user, address indexed referrer, uint256 indexed userId, uint256 referrerId);\n    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);\n    event Upgrade(address indexed user, address indexed referrer, uint8 matrix, uint8 level);\n    event NewUserPlace(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint8 place);\n    event MissedERC20Receive(address indexed receiver, address indexed from, uint8 matrix, uint8 level);\n    event SentExtraERC20Dividends(address indexed from, address indexed receiver, uint8 matrix, uint8 level);\n    event ERC20Dividens(address indexed receiver, uint8 indexed matrix, uint8 indexed level, uint256 fromAmount, uint256 toAmount);\n    event InvestorDividens(address indexed receiver, uint8 indexed matrix, uint8 indexed level, uint256 amount);\n    \n    modifier isNotInit() {\n        require(state == 0, \"Dequest: already initialized.\");\n        _;\n    }\n    \n    modifier isOwner() {\n        require(msg.sender == owner || address(0) == owner, \"Dequest: Not owner\");\n        _;\n    }\n}\n\ncontract DequestSwapable {\n    \n    function swap(address _uniswapRouter, address _tokenAddr, uint256 _value, address _receiver, uint256 _deadline) internal returns (uint256 minAmount) {\n        IUniswapV2Router02 router = IUniswapV2Router02(_uniswapRouter);\n        address[] memory path = new address[](2);\n        path[0] = router.WETH();\n        path[1] = _tokenAddr;\n        \n        minAmount = router.getAmountsOut(_value, path)[1] * 95 / 100;\n        \n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{ value : _value }(minAmount, path, _receiver, _deadline);\n    }\n}\n\ncontract Dequest is DequestBase, DequestSwapable {\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    function init(uint256 _startPrice, address _uniswapRouter, address _tokenAddr) external isNotInit isOwner returns(bool) {\n        \n        owner = msg.sender;\n        investor = msg.sender;\n        state = 1;\n        lastUserId = 100101;\n        uniswapRouter = _uniswapRouter;\n        tokenAddr = _tokenAddr;\n        \n        levelPrice[1] = _startPrice;\n        for (uint8 i = 2; i <= LAST_LEVEL; i++) {\n            levelPrice[i] = levelPrice[i-1] * 2;\n        }\n        \n        User memory user = User({\n            id: lastUserId,\n            referrer: address(0),\n            partnersCount: uint256(0)\n        });\n        \n        users[owner] = user;\n        idToAddress[lastUserId] = owner;\n        \n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\n            users[owner].activeX3Levels[i] = true;\n            users[owner].activeX6Levels[i] = true;\n        }\n        \n        lastUserId++;\n    }\n    \n    function changeOwner(address _owner) external isOwner returns (bool) {\n        owner = _owner;\n        return true;\n    }\n    \n    function changeInvestor(address _investor) external isOwner returns (bool) {\n        investor = _investor;\n        return true;\n    }\n    \n    function changeSigner(address _signer) external isOwner returns (bool) {\n        signer = _signer;\n        return true;\n    }\n    \n    function changeState(uint8 _state) external isOwner returns (bool) {\n        state = _state;\n        return true;\n    }\n    \n    function updateSwapInfo(address _uniswapRouter, address _tokenAddr) external isOwner returns (bool) {\n        uniswapRouter = _uniswapRouter;\n        tokenAddr = _tokenAddr;\n        return true;\n    }\n    \n    function registrationExt(address referrerAddress, uint256 _deadline) external payable {\n        registration(msg.sender, referrerAddress, _deadline, true);\n    }\n    \n    function registrationExtAdmin(address userAddr, address referrerAddress, uint256 _deadline, uint8 v, bytes32 r, bytes32 s) external payable {\n        require(signer != address(0x0), \"Dequest: Invalid signer [1]\");\n        \n        bytes32 message = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encode(userAddr, referrerAddress, _deadline, msg.sender))));\n        \n        require(ecrecover(message, v, r, s) == signer, \"Dequest: Invalid signer [2]\");\n        require(now <= _deadline, \"Dequest: Request expired\");\n        \n        registration(userAddr, referrerAddress, _deadline, false);\n        \n        for (uint8 i = 2; i <= LAST_LEVEL; i++) {\n            newLevel(1, i, _deadline, userAddr, false);\n            newLevel(2, i, _deadline, userAddr, false);\n        }\n    }\n    \n    function buyNewLevel(uint8 matrix, uint8 level, uint256 _deadline) external payable {\n        newLevel(matrix, level, _deadline, msg.sender, true);\n    }\n    \n    function newLevel(uint8 matrix, uint8 level, uint256 _deadline, address userAddr, bool withPayment) internal {\n        require(isUserExists(userAddr), \"Dequest: user is not exists. Register first.\");\n        require(matrix == 1 || matrix == 2, \"Dequest: invalid matrix\");\n        if (withPayment) {\n            require(msg.value == levelPrice[level], \"Dequest: invalid price\");\n        }\n        require(level > 1 && level <= LAST_LEVEL, \"Dequest: invalid level\");\n\n        if (matrix == 1) {\n            require(!users[userAddr].activeX3Levels[level], \"Dequest: level already activated\");\n\n            if (users[userAddr].x3Matrix[level-1].blocked) {\n                users[userAddr].x3Matrix[level-1].blocked = false;\n            }\n    \n            address freeX3Referrer = findFreeX3Referrer(userAddr, level);\n            users[userAddr].x3Matrix[level].currentReferrer = freeX3Referrer;\n            users[userAddr].activeX3Levels[level] = true;\n            updateX3Referrer(userAddr, freeX3Referrer, level, _deadline, withPayment);\n            \n            emit Upgrade(userAddr, freeX3Referrer, 1, level);\n\n        } else {\n            require(!users[userAddr].activeX6Levels[level], \"Dequest: level already activated\"); \n\n            if (users[userAddr].x6Matrix[level-1].blocked) {\n                users[userAddr].x6Matrix[level-1].blocked = false;\n            }\n\n            address freeX6Referrer = findFreeX6Referrer(userAddr, level);\n            \n            users[userAddr].activeX6Levels[level] = true;\n            updateX6Referrer(userAddr, freeX6Referrer, level, _deadline, withPayment);\n            \n            emit Upgrade(userAddr, freeX6Referrer, 2, level);\n        }\n    }\n    \n    function registration(address userAddress, address referrerAddress, uint256 _deadline, bool withPayment) internal {\n        uint256 price = levelPrice[1] * 2;\n        \n        if (withPayment) {\n            require(msg.value == price, \"Dequest: invalid registration cost\");\n        }\n        \n        require(!isUserExists(userAddress), \"Dequest: user exists\");\n        require(isUserExists(referrerAddress), \"Dequest: referrer not exists\");\n        \n        uint32 size;\n        assembly {\n            size := extcodesize(userAddress)\n        }\n        require(size == 0, \"Dequest: cannot be a contract\");\n        \n        User memory user = User({\n            id: lastUserId,\n            referrer: referrerAddress,\n            partnersCount: 0\n        });\n        \n        users[userAddress] = user;\n        idToAddress[lastUserId] = userAddress;\n        \n        users[userAddress].referrer = referrerAddress;\n        \n        users[userAddress].activeX3Levels[1] = true; \n        users[userAddress].activeX6Levels[1] = true;\n        \n        lastUserId++;\n        \n        users[referrerAddress].partnersCount++;\n\n        address freeX3Referrer = findFreeX3Referrer(userAddress, 1);\n        users[userAddress].x3Matrix[1].currentReferrer = freeX3Referrer;\n        updateX3Referrer(userAddress, freeX3Referrer, 1, _deadline, withPayment);\n\n        updateX6Referrer(userAddress, findFreeX6Referrer(userAddress, 1), 1, _deadline, withPayment);\n        \n        emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id);\n        \n        stats[0]++;\n    }\n    \n    function updateX3Referrer(address userAddress, address referrerAddress, uint8 level, uint256 _deadline, bool withPayment) internal {\n        users[referrerAddress].x3Matrix[level].referrals.push(userAddress);\n\n        if (users[referrerAddress].x3Matrix[level].referrals.length < 3) {\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, uint8(users[referrerAddress].x3Matrix[level].referrals.length));\n            sendERC20Dividends(referrerAddress, userAddress, 1, level, _deadline, withPayment);\n            return ;\n        }\n        \n        emit NewUserPlace(userAddress, referrerAddress, 1, level, 3);\n        //close matrix\n        users[referrerAddress].x3Matrix[level].referrals = new address[](0);\n        if (!users[referrerAddress].activeX3Levels[level+1] && level != LAST_LEVEL) {\n            users[referrerAddress].x3Matrix[level].blocked = true;\n        }\n\n        //create new one by recursion\n        if (referrerAddress != owner) {\n            //check referrer active level\n            address freeReferrerAddress = findFreeX3Referrer(referrerAddress, level);\n            if (users[referrerAddress].x3Matrix[level].currentReferrer != freeReferrerAddress) {\n                users[referrerAddress].x3Matrix[level].currentReferrer = freeReferrerAddress;\n            }\n            \n            users[referrerAddress].x3Matrix[level].reinvestCount++;\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 1, level);\n            updateX3Referrer(referrerAddress, freeReferrerAddress, level, _deadline, withPayment);\n        } else {\n            sendERC20Dividends(owner, userAddress, 1, level, _deadline, withPayment);\n            users[owner].x3Matrix[level].reinvestCount++;\n            emit Reinvest(owner, address(0), userAddress, 1, level);\n        }\n    }\n    \n    function updateX6Referrer(address userAddress, address referrerAddress, uint8 level, uint256 _deadline, bool withPayment) internal {\n        require(users[referrerAddress].activeX6Levels[level], \"Dequest: 500. Referrer level is inactive\");\n        \n        if (users[referrerAddress].x6Matrix[level].firstLevelReferrals.length < 2) {\n            users[referrerAddress].x6Matrix[level].firstLevelReferrals.push(userAddress);\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, uint8(users[referrerAddress].x6Matrix[level].firstLevelReferrals.length));\n            \n            //set current level\n            users[userAddress].x6Matrix[level].currentReferrer = referrerAddress;\n\n            if (referrerAddress == owner) {\n                sendERC20Dividends(referrerAddress, userAddress, 2, level, _deadline, withPayment);\n                return ;\n            }\n            \n            address ref = users[referrerAddress].x6Matrix[level].currentReferrer;            \n            users[ref].x6Matrix[level].secondLevelReferrals.push(userAddress); \n            \n            uint256 len = users[ref].x6Matrix[level].firstLevelReferrals.length;\n            \n            if ((len == 2) && \n                (users[ref].x6Matrix[level].firstLevelReferrals[0] == referrerAddress) &&\n                (users[ref].x6Matrix[level].firstLevelReferrals[1] == referrerAddress)) {\n                if (users[referrerAddress].x6Matrix[level].firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 5);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 6);\n                }\n            }  else if ((len == 1 || len == 2) &&\n                    users[ref].x6Matrix[level].firstLevelReferrals[0] == referrerAddress) {\n                if (users[referrerAddress].x6Matrix[level].firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 3);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 4);\n                }\n            } else if (len == 2 && users[ref].x6Matrix[level].firstLevelReferrals[1] == referrerAddress) {\n                if (users[referrerAddress].x6Matrix[level].firstLevelReferrals.length == 1) {\n                    emit NewUserPlace(userAddress, ref, 2, level, 5);\n                } else {\n                    emit NewUserPlace(userAddress, ref, 2, level, 6);\n                }\n            }\n\n            return updateX6ReferrerSecondLevel(userAddress, ref, level, _deadline, withPayment);\n        }\n        \n        users[referrerAddress].x6Matrix[level].secondLevelReferrals.push(userAddress);\n\n        if (users[referrerAddress].x6Matrix[level].closedPart != address(0)) {\n            if ((users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] == \n                users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]) &&\n                (users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] ==\n                users[referrerAddress].x6Matrix[level].closedPart)) {\n\n                updateX6(userAddress, referrerAddress, level, true);\n                return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level, _deadline, withPayment);\n            } else if (users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] == \n                users[referrerAddress].x6Matrix[level].closedPart) {\n                updateX6(userAddress, referrerAddress, level, true);\n                return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level, _deadline, withPayment);\n            } else {\n                updateX6(userAddress, referrerAddress, level, false);\n                return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level, _deadline, withPayment);\n            }\n        }\n\n        if (users[referrerAddress].x6Matrix[level].firstLevelReferrals[1] == userAddress) {\n            updateX6(userAddress, referrerAddress, level, false);\n            return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level, _deadline, withPayment);\n        } else if (users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] == userAddress) {\n            updateX6(userAddress, referrerAddress, level, true);\n            return updateX6ReferrerSecondLevel(userAddress, referrerAddress, level, _deadline, withPayment);\n        }\n        \n        if ((users[referrerAddress].x6Matrix[level].firstLevelReferrals[0] != users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]) &&\n            (users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[0]].x6Matrix[level].firstLevelReferrals.length <= \n            users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]].x6Matrix[level].firstLevelReferrals.length)) {\n            updateX6(userAddress, referrerAddress, level, false);\n        } else {\n            updateX6(userAddress, referrerAddress, level, true);\n        }\n        \n        updateX6ReferrerSecondLevel(userAddress, referrerAddress, level, _deadline, withPayment);\n    }\n    \n    function updateX6(address userAddress, address referrerAddress, uint8 level, bool x2) internal {\n        if (!x2) {\n            users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[0]].x6Matrix[level].firstLevelReferrals.push(userAddress);\n            emit NewUserPlace(userAddress, users[referrerAddress].x6Matrix[level].firstLevelReferrals[0], 2, level, uint8(users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[0]].x6Matrix[level].firstLevelReferrals.length));\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 2 + uint8(users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[0]].x6Matrix[level].firstLevelReferrals.length));\n            //set current level\n            users[userAddress].x6Matrix[level].currentReferrer = users[referrerAddress].x6Matrix[level].firstLevelReferrals[0];\n        } else {\n            users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]].x6Matrix[level].firstLevelReferrals.push(userAddress);\n            emit NewUserPlace(userAddress, users[referrerAddress].x6Matrix[level].firstLevelReferrals[1], 2, level, uint8(users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]].x6Matrix[level].firstLevelReferrals.length));\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 4 + uint8(users[users[referrerAddress].x6Matrix[level].firstLevelReferrals[1]].x6Matrix[level].firstLevelReferrals.length));\n            //set current level\n            users[userAddress].x6Matrix[level].currentReferrer = users[referrerAddress].x6Matrix[level].firstLevelReferrals[1];\n        }\n    }\n    \n    function updateX6ReferrerSecondLevel(address userAddress, address referrerAddress, uint8 level, uint256 _deadline, bool withPayment) internal {\n        if (users[referrerAddress].x6Matrix[level].secondLevelReferrals.length < 4) {\n            sendERC20Dividends(referrerAddress, userAddress, 2, level, _deadline, withPayment);\n            return ;\n        }\n        \n        address[] memory x6 = users[users[referrerAddress].x6Matrix[level].currentReferrer].x6Matrix[level].firstLevelReferrals;\n        \n        if (x6.length == 2) {\n            if (x6[0] == referrerAddress ||\n                x6[1] == referrerAddress) {\n                users[users[referrerAddress].x6Matrix[level].currentReferrer].x6Matrix[level].closedPart = referrerAddress;\n            } else if (x6.length == 1) {\n                if (x6[0] == referrerAddress) {\n                    users[users[referrerAddress].x6Matrix[level].currentReferrer].x6Matrix[level].closedPart = referrerAddress;\n                }\n            }\n        }\n        \n        users[referrerAddress].x6Matrix[level].firstLevelReferrals = new address[](0);\n        users[referrerAddress].x6Matrix[level].secondLevelReferrals = new address[](0);\n        users[referrerAddress].x6Matrix[level].closedPart = address(0);\n\n        if (!users[referrerAddress].activeX6Levels[level+1] && level != LAST_LEVEL) {\n            users[referrerAddress].x6Matrix[level].blocked = true;\n        }\n\n        users[referrerAddress].x6Matrix[level].reinvestCount++;\n        \n        if (referrerAddress != owner) {\n            address freeReferrerAddress = findFreeX6Referrer(referrerAddress, level);\n\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 2, level);\n            updateX6Referrer(referrerAddress, freeReferrerAddress, level, _deadline, withPayment);\n        } else {\n            emit Reinvest(owner, address(0), userAddress, 2, level);\n            sendERC20Dividends(owner, userAddress, 2, level, _deadline, withPayment);\n        }\n    }\n    \n    function findFreeX3Referrer(address userAddress, uint8 level) public view returns(address) {\n        while (true) {\n            if (users[users[userAddress].referrer].activeX3Levels[level] &&\n                !users[users[userAddress].referrer].x3Matrix[level].blocked) {\n                return users[userAddress].referrer;\n            }\n            userAddress = users[userAddress].referrer;\n        }\n    }\n    \n    function findFreeX6Referrer(address userAddress, uint8 level) public view returns(address) {\n        while (true) {\n            if (users[users[userAddress].referrer].activeX6Levels[level] &&\n                !users[users[userAddress].referrer].x6Matrix[level].blocked) {\n                return users[userAddress].referrer;\n            }\n            userAddress = users[userAddress].referrer;\n        }\n    }\n    \n    function usersActiveX3Levels(address userAddress, uint8 level) external view returns(bool) {\n        return users[userAddress].activeX3Levels[level];\n    }\n    \n    function usersActiveX6Levels(address userAddress, uint8 level) external view returns(bool) {\n        return users[userAddress].activeX6Levels[level];\n    }\n    \n    function usersX3Matrix(address userAddress, uint8 level) external view returns(address, address[] memory, bool, uint256) {\n        return (users[userAddress].x3Matrix[level].currentReferrer,\n                users[userAddress].x3Matrix[level].referrals,\n                users[userAddress].x3Matrix[level].blocked,\n                users[userAddress].x3Matrix[level].estEarn);\n    }\n    \n    function usersX6Matrix(address userAddress, uint8 level) external view returns(address, address[] memory, address[] memory, bool, address, uint256) {\n        return (users[userAddress].x6Matrix[level].currentReferrer,\n                users[userAddress].x6Matrix[level].firstLevelReferrals,\n                users[userAddress].x6Matrix[level].secondLevelReferrals,\n                users[userAddress].x6Matrix[level].blocked,\n                users[userAddress].x6Matrix[level].closedPart,\n                users[userAddress].x6Matrix[level].estEarn);\n    }\n    \n    function isUserExists(address user) public view returns (bool) {\n        return (users[user].id != 0);\n    }\n    \n    function findERC20Receiver(address userAddress, address _from, uint8 matrix, uint8 level) internal returns(address, bool) {\n        address receiver = userAddress;\n        bool isExtraDividends;\n        if (matrix == 1) {\n            while (true) {\n                if (users[receiver].x3Matrix[level].blocked) {\n                    emit MissedERC20Receive(receiver, _from, 1, level);\n                    isExtraDividends = true;\n                    receiver = users[receiver].x3Matrix[level].currentReferrer;\n                } else {\n                    return (receiver, isExtraDividends);\n                }\n            }\n        } else {\n            while (true) {\n                if (users[receiver].x6Matrix[level].blocked) {\n                    emit MissedERC20Receive(receiver, _from, 2, level);\n                    isExtraDividends = true;\n                    receiver = users[receiver].x6Matrix[level].currentReferrer;\n                } else {\n                    return (receiver, isExtraDividends);\n                }\n            }\n        }\n    }\n    \n    function sendERC20Dividends(address userAddress, address _from, uint8 matrix, uint8 level, uint256 _deadline, bool withPayment) internal returns (uint256 minAmount) {\n        \n        if (!withPayment) {\n            return 0;\n        }\n        \n        (address receiver, bool isExtraDividends) = findERC20Receiver(userAddress, _from, matrix, level);\n        \n        uint256 iAmt = levelPrice[level] * 10 / 100;\n        uint256 lPrice = levelPrice[level] - iAmt;\n        \n        payable(investor).transfer(iAmt);\n        emit InvestorDividens(investor, matrix, level, iAmt);\n        \n        minAmount = swap(uniswapRouter, tokenAddr, lPrice, receiver, _deadline);\n        if (matrix == 1) {\n            users[receiver].x3Matrix[level].estEarn += minAmount;\n        } else {\n            users[receiver].x6Matrix[level].estEarn += minAmount;\n        }\n        \n        emit ERC20Dividens(receiver, matrix, level, levelPrice[level], minAmount);\n        stats[1] += levelPrice[level];\n        stats[2] += minAmount;\n        \n        if (isExtraDividends) {\n            emit SentExtraERC20Dividends(_from, receiver, matrix, level);\n        }\n    }\n}\n\ncontract Storage {\n\n    bytes32 private constant _IMPL_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 private constant _OWNR_SLOT = 0x47e21bd924639e009830914fa04c527878b6aa0d3a9314aa3b88500716eb806b;\n    \n    event Upgrade(address indexed implementation);\n    event ChangeOwner(address indexed owner);\n    \n    modifier isOwner() {\n        address owner = _owner();\n        require(msg.sender == owner || address(0) == owner, \"Storage: Not owner.\");\n        _;\n    }\n    \n    constructor(address _impl) public {\n        require(_IMPL_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1), \"Storage: Invalid IMPL slot\");\n        require(_OWNR_SLOT == bytes32(uint256(keccak256(\"storage.owner.slot\")) - 1), \"Storage: Invalid OWNR slot\");\n        \n        _upgrade(_impl);\n        _changeOwner(msg.sender);\n    }\n    \n    function _upgrade(address _impl) public isOwner returns (bool) {\n        bytes32 slot = _IMPL_SLOT;\n        \n        emit Upgrade(_impl);\n        \n        assembly {\n            sstore(slot, _impl)\n        }\n        \n        return true;\n    }\n    \n    function _changeOwner(address _ownr) public isOwner returns (bool) {\n        bytes32 slot = _OWNR_SLOT;\n        \n        emit ChangeOwner(_ownr);\n        \n        assembly {\n            sstore(slot, _ownr)\n        }\n        \n        return true;\n    }\n    \n    function _implementation() public view returns (address _impl) {\n        bytes32 slot = _IMPL_SLOT;\n        assembly {\n            _impl := sload(slot)\n        }\n    }\n    \n    function _owner() public view returns (address _ownr) {\n        bytes32 slot = _OWNR_SLOT;\n        assembly {\n            _ownr := sload(slot)\n        }\n    }\n    \n    fallback() external payable {\n        address _impl = _implementation();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}\n"
    },
    "https://github.com/uniswap/uniswap-v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "https://github.com/uniswap/uniswap-v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "https://github.com/uniswap/uniswap-v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    }
  }
}