{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/buyLbpTx.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport './helpers.sol';\n\n    struct SingleSwap {\n        bytes32 poolId;\n        uint8 kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\ninterface balancerV2Vault {\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    )\n    external\n    payable;\n}\n\ncontract buyLbpTx is Owned, WithdrawFundsToOwner, AccessControl, ApproveErc20 {\n\n    constructor() {\n        _grantAdmin(msg.sender);\n    }\n\n    function swapYo(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline,\n        address vaultAddress\n    )\n    external\n    payable {\n        return balancerV2Vault(vaultAddress).swap(singleSwap, funds, limit, deadline);\n    }\n}"},"contracts/helpers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ncontract Owned {\n    address payable owner;\n\n    constructor() { owner = msg.sender; }\n}\n\ncontract WithdrawFundsToOwner is Owned {\n\n    function wthdrwEther(uint256 amount) external {\n        require( owner == tx.origin, \"x\");\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function wthdrwToken(address tokenAddress, uint256 amount) external {\n        require( owner == tx.origin, \"x\");\n        uint256 withdrawAmount =  amount;\n\n        IERC20 tokenContract = IERC20(tokenAddress);\n\n        // if amount == 0 - withdraw all tokens!!!\n        if (amount == 0) {\n            uint256 contractTokenBalance = tokenContract.balanceOf(address(this));\n            require(contractTokenBalance > 0, \"Token balance is 0\");\n            withdrawAmount = contractTokenBalance;\n        }\n\n        address recipient = msg.sender;\n\n        tokenContract.transfer(recipient, withdrawAmount);\n    }\n}\n\nabstract contract AccessControl {\n    mapping(address => bool) private _admins;\n\n    function isAdminYo(address account) public view returns (bool) {\n        return _admins[account];\n    }\n\n    function _grantAdmin(address account) internal {\n        if (!isAdminYo(account)) {\n            _admins[account] = true;\n        }\n    }\n\n    function _revokeAdmin(address account) internal {\n        if (isAdminYo(account)) {\n            _admins[account] = false;\n        }\n    }\n\n    function grantAdminYo(address account) public {\n        require( isAdminYo(tx.origin), \"zz\");\n        _grantAdmin( account);\n    }\n\n    function revokeAdminYo(address account) public {\n        require( isAdminYo(tx.origin), \"zz\");\n        _revokeAdmin( account);\n    }\n}\n\ncontract ApproveErc20 is AccessControl {\n    function approveToken(address tokenAddress, address spenderAddress) external {\n        require( isAdminYo(tx.origin), \"x\");\n        _approveToken(tokenAddress, spenderAddress);\n    }\n\n    function _approveToken(address tokenAddress, address spenderAddress) private {\n        IERC20 tokenContract = IERC20(tokenAddress);\n        tokenContract.approve(\n            spenderAddress,\n            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n        );\n    }\n}"}}}