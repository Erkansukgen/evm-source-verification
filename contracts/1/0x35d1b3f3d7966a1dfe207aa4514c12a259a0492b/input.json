{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"vat.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2019-11-14\n*/\n\n// hevm: flattened sources of /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/vat.sol\npragma solidity =0.5.12;\n\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/vat.sol\n/// vat.sol -- Dai CDP database\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.5.12; */\n\ncontract Vat {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 1; }\n    function deny(address usr) external note auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\n        _;\n    }\n\n    mapping(address => mapping (address => uint)) public can;\n    function hope(address usr) external note { can[msg.sender][usr] = 1; }\n    function nope(address usr) external note { can[msg.sender][usr] = 0; }\n    function wish(address bit, address usr) internal view returns (bool) {\n        return either(bit == usr, can[bit][usr] == 1);\n    }\n\n    // --- Data ---\n    struct Ilk {\n        uint256 Art;   // Total Normalised Debt     [wad]\n        uint256 rate;  // Accumulated Rates         [ray]\n        uint256 spot;  // Price with Safety Margin  [ray]\n        uint256 line;  // Debt Ceiling              [rad]\n        uint256 dust;  // Urn Debt Floor            [rad]\n    }\n    struct Urn {\n        uint256 ink;   // Locked Collateral  [wad]\n        uint256 art;   // Normalised Debt    [wad]\n    }\n\n    mapping (bytes32 => Ilk)                       public ilks;\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\n    mapping (address => uint256)                   public dai;  // [rad]\n    mapping (address => uint256)                   public sin;  // [rad]\n\n    uint256 public debt;  // Total Dai Issued    [rad]\n    uint256 public vice;  // Total Unbacked Dai  [rad]\n    uint256 public Line;  // Total Debt Ceiling  [rad]\n    uint256 public live;  // Access Flag\n\n    // --- Logs ---\n    event LogNote(\n        bytes4   indexed  sig,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes32  indexed  arg3,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: the selector and the first three args\n            let mark := msize                         // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 calldataload(4),                     // arg1\n                 calldataload(36),                    // arg2\n                 calldataload(68)                     // arg3\n                )\n        }\n    }\n\n    // --- Init ---\n    constructor() public {\n        wards[msg.sender] = 1;\n        live = 1;\n    }\n\n    // --- Math ---\n    function add(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n    function sub(uint x, int y) internal pure returns (uint z) {\n        z = x - uint(y);\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function mul(uint x, int y) internal pure returns (int z) {\n        z = int(x) * y;\n        require(int(x) >= 0);\n        require(y == 0 || z / y == int(x));\n    }\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    function init(bytes32 ilk) external note auth {\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\n        ilks[ilk].rate = 10 ** 27;\n    }\n    function file(bytes32 what, uint data) external note auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"Line\") Line = data;\n        else revert(\"Vat/file-unrecognized-param\");\n    }\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"spot\") ilks[ilk].spot = data;\n        else if (what == \"line\") ilks[ilk].line = data;\n        else if (what == \"dust\") ilks[ilk].dust = data;\n        else revert(\"Vat/file-unrecognized-param\");\n    }\n    function cage() external note auth {\n        live = 0;\n    }\n\n    // --- Fungibility ---\n    function slip(bytes32 ilk, address usr, int256 wad) external note auth {\n        gem[ilk][usr] = add(gem[ilk][usr], wad);\n    }\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external note {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        gem[ilk][src] = sub(gem[ilk][src], wad);\n        gem[ilk][dst] = add(gem[ilk][dst], wad);\n    }\n    function move(address src, address dst, uint256 rad) external note {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        dai[src] = sub(dai[src], rad);\n        dai[dst] = add(dai[dst], rad);\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- CDP Manipulation ---\n    function frob(bytes32 i, address u, address v, address w, int dink, int dart) external note {\n        // system is live\n        require(live == 1, \"Vat/not-live\");\n\n        Urn memory urn = urns[i][u];\n        Ilk memory ilk = ilks[i];\n        // ilk has been initialised\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\n\n        urn.ink = add(urn.ink, dink);\n        urn.art = add(urn.art, dart);\n        ilk.Art = add(ilk.Art, dart);\n\n        int dtab = mul(ilk.rate, dart);\n        uint tab = mul(ilk.rate, urn.art);\n        debt     = add(debt, dtab);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        require(either(dart <= 0, both(mul(ilk.Art, ilk.rate) <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\n        // urn is either less risky than before, or it is safe\n        require(either(both(dart <= 0, dink >= 0), tab <= mul(urn.ink, ilk.spot)), \"Vat/not-safe\");\n\n        // urn is either more safe, or the owner consents\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\n        // collateral src consents\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\n        // debt dst consents\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\n\n        // urn has no debt, or a non-dusty amount\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\n\n        gem[i][v] = sub(gem[i][v], dink);\n        dai[w]    = add(dai[w],    dtab);\n\n        urns[i][u] = urn;\n        ilks[i]    = ilk;\n    }\n    // --- CDP Fungibility ---\n    function fork(bytes32 ilk, address src, address dst, int dink, int dart) external note {\n        Urn storage u = urns[ilk][src];\n        Urn storage v = urns[ilk][dst];\n        Ilk storage i = ilks[ilk];\n\n        u.ink = sub(u.ink, dink);\n        u.art = sub(u.art, dart);\n        v.ink = add(v.ink, dink);\n        v.art = add(v.art, dart);\n\n        uint utab = mul(u.art, i.rate);\n        uint vtab = mul(v.art, i.rate);\n\n        // both sides consent\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\n\n        // both sides safe\n        require(utab <= mul(u.ink, i.spot), \"Vat/not-safe-src\");\n        require(vtab <= mul(v.ink, i.spot), \"Vat/not-safe-dst\");\n\n        // both sides non-dusty\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\n    }\n    // --- CDP Confiscation ---\n    function grab(bytes32 i, address u, address v, address w, int dink, int dart) external note auth {\n        Urn storage urn = urns[i][u];\n        Ilk storage ilk = ilks[i];\n\n        urn.ink = add(urn.ink, dink);\n        urn.art = add(urn.art, dart);\n        ilk.Art = add(ilk.Art, dart);\n\n        int dtab = mul(ilk.rate, dart);\n\n        gem[i][v] = sub(gem[i][v], dink);\n        sin[w]    = sub(sin[w],    dtab);\n        vice      = sub(vice,      dtab);\n    }\n\n    // --- Settlement ---\n    function heal(uint rad) external note {\n        address u = msg.sender;\n        sin[u] = sub(sin[u], rad);\n        dai[u] = sub(dai[u], rad);\n        vice   = sub(vice,   rad);\n        debt   = sub(debt,   rad);\n    }\n    function suck(address u, address v, uint rad) external note auth {\n        sin[u] = add(sin[u], rad);\n        dai[v] = add(dai[v], rad);\n        vice   = add(vice,   rad);\n        debt   = add(debt,   rad);\n    }\n\n    // --- Rates ---\n    function fold(bytes32 i, address u, int rate) external note auth {\n        require(live == 1, \"Vat/not-live\");\n        Ilk storage ilk = ilks[i];\n        ilk.rate = add(ilk.rate, rate);\n        int rad  = mul(ilk.Art, rate);\n        dai[u]   = add(dai[u], rad);\n        debt     = add(debt,   rad);\n    }\n}\n"}}}