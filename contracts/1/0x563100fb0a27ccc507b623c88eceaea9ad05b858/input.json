{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/yf.sol":{"content":"pragma solidity ^0.7.4;\ninterface tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;}\ncontract ERC20 {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed from, uint256 value);\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != address(0x0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n\n\ncontract yieldFarmer {\n    address creator;\n    uint8 public decimals = 18;\n    uint64 public blockTime = 180000;\n    address erushLPtoken = 0x88B96ad151D86AAb2367292f53e53C8eaF12dFa3;\n    address daiAddress = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    event NewFarmer(address indexed from, uint256 value);\n    event RemoveLiq(address indexed from, uint256 value);\n    using SafeMath for uint;\n    constructor() {creator = msg.sender;}\n\n    struct fdetailz {\n       uint256 _amount;\n       uint256 _block;\n   }\n\n    mapping(address => fdetailz) fdetails;\n\n    function importDAI(uint256 _tokens)  public {\n        uint256 rma = _tokens * 10 ** uint256(decimals);\n        ERC20(daiAddress).transferFrom(msg.sender, address(this), rma);\n    }\n\n\n\n    function startFarming(uint256 _tokens)  public {\n        //150 LP token provider can reach 50  DAI -> 0.33$ per LPToken\n        uint256 rma = _tokens.mul(10 ** uint256(decimals));\n        require(rma > 1 * 10 ** uint256(decimals)); //minimum 1 LPtoken require\n        require(ERC20(erushLPtoken).balanceOf(msg.sender) >= rma);\n        require(fdetails[msg.sender]._amount == 0);\n        ERC20(erushLPtoken).transferFrom(msg.sender, address(this), rma);\n        uint256 daincome = _tokens.mul(50).div(150);\n        ERC20(daiAddress).transfer(msg.sender, daincome * 10 ** uint256(decimals) );\n        fdetails[msg.sender] = fdetailz(rma, block.number);\n        emit NewFarmer(msg.sender, _tokens);\n    }\n\n    function stopFarming() public {\n        require(fdetails[msg.sender]._amount != 0);\n        require(block.number - fdetails[msg.sender]._block >= blockTime);\n        ERC20(erushLPtoken).transfer(msg.sender, fdetails[msg.sender]._amount);\n        emit RemoveLiq(msg.sender, fdetails[msg.sender]._amount.div(10 ** uint256(decimals)));\n        fdetails[msg.sender] = fdetailz(0, 0);\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == creator);   // Check if the sender is manager\n        if (newOwner != address(0)) {\n            creator = newOwner;\n        }\n    }\n\n    function showMyBloks(address _addr) public view returns(uint256) {\n        return block.number - fdetails[_addr]._block;\n    }\n\n\n    function showMyBalance(address _addr) public view returns(uint256) {\n        return   fdetails[_addr]._amount.div(10 ** uint256(decimals));\n    }\n\n    function withdrawal(uint tokens)  public {\n        require(msg.sender == creator);\n        ERC20(erushLPtoken).transfer(creator, tokens);\n    }\n\n    function withdrawalDAI(uint tokens)  public {\n        require(msg.sender == creator);\n        ERC20(daiAddress).transfer(creator, tokens);\n    }\n}\n"}}}