{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/UniBOMBV1.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-05-11\n*/\n\npragma solidity ^0.6.8;\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a / b;\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n    uint256 c = add(a,m);\n    uint256 d = sub(c,1);\n    return mul(div(d,m),m);\n  }\n}\n\nabstract contract ERC20Token {\n  function approve(address spender, uint256 value) public virtual returns (bool);\n  function transferFrom (address from, address to, uint value) public virtual returns (bool);\n}\n\ncontract Ownable {\n    address public owner;\n\n    event TransferOwnership(address _from, address _to);\n\n    constructor() public {\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    function setOwner(address _owner) external onlyOwner {\n        emit TransferOwnership(owner, _owner);\n        owner = _owner;\n    }\n}\n\ncontract WrappedBOMB is Ownable {\n   \n    using SafeMath for uint256;\n  \n    string public name     = \"Wrapped BOMB\";\n    string public symbol   = \"WBOMB\";\n    uint8  public decimals = 0;\n    \n    address BOMB_CONTRACT = 0x1C95b093d6C236d3EF7c796fE33f9CC6b8606714;\n    \n    uint256 public _totalSupply = 0;\n    uint256 basePercent = 100;\n    \n    event Approval(address indexed src, address indexed guy, uint256 amount);\n    event Transfer(address indexed src, address indexed to, uint256 amount);\n    event Deposit(address indexed to, uint256 amount);\n    event Withdrawal(address indexed src, uint256 amount);\n    event WhitelistFrom(address _addr, bool _whitelisted);\n    event WhitelistTo(address _addr, bool _whitelisted);\n    \n\n    mapping (address => uint256)                       public  balanceOf;\n    mapping (address => mapping (address => uint256))  public  allowance;\n    \n \n    mapping(address => bool) public whitelistFrom;\n    mapping(address => bool) public whitelistTo;\n\n    fallback()  external payable {\n        revert();\n    }\n    \n    function _isWhitelisted(address _from, address _to) internal view returns (bool) {\n        return whitelistFrom[_from]||whitelistTo[_to];\n    }\n\n    function setWhitelistedTo(address _addr, bool _whitelisted) external onlyOwner {\n        emit WhitelistTo(_addr, _whitelisted);\n        whitelistTo[_addr] = _whitelisted;\n    }\n\n    function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyOwner {\n        emit WhitelistFrom(_addr, _whitelisted);\n        whitelistFrom[_addr] = _whitelisted;\n    }\n    \n    function deposit(uint256 amount) public returns(uint256){ //deposit burn is intrinsic to BOMB\n    \n        require(ERC20Token(BOMB_CONTRACT).transferFrom(address(msg.sender),address(this),amount),\"TransferFailed\");\n            \n        //calc actual deposit amount due to BOMB burn\n        uint256 tokensToBurn = findOnePercent(amount);\n        uint256 actual = amount.sub(tokensToBurn);\n        \n        balanceOf[msg.sender] += actual;\n        _totalSupply += actual;\n        emit Deposit(msg.sender, amount);\n        emit Transfer(address(this), address(msg.sender), actual);\n        return actual;\n        \n        \n    }\n    \n    function withdraw(uint256 amount) public returns(uint256){ //\n        require(balanceOf[msg.sender] >= amount,\"NotEnoughBalance\");\n        balanceOf[msg.sender] -= amount;\n        _totalSupply -= amount;\n        emit Withdrawal(msg.sender, amount);\n        emit Transfer(address(msg.sender), address(this), amount);\n        ERC20Token(BOMB_CONTRACT).approve(address(this),amount);\n        ERC20Token(BOMB_CONTRACT).transferFrom(address(this),address(msg.sender),amount);\n        return amount;\n        \n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address guy, uint256 amount) public returns (bool) {\n        allowance[msg.sender][guy] = amount;\n        emit Approval(msg.sender, guy, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) { //unibombs\n        return transferFrom(msg.sender, to, amount);\n    }\n    \n    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n        for (uint256 i = 0; i < receivers.length; i++) {\n            transfer(receivers[i], amounts[i]);\n        }\n    }\n    \n    function findOnePercent(uint256 value) public view returns (uint256)  {\n        uint256 roundValue = value.ceil(basePercent);\n        uint256 onePercent = roundValue.mul(basePercent).div(10000);\n        return onePercent;\n    }\n    \n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= balanceOf[from],\"NotEnoughBalance\");\n\n        if (from != msg.sender && allowance[from][msg.sender] != uint(-1)) {\n            require(allowance[from][msg.sender] >= value);\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        \n        balanceOf[from] = balanceOf[from].sub(value);\n\n        if(!_isWhitelisted(from, to)){\n            uint256 tokensToBurn = findOnePercent(value);\n            uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n            balanceOf[to] = balanceOf[to].add(tokensToTransfer);\n            _totalSupply = _totalSupply.sub(tokensToBurn);\n\n            emit Transfer(from, to, tokensToTransfer);\n            emit Transfer(from, address(0), tokensToBurn);\n            ERC20Token(BOMB_CONTRACT).approve(address(this),value);\n            ERC20Token(BOMB_CONTRACT).transferFrom(address(this),address(this),value); //burn\n            //\n            }\n        \n        else{\n          //  uint256 tokensToTransfer = .sub(tokensToBurn);\n\n            balanceOf[to] = balanceOf[to].add(value);\n            \n            emit Transfer(from, to, value);\n       }\n        return true;\n    }\n    \n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n        allowance[msg.sender][spender] = (allowance[msg.sender][spender].add(addedValue));\n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n        allowance[msg.sender][spender] = (allowance[msg.sender][spender].sub(subtractedValue));\n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);\n        return true;\n    }\n\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= balanceOf[account]);\n        _totalSupply = _totalSupply.sub(amount);\n        balanceOf[account] = balanceOf[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external {\n        require(amount <= allowance[account][msg.sender]);\n        allowance[account][msg.sender] = allowance[account][msg.sender].sub(amount);\n        _burn(account, amount);\n    }\n\n}"
    }
  }
}