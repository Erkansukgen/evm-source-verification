{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Flashbots.sol": {
      "content": "pragma solidity 0.8.1;\n\ninterface IUniswap {\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n        \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n}\n\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract Flashbots {\n  IUniswap constant public uniswap = IUniswap(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n  event Amounts(uint[] val);\n  event Profit(int val);\n  \n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        {\n            \n            uniswap.swapExactETHForTokens{ value: msg.value }(\n              amountOutMin,\n              path,\n              to,\n              deadline\n            );\n            \n        }\n        \n  function swapExactTokensForETH(address tokenAddress, uint buyValue, uint amountIn, uint amountOutMin, address[] calldata path, address payable to, uint deadline)\n        external\n        payable\n        {\n            \n            IERC20(tokenAddress).approve(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, uint(2**256 - 1));\n            \n            uint[] memory amounts = uniswap.swapExactTokensForETH(\n              amountIn,\n              amountOutMin,\n              path,\n              address(this),\n              deadline\n            );\n            \n            emit Amounts(amounts);\n            uint sellValue = (amounts[amounts.length - 1]);\n            int profit = int(sellValue - buyValue);\n            emit Profit(profit);\n            require(profit > 0, \"No Profit Made\");\n            block.coinbase.transfer(19 * uint(profit)/20);\n            to.transfer(address(this).balance);\n            \n            \n            \n        }\n  \n  \n  \n  \n  \n  // important to receive ETH\n  receive() payable external {}\n}"
    }
  }
}