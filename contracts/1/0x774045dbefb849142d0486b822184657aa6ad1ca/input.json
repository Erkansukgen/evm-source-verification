{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/kkk.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.6.2 <0.7.0;\r\n\r\nabstract contract Token {\r\n\r\n    function balanceOf(address _owner) public virtual view returns (uint balance) {}\r\n\r\n\r\n    function transfer(address _to, uint _value) public virtual returns (bool success) {}\r\n\r\n   \r\n    function transferFrom(address _from, address _to, uint _value) public virtual returns (bool success) {}\r\n\r\n   \r\n    function approve(address _spender, uint _value) public virtual returns (bool success) {}\r\n\r\n   \r\n    function allowance(address _owner, address _spender) public virtual view returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    \r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n\r\n    function transfer(address _to, uint _value) public override returns (bool) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n   uint constant MAX_UINT = 2**256 - 1;\r\n   \r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public override view returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public override returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public override view returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    \r\n}\r\n\r\ncontract BMCToken is RegularToken {\r\n\r\n    address payable owner;\r\n    uint public totalSupply =  100000000*1e6;\r\n    uint8 constant public decimals = 6;\r\n    string constant public name = \"BMC\";\r\n    string constant public symbol = \"BMC\";\r\n    \r\n    bool open = true;\r\n\r\n    uint until=1e6;\r\n    \r\n    //\r\n    uint totalDestroy = 0;\r\n    uint origExchangedRate = 8888*until;\r\n    uint dayExchange=0;\r\n\r\n    //\r\n    mapping (address => uint) ethBalances;\r\n    \r\n    ///\r\n    address payable project10 = address(0);\r\n    \r\n    ///\r\n    constructor() public {\r\n        owner=msg.sender;\r\n        balances[msg.sender] = totalSupply;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n    \r\n    function destroy() virtual public {\r\n        if (msg.sender == owner) selfdestruct(owner);\r\n    }\r\n\r\n    address betFlags = address(3);\r\n     \r\n    event Received(uint);\r\n    receive() external payable{\r\n        require(open,\"closed by owner\");\r\n\r\n        require(project10 != address(0),\"pleace init project\");\r\n        uint remain=getR();\r\n        project10.transfer(msg.value*10/100);\r\n\r\n        betFlags = address(0);\r\n\r\n        require(dayExchange<(1000000*until),\"one day must change 1000000\");\r\n        uint ethV=(msg.value/1e12);\r\n        emit Received(ethV);\r\n        uint giftBanlce=ethV*remain;\r\n        balances[msg.sender] += giftBanlce;\r\n        balances[owner]-=giftBanlce;\r\n        dayExchange+=giftBanlce;\r\n        emit Transfer(owner, msg.sender, giftBanlce);\r\n    }\r\n    \r\n    function maintain(bool _flag) public {\r\n        require(msg.sender== owner);\r\n        open = _flag;\r\n    }\r\n    \r\n    function bet() public payable returns(bool) {\r\n        uint remain=getR();\r\n        betFlags = address(3);\r\n        uint consume = remain*until*msg.value/1e19; \r\n        emit Received(consume);\r\n        require(balances[msg.sender]>consume,\"no balance BMC\");\r\n        totalDestroy+=consume;\r\n        balances[msg.sender]-=consume;\r\n        emit Transfer(msg.sender,address(3),consume);\r\n    }\r\n    \r\n    // every day invoke\r\n    function resetDay() public {\r\n        require(msg.sender==owner);\r\n        dayExchange = 0;\r\n    }\r\n    \r\n    // dayRemin\r\n    function dayRemin() public view returns (uint){\r\n        return dayExchange;\r\n    }\r\n    \r\n    function getR() public view returns(uint){\r\n        uint remain=(origExchangedRate-(totalDestroy/(400000*until))*10*until)/until;\r\n        return remain;\r\n    }\r\n    \r\n    // withdraw\r\n    function withdraw(address payable _user,uint _amout) public returns (bool) {\r\n        require(msg.sender==owner);\r\n        _user.transfer(_amout);\r\n    }\r\n    \r\n    function projectInit(address payable _project10) public {\r\n        require(msg.sender==owner);\r\n        project10 = _project10;\r\n    }\r\n    \r\n}\r\n"}}}