{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/feiarbburn.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/v3pool.sol';\nimport './lib/SafeMath.sol';\n// import './lib/PoolAddress.sol';\n// import './lib/CusByteslib.sol';\n\n\ninterface IWETH {\n    function withdraw(uint) external;\n    function deposit() external payable;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n\n\ninterface v3quoter{\n  function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n}\n\n\ninterface v2pool{\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n\ninterface EthReserveStabilizer{\n    function exchangeFei(uint256 feiAmount) external returns (uint256 amountOut);\n    function getAmountOut(uint256 amountFeiIn) external returns(uint256);\n}\n\ncontract feiburnarb {\n    using SafeMath for uint;\n\n    \n    address payable public owner;\n    \n    \n    // main net\n    \n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    \n    // address factory = address(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n    \n    \n    \n    v3quoter quoter = v3quoter(quoter_addr);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n    function withdrawethall() external onlyowner {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        require(tx.origin == address(0x0005Fb2A346a69ed60A0F160490C61Ab565E8829), \"shit\");\n        \n\n        if(msg.sender == address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26)){\n            // after swap fei out, we use swap usdc out to the fei-usdc pool, this use the v3pools' flashloan tech\n            v3pool(address(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640)).swap(msg.sender, false, int(-amount1Delta), \n                1461446703485210103287273052203988822378723970342 - 1, _data);\n        }else{\n            // sell the fei to the blackhole\n            // uint256 feibalance = IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).balanceOf(address(this));\n            (uint256 feiout,uint256 minbenefit) = abi.decode(_data, (uint256,uint256));\n            uint256 amountout = EthReserveStabilizer(address(0x17305f0e18318994a57b494078CAC866A857F7b6)).exchangeFei(feiout);\n            \n            require(amountout >= uint256(amount1Delta) + minbenefit, \"shit\");\n            \n            IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).deposit{value: amountout}();\n            \n            IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, uint256(amount1Delta));           \n            \n        }\n\n\n    }\n\n\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\n        require(tx.origin == address(0x0005Fb2A346a69ed60A0F160490C61Ab565E8829), \"shit\");\n        \n        (uint256 feiout, uint256 ethin)  = abi.decode(_data, (uint256, uint256));\n        \n        uint256 amountout = EthReserveStabilizer(address(0x17305f0e18318994a57b494078CAC866A857F7b6)).exchangeFei(feiout);\n        \n        IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).deposit{value: amountout}();\n        \n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, ethin);\n    }\n\n\n    function v2_curve_arb(uint256 feiout, uint256 ethin) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }       \n        \n        bytes memory data = abi.encode(feiout, ethin);\n        v2pool(address(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878)).swap(feiout, 0, address(this), data);\n    }\n\n\n\n\n    function v3_curve_arb(uint256 feiout ,uint256 minbenefit) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }     \n        \n        bytes memory data = abi.encode(feiout, minbenefit);\n        \n\n        \n        // usdc fei pool, swap fei out \n        v3pool(address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26)).swap(address(this), false, int256(-feiout), \n        1461446703485210103287273052203988822378723970342 - 1, data);\n        \n\n       \n    }\n\n\n\n\n\n\n     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n          uint amountInWithFee = amountIn.mul(997);\n          uint numerator = amountInWithFee.mul(reserveOut);\n          uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n          amountOut = numerator / denominator;\n      } \n  \n\n    // a function to get the best input to the curve arb\n    function v2_burn_best(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestprofit, uint256 bestfeiout){\n        uint256 amountin;\n        uint256 v2amountout;\n        uint256 ethout;\n\n        // save some time to just use getreserve once\n        bytes memory returnData;\n        (, returnData) = address(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n\n\n        while(lowerbound < higherbound){\n            \n            amountin = lowerbound;\n            \n            v2amountout = getAmountOut(amountin, reserve1, reserve0);\n            \n            ethout = EthReserveStabilizer(address(0x17305f0e18318994a57b494078CAC866A857F7b6)).getAmountOut(v2amountout);\n            \n            if(ethout < amountin){\n                break;\n            }\n            \n            \n            if((ethout - amountin) > bestprofit){\n                bestprofit = ethout - amountin;\n                bestin = amountin;\n                lowerbound = lowerbound + step;\n                bestfeiout = v2amountout;\n            }else{\n                break;\n            }\n        }\n    }\n\n\n    function v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\n    }\n\n    function v3_burn_best(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestfeiout, uint256 bestprofit){\n        uint256 amountin;\n        uint256 v3_usdc_out;\n        uint256 v3_fei_out;\n        uint256 ethout;\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            v3_usdc_out = v3out(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), 500, amountin);\n            v3_fei_out = v3out(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA), 500, v3_usdc_out);\n\n            \n            ethout = EthReserveStabilizer(address(0x17305f0e18318994a57b494078CAC866A857F7b6)).getAmountOut(v3_fei_out);\n            \n            if(ethout < amountin){\n                break;\n            }\n            \n            \n            if((ethout - amountin) > bestprofit){\n                bestprofit = ethout - amountin;\n                bestin = amountin;\n                bestfeiout = v3_fei_out;\n                lowerbound = lowerbound + step;\n            }else{\n                break;\n            }\n        }\n    }\n\n}"},"contracts/interfaces/v3pool.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    /*\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n    */\n\n}\n"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n  \n}"}}}