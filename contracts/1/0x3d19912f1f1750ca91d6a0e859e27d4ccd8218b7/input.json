{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/burn.sol":{"content":"// pragma solidity 0.6.12;\r\npragma solidity 0.8.10;\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\ninterface IUniswapV2Pair {\r\n    function sync() external;\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface IburnFunc {\r\n    function burn(address account, uint256 amount) external;\r\n    function _burn(address account, uint256 amount) external;\r\n    function burnFrom(address account, uint256 amount) external;\r\n    function _burnFrom(address account, uint256 amount) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function withdraw(uint wad) external;\r\n    function deposit() external payable;\r\n}\r\ncontract burn{\r\n    address payable recipient = payable(0x9b6f240AbD4bA6fE3fb897cF179ce5D8b8bCEb0f);\r\n//pancake\r\n //   address pancakeRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n //   address wBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n//uniswap\r\n    address pancakeRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address wBNB = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    constructor(){\r\n        //own = msg.sender;\r\n    }\r\n\r\n\r\n    function burnToken(address burnToken, address otherToken, address pairAddress,  uint burnType, uint256 burnAmount) public payable {\r\n\r\n        IERC20(burnToken).approve(pancakeRouter,0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        IERC20(otherToken).approve(pancakeRouter,0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n        address[] memory  sell_paths = new address[](2);\r\n        sell_paths[0] = burnToken;\r\n        sell_paths[1] = otherToken;\r\n        \r\n        if (burnType == 0)\r\n        {\r\n            IburnFunc(burnToken).burn(pairAddress, burnAmount);\r\n        }\r\n        else if (burnType == 1)\r\n        {\r\n            IburnFunc(burnToken)._burn(pairAddress, burnAmount);\r\n        }\r\n        else if (burnType == 2)\r\n        {\r\n            IburnFunc(burnToken).burnFrom(pairAddress, burnAmount);\r\n        }\r\n        else if (burnType == 3)\r\n        {\r\n            IburnFunc(burnToken)._burnFrom(pairAddress, burnAmount);\r\n        }\r\n\r\n        IUniswapV2Pair(pairAddress).sync();\r\n        IUniswapV2Router02(pancakeRouter).swapExactTokensForTokens(\r\n            IERC20(burnToken).balanceOf(address(this)),\r\n            0, sell_paths,  recipient,  block.timestamp);\r\n        \r\n        IERC20(otherToken).transfer(recipient,IERC20(otherToken).balanceOf(address(this)));\r\n    }\r\n\r\n    function buyAndBurn(address burnToken, address otherToken, address pairAddress,  uint burnType, uint256 burnAmount, uint256 buyAmount) public payable {\r\n\r\n        //require(msg.value == buyAmount);\r\n        \r\n        if(otherToken == wBNB && msg.value > 0)\r\n        {\r\n            require(msg.value > 0, \"require buyAmount\");\r\n            IERC20(wBNB).deposit{value:msg.value}();\r\n        }\r\n\r\n        IERC20(burnToken).approve(pancakeRouter,0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        IERC20(otherToken).approve(pancakeRouter,0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n        address[] memory  buy_paths = new address[](2);\r\n        buy_paths[0] = otherToken;\r\n        buy_paths[1] = burnToken;\r\n\r\n        address[] memory  sell_paths = new address[](2);\r\n        sell_paths[0] = burnToken;\r\n        sell_paths[1] = otherToken;\r\n        \r\n\r\n        IUniswapV2Router02(pancakeRouter).swapExactTokensForTokens(buyAmount,0,buy_paths,address(this),block.timestamp);\r\n\r\n        if (burnType == 0)\r\n        {\r\n            IburnFunc(burnToken).burn(pairAddress, burnAmount);\r\n        }\r\n        else if (burnType == 1)\r\n        {\r\n            IburnFunc(burnToken)._burn(pairAddress, burnAmount);\r\n        }\r\n        else if (burnType == 2)\r\n        {\r\n            IburnFunc(burnToken).burnFrom(pairAddress, burnAmount);\r\n        }\r\n        else if (burnType == 3)\r\n        {\r\n            IburnFunc(burnToken)._burnFrom(pairAddress, burnAmount);\r\n        }\r\n\r\n        IUniswapV2Pair(pairAddress).sync();\r\n        IUniswapV2Router02(pancakeRouter).swapExactTokensForTokens(\r\n            IERC20(burnToken).balanceOf(address(this)),\r\n            0, sell_paths,  recipient,  block.timestamp);\r\n        \r\n        IERC20(otherToken).transfer(recipient,IERC20(otherToken).balanceOf(address(this)));\r\n    }\r\n\r\n    function withdrawBalance() external{\r\n        recipient.transfer(address(this).balance);\r\n    }\r\n    function withdrawToken(address token) external{\r\n        IERC20(token).transfer(recipient,IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n}"}}}