{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"
    },
    "localhost/Context.sol": {
      "content": "// File: @openzeppelin/contracts/GSN/Context.sol\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "localhost/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}"
    },
    "localhost/IERC20.sol": {
      "content": "\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function mint(address account, uint amount) external;\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "localhost/Math.sol": {
      "content": "// File: @openzeppelin/contracts/math/Math.sol\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "localhost/Ownable.sol": {
      "content": "\n// File: @openzeppelin/contracts/ownership/Ownable.sol\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "localhost/RacePool.sol": {
      "content": "\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./Ownable.sol\";\nimport \"./Address.sol\";\nimport \"./IERC20.sol\";\nimport \"./Math.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./EnumerableSet.sol\";\n\ninterface DaoContract {\n    function addDaoReward(uint256 amount) external;\n}\n\ncontract RacePool is ReentrancyGuard, Ownable {\n    event TransferTo(address to, uint256 amount);\n    event AddPoolAmount(address indexed account, uint256 amount);\n    event Bet(uint256 _tID, address indexed account, uint256 _id, Result _r, uint256 _amount);\n    event StartRaceReward(uint256 _tID, uint256 _id, Result _r, bool _start);\n    event ClaimRaceReward(\n        uint256 _tID, address indexed account, uint256 _id, Result _r, uint256 _amount);\n    event ClaimBanker(address indexed account, uint256 blockNum, uint256);\n    event TransferDao(address _dao, uint256 _amount);\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    \n    \n    IERC20 public rewardToken;\n    uint256 public typeID;\n    uint256 public useRate = 2000;\n    uint256 public baseRate = 10000;\n    uint256 multi = 1e18;\n    uint256 public currRaceNum;\n    uint256 public bankerID;\n    uint256 public lockTime = 7 days;\n    uint256 public useTime;\n    uint256 public minTime;\n    uint256 public userMaxBetAmount;\n    uint256 public haveRewardNum;\n    bool public isBankerTx = true;\n    bool public bankerCanTx = true;\n\n    enum Result {\n        NONE,\n        WIN,\n        EQUA,\n        LOSE,\n        CANCEL\n    }\n\n    mapping(uint256 => TypeInfo) public typeInfo;\n    mapping(uint256 => TypeUse) public typeUse;\n    mapping(string => uint256) public typeNameID;\n    mapping(uint256 => uint256) public raceID;\n    struct TypeInfo{\n        string typeName;\n        uint256 capRate;\n        uint256 daoRate;\n        uint256 feeRate;\n        uint256 haveEnd;\n        uint256 lastRaceEndTime;\n    }\n    \n    struct TypeUse {\n        uint256 createTime;\n        uint256 setEndTime;\n        bool canTx;\n    }\n\n    PoolInfo public poolInfo;\n    struct PoolInfo {\n        uint256 totalRewards;\n        uint256 rewards;\n        uint256 maxTakeAmount;\n        uint256 claim;\n        uint256 lastClaim;\n    }\n    \n    mapping (uint256 => uint256) public ballNum;\n    //tid => name => id\n    mapping(uint256 => mapping(string => uint256)) public nameToID;\n    // tid => id => name\n    mapping(uint256 => mapping(uint256 => string)) public IDToName;\n    mapping(uint256 => mapping(uint256 => RaceInfo)) public raceInfo;\n    struct RaceInfo {\n        Result result;\n        uint256 teamA;\n        uint256 teamB;\n        uint256 teamL;\n        uint256 rateA;\n        uint256 rateB;\n        uint256 rateL;\n        uint256 startTime;\n        bool canTx;\n    }\n    \n    mapping(uint256 => mapping(uint256 => RaceUse)) public raceUse;\n    struct RaceUse {\n        uint256 settlement;\n        uint256 needPay;\n        uint256 havePay;\n        uint256 perAmount;\n        uint256 remainAmount;\n        uint256 reward;\n        uint256 haveReward;\n        uint256 perReward;\n        bool canClaim;\n        bool isEnd;\n    }\n\n    mapping(address => uint256) public bankerAddrID;\n    // bankerAddrID => BankerInfo\n    mapping(uint256 => BankerInfo) public bankerInfo;\n    \n    struct BankerInfo {\n        address banker;\n        uint256 totalAmount;\n        uint256 payAmount;\n        uint256 winAmount;\n        uint256 lastTime;\n        uint256 unLockTime;\n        uint256 addNum;\n    }\n\n    // banker => raceID => BankerRace\n    mapping(address => mapping(uint256 => mapping(uint256 => BankerRace))) public bankerRace;\n    struct BankerRace {\n        uint256 payAmount;\n        uint256 winAmount;\n        uint256 feeAmount;\n        uint256 num;\n        bool isOK;\n    }\n\n    // num => BankerTime\n    mapping(address => mapping(uint256 => BankerTime)) public addInfo;\n    struct BankerTime {\n        uint256 amount;\n        uint256 time;\n        uint256 blockNum;\n        uint256 currNum;\n    }\n\n    mapping(uint256 => mapping(address => mapping(uint256 => UserInfo))) public userInfo;\n    struct UserInfo {\n        uint256 haveRecive;\n        uint256 betAmount;\n        uint256 lastBetTime;\n        uint256 betNum;\n    }\n\n    mapping(uint256 => mapping(address => mapping(uint256 => mapping(uint256 => UserBet)))) public userBet;\n    struct UserBet{\n        uint256 betAmount;\n        uint256 betTeam;\n        uint256 betTime;\n        uint256 teamRate;\n    }    \n\n    mapping(uint256 => mapping(address => mapping(uint256 => UserRaceBet))) public userRaceBet;\n    struct UserRaceBet {\n        uint256 betA;\n        uint256 betB;\n        uint256 betL;\n    }\n\n    mapping(uint256 => mapping(uint256 => TakeAmount)) public takeRaceAmount;\n    struct TakeAmount {\n        uint256 takeAmountA;\n        uint256 takeAmountB;\n        uint256 takeAmountL;\n        uint256 maxTakeAmount;\n    }\n\n    Dao public dao;\n    DaoContract public daoAddr;\n    mapping (uint256 => mapping(uint256 => uint256)) public raceDaoReward;\n    struct Dao {\n        uint256 rewardAmount;\n        uint256 bankerAmount;\n        uint256 tranferAmount;\n    }\n\n    mapping(address => bool) public isOperator;\n    mapping(uint256 => mapping(uint256 => bool)) public startReward;\n    mapping(uint256 => EnumerableSet.UintSet) needDeal;\n    mapping(uint256 => mapping(uint256 => bool)) isDeal;\n\n    constructor(\n        IERC20 _token,\n        uint256 _miniTime,\n        uint256 _maxAmount\n    ) \n        public \n    {\n        rewardToken = _token;\n        minTime = _miniTime;\n        useTime = _miniTime;\n        userMaxBetAmount = _maxAmount;\n    }\n\n    modifier raceCanTx(uint256 _tID, uint256 _id) {\n        require(raceInfo[_tID][_id].canTx, \"err43\");\n        _;\n    }\n\n    modifier tIDExist(uint256 _tID) {\n        require(_tID <= typeID && _tID > 0, \"err1\");\n        _;\n    }\n \n    modifier isIdExist(uint256 _tID, uint256 _id) {\n        require(_id > 0 && _id <= raceID[_tID], \"err5\");\n        _;\n    }\n\n    modifier checkRate(uint256 _useRate) {\n        require(_useRate <= baseRate, \"err40\");\n        _;\n    }\n\n    modifier isPermission() {\n        require(isOperator[msg.sender] || msg.sender == owner(), \"err6\");\n        _;\n    }\n\n    modifier checkAmount(uint256 amount) {\n        require(amount > 0, \"err8\");\n        _;\n    }\n\n    // ***********************************************\n    function addOpreator(address newOperator) public onlyOwner {\n        isOperator[newOperator] = true;\n\n    }\n\n    function removeOpreator(address operator) public onlyOwner {\n        isOperator[operator] = false;\n    }\n\n\n    event CreateTypeInfo(string _typeName, uint256 _tID);\n    function createTypeInfo(\n        string memory _typeName, \n        uint256 _capRate\n    ) \n        public \n        isPermission\n        returns(uint256)\n    {\n        uint256 _tID = typeNameID[_typeName];\n         if(_tID == 0){\n            _tID = ++typeID;\n            typeNameID[_typeName] = _tID;\n            typeInfo[_tID].typeName = _typeName;\n            typeInfo[_tID].capRate = _capRate;\n            typeInfo[_tID].daoRate = 3000;\n            typeInfo[_tID].feeRate = 4000;\n            typeUse[_tID].createTime = block.timestamp;\n            typeUse[_tID].canTx = true;\n    \n            emit CreateTypeInfo(_typeName, _tID);             \n         }\n\n        return _tID;\n    }\n\n    function updateCurrRaceNum(uint256 _tID) public {\n        if(typeUse[_tID].setEndTime == 0) {\n            uint256 _num = needDeal[_tID].length();\n            for(uint256 i = 0; i < _num; i++) {\n                uint256 _id = needDeal[_tID].at(i);\n                if(block.timestamp >= raceInfo[_tID][_id].startTime && !startReward[_tID][_id]) {\n                    if(!isDeal[_tID][_id]) {\n                        currRaceNum++;\n                        isDeal[_tID][_id] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    function addFootBallTeamName(uint256 _tID, string[] memory names) \n        public \n        isPermission \n        tIDExist(_tID)\n        returns(uint256 _num)\n    {\n        updateCurrRaceNum(_tID);\n        for(uint256 i = 0; i < names.length; i++) {\n            if(nameToID[_tID][names[i]] == 0) {\n                uint256 _n = ++ballNum[_tID];\n                IDToName[_tID][_n] = names[i];\n                nameToID[_tID][names[i]] = _n;\n                ++_num;\n            }\n        }\n    }\n\n    function setErrName(uint256 _tID, string memory errName, string memory newName) \n        public \n        isPermission \n    {\n        require(nameToID[_tID][errName] != 0, \"err73\");\n        updateCurrRaceNum(_tID);\n        uint256 _id = nameToID[_tID][errName];\n        IDToName[_tID][_id] = newName;\n        nameToID[_tID][newName] = _id;\n    }\n\n    function setRaceInfo(\n        uint256 _tID,\n        uint256 _teamA,\n        uint256 _teamB,\n        uint256 _rateA,\n        uint256 _rateB,\n        uint256 _rateL,\n        uint256 _startTime\n    ) \n        public \n        isPermission \n        returns(uint256)\n    {\n\n        require(_startTime > block.timestamp, \"err7\");   \n        if(typeUse[_tID].setEndTime != 0) {\n            require(typeUse[_tID].setEndTime > block.timestamp, \"err74\");\n        }\n        require(_teamA != _teamB, \"err50\");\n        require(_teamA > 0 && _teamA <= ballNum[_tID], \"err9\");\n        require(_teamB > 0 && _teamB <= ballNum[_tID], \"err10\");\n        require(_rateA > 0 && _rateA <= typeInfo[_tID].capRate, \"err11\");\n        require(_rateB > 0 && _rateB <= typeInfo[_tID].capRate, \"err12\");\n        require(_rateL > 0 && _rateL <= typeInfo[_tID].capRate, \"err13\");\n        updateCurrRaceNum(_tID);\n        uint256 _id = ++raceID[_tID];\n        raceInfo[_tID][_id].result = Result.NONE;\n        raceInfo[_tID][_id].teamA = _teamA;\n        raceInfo[_tID][_id].teamB = _teamB;\n        raceInfo[_tID][_id].rateA = _rateA;\n        raceInfo[_tID][_id].rateB = _rateB;\n        raceInfo[_tID][_id].rateL = _rateL;\n        raceInfo[_tID][_id].startTime = _startTime;\n        raceInfo[_tID][_id].canTx = true;\n        needDeal[_tID].add(_id);\n\n        return _id;\n    }\n\n    function addPoolAmount(uint256 amount, bool _isDeal) \n        public \n        nonReentrant \n        checkAmount(amount)\n    {\n        require(bankerCanTx && isBankerTx, \"err14\");\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        uint256 _id = bankerAddrID[msg.sender];\n        if(_id == 0) {\n            _id = ++bankerID;\n            bankerAddrID[msg.sender] = _id;\n            bankerInfo[_id].banker = msg.sender;    \n        }\n\n        uint256 _num = ++bankerInfo[_id].addNum;\n        if(bankerInfo[_id].lastTime != 0) {\n            require(bankerInfo[_id].lastTime.add(useTime) <= block.timestamp, \"err15\");           \n        }\n\n        bankerInfo[_id].lastTime = block.timestamp;\n        bankerInfo[_id].unLockTime = block.timestamp.add(lockTime);\n        bankerInfo[_id].totalAmount = bankerInfo[_id].totalAmount.add(amount);\n        poolInfo.totalRewards = poolInfo.totalRewards.add(amount);\n\n        BankerTime storage bTime = addInfo[msg.sender][_num];\n        bTime.amount = amount;\n        bTime.time = block.timestamp;\n        bTime.blockNum = block.number;\n        bTime.currNum = currRaceNum;\n        rewardToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit AddPoolAmount(msg.sender, amount);\n    }\n\n\n    function dealTakeAmountL(uint256 _tID, uint256 _id, uint256 _amount) internal {\n        TakeAmount storage tAmount = takeRaceAmount[_tID][_id];\n\n        uint256 _new = \n            raceBet[_tID][_id].betL\n            .add(_amount)\n            .mul(raceInfo[_tID][_id].rateL).div(baseRate);\n        \n        uint256 _total = getAllBet(_tID, _id).add(_amount);\n        if(_new > _total) {\n            _new = _new.sub(_total);\n        } else {\n            _new = 0;\n        }\n\n        tAmount.takeAmountL = _new;\n        uint256 _max = _new;\n\n        uint256 _newA = raceBet[_tID][_id].betA.mul(raceInfo[_tID][_id].rateA).div(baseRate);\n        if(_newA > _total) {\n            _newA = _newA.sub(_total);\n        } else {\n            _newA = 0;\n        }\n        tAmount.takeAmountA = _newA;\n        if(_max < _newA) {\n            _max = _newA;\n        }\n\n        uint256 _newB = raceBet[_tID][_id].betB.mul(raceInfo[_tID][_id].rateB).div(baseRate);\n        if(_newB > _total) {\n            _newB = _newB.sub(_total);\n        } else {\n            _newB = 0;\n        }\n        tAmount.takeAmountB = _newB;\n        if(_max < _newB) {\n            _max = _newB;\n        }\n        \n        poolInfo.maxTakeAmount = poolInfo.maxTakeAmount.add(_max).sub(tAmount.maxTakeAmount);\n        tAmount.maxTakeAmount = _max;\n    }\n    \n\n    function dealTakeAnmountB(uint256 _tID, uint256 _id, uint256 _amount) internal {\n        TakeAmount storage tAmount = takeRaceAmount[_tID][_id];\n\n        uint256 _new = \n            raceBet[_tID][_id].betB\n            .add(_amount)\n            .mul(raceInfo[_tID][_id].rateB).div(baseRate);\n        \n        uint256 _total = getAllBet(_tID, _id).add(_amount);\n        if(_new > _total) {\n            _new = _new.sub(_total);\n        } else {\n            _new = 0;\n        }\n        tAmount.takeAmountB = _new;\n        uint256 _max = _new;\n\n        uint256 _newA = raceBet[_tID][_id].betA.mul(raceInfo[_tID][_id].rateA).div(baseRate);\n        if(_newA > _total) {\n            _newA = _newA.sub(_total);\n        } else {\n            _newA = 0;\n        }\n        tAmount.takeAmountA = _newA;\n        if(_max < _newA) {\n            _max = _newA;\n        }\n\n        uint256 _newL = raceBet[_tID][_id].betL.mul(raceInfo[_tID][_id].rateL).div(baseRate);\n        if(_newL > _total) {\n            _newL = _newL.sub(_total);\n        } else {\n            _newL = 0;\n        }\n        tAmount.takeAmountL = _newL;\n        if(_max < _newL) {\n            _max = _newL;\n        }\n\n        poolInfo.maxTakeAmount = poolInfo.maxTakeAmount.add(_max).sub(tAmount.maxTakeAmount);\n        tAmount.maxTakeAmount = _max;\n    }\n\n    function dealTakeAmountA(uint256 _tID, uint256 _id, uint256 _amount) internal {\n        TakeAmount storage tAmount = takeRaceAmount[_tID][_id];\n\n        uint256 _new = \n            raceBet[_tID][_id].betA\n            .add(_amount)\n            .mul(raceInfo[_tID][_id].rateA).div(baseRate);\n        \n        uint256 _total = getAllBet(_tID, _id).add(_amount);\n        if(_new > _total) {\n            _new = _new.sub(_total);\n        } else {\n            _new = 0;\n        }\n        tAmount.takeAmountA = _new;\n        uint256 _max = _new;\n\n        uint256 _newL = raceBet[_tID][_id].betL.mul(raceInfo[_tID][_id].rateL).div(baseRate);\n        if(_newL > _total) {\n            _newL = _newL.sub(_total);        \n        } else {\n            _newL = 0;\n        }\n        tAmount.takeAmountL = _newL;\n        if(_max < _newL) {\n            _max = _newL;\n        }\n\n\n        uint256 _newB = raceBet[_tID][_id].betB.mul(raceInfo[_tID][_id].rateB).div(baseRate);\n        if(_newB > _total) {\n            _newB = _newB.sub(_total);\n        } else {\n            _newB = 0;\n        }\n        tAmount.takeAmountB = _newB;\n        if(_max < _newB) {\n            _max = _newB;\n        }\n        \n        poolInfo.maxTakeAmount = poolInfo.maxTakeAmount.add(_max).sub(tAmount.maxTakeAmount);\n        tAmount.maxTakeAmount = _max;\n    }\n    \n    function _betInfo(uint256 _tID, uint256 _id, Result _r, uint256 _amount) \n        internal \n        returns(bool) \n    {\n        uint256 _max = takeRaceAmount[_tID][_id].maxTakeAmount;\n        if(_r == Result.WIN) {\n            uint256 _t = _max.mul(useRate).div(baseRate).add(getBetMaxA(_tID, _id));\n            require(_t >= raceBet[_tID][_id].betA.add(_amount), \"err75\");\n            dealTakeAmountA(_tID, _id, _amount);\n        }\n        if(_r == Result.EQUA) {\n            uint256 _t = _max.mul(useRate).div(baseRate).add(getBetMaxL(_tID, _id));\n            require(_t >= raceBet[_tID][_id].betL.add(_amount), \"err76\");\n            dealTakeAmountL(_tID, _id, _amount);\n        } \n        if(_r == Result.LOSE) {\n            uint256 _t = _max.mul(useRate).div(baseRate).add(getBetMaxB(_tID, _id));\n            require(_t >= raceBet[_tID][_id].betB.add(_amount), \"err77\");\n            dealTakeAnmountB(_tID, _id, _amount);\n        }\n\n        return true;\n    }\n    \n    function bet(uint256 _tID, uint256 _id, Result _r, uint256 _amount) \n        public \n        nonReentrant \n        raceCanTx(_tID, _id)\n        checkAmount(_amount)\n    {\n        require(\n            userMaxBetAmount >= userInfo[_tID][msg.sender][_id].betAmount.add(_amount), \n            \"err78\");\n        require(typeUse[_tID].canTx, \"err16\");\n        require(_r != Result.NONE && _r != Result.CANCEL, \"err17\");\n        require(raceInfo[_tID][_id].startTime > block.timestamp, \"err18\");\n    \n        updateCurrRaceNum(_tID);\n        uint256 _bNum = ++userInfo[_tID][msg.sender][_id].betNum;\n        userBet[_tID][msg.sender][_id][_bNum].betAmount =  _amount;\n        userBet[_tID][msg.sender][_id][_bNum].betTime = block.timestamp;\n\n        require(_betInfo(_tID, _id, _r, _amount), \"err97\");\n        _bet(_tID, _id, _r, _amount, _bNum);\n        \n        rewardToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Bet(_tID, msg.sender, _id, _r, _amount);\n    }\n\n    struct RaceBet {\n        uint256 betA;\n        uint256 betB;\n        uint256 betL;\n    }\n    mapping(uint256 => mapping(uint256 => RaceBet)) public raceBet;\n\n    function _bet(uint256 _tID, uint256 _id, Result _r, uint256 _amount, uint256 _bNum) internal {    \n        if(_r == Result.WIN) {\n            userRaceBet[_tID][msg.sender][_id].betA = \n                userRaceBet[_tID][msg.sender][_id].betA.add(_amount);\n            userBet[_tID][msg.sender][_id][_bNum].betTeam = raceInfo[_tID][_id].teamA;\n            userBet[_tID][msg.sender][_id][_bNum].teamRate = raceInfo[_tID][_id].rateA;\n            raceBet[_tID][_id].betA = raceBet[_tID][_id].betA.add(_amount);\n        }   \n        if(_r == Result.EQUA) {\n            userRaceBet[_tID][msg.sender][_id].betL = userRaceBet[_tID][msg.sender][_id].betL.add(_amount);\n            userBet[_tID][msg.sender][_id][_bNum].betTeam = raceInfo[_tID][_id].teamL;\n            userBet[_tID][msg.sender][_id][_bNum].teamRate = raceInfo[_tID][_id].rateL;\n            raceBet[_tID][_id].betL = raceBet[_tID][_id].betL.add(_amount);\n\n        }\n        if(_r == Result.LOSE) {\n            userRaceBet[_tID][msg.sender][_id].betB = userRaceBet[_tID][msg.sender][_id].betB.add(_amount);\n            userBet[_tID][msg.sender][_id][_bNum].betTeam = raceInfo[_tID][_id].teamB;\n            userBet[_tID][msg.sender][_id][_bNum].teamRate = raceInfo[_tID][_id].rateB;\n            raceBet[_tID][_id].betB = raceBet[_tID][_id].betB.add(_amount);\n        }\n\n        userInfo[_tID][msg.sender][_id].betAmount = userInfo[_tID][msg.sender][_id].betAmount.add(_amount);\n        userInfo[_tID][msg.sender][_id].lastBetTime = block.timestamp;\n    }\n\n    function setResult(uint256 _tID, uint256 _id, Result _r) \n        public \n        isPermission\n        isIdExist(_tID, _id)\n    {\n        require(!startReward[_tID][_id], \"err2\");\n        require(_r != Result.NONE, \"err22\");\n        require(block.timestamp > raceInfo[_tID][_id].startTime, \"not start\");\n        updateCurrRaceNum(_tID);\n        raceUse[_tID][_id].isEnd = true;\n        raceInfo[_tID][_id].result = _r;\n\n    }\n\n    function startRaceReward(uint256 _tID, uint256 _id) \n        public \n        nonReentrant\n        isPermission\n    {\n        require(!startReward[_tID][_id] && raceUse[_tID][_id].isEnd, \"err23\");\n        require(haveRewardNum == 0, \"one not settlement\");\n        isBankerTx = false;\n        ++haveRewardNum;\n        updateCurrRaceNum(_tID);\n        startReward[_tID][_id] = true;\n        Result _r = raceInfo[_tID][_id].result;\n        RaceUse storage rUse = raceUse[_tID][_id];\n        uint256 _dRate = typeInfo[_tID].daoRate;\n        rUse.settlement = block.timestamp;\n        if(typeInfo[_tID].lastRaceEndTime < rUse.settlement) {\n            typeInfo[_tID].lastRaceEndTime = rUse.settlement;\n        }\n\n        if(_r == Result.WIN) {\n            if(takeRaceAmount[_tID][_id].takeAmountA > 0) {\n                poolInfo.rewards = poolInfo.rewards.add(takeRaceAmount[_tID][_id].takeAmountA);\n                rUse.needPay = takeRaceAmount[_tID][_id].takeAmountA;\n            } else {\n                rUse.reward = getAllBet(_tID, _id).sub(getRamountA(_tID, _id));\n            }\n        } \n        if(_r == Result.EQUA) {\n            if(takeRaceAmount[_tID][_id].takeAmountL > 0) {\n                poolInfo.rewards = poolInfo.rewards.add(takeRaceAmount[_tID][_id].takeAmountL);\n                rUse.needPay = takeRaceAmount[_tID][_id].takeAmountL;\n            } else {\n                rUse.reward = getAllBet(_tID, _id).sub(getRamountL(_tID, _id));\n            }\n        } \n        if(_r == Result.LOSE) {\n            if(takeRaceAmount[_tID][_id].takeAmountB > 0) {\n                poolInfo.rewards = poolInfo.rewards.add(takeRaceAmount[_tID][_id].takeAmountB);\n                rUse.needPay = takeRaceAmount[_tID][_id].takeAmountB;\n            } else {\n                rUse.reward = getAllBet(_tID, _id).sub(getRamountB(_tID, _id));\n            }\n        }\n        uint256 _total = poolInfo.totalRewards.sub(poolInfo.rewards);\n        if(_total > 0) {\n            if(rUse.needPay > 0) {\n                rUse.perAmount = rUse.needPay.mul(multi).div(_total);    \n            }\n            \n            if(rUse.reward > 0) {\n                uint256 _daoAmount = rUse.reward.mul(_dRate).div(baseRate);\n                dao.rewardAmount = dao.rewardAmount.add(_daoAmount);\n                raceDaoReward[_tID][_id] = _daoAmount;\n                rUse.reward = rUse.reward.sub(_daoAmount);\n                rUse.perReward = rUse.reward.mul(multi).div(_total).add(1);\n                if(address(daoAddr) != address(0)) {\n                    if(_daoAmount > 0) {\n                        _transferDao(address(daoAddr), _daoAmount);\n                    }\n                } \n            }\n            rUse.remainAmount = _total;\n        }\n        poolInfo.claim =  poolInfo.claim.add(rUse.reward);\n        poolInfo.totalRewards = poolInfo.totalRewards.add(rUse.reward);\n\n        poolInfo.lastClaim = rUse.reward;\n\n        poolInfo.maxTakeAmount = \n            poolInfo.maxTakeAmount.sub(takeRaceAmount[_tID][_id].maxTakeAmount);\n        rUse.canClaim = true;\n        typeInfo[_tID].haveEnd = typeInfo[_tID].haveEnd.add(1);\n        if(currRaceNum > 0) {\n            currRaceNum--;\n        }\n        if(needDeal[_tID].contains(_id)) {\n            needDeal[_tID].remove(_id);\n        }\n\n        emit StartRaceReward(_tID, _id, raceInfo[_tID][_id].result, true);\n    }\n    \n\n    function getAllBet(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return \n            raceBet[_tID][_id].betA.add(raceBet[_tID][_id].betB).add(raceBet[_tID][_id].betL);\n    }\n\n    function setBankerInfo(uint256 _tID, uint256 _id, address[] memory _bankers) \n        public\n        nonReentrant\n        isPermission\n    {\n        require(startReward[_tID][_id] == true, \"err25\");\n        updateCurrRaceNum(_tID);\n        Result _r = raceInfo[_tID][_id].result;\n        for(uint256 i = 0; i < _bankers.length; i++) {\n            address _addr = _bankers[i];\n            uint256 _bID = bankerAddrID[_addr];\n            \n            if(!bankerRace[_addr][_tID][_id].isOK) {\n                bankerRace[_addr][_tID][_id].isOK = true;\n                uint256 _amount = bankerInfo[_bID].totalAmount.sub(bankerInfo[_bID].payAmount);\n                uint256 _num = bankerInfo[_bID].addNum;\n                if(_amount > 0) {\n                    _setBankerInfo(_tID, _id, _bID, _num, _amount, _addr, _r);\n                }\n            }\n        }\n    }\n\n    function _setBankerInfo(\n        uint256 _tID,\n        uint256 _id, \n        uint256 _bID, \n        uint256 _num,\n        uint256 _amount,\n        address _addr, \n        Result _r\n    ) internal {\n        RaceUse storage rUse = raceUse[_tID][_id];\n        BankerInfo storage bInfo = bankerInfo[_bID];\n        BankerRace storage bRace = bankerRace[_addr][_tID][_id];\n\n        uint256 _feeRate = typeInfo[_tID].feeRate;\n\n        if(_r != Result.CANCEL && rUse.perAmount > 0 && rUse.needPay > rUse.havePay) {\n            uint256 _use = _amount.mul(rUse.perAmount).div(multi);\n            if(_use > _amount) {\n                _use = _amount;\n            }\n            if(rUse.havePay.add(_use) > rUse.needPay) {\n                _use = rUse.needPay.sub(rUse.havePay);\n            }\n            if(rUse.needPay.sub(rUse.havePay).sub(_use) >= 1 && \n                bInfo.totalAmount.sub(bInfo.payAmount) >= _use.add(1)) \n            {\n                _use = _use.add(1);\n            }\n            rUse.havePay = rUse.havePay.add(_use);\n            bInfo.payAmount = bInfo.payAmount.add(_use);                    \n            bRace.payAmount = bRace.payAmount.add(_use);\n        } else {\n            uint256 _use = rUse.perReward.mul(_amount).div(multi);\n            if(rUse.haveReward.add(_use) > rUse.reward) {\n                _use = rUse.reward.sub(rUse.haveReward);\n            }\n\n            if(addInfo[_addr][_num].currNum > 0 \n                && addInfo[_addr][_num].time >= raceInfo[_tID][_id].startTime\n                && addInfo[_addr][_num].time <= rUse.settlement) \n            {\n                uint256 _fee = _use.mul(_feeRate).div(baseRate);\n                dao.bankerAmount = dao.bankerAmount.add(_fee);\n                //_use = _use.sub(_fee);\n                bRace.feeAmount = _fee;\n                poolInfo.totalRewards = poolInfo.totalRewards.sub(_fee);\n                if(address(daoAddr) != address(0)) {\n                    if(_fee > 0) {\n                        _transferDao(address(daoAddr), _fee);\n                    }\n                }\n            }\n            if(rUse.reward.sub(rUse.haveReward).sub(_use) >= 1) {\n                _use = _use.add((1));\n            }\n            rUse.haveReward = rUse.haveReward.add(_use);\n            bInfo.winAmount = bInfo.winAmount.add(_use).sub(bRace.feeAmount);\n            bInfo.totalAmount = bInfo.totalAmount.add(_use).sub(bRace.feeAmount);\n            \n            bRace.num = _num;\n            bRace.winAmount = bRace.winAmount.add(_use).sub(bRace.feeAmount);\n        }\n    }\n\n\n    function claimRaceReward(uint256 _tID, uint256 _id) \n        public \n        nonReentrant \n        raceCanTx(_tID, _id)\n    {\n        require(typeUse[_tID].canTx, \"err42\");\n        require(startReward[_tID][_id] == true, \"err26\");\n        require(raceUse[_tID][_id].canClaim, \"err27\");\n        updateCurrRaceNum(_tID);\n        Result _r = raceInfo[_tID][_id].result;\n        UserInfo storage user = userInfo[_tID][msg.sender][_id];\n        require(user.betAmount > 0, \"err28\");\n        require(user.haveRecive == 0, \"err29\");\n        if(_r == Result.CANCEL) {\n            user.haveRecive = user.haveRecive.add(user.betAmount);\n            rewardToken.safeTransfer(msg.sender, user.betAmount);\n            emit ClaimRaceReward(_tID, msg.sender, _id, _r, user.betAmount);\n        } else {\n            uint256 _reward = getReward(_tID, msg.sender, _id, _r);\n            if(_reward > 0) {\n                user.haveRecive = user.haveRecive.add(_reward);\n                rewardToken.safeTransfer(msg.sender, _reward);\n                emit ClaimRaceReward(_tID, msg.sender, _id, _r, _reward);\n            }\n        }\n    }\n\n    function claimBanker(uint256 _amount, bool _isDeal) \n        public \n        nonReentrant \n        checkAmount(_amount)\n    {\n        require(bankerCanTx && isBankerTx, \"err30\");\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        uint256 _bid = bankerAddrID[msg.sender];\n        require(_bid != 0, \"err31\");\n        BankerInfo storage bInfo = bankerInfo[_bid];\n        require(bInfo.totalAmount.sub(bInfo.payAmount) >= _amount, \"err32\");\n        require(bInfo.unLockTime < block.timestamp, \"not unLockTime\");\n\n        bInfo.totalAmount = bInfo.totalAmount.sub(_amount);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(_amount);\n        rewardToken.safeTransfer(msg.sender, _amount);\n        emit ClaimBanker(msg.sender, block.number, _amount);\n        \n    }\n\n\n    function updateCurrNum() public {\n        for(uint256 i = 1; i <= typeID; i++) {\n            updateCurrRaceNum(i);\n        }\n    }\n\n    function transferDao(address _dao, uint256 _amount, bool _isDeal) \n        public  \n        isPermission \n        checkAmount(_amount)\n    {\n        require(\n            dao.rewardAmount.add(dao.bankerAmount).sub(dao.tranferAmount) >= _amount,\"err33\"\n        );\n        require(address(_dao) != address(0), \"err34\");\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        if(address(daoAddr) == _dao) {\n            daoAddr.addDaoReward(_amount);\n        } \n        dao.tranferAmount = dao.tranferAmount.add(_amount);\n        rewardToken.safeTransfer(_dao, _amount);\n        emit TransferDao(_dao, _amount);\n    }\n\n    function _transferDao(address _dao, uint256 _amount) internal {\n        dao.tranferAmount = dao.tranferAmount.add(_amount);\n        daoAddr.addDaoReward(_amount);\n        rewardToken.safeTransfer(_dao, _amount);\n        emit TransferDao(_dao, _amount);\n    }\n\n    function getReward(uint256 _tID, address account, uint256 _id, Result _r) \n        public \n        view \n        returns(uint256) \n    {\n        if(_r == Result.WIN) {\n            return userRaceBet[_tID][account][_id].betA\n                .mul(raceInfo[_tID][_id].rateA).div(baseRate);\n        } \n        if(_r == Result.EQUA) {\n            return userRaceBet[_tID][account][_id].betL\n                .mul(raceInfo[_tID][_id].rateL).div(baseRate);\n        }  \n        if(_r == Result.LOSE){\n            return userRaceBet[_tID][account][_id].betB\n                .mul(raceInfo[_tID][_id].rateB).div(baseRate);\n        }  \n        if(_r == Result.CANCEL) {\n            return userInfo[_tID][account][_id].betAmount;\n        }\n        return 0;\n    }\n\n    function getPoolUseAmount() public view returns(uint256) {\n        return \n            poolInfo.totalRewards\n            .sub(poolInfo.maxTakeAmount)\n            .sub(poolInfo.rewards);\n    }\n\n    function getPoolAmount() public view returns(uint256) {\n        return \n            (poolInfo.totalRewards\n            .sub(poolInfo.maxTakeAmount)\n            .sub(poolInfo.rewards))\n            .mul(useRate).div(baseRate);\n    }\n\n\n    function getPayA(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return getAllBet(_tID, _id).add(getPoolAmount());\n    }\n\n    function getPayB(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return getAllBet(_tID, _id).add(getPoolAmount());\n    }\n\n    function getPayL(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return getAllBet(_tID, _id).add(getPoolAmount());\n    }\n\n    function getBetMaxA(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return getPayA(_tID, _id).mul(baseRate).div(raceInfo[_tID][_id].rateA);\n    }\n\n    function getBetMaxB(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return getPayB(_tID, _id).mul(baseRate).div(raceInfo[_tID][_id].rateB);\n    }\n\n    function getBetMaxL(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return getPayL(_tID, _id).mul(baseRate).div(raceInfo[_tID][_id].rateL);\n    }\n\n    function getRamountA(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return raceBet[_tID][_id].betA.mul(raceInfo[_tID][_id].rateA).div(baseRate);\n    }\n\n    function getRamountB(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return raceBet[_tID][_id].betB.mul(raceInfo[_tID][_id].rateB).div(baseRate);\n    }\n\n    function getRamountL(uint256 _tID, uint256 _id) public view returns(uint256) {\n        return raceBet[_tID][_id].betL.mul(raceInfo[_tID][_id].rateL).div(baseRate);\n    }\n\n    \n    function getCurrTime() public view returns(uint256) {\n        return block.timestamp;\n    }\n    \n    function getBlockNum() public view returns(uint256) {\n        return block.number;\n    }\n\n\n    // ***************************************************************************\n    function setUserClaim(uint256 _tID, uint256 _id, bool _claim) \n        public\n        isPermission\n    {\n        require(startReward[_tID][_id], \"err3\");\n        updateCurrRaceNum(_tID);\n        raceUse[_tID][_id].canClaim = _claim;\n    }\n\n    function transferTo(IERC20 token, address to, uint256 amount, bool _isDeal) public onlyOwner {\n        require(to != address(0), \"err36\");\n        //require(token.balanceOf(address(this)) >= amount, \"err37\");\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        token.safeTransfer(to, amount);\n\n        emit TransferTo(to, amount);\n    }\n\n    function setTypeEnd(uint256 _tID, uint256 _endTime) public isPermission {\n        updateCurrRaceNum(_tID);\n        require(typeInfo[_tID].haveEnd == raceID[_tID], \"err38\");\n        require(typeInfo[_tID].lastRaceEndTime <= _endTime, \"err39\");\n        typeUse[_tID].setEndTime = _endTime;\n    }\n\n\n    function setUseRate(uint256 _useRate, bool _isDeal) \n        public \n        isPermission \n        checkRate(_useRate)\n    {\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        useRate = _useRate;\n    }\n\n    function setUseTime(uint256 _time, bool _isDeal) public isPermission {\n        require(_time >= minTime, \"err41\");\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        useTime = _time;\n    }\n\n    function setLockTime(uint256 _time, bool _isDeal) public isPermission {\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        lockTime = _time;\n    }\n\n    function setDaoRate(uint256 _tID, uint256 _daoRate) \n        public \n        isPermission \n        tIDExist(_tID) \n        checkRate(_daoRate)\n    {\n        updateCurrRaceNum(_tID);\n        typeInfo[_tID].daoRate = _daoRate;\n    }\n\n    function setFeeRate(uint256 _tID, uint256 _feeRate) \n        public \n        isPermission \n        tIDExist(_tID) \n        checkRate(_feeRate)\n    {\n        updateCurrRaceNum(_tID);\n        typeInfo[_tID].feeRate = _feeRate;\n    }\n\n\n    function setCanTx(uint256 _tID, bool _isTx) \n        public \n        isPermission \n        tIDExist(_tID)\n    {\n        updateCurrRaceNum(_tID);\n        typeUse[_tID].canTx = _isTx;\n    }\n\n\n    function setRaceCanTx(uint256 _tID, uint256 _id, bool _isTx) \n        public \n        isPermission \n        isIdExist(_tID, _id)\n    {\n        updateCurrRaceNum(_tID);\n        raceInfo[_tID][_id].canTx = _isTx;\n    }\n  \n    function setBankerCanTx(bool _isTx, bool _isDeal) public isPermission{\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        bankerCanTx = _isTx;\n    }\n\n    function setIsBankerTx(bool _isDeal) public isPermission{\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        if(haveRewardNum > 1) {\n            haveRewardNum--;\n        } else {\n            isBankerTx = true;\n            haveRewardNum = 0;\n        }\n    }\n\n    function setDaoContract(DaoContract _dao, bool _isDeal) public isPermission {\n        if(_isDeal) {\n            updateCurrNum();   \n        }\n        daoAddr = _dao;\n    }\n\n    function setUserMaxBetAmount(uint256 _newMax) public isPermission {\n        userMaxBetAmount = _newMax;\n    }\n\n}"
    },
    "localhost/ReentrancyGuard.sol": {
      "content": "\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool public _notEntered;\n\n    constructor () internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}"
    },
    "localhost/SafeERC20.sol": {
      "content": "\n//SPDX-License-Identifier: UNLICENSED\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n\npragma solidity ^0.6.0;\n\nimport \"./SafeMath.sol\";\nimport \"./IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n"
    },
    "localhost/SafeMath.sol": {
      "content": "// File: @openzeppelin/contracts/math/SafeMath.sol\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  }
}