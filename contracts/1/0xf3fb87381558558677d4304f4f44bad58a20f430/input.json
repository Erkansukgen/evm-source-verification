{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/redeemer.sol":{"content":"pragma solidity 0.7.1;\n// SPDX-License-Identifier: MIT\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IESDS {\n    function deposit(uint256) external;\n    function balanceOfStaged(address) external view returns (uint256);\n    function bond(uint256) external;\n    function balanceOfBonded(address) external view returns (uint256);\n    function unbondUnderlying(uint256) external;\n    function withdraw(uint256) external; // \"unstage\"\n    function advance() external;\n    function epoch() external view returns (uint256);\n    function epochTime() external view returns (uint256);\n    function totalRedeemable() external view returns (uint256);\n}\n\ninterface ICHI {\n    function freeFromUpTo(address _addr, uint256 _amount) external returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ninterface ICouponClipper {\n    function getOffer(address _user) external view returns (uint256);\n    function redeem(address _user, uint256 _epoch, uint256 _couponAmount) external;\n}\n\n\n// @notice Example code for use by bot runners\n// @dev The `advanceAndRedeemMany` function allows you to attempt to redeem several sets of coupons\n//    in a single tx.\n//    It will call \"advance\" first, if needed.\n//    It will do partial fills if/when totalRedeemable is less than the number of coupons you're trying to redeem.\n//    It will continue execution if one attempt fails (using try/catch).\n//    It will free gas tokens (assuming you have some in your account and have approved this contract to spend them).\n// @dev You should test this code with low-value transactions first to make sure it behaves the way you think it does.\n//    This is unaudited code, so please exercise prudence.\ncontract ExampleRedeemer is Ownable {\n    \n    using SafeMath for uint256;\n    \n    // external contracts and addresses\n    address constant private esd = 0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723;\n    IESDS constant private esds = IESDS(0x443D2f2755DB5942601fa062Cc248aAA153313D3);\n    ICHI  constant private chi = ICHI(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n    ICouponClipper constant private couponClipper = ICouponClipper(0xb4027EEEa4b2D91616c63Dc3E37075E69f36b457);\n    \n    // frees CHI to reduce gas costs\n    // requires that msg.sender has approved this contract to spend its CHI\n    modifier useCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + (16 * msg.data.length);\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n    }\n    \n    fallback() external payable {}\n    receive() external payable {}\n    \n    constructor() {\n        // approve ESDS contract to move ESD (needed to stage and bond)\n        // (Not needed to redeem coupons but is nice to have if you want to use this contract as an ESD wallet)\n        IERC20(esd).approve(address(esds), uint256(uint128(-1)));\n    }\n    \n    // @notice Call this function with the bot. Use a high gas price.\n    // @param _targetEpoch the future epoch we are trying to advance to.\n    // @param _users Array of users whose copouns you're trying to redeem\n    // @param _epochs Array of epochs at which the users' coupons were purchased\n    // @param _couponAmounts The amounts of the users' coupons you're trying to redeem.\n    // @dev Consider using a gas limit of `700_000 + (N * 300_000)`  where `N` is the length of the `_users` array.\n    //    This may be overkill, but out-of-gas errors can really hurt, so best to avoid them.\n\n    event Deposit(address indexed _from, uint256 indexed _epoch, uint256 _value);\n\n    function redeemdata(address[] calldata _users, uint256[] calldata  _epochs, uint256[] calldata _couponAmounts) external onlyOwner{\n        for (uint256 i; i < _users.length; i++) {\n            emit Deposit(_users[i], _epochs[i], _couponAmounts[i]);\n        }\n\n    }\n\n    function advanceAndRedeemMany(uint16 _targetEpoch, address[] calldata _users, uint256[] calldata  _epochs, uint256[] calldata _couponAmounts) external useCHI onlyOwner {\n        \n        // Abort if this tx is mined too early (extreamly cheap)\n        uint256 epochStartTime = getEpochStartTime(_targetEpoch);\n        if (block.timestamp < epochStartTime) {\n            // We ended up in the wrong block. The new epoch hasn't started yet.\n            return;\n        }\n        \n        // If ESDS.advance() has NOT already been called and advanced to the target epoch then we'll advance\n        if (esds.epoch() != _targetEpoch) {\n            // Then we can advance the epoch \n            // Try to call the ESDS.advance() function, but use try/catch so we can use gas tokens\n            // in the case that the call fails (for example, if we passed in an incorrect `_targetEpoch` value\n            try esds.advance() {\n                // Success! We advanced the epoch.\n            } catch {\n                // Failure! Someone else advanced the epoch before us.\n            }\n        }\n        \n        // Now we know the epoch has been advanced (whether or not we advanced it), so we attempt to redeem coupons\n        _redeemManyOpportunities(_users, _epochs, _couponAmounts);\n        \n        return;\n    }\n    \n    function _redeemManyOpportunities(address[] calldata _users, uint256[] calldata  _epochs, uint256[] calldata _couponAmounts) internal {\n        uint256 amountRedeemable = esds.totalRedeemable();\n        bool success;\n        uint256 amountToRedeem;\n        \n        for (uint256 i; i < _users.length; i++) {\n\n            // redemption validity check\n            if (amountRedeemable == 0) { break; }\n            \n            // redeem coupons\n            amountToRedeem = _couponAmounts[i] < amountRedeemable ? _couponAmounts[i] : amountRedeemable;\n            success = _redeemOpportunity(_users[i], _epochs[i], amountToRedeem);\n            \n            // update amountRedeemable\n            amountRedeemable = success ? amountRedeemable - amountToRedeem : amountRedeemable;\n        }\n    }\n    \n\n    function _redeemOpportunity(address _user, uint256 _epoch, uint256 _couponAmount) internal returns (bool) {\n        try couponClipper.redeem(_user, _epoch, _couponAmount) {\n            // Success!\n            return true;\n        } catch {\n            // Failure!\n            return false;\n        }\n    }\n    \n    // @notice Returns the timestamp at which the _targetEpoch starts\n    function getEpochStartTime(uint256 _targetEpoch) public pure returns (uint256) {\n        return _targetEpoch.sub(106).mul(28800).add(1602201600);\n    }\n    \n    // BASIC WALLET FUNCTIONS\n    \n    function withdrawETH() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n    \n    function withdrawERC20(address _token) external onlyOwner {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).transfer(owner(), balance);\n    }\n    \n    // Used for approving the Uniswap V2 router to move this contract's ESD tokens\n    // e.g. _token = ESD, _spender = UniswapV2Router02, _amount = uint128(-1)\n    function ERC20Approve(address _token, address _spender, uint256 _amount) external onlyOwner {\n        IERC20(_token).approve(_spender, _amount);\n    }\n    \n    // ESD/ESDS WALLET FUNCTIONS \n    \n    // stage (aka \"deposit\") ESD \n    function deposit(uint256 _amountOfESD) external onlyOwner {\n        esds.deposit(_amountOfESD);\n    }\n    \n    // bond ESD (to get ESDS)\n    // @param _amountOfESD The amount of ESD you want to bond.\n    function bond(uint256 _amountOfESD) external onlyOwner {\n        esds.bond(_amountOfESD);\n    }\n    \n    // stage (aka \"deposit\") and then bond in a single tx to save gas\n    function depositAndBond(uint256 _amountOfESD) external onlyOwner {\n        esds.deposit(_amountOfESD);\n        esds.bond(_amountOfESD);\n    }\n    \n    // unbond ESDS (to get ESD)\n    // @param _amountOfESD The amount of ESD you want to get out! (NOT the amount of ESDS you want to unbond)\n    function unbond(uint256 _amountOfESD) external onlyOwner {\n        esds.unbondUnderlying(_amountOfESD);\n    }\n    \n    // \"unstage\" (aka \"withdraw\") ESD (so it can be sold, transferred out, etc)\n    function unstage(uint256 _amountOfESD) external onlyOwner {\n        esds.withdraw(_amountOfESD);\n    }\n    \n    // view ESD balance (amount that can be sold, transferred, etc rn)\n    function getBalanceOf() external view returns (uint256) {\n        return IERC20(esd).balanceOf(address(this));\n    }\n    \n    // view balanceOfStaged (amount that is staged)\n    function getBalanceOfStaged() external view returns (uint256) {\n        return esds.balanceOfStaged(address(this));   \n    }\n    \n    // get balanceOfBonded (amount of bonded ESD)\n    // @returns uint256 The amount of ESD bonded (NOT ESDS!!!)\n    function getBalanceOfBonded() external view returns (uint256) {\n        return esds.balanceOfBonded(address(this));\n    }\n    \n}\n\n\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n"}}}