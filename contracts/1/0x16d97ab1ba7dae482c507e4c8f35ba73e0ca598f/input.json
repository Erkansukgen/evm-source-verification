{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/adoreCoin.sol": {
      "content": "pragma solidity ^0.7.0;\n\ncontract AdoreFinanceToken {\n    // only people with tokens\n    modifier onlyBagholders() {\n        require(myTokens() > 0);\n        _;\n    }\n    modifier onlyAdministrator(){\n        address _customerAddress = msg.sender;\n        require(administrators[_customerAddress]);\n        _;\n    }\n    /*==============================\n    =            EVENTS            =\n    ==============================*/\n\n    event Reward(\n       address indexed to,\n       uint256 rewardAmount,\n       uint256 level\n    );\n    event RewardWithdraw(\n       address indexed from,\n       uint256 rewardAmount\n    );\n    // ERC20\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 tokens\n    );\n   \n    /*=====================================\n    =            CONFIGURABLES            =\n    =====================================*/\n    string public name = \"Adore Finance Token\";\n    string public symbol = \"XFA\";\n    uint8 constant public decimals = 0;\n    uint256 public totalSupply_ = 2000000;\n    uint256 constant internal tokenPriceInitial_ = 0.00012 ether;\n    uint256 constant internal tokenPriceIncremental_ = 25000000;\n    uint256 public currentPrice_ = tokenPriceInitial_ + tokenPriceIncremental_;\n    uint256 public base = 1;\n    uint256 public basePrice = 400;\n    uint public percent = 500;\n    uint public referralPercent = 1000;\n    uint public sellPercent = 1500;\n    mapping(address => uint256) internal tokenBalanceLedger_;\n    mapping(address => uint256) internal rewardBalanceLedger_;\n    address commissionHolder;\n    uint256 internal tokenSupply_ = 0;\n    mapping(address => bool) internal administrators;\n    mapping(address => address) public genTree;\n    mapping(address => uint256) public level1Holding_;\n    address payable internal creator;\n    address payable internal management; //for management funds\n    address internal poolFund;\n    uint8[] percent_ = [7,2,1];\n    uint8[] adminPercent_ = [37,37,16,10];\n    address dev1;\n    address dev2;\n    address dev3;\n    address dev4;\n   \n    constructor()\n    {\n        creator = msg.sender;\n        administrators[creator] = true;\n    }\n    \n    function isContract(address account) public view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n   \n    function withdrawRewards(address payable _customerAddress, uint256 _amount) onlyAdministrator() public returns(uint256)\n    {\n        require(rewardBalanceLedger_[_customerAddress]>_amount && _amount > 3000000000000000);\n        rewardBalanceLedger_[commissionHolder] += 3000000000000000;\n        rewardBalanceLedger_[_customerAddress] -= _amount;\n        emit RewardWithdraw(_customerAddress,_amount);\n        _amount = SafeMath.sub(_amount, 3000000000000000);\n        _customerAddress.transfer(_amount);\n    }\n\n    function setDevs(address _dev1, address _dev2, address _dev3, address _dev4) onlyAdministrator() public{\n        dev1 = _dev1;\n        dev2 = _dev2;\n        dev3 = _dev3;\n        dev4 = _dev4;\n    }\n    function distributeCommission() onlyAdministrator() public returns(bool)\n    {\n        require(rewardBalanceLedger_[management]>100000000000000);\n        rewardBalanceLedger_[dev1] += (rewardBalanceLedger_[management]*3700)/10000;\n        rewardBalanceLedger_[dev2] += (rewardBalanceLedger_[management]*3700)/10000;\n        rewardBalanceLedger_[dev3] += (rewardBalanceLedger_[management]*1600)/10000;\n        rewardBalanceLedger_[dev4] += (rewardBalanceLedger_[management]*1000)/10000;\n        rewardBalanceLedger_[management] = 0;\n        return true;\n    }\n    \n    function withdrawRewards(uint256 _amount) onlyAdministrator() public returns(uint256)\n    {\n        address payable _customerAddress = msg.sender;\n        require(rewardBalanceLedger_[_customerAddress]>_amount && _amount > 3000000000000000);\n        rewardBalanceLedger_[_customerAddress] -= _amount;\n        rewardBalanceLedger_[commissionHolder] += 3000000000000000;\n        _amount = SafeMath.sub(_amount, 3000000000000000);\n        _customerAddress.transfer(_amount);\n    }\n    \n    function useManagementFunds(uint256 _amount) onlyAdministrator() public returns(uint256)\n    {\n        require(rewardBalanceLedger_[management]>_amount && _amount > 4000000000000000);\n        rewardBalanceLedger_[commissionHolder] += 3000000000000000;\n        rewardBalanceLedger_[management] -= _amount;\n        _amount = _amount - 3000000000000000;\n        management.transfer(_amount);\n    }\n   \n    function distributeRewards(uint256 _amountToDistribute, address _idToDistribute)\n    internal\n    {\n        uint256 _tempAmountToDistribute = _amountToDistribute;\n        for(uint i=0; i<3; i++)\n        {\n            address referrer = genTree[_idToDistribute];\n            if(referrer != address(0x0) && level1Holding_[referrer] > i && i>0)\n            {\n                rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[i])/10;\n                _idToDistribute = referrer;\n                emit Reward(referrer,(_amountToDistribute*percent_[i])/10,i);\n                _tempAmountToDistribute -= (_amountToDistribute*percent_[i])/10;\n            }\n            else if(i == 0)\n            {\n                 rewardBalanceLedger_[referrer] += (_amountToDistribute*percent_[i])/10;\n                _idToDistribute = referrer;\n                emit Reward(referrer,(_amountToDistribute*percent_[i])/10,i);\n                _tempAmountToDistribute -= (_amountToDistribute*percent_[i])/10;\n            }\n            else\n            {\n                \n            }\n        }\n        rewardBalanceLedger_[commissionHolder] += _tempAmountToDistribute;\n    }\n   \n   function setBasePrice(uint256 _price)\n    onlyAdministrator()\n    public\n    returns(bool) {\n        basePrice = _price;\n    }\n   \n    function buy(address _referredBy)\n        public\n        payable\n        returns(uint256)\n    {\n        require(!isContract(msg.sender),\"Buy from contract is not allowed\");\n        require(_referredBy != msg.sender,\"Self Referral Not Allowed\");\n        if(genTree[msg.sender]!=_referredBy)\n            level1Holding_[_referredBy] +=1;\n        genTree[msg.sender] = _referredBy;\n        purchaseTokens(msg.value);\n    }\n   \n    receive() external payable\n    {\n        require(msg.value > currentPrice_, \"Very Low Amount\");\n        purchaseTokens(msg.value);\n    }\n    \n    fallback() external payable\n    {\n        require(msg.value > currentPrice_, \"Very Low Amount\");\n        purchaseTokens(msg.value);\n    }\n   \n     bool mutex = true;\n     \n    function sell(uint256 _amountOfTokens)\n        onlyBagholders()\n        public\n    {\n        // setup data\n        require(!isContract(msg.sender),\"Selling from contract is not allowed\");\n        require (mutex == true);\n        address payable _customerAddress = msg.sender;\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n        uint256 _tokens = _amountOfTokens;\n        uint256 _ethereum = tokensToEthereum_(_tokens,true);\n        uint256 _dividends = _ethereum * (sellPercent)/10000;\n        // burn the sold tokens\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n        rewardBalanceLedger_[management] += _dividends;\n        rewardBalanceLedger_[commissionHolder] += 3000000000000000;\n        _dividends = _dividends + 3000000000000000;\n        _ethereum = SafeMath.sub(_ethereum,_dividends);\n        _customerAddress.transfer(_ethereum);\n        emit Transfer(_customerAddress, address(this), _tokens);\n    }\n   \n    function rewardOf(address _toCheck)\n        public view\n        returns(uint256)\n    {\n        return rewardBalanceLedger_[_toCheck];    \n    }\n   \n    function transfer(address _toAddress, uint256 _amountOfTokens)\n        onlyAdministrator()\n        public\n        returns(bool)\n    {\n        // setup\n        address _customerAddress = msg.sender;\n        // exchange tokens\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\n        return true;\n    }\n   \n    function destruct() onlyAdministrator() public{\n        selfdestruct(creator);\n    }\n   \n    function setName(string memory _name)\n        onlyAdministrator()\n        public\n    {\n        name = _name;\n    }\n   \n    function setSymbol(string memory _symbol)\n        onlyAdministrator()\n        public\n    {\n        symbol = _symbol;\n    }\n\n    function setupWallets(address _commissionHolder, address payable _management, address _poolFunds)\n    onlyAdministrator()\n    public\n    {\n        commissionHolder = _commissionHolder;\n        management = _management;\n        poolFund = _poolFunds;\n    }\n    \n\n    function totalEthereumBalance()\n        public\n        view\n        returns(uint)\n    {\n        return address(this).balance;\n    }\n   \n    function totalSupply()\n        public\n        view\n        returns(uint256)\n    {\n        return totalSupply_;\n    }\n   \n    function tokenSupply()\n    public\n    view\n    returns(uint256)\n    {\n        return tokenSupply_;\n    }\n   \n    /**\n     * Retrieve the tokens owned by the caller.\n     */\n    function myTokens()\n        public\n        view\n        returns(uint256)\n    {\n        address _customerAddress = msg.sender;\n        return balanceOf(_customerAddress);\n    }\n   \n   \n    /**\n     * Retrieve the token balance of any single address.\n     */\n    function balanceOf(address _customerAddress)\n        view\n        public\n        returns(uint256)\n    {\n        return tokenBalanceLedger_[_customerAddress];\n    }\n   \n    /**\n     * Return the sell price of 1 individual token.\n     */\n    function buyPrice()\n        public\n        view\n        returns(uint256)\n    {\n        return currentPrice_;\n    }\n   \n    /*==========================================\n    =            INTERNAL FUNCTIONS            =\n    ==========================================*/\n   \n    function purchaseTokens(uint256 _incomingEthereum)\n        internal\n        returns(uint256)\n    {\n        // data setup\n        uint256 _totalDividends = 0;\n        uint256 _dividends = _incomingEthereum * referralPercent/10000;\n        _totalDividends += _dividends;\n        address _customerAddress = msg.sender;\n        distributeRewards(_dividends,_customerAddress);\n        _dividends = _incomingEthereum * referralPercent/10000;\n        _totalDividends += _dividends;\n        rewardBalanceLedger_[management] += _dividends;\n        _dividends = (_incomingEthereum *percent)/10000;\n        _totalDividends += _dividends;\n        rewardBalanceLedger_[poolFund] += _dividends;\n        _incomingEthereum = SafeMath.sub(_incomingEthereum, _totalDividends);\n        \n        uint256 _amountOfTokens = ethereumToTokens_(_incomingEthereum , currentPrice_, base, true);\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n        tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n        require(SafeMath.add(_amountOfTokens,tokenSupply_) < (totalSupply_));\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n        // fire event\n        emit Transfer(address(this), _customerAddress, _amountOfTokens);\n        return _amountOfTokens;\n    }\n   \n    function ethereumToTokens_(uint256 _ethereum, uint256 _currentPrice, uint256 _grv, bool _buy)\n        internal\n        returns(uint256)\n    {\n        uint256 _tokenPriceIncremental = (tokenPriceIncremental_*(3**(_grv-1)));\n        uint256 _tempad = SafeMath.sub((2*_currentPrice), _tokenPriceIncremental);\n        uint256 _tokenSupply = tokenSupply_;\n        uint256 _totalTokens = 0;\n        uint256 _tokensReceived = (\n            (\n                SafeMath.sub(\n                    (sqrt\n                        (\n                            _tempad**2\n                            + (8*_tokenPriceIncremental*_ethereum)\n                        )\n                    ), _tempad\n                )\n            )/(2*_tokenPriceIncremental)\n        );\n        uint256 tempbase = upperBound_(_grv);\n        while((_tokensReceived + _tokenSupply) > tempbase){\n            _tokensReceived = tempbase - _tokenSupply;\n            _ethereum = SafeMath.sub(\n                _ethereum,\n                ((_tokensReceived)/2)*\n                ((2*_currentPrice)+((_tokensReceived-1)\n                *_tokenPriceIncremental))\n            );\n            _currentPrice = _currentPrice+((_tokensReceived-1)*_tokenPriceIncremental);\n            _grv = _grv + 1;\n            _tokenPriceIncremental = (tokenPriceIncremental_*((3)**(_grv-1)));\n            _tempad = SafeMath.sub((2*_currentPrice), _tokenPriceIncremental);\n            uint256 _tempTokensReceived = (\n                (\n                    SafeMath.sub(\n                        (sqrt\n                            (\n                                _tempad**2\n                                + (8*_tokenPriceIncremental*_ethereum)\n                            )\n                        ), _tempad\n                    )\n                )/(2*_tokenPriceIncremental)\n            );\n            _tokenSupply = _tokenSupply + _tokensReceived;\n            _totalTokens = _totalTokens + _tokensReceived;\n            _tokensReceived = _tempTokensReceived;\n            tempbase = upperBound_(_grv);\n        }\n        _totalTokens = _totalTokens + _tokensReceived;\n        _currentPrice = _currentPrice+((_tokensReceived-1)*_tokenPriceIncremental);\n        if(_buy == true)\n        {\n            currentPrice_ = _currentPrice;\n            base = _grv;\n        }\n        return _totalTokens;\n    }\n   \n    function upperBound_(uint256 _grv)\n    internal\n    pure\n    returns(uint256)\n    {\n        uint256 topBase = 0;\n        for(uint i = 1;i<=_grv;i++)\n        {\n            topBase +=200000-((_grv-i)*10000);\n        }\n        return topBase;\n    }\n   \n     function tokensToEthereum_(uint256 _tokens, bool _sell)\n        internal\n        returns(uint256)\n    {\n        uint256 _tokenSupply = tokenSupply_;\n        uint256 _etherReceived = 0;\n        uint256 _grv = base;\n        uint256 tempbase = upperBound_(_grv-1);\n        uint256 _currentPrice = currentPrice_;\n        uint256 _tokenPriceIncremental = (tokenPriceIncremental_*((3)**(_grv-1)));\n        while((_tokenSupply - _tokens) < tempbase)\n        {\n            uint256 tokensToSell = _tokenSupply - tempbase;\n            if(tokensToSell == 0)\n            {\n                _tokenSupply = _tokenSupply - 1;\n                _grv -= 1;\n                tempbase = upperBound_(_grv-1);\n                continue;\n            }\n            uint256 b = ((tokensToSell-1)*_tokenPriceIncremental);\n            uint256 a = _currentPrice - b;\n            _tokens = _tokens - tokensToSell;\n            _etherReceived = _etherReceived + ((tokensToSell/2)*((2*a)+b));\n            _currentPrice = a;\n            _tokenSupply = _tokenSupply - tokensToSell;\n            _grv = _grv-1 ;\n            _tokenPriceIncremental = (tokenPriceIncremental_*((3)**(_grv-1)));\n            tempbase = upperBound_(_grv-1);\n        }\n        if(_tokens > 0)\n        {\n             uint256 a = _currentPrice - ((_tokens-1)*_tokenPriceIncremental);\n             _etherReceived = _etherReceived + ((_tokens/2)*((2*a)+((_tokens-1)*_tokenPriceIncremental)));\n             _tokenSupply = _tokenSupply - _tokens;\n             _currentPrice = a;\n        }\n       \n        if(_sell == true)\n        {\n            base = _grv;\n            currentPrice_ = _currentPrice;\n        }\n        return _etherReceived;\n    }\n   \n   \n    function sqrt(uint x) internal pure returns (uint y) {\n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    /**\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}"
    }
  }
}