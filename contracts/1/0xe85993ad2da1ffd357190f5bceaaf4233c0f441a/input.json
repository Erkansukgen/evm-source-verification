{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Jug.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2019-11-14\n*/\n\n// hevm: flattened sources of /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/jug.sol\npragma solidity =0.5.12;\n\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/lib.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.5.12; */\n\ncontract LibNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  usr,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: selector, caller, arg1 and arg2\n            let mark := msize                         // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 caller,                              // msg.sender\n                 calldataload(4),                     // arg1\n                 calldataload(36)                     // arg2\n                )\n        }\n    }\n}\n\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/jug.sol\n/* pragma solidity 0.5.12; */\n\n/* import \"./lib.sol\"; */\n\ncontract VatLike {\n    function ilks(bytes32) external returns (\n        uint256 Art,   // wad\n        uint256 rate   // ray\n    );\n    function fold(bytes32,address,int) external;\n}\n\ncontract Jug is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Jug/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Ilk {\n        uint256 duty;\n        uint256  rho;\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n    VatLike                  public vat;\n    address                  public vow;\n    uint256                  public base;\n\n    // --- Init ---\n    constructor(address vat_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n    }\n\n    // --- Math ---\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\n      assembly {\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\n        default {\n          switch mod(n, 2) case 0 { z := b } default { z := x }\n          let half := div(b, 2)  // for rounding.\n          for { n := div(n, 2) } n { n := div(n,2) } {\n            let xx := mul(x, x)\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\n            let xxRound := add(xx, half)\n            if lt(xxRound, xx) { revert(0,0) }\n            x := div(xxRound, b)\n            if mod(n,2) {\n              let zx := mul(z, x)\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n              let zxRound := add(zx, half)\n              if lt(zxRound, zx) { revert(0,0) }\n              z := div(zxRound, b)\n            }\n          }\n        }\n      }\n    }\n    uint256 constant ONE = 10 ** 27;\n    function add(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function diff(uint x, uint y) internal pure returns (int z) {\n        z = int(x) - int(y);\n        require(int(x) >= 0 && int(y) >= 0);\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = x * y;\n        require(y == 0 || z / y == x);\n        z = z / ONE;\n    }\n\n    // --- Administration ---\n    function init(bytes32 ilk) external note auth {\n        Ilk storage i = ilks[ilk];\n        require(i.duty == 0, \"Jug/ilk-already-init\");\n        i.duty = ONE;\n        i.rho  = now;\n    }\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\n        require(now == ilks[ilk].rho, \"Jug/rho-not-updated\");\n        if (what == \"duty\") ilks[ilk].duty = data;\n        else revert(\"Jug/file-unrecognized-param\");\n    }\n    function file(bytes32 what, uint data) external note auth {\n        if (what == \"base\") base = data;\n        else revert(\"Jug/file-unrecognized-param\");\n    }\n    function file(bytes32 what, address data) external note auth {\n        if (what == \"vow\") vow = data;\n        else revert(\"Jug/file-unrecognized-param\");\n    }\n\n    // --- Stability Fee Collection ---\n    function drip(bytes32 ilk) external note returns (uint rate) {\n        require(now >= ilks[ilk].rho, \"Jug/invalid-now\");\n        (, uint prev) = vat.ilks(ilk);\n        rate = rmul(rpow(add(base, ilks[ilk].duty), now - ilks[ilk].rho, ONE), prev);\n        vat.fold(ilk, vow, diff(rate, prev));\n        ilks[ilk].rho = now;\n    }\n}\n"}}}