{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Stats.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface CTokenInterface {\n    function exchangeRateStored() external view returns (uint);\n    function borrowBalanceStored(address) external view returns (uint);\n\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface ListInterface {\n    function accounts() external view returns (uint);\n    function accountID(address) external view returns (uint64);\n    function accountAddr(uint64) external view returns (address);\n}\n\ncontract Helpers {\n\n    struct CompData {\n        uint balanceOfUser;\n        uint borrowBalanceStoredUser;\n    }\n    struct data {\n        address user;\n        CompData[] tokensData;\n    }\n}\n\n\ncontract Resolver is Helpers {\n    \n    function getDSAWallets(uint len) public view returns(address[] memory) {\n        address[] memory wallets = new address[](len);\n        for (uint i = 0; i < len; i++) {\n            ListInterface list = ListInterface(0x4c8a1BEb8a87765788946D6B19C6C6355194AbEb);\n            wallets[i] = list.accountAddr(uint64(i+1));\n        }\n\n    }\n\n    function getCompoundData(address owner, address[] memory cAddress) public view returns (CompData[] memory) {\n        CompData[] memory tokensData = new CompData[](cAddress.length);\n        for (uint i = 0; i < cAddress.length; i++) {\n            CTokenInterface cToken = CTokenInterface(cAddress[i]);\n            tokensData[i] = CompData(\n                cToken.balanceOf(owner),\n                cToken.borrowBalanceStored(owner)\n            );\n        }\n\n        return tokensData;\n    }\n\n    function getPosition(\n        address[] memory owners,\n        address[] memory cAddress\n    )\n        public\n        view\n        returns (data[] memory)\n    {\n        data[] memory datas = new data[](owners.length);\n        for (uint i = 0; i < cAddress.length; i++) {\n            datas[i] = data(\n                owners[i],\n                getCompoundData(owners[i], cAddress)\n            );\n        }\n        return datas;\n    }\n\n}\n"
    }
  }
}