{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/AuctionHouseEmptyV1.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./AuctionHouseV1.sol\";\n\n/// @author Guillaume Gonnaud 2018\n/// @title Auction House Empty Logic Code\n/// @notice Contain all the storage of the auction house declared in a way that generate getters for Logic Code use, but no code that changes memory\ncontract AuctionHouseEmptyV1 is VCProxyData, AuctionHouseHeaderV1, AuctionHouseStoragePublicV1 {\n\n    //No functions, including no withdraw/catchall, in case of an exploit to the pending withdrawals array.\n    //Any non \"view\" call will fail.\n\n}"
    },
    "browser/AuctionHouseV1.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Auction House Header\n/// @notice Contain all the events emitted by the Auction House\ncontract AuctionHouseHeaderV1 {\n\n    // Deposit: Event emitted whenever money is made available for withdrawal in the Auction House\n    // amount: Amount of money being deposited\n    // beneficiary: Account that will be able to withdraw the money\n    // contributor: Which user wallet initially contributed the received money\n    // origin: Which smart contract sent the money\n    event Deposit(uint256 indexed amount, address indexed beneficiary, address indexed contributor, address origin);\n\n    // Withdrawal: event emitted whenever a user withdraw his Eth on the auction house smart contract\n    // amount: total amount of money withdrawn\n    // account: address of user withdrawing his money\n    event UserWithdrawal(uint256 indexed amount, address indexed account);\n\n    // Bid: event emitted whenever a user submit a new bid to an auction\n    // auction: the address of the auction\n    // bidValue: the eth value of the new standing bid\n    // bidder: the address of the user who just bid\n    event UserBid(address indexed auction, uint256 indexed bidValue, address indexed bidder);\n\n    // CancelBid: event emitted whenever a user manually cancel a bid\n    // auction: the address of the auction\n    // bidder: the address of the user who just cancelled his bid\n    event UserCancelledBid(address indexed auction, address indexed bidder);\n\n    // Win: event emitted whenever a user win an auction\n    // auction: the address of the auction\n    // bidValue: the eth value of the winning bid\n    // bidder: the address of the user who just won the auction his bid\n    event UserWin(address indexed auction, uint256 indexed bidValue, address indexed bidder);\n\n    // UserSell: event emitted whenever a user trigger a sale at an auction\n    // auction: the address of the auction\n    event UserSell(address indexed auction);\n\n    // UserSellingPriceAdjust: event emitted whenever a user adjust the selling price of an auction\n    // auction: the address of the auction\n    // value : the new adjusted price. 0 for disabled\n    event UserSellingPriceAdjust(address indexed auction, uint256 indexed value);\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Auction House Storage Internal\n/// @notice Contain all the storage of the auction house declared in a way that does not generate getters for Proxy use\ncontract AuctionHouseStorageInternalV1 {\n    bool internal initialized; //Bool to check if the index have been initialized\n    address internal factory; //The factory smart contract (proxy) that will publish the cryptographs\n    address internal index; //The index smart contract that maps cryptographs and their auctions\n    mapping (address => uint) internal pendingWithdrawals;  //How much money each user owns on the smart contract\n\n    address internal ERC2665Lieutenant;\n    address internal kycContract;\n}\n\n\n/// @author Guillaume Gonnaud\n/// @title Auction House Storage Public\n/// @notice Contain all the storage of the auction house declared in a way that generates getters for Logic Code use\ncontract AuctionHouseStoragePublicV1 {\n    bool public initialized; //Bool to check if the index have been initialized\n    address public factory; //The factory smart contract (proxy) that will publish the cryptographs\n    address public index; //The index smart contract that maps cryptographs and their auctions\n    mapping (address => uint) public pendingWithdrawals;  //How much money each user owns on the smart contract\n\n    address public ERC2665Lieutenant;\n    address public kycContract;\n\n}"
    },
    "browser/VCProxy.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/* Based on a variation of https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201\nThis generic proxy is gonna ask a version control smart contract for its logic code instead\nof storing the remote address himself\n*/\n\n/*\nSmart contract only containing a public array named the same as VC so that the compiler call the proper\nfunction signature in our generic proxy\n*/\ncontract VersionControlStoragePublic {\n    address[] public code;\n}\n\n\n/*\nStorage stack of a proxy contract. VCproxy inherit this, as well as ALL logic contracts associated to a proxy for storage alignment reasons.\n*/\ncontract VCProxyData {\n    address internal vc; //Version Control Smart Contract Address\n    uint256 internal version; //The index of our logic code in the Version Control array.\n}\n\n\n/*\nLogic of a proxy contract. EVERY proxied contract inherit this\n*/\ncontract VCProxy is VCProxyData {\n    constructor(uint256 _version, address _vc) public {\n        version = _version;\n        vc = _vc;\n    }\n\n    fallback () virtual external payable {\n\n        address addr = VersionControlStoragePublic(vc).code(version);\n        assembly {\n            let freememstart := mload(0x40)\n            calldatacopy(freememstart, 0, calldatasize())\n            let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 0)\n            returndatacopy(freememstart, 0, returndatasize())\n            switch success\n            case 0 { revert(freememstart, returndatasize()) }\n            default { return(freememstart, returndatasize()) }\n        }\n    }\n\n    \n    /// @notice Generic catch-all function that refuse payments to prevent accidental Eth burn.\n    receive() virtual external payable{\n       require(false, \"Do not send me Eth without a reason\");\n    }\n}"
    }
  }
}