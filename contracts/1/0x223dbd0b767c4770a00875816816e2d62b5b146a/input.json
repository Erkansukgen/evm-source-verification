{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/SpellProxy.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-11-06\n*/\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0 <0.9.0;\n\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.2\n// License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface sSpellV1 {\n    function users(address _account) external view returns (uint128, uint128);\n}\n\n/**\n * @title SpellProxy\n * @dev Get user's $Spell, APY\n */\ncontract SpellProxy {\n    using SafeMath for uint128;\n    using SafeMath for uint256;\n    \n    address private owner;\n    \n    address public spellToken;\n    address public sSpellToken;\n    \n    uint256 public previousTotalShare;\n    uint256 public previousTotalTokenSupply;\n    \n    uint256 private constant LOCK_TIME = 600; //24 hours;\n    uint256 private apyForSpell;\n    uint256 private lastUpdateApyTime;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    modifier notContract() {\n        require(!_isContract(msg.sender), \"Contract not allowed\");\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor(address _spellToken, address _sSpellToken) public {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        \n        spellToken = _spellToken;\n        sSpellToken = _sSpellToken;\n        \n        lastUpdateApyTime = block.timestamp;\n        \n        // Store the current $Spell and Staked $Spell supply in the Staked $Spell contract.\n        previousTotalShare = IERC20(sSpellToken).totalSupply();\n        previousTotalTokenSupply = IERC20(spellToken).balanceOf(sSpellToken);\n        \n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n    \n    /**\n     * @notice Get amount of $Spell token and Unlock time according to the user's Staked $Spell\n     * @param _account: user's wallet address\n     * @dev Callable by users only, not contract!\n     */\n    function getSpellToken(address _account) public view notContract returns (uint, uint128){\n        \n        (uint128 shares, uint128 unLockTime) = sSpellV1(sSpellToken).users(_account);\n\n        // Calculate the $Spell equivalent to the Staked $Spell\n        uint totalShare = IERC20(sSpellToken).totalSupply();\n        uint totalTokenSupply = IERC20(spellToken).balanceOf(sSpellToken);\n        \n        uint amount = (shares.mul(totalTokenSupply)).div(totalShare);\n        \n        return (amount, unLockTime);\n    }\n    \n    /**\n     * @notice Update the APY of Staked  $Spell\n     * @dev Callable by users only, not contract!\n     */\n    function updateApy() public notContract {\n        if (block.timestamp < lastUpdateApyTime + LOCK_TIME)\n            return;\n        \n        // Calculate the $Spell equivalent to the Staked $Spell\n        uint totalShare = IERC20(sSpellToken).totalSupply();\n        uint totalTokenSupply = IERC20(spellToken).balanceOf(sSpellToken);\n        \n        require(previousTotalTokenSupply >= 0 && totalShare >= 0, \"updateApy: division by zero\");\n        \n        // Calculate the earning perent of the $Spell during the LOCK_TIME period by the APY Calculation Formula.\n        uint256 earningPercent = ((previousTotalShare.mul(totalTokenSupply)).mul(10000).\n                                    div(previousTotalTokenSupply.mul(totalShare))).sub(10000);\n                            \n        uint256 interval = block.timestamp.sub(lastUpdateApyTime);\n        \n        // Calculate the earning of $Spell per hour\n        uint256 earningPercentForOneday = earningPercent.mul(86400).div(interval);                  // 3600 * 24 = 86400\n        \n        // Calculate the APY\n        apyForSpell = earningPercentForOneday.mul(365);\n        \n        // Save the current values.\n        previousTotalShare = totalShare;\n        previousTotalTokenSupply = totalTokenSupply;\n        \n        lastUpdateApyTime = block.timestamp;\n    }\n    \n    function getApy() external view returns (uint) {\n        return apyForSpell;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n    \n    /**\n     * @notice Check if an address is a contract\n     */\n    function _isContract(address _address) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_address)\n        }\n        return size > 0;\n    }\n}"}}}