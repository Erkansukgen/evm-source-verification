{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/AIP2.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\ninterface ITokenDistributor {\n\n  function initialize(address[] memory _receivers, uint[] memory _percentages) external;\n\n  function distribute(IERC20[] memory _tokens) external;\n\n  function getDistribution()\n    external\n    view\n    returns (address[] memory receivers, uint256[] memory percentages);\n}\n\ninterface IProxyWithAdminActions {\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\n\n  function changeAdmin(address newAdmin) external;\n}\n\ninterface IProposalExecutor {\n    function execute() external;\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n * From https://github.com/OpenZeppelin/openzeppelin-contracts\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title AIP2ProposalPayload\n * @notice Proposal payload to be executed by the Aave Governance contract via DELEGATECALL\n * - Updates the TokenDistributor contract as defined by the AIP-2\n * @author Aave\n **/\ncontract AIP2ProposalPayload is IProposalExecutor {\n  event ProposalExecuted();\n\n  address public constant DISTRIBUTOR_IMPL = 0x62C936a16905AfC49B589a41d033eE222A2325Ad;\n  address public constant DISTRIBUTOR_PROXY = 0xE3d9988F676457123C5fD01297605efdD0Cba1ae;\n  address public constant AAVE_COLLECTOR = 0x464C71f6c2F760DdA6093dCB91C24c39e5d6e18c;\n  address public constant REFERRAL_WALLET = 0x2fbB0c60a41cB7Ea5323071624dCEAD3d213D0Fa;\n\n  /**\n   * @dev Payload execution function, called once a proposal passed in the Aave governance\n   */\n  function execute() external override {\n    address[] memory receivers = new address[](2);\n    receivers[0] = AAVE_COLLECTOR;\n    receivers[1] = REFERRAL_WALLET;\n\n    uint256[] memory percentages = new uint256[](2);\n    percentages[0] = uint256(8000);\n    percentages[1] = uint256(2000);\n\n    bytes memory params =\n      abi.encodeWithSelector(\n        ITokenDistributor(DISTRIBUTOR_IMPL).initialize.selector,\n        receivers,\n        percentages\n      );\n\n    IProxyWithAdminActions(DISTRIBUTOR_PROXY).upgradeToAndCall(DISTRIBUTOR_IMPL, params);\n\n    emit ProposalExecuted();\n  }\n}\n"}}}