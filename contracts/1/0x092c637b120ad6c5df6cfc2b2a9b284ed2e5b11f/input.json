{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/MultiCallV1.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\r\npragma abicoder v2;\r\npragma solidity ^0.8.6;\r\n\r\ncontract MultiCallV1 {\r\n  function executeCall(address target, string calldata signature, bytes calldata data) external returns (bytes memory) {\r\n    bytes memory callData;\r\n\r\n    if (bytes(signature).length == 0) {\r\n        callData = data;\r\n    } else {\r\n        callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n    }\r\n\r\n    // solium-disable-next-line security/no-call-value\r\n    (bool success, bytes memory returnData) = target.call(callData);\r\n    \r\n    if (success) {   \r\n        return returnData;\r\n    }\r\n    \r\n    return \"\";\r\n  }\r\n\r\n  function executeCallsOfMultiTargets(address[] calldata targets, string calldata signature, bytes calldata data) external returns (bytes[] memory returnDatas) {\r\n    returnDatas = new bytes[](targets.length);\r\n    \r\n    for(uint i = 0; i < targets.length; i++) {\r\n      try this.executeCall(targets[i], signature, data) returns (bytes memory returnData) {\r\n        returnDatas[i] = returnData;\r\n      } catch {}\r\n    }\r\n    return returnDatas;\r\n  }\r\n\r\n  function executeMultiCallsOfTarget(address target, string[] calldata signatures, bytes[] calldata datas) external returns (bytes[] memory returnDatas) {\r\n    returnDatas = new bytes[](signatures.length);\r\n    \r\n    for(uint i = 0; i < signatures.length; i++) {\r\n      try this.executeCall(target, signatures[i], datas[i]) returns (bytes memory returnData) {\r\n        returnDatas[i] = returnData;\r\n      } catch {}\r\n    }\r\n    return returnDatas;\r\n  }\r\n\r\n  function executeMultiCallsOfMultiTarget(address[] calldata targets, string[] calldata signatures, bytes[] calldata datas) external returns (bytes[] memory returnDatas) {\r\n    returnDatas = new bytes[](targets.length);\r\n    \r\n    for(uint i = 0; i < targets.length; i++) {\r\n      try this.executeCall(targets[i], signatures[i], datas[i]) returns (bytes memory returnData) {\r\n        returnDatas[i] = returnData;\r\n      } catch {}\r\n    }\r\n    return returnDatas;\r\n  }\r\n}"}}}