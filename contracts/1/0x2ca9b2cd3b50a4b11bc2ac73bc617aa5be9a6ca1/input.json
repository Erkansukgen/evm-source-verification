{"language":"Solidity","sources":{"LendingController.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IInterestRateModel.sol\";\nimport \"IPriceOracle.sol\";\nimport \"ILendingController.sol\";\nimport \"SafeOwnable.sol\";\nimport \"AddressLibrary.sol\";\n\ncontract LendingController is ILendingController, SafeOwnable {\n\n  using AddressLibrary for address;\n\n  uint private constant MAX_COL_FACTOR = 99e18;\n  uint private constant MAX_LIQ_FEES   = 50e18;\n\n  IPriceOracle public priceOracle;\n\n  address public override interestRateModel;\n\n  bool public override depositsEnabled;\n  bool public override borrowingEnabled;\n  uint public liqFeeCallerDefault;\n  uint public liqFeeSystemDefault;\n  uint public override uniMinOutputPct; // 99e18 = 99%\n\n  mapping(address => bool) public isGuardian;\n  mapping(address => mapping(address => uint)) public override depositLimit;\n  mapping(address => mapping(address => uint)) public override borrowLimit;\n  mapping(address => uint) public liqFeeCallerToken; // 1e18  = 1%\n  mapping(address => uint) public liqFeeSystemToken; // 1e18  = 1%\n  mapping(address => uint) public override colFactor; // 99e18 = 99%\n  mapping(address => uint) public override minBorrow;\n\n  event NewInterestRateModel(address indexed interestRateModel);\n  event NewPriceOracle(address indexed priceOracle);\n  event NewColFactor(address indexed token, uint value);\n  event NewDepositLimit(address indexed pair, address indexed token, uint value);\n  event NewBorrowLimit(address indexed pair, address indexed token, uint value);\n  event AllowGuardian(address indexed guardian, bool value);\n  event DepositsEnabled(bool value);\n  event BorrowingEnabled(bool value);\n  event NewLiqParamsToken(address indexed token, uint liqFeeSystem, uint liqFeeCaller);\n  event NewLiqParamsDefault(uint liqFeeSystem, uint liqFeeCaller);\n  event NewUniMinOutputPct(uint value);\n  event NewMinBorrow(address indexed token, uint value);\n\n  modifier onlyGuardian() {\n    require(isGuardian[msg.sender], \"LendingController: caller is not a guardian\");\n    _;\n  }\n\n  constructor(\n    address _interestRateModel,\n    uint _liqFeeSystemDefault,\n    uint _liqFeeCallerDefault,\n    uint _uniMinOutputPct\n  ) {\n    _requireContract(_interestRateModel);\n    require(_liqFeeSystemDefault + _liqFeeCallerDefault <= MAX_LIQ_FEES, \"LendingController: fees too high\");\n\n    interestRateModel   = _interestRateModel;\n    liqFeeSystemDefault = _liqFeeSystemDefault;\n    liqFeeCallerDefault = _liqFeeCallerDefault;\n    uniMinOutputPct     = _uniMinOutputPct;\n    depositsEnabled     = true;\n    borrowingEnabled    = true;\n  }\n\n  function setLiqParamsToken(\n    address _token,\n    uint    _liqFeeSystem,\n    uint    _liqFeeCaller\n  ) external onlyOwner {\n    require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, \"LendingController: fees too high\");\n    _requireContract(_token);\n\n    liqFeeSystemToken[_token] = _liqFeeSystem;\n    liqFeeCallerToken[_token] = _liqFeeCaller;\n\n    emit NewLiqParamsToken(_token, _liqFeeSystem, _liqFeeCaller);\n  }\n\n  function setLiqParamsDefault(\n    uint    _liqFeeSystem,\n    uint    _liqFeeCaller\n  ) external onlyOwner {\n    require(_liqFeeCaller + _liqFeeSystem <= MAX_LIQ_FEES, \"LendingController: fees too high\");\n\n    liqFeeSystemDefault = _liqFeeSystem;\n    liqFeeCallerDefault = _liqFeeCaller;\n\n    emit NewLiqParamsDefault(_liqFeeSystem, _liqFeeCaller);\n  }\n\n  function setInterestRateModel(address _value) external onlyOwner {\n    _requireContract(_value);\n    interestRateModel = _value;\n    emit NewInterestRateModel(_value);\n  }\n\n  function setPriceOracle(address _value) external onlyOwner {\n    _requireContract(_value);\n    priceOracle = IPriceOracle(_value);\n    emit NewPriceOracle(address(_value));\n  }\n\n  function setMinBorrow(address _token, uint _value) external onlyOwner {\n    _requireContract(_token);\n    minBorrow[_token] = _value;\n    emit NewMinBorrow(_token, _value);\n  }\n\n  // Allow immediate emergency shutdown of deposits by the guardian.\n  function disableDeposits() external onlyGuardian {\n    depositsEnabled = false;\n    emit DepositsEnabled(false);\n  }\n\n  // Re-enabling deposits can only be done by the owner\n  function enableDeposits() external onlyOwner {\n    depositsEnabled = true;\n    emit DepositsEnabled(true);\n  }\n\n  function disableBorrowing() external onlyGuardian {\n    borrowingEnabled = false;\n    emit BorrowingEnabled(false);\n  }\n\n  function enableBorrowing() external onlyOwner {\n    borrowingEnabled = true;\n    emit BorrowingEnabled(true);\n  }\n\n  function setDepositLimit(address _pair, address _token, uint _value) external onlyOwner {\n    _requireContract(_pair);\n    _requireContract(_token);\n    depositLimit[_pair][_token] = _value;\n    emit NewDepositLimit(_pair, _token, _value);\n  }\n\n  function allowGuardian(address _guardian, bool _value) external onlyOwner {\n    isGuardian[_guardian] = _value;\n    emit AllowGuardian(_guardian, _value);\n  }\n\n  function setBorrowLimit(address _pair, address _token, uint _value) external onlyOwner {\n    _requireContract(_pair);\n    _requireContract(_token);\n    borrowLimit[_pair][_token] = _value;\n    emit NewBorrowLimit(_pair, _token, _value);\n  }\n\n  function setUniMinOutputPct(uint _value) external onlyOwner {\n    uniMinOutputPct = _value;\n    emit NewUniMinOutputPct(_value);\n  }\n\n  function setColFactor(address _token, uint _value) external onlyOwner {\n    require(_value <= MAX_COL_FACTOR, \"LendingController: _value <= MAX_COL_FACTOR\");\n    _requireContract(_token);\n    colFactor[_token] = _value;\n    emit NewColFactor(_token, _value);\n  }\n\n  function liqFeeSystem(address _token) public view override returns(uint) {\n    return liqFeeSystemToken[_token] > 0 ? liqFeeSystemToken[_token] : liqFeeSystemDefault;\n  }\n\n  function liqFeeCaller(address _token) public view override returns(uint) {\n    return liqFeeCallerToken[_token] > 0 ? liqFeeCallerToken[_token] : liqFeeCallerDefault;\n  }\n\n  function liqFeesTotal(address _token) external view returns(uint) {\n    return liqFeeSystem(_token) + liqFeeCaller(_token);\n  }\n\n  function tokenPrice(address _token) external view override returns(uint) {\n    return priceOracle.tokenPrice(_token);\n  }\n\n  function tokenPrices(address _tokenA, address _tokenB) external view override returns (uint, uint) {\n    return (\n      priceOracle.tokenPrice(_tokenA),\n      priceOracle.tokenPrice(_tokenB)\n    );\n  }\n\n  function tokenSupported(address _token) external view override returns(bool) {\n    return priceOracle.tokenSupported(_token);\n  }\n\n  function _requireContract(address _value) internal view {\n    require(_value.isContract(), \"LendingController: must be a contract\");\n  }\n}\n"},"IInterestRateModel.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IInterestRateModel {\n  function lpRate(address _pair, address _token) external view returns(uint);\n  function interestRatePerBlock(address _pair, address _token, uint _totalSupply, uint _totalDebt) external view returns(uint);\n}"},"IPriceOracle.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IPriceOracle {\n\n  function tokenPrice(address _token) external view returns(uint);\n  function tokenSupported(address _token) external view returns(bool);\n  function convertTokenValues(address _fromToken, address _toToken, uint _amount) external view returns(uint);\n}\n"},"ILendingController.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\n\ninterface ILendingController is IOwnable {\n  function interestRateModel() external view returns(address);\n  function liqFeeSystem(address _token) external view returns(uint);\n  function liqFeeCaller(address _token) external view returns(uint);\n  function uniMinOutputPct() external view returns(uint);\n  function colFactor(address _token) external view returns(uint);\n  function depositLimit(address _lendingPair, address _token) external view returns(uint);\n  function borrowLimit(address _lendingPair, address _token) external view returns(uint);\n  function depositsEnabled() external view returns(bool);\n  function borrowingEnabled() external view returns(bool);\n  function tokenPrice(address _token) external view returns(uint);\n  function minBorrow(address _token) external view returns(uint);\n  function tokenPrices(address _tokenA, address _tokenB) external view returns (uint, uint);\n  function tokenSupported(address _token) external view returns(bool);\n}\n"},"IOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IOwnable {\n  function owner() external view returns(address);\n  function transferOwnership(address _newOwner) external;\n  function acceptOwnership() external;\n}"},"SafeOwnable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\n\ncontract SafeOwnable is IOwnable {\n\n  uint public constant RENOUNCE_TIMEOUT = 1 hours;\n\n  address public override owner;\n  address public pendingOwner;\n  uint public renouncedAt;\n\n  event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\n  event OwnershipTransferConfirmed(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnershipTransferConfirmed(address(0), msg.sender);\n  }\n\n  modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function isOwner() public view returns (bool) {\n    return msg.sender == owner;\n  }\n\n  function transferOwnership(address _newOwner) external override onlyOwner {\n    require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferInitiated(owner, _newOwner);\n    pendingOwner = _newOwner;\n  }\n\n  function acceptOwnership() external override {\n    require(msg.sender == pendingOwner, \"Ownable: caller is not pending owner\");\n    emit OwnershipTransferConfirmed(msg.sender, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n\n  function initiateRenounceOwnership() external onlyOwner {\n    require(renouncedAt == 0, \"Ownable: already initiated\");\n    renouncedAt = block.timestamp;\n  }\n\n  function acceptRenounceOwnership() external onlyOwner {\n    require(renouncedAt > 0, \"Ownable: not initiated\");\n    require(block.timestamp - renouncedAt > RENOUNCE_TIMEOUT, \"Ownable: too early\");\n    owner = address(0);\n    pendingOwner = address(0);\n    renouncedAt = 0;\n  }\n\n  function cancelRenounceOwnership() external onlyOwner {\n    require(renouncedAt > 0, \"Ownable: not initiated\");\n    renouncedAt = 0;\n  }\n}"},"AddressLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressLibrary {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}"}},"settings":{"evmVersion":"istanbul","optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}}