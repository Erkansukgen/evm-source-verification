{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"kLP.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity =0.7.6;\r\npragma abicoder v2;\r\n\r\nlibrary FullMath {\r\n    \r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = a * b\r\n        // Compute the product mod 2**256 and mod 2**256 - 1\r\n        // then use the Chinese Remainder Theorem to reconstruct\r\n        // the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2**256 + prod0\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2**256.\r\n        // Also prevents denominator == 0\r\n        require(denominator > prod1);\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0]\r\n        // Compute remainder using mulmod\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        // Subtract 256 bit number from 512 bit number\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator\r\n        // Compute largest power of two divisor of denominator.\r\n        // Always >= 1.\r\n        uint256 twos = -denominator & denominator;\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        // Invert denominator mod 2**256\r\n        // Now that denominator is an odd number, it has an inverse\r\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n        // Compute the inverse by starting with a seed that is correct\r\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n        // Now use Newton-Raphson iteration to improve the precision.\r\n        // Thanks to Hensel's lifting lemma, this also works in modular\r\n        // arithmetic, doubling the correct bits in each step.\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        // Because the division is now exact we can divide by multiplying\r\n        // with the modular inverse of denominator. This will give us the\r\n        // correct result modulo 2**256. Since the precoditions guarantee\r\n        // that the outcome is less than 2**256, this is the final result.\r\n        // We don't need to compute the high bits of the result and prod1\r\n        // is no longer required.\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary TickMath {\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\r\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\r\n        require(absTick <= uint256(MAX_TICK), 'T');\r\n\r\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\r\n    }\r\n}\r\n\r\n/// @title FixedPoint96\r\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\r\n/// @dev Used in SqrtPriceMath.sol\r\nlibrary FixedPoint96 {\r\n    uint8 internal constant RESOLUTION = 96;\r\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\r\n}\r\n\r\n/// @title Liquidity amount functions\r\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\r\nlibrary LiquidityAmounts {\r\n    /// @notice Downcasts uint256 to uint128\r\n    /// @param x The uint258 to be downcasted\r\n    /// @return y The passed value, downcasted to uint128\r\n    function toUint128(uint256 x) private pure returns (uint128 y) {\r\n        require((y = uint128(x)) == x);\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\r\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount0 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\r\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\r\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount1 The amount1 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\r\n    }\r\n\r\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount of token0 being sent in\r\n    /// @param amount1 The amount of token1 being sent in\r\n    /// @return liquidity The maximum amount of liquidity received\r\n    function getLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\r\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\r\n\r\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\r\n        } else {\r\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\r\n        }\r\n    }\r\n\r\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    function getAmount0ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return\r\n            FullMath.mulDiv(\r\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\r\n                sqrtRatioBX96 - sqrtRatioAX96,\r\n                sqrtRatioBX96\r\n            ) / sqrtRatioAX96;\r\n    }\r\n\r\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount1 The amount of token1\r\n    function getAmount1ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\r\n    }\r\n\r\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    /// @return amount1 The amount of token1\r\n    function getAmountsForLiquidity(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\r\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\r\n        } else {\r\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary PoolAddress {\r\n    \r\n    struct PoolKey {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n    }\r\n    \r\n    function getPoolKey(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) internal pure returns (PoolKey memory) {\r\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\r\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\r\n    }\r\n}\r\n\r\ninterface erc20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function balanceOf(address) external view returns (uint);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\ninterface weth9 is erc20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint256) external;\r\n}\r\n\r\ninterface univ3 {\r\n    function fee() external view returns (uint24);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool);\r\n    function mint(address, int24, int24, uint128, bytes calldata) external returns (uint256, uint256);\r\n    function burn(int24 tickLower, int24 tickUpper, uint128 amount) external returns (uint256, uint256);\r\n    function collect(address recipient, int24 tickLower, int24 tickUpper, uint128 amount0Requested, uint128 amount1Requested) external returns (uint128, uint128);\r\n    function positions(bytes32) external view returns (uint128, uint, uint, uint128, uint128);\r\n}\r\n\r\ncontract Keep3rV1Pair {\r\n    \r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;\r\n    \r\n    uint public totalSupply = 0;\r\n    \r\n    mapping(address => mapping (address => uint)) public allowance;\r\n    mapping(address => uint) public balanceOf;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n    \r\n    address public immutable token0;\r\n    address public immutable token1;\r\n    \r\n    address public immutable pool;\r\n    \r\n    address public governance;\r\n    address public pendingGovernance;\r\n\r\n    int24 constant tickLower = -887200;\r\n    int24 constant tickUpper = 887200;\r\n    \r\n    weth9 constant weth = weth9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    \r\n    uint24 immutable fee;\r\n    \r\n    function _safeTransfer(address token,address to,uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n    \r\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n\r\n    constructor(address _pool) {\r\n        pool = _pool;\r\n        address _token0 = univ3(_pool).token0();\r\n        address _token1 = univ3(_pool).token1();\r\n        token0 =  _token0;\r\n        token1 =  _token1;\r\n        fee = univ3(_pool).fee();\r\n        name = string(abi.encodePacked(\"Keep3rV1 - \", erc20(_token0).symbol(), \"/\", erc20(_token1).symbol()));\r\n        symbol = string(abi.encodePacked(\"kLP-\", erc20(_token0).symbol(), \"/\", erc20(_token1).symbol()));\r\n        governance = msg.sender;\r\n    }\r\n    \r\n    modifier gov() {\r\n        require(msg.sender == governance);\r\n        _;\r\n    }\r\n    \r\n    function setGovernance(address _governance) external gov {\r\n        pendingGovernance = _governance;\r\n    }\r\n    \r\n    function acceptGovernance() external {\r\n        require(msg.sender == pendingGovernance);\r\n        governance = pendingGovernance;\r\n    }\r\n\r\n    struct AddLiquidityParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        address recipient;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n    }\r\n    \r\n    struct MintCallbackData {\r\n        PoolAddress.PoolKey poolKey;\r\n        address payer;\r\n    }\r\n    \r\n    /// @notice Add liquidity to an initialized pool\r\n    function _addLiquidity(AddLiquidityParams memory params)\r\n        internal\r\n        returns (\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        )\r\n    {\r\n        PoolAddress.PoolKey memory poolKey =\r\n            PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee});\r\n            \r\n        // compute the liquidity amount\r\n        {\r\n            (uint160 sqrtPriceX96, , , , , , ) = univ3(pool).slot0();\r\n            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);\r\n            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);\r\n\r\n            liquidity = LiquidityAmounts.getLiquidityForAmounts(\r\n                sqrtPriceX96,\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                params.amount0Desired,\r\n                params.amount1Desired\r\n            );\r\n        }\r\n\r\n        (amount0, amount1) = univ3(pool).mint(\r\n            params.recipient,\r\n            params.tickLower,\r\n            params.tickUpper,\r\n            liquidity,\r\n            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))\r\n        );\r\n\r\n        require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');\r\n    }\r\n    \r\n    function _pay(\r\n        address token,\r\n        address payer,\r\n        address recipient,\r\n        uint256 value\r\n    ) internal {\r\n        if (token == address(weth) && address(this).balance >= value) {\r\n            // pay with WETH9\r\n            weth.deposit{value: value}(); // wrap only what is needed to pay\r\n            weth.transfer(recipient, value);\r\n        } else if (payer == address(this)) {\r\n            _safeTransfer(token, recipient, value);\r\n        } else {\r\n            _safeTransferFrom(token, payer, recipient, value);\r\n        }\r\n    }\r\n    \r\n    function _safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n    \r\n    function uniswapV3MintCallback(\r\n        uint256 amount0Owed,\r\n        uint256 amount1Owed,\r\n        bytes calldata data\r\n    ) external {\r\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\r\n        require(msg.sender == pool);\r\n        if (amount0Owed > 0) _pay(decoded.poolKey.token0, decoded.payer, pool, amount0Owed);\r\n        if (amount1Owed > 0) _pay(decoded.poolKey.token1, decoded.payer, pool, amount1Owed);\r\n    }\r\n    \r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(uint amount0Desired, uint amount1Desired, uint amount0Min, uint amount1Min, address to) external payable returns (uint128 liquidity) {\r\n       (liquidity,,) = _addLiquidity(AddLiquidityParams(token0, token1, fee, to, tickLower, tickUpper, amount0Desired, amount1Desired, amount0Min, amount1Min));\r\n       _mint(to, liquidity);\r\n       if (address(this).balance > 0) _safeTransferETH(msg.sender, address(this).balance);\r\n    }\r\n    \r\n    function collect() external gov returns (uint amount0, uint amount1) {\r\n        (,,,uint128 tokensOwed0, uint128 tokensOwed1) = univ3(pool).positions(keccak256(abi.encodePacked(address(this), tickLower, tickUpper)));\r\n        (amount0, amount1) = univ3(pool).collect(governance, tickLower, tickUpper, tokensOwed0, tokensOwed1);\r\n    }\r\n    \r\n    function burn(uint128 liquidity, uint amount0Min, uint amount1Min, address to) external returns (uint amount0, uint amount1) {\r\n        (amount0, amount1) = univ3(pool).burn(tickLower, tickUpper, liquidity);\r\n        require(amount0 >= amount0Min && amount1 >= amount1Min, 'Price slippage check');\r\n        univ3(pool).collect(to, tickLower, tickUpper, uint128(amount0), uint128(amount1));\r\n        _burn(msg.sender, liquidity);\r\n    }\r\n    \r\n    function _mint(address dst, uint amount) internal {\r\n        totalSupply += amount;\r\n        balanceOf[dst] += amount;\r\n        emit Transfer(address(0), dst, amount);\r\n    }\r\n        \r\n    function _burn(address dst, uint amount) internal {\r\n        totalSupply -= amount;\r\n        balanceOf[dst] -= amount;\r\n        emit Transfer(dst, address(0), amount);\r\n    }\r\n\r\n    function approve(address spender, uint amount) external returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint amount) external returns (bool) {\r\n        _transferTokens(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\r\n        address spender = msg.sender;\r\n        uint spenderAllowance = allowance[src][spender];\r\n\r\n        if (spender != src && spenderAllowance != type(uint).max) {\r\n            uint newAllowance = spenderAllowance - amount;\r\n            allowance[src][spender] = newAllowance;\r\n\r\n            emit Approval(src, spender, newAllowance);\r\n        }\r\n\r\n        _transferTokens(src, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transferTokens(address src, address dst, uint amount) internal {\r\n        balanceOf[src] -= amount;\r\n        balanceOf[dst] += amount;\r\n        \r\n        emit Transfer(src, dst, amount);\r\n    }\r\n}"}}}