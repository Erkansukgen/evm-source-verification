{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/IndexTrader_combined.sol":{"content":"\n// SPDX-License-Identifier: MIT\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\npragma solidity ^0.6.0;\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\npragma solidity ^0.6.0;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\npragma solidity ^0.6.2;\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\npragma solidity ^0.6.0;\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n}\n\n// File: contracts/interfaces/BMathInterface.sol\npragma solidity 0.6.12;\ninterface BMathInterface {\n  function calcInGivenOut(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 tokenAmountOut,\n    uint256 swapFee\n    ) external pure returns (uint256 tokenAmountIn);\n  function calcOutGivenIn(\n    uint tokenBalanceIn,\n    uint tokenWeightIn,\n    uint tokenBalanceOut,\n    uint tokenWeightOut,\n    uint tokenAmountIn,\n    uint swapFee\n    ) external pure returns (uint tokenAmountOut);\n}\n\n\n// File: contracts/interfaces/BPoolInterface.sol\npragma solidity 0.6.12;\ninterface BPoolInterface is IERC20,  BMathInterface {\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n  function getBalance(address) external view returns (uint256);\n  function getCommunityFee() external view returns (uint256, uint256, uint256, address);\n  function calcAmountWithCommunityFee(uint256, uint256, address) external view returns (uint256, uint256);\n  function getCurrentTokens() external view returns (address[] memory tokens);\n  function swapExactAmountIn(address, uint, address, uint, uint) external returns (uint, uint);\n  function getDenormalizedWeight(address token) external view returns (uint);\n  function getSwapFee() external view returns (uint);\n}\n\n// File: contracts/interfaces/TokenInterface.sol\npragma solidity 0.6.12;\ninterface TokenInterface is IERC20 {\n  function deposit() external payable;\n  function withdraw(uint256) external;\n}\n\n// File: contracts/interfaces/IUniswapV2Pair.sol\npragma solidity >=0.5.0;\ninterface IUniswapV2Pair {\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n  function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n  function token0() external view returns (address);\n}\n\n// File: contracts/lib/SafeMathUniswap.sol\npragma solidity =0.6.12;\nlibrary SafeMathUniswap {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\n// File: contracts/lib/UniswapV2Library.sol\npragma solidity >=0.5.0;\nlibrary UniswapV2Library {\n    using SafeMathUniswap for uint;\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n            ))));\n    }\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n    \n      // performs chained getAmountOut calculations on any number of pairs\n      function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n      ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n          (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n          amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n      }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n\ninterface IFreeFromUpTo is IERC20 {\n    function freeFromUpTo(address from, uint256 value) external returns(uint256 freed);\n}\n\n// File: contracts/EthPiptSwap.sol\npragma solidity 0.6.12;\ncontract IndexTokenTrader {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for TokenInterface;\n    using SafeERC20 for BPoolInterface;\n\n    address public owner;\n    mapping(address => bool) public whitelist;\n    TokenInterface public weth;\n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n    uint256 private defaultSlippage;\n\n    struct Trader {\n        address indexToken;    // TokenInterface and BPoolInterface . Same address as pipt, but for transfer, etc.\n        address tokenWethPool;       // TODO: Within functions using this, convert to IUniswapV2Pair or PoolInterface\n        bool isUniswap;\n        bool hasCommunityFee;\n    }\n\n    Trader[] public trader;\n\n    struct CalculationStruct {\n        uint256 tokenAmount;\n        uint256 ethAmount;\n        uint256 tokenReserve;\n        uint256 ethReserve;\n    }\n\n    constructor(TokenInterface _weth) public {\n        weth = _weth;\n        whitelist[msg.sender] = true;\n        owner = msg.sender;\n        defaultSlippage = 0.02 ether;\n    }\n\n    modifier onlyOwnerOrWhitelisted() {\n        require(whitelist[msg.sender] || (msg.sender == owner), \"NOT_ALLOWED\");\n        //require((msg.sender == owner) || (tx.origin == owner), \"NOT_OWNER\");\n        _;\n    }\n\n    modifier discountCHI(bool useCHI) {\n        if (useCHI) {\n            uint256 gasStart = gasleft();\n            _;\n            uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n\n            chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n        } else {\n            _;\n        }\n    }\n\n    receive() external payable {\n        if (msg.sender != tx.origin) {\n            return;\n        }\n        _refundLeftoverEth();\n    }\n\n    function addAddressToWhitelist(address addr) external onlyOwnerOrWhitelisted {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n        }\n    }\n\n    function removeAddressFromWhitelist(address addr) external onlyOwnerOrWhitelisted {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n        }\n    }\n\n    function addTrader(address _indexToken, address _tokenWethPool, bool _isUniswap, bool _hasCommunityFee) external onlyOwnerOrWhitelisted {\n        trader.push(Trader({\n            indexToken: _indexToken,\n            tokenWethPool: _tokenWethPool,\n            isUniswap: _isUniswap,\n            hasCommunityFee: _hasCommunityFee\n        }));\n    }\n\n    function updateTrader(uint256 _pid, address _indexToken, address _tokenWethPool, bool _isUniswap, bool _hasCommunityFee) external onlyOwnerOrWhitelisted {\n        trader[_pid].indexToken = _indexToken;\n        trader[_pid].tokenWethPool = _tokenWethPool;\n        trader[_pid].isUniswap = _isUniswap;\n        trader[_pid].hasCommunityFee = _hasCommunityFee;\n    }\n\n    // TODO: Do i need to use the useCHI modifier on all functions? Don't think so.\n    //buy_and_redeem(uint256,uint256,address[],bool)\n    function buy_and_redeem_tc_(uint256 _pid, uint256 minAmountOut, IUniswapV2Pair[] calldata _pairs, bool useCHI) external payable onlyOwnerOrWhitelisted discountCHI(useCHI) {\n        uint256 indexTokenOut;\n        if (trader[_pid].isUniswap) {\n            indexTokenOut = buy_uniswap(_pid, minAmountOut);\n        } else {\n            indexTokenOut =  buy_bpool(_pid, minAmountOut);\n        }\n\n        swapIndexToEth(_pid, indexTokenOut, _pairs);\n\n        _refundLeftoverEth();\n    }\n\n    function buy_uniswap(uint256 _pid, uint256 minAmountOut) private returns (uint256 indexTokenOut) {\n        /*\n            1. Wrap ETH to WETH\n            2. Trade WETH for PIPT via uniPool\n            3. Redeem PIPT for ETH via EthPiptSwap\n            4. Transfer remaining (W)ETH to wallet\n            minAmountOut is number of PIPT tokens\n        */\n\n        //BPoolInterface indexToken = BPoolInterface(trader[_pid].indexToken);\n        IUniswapV2Pair uniPool = IUniswapV2Pair(trader[_pid].tokenWethPool);\n        address token0 = uniPool.token0();\n        uint256 indexTokenReserve;\n        uint256 ethReserve;\n\n        if (token0 ==  address(weth)) {\n            (ethReserve, indexTokenReserve, ) = uniPool.getReserves();\n        } else {\n            (indexTokenReserve, ethReserve, ) = uniPool.getReserves();\n        }\n\n        indexTokenOut = UniswapV2Library.getAmountOut(\n            msg.value,             // amountIn       https://uniswap.org/docs/v2/smart-contracts/library/\n            ethReserve,            // reserveIn\n            indexTokenReserve     // reserveOut\n        );\n\n        require(indexTokenOut >= minAmountOut, \"limit out\");\n\n        weth.deposit{ value: msg.value }();\n\n        // Sell WETH for PIPT\n        weth.transfer(address(uniPool), msg.value );\n\n        // minAmountOut is amount of PIPT to receive\n        if (token0 == address(weth)) {\n            uniPool.swap(uint256(0), indexTokenOut, address(this), new bytes(0));   // amount0Out, amount1Out\n        } else {\n            uniPool.swap(indexTokenOut, uint256(0), address(this), new bytes(0));\n        }\n\n    }\n\n    function buy_bpool(uint256 _pid, uint256 minAmountOut) private returns (uint256 indexTokenOut) {\n        /*\n            1. Wrap ETH to WETH\n            2. Trade WETH for PIPT via bPool\n            3. Redeem PIPT for ETH via EthPiptSwap\n            4. Transfer remaining (W)ETH to wallet\n        */\n\n        TokenInterface indexToken = TokenInterface(trader[_pid].indexToken);\n        BPoolInterface bPool = BPoolInterface(trader[_pid].tokenWethPool);\n\n        weth.deposit{ value: msg.value }();\n\n        //_bPoolTrade(trader.bPool, weth, trader.piptToken, minAmountOut);\n\n        //uint tokenInBalance = weth.balanceOf(address(this));\n\n        // Approve spending of tokenIn by bPool if necessary\n        if (weth.allowance(address(this), address(bPool)) < msg.value) {\n            weth.approve(address(bPool), type(uint).max);\n        }\n\n        bPool.swapExactAmountIn(\n            address(weth),\n            msg.value,\n            address(indexToken),\n            minAmountOut,\n            type(uint).max\n        );\n\n        indexTokenOut = indexToken.balanceOf(address(this));\n    }\n\n\n    // mint_and_sell(uint256,uint256,uint256,address[],bool)\n    function mint_and_sell_4bY(uint256 _pid, uint256 _poolAmountOut, uint256 minAmountOut, IUniswapV2Pair[] calldata _pairs, bool useCHI) external payable onlyOwnerOrWhitelisted discountCHI(useCHI) {\n        if (trader[_pid].isUniswap) {\n            mint_and_sell_uniswap(_pid, _poolAmountOut, minAmountOut, _pairs);\n        } else {\n            mint_and_sell_bpool(_pid, _poolAmountOut, minAmountOut, _pairs);\n        }\n        _refundLeftoverEth();\n    }\n\n    function mint_and_sell_uniswap(\n        uint256 _pid, uint256 _poolAmountOut, uint256 minAmountOut, IUniswapV2Pair[] calldata _pairs) private {\n        /*\n            1. Swap ETH for _poolAmountOut PIPT via EthPiptSwap\n            2. Trade _poolAmountOut PIPT for WETH via uniPool\n            3. Transfer remaining (W)ETH to wallet\n        */\n\n        //TraderInfo storage trader = traderInfo[_pid];\n        BPoolInterface indexToken = BPoolInterface(trader[_pid].indexToken);\n        IUniswapV2Pair uniPool = IUniswapV2Pair(trader[_pid].tokenWethPool);\n        address token0 = uniPool.token0();\n        uint256 indexTokenReserve;\n        uint256 ethReserve;\n        uint256 ethOut;\n\n        if (token0 ==  address(weth)) {\n            (ethReserve, indexTokenReserve, ) = uniPool.getReserves();\n        } else {\n            (indexTokenReserve, ethReserve, ) = uniPool.getReserves();\n        }\n        \n        uint256 poolAmountOutAfterFee;\n        if (trader[_pid].hasCommunityFee) {\n            (, uint256 communityJoinFee, , ) = indexToken.getCommunityFee();\n            (poolAmountOutAfterFee, ) = indexToken.calcAmountWithCommunityFee(_poolAmountOut, communityJoinFee, address(this));\n        } else {\n            poolAmountOutAfterFee = _poolAmountOut;\n        }\n\n        ethOut = UniswapV2Library.getAmountOut(\n            poolAmountOutAfterFee,           // amountIn       TODO: Needs to be _poolAmountOutAfterFee\n            indexTokenReserve,        // reserveIn\n            ethReserve                // reserveOut\n        );\n\n        require(ethOut >= minAmountOut, \"limit out\");\n        \n        weth.deposit{ value: msg.value }();\n\n        swapEthToIndexByPoolOut(indexToken, _poolAmountOut, _pairs);         // Mint PIPT - In ETH Out PIPT\n\n        // Sell PIPT for ETH\n        //uint tokenInBalance = indexToken.balanceOf(address(this));\n        indexToken.transfer(address(uniPool), poolAmountOutAfterFee);\n\n        // minAmountOut is amount of ETH to receive\n        if (token0 == address(weth)) {\n            uniPool.swap(ethOut, uint256(0), address(this), new bytes(0));\n        } else {\n            uniPool.swap(uint256(0), ethOut, address(this), new bytes(0));\n        }\n    }\n\n    function mint_and_sell_bpool(\n        uint256 _pid, uint256 _poolAmountOut, uint256 minAmountOut, IUniswapV2Pair[] calldata _pairs) private {\n        /*\n            1. Swap ETH for _poolAmountOut PIPT via EthPiptSwap\n            2. Trade _poolAmountOut PIPT for WETH via bPool\n            3. Transfer remaining (W)ETH to wallet\n        */\n\n        BPoolInterface indexToken = BPoolInterface(trader[_pid].indexToken);\n        BPoolInterface bPool = BPoolInterface(trader[_pid].tokenWethPool);\n        uint256 ethOut;\n\n        uint256 poolAmountOutAfterFee;\n        if (trader[_pid].hasCommunityFee) {\n            (, uint256 communityJoinFee, , ) = indexToken.getCommunityFee();\n            (poolAmountOutAfterFee, ) = indexToken.calcAmountWithCommunityFee(_poolAmountOut, communityJoinFee, address(this));\n        } else {\n            poolAmountOutAfterFee = _poolAmountOut;\n        }\n\n        ethOut = bPool.calcOutGivenIn(\n            bPool.getBalance(address(indexToken)),\n            bPool.getDenormalizedWeight(address(indexToken)),\n            bPool.getBalance(address(weth)),\n            bPool.getDenormalizedWeight(address(weth)),\n            poolAmountOutAfterFee,\n            bPool.getSwapFee()\n        );\n\n        require(ethOut >= minAmountOut, \"limit out\");\n        \n        weth.deposit{ value: msg.value }();\n\n        swapEthToIndexByPoolOut(indexToken, _poolAmountOut, _pairs);         // Mint PIPT - In ETH Out PIPT\n\n        // Approve spending of tokenIn by bPool if necessary\n        if (indexToken.allowance(address(this), address(bPool)) < poolAmountOutAfterFee) {\n            indexToken.approve(address(bPool), type(uint).max);\n        }\n\n        bPool.swapExactAmountIn(\n            address(indexToken),\n            poolAmountOutAfterFee,\n            address(weth),\n            minAmountOut,\n            type(uint).max\n        );\n    }\n\n    function swapEthToIndexByPoolOut(BPoolInterface indexToken, uint256 _poolAmountOut, IUniswapV2Pair[] calldata _pairs) private  {\n\n        uint256 ratio = _poolAmountOut.mul(1 ether).div(indexToken.totalSupply()).add(10);  // .add(10) -> Makes sure to not fail at joinPool maxAmountsIn\n\n        address[] memory tokens = indexToken.getCurrentTokens();\n        uint256 len = tokens.length;\n\n        // CalculationStruct[] memory calculations = new CalculationStruct[](len);\n        uint256[] memory tokensInIndex = new uint256[](len);\n\n        uint256 totalEthSwap = 0;\n        for (uint256 i = 0; i < len; i++) {\n            (uint256 amountToPool, uint256 ethAmountIn) = _getSwapAmountsForJoin(\n                indexToken,\n                tokens[i],\n                _pairs[i],\n                ratio\n            );\n            \n            weth.safeTransfer(address(_pairs[i]), ethAmountIn);\n\n            _swap(_pairs[i], amountToPool);\n\n            tokensInIndex[i] = amountToPool;\n            totalEthSwap = totalEthSwap.add(ethAmountIn);\n\n            if (TokenInterface(tokens[i]).allowance(address(this), address(indexToken)) < tokensInIndex[i]) {\n                TokenInterface(tokens[i]).approve(address(indexToken), type(uint).max);\n            }\n        }\n\n        indexToken.joinPool(_poolAmountOut, tokensInIndex);\n    }\n\n    function swapIndexToEth(uint256 _pid, uint256 _poolAmountIn, IUniswapV2Pair[] calldata _pairs) private {\n        BPoolInterface indexToken = BPoolInterface(trader[_pid].indexToken);\n\n        address[] memory tokens = indexToken.getCurrentTokens();\n\n        uint256 len = tokens.length;\n        (uint256[] memory tokensOutIndex, uint256[] memory ethOutUniswap, ) =\n        calcSwapIndexToEthInputs(indexToken, _poolAmountIn, trader[_pid].hasCommunityFee, _pairs);\n\n        //indexToken.safeTransferFrom(msg.sender, address(this), _poolAmountIn); // Not necessary..\n        if (indexToken.allowance(address(this), address(indexToken)) < _poolAmountIn) {\n            indexToken.approve(address(indexToken), type(uint).max);\n        }\n        //indexToken.approve(address(indexToken), _poolAmountIn);\n        indexToken.exitPool(_poolAmountIn, tokensOutIndex);\n\n        for (uint256 i = 0; i < len; i++) {\n            TokenInterface(tokens[i]).safeTransfer(address(_pairs[i]), tokensOutIndex[i]);\n\n            address token0 = _pairs[i].token0();\n            if (token0 == tokens[i]) {\n                _pairs[i].swap(uint256(0), ethOutUniswap[i], address(this), new bytes(0));\n            } else {\n                _pairs[i].swap(ethOutUniswap[i], uint256(0), address(this), new bytes(0));\n            }\n\n        }\n        // Happens in _refundLeftoverEth\n        // // return totalEthOut;\n        // weth.withdraw(totalEthOut);\n        // msg.sender.transfer(totalEthOut);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwnerOrWhitelisted {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        owner = payable(newOwner);\n    }\n\n    function calcSwapIndexToEthInputs(BPoolInterface indexToken, uint256 _poolAmountIn, bool _hasCommunityFee, IUniswapV2Pair[] calldata _pairs) public view\n    returns (uint256[] memory tokensOutIndex, uint256[] memory ethOutUniswap, uint256 totalEthOut)\n    {\n        //BPoolInterface indexToken = BPoolInterface(trader[_pid].indexToken);\n\n        address[] memory _tokens = indexToken.getCurrentTokens();\n        tokensOutIndex = new uint256[](_tokens.length);\n        ethOutUniswap = new uint256[](_tokens.length);\n\n        uint256 poolAmountInAfterFee;\n        if (_hasCommunityFee) {\n            (, , uint256 communityExitFee, ) = indexToken.getCommunityFee();\n            (poolAmountInAfterFee, ) = indexToken.calcAmountWithCommunityFee(_poolAmountIn, communityExitFee, address(this));\n        } else {\n            poolAmountInAfterFee = _poolAmountIn;\n        }\n\n        uint256 poolRatio = poolAmountInAfterFee.mul(1 ether).div(indexToken.totalSupply());\n\n        totalEthOut = 0;\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            tokensOutIndex[i] = poolRatio.mul(indexToken.getBalance(_tokens[i])).div(1 ether);\n\n            uint256 tokenReserve;\n            uint256 ethReserve;\n\n            address token0 = _pairs[i].token0();\n            if (token0 == address(weth)) {\n                (ethReserve, tokenReserve, ) = _pairs[i].getReserves();\n            } else {\n                (tokenReserve, ethReserve, ) = _pairs[i].getReserves();\n            }\n\n            ethOutUniswap[i] = UniswapV2Library.getAmountOut(tokensOutIndex[i], tokenReserve, ethReserve);\n            totalEthOut = totalEthOut.add(ethOutUniswap[i]);\n        }\n    }\n\n    function calcSwapEthToIndexInputs(BPoolInterface indexToken, uint256 _ethValue, IUniswapV2Pair[] calldata _pairs)\n        external view returns (uint256[] memory ethInUniswap, uint256 poolOut)\n    {\n        //BPoolInterface indexToken = BPoolInterface(trader[_pid].indexToken);\n        address[] memory _tokens = indexToken.getCurrentTokens();\n        // Should be passed in function\n        //_ethValue = _ethValue.sub(_ethValue.mul(defaultSlippage).div(1 ether));\n\n        // get shares and eth required for each share\n        CalculationStruct[] memory calculations = new CalculationStruct[](_tokens.length);\n\n        uint256 totalEthRequired = 0;\n        {\n            // get pool out for 1 ether as 100% for calculate shares\n            // poolOut by 1 ether first token join = piptTotalSupply.mul(1 ether).div(pipt.getBalance(_tokens[0]))\n            // poolRatio = poolOut/totalSupply\n            uint256 totalSupply = indexToken.totalSupply();\n            uint256 poolRatio = totalSupply.mul(1 ether).div(indexToken.getBalance(_tokens[0])).mul(1 ether).div(totalSupply);\n            //uint256 x = 1;\n            //uint256 poolRatio = x.mul(1 ether).div(indexToken.getBalance(_tokens[0]));\n\n            for (uint256 i = 0; i < _tokens.length; i++) {\n            // token share relatively 1 ether of first token\n                calculations[i].tokenAmount = poolRatio.mul(indexToken.getBalance(_tokens[i])).div(1 ether);\n\n                address token0 = _pairs[i].token0();\n                if (token0 == address(weth)) {\n                    (calculations[i].ethReserve, calculations[i].tokenReserve, ) = _pairs[i].getReserves();\n                } else {\n                    (calculations[i].tokenReserve, calculations[i].ethReserve, ) = _pairs[i].getReserves();\n                }\n\n                calculations[i].ethAmount = UniswapV2Library.getAmountIn(\n                    calculations[i].tokenAmount,\n                    calculations[i].ethReserve,\n                    calculations[i].tokenReserve\n                );\n                totalEthRequired = totalEthRequired.add(calculations[i].ethAmount);\n            }\n        }\n\n        // // calculate eth and tokensIn based on shares and normalize if totalEthRequired more than 100%\n        //uint256[] memory tokensInPipt = new uint256[](_tokens.length);\n        ethInUniswap = new uint256[](_tokens.length);\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            ethInUniswap[i] = _ethValue.mul(calculations[i].ethAmount.mul(1 ether).div(totalEthRequired)).div(1 ether);\n            //tokensInPipt[i] = calculations[i].tokenAmount.mul(_ethValue.mul(1 ether).div(totalEthRequired)).div(1 ether);\n        }\n\n        // uint256 token0Balance = indexToken.getBalance(_tokens[0]);\n        uint256 token0Out = calculations[0].tokenAmount.mul(_ethValue.mul(1 ether).div(totalEthRequired)).div(1 ether);\n        poolOut = indexToken.totalSupply().mul(token0Out).div(indexToken.getBalance(_tokens[0]));\n    }\n\n    function _refundLeftoverEth() private {\n        uint wethBalance = weth.balanceOf(address(this));\n\n        if (wethBalance > 0) {\n            weth.withdraw(wethBalance);\n        }\n\n        uint ethBalance = address(this).balance;\n\n        if (ethBalance > 0) {\n            (bool success,) = msg.sender.call{ value: ethBalance }(\"\");\n            require(success, \"ERR_ETH_FAILED\");\n        }\n    }\n\n    function withdrawEth_cfq() external onlyOwnerOrWhitelisted {\n        (bool success, ) = msg.sender.call{ value: address(this).balance }(\"\");\n        require(success, \"Transfer failed.\");\n    }\n\n    function withdrawErc20(IERC20 token) external onlyOwnerOrWhitelisted {\n        uint erc20Balance = token.balanceOf(address(this));\n        token.transfer(msg.sender, erc20Balance);\n    }\n\n    function _getSwapAmountsForJoin(BPoolInterface indexToken, address poolToken, IUniswapV2Pair pair, uint256 ratio) \n        private view returns (uint256 amountToPool, uint256 ethAmountIn) {\n        address token0 = pair.token0();\n        uint256 ethReserve;\n        uint256 tokenReserve;\n        if (token0 == address(weth)) {\n            (ethReserve, tokenReserve, ) = pair.getReserves();\n        } else {\n            (tokenReserve, ethReserve, ) = pair.getReserves();\n        }\n\n        amountToPool = ratio.mul(indexToken.getBalance(poolToken)).div(1 ether);\n        ethAmountIn = UniswapV2Library.getAmountIn(\n            amountToPool,                 // amountOut\n            ethReserve,       // reserveIn\n            tokenReserve      // reserveOut\n        );\n    }\n    \n    function _swap(IUniswapV2Pair pair, uint256 amountToPool) private {\n        address token0 = pair.token0();\n        if (token0 == address(weth)) {\n            pair.swap(uint256(0), amountToPool, address(this), new bytes(0));\n        } else {\n            pair.swap(amountToPool, uint256(0), address(this), new bytes(0));\n        }      \n    }\n\n            \n\n}\n\n\n/*\n  TODO:\n    - Move calcSwapEthToPiptInputs to offline function\n    - Change calcSwapPiptToEthInputs to private and create an offline version as well\n    - replace swap with swapExactTokens.. --> Not necessary since I calculate exactly what I need here.\n    - add struct with pipt info to make it generic\n      -> Include commuunity fee check\n      -> include tokens\n      ->\n\n*/"}}}