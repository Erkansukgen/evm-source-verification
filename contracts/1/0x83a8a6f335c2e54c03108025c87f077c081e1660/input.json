{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Invite.sol": {
      "content": "// File: contracts/storage/InviteStorage.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nlibrary InviteStorage {\n\n    bytes32 public constant sSlot = keccak256(\"InviteStorage.storage.location\");\n\n    struct Storage{\n        address owner;\n        uint256 lastId;\n        mapping(uint256 => address)  indexs;\n        mapping(address => address)  inviter;\n        mapping(address => address[])  inviterList;\n        mapping(address => bool)  whiteListed;\n        mapping(address => uint256)  userIndex;\n    }\n\n    function load() internal pure returns (Storage storage s) {\n        bytes32 loc = sSlot;\n        assembly {\n        s_slot := loc\n        }\n    }\n\n}\n\n// File: contracts/market/Invite.sol\n\n\npragma solidity ^0.6.12;\n\n\n\ncontract Invite {\n\n\n    constructor(uint256 index)public{\n        init(index);\n    }\n    modifier onlyOwner() {\n        require(InviteStorage.load().owner == msg.sender, \"Invite.onlyOwner: caller is not the owner\");\n        _;\n    }\n\n    function init(uint256 index)public{\n        require(InviteStorage.load().owner==address(0),'Invite.init: already initialised');\n        InviteStorage.load().owner=msg.sender;\n        InviteStorage.load().lastId = index;\n    }\n\n    function owner()public view returns(address){\n        return InviteStorage.load().owner;\n    }\n\n    function setWhiteList(address[] memory users) public onlyOwner{\n        InviteStorage.Storage storage inviteData=InviteStorage.load();\n        for(uint256 i=0;i<users.length;i++){\n            address user=users[i];\n            inviteData.whiteListed[user] = true;\n            if(inviteData.userIndex[user] == 0){\n                inviteData.userIndex[user] = inviteData.lastId;\n                inviteData.indexs[inviteData.lastId] = user;\n                inviteData.lastId = inviteData.lastId + 1;\n            }\n        }\n\n    }\n\n    function setInviteUser(address inviteUser) public{\n        InviteStorage.Storage storage inviteData=InviteStorage.load();\n        require(!inviteData.whiteListed[msg.sender], 'whiteList user cannot be invited');\n        if(inviteData.userIndex[msg.sender] == 0){\n            inviteData.userIndex[msg.sender] = inviteData.lastId;\n            inviteData.indexs[inviteData.lastId] = msg.sender;\n            inviteData.lastId = inviteData.lastId + 1;\n        }\n\n        if(inviteData.whiteListed[inviteUser] || inviteData.inviter[inviteUser] != address(0)){\n            inviteData.inviter[msg.sender] = inviteUser;\n            inviteData.inviterList[inviteUser].push(msg.sender);\n        }\n    }\n\n    function getInviteCount(address user) external view returns (uint256) {\n        return InviteStorage.load().inviterList[user].length;\n    }\n\n    function lastId()public view returns(uint256){\n        return InviteStorage.load().lastId;\n    }\n\n    function indexs(uint256 id)public view returns(address){\n        return InviteStorage.load().indexs[id];\n    }\n\n    function inviter(address user)public view returns(address){\n        return InviteStorage.load().inviter[user];\n    }\n\n    function inviterList(address user)public view returns(address[] memory){\n        return InviteStorage.load().inviterList[user];\n    }\n\n    function whiteListed(address user)public view returns(bool){\n        return InviteStorage.load().whiteListed[user];\n    }\n\n    function userIndex(address user)public view returns(uint256){\n        return InviteStorage.load().userIndex[user];\n    }\n}\n"
    }
  }
}