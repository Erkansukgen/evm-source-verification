{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/UniLikeDexTrader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n}\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256) external;\n}\n\ninterface IUniswapV2Pair {\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\nlibrary TransferHelper {\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\nlibrary DexLibrary {\n    using SafeMath for uint256;\n\n    // feeRate 按 10000 计算, 如果千分之三，则 feeRate 输入 9970\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut, uint256 feeRate) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, 'DexBotHelper: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'DexBotHelper: INSUFFICIENT_LIQUIDITY');\n        uint256 amountInWithFee = amountIn.mul(feeRate);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(10000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // feeRate 按 10000 计算, 如果千分之三，则 feeRate 输入 9970\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut, uint256 feeRate) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, 'DexBotHelper: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'DexBotHelper: INSUFFICIENT_LIQUIDITY');\n        uint256 numerator = reserveIn.mul(amountOut).mul(10000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(feeRate);\n        amountIn = (numerator / denominator).add(1);\n    }\n}\n\ncontract Ownable {\n    address public immutable owner;\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    receive() external payable {}\n\n    function withdraw(address token, address to) public onlyOwner {\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n    }\n\n    function withdrawETH(address to) public onlyOwner {\n        TransferHelper.safeTransferETH(to, address(this).balance);\n    }\n\n    function call(address payable _to, uint256 _value, bytes calldata _data) external onlyOwner payable returns (bytes memory) {\n        require(_to != address(0));\n        (bool _success, bytes memory _result) = _to.call{value: _value}(_data);\n        require(_success);\n        return _result;\n    }\n}\n\ncontract UniLikeDexTrader is IUniswapV2Callee, Ownable {\n    using SafeMath for uint256;\n    enum Direction {\n        BorrowToken0FromPair0,\n        BorrowToken1FromPair0,\n        BorrowToken0FromPair1,\n        BorrowToken1FromPair1\n    }\n\n    address public immutable WETH;\n\n    constructor(address _WETH) {\n        WETH = _WETH;\n    }\n\n    function sortToken(address tokenA, address tokenB) public pure returns (address token0, address token1) {\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    }\n\n    // 根据 factory 和 token，获取池子的地址\n    function getPairs(\n        address factory0,\n        address factory1,\n        address token0, \n        address token1) public view returns (address, address) {\n        require(token0 < token1, \"token0 < token1\");\n        address pair0 = IUniswapV2Factory(factory0).getPair(token0, token1);\n        address pair1 = IUniswapV2Factory(factory1).getPair(token0, token1);\n        require(pair0 != address(0) && pair1 != address(0), \"Requested _token is not available.\");\n        return (pair0, pair1);\n    }\n\n    // 获取池子的余额\n    function getPairReserves(address pair0, address pair1) public view returns (uint256, uint256, uint256, uint256) {\n        (uint pair0Reserve0, uint pair0Reserve1, ) = IUniswapV2Pair(pair0).getReserves();\n        (uint pair1Reserve0, uint pair1Reserve1, ) = IUniswapV2Pair(pair1).getReserves();\n        return (pair0Reserve0, pair0Reserve1, pair1Reserve0, pair1Reserve1);\n    }\n\n    // 执行套利操作\n    // 节省gas，直接用pair，不用factory\n    function executeSwap(\n        address pair0,\n        address pair1,\n        address token0, \n        address token1, \n        uint256 amount,\n        Direction direction,\n        uint256 profitMin,\n        uint256 feeToCoinbase, // 付给旷工的fee\n        uint256 deadline) public onlyOwner {\n        // 判断超过了时间就不执行了\n        require(deadline >= block.timestamp);\n        // 获取池子余额\n        (uint256 pair0Reserve0, uint256 pair0Reserve1, uint256 pair1Reserve0, uint256 pair1Reserve1) = getPairReserves(pair0, pair1);\n\n        // 防止 Stack too deep，用数组保存\n        // addresses[0]：borrowPair\n        // addresses[1]：swapPair\n        // addresses[2]：borrowToken\n        // addresses[3]：swapToken\n        address[] memory addresses = new address[](4);\n        \n        // 防止 Stack too deep，用数组保存\n        // data[0]：amount，借的 token 的数量\n        // data[1]：profitMin，最小套利的数量\n        // data[2]：feeToCoinbase，付给矿工的小费(ETH gwei)\n        // data[3]：borrowReserveIn\n        // data[4]：borrowReserveOut\n        // data[5]：swapReserveIn\n        // data[6]：swapReserveOut\n        uint256[] memory data = new uint256[](7);\n        data[0] = amount;\n        data[1] = profitMin;\n        data[2] = feeToCoinbase;\n        if (direction == Direction.BorrowToken0FromPair0) {\n            // 从 Pair0 借 token0，在 Pair1 用 token0 换 token1，在 Pair0 还 token1\n            addresses[0] = pair0;\n            addresses[1] = pair1;\n            addresses[2] = token0;\n            addresses[3] = token1;\n            data[3] = pair0Reserve1;\n            data[4] = pair0Reserve0;\n            data[5] = pair1Reserve0;\n            data[6] = pair1Reserve1;\n        } else if (direction == Direction.BorrowToken1FromPair0) {\n            // 从 Pair0 借 token1，在 Sushiswap 用 token1 换 token0，在 Pair0 还 token0\n            addresses[0] = pair0;\n            addresses[1] = pair1;\n            addresses[2] = token1;\n            addresses[3] = token0;\n            data[3] = pair0Reserve0;\n            data[4] = pair0Reserve1;\n            data[5] = pair1Reserve1;\n            data[6] = pair1Reserve0;\n        } else if (direction == Direction.BorrowToken0FromPair1) {\n            // 从 Pair1 借 token0，在 Pair0 用 token0 换 token1，在 Pair1 还 token1\n            addresses[0] = pair1;\n            addresses[1] = pair0;\n            addresses[2] = token0;\n            addresses[3] = token1;\n            data[3] = pair1Reserve1;\n            data[4] = pair1Reserve0;\n            data[5] = pair0Reserve0;\n            data[6] = pair0Reserve1;\n        } else {\n            // 从 Pair1 借 token1，在 Pair0 用 token1 换 token0，在 Pair1 还 token0\n            addresses[0] = pair1;\n            addresses[1] = pair0;\n            addresses[2] = token1;\n            addresses[3] = token0;\n            data[3] = pair1Reserve0;\n            data[4] = pair1Reserve1;\n            data[5] = pair0Reserve1;\n            data[6] = pair0Reserve0;\n        }\n        executeSwap2(addresses, direction, data);\n    }\n\n    function executeSwap2(\n        address[] memory addresses,\n        Direction direction,\n        uint256[] memory data\n        ) internal {\n        // 根据借的amount，算出需要换多少\n        uint256 repayAmount = DexLibrary.getAmountIn(data[0], data[3], data[4], 9970);\n        // 根据借的amount，算出能兑换多少\n        uint256 swapAmount = DexLibrary.getAmountOut(data[0], data[5], data[6], 9970);\n        // 判断套利空间\n        require(repayAmount.add(data[1]) < swapAmount);\n\n        bytes memory encodeData = abi.encode(\n            addresses,\n            data[0],\n            swapAmount,\n            repayAmount,\n            data[2]\n        );\n        if (direction == Direction.BorrowToken0FromPair0 || direction == Direction.BorrowToken0FromPair1) {\n            // 借 token0\n            IUniswapV2Pair(addresses[0]).swap(data[0], 0, address(this), encodeData);\n        } else {\n            // 借 token1\n            IUniswapV2Pair(addresses[0]).swap(0, data[0], address(this), encodeData);\n        }\n    }\n\n    // Uniswap、Sushiswap闪电贷回调接口\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external override {\n        require(tx.origin == owner);\n        swapRealCall(data);\n    }\n\n    // 闪电贷执行兑换和还币的逻辑\n    function swapRealCall(bytes calldata data) internal {\n        (\n            address[] memory addresses, \n            uint256 amount,\n            uint256 swapAmount, \n            uint256 repayAmount,\n            uint256 feeToCoinbase\n        ) = abi.decode(data, (address[], uint256, uint256, uint256, uint256));\n        // addresses[0]：borrowPair\n        // addresses[1]：swapPair\n        // addresses[2]：borrowToken\n        // addresses[3]：swapToken\n        // 先把借来的 token 转移到兑换的池子\n        TransferHelper.safeTransfer(addresses[2], addresses[1], amount);\n        (address token0,) = sortToken(addresses[2], addresses[3]);\n        (uint amount0Out, uint amount1Out) = addresses[2] == token0 ? (uint256(0), swapAmount) : (swapAmount, uint256(0));\n        // 在兑换池执行兑换\n        IUniswapV2Pair(addresses[1]).swap(amount0Out, amount1Out, address(this), new bytes(0));\n        // 这时兑换的池子应该给当前的池子转了兑换的代币，需要把代币还给借币的池子\n        TransferHelper.safeTransfer(addresses[3], addresses[0], repayAmount);\n        // 如果兑换的是 WETH，则把套利的 WETH 换成 ETH\n        if (addresses[3] == WETH) {\n            IWETH(WETH).withdraw(swapAmount.sub(repayAmount));\n        }\n        // 付小费给旷工\n        if (feeToCoinbase > 0) {\n            block.coinbase.transfer(feeToCoinbase);\n        }\n    }\n}\n"
    }
  }
}