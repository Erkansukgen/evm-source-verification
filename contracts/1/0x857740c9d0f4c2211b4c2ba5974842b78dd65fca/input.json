{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Cycle.sol":{"content":"pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\nimport \"./IGroupSchema.sol\";\nimport \"./StorageOwners.sol\";\n\ncontract Cycles is IGroupSchema, StorageOwners {\n    // list of Group Cycles\n    Cycle[] private Cycles;\n    CycleFinancial[] private CycleFinancials;\n\n    //Mapping that enables ease of traversal of the cycle records. Key is cycle id\n    mapping(uint256 => RecordIndex) private CycleIndexer;\n\n    //Mapping that enables ease of traversal of cycle records by the group. key is group id\n    mapping(uint256 => RecordIndex[]) private GroupCycleIndexer;\n\n    //Mapping that enables ease of traversal of the cycle financials records. Key is cycle id\n    mapping(uint256 => RecordIndex) private CycleFinancialsIndexer;\n\n    //Mapping that enables ease of traversal of cycle financials records by the group. key is group id\n    mapping(uint256 => RecordIndex[]) private GroupCycleFinancialsIndexer;\n\n    CycleMember[] private CycleMembers;\n\n    //Mapping of a cycle members. key is the cycle id\n    mapping(uint256 => RecordIndex[]) private CycleMembersIndexer;\n    //Mapping of a cycle members, key is depositor address\n    mapping(address => RecordIndex[]) private CycleMembersIndexerByDepositor;\n    //Mapping that enables easy traversal of cycle members in a group. outer key is the cycle id, inner key is the member address\n    mapping(uint256 => mapping(address => RecordIndex))\n        private CycleMembersDeepIndexer;\n\n    uint256 lastCycleId;\n\n    function getCycleInfoByIndex(uint256 index)\n        external\n        view\n        returns (\n            uint256 id,\n            uint256 groupId,\n            uint256 numberOfDepositors,\n            uint256 cycleStartTimeStamp,\n            uint256 cycleDuration,\n            uint256 maximumSlots,\n            bool hasMaximumSlots,\n            uint256 cycleStakeAmount,\n            uint256 totalStakes,\n            uint256 stakesClaimed,\n            CycleStatus cycleStatus,\n            uint256 stakesClaimedBeforeMaturity\n        )\n    {\n        Cycle memory cycle = Cycles[index];\n\n        return (\n            cycle.id,\n            cycle.groupId,\n            cycle.numberOfDepositors,\n            cycle.cycleStartTimeStamp,\n            cycle.cycleDuration,\n            cycle.maximumSlots,\n            cycle.hasMaximumSlots,\n            cycle.cycleStakeAmount,\n            cycle.totalStakes,\n            cycle.stakesClaimed,\n            cycle.cycleStatus,\n            cycle.stakesClaimedBeforeMaturity\n        );\n    }\n\n    function getCycleInfoById(uint256 cycleId)\n        external\n        view\n        returns (\n            uint256 id,\n            uint256 groupId,\n            uint256 numberOfDepositors,\n            uint256 cycleStartTimeStamp,\n            uint256 cycleDuration,\n            uint256 maximumSlots,\n            bool hasMaximumSlots,\n            uint256 cycleStakeAmount,\n            uint256 totalStakes,\n            uint256 stakesClaimed,\n            CycleStatus cycleStatus,\n            uint256 stakesClaimedBeforeMaturity\n        )\n    {\n        uint256 index = _getCycleIndex(cycleId);\n\n        Cycle memory cycle = Cycles[index];\n\n        return (\n            cycle.id,\n            cycle.groupId,\n            cycle.numberOfDepositors,\n            cycle.cycleStartTimeStamp,\n            cycle.cycleDuration,\n            cycle.maximumSlots,\n            cycle.hasMaximumSlots,\n            cycle.cycleStakeAmount,\n            cycle.totalStakes,\n            cycle.stakesClaimed,\n            cycle.cycleStatus,\n            cycle.stakesClaimedBeforeMaturity\n        );\n    }\n\n    function getCycleFinancialsByIndex(uint256 index)\n        external\n        view\n        returns (\n            uint256 cycleId,\n            uint256 underlyingTotalDeposits,\n            uint256 underlyingTotalWithdrawn,\n            uint256 underlyingBalance,\n            uint256 derivativeBalance,\n            uint256 underylingBalanceClaimedBeforeMaturity,\n            uint256 derivativeBalanceClaimedBeforeMaturity\n        )\n    {\n        CycleFinancial memory cycleFinancial = CycleFinancials[index];\n\n        return (\n            cycleFinancial.cycleId,\n            cycleFinancial.underlyingTotalDeposits,\n            cycleFinancial.underlyingTotalWithdrawn,\n            cycleFinancial.underlyingBalance,\n            cycleFinancial.derivativeBalance,\n            cycleFinancial.underylingBalanceClaimedBeforeMaturity,\n            cycleFinancial.derivativeBalanceClaimedBeforeMaturity\n        );\n    }\n\n    function getCycleFinancialsByCycleId(uint256 cycleId)\n        external\n        view\n        returns (\n            uint256 underlyingTotalDeposits,\n            uint256 underlyingTotalWithdrawn,\n            uint256 underlyingBalance,\n            uint256 derivativeBalance,\n            uint256 underylingBalanceClaimedBeforeMaturity,\n            uint256 derivativeBalanceClaimedBeforeMaturity\n        )\n    {\n        uint256 index = _getCycleFinancialIndex(cycleId);\n        CycleFinancial memory cycleFinancial = CycleFinancials[index];\n\n        return (\n            cycleFinancial.underlyingTotalDeposits,\n            cycleFinancial.underlyingTotalWithdrawn,\n            cycleFinancial.underlyingBalance,\n            cycleFinancial.derivativeBalance,\n            cycleFinancial.underylingBalanceClaimedBeforeMaturity,\n            cycleFinancial.derivativeBalanceClaimedBeforeMaturity\n        );\n    }\n\n    function getCycleMember(uint256 index)\n        external\n        view\n        returns (\n            uint256 cycleId,\n            uint256 groupId,\n            address payable _address,\n            uint256 totalLiquidityAsPenalty,\n            uint256 numberOfCycleStakes,\n            uint256 stakesClaimed,\n            bool hasWithdrawn\n        )\n    {\n        CycleMember memory cycleMember = _getCycleMember(index);\n\n        return (\n            cycleMember.cycleId,\n            cycleMember.groupId,\n            cycleMember._address,\n            cycleMember.totalLiquidityAsPenalty,\n            cycleMember.numberOfCycleStakes,\n            cycleMember.stakesClaimed,\n            cycleMember.hasWithdrawn\n        );\n    }\n\n    function getCycles() external view returns (Cycle[] memory) {\n        return Cycles;\n    }\n\n    function getCyclesLength() external view returns (uint256) {\n        return Cycles.length;\n    }\n\n    function createCycleMember(\n        uint256 cycleId,\n        uint256 groupId,\n        uint256 totalLiquidityAsPenalty,\n        uint256 numberOfCycleStakes,\n        uint256 stakesClaimed,\n        address payable depositor,\n        bool hasWithdrawn\n    ) external onlyStorageOracle {\n        bool exist = _doesCycleMemberExist(cycleId, depositor);\n        require(!exist, \"Cycle member already exist\");\n\n        CycleMember memory cycleMember =\n            CycleMember(\n                cycleId,\n                groupId,\n                totalLiquidityAsPenalty,\n                numberOfCycleStakes,\n                stakesClaimed,\n                true,\n                 depositor,\n                hasWithdrawn\n            );\n\n        uint256 index = CycleMembers.length;\n\n        RecordIndex memory recordIndex = RecordIndex(true, index);\n\n        CycleMembers.push(cycleMember);\n        CycleMembersIndexer[cycleId].push(recordIndex);\n        CycleMembersIndexerByDepositor[depositor].push(recordIndex);\n\n        CycleMembersDeepIndexer[cycleId][depositor] = recordIndex;\n    }\n\n    function updateCycleMember(\n        uint256 cycleId,\n        address payable depositor,\n        uint256 totalLiquidityAsPenalty,\n        uint256 numberOfCycleStakes,\n        uint256 stakesClaimed,\n        bool hasWithdrawn\n    ) external onlyStorageOracle {\n        CycleMember memory cycleMember = _getCycleMember(cycleId, depositor);\n        cycleMember._address = depositor;\n        cycleMember.totalLiquidityAsPenalty = totalLiquidityAsPenalty;\n        cycleMember.numberOfCycleStakes = numberOfCycleStakes;\n        cycleMember.stakesClaimed = stakesClaimed;\n        cycleMember.hasWithdrawn = hasWithdrawn;\n\n        _updateCycleMember(cycleMember);\n    }\n\n    function createCycle(\n        uint256 groupId,\n        uint256 numberOfDepositors,\n        uint256 startTimeStamp,\n        uint256 duration,\n        uint256 maximumSlots,\n        bool hasMaximumSlots,\n        uint256 cycleStakeAmount,\n        uint256 totalStakes,\n        uint256 stakesClaimed,\n        CycleStatus cycleStatus,\n        uint256 stakesClaimedBeforeMaturity\n    ) external onlyStorageOracle returns (uint256) {\n        lastCycleId += 1;\n        Cycle memory cycle =\n            Cycle(\n                lastCycleId,\n                groupId,\n                numberOfDepositors,\n                startTimeStamp,\n                duration,\n                maximumSlots,\n                cycleStakeAmount,\n                totalStakes,\n                stakesClaimed,\n                hasMaximumSlots,\n                true,\n                cycleStatus,\n                stakesClaimedBeforeMaturity\n            );\n\n        uint256 index = Cycles.length;\n        RecordIndex memory recordIndex = RecordIndex(true, index);\n\n        Cycles.push(cycle);\n        CycleIndexer[lastCycleId] = recordIndex;\n        GroupCycleIndexer[cycle.groupId].push(recordIndex);\n        return lastCycleId;\n    }\n\n    function createCycleFinancials(\n        uint256 cycleId,\n        uint256 groupId,\n        uint256 underlyingTotalDeposits,\n        uint256 underlyingTotalWithdrawn,\n        uint256 underlyingBalance,\n        uint256 derivativeBalance,\n        uint256 underylingBalanceClaimedBeforeMaturity,\n        uint256 derivativeBalanceClaimedBeforeMaturity\n    ) external onlyStorageOracle {\n        RecordIndex memory recordIndex = CycleIndexer[cycleId];\n        require(recordIndex.exists, \"Cycle not found\");\n        CycleFinancial memory cycleFinancial =\n            CycleFinancial(\n                true,\n                cycleId,\n                underlyingTotalDeposits,\n                underlyingTotalWithdrawn,\n                underlyingBalance,\n                derivativeBalance,\n                underylingBalanceClaimedBeforeMaturity,\n                derivativeBalanceClaimedBeforeMaturity\n            );\n        CycleFinancials.push(cycleFinancial);\n        CycleFinancialsIndexer[cycleId] = recordIndex;\n        GroupCycleFinancialsIndexer[groupId].push(recordIndex);\n    }\n\n    function updateCycle(\n        uint256 cycleId,\n        uint256 numberOfDepositors,\n        uint256 startTimeStamp,\n        uint256 duration,\n        uint256 maximumSlots,\n        bool hasMaximumSlots,\n        uint256 cycleStakeAmount,\n        uint256 totalStakes,\n        uint256 stakesClaimed,\n        CycleStatus cycleStatus,\n        uint256 stakesClaimedBeforeMaturity\n    ) external onlyStorageOracle {\n        Cycle memory cycle = _getCycle(cycleId);\n        cycle.numberOfDepositors = numberOfDepositors;\n        cycle.cycleStartTimeStamp = startTimeStamp;\n        cycle.cycleDuration = duration;\n        cycle.maximumSlots = maximumSlots;\n        cycle.hasMaximumSlots = hasMaximumSlots;\n        cycle.cycleStakeAmount = cycleStakeAmount;\n\n        cycle.totalStakes = totalStakes;\n        cycle.stakesClaimed = stakesClaimed;\n        cycle.cycleStatus = cycleStatus;\n        cycle.stakesClaimedBeforeMaturity = stakesClaimedBeforeMaturity;\n\n        _updateCycle(cycle);\n    }\n\n    function updateCycleFinancials(\n        uint256 cycleId,\n        uint256 underlyingTotalDeposits,\n        uint256 underlyingTotalWithdrawn,\n        uint256 underlyingBalance,\n        uint256 derivativeBalance,\n        uint256 underylingBalanceClaimedBeforeMaturity,\n        uint256 derivativeBalanceClaimedBeforeMaturity\n    ) external onlyStorageOracle {\n        uint256 index = _getCycleFinancialIndex(cycleId);\n\n        CycleFinancial memory cycleFinancial = CycleFinancials[index];\n        cycleFinancial.underlyingTotalDeposits = underlyingTotalDeposits;\n        cycleFinancial.underlyingTotalWithdrawn = underlyingTotalWithdrawn;\n        cycleFinancial.underlyingBalance = underlyingBalance;\n        cycleFinancial.derivativeBalance = derivativeBalance;\n        cycleFinancial\n            .underylingBalanceClaimedBeforeMaturity = underylingBalanceClaimedBeforeMaturity;\n        cycleFinancial\n            .derivativeBalanceClaimedBeforeMaturity = derivativeBalanceClaimedBeforeMaturity;\n        _updateCycleFinancial(cycleFinancial);\n    }\n\n    function getCycleIndex(uint256 cycleId) external view returns (uint256) {\n        return _getCycleIndex(cycleId);\n    }\n\n    function getCycleFinancialIndex(uint256 cycleId)\n        external\n        view\n        returns (uint256)\n    {\n        return _getCycleFinancialIndex(cycleId);\n    }\n\n    function _getCycleIndex(uint256 cycleId) internal view returns (uint256) {\n        bool doesCycleExist = CycleIndexer[cycleId].exists;\n        require(doesCycleExist, \"Cycle not found\");\n\n        return CycleIndexer[cycleId].index;\n    }\n\n    function getRecordIndexForCycleMembersIndexerByDepositor(\n        address depositorAddress,\n        uint256 recordIndexLocation\n    ) external view returns (bool, uint256) {\n        RecordIndex memory recordIndex =\n            CycleMembersIndexerByDepositor[depositorAddress][\n                recordIndexLocation\n            ];\n\n        return (recordIndex.exists, recordIndex.index);\n    }\n\n    function getRecordIndexForCycleMembersIndexer(\n        uint256 cycleId,\n        uint256 recordIndexLocation\n    ) external view returns (bool, uint256) {\n        RecordIndex memory recordIndex =\n            CycleMembersIndexer[cycleId][recordIndexLocation];\n        return (recordIndex.exists, recordIndex.index);\n    }\n\n    function getRecordIndexLengthForCycleMembers(uint256 cycleId)\n        external\n        view\n        returns (uint256)\n    {\n        return CycleMembersIndexer[cycleId].length;\n    }\n\n    function getRecordIndexLengthForGroupCycleIndexer(uint256 groupId)\n        external\n        view\n        returns (uint256)\n    {\n        return GroupCycleIndexer[groupId].length;\n    }\n\n    function getRecordIndexLengthForCycleMembersByDepositor(\n        address depositorAddress\n    ) external view returns (uint256) {\n        return CycleMembersIndexerByDepositor[depositorAddress].length;\n    }\n\n    function getCycleMemberIndex(uint256 cycleId, address payable memberAddress)\n        external\n        view\n        returns (uint256)\n    {\n        return _getCycleMemberIndex(cycleId, memberAddress);\n    }\n\n    function _getCycleMember(uint256 cycleId, address payable depositor)\n        internal\n        view\n        returns (CycleMember memory)\n    {\n        uint256 index = _getCycleMemberIndex(cycleId, depositor);\n        return _getCycleMember(index);\n    }\n\n    function _getCycleMember(uint256 index)\n        internal\n        view\n        returns (CycleMember memory)\n    {\n        return CycleMembers[index];\n    }\n\n    function _getCycleMemberIndex(uint256 cycleId, address payable depositor)\n        internal\n        view\n        returns (uint256)\n    {\n        bool doesCycleMemberExist =\n            CycleMembersDeepIndexer[cycleId][depositor].exists;\n        require(doesCycleMemberExist, \"Cycle member not found\");\n\n        return CycleMembersDeepIndexer[cycleId][depositor].index;\n    }\n\n    function _getCycleFinancialIndex(uint256 cycleId)\n        internal\n        view\n        returns (uint256)\n    {\n        bool doesCycleFinancialExist = CycleFinancialsIndexer[cycleId].exists;\n        require(doesCycleFinancialExist, \"Cycle financials not found\");\n\n        return CycleFinancialsIndexer[cycleId].index;\n    }\n\n    function _updateCycleMember(CycleMember memory cycleMember) internal {\n        uint256 index =\n            _getCycleMemberIndex(cycleMember.cycleId, cycleMember._address);\n        CycleMembers[index] = cycleMember;\n    }\n\n    function _updateCycle(Cycle memory cycle) internal {\n        uint256 index = _getCycleIndex(cycle.id);\n        Cycles[index] = cycle;\n    }\n\n    function _updateCycleFinancial(CycleFinancial memory cycleFinancial)\n        internal\n    {\n        uint256 index = _getCycleIndex(cycleFinancial.cycleId);\n        CycleFinancials[index] = cycleFinancial;\n    }\n\n    function _getCycle(uint256 cycleId) internal view returns (Cycle memory) {\n        uint256 index = _getCycleIndex(cycleId);\n\n        return Cycles[index];\n    }\n\n    function _getCycleFinancial(uint256 cycleId)\n        internal\n        view\n        returns (CycleFinancial memory)\n    {\n        uint256 index = _getCycleFinancialIndex(cycleId);\n\n        CycleFinancial memory cycleFinancial = CycleFinancials[index];\n        return cycleFinancial;\n    }\n\n    function doesCycleMemberExist(uint256 cycleId, address depositor)\n        external\n        view\n        returns (bool)\n    {\n        return _doesCycleMemberExist(cycleId, depositor);\n    }\n\n    function _doesCycleMemberExist(uint256 cycleId, address depositor)\n        internal\n        view\n        returns (bool)\n    {\n        return CycleMembersDeepIndexer[cycleId][depositor].exists;\n    }\n}\n"},"browser/IGroupSchema.sol":{"content":"pragma solidity 0.6.6;\n\ninterface IGroupSchema {\n    struct Group {\n        uint256 id;\n        string name;\n        string symbol;\n        bool exists;\n        address payable creatorAddress;\n    }\n\n    struct Cycle {\n        uint256 id;\n        uint256 groupId;\n        uint256 numberOfDepositors;\n        uint256 cycleStartTimeStamp;\n        uint256 cycleDuration;\n        uint256 maximumSlots;\n        uint256 cycleStakeAmount;\n        // represents the total stakes of every cycle member deposits\n        uint256 totalStakes;\n        //represents the total stakes of every cycle member withdrawal\n        uint256 stakesClaimed;\n        bool hasMaximumSlots;\n        bool exists;\n        CycleStatus cycleStatus;\n        // represents the number of cycle stakes that user's have cashed out on before the cycle has ended\n        uint256 stakesClaimedBeforeMaturity;\n    }\n\n    struct CycleFinancial {\n        bool exists;\n        uint256 cycleId;\n        //total underlying asset deposited into contract\n        uint256 underlyingTotalDeposits;\n        //total underlying asset that have been withdrawn by cycle members\n        uint256 underlyingTotalWithdrawn;\n        // underlying amount gotten after lending period has ended and shares have been reedemed for underlying asset;\n        uint256 underlyingBalance;\n        // lending shares representation of amount deposited in lending protocol\n        uint256 derivativeBalance;\n        // represents the total underlying crypto amount that has been cashed out before the cycle ended\n        uint256 underylingBalanceClaimedBeforeMaturity;\n        // represents the total derivative crypto amount that has been cashed out on before the cycle ended\n        uint256 derivativeBalanceClaimedBeforeMaturity;\n    }\n\n    struct CycleMember {\n        uint256 cycleId;\n        uint256 groupId;\n        uint256 totalLiquidityAsPenalty;\n        uint256 numberOfCycleStakes;\n        uint256 stakesClaimed;\n        bool exist;\n        address payable _address;\n        bool hasWithdrawn;\n    }\n\n    struct Member {\n        bool exists;\n        address payable _address;\n    }\n\n    struct GroupMember {\n        bool exists;\n        address payable _address;\n        uint256 groupId;\n    }\n\n    struct RecordIndex {\n        bool exists;\n        uint256 index;\n    }\n\n    enum CycleStatus {NOT_STARTED, ONGOING, ENDED}\n}\n"},"browser/StorageOwners.sol":{"content":"pragma solidity 0.6.6;\n\ncontract StorageOwners {\n    address owner;\n    mapping(address => bool) private storageOracles;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function changeStorageOracleStatus(address oracle, bool status) external onlyOwner {\n        storageOracles[oracle] = status;\n}\n  function activateStorageOracle(address oracle) external onlyOwner {\n        storageOracles[oracle] = true;\n    }\n\n    function deactivateStorageOracle(address oracle) external onlyOwner {\n        storageOracles[oracle] = false;\n    }\n\n    function reAssignStorageOracle(address newOracle)\n        external\n        onlyStorageOracle\n    {\n        storageOracles[msg.sender] = false;\n        storageOracles[newOracle] = true;\n    }\n\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n\n        // require(newOwner == address(0), \"new owneru\");\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"unauthorized access to contract\");\n        _;\n    }\n\n    modifier onlyStorageOracle() {\n        bool hasAccess = storageOracles[msg.sender];\n        require(hasAccess, \"unauthorized access to contract\");\n        _;\n    }\n}\n"}}}