{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Blo.sol":{"content":"pragma solidity >=0.4.0 <0.7.0;\ninterface IMember {\n    function addMember(address _member, address _parent) external;\n    function getParent(address _member) external view returns (address _parent);\n    function isMember(address _member) external view returns (bool);\n    function getParentTree(address _member)\n        external\n        view\n        returns (address[8] memory);\n    function getRefs(address _member) external view returns (address[] memory);\n    function getRef(address _member, uint256 _index)\n        external\n        view\n        returns (address);\n    function getRefsLength(address _member) external view returns (uint256);\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\ninterface OldContract {\n    function getUser(address _address) external view returns (uint256 level, uint256[8] memory refTree, uint256 totalMember);\n    function getCurrentBonus() external view returns (uint256 step, uint256 max, uint256 sold, uint256 bonus);\n}\ncontract Hoobi {\n    address private owner;\n    address private fund = 0x17796dB252B9FF3ddff9646C7E8738bF50e3e58e;\n    OldContract old = OldContract(0xb28F1760695d65e501966353831C286D6E26Ec10);\n    IERC20 share;\n    IMember member;\n    uint256 shareDecimal = 6;\n    uint256 priceETH = 200 * 10**6;\n    uint256 lastPriceETH = 200 * 10 ** 6;\n    uint256 priceShare = 10**5;\n    uint256[7] refPercent = [5, 4, 2, 1, 1, 1, 1]; //div 100\n    uint256[3] firstPercent = [60, 80, 100];\n    uint256[3] secondPercent = [50, 60, 70];\n    uint256[9] bonusShare = [520, 380, 260, 140, 80, 50, 30, 20, 16]; //div\n    uint256[9] poolShare = [\n        10**11,\n        3 * 10**11,\n        10**12,\n        3 * 10**12,\n        8 * 10**12,\n        20 * 10**12,\n        50 * 10**12,\n        100 * 10**12,\n        300 * 10**12\n    ];\n    uint256[9] soldShare = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    uint256[3] level = [100 * 10**6, 200 * 10**6, 400 * 10**6];\n    uint256 currentPool = 0;\n    address bot = 0x2637F27ed1A8dC88a950b785329cc5606F7CaEa7;\n    struct User {\n        uint256 level;\n        uint256[8] refTree;\n    }\n    mapping(address => User) users;\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Must be owner\");\n        _;\n    }\n    modifier onlyMod() {\n        require(msg.sender == owner || msg.sender == bot, \"Must be bot\");\n        _;\n    }\n    constructor(\n        address _shareContract,\n        address _memberContract\n    ) public {\n        owner = msg.sender;\n        share = IERC20(_shareContract);\n        member = IMember(_memberContract);\n    }\n    function init() public onlyOwner {\n        (,,soldShare[0],) = old.getCurrentBonus();\n    }\n    function recover(address[] memory oldUsers) public onlyOwner {\n        for(uint i=0;i<oldUsers.length;i++){\n            (users[oldUsers[i]].level,users[oldUsers[i]].refTree,) = old.getUser(oldUsers[i]);\n        }\n    }\n    function getAmountETH(uint256 _amount) public view returns (uint256) {\n        return ((_amount * 10**24) / priceETH);\n    }\n    function getAmountETHLevel(uint _level) public view returns(uint){\n        if(_level == 0) return 0;\n        if(_level == 1) return getAmountETH(100);\n        if(_level == 2) return getAmountETH(200);\n        if(_level == 3) return getAmountETH(400);\n        return 0;\n    }\n    function getLevel(uint _amount) public view returns(uint8 level,uint256 value){\n        if (_amount == ((100 * 10**24) / priceETH)) {\n            return(1,100 * 10 ** 6);\n        } else if (_amount == ((200 * 10**24) / priceETH)){\n             return(2,200 * 10 ** 6);\n        } else if (_amount == ((400 * 10**24) / priceETH)) {\n            return(3,400 * 10 ** 6);\n        } else if (_amount == ((100 * 10**24) / lastPriceETH)) {\n            return(1,100 * 10 ** 6);\n        } else if (_amount == ((200 * 10**24) / lastPriceETH)) {\n            return(2,200 * 10 ** 6);\n        } else if (_amount == ((400 * 10**24) / lastPriceETH)) {\n            return(4,400 * 10 ** 6);\n        } else {\n            return(0,0);\n        }\n    }\n    function upgradePackage(address _ref) public payable {\n        require(member.isMember(msg.sender) || member.isMember(_ref),\"Must be valid\");\n        (uint8 userLevel,uint256 value) = getLevel(msg.value);\n        require(userLevel > users[msg.sender].level, \"User only can upgrade membership!\");\n        sendFunds(fund, (msg.value * 15) / 1000, 0);\n        users[msg.sender].level = userLevel;\n        if (member.isMember(msg.sender)) {\n            reInvest(msg.sender, msg.value);\n        } else {\n            // member.addMember(msg.sender, _ref);\n            addNewInvestor(_ref, msg.value, userLevel);\n        }\n        if (currentPool < 9) {\n            uint256 amountShare = (value * (10**shareDecimal)) / priceShare;\n            uint256 bonus;\n            if (poolShare[currentPool] - soldShare[currentPool] >= value) {\n                bonus = (amountShare * bonusShare[currentPool]) / 10;\n                soldShare[currentPool] += value;\n                if (soldShare[currentPool] == poolShare[currentPool])\n                    currentPool++;\n            } else {\n                uint256 payed = poolShare[currentPool] - soldShare[currentPool];\n                bonus =\n                    (((payed * (10**shareDecimal)) / priceShare) *\n                        bonusShare[currentPool]) /\n                    10;\n                soldShare[currentPool] = poolShare[currentPool];\n                currentPool++;\n                if (currentPool < 9) {\n                    bonus +=\n                        ((((value - payed) * (10**shareDecimal)) / priceShare) *\n                            bonusShare[currentPool]) /\n                        10;\n                    soldShare[currentPool] += value - payed;\n                }\n            }\n            sendFunds(msg.sender, amountShare + bonus, 1);\n        } else {\n            uint256 amountShare = (value * (10**shareDecimal)) / priceShare;\n            sendFunds(msg.sender, amountShare, 1);\n        }\n    }\n    function invest(address _ref) public payable {\n        require(validRef(msg.sender, _ref), \"Must be valid Ref\");\n        (uint8 userLevel,uint256 value) = getLevel(msg.value);\n        require(userLevel > users[msg.sender].level, \"User only can upgrade membership!\");\n        sendFunds(fund, (msg.value * 15) / 1000, 0);\n        users[msg.sender].level = userLevel;\n        if (member.isMember(msg.sender)) {\n            reInvest(msg.sender, msg.value);\n        } else {\n            // member.addMember(msg.sender, _ref);\n            addNewInvestor(_ref, msg.value, userLevel);\n        }\n        if (currentPool < 9) {\n            uint256 amountShare = (value * (10**shareDecimal)) / priceShare;\n            uint256 bonus;\n            if (poolShare[currentPool] - soldShare[currentPool] >= value) {\n                bonus = (amountShare * bonusShare[currentPool]) / 10;\n                soldShare[currentPool] += value;\n                if (soldShare[currentPool] == poolShare[currentPool])\n                    currentPool++;\n            } else {\n                uint256 payed = poolShare[currentPool] - soldShare[currentPool];\n                bonus =\n                    (((payed * (10**shareDecimal)) / priceShare) *\n                        bonusShare[currentPool]) /\n                    10;\n                soldShare[currentPool] = poolShare[currentPool];\n                currentPool++;\n                if (currentPool < 9) {\n                    bonus +=\n                        ((((value - payed) * (10**shareDecimal)) / priceShare) *\n                            bonusShare[currentPool]) /\n                        10;\n                    soldShare[currentPool] += value - payed;\n                }\n            }\n            sendFunds(msg.sender, amountShare + bonus, 1);\n        } else {\n            uint256 amountShare = (value * (10**shareDecimal)) / priceShare;\n            sendFunds(msg.sender, amountShare, 1);\n        }\n    }\n    function reInvest(address _investor, uint256 _value)\n        private\n    {\n        address[8] memory parentTree = member.getParentTree(_investor);\n        if (parentTree[0] != address(0x0)) {\n            sendFunds(\n                parentTree[0],\n                (_value * secondPercent[users[parentTree[0]].level - 1]) / 100,\n                0\n            );\n            for (uint256 i = 1; i < 8; i++) {\n                if (parentTree[i] == address(0x0)) {\n                    break;\n                } else {\n                    sendFunds(\n                        parentTree[i],\n                        (_value * refPercent[i - 1]) / 100,\n                        0\n                    );\n                }\n            }\n        }\n    }\n    function addNewInvestor(address _ref, uint256 _value, uint256 _level)\n        private\n    {\n        if(_ref != address(0x0)){\n            User storage user = users[_ref];\n            user.refTree[0] += 1;\n            if (user.refTree[0] == 2) {\n                if (user.level < _level) {\n                    if(getAmountETHLevel(user.level) > 0 && user.level > 0){\n                         sendFunds(_ref,(getAmountETHLevel(user.level) * firstPercent[user.level - 1]) /100,0);\n                    }\n                } else {\n                    sendFunds(_ref,(_value * firstPercent[user.level - 1]) / 100,0);\n                    \n                }\n            }\n            if (user.refTree[0] > 2) { sendFunds( _ref,(_value * secondPercent[user.level - 1]) / 100,0); }\n            address[8] memory parentTree = member.getParentTree(_ref);\n            for(uint i = 0;i < 7;i++){\n                if(parentTree[i] != address(0x0)){\n                    uint256[8] storage userRef = users[parentTree[i]].refTree;\n                    userRef[i+1] += 1;\n                    if (userRef[i+1] == 2) {\n                        sendFunds(parentTree[i], (_value * refPercent[i]) / 100, 0);\n                    } else {\n                        if (userRef[i+1] > 2) {\n                            sendFunds(parentTree[i],(_value * refPercent[i]) / 200,0);\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    function getUserStats(address _investor) public view returns(address[] memory refs){\n        address[] memory tempRefs = member.getRefs(_investor);\n        return (tempRefs);\n    }\n    function getUser(address _address)\n        public\n        view\n        returns (uint256 userLevel, uint256[8] memory refTree)\n    {\n        User memory user = users[_address];\n        return (user.level, user.refTree);\n    }\n    function getUserRefsStats(address _investor)\n        public\n        view\n        returns (address[] memory refs)\n    {\n        address[] memory _refs = member.getRefs(_investor);\n        return (_refs);\n    }\n    function getPrice()\n        public\n        view\n        returns (uint256 ethPrice, uint256 sharePrice)\n    {\n        return (priceETH, priceShare);\n    }\n    function getCurrentBonus()\n        public\n        view\n        returns (uint256 step, uint256 max, uint256 sold, uint256 bonus)\n    {\n        return (\n            currentPool,\n            poolShare[currentPool],\n            soldShare[currentPool],\n            bonusShare[currentPool]\n        );\n    }\n    function validRef(address _investor, address _ref)\n        public\n        view\n        returns (bool)\n    {\n        if (member.isMember(_investor)) {\n            return true;\n        } else {\n            if (member.isMember(_ref)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n    function changeMemberContract(address _contract) public onlyOwner {\n        member = IMember(_contract);\n    }\n    function changeShareContract(address _contract) public onlyOwner {\n        share = IERC20(_contract);\n    }\n    function changeETHPrice(uint256 _price) public onlyMod {\n        lastPriceETH = priceETH;\n        priceETH = _price;\n    }\n    function changeBot(address _bot) public onlyOwner {\n        bot = _bot;\n    }\n    function changeSharePrice(uint256 _price) public onlyMod {\n        priceShare = _price;\n    }\n    function adminWidthdraw(\n        address _address,\n        uint256 _amount,\n        uint256 _currency\n    ) public onlyOwner {\n        sendFunds(_address, _amount, _currency);\n    }\n    function sendFunds(address beneficiary, uint256 amount, uint256 currency)\n        private\n    {\n        if (currency == 0) {\n            require(\n                address(this).balance >= amount,\n                \"Balance in contract is not enough to cash out, please contact for admin\"\n            );\n            address(uint160(beneficiary)).transfer(amount);\n        } else {\n            // require(\n            //     share.balanceOf(address(this)) >= amount,\n            //     \"Balance in contract is not enough to cash out, please contact for admin\"\n            // );\n            // share.transfer(beneficiary, amount);\n        }\n    }\n}"}}}