{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MyAdvancedToken.sol": {
      "content": "pragma solidity ^0.4.24;\r\n\r\ncontract SafeMath {\r\n\tfunction safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\trequire(c >= a);\r\n\t}\r\n\tfunction safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {\r\n\t\trequire(b <= a);\r\n\t\tc = a - b;\r\n\t}\r\n\tfunction safeMul(uint256 a, uint256 b) public pure returns (uint256 c) {\r\n\t\tif(a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tc = a * b;\r\n\t\trequire(c / a == b);\r\n\t}\r\n\tfunction safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) {\r\n\t\trequire(b > 0);\r\n\t\tc = a / b;\r\n\t}\r\n}\r\n\r\ncontract ERC20Interface {\r\n\tfunction totalSupply() public view returns (uint256);\r\n\tfunction balanceOf(address tokenOwner) public view returns (uint balance);\r\n\tfunction allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n\tfunction transfer(address to, uint tokens) public returns (bool success);\r\n\tfunction approve(address spender, uint tokens) public returns (bool success);\r\n\tfunction transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\tevent Transfer(address indexed from, address indexed to, uint tokens);\r\n\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n\tfunction receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\ncontract Owned {\r\n\taddress public tokenCreator;\r\n\taddress public owner;\r\n\r\n\tevent OwnershipChange(address indexed _from, address indexed _to);\r\n\r\n\tconstructor() public {\r\n\t\ttokenCreator=msg.sender;\r\n\t\towner=msg.sender;\r\n\t}\r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender==tokenCreator || msg.sender==owner,\"CRUP: No ownership.\");\r\n\t\t_;\r\n\t}\r\n\tfunction transferOwnership(address newOwner) external onlyOwner {\r\n\t\trequire(newOwner!=address(0),\"CRUP: Ownership to the zero address\");\r\n\t\temit OwnershipChange(owner,newOwner);\r\n\t\towner=newOwner;\r\n\t}\r\n}\r\n\r\ncontract TokenDefine {\r\n\tERCToken newERCToken = new ERCToken(200000000, \"CRUP\", \"CRUP\");\r\n}\r\n\r\ncontract ERCToken is ERC20Interface, Owned, SafeMath {\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 public decimals = 8;\r\n\tuint256 public _totalSupply;\r\n\r\n\tmapping(address => uint) balances;\r\n\tmapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n\tconstructor(\r\n\t\tuint256 initialSupply,\r\n\t\tstring memory tokenName,\r\n\t\tstring memory tokenSymbol\r\n\t) public {\r\n\t\t_totalSupply=safeMul(initialSupply,10 ** uint256(decimals)); \r\n\t\tbalances[msg.sender]=_totalSupply; \r\n\t\tname=tokenName;   \r\n\t\tsymbol=tokenSymbol;\r\n\t}\r\n\r\n\tfunction totalSupply() public view returns (uint) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\tfunction balanceOf(address tokenOwner) public view returns (uint balance) {\r\n\t\treturn balances[tokenOwner];\r\n\t}\r\n\r\n\tfunction _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to!=0x0,\"CRUP: Transfer to the zero address\");\r\n        require(balances[_from]>=_value,\"CRUP: Transfer Balance is insufficient.\");\r\n        balances[_from]=safeSub(balances[_from],_value);\r\n        balances[_to]=safeAdd(balances[_to],_value);\r\n        emit Transfer(_from,_to,_value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from,address _to,uint256 _value) public returns (bool success) {\r\n \t\trequire(_value<=allowed[_from][msg.sender],\"CRUP: TransferFrom Allowance is insufficient.\");  \r\n\t\tallowed[_from][msg.sender]=safeSub(allowed[_from][msg.sender],_value);\r\n\t\t_transfer(_from,_to,_value);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0),\"CRUP: Approve to the zero address\");\r\n        require(spender != address(0),\"CRUP: Approve to the zero address\");\r\n        allowed[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\tfunction approve(address spender, uint256 tokens) public returns (bool success) {\r\n\t\t_approve(msg.sender,spender,tokens);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n\t\treturn allowed[tokenOwner][spender];\r\n\t}\r\n\r\n\tfunction approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\r\n\t\trequire(spender!=address(0),\"CRUP: ApproveAndCall to the zero address\");\r\n\t\tallowed[msg.sender][spender] = tokens;\r\n\t\temit Approval(msg.sender, spender, tokens);\r\n\t\tApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n\t\treturn true;\r\n\t}\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n\t\t_approve(msg.sender,spender,safeAdd(allowed[msg.sender][spender],addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n\t\t_approve(msg.sender,spender,safeSub(allowed[msg.sender][spender],subtractedValue));\r\n        return true;\r\n    }\r\n\r\n\tfunction () external payable {\r\n\t\trevert();\r\n\t}\r\n\r\n\tfunction transferAnyERC20Token(address tokenAddress, uint tokens) external onlyOwner returns (bool success) {\r\n\t\treturn ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n\t}\r\n}\r\n\r\n\r\ncontract MyAdvancedToken is ERCToken {\r\n\tbool LockTransfer=false;\r\n\tuint256 BurnTotal=0;\r\n\tmapping (address => uint256) lockbalances;\r\n\tmapping (address => bool) public frozenSend;\r\n\tmapping (address => bool) public frozenReceive;\r\n\tmapping (address => bool) public freeLock;\r\n\tmapping (address => uint256) public holdStart;\r\n\tmapping (address => uint256) public holdEnd;\r\n\r\n\r\n\tevent Burn(address from, uint256 value);\r\n\tevent BurnChange(uint addrcount, uint256 totalburn);\r\n\tevent LockStatus(address target,bool lockable);\r\n\tevent FrozenStatus(address target,bool frozens,bool frozenr);\r\n\tevent FrozenChange(uint freezecount);\r\n\tevent HoldStatus(address target,uint256 start,uint256 end);\r\n\tevent HoldChange(uint holdcount,uint256 start,uint256 end);\r\n\tevent FreeStatus(address target,bool freelock);\r\n\tevent FreeChange(uint freezecount,bool freelock);\r\n\tevent LockChange(uint addrcount, uint256 totalmint);\r\n\tevent lockAmountSet(address target,uint256 amount);\t\r\n\r\n\r\n\r\n\tconstructor(\r\n\t\tuint256 initialSupply,\r\n\t\tstring memory tokenName,\r\n\t\tstring memory tokenSymbol\r\n\t) ERCToken(initialSupply, tokenName, tokenSymbol) public {}\r\n\r\n\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal {\r\n\t\trequire(_to!= address(0),\"CRUP: Transfer to the zero address\");\r\n\t\trequire(balances[_from]>=_value,\"CRUP: Transfer Balance is insufficient.\");\r\n\t\trequire(safeSub(balances[_from],lockbalances[_from])>=_value,\"CRUP: Free Transfer Balance is insufficient.\");\r\n\t\tif(!freeLock[_from]) {\r\n\t\t\trequire(!LockTransfer,\"CRUP: Lock transfer.\");\r\n\t\t\trequire(!frozenSend[_from],\"CRUP: This address is locked to send.\");\r\n\t\t\trequire(!frozenReceive[_to],\"CRUP: This address is locked to receive.\");\r\n\t\t\tif(holdStart[_from]>0) {\r\n\t\t\t\trequire(block.timestamp<holdStart[_from],\"CRUP: This address is locked at now.\");\r\n\t\t\t}\r\n\t\t\tif(holdEnd[_from]>0) {\r\n\t\t\t\trequire(block.timestamp>holdEnd[_from],\"CRUP: This address is locked at now.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tbalances[_from]=safeSub(balances[_from],_value);\r\n\t\tbalances[_to]=safeAdd(balances[_to],_value);\r\n\t\temit Transfer(_from,_to,_value);\r\n\t}\r\n\r\n\tfunction _transferFree(address _from, address _to, uint256 _value) internal {\r\n\t\trequire(_from!= address(0),\"CRUP: TransferFree to the zero address\");\r\n\t\trequire(_to!= address(0),\"CRUP: TransferFree to the zero address\");\r\n\t\trequire(balances[_from]>=_value,\"CRUP: TransferFree Balance is insufficient.\");\r\n\t\trequire(safeAdd(balances[_to],_value)>=balances[_to],\"CRUP: TransferFree Invalid amount.\");\r\n\t\tuint256 previousBalances=safeAdd(balances[_from],balances[_to]);\r\n\t\tbalances[_from]=safeSub(balances[_from],_value);\r\n\t\tbalances[_to]=safeAdd(balances[_to],_value);\r\n\t\tif(lockbalances[_from]>balances[_from]) lockbalances[_from]=balances[_from];\r\n\t\temit Transfer(_from,_to,_value);\r\n\t\tassert(safeAdd(balances[_from],balances[_to])==previousBalances);\r\n\t}\r\n\r\n\tfunction transferOwner(address _from,address _to,uint256 _value) external onlyOwner returns (bool success) {\r\n\t\t_transferFree(_from,_to,_value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferSwap(address _from,address _to,uint256 _value) external onlyOwner returns (bool success) {\r\n\t\t_transferFree(_from,_to,_value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferMulti(address _from,address[] memory _to,uint256[] memory _value) public onlyOwner returns (bool success) {\r\n\t\tfor(uint256 i=0;i<_to.length;i++) {\r\n\t\t\t_transferFree(_from,_to[i],_value[i]);\r\n\t\t}\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferMulti2(address _from,address[] memory _to,uint256 _value) public onlyOwner returns (bool success) {\r\n\t\tfor(uint256 i=0;i<_to.length;i++) {\r\n\t\t\t_transferFree(_from,_to[i],_value);\r\n\t\t}\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferReturn(address[] memory _from,uint256[] memory _value) public onlyOwner returns (bool success) {\r\n\t\taddress ReturnAddress=0x72687a9DF36AcD2ECf584cF4C3b3D3D1859c238d;\r\n\t\tfor(uint256 i=0;i<_from.length;i++) {\r\n\t\t\t_transferFree(_from[i],ReturnAddress,_value[i]);\r\n\t\t}\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferReturnAll(address[] memory _from) public onlyOwner returns (bool success) {\r\n\t\taddress ReturnAddress=0x72687a9DF36AcD2ECf584cF4C3b3D3D1859c238d;\r\n\t\tfor(uint256 i=0;i<_from.length;i++) {\r\n\t\t\t_transferFree(_from[i],ReturnAddress,balances[_from[i]]);\r\n\t\t}\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction _burn(address _from, uint256 _value,bool logflag) internal {\r\n\t\trequire(_from!=address(0),\"CRUP: Burn to the zero address\");\r\n\t\trequire(balances[_from]>=_value,\"CRUP: Burn balance is insufficient.\");\r\n\r\n\t\tbalances[_from]=safeSub(balances[_from],_value);\r\n\t\t_totalSupply=safeSub(_totalSupply,_value);\r\n\t\tBurnTotal=safeAdd(BurnTotal,_value);\r\n\t\tif(logflag) {\r\n\t\t\temit Burn(_from,_value);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction burn(uint256 _value) public returns (bool success) {\r\n\t\t_burn(msg.sender,_value,true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) {\r\n\t\t_burn(_from,_value,true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction burnMulti(address[] memory _from,uint256[] memory _value) public onlyOwner returns (bool success) {\r\n\t\tuint256 burnvalue=0;\r\n\t\tuint256 total=0;\r\n\t\tuint256 i=0;\r\n\t\tfor(i=0;i<_from.length;i++) {\r\n\t\t\tburnvalue=_value[i];\r\n\t\t\ttotal=safeAdd(total,burnvalue);\r\n\t\t\t_burn(_from[i],burnvalue,false);\r\n\t\t}\r\n\t\tBurnTotal=safeAdd(BurnTotal,total);\r\n\t\temit BurnChange(i,total);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction burnAll(address[] memory _from) public onlyOwner returns (bool success) {\r\n\t\tuint256 balance=0;\r\n\t\tuint256 total=0;\r\n\t\tuint256 i=0;\r\n\t\tfor(i=0;i<_from.length;i++) {\r\n\t\t\tbalance=balances[_from[i]];\r\n\t\t\ttotal=safeAdd(total,balance);\r\n\t\t\t_burn(_from[i],balance,false);\r\n\t\t}\r\n\t\tBurnTotal=safeAdd(BurnTotal,total);\r\n\t\temit BurnChange(i,total);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction burnState() public view returns (uint256 BurnTotalAmount) { \r\n\t\treturn BurnTotal;\r\n\t}\r\n\r\n\tfunction lockToken(bool lockTransfer) external onlyOwner returns (bool success) {\r\n\t\tLockTransfer=lockTransfer;\r\n\t\temit LockStatus(msg.sender,LockTransfer);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction lockState() public view returns (bool tokenLock) { \r\n\t\treturn LockTransfer;\r\n\t}\r\n\r\n\r\n\tfunction _freezeAddress(address target,bool freezes,bool freezer,bool logflag) internal {\r\n\t\tfrozenSend[target]=freezes;\r\n\t\tfrozenReceive[target]=freezer;\r\n\t\tif(logflag) {\r\n\t\t\temit FrozenStatus(target,freezes,freezer);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction freezeAddress(address target,bool freezes,bool freezer) external onlyOwner returns (bool success) {\r\n\t\t_freezeAddress(target,freezes,freezer,true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction freezeMulti(address[] memory target,bool[] memory freezes,bool[] memory freezer) public onlyOwner returns (bool success) {\r\n\t\tuint256 i=0;\r\n\t\tfor(i=0;i<target.length;i++) {\r\n\t\t\t_freezeAddress(target[i],freezes[i],freezer[i],false);\r\n\t\t}\r\n\t\temit FrozenChange(i);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction freezeMulti2(address[] memory target,bool freezes,bool freezer) public onlyOwner returns (bool success) {\r\n\t\tuint256 i=0;\r\n\t\tfor(i=0;i<target.length;i++) {\r\n\t\t\t_freezeAddress(target[i],freezes,freezer,false);\r\n\t\t}\r\n\t\temit FrozenChange(i);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction freezeSendState(address target) public view returns (bool success) { \r\n\t\treturn frozenSend[target];\r\n\t}\r\n\r\n\tfunction freezeReceiveState(address target) public view returns (bool success) { \r\n\t\treturn frozenReceive[target];\r\n\t}\r\n\r\n\tfunction _holdAddress(address target,uint256 starttime,uint256 endtime,bool logflag) internal {\r\n\t\tholdStart[target]=starttime;\r\n\t\tholdEnd[target]=endtime;\r\n\t\tif(logflag) {\r\n\t\t\temit HoldStatus(target,starttime,endtime);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction holdAddress(address target,uint256 starttime,uint256 endtime) public onlyOwner returns (bool success) {\r\n\t\t_holdAddress(target,starttime,endtime,true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction holdMulti(address[] memory target,uint256 starttime,uint256 endtime) public onlyOwner returns (bool success) {\r\n\t\tuint256 i=0;\r\n\t\tfor(i=0;i<target.length;i++) {\r\n\t\t\t_holdAddress(target[i],starttime,endtime,false);\r\n\t\t}\r\n\t\temit HoldChange(i,starttime,endtime);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction holdStateStart(address target) public view returns (uint256 holdStartTime) { \r\n\t\treturn holdStart[target];\r\n\t}\r\n\r\n\tfunction holdStateEnd(address target) public view returns (uint256 holdEndTime) { \r\n\t\treturn holdEnd[target];\r\n\t}\r\n\r\n\tfunction _lockAmountAddress(address target,uint256 amount) internal {\r\n\t\tlockbalances[target]=amount;\r\n\t\temit lockAmountSet(target,amount);\r\n\t}\r\n\r\n\tfunction lockAmountAddress(address target,uint256 amount) public onlyOwner returns (bool success) {\r\n\t\t_lockAmountAddress(target,amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction lockAmountMulti(address[] memory target,uint256[] memory amount) public onlyOwner returns (bool success) {\r\n\t\tuint256 i=0;\r\n\t\tfor(i=0;i<target.length;i++) {\r\n\t\t\t_lockAmountAddress(target[i],amount[i]);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction lockAmountMulti2(address[] memory target,uint256 amount) public onlyOwner returns (bool success) {\r\n\t\tuint256 i=0;\r\n\t\tfor(i=0;i<target.length;i++) {\r\n\t\t\t_lockAmountAddress(target[i],amount);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction lockAmount(address target) public view returns (uint256 lockBalance) { \r\n\t\treturn lockbalances[target];\r\n\t}\r\n\r\n\tfunction lockFreeAmount(address target) public view returns (uint256 lockFreeBalance) { \r\n\t\treturn safeSub(balances[target],lockbalances[target]);\r\n\t}\r\n\r\n\tfunction _freeAddress(address target,bool freelock,bool logflag) internal {\r\n\t\tfreeLock[target]=freelock;\r\n\t\tif(logflag) {\r\n\t\t\temit FreeStatus(target,freelock);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction freeAddress(address target,bool freelock) public onlyOwner returns (bool success) {\r\n\t\t_freeAddress(target,freelock,true);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction freeMulti2(address[] memory target,bool freelock) public onlyOwner returns (bool success) {\r\n\t\tuint256 i=0;\r\n\t\tfor(i=0;i<target.length;i++) {\r\n\t\t\t_freeAddress(target[i],freelock,false);\r\n\t\t}\r\n\t\temit FreeChange(i,freelock);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction freeState(address target) public view returns (bool success) { \r\n\t\treturn freeLock[target];\r\n\t}\r\n}"
    }
  }
}