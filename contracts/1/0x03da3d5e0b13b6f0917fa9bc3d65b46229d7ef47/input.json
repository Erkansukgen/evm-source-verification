{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/AutoRewardDripper.sol":{"content":"/// AutoRewardDripper.sol\n\n// Copyright (C) 2021 Reflexer Labs, INC\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.7;\n\nabstract contract TokenLike {\n    function balanceOf(address) virtual public view returns (uint256);\n    function transfer(address, uint256) virtual external returns (bool);\n}\n\ncontract AutoRewardDripper {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"AutoRewardDripper/account-not-authorized\");\n        _;\n    }\n\n    // --- Variables ---\n    // Last block when a reward was given\n    uint256   public lastRewardBlock;\n    // Amount of tokens distributed per block\n    uint256   public rewardPerBlock;\n    // The timeline (in number of blocks) used to calculate rewardPerBlock\n    uint256   public rewardTimeline;\n    // Last time when the reward was calculated\n    uint256   public lastRewardCalculation;\n    // Delay between reward calculations\n    uint256   public rewardCalculationDelay;\n    // The address that can request rewards\n    address   public requestor;\n    // The reward token being distributed\n    TokenLike public rewardToken;\n\n    uint256 public constant MAX_REWARD_TIMELINE = 2250000;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 indexed parameter, uint256 data);\n    event ModifyParameters(bytes32 indexed parameter, address data);\n    event DripReward(address requestor, uint256 amountToTransfer);\n    event TransferTokenOut(address dst, uint256 amount);\n    event RecomputePerBlockReward(uint256 rewardPerBlock);\n\n    constructor(\n      address requestor_,\n      address rewardToken_,\n      uint256 rewardTimeline_,\n      uint256 rewardCalculationDelay_\n    ) public {\n        require(requestor_ != address(0), \"AutoRewardDripper/null-requoestor\");\n        require(rewardToken_ != address(0), \"AutoRewardDripper/null-reward-token\");\n        require(rewardTimeline_ > 0, \"AutoRewardDripper/null-reward-time\");\n        require(rewardTimeline_ <= MAX_REWARD_TIMELINE, \"AutoRewardDripper/high-reward-timeline\");\n        require(rewardCalculationDelay_ > 0, \"AutoRewardDripper/null-reward-calc-delay\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        rewardTimeline         = rewardTimeline_;\n        requestor              = requestor_;\n        rewardCalculationDelay = rewardCalculationDelay_;\n        rewardToken            = TokenLike(rewardToken_);\n        lastRewardBlock        = block.number;\n\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"rewardTimeline\", rewardTimeline);\n        emit ModifyParameters(\"rewardCalculationDelay\", rewardCalculationDelay);\n        emit ModifyParameters(\"requestor\", requestor);\n        emit ModifyParameters(\"lastRewardBlock\", lastRewardBlock);\n    }\n\n    // --- Boolean ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Math ---\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"AutoRewardDripper/sub-underflow\");\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"AutoRewardDripper/mul-overflow\");\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Modify an uint256 parameter\n    * @param parameter The name of the parameter to modify\n    * @param data New value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"lastRewardBlock\") {\n            require(data >= block.number, \"AutoRewardDripper/invalid-last-reward-block\");\n            lastRewardBlock = data;\n        } else if (parameter == \"rewardPerBlock\") {\n            require(data > 0, \"AutoRewardDripper/invalid-reward-per-block\");\n            rewardPerBlock = data;\n        } else if (parameter == \"rewardCalculationDelay\") {\n            require(data > 0, \"AutoRewardDripper/invalid-reward-calculation-delay\");\n            rewardCalculationDelay = data;\n        } else if (parameter == \"rewardTimeline\") {\n            require(data > 0 && data <= MAX_REWARD_TIMELINE, \"AutoRewardDripper/invalid-reward-timeline\");\n            rewardTimeline = data;\n        }\n        else revert(\"AutoRewardDripper/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /*\n    * @notify Modify an address parameter\n    * @param parameter The name of the parameter to modify\n    * @param data New value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"AutoRewardDripper/null-data\");\n        if (parameter == \"requestor\") {\n            requestor = data;\n        }\n        else revert(\"AutoRewardDripper/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notice Transfer tokens to a custom address\n    * @param dst The destination address for the tokens\n    * @param amount The amount of tokens transferred\n    */\n    function transferTokenOut(address dst, uint256 amount) external isAuthorized {\n        require(dst != address(0), \"AutoRewardDripper/null-dst\");\n        require(amount > 0, \"AutoRewardDripper/null-amount\");\n\n        require(rewardToken.transfer(dst, amount), \"AutoRewardDripper/failed-transfer\");\n\n        emit TransferTokenOut(dst, amount);\n    }\n    /*\n    * @notify Send rewards to the requestor\n    */\n    function dripReward() external {\n        dripReward(msg.sender);\n    }\n    /*\n    * @notify Recompute rewardPerBlock\n    */\n    function recomputePerBlockReward() public {\n        uint256 remainingBalance = rewardToken.balanceOf(address(this));\n        if (either(remainingBalance == 0, subtract(now, lastRewardCalculation) < rewardCalculationDelay)) return;\n        lastRewardCalculation    = now;\n        rewardPerBlock           = (rewardTimeline >= remainingBalance) ? remainingBalance : remainingBalance / rewardTimeline;\n        emit RecomputePerBlockReward(rewardPerBlock);\n    }\n    /*\n    * @notify Send rewards to an address defined by the requestor\n    */\n    function dripReward(address to) public {\n        if (lastRewardBlock >= block.number) return;\n        require(msg.sender == requestor, \"AutoRewardDripper/invalid-caller\");\n\n        uint256 remainingBalance = rewardToken.balanceOf(address(this));\n        uint256 amountToTransfer = multiply(subtract(block.number, lastRewardBlock), rewardPerBlock);\n        amountToTransfer         = (amountToTransfer > remainingBalance) ? remainingBalance : amountToTransfer;\n\n        lastRewardBlock = block.number;\n        recomputePerBlockReward();\n\n        if (amountToTransfer == 0) return;\n        require(rewardToken.transfer(to, amountToTransfer), \"AutoRewardDripper/failed-transfer\");\n\n        emit DripReward(to, amountToTransfer);\n    }\n}"}}}