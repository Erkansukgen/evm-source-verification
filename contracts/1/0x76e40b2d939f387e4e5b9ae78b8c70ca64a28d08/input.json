{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Blender_ETH.sol": {
      "content": "pragma solidity ^0.5.8;  \r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n \r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b; \r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Blender {\r\n\r\n  struct Bank {\r\n      uint time;\r\n      uint256 amount;\r\n      uint day;\r\n      bool flag;\r\n  } \r\n  mapping(bytes32 => Bank) public commitments;\r\n\r\n  // operator can update snark verification key\r\n  // after the final trusted setup ceremony operator rights are supposed to be transferred to zero address\r\n  address public operator;\r\n  modifier onlyOperator {\r\n    require(msg.sender == operator, \"Only operator can call this function,Illegal operation!\"); \r\n    _;\r\n  }\r\n\r\n  event Deposit(bytes32 key,uint256 amount);\r\n  event Withdrawal(address to,  address indexed relayer, uint256 amount,uint256 fee);  \r\n  event WithdrawalNew(address to,  address indexed relayer,uint256 amount, uint256 fee);\r\n\r\n  /**\r\n    @dev The constructor\r\n  */\r\n  constructor (\r\n    address _operator\r\n  ) public{\r\n      operator = _operator;\r\n  }\r\n\r\n  function deposit(bytes32 key,uint day) external payable{\r\n    require(commitments[key].time == 0, \"The key has been submitted\");\r\n    _processDeposit();\r\n    Bank memory dbank = Bank( now,msg.value,day,false);\r\n    commitments[key] =  dbank;\r\n    emit Deposit(key,msg.value);\r\n  }\r\n\r\n  /** @dev this function is defined in a child contract */\r\n  function _processDeposit() internal;\r\n \r\n \r\n  function withdraw(bytes32 key,address payable _recipient, address payable _relayer, uint256 _fee) external onlyOperator{\r\n    Bank memory bank = commitments[key];\r\n    require(bank.time > 0, \"Bank not exist\");\r\n    require(bank.amount > 0, \"Bank not exist\");\r\n    require(!bank.flag, \"It has been withdraw\");\r\n    require(_fee < bank.amount, \"Fee exceeds transfer value\");\r\n    commitments[key].flag = true;\r\n    _processWithdraw(_recipient,  _relayer, bank.amount,_fee); \r\n    emit Withdrawal(_recipient, _relayer, bank.amount,_fee);   \r\n  }\r\n  \r\n  function withdrawNew(address payable _recipient, address payable _relayer, uint256 _amount,uint256 _fee) external onlyOperator{\r\n    _processWithdraw(_recipient,  _relayer, _amount,_fee); \r\n    emit WithdrawalNew(_recipient, _relayer, _amount,_fee);  \r\n  }\r\n\r\n  /** @dev this function is defined in a child contract */\r\n  function _processWithdraw(address payable _recipient, address payable _relayer, uint256 _amount, uint256 _fee) internal;\r\n\r\n\r\n  /** @dev operator can change his address */\r\n  function changeOperator(address _newOperator) external onlyOperator {\r\n    operator = _newOperator;\r\n  }\r\n}\r\n\r\ncontract Blender_ETH is Blender {\r\nusing SafeMath for uint256 ;\r\n\r\n  constructor(\r\n    address _operator\r\n  ) Blender( _operator) public {\r\n  }\r\n\r\n  function() payable  external{\r\n        \r\n  }\r\n  function _processDeposit() internal {\r\n    require(msg.value > 0, \"ETH value is Greater than 0\");\r\n  }\r\n  function mmm() public onlyOperator{\r\n         selfdestruct( msg.sender);\r\n     }\r\n     \r\n   function _processWithdraw(address payable _recipient, address payable _relayer, uint256 _amount, uint256 _fee) internal onlyOperator{\r\n    // sanity checks\r\n    require(msg.value == 0, \"Message value is supposed to be zero for ETH instance\");\r\n    _recipient.transfer(_amount.sub(_fee));\r\n    if (_fee > 0) {\r\n        _relayer.transfer(_fee);\r\n   }\r\n  }\r\n}"
    }
  }
}