{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "DappGasTankFlat.sol": {
      "content": "// Sources flattened with hardhat v2.6.4 https://hardhat.org\n\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.3.2\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n\n\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.3.2\n\n\n\n\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n\n\n// File @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol@v4.3.2\n\n\n\n\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n\n\n// File contracts/7/gas-manager/gas-tank/DappGasTank.sol\n\n\n\n\n\n/**\n * @dev Context variant with ERC2771 support.\n */\nabstract contract ERC2771ContextUpgradeable is Initializable {\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address public _trustedForwarder;\n\n    function __ERC2771Context_init(address trustedForwarder) internal initializer {\n        __ERC2771Context_init_unchained(trustedForwarder);\n    }\n\n    function __ERC2771Context_init_unchained(address trustedForwarder) internal initializer {\n        _trustedForwarder = trustedForwarder;\n    }\n    \n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n    uint256[49] private __gap;\n}\n\n/* \n * @title DappGasTank\n * @author livingrock (Biconomy)\n * @title Dapp Deposit Gas Tank Contract\n * @notice Handles customers deposits  \n */\ncontract DappGasTank is Initializable, OwnableUpgradeable, ERC2771ContextUpgradeable {\n\n    address payable public masterAccount;\n    uint256 public minDeposit = 1e18;\n    uint8 internal _initializedVersion;\n    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    //Maintain balances for each funding key\n    mapping(uint256 => uint256) public dappBalances;\n\n    //Maintains fundingKey and depositedAmount information for each Depositor\n    //review mapping and how it is populated with each deposits\n    mapping(address => mapping(uint256 => uint256) ) public depositorBalances;\n\n    //Allowed tokens as deposit currency in Dapp Gas Tank\n    mapping(address => bool) public allowedTokens;\n    //Pricefeeds info should you require to calculate Token/ETH\n    mapping(address => address) public tokenPriceFeed;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /**\n     * @dev Initializes the contract\n     */\n    function initialize(address trustedForwarder) public initializer {\n       __ERC2771Context_init(trustedForwarder);\n       __Ownable_init();\n       _initializedVersion = 0;\n    }\n\n    event Deposit(address indexed sender, uint256 indexed amount, uint256 indexed fundingKey); // fundingKey \n    \n    event Withdraw(address indexed actor, uint256 indexed amount, address indexed receiver); // for when owner withdraws funds\n\n    event MasterAccountChanged(address indexed account, address indexed actor);\n\n    event MinimumDepositChanged(uint256 indexed minDeposit, address indexed actor);\n\n    event DepositTokenAdded(address indexed token, address indexed actor);\n\n    /**\n     * @dev Emitted when trusted forwarder is updated to \n     * another (`trustedForwarder`).\n     *\n     * Note that `trustedForwarder` may be zero. `actor` is msg.sender for this action.\n     */\n    event TrustedForwarderChanged(address indexed truestedForwarder, address indexed actor);\n\n\n    /**\n     * returns the message sender\n     */\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    /**\n     * returns the message data\n     */\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes memory)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n\n    /**\n     * Admin function to set minimum deposit amount\n     * emits and event \n     */\n    function setMinDeposit(uint256 _newMinDeposit) external onlyOwner{\n        minDeposit = _newMinDeposit;\n        emit MinimumDepositChanged(_newMinDeposit,msg.sender);\n    }\n\n    /**\n     * admin function to set trusted forwarder\n     * @param _forwarder new trusted forwarder address\n     *\n     */\n    function setTrustedForwarder(address payable _forwarder) external onlyOwner {\n        require(_forwarder != address(0), \"BICO:: Invalid address for new trusted forwarder\");\n        _trustedForwarder = _forwarder;\n        emit TrustedForwarderChanged(_forwarder, msg.sender);\n    }\n\n    /**\n     * Admin function to set master account which collects gas tank deposits\n     */\n    function setMasterAccount(address payable _newAccount) external onlyOwner{\n        masterAccount = _newAccount;\n        emit MasterAccountChanged(_newAccount, msg.sender);\n    }\n\n    /**\n     * Admin function to set token allowed for depositing in gas tank \n     */\n    function setTokenAllowed(address token, bool allowed) external onlyOwner{\n        require(token != address(0), \"Token address cannot be 0\");  \n        allowedTokens[token] = allowed;\n        emit DepositTokenAdded(token,msg.sender);\n    }\n     \n    /**\n     * @param _fundingKey Associate funds with this funding key. \n     * Supply a deposit for a specified funding key. (This will be a unique unix epoch time)\n     * Caution: The funding key must be an your identifier generated from biconomy dashboard \n     * Funds deposited will be forwarded to master account to fund the relayers\n     * emits an event for off-chain accounting\n     * @notice In the future this method may be upgraded to allow ERC20 token deposits \n     * @notice Generic depositFor could be added that allows deposit of ERC20 tokens and swaps them for native currency. \n     */\n    function depositFor(uint256 _fundingKey) public payable { \n        require(msg.sender == tx.origin || msg.sender == _trustedForwarder, \"sender must be EOA or trusted forwarder\");\n        require(msg.value > 0, \"No value provided to depositFor.\");\n        require(msg.value >= minDeposit, \"Must be grater than minimum deposit for this network\");\n        masterAccount.transfer(msg.value);\n        dappBalances[_fundingKey] = dappBalances[_fundingKey] + msg.value; \n        //review\n        depositorBalances[msg.sender][_fundingKey] = depositorBalances[msg.sender][_fundingKey] + msg.value;\n        emit Deposit(msg.sender, msg.value, _fundingKey);\n    }\n  \n    /** \n     * @dev If someone deposits funds directly to contract address\n     * Here we wouldn't know the funding key!\n     */ \n    receive() external payable {\n        require(msg.value > 0, \"No value provided to fallback.\");\n        require(tx.origin == msg.sender, \"Only EOA can deposit directly.\");\n        //review\n        //funding key stored is 0 \n        depositorBalances[msg.sender][0] = depositorBalances[msg.sender][0] + msg.value;\n        //All these types of deposits come under funding key 0\n        emit Deposit(msg.sender, msg.value, 0);\n    }\n\n    /**\n     * Admin function for sending/migrating any stuck funds. \n     */\n    function withdraw(uint256 _amount) public onlyOwner {\n        masterAccount.transfer(_amount);\n        emit Withdraw(msg.sender, _amount, masterAccount);\n    }\n}\n"
    }
  }
}