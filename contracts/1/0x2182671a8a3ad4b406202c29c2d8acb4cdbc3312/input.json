{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/MetaWallet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function transfer(address to, uint value) external returns (bool);\n    function approve(address to, uint value) external returns (bool);\n}\n\ncontract MetaWallet {\n    \n    string public constant name = \"MetaWallet\";\n    \n    address private _owner0;\n    address private _owner1;\n    \n    address private _pendingOwner0;\n    address private _pendingOwner1;\n    \n    constructor(address owner0, address owner1) public {\n        _owner0 = owner0;\n        _owner1 = owner1;\n    }\n    \n    // @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the execute struct used by the contract\n    bytes32 public constant EXECUTE_TYPEHASH = keccak256(\"Execute(address to,uint value,bytes data,uint nonces,uint deadline)\");\n\n    /// @notice The EIP-712 typehash for the send struct used by the contract\n    bytes32 public constant SEND_TYPEHASH = keccak256(\"Send(address to,uint value,uint nonces,uint deadline)\");\n\n    /// @notice The EIP-712 typehash for the transfer struct used by the contract\n    bytes32 public constant TRANSFER_TYPEHASH = keccak256(\"Transfer(address token,address to,uint value,uint nonces,uint deadline)\");\n\n    /// @notice The EIP-712 typehash for the approve struct used by the contract\n    bytes32 public constant APPROVE_TYPEHASH = keccak256(\"Approve(address token,address to,uint value,uint nonces,uint deadline)\");\n    \n    function transferOwnership(address _newOwner) external {\n        require(msg.sender == _owner0 || msg.sender == _owner1, \"MetaWallet::transferOwnership: !owner\");\n        if (msg.sender == _owner0) {\n            _pendingOwner0 = _newOwner;\n        } else if (msg.sender == _owner1) {\n            _pendingOwner1 = _newOwner;\n        }\n    }\n    \n    function acceptOwnership() external {\n        require(msg.sender == _pendingOwner0 || msg.sender == _pendingOwner1, \"MetaWallet::acceptOwnership: !pendingOwner\");\n        if (msg.sender == _pendingOwner0) {\n            _owner0 = _pendingOwner0;\n        } else if (msg.sender == _pendingOwner1) {\n            _owner1 = _pendingOwner1;\n        }\n    }\n    \n    /// @notice A record of states for signing / validating signatures\n    uint public nonces;\n    \n    fallback() external {}\n    \n    function send(address payable to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool, bytes memory) {\n        require(_verify(keccak256(abi.encode(SEND_TYPEHASH, to, value, nonces++, deadline)), deadline, v, r, s));\n        return to.call{value: value}(\"\");\n    }\n    \n    function transfer(address token, address to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool) {\n        require(_verify(keccak256(abi.encode(TRANSFER_TYPEHASH, token, to, value, nonces++, deadline)), deadline, v, r, s));\n        return IERC20(token).transfer(to, value);\n    }\n    \n    function approve(address token, address to, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool) {\n        require(_verify(keccak256(abi.encode(APPROVE_TYPEHASH, token, to, value, nonces++, deadline)), deadline, v, r, s));\n        return IERC20(token).approve(to, value);\n    }\n    \n    function _verify(bytes32 structHash, uint deadline, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this)));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        return ((signatory == _owner0 || signatory == _owner1) && now <= deadline);\n    }\n    \n    struct stack {\n        address recipients;\n        uint values;\n        bytes datas;\n        uint deadlines; \n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n    \n    function batch(stack[] calldata stacks) external returns (bool[] memory results, bytes[] memory responses) {\n        for (uint i = 0; i < stacks.length; i++) {\n            (results[i], responses[i]) = _exec(stacks[i].recipients, stacks[i].values, stacks[i].datas, stacks[i].deadlines, stacks[i].v, stacks[i].r, stacks[i].s);\n        }\n    }\n    \n    function execute(address to, uint value, bytes calldata data, uint deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool, bytes memory) {\n        return _exec(to, value, data, deadline, v, r, s);\n    }\n    \n    function _exec(address to, uint value, bytes memory data, uint deadline, uint8 v, bytes32 r, bytes32 s) internal returns (bool, bytes memory) {\n        require(_verify(keccak256(abi.encode(EXECUTE_TYPEHASH, to, value, data, nonces++, deadline)), deadline, v, r, s));\n        return to.call{value: value}(data);\n    }\n    \n    function _getChainId() internal pure returns (uint) {\n        uint chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}\n\ncontract MetaWalletFactory {\n    \n    struct stack {\n        address wallet;\n        address to;\n        uint value;\n        bytes data;\n        uint deadline; \n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n    \n    struct id {\n        uint index0;\n        address owner0;\n        uint index1;\n        address owner1;\n    }\n    \n    mapping(address => address[]) public lookups;\n    mapping(address => id) public indexes;\n    \n    function lookup(address wallet) external view returns (uint index0, address owner0, uint index1, address owner1) {\n        return (indexes[wallet].index0, indexes[wallet].owner0, indexes[wallet].index1, indexes[wallet].owner1);\n    }\n    \n    function wallet(address owner, uint index) external view returns (address) {\n        return lookups[owner][index];\n    }\n    \n    function wallets(address owner) external view returns (address[] memory) {\n        return lookups[owner];\n    }\n    \n    function createWallet(address _owner0, address _owner1) external {\n        address _wallet = address(new MetaWallet(_owner0, _owner1));\n        indexes[_wallet] = id(lookups[_owner0].length, _owner0, lookups[_owner1].length, _owner1);\n        lookups[_owner0].push(_wallet);\n        lookups[_owner1].push(_wallet);\n        \n    }\n    \n    function batch(stack[] calldata stacks) external returns (bool[] memory results, bytes[] memory responses) {\n        for (uint i = 0; i < stacks.length; i++) {\n            (results[i], responses[i]) = MetaWallet(stacks[i].wallet).execute(stacks[i].to, stacks[i].value, stacks[i].data, stacks[i].deadline, stacks[i].v, stacks[i].r, stacks[i].s);\n        }\n    }\n}"}}}