{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Thera.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5 <0.8.0;\n\n/**\n     * Thera.Foundation Emerald Smart Contract - Suite of foundings to develop the Amazon.\n     * \n     * Each Thera reforests a tree among 2.000 species of selected breed, some harness shadow others enroot water, others help life some bring bees.\n     * To Receive Theras, Choose a TheraFounding of your Choose. Each TheraFounding also develops the bestest of technology in the Amazon Region and reduces Carbon emssion.\n     * All TheraFounding projects depend on each other to co-exist and co-evolve.\n     * There will be a total of 7 TheraFoundings, each will be Unpaused as team and infrastructure grow.\n     * \n     * Cada Thera refloresta uma árvore entre 2.000 espécies de raças selecionadas, alguns aproveitam a sombra, outros enraizam a água, outros ajudam a vida, alguns trazem abelhas.\n     * Para receber Theras, escolha um TheraFounding de sua escolha. Cada TheraFounding também desenvolve o que há de melhor em tecnologia na Amazônia e reduze a emissão de Carbono.\n     * Todos os projetos do TheraFounding dependem uns dos outros para coexistir e evoluir.\n     * Haverá um total de 7 TheraFoundings, cada um não pausado conforme a equipe e a infraestrutura crescerem.\n     *\n     * Code developed by trees for gaia a Sidi Corp business. Thera foundation is operated by Thera foundation through D S Sidi Brasil Manaus-Amazonas.\n     * \n     */\n\n\n//All Purpose Library to help with the math equations\n\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n//All purpose contract giving ownership to Contract\nabstract contract Ownable {\n    address payable private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address payable) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address payable newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n//Erc20 Interface to negotatiate with open market in a standard giving more value and tradablilty \ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// ERC20 Contract and directions of flow between ethereum, token and User.\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    uint256 private constant MAXCAP = 10000000 * (10 ** uint256(18));\n\n    function totalSupply() override public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) override public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) override public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) override public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 value) override public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) override public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        require(amount + totalSupply() <= MAXCAP, \"Max Cap: request for minting more than possible value\");\n        \n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n}\n\n//Token Details with name, symbol and Decimals\nabstract contract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n//Roles help store addresses and give them functions.\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n//The Pauser Role helps Pause the Contract.\ncontract PauserRole {\n    using Roles for Roles.Role;\n\n    event PauserAdded(address indexed account);\n    event PauserRemoved(address indexed account);\n\n    Roles.Role private _pausers;\n\n    constructor () {\n        _addPauser(msg.sender);\n    }\n\n    modifier onlyPauser() {\n        require(isPauser(msg.sender), \"PauserRole: caller does not have the Pauser role\");\n        _;\n    }\n\n    function isPauser(address account) public view returns (bool) {\n        return _pausers.has(account);\n    }\n\n    function addPauser(address account) public onlyPauser {\n        _addPauser(account);\n    }\n\n    function _addPauser(address account) internal {\n        _pausers.add(account);\n        emit PauserAdded(account);\n    }\n\n    function _removePauser(address account) internal {\n        _pausers.remove(account);\n        emit PauserRemoved(account);\n    }\n}\n\ncontract Pausable is PauserRole {\n    event Paused(address account);\n    event Unpaused(address account);\n    bool private _paused;\n\n    constructor (){\n        _paused = false;\n    }\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    function pause() public onlyPauser whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\nabstract contract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor (){\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\ncontract TheraSeeding is ERC20, MinterRole {\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n//Crowdsale for the Trees.\ncontract Crowdsale is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    IERC20 private _token;\n    address payable private _wallet;\n    uint256 private _rate;\n    uint256 private _weiRaised;\n\n    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n    constructor (uint256 rate, address payable wallet, IERC20 token) public {\n        require(rate > 0, \"Crowdsale: rate is 0\");\n        require(wallet != address(0), \"Crowdsale: wallet is the zero address\");\n        require(address(token) != address(0), \"Crowdsale: token is the zero address\");\n\n        _rate = rate;\n        _wallet = wallet;\n        _token = token;\n    }\n\n   receive () external payable {\n       this.buyTokens{value: msg.value}(msg.sender);\n    }\n\n    function token() public view returns (IERC20) {\n        return _token;\n    }\n\n    function wallet() public view returns (address payable) {\n        return _wallet;\n    }\n\n    function rate() public view returns (uint256) {\n        return _rate;\n    }\n\n    function weiRaised() public view returns (uint256) {\n        return _weiRaised;\n    }\n\n    function buyTokens(address beneficiary) public nonReentrant whenNotPaused payable {\n        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(beneficiary, weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = _getTokenAmount(weiAmount);\n        tokens = tokens.mul(10 ** uint256(18));\n        // update state\n        _weiRaised = _weiRaised.add(weiAmount);\n        \n        _processPurchase(beneficiary, tokens);\n        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);\n\n        _updatePurchasingState(beneficiary, weiAmount);\n\n        _forwardFunds();\n        _postValidatePurchase(beneficiary, weiAmount);\n    }\n\n    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\n        require(beneficiary != address(0), \"Crowdsale: beneficiary is the zero address\");\n        require(weiAmount != 0, \"Crowdsale: weiAmount is 0\");\n    }\n\n    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) virtual internal {\n        _token.safeTransfer(beneficiary, tokenAmount);\n    }\n\n    function _processPurchase(address beneficiary, uint256 tokenAmount) internal {\n        _deliverTokens(beneficiary, tokenAmount);\n    }\n\n    function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\n        return weiAmount.div(_rate);\n    }\n\n    function _forwardFunds() internal {\n        _wallet.transfer(msg.value);\n    }\n}\nabstract contract TheraFounding is Crowdsale {\n    function _deliverTokens(address beneficiary, uint256 tokenAmount) override internal {\n        // Potentially dangerous assumption about the type of the token.\n        require(\n            TheraSeeding(address(token())).mint(beneficiary, tokenAmount),\n                \"MintedCrowdsale: minting failed\"\n        );\n    }\n}\n\n//Token Contract stabilized with Details, Minting qualitys and ownability.\ncontract Thera is ERC20, ERC20Detailed,TheraSeeding, Ownable, Pausable  {\n    uint8 internal constant DECIMALS = 18;\n\n    receive() external payable {\n    }\n    \n    function getBalance() public view returns(uint256) {\n        return address(this).balance;\n    }\n    \n    function withdrawEther() external onlyOwner {\n        owner().transfer(getBalance());\n    }\n    \n    constructor () public\n     ERC20Detailed(\"THERA\", \"THERA\", DECIMALS)  {\n    }\n    \n    string public emblema = \"Therae lux in mundum\";\n    \n    \n}\n//Minter Minting Contract seeding Theras for the purpose of developing Co2 emssion captures pricification bringing and initial Thera plantations.\ncontract TheraAether is TheraFounding {\n    uint256 internal constant RATE = 39060000000000000;\n    \n    constructor(address payable Wallet, address payable Token) public Crowdsale(RATE, Wallet, TheraSeeding(Token)) {\n    }\n}\n//Minter Minting Contract seeding Theras for the purpose of developing Drone technology capable of automated reforestations.\ncontract TheraSeed is TheraFounding {\n    uint256 internal constant RATE = 39060000000000000;\n    \n    constructor(address payable Wallet, address payable Token) public Crowdsale(RATE, Wallet, TheraSeeding(Token)) {\n    }\n}\n//Minter Minting Contract seeding Theras for the purpose of developing blockchain like market selling Amazonian products.\ncontract TheraMarket is TheraFounding {\n    uint256 internal constant RATE = 39060000000000000;\n    \n    constructor(address payable Wallet, address payable Token) public Crowdsale(RATE, Wallet, TheraSeeding(Token)) {\n    }\n}\n\n//Minter Minting Contract seeding Theras for the purpose of developing cures and medicines using the exotic anticancer agents found in the Amazon Bioma.\ncontract TheraBioTech is TheraFounding {\n    uint256 internal constant RATE = 39060000000000000;\n    \n    constructor(address payable Wallet, address payable Token) public Crowdsale(RATE, Wallet, TheraSeeding(Token)) {\n    }\n}\n//Minter Minting Contract seeding Theras for the purpose of developing Disruptive technology and uniting multi-patent technologies for genesis like creations.\ncontract TheraTech is TheraFounding {\n    uint256 internal constant RATE = 39060000000000000;\n    \n    constructor(address payable Wallet, address payable Token) public Crowdsale(RATE, Wallet, TheraSeeding(Token)) {\n    }\n}\n\n//Minter Minting Contract seeding Theras for the purpose of developing 0 point renewable Energy in the Amazon.\ncontract TheraEnergy is TheraFounding {\n    uint256 internal constant RATE = 39060000000000000;\n    \n    constructor(address payable Wallet, address payable Token) public Crowdsale(RATE, Wallet, TheraSeeding(Token)) {\n    }\n}\n\n//Minter Minting Contract seeding Theras for the purpose of developing space technology in the Amazon Equatoria Line with universal launches in perspective and fuel saving\ncontract TheraSpace is TheraFounding {\n    uint256 internal constant RATE = 39060000000000000;\n    \n    constructor(address payable Wallet, address payable Token) public Crowdsale(RATE, Wallet, TheraSeeding(Token)) {\n    }\n}\n"}}}