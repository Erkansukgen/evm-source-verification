{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Playshare/stakepool.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-11-11\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\n//import \"./nft.sol\";\n\n\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n    }\n    \n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n    }\n    \n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n    \n    return c;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    \n    function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n    ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    \n    return c;\n    }\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n    return 0;\n    }\n    \n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n    \n    return c;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n    }\n    \n    function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n    ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    \n    return c;\n    }\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    \n    function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n    ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n    }\n}\n\ncontract Context1 {\n    constructor()  {}\n    \n    function _msgSender_() internal view returns (address payable) {\n    return payable(msg.sender);\n    }\n    \n    function _msgData_() internal view returns (bytes memory) {\n    this;\n    return msg.data;\n    }\n}\n\ncontract Ownable is Context1 {\n    address private _owner;\n    \n    event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n    );\n    \n    constructor()  {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n    }\n    \n    function owner() public view returns (address) {\n    return _owner;\n    }\n    \n    modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n    }\n    \n    function isOwner() public view returns (bool) {\n    return msg.sender == _owner;\n    }\n    \n    function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n    }\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n    }\n    \n    function _transferOwnership(address newOwner) internal {\n    require(\n    newOwner != address(0),\n    \"Ownable: new owner is the zero address\"\n    );\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n    }\n}\n\n/**\n* @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n* the optional functions; to access them see {ERC20Detailed}.\n*/\ninterface IERC20 {\n    /**\n    * @dev Returns the amount of tokens in existence.\n    */\n    function totalSupply() external view returns (uint256);\n    \n    /**\n    * @dev Returns the token decimals.\n    */\n    function decimals() external view returns (uint8);\n    \n    /**\n    * @dev Returns the token symbol.\n    */\n    function symbol() external view returns (string memory);\n    \n    /**\n    * @dev Returns the token name.\n    */\n    function name() external view returns (string memory);\n    \n    /**\n    * @dev Returns the bep token owner.\n    */\n    function getOwner() external view returns (address);\n    \n    /**\n    * @dev Returns the amount of tokens owned by `account`.\n    */\n    function balanceOf(address account) external view returns (uint256);\n    \n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    \n    /**\n    * @dev Returns the remaining number of tokens that `spender` will be\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\n    * zero by default.\n    *\n    * This value changes when {approve} or {transferFrom} are called.\n    */\n    function allowance(address _owner, address spender) external view returns (uint256);\n    \n    /**\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\n    * that someone may use both the old and the new allowance by unfortunate\n    * transaction ordering. One possible solution to mitigate this race\n    * condition is to first reduce the spender's allowance to 0 and set the\n    * desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    *\n    * Emits an {Approval} event.\n    */\n    function approve(address spender, uint256 amount) external returns (bool);\n    \n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\n    * allowance mechanism. `amount` is then deducted from the caller's\n    * allowance.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n    ) external returns (bool);\n    \n    /**\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\n    * another (`to`).\n    *\n    * Note that `value` may be zero.\n    */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /**\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    * a call to {approve}. `value` is the new allowance.\n    */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Address1 {\n    /**\n    * @dev Returns true if `account` is a contract.\n    *\n    * This test is non-exhaustive, and there may be false-negatives: during the\n    * execution of a contract's constructor, its address will be reported as\n    * not containing a contract.\n    *\n    * IMPORTANT: It is unsafe to assume that an address for which this\n    * function returns false is an externally-owned account (EOA) and not a\n    * contract.\n    */\n    function isContract(address account) internal view returns (bool) {\n    // This method relies in extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n    \n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly { codehash := extcodehash(account) }\n    return (codehash != 0x0 && codehash != accountHash);\n    }\n    \n    /**\n    * @dev Converts an `address` into `address payable`. Note that this is\n    * simply a type cast: the actual underlying value is not changed.\n    *\n    * Available since v2.4.0.\n    */\n    function toPayable(address account) internal pure returns (address payable) {\n    return payable(address(uint160(account)));\n    }\n    \n    /**\n    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n    * `recipient`, forwarding all available gas and reverting on errors.\n    *\n    * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n    * of certain opcodes, possibly making contracts go over the 2300 gas limit\n    * imposed by `transfer`, making them unable to receive funds via\n    * `transfer`. {sendValue} removes this limitation.\n    *\n    * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n    *\n    * IMPORTANT: because control is transferred to `recipient`, care must be\n    * taken to not create reentrancy vulnerabilities. Consider using\n    * {ReentrancyGuard} or the\n    * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n    *\n    * Available since v2.4.0.\n    */\n    function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n    \n    // solhint-disable-next-line avoid-call-value\n    (bool success, ) = recipient.call{value:amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// interface IPool {\n//     function notifyReward() external payable ;\n//     }\n\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n\n/**\n* @title SafeERC20\n* @dev Wrappers around ERC20 operations that throw on failure (when the token\n* contract returns false). Tokens that return no value (and instead revert or\n* throw on failure) are also supported, non-reverting calls are assumed to be\n* successful.\n* To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n* which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n*/\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address1 for address;\n    \n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n    \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    \n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    // solhint-disable-next-line max-line-length\n    require((value == 0) || (token.allowance(address(this), spender) == 0),\n    \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    \n    /**\n    * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n    * on the return value: the return value is optional (but if data is returned, it must not be false).\n    * @param token The token targeted by the call.\n    * @param data The call data (encoded using abi.encode or one of its variants).\n    */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves.\n    \n    // A Solidity high level call has three parts:\n    // 1. The target address is checked to verify it contains contract code\n    // 2. The call itself is made, and success asserted\n    // 3. The return value is decoded, which in turn checks the size of the returned data.\n    // solhint-disable-next-line max-line-length\n    require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n    \n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = address(token).call(data);\n    require(success, \"SafeERC20: low-level call failed\");\n    \n    if (returndata.length > 0) { // Return data is optional\n    // solhint-disable-next-line max-line-length\n    require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n    }\n}\n\ncontract LPTokenWrapper is Ownable {\n    \n    \n    uint256 counter;\n    struct Stakepool {\n        uint256 timestamp;\n        uint256 amount;\n        address walletaddress;\n        bool iswhitelisted;\n        uint256 participationCount;\n        bool stakeStatus;\n        uint256 initialStakeTime;\n    }\n    \n    uint256 participationCount=0;\n    mapping(address => uint256)  Stakecount;\n    \n    mapping (uint256 => Stakepool) Stakemap;\n    uint256[] public stakeAccts;\n    \n    mapping (address => uint256[]) public toCheckList;\n\n    \n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    \n    //IERC20 public BAKED;\n    \n    IERC20 public BAKED = IERC20(0xa4cb0dCe4849BdcAd2d553E9e68644Cf40E26ccE); // BAKED Token\n    \n\n    \n    uint256 private _totalSupply;\n    //uint256 public counter=0;\n    mapping(address => uint256) private _balances;\n    \n    function totalSupply() public view returns (uint256) {\n    return _totalSupply.div(10 **18);\n    }\n    \n    function _balanceOf(address account) public view returns (uint256) {\n    return _balances[account].div(10**18);\n    }\n    \n    function stake(uint256 _stkId,uint256 amount) public virtual {\n        amount = amount.mul(10**18);\n    require(BAKED.balanceOf(msg.sender)>= amount,\"Error: User Token Balance is insufficient\");\n    _totalSupply = _totalSupply + amount;\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n    BAKED.safeTransferFrom\n    (msg.sender, address(this), amount);\n    }\n    \n    function withdraw(uint256 _stkId,uint256 amount) public virtual{\n        amount = amount.mul(10**18);\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    BAKED.safeTransfer(msg.sender, amount);\n    }\n    \n    function setStakePool(uint256 _stkId, uint256 _amount) public {\n        //var Stakepool = Stakemap[counter];\n        \n        Stakemap[_stkId].timestamp = block.timestamp;\n        Stakemap[_stkId].amount = _amount;\n        Stakemap[_stkId].walletaddress = msg.sender;\n        Stakemap[_stkId].stakeStatus = true;\n        Stakemap[_stkId].initialStakeTime = block.timestamp;\n        toCheckList[msg.sender].push(_stkId);\n\n    }\n    \n    function getStakes(uint256 _stakeid) view public returns (uint256, uint256, uint256, address, bool,bool,uint256) {\n        return (_stakeid,Stakemap[_stakeid].amount, Stakemap[_stakeid].timestamp, Stakemap[_stakeid].walletaddress,Stakemap[_stakeid].iswhitelisted,Stakemap[_stakeid].stakeStatus,Stakemap[_stakeid].initialStakeTime);\n    }\n    \n}\n\ncontract BakedLpPool is LPTokenWrapper {\n    \n    \n    uint256 public duration = 30 days; // 30 days;\n    uint256 starttime = 0; // trace startdate of staking pool\n    uint256 public minTokenValue= 25000;\n    uint256 trackStakeTime;\n    \n    uint256 whitelistedTime;\n    \n    \n    mapping(address => uint256) userRewardPerTokenPaid;\n    mapping(address => uint256) rewards;\n    \n    uint256 public totalparticipationCount=0;\n    mapping(address => uint256) public Totalticket;\n    \n    \n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event Rewarded(address indexed from, address indexed to, uint256 value);\n    \n\n    function adminSetMinTokenAmount(uint256 _minTokenAmount) public onlyOwner {\n    minTokenValue = _minTokenAmount;\n    }\n    \n    function adminSetDuration(uint256 _duration) public onlyOwner {\n    duration = _duration;\n    }\n    \n    function stake(uint256 _stkId, uint256 amount) public  override {\n    require(amount > 0, \"Error : Cannot stake 0\");\n    require(amount >= minTokenValue, \"Error : Canot stake, need minimum Baked tokens\");\n    super.stake(_stkId,amount);\n    trackStakeTime=block.timestamp;\n    super.setStakePool(_stkId,amount);\n    }\n    \n    function withdraw(uint256 _stkId,uint256 amount) public override\n    {\n        uint256 stkTime = Stakemap[_stkId].initialStakeTime;\n        uint256 unstakeTime = stkTime + duration;\n    require(block.timestamp>=unstakeTime,\"Error:User not Completed the Lock duration\");\n    require(amount > 0, \"Error : Cannot withdraw 0\");\n    super.withdraw(_stkId,amount);\n    Stakemap[_stkId].stakeStatus = false;\n    \n    }\n    \n    \n    function whiteListed(uint256 _stakeid) public {\n        whitelistedTime = Stakemap[_stakeid].timestamp + duration;\n        require(block.timestamp >=whitelistedTime, \"Your Lock duration is not completed\" );\n        Stakemap[_stakeid].iswhitelisted = true;\n        \n        \n        uint256 rewardDuration =block.timestamp - Stakemap[_stakeid].timestamp;                                                                                                               \n        require(rewardDuration >= duration, \"Locking Period is not over\");\n        uint256 ticketonduration = rewardDuration/duration;\n        \n        require(Stakemap[_stakeid].amount >= minTokenValue,\"balance is low reward not applicable\");\n        uint256 ticketonamount = Stakemap[_stakeid].amount/minTokenValue;\n        \n        uint256 tempcount = Stakemap[_stakeid].participationCount;\n         Stakemap[_stakeid].participationCount = (ticketonamount * ticketonduration) + tempcount;\n        \n        address tempaddress = Stakemap[_stakeid].walletaddress;\n        Totalticket[tempaddress] = Totalticket[tempaddress] + (Stakemap[_stakeid].participationCount - tempcount);\n        \n       \n        Stakemap[_stakeid].timestamp = block.timestamp; \n    }\n    \n    function AllStakes(address _addr) public view returns(uint256[] memory)\n    {\n        return toCheckList[_addr];\n    }\n\n    \n    function iswhitelisted(uint256 _stakeid) public view returns(bool){\n        return Stakemap[_stakeid].iswhitelisted;\n    } \n    \n    function ticketcount(uint256 _stakeid) public view returns(uint256){\n        return Stakemap[_stakeid].participationCount;\n    }\n    \n    function changeAdmin(address newOwner) public onlyOwner{\n        transferOwnership(newOwner);\n    }\n    \n}\n"
    }
  }
}