{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/AtlantisCore.sol": {
      "content": "\n// File: @openzeppelin/contracts/GSN/Context.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/AtlantisCore.sol\n\npragma solidity <=0.6.2;\n\n\ninterface ITask {\n    function check(uint _requirement) external view returns (uint256);\n    function execute() external;\n}\n\ninterface IWhirlpool {\n    function claim() external;\n    function getAllInfoFor(address _user) external view returns (bool isActive, uint256[12] memory info);\n}\n\ninterface ISURF3D {\n    function dividendsOf(address _user) external view returns (uint256);\n    function withdraw() external returns (uint256);\n}\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IFreeFromUpTo {\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n}\n\ncontract AtlantisCore is Ownable {\n    IFreeFromUpTo public constant gst = IFreeFromUpTo(0x0000000000b3F879cb30FE243b4Dfee438691c04);\n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n\n    address private constant _surf = 0xEa319e87Cf06203DAe107Dd8E5672175e3Ee976c;\n    address private constant _surf3D = 0xeb620A32Ea11FcAa1B3D70E4CFf6500B85049C97;\n    address private constant _whirlpool = 0x999b1e6EDCb412b59ECF0C5e14c20948Ce81F40b;\n\n    address[] public processors;\n\n    // track the total amount of incentive burned by this core\n    uint private _totalBurned;\n\n    // track the total amount of tasks created\n    uint private _totalTasks;\n\n    // mapping of task IDs to respective struct\n    mapping (uint => Task) private _taskMap;\n\n    // mapping of addresses to total incentive received\n    mapping (address => uint) private _totalIncentiveReceived;\n    \n    // mapping of addresses to total tasks executed\n    mapping (address => uint) private _totalTasksByProcessor;\n\n    // mapping of task IDs to when they were last executed (unix timestamp). used for throttle\n    mapping (uint => uint) private _taskTimestamp;\n\n    // mapping indiciating that an address has processed for this core at least once\n    mapping (address => bool) private _processed;\n\n    // mapping of processor addressses to when they were last seen by this core\n    mapping (address => uint) public processorTimestamp;\n\n    struct Task {\n        // address of the contract which implements the ITask interface\n        address process;\n        // is this task enabled?\n        bool enabled;\n        // how much SURF will incentivize this task\n        uint incentive;\n        // ratio of incentive to burn, send rest to caller. 0 = disabled, 1 = 100%, 2 = 50%, 3 = 33%, 4 = 25%, etc\n        uint burnRatio;\n        // how much time to wait before allowing this task to be executed again. 0 = disable\n        uint throttle;\n        // task requirement variable - used for minimum balance checks etc\n        uint requirement;\n    }\n\n    modifier discountGST {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        gst.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41130);\n    }\n\n    modifier discountCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41130);\n    }\n\n    constructor()\n    public {\n        _taskMap[0] = Task({\n            process: address(0x0),\n            enabled: true,\n            incentive: 200 ether,       // 200 SURF (100 received)\n            burnRatio: 2,               // burn 50%\n            throttle: 1 weeks,          // every week\n            requirement: 1000 ether     // if the whirlpool rewards are more than 1000 SURF\n        });\n\n        _totalTasks++;\n    }\n\n    function _check(uint _requirement)\n    internal view returns (uint256) {\n       (, uint256[12] memory userData) = IWhirlpool(_whirlpool).getAllInfoFor(address(this));\n\n        if(userData[10] >= _requirement)\n            return 0;\n        else\n            return _requirement - userData[10];\n    }\n\n    function _execute()\n    internal {\n        IWhirlpool(_whirlpool).claim();\n\n        if(ISURF3D(_surf3D).dividendsOf(address(this)) > 0)\n            ISURF3D(_surf3D).withdraw();\n    }\n\n    function _process(uint _taskID, address _processor)\n    internal {\n        // only allow execution if the timestamp throttle is expired\n        require(block.timestamp >= _taskTimestamp[_taskID] + _taskMap[_taskID].throttle, \"\");\n        // only allow execution if the task is enabled (incentives active)\n        require(_taskMap[_taskID].enabled, \"\");\n\n        // load requirement\n        uint requirement = _taskMap[_taskID].requirement;\n        address taskProcess = _taskMap[_taskID].process;\n\n        // only allow execution if the task requirements are met - if any\n        if(requirement > 0)\n            require(_taskID == 0 ? _check(requirement) == 0 : ITask(taskProcess).check(requirement) == 0, \"\");\n\n        // load other variables \n        uint incentive = _taskMap[_taskID].incentive;\n        uint burnRatio = _taskMap[_taskID].burnRatio;\n        \n        // execute the task\n        _taskID == 0 ? _execute() : ITask(taskProcess).execute();\n\n        // if this is the first time they are processing a task\n        if(!_processed[_processor]) {\n            _processed[_processor] = true;\n            processors.push(_processor);\n        }\n\n        processorTimestamp[_processor] = block.timestamp;\n\n        // burn whatever amount of tokens specified by the burnRatio - if any\n        if(burnRatio != 0)\n            IERC20(_surf).transfer(_surf, incentive / burnRatio);\n\n        uint incentiveReceived = burnRatio == 0 ? incentive : incentive - (incentive / burnRatio);\n\n        IERC20(_surf).transfer(_processor, incentiveReceived);\n\n        _totalIncentiveReceived[_processor] += incentiveReceived;\n\n        if(incentive - incentiveReceived > 0)\n            _totalBurned += (incentive - incentiveReceived);\n\n        _totalTasksByProcessor[_processor]++;\n        _taskTimestamp[_taskID] = block.timestamp;\n    }\n\n    function addTask(address _taskProcess, uint _incentive, uint _burnRatio, uint _throttle, uint _requirement)\n    external onlyOwner {\n        _taskMap[_totalTasks] = Task({\n            process: _taskProcess,\n            enabled: true,\n            incentive: _incentive,\n            burnRatio: _burnRatio,\n            throttle: _throttle,\n            requirement: _requirement\n        });\n\n        _totalTasks++;\n    }\n\n    function editTask(uint _taskID, address _taskProcess, bool _enabled, uint _incentive, uint _burnRatio, uint _throttle, uint _requirement)\n    external onlyOwner {\n        _taskMap[_taskID] = Task({\n            process: _taskProcess,\n            enabled: _enabled,\n            incentive: _incentive,\n            burnRatio: _burnRatio,\n            throttle: _throttle,\n            requirement: _requirement\n        });\n    }\n\n    function process(uint _taskID, address _processor)\n    external {\n        // if the contract is calling itself via the bulkProcess() loop\n        if(msg.sender == address(this))\n            _process(_taskID, _processor);\n        else\n            _process(_taskID, msg.sender);\n    }\n\n    function processCHI(uint _taskID)\n    external discountCHI {\n        _process(_taskID, msg.sender);\n    }\n\n    function processGST(uint _taskID)\n    external discountGST {\n        _process(_taskID, msg.sender);\n    }\n\n    function bulkProcess(uint256[] calldata _taskIDs)\n    external {\n        // loop through all specified task IDs\n        for(uint x = 0; x < _taskIDs.length; x++)\n            // manually call process() - if the tx fails (due to task being executed while tx is in transit etc) we ignore it and proceed instead of reverting the entire tx\n            address(this).call(abi.encodeWithSignature(\"process(uint256,address)\", _taskIDs[x], msg.sender));\n    }\n\n    function bulkProcessCHI(uint256[] calldata _taskIDs)\n    external discountCHI {\n        // loop through all specified task IDs\n        for(uint x = 0; x < _taskIDs.length; x++)\n            // manually call process() - if the tx fails (due to task being executed while tx is in transit etc) we ignore it and proceed instead of reverting the entire tx\n            address(this).call(abi.encodeWithSignature(\"process(uint256,address)\", _taskIDs[x], msg.sender));\n    }\n\n    function bulkProcessGST(uint256[] calldata _taskIDs)\n    external discountGST {\n        // loop through all specified task IDs\n        for(uint x = 0; x < _taskIDs.length; x++)\n            // manually call process() - if the tx fails (due to task being executed while tx is in transit etc) we ignore it and proceed instead of reverting the entire tx\n            address(this).call(abi.encodeWithSignature(\"process(uint256,address)\", _taskIDs[x], msg.sender));\n    }\n\n    function check(uint _requirement)\n    external view returns (uint256) {\n        return _check(_requirement);\n    }\n\n    function viewStatsFor(address _processor)\n    external view returns (uint256, uint256) {\n        return (_totalIncentiveReceived[_processor], _totalTasksByProcessor[_processor]);\n    }\n\n    function viewCore()\n    external view returns (uint256, uint256) {\n        return (_totalBurned, _totalTasks);\n    }\n\n    function viewAllStatsFor(address _processor)\n    external view returns (uint256, uint256, uint256, uint256) {\n        return (_totalIncentiveReceived[_processor], _totalTasksByProcessor[_processor], _totalBurned, _totalTasks);\n    }\n\n    function viewTask(uint _taskID)\n    external view returns (bool, uint256, uint256, uint256, uint256) {\n        return (_taskMap[_taskID].enabled, _taskMap[_taskID].incentive, _taskMap[_taskID].burnRatio, _taskMap[_taskID].throttle, _taskMap[_taskID].requirement);\n    }\n\n    // returns time left and requirement left (if any)\n    function viewTaskCheck(uint _taskID)\n    external view returns (uint256, uint256) {\n        uint throttleTimeLeft;\n\n        if(_taskTimestamp[_taskID] + _taskMap[_taskID].throttle > block.timestamp)\n            throttleTimeLeft = (_taskTimestamp[_taskID] + _taskMap[_taskID].throttle) - block.timestamp;\n        else\n            throttleTimeLeft = 0;\n\n        return (throttleTimeLeft, _taskID == 0 ? _check(_taskMap[_taskID].requirement) : ITask(_taskMap[_taskID].process).check(_taskMap[_taskID].requirement));\n    }\n\n    function viewProcessorLength()\n    external view returns (uint256) {\n        return processors.length;\n    }\n\n    function viewProcessors()\n    external view returns (address[] memory) {\n        return processors;\n    }\n}\n"
    }
  }
}