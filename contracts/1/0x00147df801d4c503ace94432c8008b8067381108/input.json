{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "inariHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n‚ñÑ‚ñÑ‚ñà    ‚ñÑ   ‚ñà‚ñà   ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñà \n‚ñà‚ñà     ‚ñà  ‚ñà ‚ñà  ‚ñà  ‚ñÑ‚ñÄ ‚ñà‚ñà \n‚ñà‚ñà ‚ñà‚ñà   ‚ñà ‚ñà‚ñÑ‚ñÑ‚ñà ‚ñà‚ñÄ‚ñÄ‚ñå  ‚ñà‚ñà \n‚ñê‚ñà ‚ñà ‚ñà  ‚ñà ‚ñà  ‚ñà ‚ñà  ‚ñà  ‚ñê‚ñà \n ‚ñê ‚ñà  ‚ñà ‚ñà    ‚ñà   ‚ñà    ‚ñê \n   ‚ñà   ‚ñà‚ñà   ‚ñà   ‚ñÄ   \n           ‚ñÄ          */\n/// ü¶äüåæ Special thanks to Keno / Boring / Gonpachi / Karbon for review and continued inspiration.\npragma solidity 0.8.6;\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\n// License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\ninterface IBentoHelper {\n    function balanceOf(IERC20, address) external view returns (uint256);\n    \n    function toAmount(\n        IERC20 token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    function toShare(\n        IERC20 token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n}\n\ninterface ICompoundHelper {\n    function getCash() external view returns (uint256);\n    function totalBorrows() external view returns (uint256);\n    function totalReserves() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function exchangeRateStored() external view returns (uint256);\n}\n\ninterface IKashiHelper {\n    function asset() external view returns (IERC20);\n    function totalAsset() external view returns (Rebase memory);\n    function totalBorrow() external view returns (Rebase memory);\n    struct Rebase {\n        uint128 elastic;\n        uint128 base;\n    }\n}\n\ncontract InariHelper {\n    IBentoHelper constant bento = IBentoHelper(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966); // BENTO vault contract\n    \n    // **** BENTO \n    function toBento(IERC20 token, uint256 amount) external view returns (uint256 share) {\n        share = bento.toShare(token, amount, false);\n    }\n    \n    function fromBento(IERC20 token, uint256 share) external view returns (uint256 amount) {\n        amount = bento.toAmount(token, share, false);\n    }\n    \n    // **** COMPOUND/CREAM\n    function toCompound(ICompoundHelper cToken, uint256 underlyingAmount) external view returns (uint256 result) { \n        uint256 exchangeRate = cToken.getCash() + cToken.totalBorrows() - cToken.totalReserves() / cToken.totalSupply();\n        result = underlyingAmount * exchangeRate;\n    }\n    \n    function fromCompound(ICompoundHelper cToken, uint256 cTokenAmount) external view returns (uint256 result) {\n        uint256 exchangeRate = cToken.getCash() + cToken.totalBorrows() - cToken.totalReserves() / cToken.totalSupply();\n        result = cTokenAmount / exchangeRate;\n    }\n    \n    // **** KASHI ASSET\n    function toKashi(IKashiHelper kashiPair, uint256 amount) external view returns (uint256 fraction) {\n        IERC20 token = kashiPair.asset();\n        uint256 share = bento.toShare(token, amount, false);\n        uint256 allShare = kashiPair.totalAsset().elastic + bento.toShare(token, kashiPair.totalBorrow().elastic, true);\n        fraction = allShare == 0 ? share : share * kashiPair.totalAsset().base / allShare;\n    }\n    \n    function fromKashi(IKashiHelper kashiPair, uint256 amount) external view returns (uint256 share) {\n        uint256 allShare = kashiPair.totalAsset().elastic + bento.toShare(kashiPair.asset(), kashiPair.totalBorrow().elastic, true);\n        share = amount * allShare / kashiPair.totalAsset().base;\n    }\n}"
    }
  }
}