{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/yieldliq.sol":{"content":"pragma solidity >=0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n//import './lib/SafeMath.sol';\r\n\r\ninterface IWETH {\r\n    function withdraw(uint) external;\r\n    function deposit() external payable;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\ninterface v3pool {\r\n    function swap(address recipient,\r\n        bool zeroForOne,\r\n        int256 amountSpecified,\r\n        uint160 sqrtPriceLimitX96,\r\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\r\n\r\n}\r\n\r\n\r\n\r\nstruct Series {\r\n    address fyToken;                                               // Redeemable token for the series.\r\n    bytes6  baseId;                                                 // Asset received on redemption.\r\n    uint32  maturity;                                               // Unix time at which redemption becomes possible.\r\n    // bytes2 free\r\n}\r\n\r\nstruct Vault {\r\n    address owner;\r\n    bytes6  seriesId;                                                // Each vault is related to only one series, which also determines the underlying.\r\n    bytes6  ilkId;                                                   // Asset accepted as collateral\r\n}\r\n\r\nstruct Balances {\r\n    uint128 art;                                                     // Debt amount\r\n    uint128 ink;                                                     // Collateral amount\r\n}\r\n\r\ninterface wsteth{\r\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\r\n}\r\n\r\ninterface curve{\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 mindy) external returns (uint256);\r\n}\r\n\r\n\r\n\r\ninterface yieldprotocol{\r\n\r\n    function vaults(bytes12 vault) external view returns (Vault memory);\r\n    function series(bytes6 seriesId) external view returns (Series memory);\r\n    function balances(bytes12 vault) external view returns (Balances memory);\r\n    function debtToBase(bytes6 seriesId, uint128 art) external returns (uint128 base);\r\n    function payAll(bytes12 vaultId, uint128 min)\r\n        external\r\n        returns (uint256 ink);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract yieldliq {\r\n    // using SafeMath for uint;\r\n\r\n    \r\n    address payable public owner;\r\n\r\n\r\n\r\n    constructor() public {\r\n        owner = payable(msg.sender);\r\n        // approvetoken(address(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84), address(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        address(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84).call(abi.encodeWithSelector(bytes4(keccak256(bytes('approve(address,uint256)'))), address(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n    \r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n\r\n    function approvetoken(address token, address spender, uint256 amount) external onlyowner{\r\n        // IERC20(address(token)).approve(spender,  amount);\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('approve(address,uint256)'))), spender, amount));\r\n    }\r\n\r\n\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata _data\r\n    ) external {\r\n        (uint256 pos, bytes12 vaultId, address[] memory pools, address[] memory tokens, bool[] memory flags) = abi.decode(_data, (uint256, bytes12, address[], address[], bool[]));\r\n\r\n        if(pos == 0){\r\n            // approve token\r\n            uint256 amount;\r\n            if(flags[pos]){\r\n                amount = uint256(-amount1Delta);\r\n            }else{\r\n                amount = uint256(-amount0Delta);\r\n            }\r\n            \r\n            // approve the token\r\n            tokens[0].call(abi.encodeWithSelector(bytes4(keccak256(bytes('approve(address,uint256)'))), pools[pools.length - 1], amount));\r\n\r\n            uint256 collateralReceived = yieldprotocol(address(0x53C3760670f6091E1eC76B4dd27f73ba4CAd5061)).payAll(vaultId, 0);\r\n\r\n            // sell the token\r\n            if(tokens.length > 2){\r\n\r\n                if(tokens[2] == address(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)){\r\n                    // for wsteth, unwrap it to stETH\r\n                    uint256 stethamount = wsteth(address(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)).unwrap(collateralReceived);\r\n\r\n                    // exchange it to weth\r\n                    curve(address(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022)).exchange(1, 0, stethamount, 0);\r\n\r\n                    IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).deposit{value: address(this).balance}();\r\n\r\n                }else{\r\n\r\n                    bytes memory callbackdata = abi.encode(1, address(0), bytes12(0), pools, tokens, flags);  \r\n\r\n                    v3pool(pools[1]).swap(address(this), flags[1], int256(collateralReceived), \r\n                       flags[1] ? 4295128739 + 1 : 1461446703485210103287273052203988822378723970342 - 1, callbackdata);   \r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n\r\n        if(flags[pos]){\r\n            _safeTransfer(tokens[pos+1], msg.sender, uint256(amount0Delta));\r\n        }else{\r\n            _safeTransfer(tokens[pos+1], msg.sender, uint256(amount1Delta));\r\n        }\r\n\r\n    }\r\n\r\n\r\n    // tokens contains the [borrowtoken, repay token0, repay token1 ...]\r\n    function liqtarget(bytes12 vaultId, address[] calldata pools, address[] calldata tokens, bool[] calldata flags, uint256 percent) external payable returns(uint256){\r\n\r\n        uint256 gasstart = gasleft();\r\n\r\n        Vault memory vault = yieldprotocol(address(0xc88191F8cb8e6D4a668B047c1C8503432c3Ca867)).vaults(vaultId);\r\n        Balances memory balances = yieldprotocol(address(0xc88191F8cb8e6D4a668B047c1C8503432c3Ca867)).balances(vaultId);\r\n        Series memory series = yieldprotocol(address(0xc88191F8cb8e6D4a668B047c1C8503432c3Ca867)).series(vault.seriesId);\r\n\r\n        uint256 baseLoan = yieldprotocol(address(0xc88191F8cb8e6D4a668B047c1C8503432c3Ca867)).debtToBase(vault.seriesId, balances.art);\r\n\r\n\r\n        bytes memory callbackdata = abi.encode(0, vaultId, pools, tokens, flags);  \r\n\r\n        v3pool(pools[0]).swap(address(this), flags[0], int256(-baseLoan), \r\n                   flags[0] ? 4295128739 + 1 : 1461446703485210103287273052203988822378723970342 - 1, callbackdata);   \r\n\r\n\r\n        // reuse baseloan\r\n        baseLoan = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n\r\n        IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(baseLoan);\r\n\r\n        block.coinbase.call{value: baseLoan * percent / 100}(new bytes(0));\r\n\r\n        baseLoan = address(this).balance;\r\n\r\n        require(baseLoan > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n        payable(msg.sender).transfer(baseLoan);\r\n        return(baseLoan);\r\n\r\n    }\r\n\r\n\r\n}"}}}