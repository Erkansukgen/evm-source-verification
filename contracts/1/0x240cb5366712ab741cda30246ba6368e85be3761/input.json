{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/CompoundFastGetter.sol": {
      "content": "\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\n\n//acc \t0x5d3a536e4d6dbd6114cc1ead35777bab948e3643\n//cdai 0x5d3a536e4d6dbd6114cc1ead35777bab948e3643\n\n//[\"0xf54b98439b4bc686403f448a2272ba4e3dbcc5c5\"]\n//[[\"0x5d3a536e4d6dbd6114cc1ead35777bab948e3643\",\"DAI\"]]\n\n//[\"0x7a2554c1cdcbb261ab529ae75e2ca9465240b894\",\"0x7a2554c1cdcbb261ab529ae75e2ca9465240b894\"]\n//[[\"0x6c8c6b02e7b2be14d4fa6022dfd6d75921d90e4e\",\"BAT\"],[\"0x5d3a536e4d6dbd6114cc1ead35777bab948e3643\",\"DAI\"]]\n//[[\"0x6c8c6b02e7b2be14d4fa6022dfd6d75921d90e4e\",\"BAT\"],[\"0x5d3a536e4d6dbd6114cc1ead35777bab948e3643\",\"DAI\"],[\"0x4ddc2d193948926d02f9b1fe9e1daa0718270ed5\",\"ETH\"]]\n\ncontract CompoundFastGetter\n{\n    ComptorllerInterface Comptroller;\n    address CoinbaseReporterKey;\n   \n\n    constructor() {\n        \n        Comptroller=ComptorllerInterface(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n        CoinbaseReporterKey= 0xfCEAdAFab14d46e20144F48824d0C09B1a03F2BC;\n    }\n    \n    function GetAccountsSnapshot(address[] calldata accountAddresses, CTokenData[] memory cTokenAddresses) external view returns (CTokenState[] memory,CTokenAccount[] memory ) {\n\n        \n        UniswapAnchoredView priceOracle= UniswapAnchoredView(Comptroller.oracle());\n        PriceDataStorage priceStorage=PriceDataStorage( priceOracle.priceData());\n       \n        CTokenState[] memory cTokenStates=new CTokenState[](cTokenAddresses.length);\n        CTokenAccount[] memory accounts= new  CTokenAccount[](accountAddresses.length*cTokenAddresses.length);\n \n        for (uint j=0; j<cTokenAddresses.length; j++) {\n            \n             CTokenData memory currentCToken=cTokenAddresses[j];\n             CToken cToken = CToken(currentCToken.Address);\n             \n             for (uint i=0; i<accountAddresses.length; i++) {\n                 address currentAccount=accountAddresses[i];\n                 uint index=i+j*accountAddresses.length;\n                 Snapshot memory v  =cToken.getAccountSnapshot(currentAccount);\n                 CTokenAccount memory account;\n                 account.cTokenIndex=j;\n                 account.accountIndex=i;\n                 account.snapshot =v;\n                 account.collateral=Comptroller.checkMembership(currentAccount,currentCToken.Address);\n                \n                 accounts[index]=account;\n     \n                 \n             }\n             CTokenState memory c;\n             c.cTokenIndex=j;\n             c.accrualBlockNumber=cToken.accrualBlockNumber();\n             c.borrowRatePerBlock=cToken.borrowRatePerBlock();\n             c.supplyRatePerBlock=cToken.supplyRatePerBlock();\n    \n    \n             c.price=priceOracle.getUnderlyingPrice(currentCToken.Address);\n             c.storagePrice=priceStorage.get(CoinbaseReporterKey,currentCToken.UndelyingSymbol);\n             cTokenStates[j]=c;\n        }\n        \n        return (cTokenStates,accounts);\n    }  \n    \n}\n\nstruct PriceStorageItem{\n    uint64 timestamp;\n    uint64 value;\n}\n\nabstract contract PriceDataStorage{\n      function get(address source, string calldata key) virtual  external view returns (PriceStorageItem memory) ;\n\n}\n\nabstract contract UniswapAnchoredView{\n     address public priceData;\n     function getUnderlyingPrice(address cToken) virtual external view returns (uint) ;\n}\n\nabstract contract ComptorllerInterface\n{\n     address public oracle;\n     function checkMembership(address account, address cToken) virtual external view returns (bool) ;\n}\n\ninterface  ERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract CToken\n{\n    uint public accrualBlockNumber;\n    function  getAccountSnapshot(address account) virtual external view returns (Snapshot memory) ;\n    function borrowRatePerBlock() virtual external view returns (uint);\n    function supplyRatePerBlock() virtual external view returns (uint);\n}\n\n struct CTokenAccount { \n   uint cTokenIndex;    \n   uint accountIndex;\n   Snapshot snapshot;\n   bool collateral;\n}\n\n struct Snapshot { \n   uint ErrorCode;\n   uint Supply;\n   uint Borrow;\n   uint Price;\n}\n struct CTokenState\n { \n     uint cTokenIndex;    \n     uint accrualBlockNumber;\n     uint borrowRatePerBlock;\n     uint supplyRatePerBlock;\n     uint price;\n     PriceStorageItem storagePrice;\n\n     \n }\n \n struct CTokenData { \n   address Address;\n   string UndelyingSymbol;\n   \n}\n"
    }
  }
}