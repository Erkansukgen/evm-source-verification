{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/safeMath.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\r\n\r\nlibrary SafeMath {\r\n    //加\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    //减\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    //乘\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    //除\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    //取余\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"browser/token.sol":{"content":"pragma solidity >=0.6.0 <0.7.0;\nimport \"./safeMath.sol\";\n\n\ncontract owned {\n    address payable public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n}\n\n\ninterface tokenRecipient {\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes calldata _extraData\n    ) external;\n}\n\n\ncontract TokenERC20 {\n    using SafeMath for uint256;\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    event Burn(address indexed from, uint256 value);\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply.mul(10**uint256(decimals));\n        balanceOf[address(this)] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        require(_to != address(0x0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value)\n        public\n        returns (bool success)\n    {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value)\n        public\n        returns (bool success)\n    {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function approveAndCall(\n        address _spender,\n        uint256 _value,\n        bytes memory _extraData\n    ) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(\n                msg.sender,\n                _value,\n                address(this),\n                _extraData\n            );\n            return true;\n        }\n        return true;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value)\n        public\n        returns (bool success)\n    {\n        require(balanceOf[_from] >= _value);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        allowance[_from][msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Burn(_from, _value);\n        return true;\n    }\n}\n\n\ncontract MyToken is owned, TokenERC20 {\n    uint256 public sellBalance;\n    uint256 public burnBalance;\n    Db db;\n    Core core;\n    address coreAddress;\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public TokenERC20(initialSupply, tokenName, tokenSymbol) {}\n\n    function price() public view returns (uint256) {\n        if (sellBalance < 8e25) {\n            uint256 _init = 150e10;\n            uint256 _initPrice = uint256(1).mul(1e18).div(_init);\n            uint256 _singlePrice = uint256(1).mul(1e18).div(_init).div(100);\n            uint256 _ratio = sellBalance.div(1e23);\n            uint256 _newPrice = _initPrice.add(_singlePrice.mul(_ratio));\n            uint256 _price = uint256(1).mul(1e18).div(_newPrice);\n            return _price.div(1e10);\n        } else if (sellBalance < 16e25) {\n            uint256 _init = 166e9;\n            uint256 _initPrice = uint256(1).mul(1e18).div(_init);\n            uint256 _singlePrice = uint256(1).mul(1e18).div(_init).div(100);\n            uint256 _ratio = (sellBalance.sub(8e25)).div(2e23);\n            uint256 _newPrice = _initPrice.add(_singlePrice.mul(_ratio));\n            uint256 _price = uint256(1).mul(1e18).div(_newPrice);\n            return _price.div(1e10);\n        } else if (sellBalance < 229e24) {\n            uint256 _init = 33e9;\n            uint256 _initPrice = uint256(1).mul(1e18).div(_init);\n            uint256 _singlePrice = uint256(1).mul(1e18).div(_init).div(100);\n            uint256 _ratio = (sellBalance.sub(16e25)).div(3e23);\n            uint256 _newPrice = _initPrice.add(_singlePrice.mul(_ratio));\n            uint256 _price = uint256(1).mul(1e18).div(_newPrice);\n            return _price.div(1e10);\n        } else {\n            return 1;\n        }\n    }\n\n    function init(address _dbAddress, address _coreAddress) public onlyOwner {\n        db = Db(_dbAddress);\n        core = Core(_coreAddress);\n        coreAddress = _coreAddress;\n    }\n\n    modifier isCore {\n        require(msg.sender == coreAddress);\n        _;\n    }\n\n    function sendTokenToAddress(address _own, uint256 _balance) public isCore {\n        _balance = _balance.mul(1e18);\n        require(_balance.add(sellBalance) < 229000000e18);\n        sellBalance = sellBalance.add(_balance);\n        _transfer(address(this), _own, _balance);\n    }\n\n    function sendTokenToV4(address _own, uint256 _balance) public onlyOwner {\n        _transfer(address(this), _own, _balance);\n    }\n\n    function getToken(address _own) public view returns (uint256) {\n        return balanceOf[_own];\n    }\n\n    function sendTokenToGame(address _to, uint256 _value)\n        public\n        isCore\n        returns (bool)\n    {\n        address txAddress = tx.origin;\n        require(balanceOf[txAddress] >= _value);\n        burnBalance = burnBalance.add(_value);\n        _transfer(txAddress, _to, _value);\n        return true;\n    }\n\n    function getTokenPrice() public view returns (uint256) {\n        return price();\n    }\n}\n\n\nabstract contract Db {\n    function getPlayerInfo(address _own)\n        public\n        virtual\n        view\n        returns (\n            address _parent,\n            bool _isExist,\n            bool _isParent\n        );\n}\n\n\nabstract contract Core {\n    function bindParent(address _parent) public virtual;\n}\n"}}}