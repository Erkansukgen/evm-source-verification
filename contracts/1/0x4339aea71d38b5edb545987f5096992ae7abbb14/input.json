{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NewOracleProxy.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 12-15-2020\r\n*/\r\n\r\n/*\r\n    Copyright 2020 Charge Factory.\r\n    SPDX-License-Identifier: Apache-2.0\r\n*/\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n// helper/SafeMath.sol\r\n/**\r\n * @title SafeMath\r\n * @author Charge Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n// helper/AggregatorV3Interface.sol\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IUniswapV2Pair.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// lib/Ownable.sol\r\n/**\r\n * @title Ownable\r\n * @author Charge Breeder\r\n *\r\n * @notice Ownership related functions\r\n */\r\ncontract Ownable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    constructor() internal {\r\n        _OWNER_ = msg.sender;\r\n        emit OwnershipTransferred(address(0), _OWNER_);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"INVALID_OWNER\");\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() external {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n\r\n// NewOracleProxy.sol\r\ncontract NewOracleProxy is Ownable {\r\n        using SafeMath for uint256;\r\n\r\n    string public oracleName;\r\n    uint8  public oracleDecimal;\r\n\r\n    address public chainlink;\r\n    address public uniswapPair;\r\n    uint256 public chainlinkThreshold;\r\n    bool    public uniswapPairReverse;\r\n\r\n    uint256 public T0 = 900;\r\n    uint256 public RATIO = 2;\r\n\r\n    uint256 public uniswapPriceCumulativeLast;\r\n    uint256 public uniswapPriceLast;\r\n    uint32  public uniswapBlockTimestampLast;\r\n\r\n    event DevivationTooBig (uint256 _chainlinPrice, uint256 _dexPrice);\r\n\r\n    constructor(address _chainlink,\r\n                address _uniswapPair,\r\n                string memory _name, \r\n                uint256 _chainlinkThreshold,\r\n                bool _uniswapPairReverse) public {\r\n        chainlink = _chainlink;\r\n        uniswapPair = _uniswapPair;\r\n        oracleName = _name;\r\n        oracleDecimal =  18;\r\n        chainlinkThreshold = _chainlinkThreshold;\r\n        uniswapPairReverse = _uniswapPairReverse;\r\n\r\n        (uniswapPriceCumulativeLast, uniswapPriceLast, uniswapBlockTimestampLast)\r\n                = _getUniswapPrice(uniswapPair, uniswapPairReverse);\r\n    }\r\n\r\n    // administration\r\n    function setT0(uint256 t0) external onlyOwner {\r\n        T0 = t0;\r\n    }\r\n\r\n    function setRATIO(uint256 ratio) external onlyOwner {\r\n        RATIO = ratio;\r\n    }\r\n\r\n    // oracle\r\n    function getChainlinkPrice() external view returns (uint256, uint256) {\r\n        (, int256 answer, , uint256 updateTimestamp, ) \r\n            = AggregatorV3Interface(chainlink).latestRoundData();\r\n        uint8 chainlinkDecimal = AggregatorV3Interface(chainlink).decimals(); \r\n        uint256 price = uint256(answer);\r\n\r\n        if (chainlinkDecimal > oracleDecimal) {\r\n            price = price.div(10 ** uint256(chainlinkDecimal - oracleDecimal));\r\n        } else if (chainlinkDecimal < oracleDecimal) {\r\n            price = price.mul(10 ** uint256(oracleDecimal - chainlinkDecimal));\r\n        } \r\n\r\n        return (price, updateTimestamp);\r\n    }\r\n\r\n    // return price with decimal 18\r\n    function getUniswapPrice(address pair, bool reverse) external view\r\n        returns (uint256, uint32) {\r\n        (uint256 priceCumulative,  , uint32 blockTimestamp) = _getUniswapPrice(pair, reverse);\r\n        return (priceCumulative, blockTimestamp);\r\n    }\r\n\r\n    // return price with decimal 18\r\n    function _getUniswapPrice(address pair, bool reverse) internal view\r\n        returns (uint256, uint256, uint32) {\r\n        // unit = (2 ** 112) / (1e18)\r\n        uint256 unit = 5192296858534827;\r\n\r\n        uint256 price0 = IUniswapV2Pair(pair).price0CumulativeLast();\r\n        uint256 price1 = IUniswapV2Pair(pair).price1CumulativeLast();\r\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves(); \r\n\r\n        // decimal 18\r\n        uint256 priceLast = 10 ** 18;\r\n\r\n        // check pair token are in the same order?\r\n        if (reverse == false) {\r\n            priceLast = priceLast.mul(reserve1).div(reserve0);\r\n            return (price0.div(unit).div(10**12), priceLast.div(10**12), uint32(blockTimestampLast % 2 ** 32));\r\n        } else {\r\n            priceLast = priceLast.mul(reserve0).div(reserve1);\r\n            return (price1.div(unit).mul(10**12), priceLast.mul(10**12), uint32(blockTimestampLast % 2 ** 32));\r\n        }\r\n    }\r\n\r\n    function getPrice() external returns (uint256, uint8) {\r\n\r\n        uint256 uniswapPriceCumulative;\r\n        uint256 uniswapPrice;\r\n        uint32  uniswapBlockTimestamp;\r\n\r\n        uint256 targetPrice;\r\n        uint256 chainlinkPrice;\r\n        uint256 chainlinkTimestamp;\r\n        uint256 dexPrice;\r\n\r\n        uint256 deltaT;\r\n        uint256 deviation;\r\n        uint8   deviationLevel;\r\n\r\n        (chainlinkPrice, chainlinkTimestamp) = this.getChainlinkPrice();\r\n\r\n        (uniswapPriceCumulative, ,uniswapBlockTimestamp) \r\n                        = _getUniswapPrice(uniswapPair, uniswapPairReverse);\r\n\r\n        if (uniswapBlockTimestamp != uniswapBlockTimestampLast) {\r\n            uniswapPrice = uniswapPriceCumulative.sub(uniswapPriceCumulativeLast).\r\n                div(uniswapBlockTimestamp-uniswapBlockTimestampLast);\r\n        } else {\r\n            uniswapPrice = uniswapPriceLast;\r\n        }\r\n        dexPrice = uniswapPrice;\r\n\r\n        // dexPrice is newer than oraclePrice\r\n        if (uint256(uniswapBlockTimestampLast) >= chainlinkTimestamp) {\r\n            // detaT = (uniswapBlockTimestamp + uniswapBlockTimestampLast)/2 - oracleTimestamp\r\n            deltaT = uint256((uniswapBlockTimestamp + uniswapBlockTimestampLast)/2).sub(chainlinkTimestamp);\r\n        } else {\r\n            deltaT = 0;\r\n            dexPrice = chainlinkPrice;\r\n        }\r\n\r\n        // last step\r\n        deviationLevel = 0;\r\n        if (dexPrice > chainlinkPrice) {\r\n            deviation = dexPrice.sub(chainlinkPrice).mul(10 ** 18).div(chainlinkPrice);\r\n            if (deviation > chainlinkThreshold.mul(RATIO)) {\r\n                targetPrice = chainlinkPrice;\r\n                // set to biggest\r\n                //deviationLevel = uint8(deviation.div(chainlinkThreshold));\r\n                deviationLevel = 255;\r\n                emit DevivationTooBig(chainlinkPrice, dexPrice);\r\n            } else {\r\n                // targetPrice = (chainlinkPrice * T0 + dexPrice * deltaT) / (T0 + deltaT)\r\n                targetPrice = chainlinkPrice.mul(T0).add(dexPrice.mul(deltaT)).div(deltaT.add(T0)); \r\n            }\r\n        } else if (dexPrice < chainlinkPrice) {\r\n            deviation = chainlinkPrice.sub(dexPrice).mul(10 ** 18).div(dexPrice);\r\n            if (deviation > chainlinkThreshold.mul(RATIO)) {\r\n                targetPrice = chainlinkPrice;\r\n                // set to biggest\r\n                //deviationLevel = uint8(deviation/chainlinkThreshold);\r\n                deviationLevel = 255;\r\n                emit DevivationTooBig(chainlinkPrice, dexPrice);\r\n            } else {\r\n                // targetPrice = (chainlinkPrice * T0 + dexPrice * deltaT) / (T0 + deltaT)\r\n                targetPrice = chainlinkPrice.mul(T0).add(dexPrice.mul(deltaT)).div(deltaT.add(T0)); \r\n            }\r\n        } else {\r\n            // dexPrice == chainlinkPrice\r\n            targetPrice = chainlinkPrice;\r\n        }\r\n\r\n        if (uniswapBlockTimestamp != uniswapBlockTimestampLast) {\r\n            uniswapPriceCumulativeLast = uniswapPriceCumulative;\r\n            uniswapPriceLast = uniswapPrice;\r\n            uniswapBlockTimestampLast = uniswapBlockTimestamp;\r\n        }\r\n\r\n        return (targetPrice, deviationLevel);\r\n    }\r\n}"}}}