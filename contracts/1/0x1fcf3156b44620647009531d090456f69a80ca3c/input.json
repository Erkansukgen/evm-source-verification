{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/HoobiSocial.sol": {
      "content": "pragma solidity >=0.4.0 <0.7.0;\ninterface IMember {\n    function addMember(address _member, address _parent) external;\n    function getParent(address _member) external view returns (address _parent);\n    function isMember(address _member) external view returns (bool);\n    function getParentTree(address _member) external view returns (address[8] memory);\n    function getRefs(address _member) external view returns (address[] memory);\n    function getRef(address _member, uint256 _index) external view returns (address);\n    function getRefsLength(address _member) external view returns (uint256);\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\ninterface OldContract {\n    function getUser(address _address) external view returns (uint256 level, uint256[8] memory refTree);\n    function getCurrentBonus() external view returns (uint256 step, uint256 max, uint256 sold, uint256 bonus);\n}\ncontract Hoobi {\n    address private owner;\n    address private fund = 0x50465607e6b098320153C0D08534bFB677a75241;\n    OldContract old = OldContract(0x38F65eB8a70B41272Ed9eBE326E7feF0b7f86CaA);\n    IERC20 share;\n    IMember member;\n    uint256 shareDecimal = 6;\n    uint256 priceETH = 200 * 10**6;\n    uint256 lastPriceETH = 200 * 10 ** 6;\n    uint256 priceShare = 10**5;\n    uint256[7] refPercent = [5, 4, 2, 1, 1, 1, 1]; //div 100\n    uint256[3] firstPercent = [60, 80, 100];\n    uint256[3] secondPercent = [50, 60, 70];\n    uint256[9] bonusShare = [520, 380, 260, 140, 80, 50, 30, 20, 16]; //div\n    uint256[9] poolShare = [\n        10**11,\n        3 * 10**11,\n        10**12,\n        3 * 10**12,\n        8 * 10**12,\n        20 * 10**12,\n        50 * 10**12,\n        100 * 10**12,\n        300 * 10**12\n    ];\n    uint256[9] soldShare = [10**11, 0, 0, 0, 0, 0, 0, 0, 0];\n    uint256[3] level = [100 * 10**6, 200 * 10**6, 400 * 10**6];\n    uint256 currentPool = 0;\n    address bot = 0x2637F27ed1A8dC88a950b785329cc5606F7CaEa7;\n    struct User {\n        uint256 level;\n        uint256[8] refTree;\n    }\n    mapping(address => User) users;\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Must be owner\");\n        _;\n    }\n    modifier onlyMod() {\n        require(msg.sender == owner || msg.sender == bot, \"Must be bot\");\n        _;\n    }\n    constructor(\n        address _shareContract,\n        address _memberContract\n    ) public {\n        owner = msg.sender;\n        share = IERC20(_shareContract);\n        member = IMember(_memberContract);\n    }\n    function init() public onlyOwner {\n        (currentPool,,soldShare[currentPool],) = old.getCurrentBonus();\n        address[3] memory fixAddress = [address(0x7D06cA295dfEA66914F859047bc056f2Ba64138a),address(0x0B270EDC63F434AFe8D78734554372F2DDe8d0cd),address(0xBe065223577e17e6C04bE68ba13f1EDdCECb8d5E)];\n        for(uint8 i=0;i<3;i++){\n            address[8] memory parentTree = member.getParentTree(fixAddress[i]);\n            for(uint8 j=0;j<8;j++){\n                if(parentTree[j] != address(0x0)){\n                    users[parentTree[j]].refTree[j] += 1;\n                }\n            }\n        }\n    }\n    function recover(address[] memory oldUsers) public onlyOwner {\n        for(uint i=0;i<oldUsers.length;i++){\n            (users[oldUsers[i]].level,users[oldUsers[i]].refTree) = old.getUser(oldUsers[i]);\n            if(users[oldUsers[i]].level > 3){\n                users[oldUsers[i]].level = 3;\n            }\n        }\n    }\n    function getAmountETH(uint256 _amount) public view returns (uint256) {\n        return ((_amount * 10**24) / priceETH);\n    }\n    function getAmountETHLevel(uint _level) public view returns(uint){\n        if(_level == 0) return 0;\n        if(_level == 1) return getAmountETH(100);\n        if(_level == 2) return getAmountETH(200);\n        if(_level == 3) return getAmountETH(400);\n        return 0;\n    }\n    function getLevel(uint _amount) public view returns(uint8 _level,uint256 _value){\n        if (_amount == ((100 * 10**24) / priceETH)) {\n            return(1,100 * 10 ** 6);\n        } else if (_amount == ((200 * 10**24) / priceETH)){\n             return(2,200 * 10 ** 6);\n        } else if (_amount == ((400 * 10**24) / priceETH)) {\n            return(3,400 * 10 ** 6);\n        } else if (_amount == ((100 * 10**24) / lastPriceETH)) {\n            return(1,100 * 10 ** 6);\n        } else if (_amount == ((200 * 10**24) / lastPriceETH)) {\n            return(2,200 * 10 ** 6);\n        } else if (_amount == ((400 * 10**24) / lastPriceETH)) {\n            return(3,400 * 10 ** 6);\n        } else {\n            return(0,0);\n        }\n    }\n    function invest(address _ref) public payable {\n        require(member.isMember(msg.sender) || member.isMember(_ref),\"Must be valid\");\n        (uint8 userLevel,uint256 value) = getLevel(msg.value);\n        require(userLevel > users[msg.sender].level, \"User only can upgrade membership!\");\n        sendFunds(fund, (msg.value * 15) / 1000, 0);\n        users[msg.sender].level = userLevel;\n        if (member.isMember(msg.sender)) {\n            reInvest(msg.sender, msg.value);\n        } else {\n            member.addMember(msg.sender, _ref);\n            addNewInvestor(_ref, msg.value, userLevel);\n        }\n        if (currentPool < 9) {\n            uint256 amountShare = (value * (10**shareDecimal)) / priceShare;\n            uint256 bonus;\n            if (poolShare[currentPool] - soldShare[currentPool] >= value) {\n                bonus = (amountShare * bonusShare[currentPool]) / 10;\n                soldShare[currentPool] += value;\n                if (soldShare[currentPool] == poolShare[currentPool])\n                    currentPool++;\n            } else {\n                uint256 payed = poolShare[currentPool] - soldShare[currentPool];\n                bonus =\n                    (((payed * (10**shareDecimal)) / priceShare) *\n                        bonusShare[currentPool]) /\n                    10;\n                soldShare[currentPool] = poolShare[currentPool];\n                currentPool++;\n                if (currentPool < 9) {\n                    bonus +=\n                        ((((value - payed) * (10**shareDecimal)) / priceShare) *\n                            bonusShare[currentPool]) /\n                        10;\n                    soldShare[currentPool] += value - payed;\n                }\n            }\n            sendFunds(msg.sender, amountShare + bonus, 1);\n        } else {\n            uint256 amountShare = (value * (10**shareDecimal)) / priceShare;\n            sendFunds(msg.sender, amountShare, 1);\n        }\n    }\n    function reInvest(address _investor, uint256 _value)\n        private\n    {\n        address[8] memory parentTree = member.getParentTree(_investor);\n        if (parentTree[0] != address(0x0)) {\n            sendFunds(parentTree[0],(_value * secondPercent[users[parentTree[0]].level - 1]) / 100,0);\n            for (uint256 i = 1; i < 8; i++) {\n                if (parentTree[i] == address(0x0)) {\n                    break;\n                } else {\n                    sendFunds(\n                        parentTree[i],\n                        (_value * refPercent[i - 1]) / 100,\n                        0\n                    );\n                }\n            }\n        }\n    }\n    function addNewInvestor(address _ref, uint256 _value, uint256 _level)\n        private\n    {\n        if(_ref != address(0x0)){\n            User storage user = users[_ref];\n            user.refTree[0] += 1;\n            if (user.refTree[0] == 2) {\n                if (user.level < _level) {\n                    if(getAmountETHLevel(user.level) > 0 && user.level > 0){\n                         sendFunds(_ref,(getAmountETHLevel(user.level) * firstPercent[user.level - 1]) /100,0);\n                    }\n                } else {\n                    sendFunds(_ref,(_value * firstPercent[user.level - 1]) / 100,0);\n                    \n                }\n            }\n            if (user.refTree[0] > 2) { sendFunds( _ref,(_value * secondPercent[user.level - 1]) / 100,0); }\n            address[8] memory parentTree = member.getParentTree(_ref);\n            for(uint i = 0;i < 7;i++){\n                if(parentTree[i] != address(0x0)){\n                    uint256[8] storage userRef = users[parentTree[i]].refTree;\n                    userRef[i+1] += 1;\n                    if (userRef[i+1] == 2) {\n                        sendFunds(parentTree[i], (_value * refPercent[i]) / 100, 0);\n                    } else {\n                        if (userRef[i+1] > 2) {\n                            sendFunds(parentTree[i],(_value * refPercent[i]) / 200,0);\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    function getUserStats(address _investor) public view returns(address[] memory refs){\n        address[] memory tempRefs = member.getRefs(_investor);\n        return (tempRefs);\n    }\n    function getUser(address _address)\n        public\n        view\n        returns (uint256 userLevel, uint256[8] memory refTree)\n    {\n        User memory user = users[_address];\n        return (user.level, user.refTree);\n    }\n    function getUserRefsStats(address _investor)\n        public\n        view\n        returns (address[] memory refs)\n    {\n        address[] memory _refs = member.getRefs(_investor);\n        return (_refs);\n    }\n    function getPrice()\n        public\n        view\n        returns (uint256 ethPrice, uint256 sharePrice)\n    {\n        return (priceETH, priceShare);\n    }\n    function getCurrentBonus()\n        public\n        view\n        returns (uint256 step, uint256 max, uint256 sold, uint256 bonus)\n    {\n        return (\n            currentPool,\n            poolShare[currentPool],\n            soldShare[currentPool],\n            bonusShare[currentPool]\n        );\n    }\n    function validRef(address _investor, address _ref)\n        public\n        view\n        returns (bool)\n    {\n        if (member.isMember(_investor)) {\n            return true;\n        } else {\n            if (member.isMember(_ref)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n    function changeMemberContract(address _contract) public onlyOwner {\n        member = IMember(_contract);\n    }\n    function changeShareContract(address _contract) public onlyOwner {\n        share = IERC20(_contract);\n    }\n    function changeETHPrice(uint256 _price) public onlyMod {\n        lastPriceETH = priceETH;\n        priceETH = _price;\n    }\n    function changeBot(address _bot) public onlyOwner {\n        bot = _bot;\n    }\n    function changeSharePrice(uint256 _price) public onlyMod {\n        priceShare = _price;\n    }\n    function adminWidthdraw(\n        address _address,\n        uint256 _amount,\n        uint256 _currency\n    ) public onlyOwner {\n        sendFunds(_address, _amount, _currency);\n    }\n    function editDataUser(address _address,uint _level,uint[8] memory _refTree) public onlyOwner {\n        users[_address].level = _level;\n        users[_address].refTree = _refTree;\n    }\n    function sendFunds(address beneficiary, uint256 amount, uint256 currency)\n        private\n    {\n        if (currency == 0) {\n            require(address(this).balance >= amount,\"Balance in contract is not enough to cash out, please contact for admin\");\n            address(uint160(beneficiary)).transfer(amount);\n        } else {\n            require(share.balanceOf(address(this)) >= amount,\"Balance in contract is not enough to cash out, please contact for admin\");\n            share.transfer(beneficiary, amount);\n        }\n    }\n}"
    }
  }
}