{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/bull.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n}\n\n\ncontract BullStaking is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _stakes;\n\n    address public owner = msg.sender;\n    address  public tokenAddress;\n    uint public stakingStarts;\n    uint public stakingEnds;\n    uint public withdrawStarts;\n    uint public withdrawEnds;\n    uint256 public stakedTotal;\n    uint256 public stakingCap;\n    uint256 public totalReward;\n    uint256 public earlyWithdrawReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n\n    address payable ethFund = 0xB205238e2eCb8462d5D826E28DCd2aCe0BF811a4;\n\n    ERC20 public ERC20Interface;\n    event Staked(address indexed token, address indexed staker_, uint256 requestedAmount_, uint256 stakedAmount_);\n    event PaidOut(address indexed token, address indexed staker_, uint256 amount_, uint256 reward_);\n    event Refunded(address indexed token, address indexed staker_, uint256 amount_);\n\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    uint256 public price;\n    uint256 public sold = 0;\n\n    bool public distributionFinished = false;\n\n    bool public distribution_ongoing = false;\n\n    uint256 public tokensPerEth = 60000e18;\n\n    constructor (string memory name, string memory symbol, address payable _ethFund, uint256 _tokensPerEth) public {\n        tokensPerEth = _tokensPerEth*1e18;\n        price = SafeMath.div(1e18, SafeMath.div(tokensPerEth, 1e18));\n        _name = name;\n        _symbol = symbol;\n        ethFund = _ethFund;\n        _decimals = 18;\n        _totalSupply = 100000000e18;\n        owner = msg.sender;\n        _balances[owner] = _balances[owner].add(_totalSupply);\n    }\n\n    modifier saleHappening {\n      require(distribution_ongoing == true, \"distribution started\");\n      require(sold <= _totalSupply, \"tokens sold out\");\n      _;\n    }\n\n    function tokenSaleStarted() public view returns (bool) {\n        return distribution_ongoing;\n    }\n\n    function startSale() public\n    onlyOwner {\n      distribution_ongoing = true;\n    }\n\n    function endSale() public\n    onlyOwner {\n      distribution_ongoing = false;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n    function finishDistribution() onlyOwner canDistr public returns (bool) {\n        distributionFinished = true;\n\n        return true;\n    }\n\n    function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n\n        _balances[owner] = _balances[owner].sub(_amount);\n        _balances[_to] = _balances[_to].add(_amount);\n\n        return true;\n    }\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier canDistr() {\n        require(!distributionFinished);\n        _;\n    }\n\n\n    receive ()\n      external\n      payable\n      saleHappening\n    {\n      \n      uint excessAmount = msg.value % price;\n\n      uint purchaseAmount = SafeMath.sub(msg.value, excessAmount);\n\n      uint tokenPurchase = SafeMath.div(SafeMath.mul(purchaseAmount,1e18), price);\n\n      uint total_token = tokenPurchase;\n\n      sold= SafeMath.add(sold, total_token);\n\n      assert(sold <= _totalSupply);\n\n      ethFund.transfer(msg.value);\n      assert(distr(msg.sender, total_token));\n\n    }\n\n\n    function init_staking(\n        address tokenAddress_,\n        uint stakingEnds_,\n        uint withdrawStarts_,\n        uint256 stakingCap_\n    )\n\n    public onlyOwner {\n\n        require(tokenAddress_ != address(0), \"BullStaking: 0 address\");\n        tokenAddress = tokenAddress_;\n\n        stakingStarts = now;\n\n        require(stakingEnds_ > 0, \"BullStaking: staking end must be positive\");\n        stakingEnds = now + stakingEnds_;\n\n        require(withdrawStarts_ >= stakingEnds_, \"Bulltaking: withdrawStarts must be after staking ends\");\n        withdrawStarts = withdrawStarts_;\n\n        withdrawEnds = withdrawStarts + 180 days; // 6 months to withdraw reward\n\n        require(stakingCap_ > 0, \"BullStaking: stakingCap must be positive\");\n        stakingCap = stakingCap_;\n    }\n\n    function addReward(uint256 rewardAmount, uint256 withdrawableAmount)\n    public\n\n    returns (bool) {\n        require(rewardAmount > 0, \"BullStaking: reward must be positive\");\n        require(withdrawableAmount >= 0, \"BullStaking: withdrawable amount cannot be negative\");\n        require(withdrawableAmount <= rewardAmount, \"BullStaking: withdrawable amount must be less than or equal to the reward amount\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = totalReward;\n        earlyWithdrawReward = earlyWithdrawReward.add(withdrawableAmount);\n        return true;\n    }\n\n    function stakeOf(address account) public view returns (uint256) {\n        return _stakes[account];\n    }\n\n    function stake(uint256 amount)\n    public\n    _positive(amount)\n    _realAddress(msg.sender)\n    returns (bool) {\n        address from = msg.sender;\n        return _stake(from, amount);\n    }\n\n    function withdraw(uint256 amount)\n    public\n    _after(withdrawStarts)\n    _positive(amount)\n    _realAddress(msg.sender)\n    returns (bool) {\n        address from = msg.sender;\n        require(amount <= _stakes[from], \"BullStaking: not enough balance\");\n        if (now < withdrawEnds) {\n            return _withdrawEarly(from, amount);\n        } else {\n            return _withdrawAfterClose(from, amount);\n        }\n    }\n\n    function _withdrawEarly(address from, uint256 amount)\n    private\n    _realAddress(from)\n    returns (bool) {\n        // The formula to calculate reward:\n        // r = (earlyWithdrawReward / stakedTotal) * (now - stakingEnds) / (withdrawEnds - stakingEnds)\n        // w = (1+r) * a\n        uint256 denom = (withdrawEnds.sub(stakingEnds)).mul(stakedTotal);\n        uint256 reward = (\n        ( (now.sub(stakingEnds)).mul(earlyWithdrawReward) ).mul(amount)\n        ).div(denom);\n        uint256 payOut = amount.add(reward);\n        rewardBalance = rewardBalance.sub(reward);\n        stakedBalance = stakedBalance.sub(amount);\n        _stakes[from] = _stakes[from].sub(amount);\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function _withdrawAfterClose(address from, uint256 amount)\n    private\n    _realAddress(from)\n    returns (bool) {\n        uint256 reward = (rewardBalance.mul(amount)).div(stakedBalance);\n        uint256 payOut = amount.add(reward);\n        _stakes[from] = _stakes[from].sub(amount);\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function _stake(address staker, uint256 amount)\n    private\n    _after(stakingStarts)\n    _before(stakingEnds)\n    _positive(amount)\n    returns (bool) {\n        amount = amount*1e18;\n        uint256 remaining = amount;\n        if (remaining > (stakingCap.sub(stakedBalance))) {\n            remaining = stakingCap.sub(stakedBalance);\n        }\n\n        require(remaining > 0, \"BullStaking: Staking cap is filled\");\n        require((remaining + stakedTotal) <= stakingCap, \"BullStaking: this will increase staking amount pass the cap\");\n        if (!_payMe(staker, remaining)) {\n            return false;\n        }\n        emit Staked(tokenAddress, staker, amount, remaining);\n\n        if (remaining < amount) {\n\n            uint256 refund = amount.sub(remaining);\n            if (_payTo(staker, staker, refund)) {\n                emit Refunded(tokenAddress, staker, refund);\n            }\n        }\n\n        stakedBalance = stakedBalance.add(remaining);\n        stakedTotal = stakedTotal.add(remaining);\n        _stakes[staker] = _stakes[staker].add(remaining);\n        return true;\n    }\n\n    function _payMe(address payer, uint256 amount)\n    private\n    returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(address allower, address receiver, uint256 amount)\n    private\n    returns (bool) {\n\n        ERC20Interface = ERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount)\n    private\n    _positive(amount)\n    returns (bool) {\n        ERC20Interface = ERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _realAddress(address addr) {\n        require(addr != address(0), \"BullStaking: zero address\");\n        _;\n    }\n\n    modifier _positive(uint256 amount) {\n        require(amount >= 0, \"BullStaking: negative amount\");\n        _;\n    }\n\n    modifier _after(uint eventTime) {\n        require(now >= eventTime, \"BullStaking: bad timing for the request\");\n        _;\n    }\n\n    modifier _before(uint eventTime) {\n        require(now < eventTime, \"BullStaking: bad timing for the request\");\n        _;\n    }\n\n}\n"}}}