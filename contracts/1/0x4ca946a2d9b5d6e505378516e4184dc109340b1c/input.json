{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/AggregatorFacade.sol": {
      "content": "pragma solidity 0.6.2;\ninterface HistoricAggregatorInterface {\n  function latestAnswer() external returns (int256);\n  function latestTimestamp() external returns (uint256);\n  function latestRound() external returns (uint256);\n  function getAnswer(uint256 roundId) external returns (int256);\n  function getTimestamp(uint256 roundId) external returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\ninterface AggregatorInterface is HistoricAggregatorInterface {\n  function decimals() external returns (uint8);\n  function getRoundData(uint256 _roundId)\n    external\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    );\n  function latestRoundData()\n    external\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    );\n}\ncontract AggregatorFacade is AggregatorInterface {\n\n  HistoricAggregatorInterface public aggregator;\n  uint8 public override decimals;\n\n  constructor(address _aggregator, uint8 _decimals) public {\n    aggregator = HistoricAggregatorInterface(_aggregator);\n    decimals = _decimals;\n  }\n\n  /**\n   * @notice get the latest completed round where the answer was updated\n   */\n  function latestRound()\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return aggregator.latestRound();\n  }\n\n  /**\n   * @notice Reads the current answer from aggregator delegated to.\n   */\n  function latestAnswer()\n    external\n    virtual\n    override\n    returns (int256)\n  {\n    return aggregator.latestAnswer();\n  }\n\n  /**\n   * @notice Reads the last updated height from aggregator delegated to.\n   */\n  function latestTimestamp()\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return aggregator.latestTimestamp();\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt value.\n   * @return roundId is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is always equal to updatedAt because the underlying\n   * Aggregator contract does not expose this information.\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is always equal to roundId because the underlying\n   * Aggregator contract does not expose this information.\n   * @dev Note that for rounds that haven't yet received responses from all\n   * oracles, answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    external\n    virtual\n    override\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    return _getRoundData(aggregator.latestRound());\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param _roundId the answer number to retrieve the answer for\n   */\n  function getAnswer(uint256 _roundId)\n    external\n    virtual\n    override\n    returns (int256)\n  {\n    return aggregator.getAnswer(_roundId);\n  }\n\n  /**\n   * @notice get block timestamp when an answer was last updated\n   * @param _roundId the answer number to retrieve the updated timestamp for\n   */\n  function getTimestamp(uint256 _roundId)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return aggregator.getTimestamp(_roundId);\n  }\n\n  /**\n   * @notice get data about a round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt value.\n   * @param _roundId the round ID to retrieve the round data for\n   * @return roundId is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is always equal to updatedAt because the underlying\n   * Aggregator contract does not expose this information.\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is always equal to roundId because the underlying\n   * Aggregator contract does not expose this information.\n   * @dev Note that for rounds that haven't yet received responses from all\n   * oracles, answer and updatedAt may change between queries.\n   */\n  function getRoundData(uint256 _roundId)\n    external\n    virtual\n    override\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    return _getRoundData(_roundId);\n  }\n\n  /*\n   * Internal\n   */\n\n  function _getRoundData(uint256 _roundId)\n    internal\n    returns (\n      uint256 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint256 answeredInRound\n    )\n  {\n    answer = aggregator.getAnswer(_roundId);\n    updatedAt = uint64(aggregator.getTimestamp(_roundId));\n    if (updatedAt == 0) {\n      answeredInRound = 0;\n    } else {\n      answeredInRound = _roundId;\n    }\n    return (_roundId, answer, updatedAt, updatedAt, answeredInRound);\n  }\n\n}"
    }
  }
}