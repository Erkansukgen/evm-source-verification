{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/iZiFoodToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a);\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b <= a);\n        c = a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\nabstract contract ERC20 {\n    using SafeMath for uint;\n\n    string public name;\n    string public symbol;\n    \n    uint256 _totalSupply;\n    uint256 funds;\n    uint8 decimals;\n    \n    uint256 dateDeploy;\n    uint256 blockYears;\n    \n    address owner;\n    \n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) alloweds;\n\n    constructor () {\n        name = \"iZiFoodToken\";\n        symbol = \"IZFO\";\n        _totalSupply = 1000000;\n        funds = 510000;\n        decimals = 0;\n        owner = msg.sender;\n        balances[owner] = _totalSupply - funds;\n        dateDeploy = block.timestamp;\n        blockYears = dateDeploy + 730 days;\n    }\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can use this function\");\n        _;\n    }\n    \n    modifier blockedTime {\n        require(block.timestamp >= blockYears, \"This funds are blocked for 2 years\");\n        _;\n    }\n    \n    function totalSupply () public view returns (uint256 total) {\n        return _totalSupply;\n    }\n    \n    function balanceOf (address _address) public view returns (uint256 balance) {\n        require(_address != address(0x0));\n        return balances[_address];\n    }\n    \n    function transfer(address _to, uint256 _value) public virtual returns (bool success) {\n        require(_to != msg.sender, \"Can't send tokens to the same address\");\n        require(_to != address(0x0), \"Can't send to a null address\");\n        require(_value > 0, \"Can't send a negative amount of tokens\");\n        require(balances[msg.sender] >= _value, \"Insufficient balance\");\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] =  balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require(_spender != msg.sender, \"Can't approve tokens to the same address\");\n        require(balances[msg.sender] >= _value,\"Insufficient amount of tokens\");\n        require(_spender != address(0x0),\"Can't approve a null address\");\n\n        alloweds[msg.sender][_spender] = alloweds[msg.sender][_spender].add(_value);\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n    }\n    \n    function disapprove(address _spender, uint256 _value) public returns (bool success){\n        require(alloweds[msg.sender][_spender] >= _value, \"Can't disapprove more than the approved\");\n        require(_spender != address(0x0), \"Can't disapprove a null address\");\n\n        alloweds[msg.sender][_spender] = alloweds[msg.sender][_spender].sub(_value);\n\n        emit Desapproval(msg.sender, _spender, _value);\n\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success) {\n        require(balances[_from] >= _value,\"Insufficient balance\");\n        require(alloweds[_from][msg.sender] >= _value,\"Insufficient allowance\");\n        require(_value > 0,\"Can't send a negative amount of tokens\");\n        require(_to != address(0x0),\"Can't send to a null address\");\n        require(_from != address(0x0),\"Can't send from a null address\");\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        alloweds[_from][msg.sender] =  alloweds[_from][msg.sender].sub(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n    \n    function requestFunds() public onlyOwner blockedTime returns (bool success) {\n        require(funds > 0, \"Funds have already been transferred\");\n\n        balances[owner] = balances[owner].add(funds);\n        funds = 0;\n        \n        return true;\n    }\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    event Desapproval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract ERC884 is ERC20 {\n    mapping(address => bytes32) private verified;\n    mapping(address => address) private cancellations;\n    mapping(address => uint256) private holderIndices;\n    \n    address[] private shareholders;\n    \n    modifier isVerifiedAddress(address _addr) {\n        require(verified[_addr] != bytes32(0), \"The address isn't in verified list\");\n        _;\n    }\n\n    modifier isShareholder(address _addr) {\n        require(holderIndices[_addr] != 0, \"The address isn't in a shareholder\");\n        _;\n    }\n\n    modifier isNotShareholder(address _addr) {\n        require(holderIndices[_addr] == 0, \"The address is a shareholder\");\n        _;\n    }\n\n    modifier isNotCancelled(address _addr) {\n        require(cancellations[_addr] == address(0x0));\n        _;\n    }\n    \n    function addVerified(address _addr, bytes32 _hash) public onlyOwner isNotCancelled(_addr) {\n        require(_addr != address(0x0), \"Can't add a null address\");\n        require(_hash != bytes32(0), \"Can't set a null hash\");\n        require(verified[_addr] == bytes32(0), \"Can't add same address\");\n        \n        verified[_addr] = _hash;\n        \n        emit VerifiedAddressAdded(_addr, _hash, msg.sender);\n    }\n\n    function removeVerified(address _addr) public onlyOwner {\n        require(_addr != address(0x0), \"Can't remove a null address\");\n        require(balances[_addr] == 0, \"Can't remove an address that has tokens\");\n        \n        if(verified[_addr] != bytes32(0)) {\n            verified[_addr] = bytes32(0);\n            emit VerifiedAddressRemoved(_addr, msg.sender);\n        }\n    }\n    \n    function updateVerified(address _addr, bytes32 _hash) public onlyOwner isVerifiedAddress(_addr) {\n        require(_hash != bytes32(0), \"The hash is required\");\n        \n        bytes32 oldHash = verified[_addr];\n        \n        if(oldHash != _hash) {\n            verified[_addr] = _hash;\n            emit VerifiedAddressUpdated(_addr, oldHash, _hash, msg.sender);\n        }\n    }\n    \n    function cancelAndReissue(address _original, address _replacement) public onlyOwner isShareholder(_original) isNotShareholder(_replacement) isVerifiedAddress(_replacement) returns (bool success) {\n        verified[_original] = bytes32(0);\n        cancellations[_original] = _replacement;\n\n        uint256 holderIndex = holderIndices[_original] - 1;\n        shareholders[holderIndex] = _replacement;\n\n        holderIndices[_replacement] = holderIndices[_original];\n        holderIndices[_original] = 0;\n\n        balances[_replacement] = balances[_original];\n        balances[_original] = 0;\n\n        emit VerifiedAddressSuperseded(_original, _replacement, msg.sender);\n\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) override public isVerifiedAddress(_to) returns (bool success) {\n        updateShareholders(_to);\n        pruneShareholders(msg.sender, _value);\n        return super.transfer(_to, _value);\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) override public isVerifiedAddress(_to) returns (bool success) {\n        updateShareholders(_to);\n        pruneShareholders(_from, _value);\n        return super.transferFrom(_from, _to, _value);\n    }\n    \n    function isVerified(address _addr) public view returns (bool verifiedAddress) {\n        require(_addr != address(0x0), \"Can't verify a null address\");\n        \n        return verified[_addr] != bytes32(0);\n    }\n\n    function isHolder(address _addr) public view returns (bool holder) {\n        require(_addr != address(0x0), \"Can't verify a null address\");\n        \n        return holderIndices[_addr] != 0;\n    }\n\n    function hasHash(address _addr, bytes32 _hash) public view returns (bool hash) {\n        require(_addr != address(0x0), \"Can't verify a null address\");\n        require(_hash != bytes32(0), \"Can't verify a null hash\");\n\n        if (_addr == address(0x0)) {\n            return false;\n        }\n\n        return verified[_addr] == _hash;\n    }\n\n    function holderCount() public view returns (uint256 totalHolders) {\n        return shareholders.length;\n    }\n\n    function holderAt(uint256 _index) public view onlyOwner returns (address holder) {\n        require(_index < shareholders.length, \"The index must be less than the size of the array\");\n\n        return shareholders[_index];\n    }\n\n    function isSuperseded(address addr) public view onlyOwner returns (bool superseded) {\n        return cancellations[addr] != address(0x0);\n    }\n\n    function getCurrentFor(address _addr) public view onlyOwner returns (address) {\n        return findCurrentFor(_addr);\n    }\n\n    function findCurrentFor(address _addr) internal view returns (address) {\n        address candidate = cancellations[_addr];\n        if (candidate == address(0x0)) {\n            return _addr;\n        }\n        return findCurrentFor(candidate);\n    }\n    \n    function updateShareholders(address _addr) internal {\n        if (holderIndices[_addr] == 0) {\n            shareholders.push(_addr);\n            holderIndices[_addr] = shareholders.length;\n        }\n    }\n    \n    function pruneShareholders(address _addr, uint256 _value) internal {\n        uint256 balance = balances[_addr] - _value;\n\n        if (balance > 0) {\n            return;\n        }\n        uint256 holderIndex = holderIndices[_addr] - 1;\n        uint256 lastIndex = shareholders.length - 1;\n\n        address lastHolder = shareholders[lastIndex];\n\n        shareholders[holderIndex] = lastHolder;\n        holderIndices[lastHolder] = holderIndices[_addr];\n\n        shareholders.pop();\n        holderIndices[_addr] = 0;\n    }\n\n    event VerifiedAddressAdded(address indexed _addr, bytes32 _hash, address indexed _sender);\n\n    event VerifiedAddressRemoved(address indexed _addr, address indexed _sender);\n    \n    event VerifiedAddressUpdated(address indexed _addr, bytes32 _oldHash, bytes32 _hash, address indexed _sender);\n    \n    event VerifiedAddressSuperseded(address indexed _original, address indexed _replacement, address indexed _sender);\n}\n"
    }
  }
}