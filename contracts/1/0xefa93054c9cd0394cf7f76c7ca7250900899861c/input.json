{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/odar_hash_v2.sol": {
      "content": "pragma solidity >=0.4.22 <0.7.0;\ncontract odar_hash {\n    uint256 public current_id;\n    address payable public operator;\n    uint256 public transfer_price_wei;\n    uint256 public update_price_wei;\n\n    struct hashtag_price_struct {\n        uint256 price_wei;\n    }\n\n    mapping(uint256 => hashtag_price_struct) public hashtag_length;\n\n    struct hashtag_struct {\n        address payable owner;\n        string dapp_url;\n        string metadata_url;\n        uint256 timestamp_registered;\n        uint256 timestamp_updated;\n        uint256 id;\n    }\n\n    mapping(string => hashtag_struct) public hashtag;\n\n    struct id_struct {\n        string ht;\n    }\n\n    mapping(uint256 => id_struct) public hashtag_id;\n\n    // ini\n    constructor() public {\n    operator = msg.sender;\n    current_id = 0;\n    transfer_price_wei = 1000000000000000; \n    update_price_wei = 1000000000000000;\n    hashtag_length[0].price_wei = 1000000000000000; \n    hashtag_length[1].price_wei = 100000000000000000000; \n    hashtag_length[2].price_wei = 10000000000000000000; \n    hashtag_length[3].price_wei = 1000000000000000000; \n    hashtag_length[4].price_wei = 100000000000000000; \n    hashtag_length[5].price_wei = 10000000000000000; \n    hashtag_length[6].price_wei = 1000000000000000; \n    }\n\n    // operator functions\n\n    function opO(address payable nop) public { // change operator\n        require(msg.sender == operator, \"Only operator can call this function\");\n        operator = nop;\n    }\n\n    function opP(uint256 chars, uint256 np) public {\n        require(msg.sender == operator, \"Only operator can call this function\");\n        hashtag_length[chars].price_wei = np;\n    }\n\n    function opUT(uint256 u, uint256 t) public {\n        require(msg.sender == operator, \"Only operator can call this function\");\n        update_price_wei = u; \n        transfer_price_wei = t; \n    }\n\n    function opW(address payable r) public {\n        require(msg.sender == operator, \"Only operator can call this function\");\n        r.transfer(address(this).balance);\n    }\n\n    // public functions \n\n    function getHashtagPrice(string memory new_hashtag) public view returns (uint256 hashtag_reg_price_wei){   \n        new_hashtag = _toLower(new_hashtag);\n        if (hashtag[new_hashtag].id != 0) {return(0);}\n        else {\n            uint256 ht_len = bytes(new_hashtag).length;\n            if (ht_len>6) {return(hashtag_length[0].price_wei);}\n            else {return(hashtag_length[ht_len].price_wei);}\n        }\n    }\n\n    function registerHashtag(\n        string memory new_hashtag,\n        string memory new_dapp_url,\n        string memory new_metadata_url,\n        address payable comm_address\n    ) public payable {\n        new_hashtag = _toLower(new_hashtag);\n        require(hashtag[new_hashtag].id == 0, \"Hashtag already registered\");\n        if (msg.sender != operator) {\n            uint256 ht_len = bytes(new_hashtag).length;\n            uint256 new_price = hashtag_length[0].price_wei;\n            if(ht_len <= 6){new_price=hashtag_length[ht_len].price_wei;}\n            require(\n                msg.value >= new_price,\n                \"Hashtag registration payment too low. Use getHashtagPrice() to check the price.\"\n            );\n        }\n        current_id++;\n        hashtag_id[current_id].ht = new_hashtag;\n        hashtag[new_hashtag].owner = msg.sender;\n        hashtag[new_hashtag].dapp_url = new_dapp_url;\n        hashtag[new_hashtag].metadata_url = new_metadata_url;\n        hashtag[new_hashtag].id = current_id;\n        hashtag[new_hashtag].timestamp_registered = now;\n        hashtag[new_hashtag].timestamp_updated = now;\n\n        //send commission\n        if (comm_address != address(0)) {\n            comm_address.transfer(msg.value / 2);\n        }\n    }\n    \nfunction getOwner(string memory hashtag_to_check) public returns (address){\n        return hashtag[hashtag_to_check].owner; \n    }\n\nfunction updateHashtag(\n        string memory hashtag_to_update,\n        string memory new_dapp_url,\n        string memory new_metadata_url, \n        address payable comm_address\n    ) public payable {\n        require(\n            msg.sender == hashtag[hashtag_to_update].owner || msg.sender == operator,\n            \"Only hashtag owner can call this function\"\n        );\n        if (msg.sender != operator) {\n            require(msg.value >= update_price_wei, \"Payment too low, check update_price_wei variable for pricing\"); \n        }\n        hashtag[hashtag_to_update].dapp_url = new_dapp_url;\n        hashtag[hashtag_to_update].metadata_url = new_metadata_url;\n        hashtag[hashtag_to_update].timestamp_updated = now;\n\n        //send commission\n        if (comm_address != address(0)) {\n            comm_address.transfer(msg.value / 2);\n        }\n    }\n\n    function transferHashtag(string memory hashtag_for_transfer, address payable new_owner, address payable commission_address) public payable {\n        hashtag_for_transfer = _toLower(hashtag_for_transfer);\n        require(\n            msg.sender == hashtag[hashtag_for_transfer].owner || msg.sender == operator,\n            \"Only current hashtag owner can call this function\"\n        );\n        if (msg.sender != operator) {\n            require(msg.value>=transfer_price_wei, \"Payment too low, check transfer_price_wei variable for pricing\"); \n        }\n        hashtag[hashtag_for_transfer].owner = new_owner;\n        \n        //send commission\n        if (commission_address != address(0)) {\n            commission_address.transfer(msg.value / 2);\n        }\n    }\n\n    // internal \n\n    function _toLower(string memory str) internal pure returns (string memory) {\n        bytes memory bStr = bytes(str);\n        bytes memory bLower = new bytes(bStr.length);\n        for (uint i = 0; i < bStr.length; i++) {\n            // Uppercase character...\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\n                // So we add 32 to make it lowercase\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\n            } else {\n                bLower[i] = bStr[i];\n            }\n        }\n        return string(bLower);\n    }\n}"
    }
  }
}