{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "bot.sol": {
      "content": "pragma solidity ^0.8.4;\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\ninterface RouterV2{\r\n    function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ncontract Ownable {\r\n    address public owner = msg.sender;\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n}\r\ncontract Manager is Ownable {\r\n    mapping(address=>bool) manager;\r\n    function setManager(address _target, bool status) public onlyOwner{\r\n        manager[_target]=status;\r\n    }\r\n    function isManager(address _target) public view returns(bool){\r\n        return manager[_target];\r\n    }\r\n    modifier onlyManager() {\r\n        if (manager[msg.sender] != true) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n}\r\ncontract GameSwap is Manager{\r\n    struct Item{\r\n        address token;\r\n        address tokenPair;\r\n        address pairContract;\r\n        address routerContract;\r\n    }\r\n    uint128 public decimals=10**18;\r\n    \r\n    address public USDT;//BUSD\r\n    address public WETH;//WBNB\r\n    address public USDC;\r\n    uint8 public safeNumber;\r\n    uint256 public maxIn = 1000000*decimals;\r\n    \r\n    function setToken(address _usdt, address _weth, address _usdc, uint8 _safeNumber, uint256 _maxIn) public onlyOwner{\r\n        USDT=_usdt;\r\n        WETH=_weth;\r\n        USDC=_usdc;\r\n        safeNumber=_safeNumber;\r\n        maxIn=_maxIn;\r\n    }\r\n    function Sum(Item[] memory Input) internal view returns(uint256){\r\n        uint256 count = Input.length;\r\n        uint256 total=0;\r\n        for(uint256 i=0;i<count;i++){\r\n            total+=IERC20(Input[i].token).balanceOf(Input[i].pairContract);\r\n        }\r\n        return total;\r\n    }\r\n    function approveToken(address token, address spender, uint256 quantity) public onlyOwner{\r\n        IERC20(token).approve(spender, quantity);\r\n    }\r\n    function safeOut(address token, uint256 quantity) public onlyOwner{\r\n        IERC20(token).transfer(msg.sender, quantity);\r\n    }\r\n    function Swap(Item[] memory Input) public onlyManager{\r\n        uint256 pool=Sum(Input);\r\n        uint256 count = Input.length;\r\n        uint256 myBalance = IERC20(USDT).balanceOf(address(this));\r\n        \r\n        for(uint256 i=0;i<count;i++){\r\n            Item memory Ip = Input[i];\r\n            \r\n            uint256 balance = IERC20(Ip.token).balanceOf(Ip.pairContract);\r\n            uint256 percent = (balance*decimals)/pool;\r\n            \r\n            uint256 tokenIn = (percent*myBalance)/decimals;\r\n            \r\n            address[] memory path = new address[](2);\r\n            path[0] = USDT;\r\n            path[1] = Ip.token;\r\n            uint256[] memory tokenOut = RouterV2(Ip.routerContract).getAmountsOut(tokenIn, path); // tokenout[0] sai\r\n            if(Ip.tokenPair==USDT){\r\n                //safe check \r\n                uint256 safeAmount = IERC20(USDT).balanceOf(Ip.pairContract);\r\n                if(safeAmount>tokenIn*safeNumber){\r\n                    RouterV2(Ip.routerContract).swapTokensForExactTokens(tokenOut[1], maxIn, path, owner, block.timestamp+1000);\r\n                }\r\n            }\r\n            else if(Ip.tokenPair==WETH){\r\n                address[] memory pathETH = new address[](2);\r\n                pathETH[0] = USDT;\r\n                pathETH[1] = WETH;\r\n                \r\n                uint256[] memory estWETH = RouterV2(Ip.routerContract).getAmountsOut(tokenIn, pathETH);\r\n                RouterV2(Ip.routerContract).swapTokensForExactTokens(estWETH[1], maxIn, pathETH, address(this), block.timestamp+1000);\r\n                \r\n                uint256 wethInBalance = IERC20(WETH).balanceOf(address(this));\r\n                address[] memory pathRouterETH = new address[](2);\r\n                pathRouterETH[0] = WETH;\r\n                pathRouterETH[1] = Ip.token;\r\n                \r\n                uint256[] memory estTokenOut = RouterV2(Ip.routerContract).getAmountsOut(wethInBalance, pathRouterETH);\r\n                //safe check\r\n                uint256 safeAmount = IERC20(WETH).balanceOf(Ip.pairContract);\r\n                if(safeAmount>wethInBalance*safeNumber){\r\n                    RouterV2(Ip.routerContract).swapTokensForExactTokens(estTokenOut[1], maxIn, pathRouterETH, owner, block.timestamp+1000);\r\n                }\r\n            }\r\n            else if(Ip.tokenPair==USDC){\r\n                address[] memory pathUSDC = new address[](2);\r\n                pathUSDC[0] = USDT;\r\n                pathUSDC[1] = USDC;\r\n                \r\n                uint256[] memory estUSDC = RouterV2(Ip.routerContract).getAmountsOut(tokenIn, pathUSDC);\r\n                RouterV2(Ip.routerContract).swapTokensForExactTokens(estUSDC[1], maxIn, pathUSDC, address(this), block.timestamp+1000);\r\n                \r\n                uint256 usdcInBalance = IERC20(USDC).balanceOf(address(this));\r\n                address[] memory pathRouterUSDC = new address[](2);\r\n                pathRouterUSDC[0] = USDC;\r\n                pathRouterUSDC[1] = Ip.token;\r\n                \r\n                uint256[] memory estTokenOut = RouterV2(Ip.routerContract).getAmountsOut(usdcInBalance, pathRouterUSDC);\r\n                //safe check\r\n                uint256 safeAmount = IERC20(USDC).balanceOf(Ip.pairContract);\r\n                if(safeAmount>usdcInBalance*safeNumber){\r\n                    RouterV2(Ip.routerContract).swapTokensForExactTokens(estTokenOut[1], maxIn, pathRouterUSDC, owner, block.timestamp+1000);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
    }
  }
}