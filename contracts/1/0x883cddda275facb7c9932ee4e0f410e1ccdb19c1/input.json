{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "TheRichies.sol": {
      "content": "\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n\npragma solidity ^0.8.0;\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\npragma solidity ^0.8.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; \n        return msg.data;\n    }\n}\n\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\npragma solidity ^0.8.0;\n\ninterface IERC1155Receiver is IERC165 {\n\n\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n\n\n\npragma solidity ^0.8.0;\n\ninterface IERC1155 is IERC165 {\n\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n    event URI(string value, uint256 indexed id);\n    \n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n    function setApprovalForAll(address operator, bool approved) external;\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n\n\npragma solidity ^0.8.0;\n\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n\n\n\npragma solidity ^0.8.0;\n\nlibrary SafeMath {\n    \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n\n\n\npragma solidity ^0.8.0;\n\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\npragma solidity ^0.8.0;\n\ninterface IERC1155MetadataURI is IERC1155 {\n    function uri(uint256 id) external view returns (string memory);\n}\n\n\npragma solidity ^0.8.0;\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor (string memory uri_) {\n        _setURI(uri_);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155).interfaceId\n            || interfaceId == type(IERC1155MetadataURI).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n        return batchBalances;\n    }\n\n  \n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n \n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, from, to, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n   \n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n   \n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n        address operator = _msgSender();\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        address operator = _msgSender();\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        address operator = _msgSender();\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        _balances[id][account] = accountBalance - amount;\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        address operator = _msgSender();\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n        for (uint i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n   \n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n\npragma solidity 0.8.0;\n\ninterface IERC20 {\n\tfunction totalSupply() external view returns (uint256);\n\tfunction balanceOf(address account) external view returns (uint256);\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract TheRichies is ERC1155, Ownable {\n\tusing SafeMath for uint256;\n\tusing Strings for string;\n\tuint256 public richiesSold;\n\tuint256 public totalRichies = 4444;\n\tuint256 public presaleSupply;\n\tbool public sale = false;\n\tbool public preSale = false;\n\tmapping(uint256 => uint256) private _totalSupply;\n\n\tstring public _baseURI = \"https://mint.richiesnft.com/api/richie/\";\n\tmapping(uint256 => string) public _tokenURIs;\n\tuint256 public itemPrice;\n\taddress public companyWallet = 0xbC4eb5e97C12542EA4951eb8A01A36F7f0957319;\n\n\tconstructor() ERC1155(_baseURI) {\n\t\titemPrice = 100000000000000000; // 0.1 ETH\n\t}\n\n\tfunction setItemPrice(uint256 _price) public onlyOwner {\n\t\titemPrice = _price;\n\t}\n\n\tfunction getItemPrice() public view returns (uint256) {\n\t\treturn itemPrice;\n\t}\n\t\n\tfunction buyPresale(uint256 _howMany) public payable {\n\t    require(presaleSupply < 445 && preSale, \"Presale inactive\");\n\t\trequire(_howMany <= 10, \"max 10 richies at once\");\n\t\trequire(itemPrice.mul(_howMany) == msg.value, \"insufficient ETH\");\n\t\tfor (uint256 i = 0; i < _howMany; i++) {\n\t\t\tgetRichie();\n\t\t}\n\t\tpresaleSupply = presaleSupply + _howMany;\n\t}\n\n\tfunction buyRichie(uint256 _howMany) public payable {\n\t    require(sale, \"Minting has not started yet\");\n\t    require(richiesSold < 4439, \"All sold out\");\n\t\trequire(_howMany <= 10, \"max 10 richies at once\");\n\t\trequire(itemPrice.mul(_howMany) == msg.value, \"insufficient ETH\");\n\t\tfor (uint256 i = 0; i < _howMany; i++) {\n\t\t\tgetRichie();\n\t\t}\n\t}\n\n\tfunction getRichie() private {\n\t\tfor (uint256 i = 0; i < 9999; i++) {\n\t\t\tuint256 randID = random(1, totalRichies, uint256(uint160(address(msg.sender))) + i);\n\t\t\tif (_totalSupply[randID] == 0) {\n\t\t\t\t_totalSupply[randID] = 1;\n\t\t\t\t_mint(msg.sender, randID, 1, \"0x0000\");\n\t\t\t\trichiesSold = richiesSold + 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trevert(\"you're very unlucky\");\n\t}\n\n\tfunction mint(address to, uint256 id, bytes memory data) public onlyOwner {\n\t\trequire(_totalSupply[id] == 0, \"this richie is already owned by someone\");\n\t\t_totalSupply[id] = 1;\n\t\trichiesSold = richiesSold + 1;\n\t\t_mint(to, id, 1, data);\n\t}\n\n\tfunction setBaseURI(string memory newuri) public onlyOwner {\n\t\t_baseURI = newuri;\n\t}\n\n\tfunction uri(uint256 tokenId) public view override returns (string memory) {\n\t\treturn string(abi.encodePacked(_baseURI, uint2str(tokenId)));\n\t}\n\t\n\tfunction tokenURI(uint256 tokenId) public view returns (string memory) {\n\t\treturn string(abi.encodePacked(_baseURI, uint2str(tokenId)));\n\t}\n\n\tfunction uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n\t\tif (_i == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\t\tuint256 j = _i;\n\t\tuint256 len;\n\t\twhile (j != 0) {\n\t\t\tlen++;\n\t\t\tj /= 10;\n\t\t}\n\t\tbytes memory bstr = new bytes(len);\n\t\tuint256 k = len;\n\t\twhile (_i != 0) {\n\t\t\tk = k - 1;\n\t\t\tuint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n\t\t\tbytes1 b1 = bytes1(temp);\n\t\t\tbstr[k] = b1;\n\t\t\t_i /= 10;\n\t\t}\n\t\treturn string(bstr);\n\t}\n\n\tfunction totalSupply(uint256 id) public view virtual returns (uint256) {\n\t\treturn _totalSupply[id];\n\t}\n\n\tfunction exists(uint256 id) public view virtual returns (bool) {\n\t\treturn totalSupply(id) > 0;\n\t}\n\n\tfunction random(\n\t\tuint256 from,\n\t\tuint256 to,\n\t\tuint256 salty\n\t) private view returns (uint256) {\n\t\tuint256 seed =\n\t\t\tuint256(\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\tblock.timestamp +\n\t\t\t\t\t\t\tblock.difficulty +\n\t\t\t\t\t\t\t((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (block.timestamp)) +\n\t\t\t\t\t\t\tblock.gaslimit +\n\t\t\t\t\t\t\t((uint256(keccak256(abi.encodePacked(msg.sender)))) / (block.timestamp)) +\n\t\t\t\t\t\t\tblock.number +\n\t\t\t\t\t\t\tsalty\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\treturn seed.mod(to - from) + from;\n\t}\n\n\tfunction withdraw() public onlyOwner {\n\t\tuint256 balance = address(this).balance;\n\t\tpayable(companyWallet).transfer(balance);\n\t}\n\n\tfunction activateSale(bool status) public onlyOwner {\n\t\tsale = status;\n\t}\n\t\n\tfunction activatePreSale(bool status) public onlyOwner {\n\t\tpreSale = status;\n\t}\n\n\tfunction reclaimToken(IERC20 token) public onlyOwner {\n\t\trequire(address(token) != address(0));\n\t\tuint256 balance = token.balanceOf(address(this));\n\t\ttoken.transfer(msg.sender, balance);\n\t}\n\t\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    }
  }
}