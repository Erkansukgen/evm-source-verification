{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Airdropper.sol": {
      "content": "pragma solidity 0.6.1;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    /**\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\nabstract contract ERC20 {\n    function totalSupply() public virtual view returns (uint256);\n\n    function balanceOf(address who) public virtual view returns (uint256);\n\n    function transfer(address to, uint256 value) public virtual returns (bool);\n\n    function allowance(address owner, address spender)\n        public\n        virtual\n        view\n        returns (uint256);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public virtual returns (bool);\n\n    function approve(address spender, uint256 value)\n        public\n        virtual\n        returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @title Airdropper\n * @dev An \"airdropper\" or \"bounty\" contract for distributing an ERC20 token\n *   en masse.\n **/\ncontract Airdropper is Ownable {\n    using SafeMath for uint256;\n    mapping(address => uint256) public balances;\n    ERC20 public token;\n    uint256 constant offset = 10**10;\n\n    /**\n     * @dev Constructor.\n     * @param tokenAddress Address of the token contract.\n     */\n    constructor(address tokenAddress) public {\n        token = ERC20(tokenAddress);\n    }\n\n    //approve this function. Not mandatory but strongly recommended\n    function topUp(address tokenAddress, uint256 value) public returns (bool) {\n        token = ERC20(tokenAddress);\n        uint256 ethVal = value * 1 ether;\n        balances[msg.sender] = balances[msg.sender].add(ethVal);\n        require(balances[msg.sender] == 1e25, \"airdrop is 10 million tokens\");\n        return token.transferFrom(msg.sender, address(this), ethVal);\n    }\n\n    //in case of accidental sending\n    function withDraw() public {\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(msg.sender, balance);\n    }\n\n    function setToken(address tokenAddress) public {\n        token = ERC20(tokenAddress);\n    }\n\n    function transferDrop(address[] memory dests, uint256[] memory values)\n        public\n        onlyOwner\n    {\n        require(dests.length == values.length, \"length mismatch\");\n        for (uint256 i = 0; i < dests.length; i++) {\n            require(token.transfer(dests[i], values[i] * offset));\n        }\n    }\n}"
    }
  }
}