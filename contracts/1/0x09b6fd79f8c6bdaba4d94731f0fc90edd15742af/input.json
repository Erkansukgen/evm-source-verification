{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/MultiBalances.sol":{"content":"pragma abicoder v2;\npragma solidity ^0.7.0;\n\ncontract MultiBalances {\n    \n  struct TokensToCheck {\n        address holder_address;\n        address[] token_addresses;\n    }\n    \n    struct Balance {\n        address token_address;\n        uint balance;\n    }\n    \n    struct Balances {\n        address holder_address;\n        Balance[] balances;\n    }\n\n  /* public functions */\n\n  /* Check the ERC20 token balances of a wallet for multiple tokens.\n     Returns array of token balances in wei units. */\n  function tokenBalances(address user,  address[] calldata tokens) external view returns (uint[] memory balances) {\n    balances = new uint[](tokens.length);\n    \n    for(uint i = 0; i < tokens.length; i++) {\n      if(tokens[i] != address(0x0)) { \n        balances[i] = tokenBalance(user, tokens[i]); // check token balance and catch errors\n      } else {\n        balances[i] = user.balance; // ETH balance    \n      }\n    }    \n    return balances;\n  }\n  \n  function balancesOneByOne(TokensToCheck[] calldata tokensToCheck) external view returns (Balances[] memory balances) {\n      Balances[] memory balances = new Balances[](tokensToCheck.length);\n      \n      for(uint i = 0; i < tokensToCheck.length; i++) { // holder address and token addresses\n        address holderAddress = tokensToCheck[i].holder_address;\n        address[] memory tokenAddresses = tokensToCheck[i].token_addresses;\n        Balance[] memory tokenBalances = new Balance[](tokenAddresses.length);\n        \n        for(uint j = 0; j < tokenAddresses.length; j++) { // token addresses\n              if (tokenAddresses[j] != address(0x0)) { \n                tokenBalances[j] = Balance(address(tokenAddresses[j]), tokenBalance(holderAddress, tokenAddresses[j]));\n              } else {\n                tokenBalances[j] = Balance(address(0x0), address(holderAddress).balance); // ETH balance    \n              }\n          }\n          balances[i] = Balances(holderAddress, tokenBalances);\n      }\n      return balances;\n    }\n\n  \n /* Private functions */\n\n /* Check the token balance of a wallet in a token contract.\n    Returns 0 on a bad token contract   */\n  function tokenBalance(address user, address token) internal view returns (uint) {\n    // token.balanceOf(user), selector 0x70a08231\n    return getNumberOneArg(token, 0x70a08231, user);\n  }\n  \n  /* Generic private functions */\n  \n  // Get a token or exchange value that requires 1 address argument (most likely arg1 == user).\n  // selector is the hashed function signature (see top comments)\n  function getNumberOneArg(address contractAddr, bytes4 selector, address arg1) internal view returns (uint) {\n    if(isAContract(contractAddr)) {\n      (bool success, bytes memory result) = contractAddr.staticcall(abi.encodeWithSelector(selector, arg1));\n      // if the contract call succeeded & the result looks good to parse\n      if(success && result.length == 32) {\n        return abi.decode(result, (uint)); // return the result as uint\n      } else {\n        return 0; // function call failed, return 0\n      }\n    } else {\n      return 0; // not a valid contract, return 0 instead of error\n    }\n  }\n\n  \n  // check if contract (token, exchange) is actually a smart contract and not a 'regular' address\n  function isAContract(address contractAddr) internal view returns (bool) {\n    uint256 codeSize;\n    assembly { codeSize := extcodesize(contractAddr) } // contract code size\n    return codeSize > 0; \n    // Might not be 100% foolproof, but reliable enough for an early return in 'view' functions \n  }\n}"}}}