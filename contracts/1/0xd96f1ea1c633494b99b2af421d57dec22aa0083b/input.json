{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BotRouter.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport './interfaces/IUniswapV2Pair.sol';\nimport './interfaces/TransferHelper.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/IERC20.sol';\n\n\ncontract BotRouter {\n    \n    bytes4 private constant transferSig = 0xa9059cbb;\n    \n    // ownership\n    address public constant OWNER1 = address(0xD43975Be509eA732A3BD64F2D5fa34D355A8F911);\n    address public constant OWNER2 = address(0x0D0B3F21d7c90d0b957Aa6aCBc993621311208E4);\n    address public constant OWNER3 = address(0xb1BD29E35D7ca6f499fFc4180357a4d237e1E0De);\n    address public constant OWNER4 = address(0xF0475a1f184f062D1eee88f0D79EC4EB2795D4F0);\n    \n    // const for all tokens\n    address public constant TOKEN_0 = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // weth mainnet\n    address public constant TOKEN_1 = address(0x514910771AF9Ca656af840dff83E8264EcF986CA); // link mainnet\n    address public constant TOKEN_2 = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // wbtc mainnet\n    address public constant TOKEN_3 = address(0x419D0d8BdD9aF5e606Ae2232ed285Aff190E711b); // fun mainnet\n    address public constant TOKEN_4 = address(0xd26114cd6EE289AccF82350c8d8487fedB8A0C07); // omg mainnet\n    address public constant TOKEN_5 = address(0xCC8Fa225D80b9c7D42F96e9570156c65D6cAAa25); // slp mainnet\n    address public constant TOKEN_6 = address(0xEA26c4aC16D4a5A106820BC8AEE85fd0b7b2b664); // quark mainnet\n    address public constant TOKEN_7 = address(0xADE00C28244d5CE17D72E40330B1c318cD12B7c3); // adex mainnet\n    address public constant TOKEN_8 = address(0x3597bfD533a99c9aa083587B074434E61Eb0A258); // dent mainnet\n    \n    function _onlyOwner() internal view {\n        require(msg.sender == OWNER1 || msg.sender == OWNER2 || msg.sender == OWNER3 || msg.sender == OWNER4, \"Only Owner\");\n    }\n    \n    function withdrawToken(address token, uint256 amount) external {\n        _onlyOwner();\n        \n        if(amount == 0) {\n            amount = IERC20(token).balanceOf(address(this));\n        }\n        \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(transferSig, msg.sender, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\n    }\n    \n    function balanceOfOwner(address token, address owner) external view returns(uint) {\n        return IERC20(token).balanceOf(owner);\n    }\n    \n    receive() external payable {\n        if (msg.sender != TOKEN_0) {\n            IWETH(TOKEN_0).deposit{value: msg.value}();\n        }\n    }\n    \n    function withdrawWeth(uint256 etherAmount) external {\n        _onlyOwner();\n        \n        if(etherAmount == 0) {\n            etherAmount = IERC20(TOKEN_0).balanceOf(address(this));\n        }\n        \n        IWETH(TOKEN_0).withdraw(etherAmount);\n        (bool success,) = msg.sender.call{value:etherAmount}(new bytes(0));\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n    \n    // view balances\n    function balanceOf(address token) external view returns (uint) {\n        return IERC20(token).balanceOf(address(this));\n    }\n    \n    function destroy() public {\n        _onlyOwner();\n\n        uint wethAmount = IERC20(TOKEN_0).balanceOf(address(this));\n        \n        if(wethAmount > 0) {\n            IWETH(TOKEN_0).withdraw(wethAmount);\n            (bool success,) = msg.sender.call{value:wethAmount}(new bytes(0));\n            require(success, 'DES');\n        }\n        selfdestruct(payable(msg.sender));\n    }\n    \n    function _swap(uint amountOut, bool zeroForOne, address pair, address to) internal {\n        (uint amount0Out, uint amount1Out) = zeroForOne ? (uint(0), amountOut) : (amountOut, uint(0));\n        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n    \n    function swapExactTokensForWETH(\n        uint amountIn,\n        uint8 tokenInIndex,\n        // address tokenIn, // use index and constant tokens instead of address\n        uint amountOut,\n        // address tokenOut, // use index instead of address\n        address pair,\n        bool zeroForOne\n        // address to,\n        // uint deadline\n    ) external payable returns (bool) {\n        _onlyOwner();\n        \n        address tokenIn = getTokenAddress(tokenInIndex);\n        require(tokenIn != TOKEN_0, \"!weth\");\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (uint reserveIn, uint reserveOut) = zeroForOne ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint amountOutComputed = getAmountOut(amountIn, reserveIn, reserveOut);\n        require(amountOutComputed >= amountOut, 'IOA');\n        TransferHelper.safeTransfer(tokenIn, pair, amountIn);\n        _swap(amountOutComputed, zeroForOne, pair, address(this));\n        block.coinbase.transfer(msg.value);\n        return true;\n    }\n    \n    function swapWETHForExactTokens(\n        uint amountIn,\n        uint8 tokenInIndex,\n        // address tokenIn, // use index and constant tokens instead of address\n        uint amountOut,\n        // address tokenOut, // use index instead of address\n        address pair,\n        bool zeroForOne\n        // address to,\n        // uint deadline\n    ) external payable returns (bool) {\n        _onlyOwner();\n        \n        address tokenIn = getTokenAddress(tokenInIndex);\n        require(tokenIn == TOKEN_0, \"only weth\");\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (uint reserveIn, uint reserveOut) = zeroForOne ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        uint amountInComputed = getAmountIn(amountOut, reserveIn, reserveOut);\n        require(amountInComputed <= amountIn, 'AOI');\n        TransferHelper.safeTransfer(tokenIn, pair, amountInComputed);\n        _swap(amountOut, zeroForOne, pair, address(this));\n        block.coinbase.transfer(msg.value);\n        return true;\n    }\n    \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        // require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        // require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn * 997;\n        uint numerator = amountInWithFee * reserveOut;\n        uint denominator = reserveIn * 1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n    \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        // require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        // require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn * amountOut * 1000;\n        uint denominator = (reserveOut - amountOut) * 997;\n        amountIn = (numerator / denominator) + 1;\n    }\n    \n    function tokenAddressToTokenIndex(address token) public pure returns(uint8 tokenIndex) {\n        if(token == TOKEN_0)\n            return 0;\n        else if(token == TOKEN_1) {\n            return 1;\n        }\n        else if(token == TOKEN_2) {\n            return 2;\n        }\n        else if(token == TOKEN_3) {\n            return 3;\n        }\n        else if(token == TOKEN_4) {\n            return 4;\n        }\n        else if(token == TOKEN_5) {\n            return 5;\n        }\n        else if(token == TOKEN_6) {\n            return 6;\n        }\n        else if(token == TOKEN_7) {\n            return 7;\n        }\n        else if(token == TOKEN_8) {\n            return 8;\n        }\n    }\n    \n    function getTokenAddress(uint8 index) public pure returns (address token) {\n        if(index == 0) {\n            return TOKEN_0;\n        }\n        else if(index == 1) {\n            return TOKEN_1;\n        }\n        else if(index == 2) {\n            return TOKEN_2;\n        }\n        else if(index == 3) {\n            return TOKEN_3;\n        }\n        else if(index == 4) {\n            return TOKEN_4;\n        }\n        else if(index == 5) {\n            return TOKEN_5;\n        }\n        else if(index == 6) {\n            return TOKEN_6;\n        }\n        else if(index == 7) {\n            return TOKEN_7;\n        }\n        else if(index == 8) {\n            return TOKEN_8;\n        }\n    }\n    \n}\n"},"interfaces/IERC20.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    // event Approval(address indexed owner, address indexed spender, uint value);\n    // event Transfer(address indexed from, address indexed to, uint value);\n\n    // function name() external view returns (string memory);\n    // function symbol() external view returns (string memory);\n    // function decimals() external view returns (uint8);\n    // function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    // function allowance(address owner, address spender) external view returns (uint);\n\n    // function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    // function transferFrom(address from, address to, uint value) external returns (bool);\n}"},"interfaces/IUniswapV2Pair.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    // event Approval(address indexed owner, address indexed spender, uint value);\n    // event Transfer(address indexed from, address indexed to, uint value);\n\n    // function name() external pure returns (string memory);\n    // function symbol() external pure returns (string memory);\n    // function decimals() external pure returns (uint8);\n    // function totalSupply() external view returns (uint);\n    // function balanceOf(address owner) external view returns (uint);\n    // function allowance(address owner, address spender) external view returns (uint);\n\n    // function approve(address spender, uint value) external returns (bool);\n    // function transfer(address to, uint value) external returns (bool);\n    // function transferFrom(address from, address to, uint value) external returns (bool);\n\n    // function DOMAIN_SEPARATOR() external view returns (bytes32);\n    // function PERMIT_TYPEHASH() external pure returns (bytes32);\n    // function nonces(address owner) external view returns (uint);\n\n    // function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    // event Mint(address indexed sender, uint amount0, uint amount1);\n    // event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    // event Swap(\n    //     address indexed sender,\n    //     uint amount0In,\n    //     uint amount1In,\n    //     uint amount0Out,\n    //     uint amount1Out,\n    //     address indexed to\n    // );\n    // event Sync(uint112 reserve0, uint112 reserve1);\n\n    // function MINIMUM_LIQUIDITY() external pure returns (uint);\n    // function factory() external view returns (address);\n    // function token0() external view returns (address);\n    // function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    // function price0CumulativeLast() external view returns (uint);\n    // function price1CumulativeLast() external view returns (uint);\n    // function kLast() external view returns (uint);\n\n    // function mint(address to) external returns (uint liquidity);\n    // function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    // function skim(address to) external;\n    // function sync() external;\n\n    // function initialize(address, address) external;\n}"},"interfaces/IWETH.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    // function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"},"interfaces/TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    // function safeApprove(\n    //     address token,\n    //     address to,\n    //     uint256 value\n    // ) internal {\n    //     // bytes4(keccak256(bytes('approve(address,uint256)')));\n    //     (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n    //     require(\n    //         success && (data.length == 0 || abi.decode(data, (bool))),\n    //         'TransferHelper::safeApprove: approve failed'\n    //     );\n    // }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    // function safeTransferFrom(\n    //     address token,\n    //     address from,\n    //     address to,\n    //     uint256 value\n    // ) internal {\n    //     // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    //     (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n    //     require(\n    //         success && (data.length == 0 || abi.decode(data, (bool))),\n    //         'TransferHelper::transferFrom: transferFrom failed'\n    //     );\n    // }\n\n    // function safeTransferETH(address to, uint256 value) internal {\n    //     (bool success, ) = to.call{value: value}(new bytes(0));\n    //     require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    // }\n}"}}}