{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "VotesOrBalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n\ninterface ICompLikeToken {\n    function getCurrentVotes(address) external view returns (uint256);\n    function delegates(address) external view returns (address);\n    function balanceOf(address) external view returns (uint256);\n}\n\n\ncontract CompLikeVotesOrBalance {\n    function getVotesOrBalance(ICompLikeToken token, address account) public view returns (uint256) {\n        address delegate = token.delegates(account);\n        uint256 votes = token.getCurrentVotes(account);\n        if (delegate == address(0) && votes == 0) return token.balanceOf(account);\n        return votes;\n    }\n    \n    function getMultipleVotesOrBalances(ICompLikeToken token, address[] calldata accounts) external view returns (uint256[] memory scores) {\n        uint256 len = accounts.length;\n        scores = new uint256[](len);\n        for (uint256 i; i < len; i++) scores[i] = getVotesOrBalance(token, accounts[i]);\n    }\n}"
    }
  }
}