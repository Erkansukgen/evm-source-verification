{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/wonderful_3day.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n\n        return c;\n    }\n}\n\ncontract wonderful_3day {\n    using SafeMath for uint256;\n    address public manager;\n    address public bidAddress;\n    address payable public feeAddress;\n    uint256 public fee = 10; // default 10\n    uint256 public day = 3 days;\n    uint256 public rechargeTime;\n    uint256 public minAmount = 0.1 ether;\n    uint256 public percentage = 900;\n    uint256 public totalUsers;\n    bool public ISEND;\n    \n    struct RechargeInfo{\n        address rec_addr;\n        uint256 rec_value;\n        uint256 rec_time;\n    }\n    RechargeInfo[] public rechargeAddress;\n    struct UserInfo {\n\t\taddress   referrer;   \n        address[] directPush; \n        uint256 amountWithdrawn;\n        uint256 depositTime;\n    }\n    mapping(address => UserInfo) public user;\n    mapping(address => uint256) public balance;\n    mapping(address => mapping(address => bool)) public userDireMap;\n    \n    constructor(address bid)public{\n        manager = msg.sender;\n        bidAddress = bid;\n    }\n\n    function deposit(address referrer) payable public {\n        require(msg.value > 0 && isTime() == false && msg.value >= minAmount);\n        uint256 fees = msg.value.div(fee);\n        if(address(this).balance >= fees){\n            feeAddress.transfer(fees);\n        }\n        UserInfo storage u = user[msg.sender];\n\t\tif (u.referrer == address(0)) {\n\t\t    if (referrer != msg.sender){\n\t\t        u.referrer = referrer;\n\t\t    }else{\n\t\t        u.referrer = bidAddress;\n\t\t    }\n\t\t    if (userDireMap[u.referrer][msg.sender] == false){\n                user[u.referrer].directPush.push(msg.sender);\n                userDireMap[u.referrer][msg.sender] = true;\n            }\n\t\t}\n\t\t\n\t\tif (balance[msg.sender] == 0){\n\t\t    totalUsers = totalUsers.add(1);\n\t\t    u.depositTime = now;\n\t\t}\n\t\t\n\t\tbalance[msg.sender] = balance[msg.sender].add(msg.value);\n\t\trechargeAddress.push(RechargeInfo({rec_addr:msg.sender,rec_value:msg.value,rec_time:block.timestamp}));\n\t\trechargeTime = block.timestamp;\n    }\n\n    function withdraw(uint256 value) public {\n        require(value > 0);\n        uint256 count = getIncome(msg.sender);\n        require(count >= value,\"Not enough quota\");\n        msg.sender.transfer(value);\n        user[msg.sender].amountWithdrawn = user[msg.sender].amountWithdrawn.add(value);\n    }\n    \n    function getPoolETH() view public returns(uint256){\n        return address(this).balance;\n    }\n    \n    function getRecTotal() view public returns(uint256){\n        return rechargeAddress.length;\n    }\n    \n    function getRec10() view public returns(RechargeInfo[] memory){\n        uint256 l = rechargeAddress.length;\n        uint256 a = 0;\n        uint256 i = 0;\n        if (rechargeAddress.length>10){\n            l = 10;\n            a = rechargeAddress.length.sub(10);\n        }\n        RechargeInfo[] memory data = new RechargeInfo[](l);\n        for (;a < rechargeAddress.length; a++){\n            data[i] = rechargeAddress[a];\n            i = i+1;\n        }\n        return data;\n    }\n    \n    function distribution72() public {\n        if (isTime() == true && ISEND == false){\n            uint256 a = 0;\n            if (rechargeAddress.length>10){\n                a = rechargeAddress.length.sub(10);\n            }\n            uint256 total = (address(this).balance.mul(percentage)).div(uint256(1000));\n            for (;a < rechargeAddress.length; a++){\n                payable(rechargeAddress[a].rec_addr).transfer(total.div(10));\n            }\n            ISEND = true;\n        }\n    }\n    \n    function isTime()view public returns(bool) {\n        if ((block.timestamp.sub(rechargeTime)) >= day && rechargeTime != 0){\n            return true;\n        }\n        return false;\n    }\n    \n    function directPushMultiple(address addr) view public isAddress(addr) returns(uint256) {\n        if(balance[addr] == 0){\n            return 0;\n        }\n        return ((getDirectTotal(addr).add(getInterest(addr))).add(getInterest(addr))).div(balance[addr]);\n    }\n    \n    // 最大收益：(推广总量 + 当前利息) - 提出总量\n    function getMaxIncome(address addr) view public isAddress(addr) returns(uint256){\n        return (getDirectTotal(addr).add(getInterest(addr))).sub(user[addr].amountWithdrawn);\n    }\n    \n    // 当前收益：直推总量 / 投入本金 是否大于等于3，小于3 当前收益为0 大于3  ：本金*3 - 已提取数\n    function getIncome(address addr) view public isAddress(addr) returns(uint256){\n        uint256 multiple = directPushMultiple(addr);\n        if (multiple < 3){\n            return 0;\n        }\n        return (balance[addr].mul(3).sub(user[addr].amountWithdrawn));\n    }\n\n    function additionalThrow(address addr) view public isAddress(addr) returns(uint256){\n        uint256 multiple = directPushMultiple(addr);\n        if (multiple < 3){\n            return 0;\n        }\n        return ((getDirectTotal(addr).add(getInterest(addr))).sub(user[addr].amountWithdrawn).sub(getIncome(addr))).div(3);\n    }\n    \n    function numberWithdrawn(address addr) view public isAddress(addr) returns(uint256) {\n        return user[addr].amountWithdrawn;\n    }\n\n    function getDirectTotal(address addr) view public isAddress(addr) returns(uint256) {\n        UserInfo memory u = user[addr];\n        if (u.directPush.length == 0){return (0);}\n        uint256 total;\n        for (uint256 i= 0; i<u.directPush.length;i++){\n            total = total.add(balance[u.directPush[i]]).add(getDirectTotal2(u.directPush[i]));\n        }\n        return (total);\n    }\n    \n    function getDirectTotal2(address addr) view public isAddress(addr) returns(uint256) {\n        UserInfo memory u = user[addr];\n        if (u.directPush.length == 0){return (0);}\n        uint256 total;\n        for (uint256 i= 0; i<u.directPush.length;i++){\n            total += balance[u.directPush[i]];\n        }\n        return (total);\n    }\n    \n    function getIndirectTotal(address addr) view public isAddress(addr) returns(uint256){\n        return getDirectTotal(addr).sub(getDirectTotal2(addr));\n    }\n    \n    function getDirectLength(address addr) view public isAddress(addr) returns(uint256){\n        return user[addr].directPush.length;\n    }\n    \n    function getInterest(address addr)view public returns(uint256){\n        // 取当前本金0.3%\n        uint256 inter = balance[addr].mul(3).div(1000);\n        uint256 d = (now.sub(user[addr].depositTime)).div(1 days);\n        return inter.mul(d);\n    }\n    \n    function ownerWitETH() public onlyOwner{\n        require(ISEND == true);\n        msg.sender.transfer(getPoolETH());\n    }\n    \n    function ownerTransfer(address newOwner) public onlyOwner isAddress(newOwner) {\n        manager = newOwner;\n    }\n    \n    function ownerSetFeeAddress(address payable feeAddr) public onlyOwner isAddress(feeAddr) {\n        feeAddress = feeAddr;\n    }\n    \n    function ownerSetFee(uint256 value) public onlyOwner{\n        require(value > 0);\n        fee = value;\n    }\n    \n    function ownerSetMinAmount(uint256 min) public onlyOwner{\n        require(min >= 0);\n        minAmount = min;\n    }\n    \n    modifier isAddress(address addr) {\n        require(addr != address(0));\n        _;\n    }\n    \n    modifier onlyOwner {\n        require(manager == msg.sender);\n        _;\n    }\n\n}\n\n"
    }
  }
}