{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/tokenLotto/contracts/lottery.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.7.5;\r\n\r\nimport \"../lib/SafeMath.sol\" ;\r\n \r\nstruct Ticket{\r\n    uint id;\r\n    address payable owner;\r\n}\r\n\r\nstruct RunConditionsSet{\r\n    uint timeCondition;  //numero de horas entre os os sorteios de uma mesma categoria\r\n    uint ticketsCondition; //numero minimo de tickets\r\n    uint amountCondition;  //valor minimo que precisa ter acumulado na respectiva categoria para se fazer o sorteio\r\n    }\r\n\r\n\r\nenum CategoryName {Fast,Daily, Lucky, Brutal}\r\n\r\nstruct RaffleCategory {\r\n    CategoryName name;\r\n    RunConditionsSet conditionsSet;\r\n    uint percentual;\r\n}\r\n\r\nstruct RafflesHistory{\r\n    RaffleCategory category;\r\n    uint prizeValue;\r\n    uint inicialTIcket;\r\n    uint finalTicket;\r\n    address payable winner;\r\n}\r\n\r\nstruct Counter {\r\n    uint inicialTicket;\r\n    uint finalTicket; \r\n    uint accumulatedValue;\r\n    uint startingTime;\r\n}\r\n\r\n\r\ncontract Lottery{\r\n    using SafeMath for uint256;\r\n    \r\n    uint  public totalReceived; \r\n    uint  public totalPrizesPaid;\r\n     \r\n    address payable   public owner;\r\n    uint   public  rafflesCategory;\r\n    \r\n    mapping (uint  => address  payable) public allTickets;\r\n    mapping  (CategoryName => RaffleCategory) raffles;\r\n    \r\n    RafflesHistory[] history;\r\n    \r\n    //rastrea as condicoes atuais\r\n    mapping (CategoryName  => Counter) public counter;\r\n\r\n    event ticketsBought(uint numTickets_);\r\n    modifier onlyOwner  {\r\n        require( msg.sender==owner, \"Back off cheater!\");\r\n        _;\r\n    }       \r\n    //Testes-->\r\n        uint public cttBalance;\r\n    // <-- testes\r\n    \r\n    uint   public  tickectPrice ; // =  ether; \r\n    uint   public  ticketsCounter;\r\n    \r\n    RaffleCategory fastlotto;     //fastLotto (1 hr, 2eth, 10 tickets)\r\n    RunConditionsSet fastlottoConditionsSet; \r\n    \r\n    RaffleCategory dailyLotto; //dailylotto (24 hr, 10eth, 20 tickets)\r\n    RunConditionsSet  dailyLottoConditionsSet; //\r\n    \r\n    \r\n    RaffleCategory luckyLotto; //luckylotto (168 hr, 30eth, 20 tickets)\r\n    RunConditionsSet  luckyLottoConditionsSet; //    \r\n    \r\n    RaffleCategory brutalLotto; //brutalLotto (168 hr, 30eth, 20 tickets)\r\n    RunConditionsSet  brutalLottoConditionsSet; //\r\n\r\n    constructor () public {\r\n        totalReceived = 0;  \r\n        owner = msg.sender;\r\n        tickectPrice = 8400000000000000; // \r\n        rafflesCategory =0;\r\n        ticketsCounter =0;\r\n        \r\n        //fastLotto\r\n        addRaffle(CategoryName.Fast,1,10,85000000000000000,5);\r\n        \r\n        //dailyLotto\r\n        addRaffle(CategoryName.Daily,24,10,3390000000000000000,15);\r\n        \r\n        //LuckyLotto\r\n        addRaffle(CategoryName.Lucky,168,10,101707005000000000000,50);\r\n        \r\n        //LuckyLotto\r\n        addRaffle(CategoryName.Lucky,1,100000,2500000000000000000000,20);\r\n        \r\n        //coloca-las para rodar\r\n        for(uint8 i=0; i< 4; i++){\r\n            counter[CategoryName(i)].inicialTicket = 0;\r\n            counter[CategoryName(i)].finalTicket = 0;\r\n            counter[CategoryName(i)].accumulatedValue =0 ;\r\n            counter[CategoryName(i)].startingTime = block.timestamp;\r\n        }        \r\n        \r\n        //colocar um loop de monitoramento\r\n        \r\n    }\r\n\r\n    //Permite o app externo saber o valor do ticket\r\n    function getTicketPrice() public view returns (uint){\r\n        return tickectPrice;\r\n    }\r\n    \r\n    function evaluate() private returns (bool){\r\n        for(uint8 i=0; i< 4; i++){\r\n            for(uint j=0; j<4; j++){\r\n                RaffleCategory memory aux = raffles[CategoryName(i)];\r\n                if( aux.name == CategoryName(j) ){\r\n                    if( aux.conditionsSet.timeCondition <= block.timestamp.sub(counter[CategoryName(i)].startingTime)  &&\r\n                        aux.conditionsSet.ticketsCondition <= counter[CategoryName(i)].finalTicket.sub(counter[CategoryName(i)].inicialTicket) &&\r\n                        aux.conditionsSet.amountCondition <= counter[CategoryName(i)].accumulatedValue){\r\n                        executeDraw(CategoryName(i));\r\n                        return true;\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n        }  \r\n        return false;\r\n    }\r\n    \r\n    function criaTicket(address payable _buyer) private {\r\n        \r\n        allTickets[ticketsCounter] = _buyer ;\r\n        setCounter(ticketsCounter++);\r\n    } \r\n    uint public value;\r\n    function setCounter(uint _ticket) private {\r\n                \r\n        //Adiciona o ticket às loterias que estão em andamento\r\n        for(uint i=0; i< 4; i++){\r\n            CategoryName aux_ = CategoryName(i); \r\n            counter[aux_].finalTicket = _ticket;\r\n            \r\n             /*Teste*/ value = tickectPrice.mul(raffles[aux_].percentual).div(100);\r\n             counter[aux_].accumulatedValue = counter[aux_].accumulatedValue.add(value);    //\r\n        }\r\n    }\r\n    \r\n    function rateio(uint _value, uint _percentual) internal returns (uint){\r\n        return  _value.mul(_percentual).div(100);\r\n    }\r\n    \r\n        //receber o pagamento do ticket\r\n    receive() external payable {\r\n        //verifica valor\r\n        require(msg.value >=tickectPrice, \"Please send 0.0084Eth or respective multiples. Ex.: 0.0084eth for 1 ticket. 0.0168eth for 2 tickets and so on! ;-)\" );\r\n        uint amount_ = msg.value;\r\n        \r\n        //calcula quantos tickets devem ser gerados e os gera\r\n        uint numTickets_ =1;\r\n        if(amount_ > tickectPrice){\r\n            numTickets_ = amount_.div(tickectPrice);\r\n        } \r\n        uint admnFee = amount_.mul(10).div(100).add(amount_.mod(numTickets_));\r\n        owner.transfer(admnFee);        \r\n        for(uint i=0; i < numTickets_; i++){\r\n            criaTicket(msg.sender);  \r\n        }\r\n        \r\n        emit ticketsBought(numTickets_);\r\n        \r\n        evaluate();\r\n    }\r\n\r\n   \r\n    function addRaffle(\r\n        CategoryName _categoryName, \r\n        uint _timeCondition, \r\n        uint _ticketsCondition, \r\n        uint _amountCondition,\r\n        uint _percentual \r\n        ) private\r\n    {\r\n        require(rafflesCategory <=4, \"Categories overflow! Your code is broken budy!\");\r\n        RunConditionsSet memory conditions = RunConditionsSet( _timeCondition, _ticketsCondition, _amountCondition );\r\n        RaffleCategory memory aux = RaffleCategory (CategoryName(_categoryName),conditions,_percentual);\r\n        raffles[CategoryName(rafflesCategory++)] = aux;\r\n    } \r\n    \r\n    function randomize(uint _i, uint _j) private  returns (uint){\r\n        require(_j>_i,\"Something didn't go smooth when trying to execute the draw...\");\r\n        return _i ; ///////////////////////////////////////////////////////////////////////add an oracle to Randomize it\r\n    }\r\n    function executeDraw(CategoryName _categoryName) public{\r\n        \r\n        //sorteia\r\n        uint winner_ = randomize(counter[_categoryName].inicialTicket,counter[_categoryName].finalTicket);\r\n        payWinner(winner_, _categoryName); //paga ao ganhador\r\n        \r\n        //salva no hishistórico de sorteios\r\n        history.push(RafflesHistory(\r\n                raffles[_categoryName],\r\n                counter[_categoryName].accumulatedValue,\r\n                counter[_categoryName].inicialTicket,\r\n                counter[_categoryName].finalTicket,\r\n                allTickets[winner_]));       \r\n        \r\n        //atualiza o counter da categoria \r\n        counter[_categoryName].inicialTicket = counter[_categoryName].finalTicket.add(1);        \r\n        counter[_categoryName].finalTicket =  counter[_categoryName].inicialTicket;\r\n        counter[_categoryName].accumulatedValue = 0;\r\n\r\n    }\r\n    \r\n    function payWinner( uint _winnerTicket,CategoryName _categoryName) private {\r\n        address payable winner_ = allTickets[ _winnerTicket];\r\n        uint prizeValue = counter[_categoryName].accumulatedValue;\r\n        winner_.transfer(prizeValue);\r\n    }\r\n    \r\n}"},"browser/tokenLotto/lib/SafeMath.sol":{"content":"pragma solidity ^0.7.5;\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}"}}}