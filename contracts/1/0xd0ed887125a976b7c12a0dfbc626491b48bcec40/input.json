{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/EtherizerV1.sol": {
      "content": "pragma solidity 0.6.7; // optimization runs: 200, evm version: istanbul\n\n\ninterface ERC1271Interface {\n  function isValidSignature(\n    bytes calldata data, bytes calldata signatures\n  ) external view returns (bytes4 magicValue);\n}\n\n\ninterface EtherizedInterface {\n  function triggerCall(\n    address target, uint256 value, bytes calldata data\n  ) external returns (bool success, bytes memory returnData);\n}\n\n\ninterface EtherizerV1Interface {\n  event TriggeredCall(\n    address indexed from,\n    address indexed to,\n    uint256 value,\n    bytes data,\n    bytes returnData\n  );\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  function triggerCallFrom(\n    EtherizedInterface from,\n    address payable to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success, bytes memory returnData);\n  function approve(\n    address spender, uint256 value\n  ) external returns (bool success);\n  function increaseAllowance(\n    address spender, uint256 addedValue\n  ) external returns (bool success);\n  function decreaseAllowance(\n    address spender, uint256 subtractedValue\n  ) external returns (bool success);\n  function modifyAllowanceViaMetaTransaction(\n    address owner,\n    address spender,\n    uint256 value,\n    bool increase,\n    uint256 expiration,\n    bytes32 salt,\n    bytes calldata signatures\n  ) external returns (bool success);\n  function cancelAllowanceModificationMetaTransaction(\n    address owner,\n    address spender,\n    uint256 value,\n    bool increase,\n    uint256 expiration,\n    bytes32 salt\n  ) external returns (bool success);\n\n  function getMetaTransactionMessageHash(\n    bytes4 functionSelector,\n    bytes calldata arguments,\n    uint256 expiration,\n    bytes32 salt\n  ) external view returns (bytes32 digest, bool valid);\n  function balanceOf(address account) external view returns (uint256 amount);\n  function allowance(\n    address owner, address spender\n  ) external view returns (uint256 amount);\n}\n\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n}\n\n\n/**\n * @title EtherizerV1\n * @author 0age\n * @notice Etherizer is a contract for enabling \"approvals\" for performing Ether\n * transfers from compliant accounts via either standard ERC20 methods or\n * meta-transactions. A \"compliant\" account must be a smart contract that\n * implements a `triggerCall` function that is only callable by this contract as\n * well as the `isValidSignature` function specified by ERC-1271 for enabling\n * meta-transaction functionality. Be warned that any approved spender can\n * initiate arbitrary calls from the owner's account, including ERC20 token\n * transfers, so be extremely cautious when granting approval to spenders.\n */\ncontract EtherizerV1 is EtherizerV1Interface {\n  using SafeMath for uint256;\n\n  // Maintain a mapping of Ether allowances.\n  mapping (address => mapping (address => uint256)) private _allowances;\n\n  // Maintain a mapping of invalid meta-transaction message hashes.\n  mapping (bytes32 => bool) private _invalidMetaTxHashes;\n\n  /**\n   * @notice Trigger a call from `owner` to `recipient` with `amount` Ether and\n   * `data` calldata as long as `msg.sender` has sufficient allowance.\n   * @param owner address The account to perform the call from.\n   * @param recipient address The account to call.\n   * @param amount uint256 The amount of Ether to transfer.\n   * @param data bytes The data to include with the call.\n   * @return success A boolean indicating whether the call was successful.\n   * @return returnData The data returned from the call, if any.\n   */\n  function triggerCallFrom(\n    EtherizedInterface owner,\n    address payable recipient,\n    uint256 amount,\n    bytes calldata data\n  ) external override returns (bool success, bytes memory returnData) {\n    // Get the current allowance granted by the owner to the caller.\n    uint256 callerAllowance = _allowances[address(owner)][msg.sender];\n\n    // Block attempts to trigger calls when no allowance has been set.\n    require(callerAllowance != 0, \"No allowance set for caller.\");\n\n    // Reduce the allowance if it is not set to full allowance.\n    if (callerAllowance != uint256(-1)) {\n      require(callerAllowance >= amount, \"Insufficient allowance.\");\n      _approve(\n          address(owner), msg.sender, callerAllowance - amount\n      ); // overflow safe (condition has already been checked).\n    }\n\n    // Trigger the call from the owner and revert if success is not returned.\n    (success, returnData) = owner.triggerCall(recipient, amount, data);\n    require(success, \"Triggered call did not return successfully.\");\n\n    // Emit an event with information regarding the triggered call.\n    emit TriggeredCall(address(owner), recipient, amount, data, returnData);\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `value` Ether on behalf of\n   * `msg.sender`.\n   * @param spender address The account to grant the allowance.\n   * @param value uint256 The size of the allowance to grant.\n   * @return success A boolean indicating whether the approval was successful.\n   */\n  function approve(\n    address spender, uint256 value\n  ) external override returns (bool success) {\n    _approve(msg.sender, spender, value);\n    success = true;\n  }\n\n  /**\n   * @notice Increase the current allowance of `spender` by `value` Ether.\n   * @param spender address The account to grant the additional allowance.\n   * @param addedValue uint256 The amount to increase the allowance by.\n   * @return success A boolean indicating whether the modification was\n   * successful.\n   */\n  function increaseAllowance(\n    address spender, uint256 addedValue\n  ) external override returns (bool success) {\n    _approve(\n      msg.sender, spender, _allowances[msg.sender][spender].add(addedValue)\n    );\n    success = true;\n  }\n\n  /**\n   * @notice Decrease the current allowance of `spender` by `value` Ether.\n   * @param spender address The account to decrease the allowance for.\n   * @param subtractedValue uint256 The amount to subtract from the allowance.\n   * @return success A boolean indicating whether the modification was\n   * successful.\n   */\n  function decreaseAllowance(\n    address spender, uint256 subtractedValue\n  ) external override returns (bool success) {\n    _approve(\n      msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue)\n    );\n    success = true;\n  }\n\n  /**\n   * @notice Modify the current allowance of `spender` for `owner` by `value`\n   * Ether, increasing it if `increase` is true, otherwise decreasing it, via a\n   * meta-transaction that expires at `expiration` (or does not expire if the\n   * value is zero) and uses `salt` as an additional input, validated using\n   * `signatures`.\n   * @param owner address The account granting the modified allowance.\n   * @param spender address The account to modify the allowance for.\n   * @param value uint256 The amount to modify the allowance by.\n   * @param increase bool A flag that indicates whether the allowance will be\n   * increased by the specified value (if true) or decreased by it (if false).\n   * @param expiration uint256 A timestamp indicating how long the modification\n   * meta-transaction is valid for - a value of zero will signify no expiration.\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\n   * to the hash digest used to validate the signatures.\n   * @param signatures bytes A signature, or collection of signatures, that the\n   * owner must provide in order to authorize the meta-transaction. If the\n   * account of the owner does not have any runtime code deployed to it, the\n   * signature will be verified using ecrecover; otherwise, it will be supplied\n   * to the owner along with the message digest and context via ERC-1271 for\n   * validation.\n   * @return success A boolean indicating whether the modification was\n   * successful.\n   */\n  function modifyAllowanceViaMetaTransaction(\n    address owner,\n    address spender,\n    uint256 value,\n    bool increase,\n    uint256 expiration,\n    bytes32 salt,\n    bytes calldata signatures\n  ) external override returns (bool success) {\n    require(expiration == 0 || now <= expiration, \"Meta-transaction expired.\");\n\n    // Construct the meta-transaction's \"context\" information and validate it.\n    bytes memory context = abi.encodePacked(\n      address(this),\n      this.modifyAllowanceViaMetaTransaction.selector,\n      expiration,\n      salt,\n      abi.encode(owner, spender, value, increase)\n    );\n    _validateMetaTransaction(owner, context, signatures);\n\n    // Calculate new allowance by applying modification to current allowance.\n    uint256 currentAllowance = _allowances[owner][spender];\n    uint256 newAllowance = (\n      increase ? currentAllowance.add(value) : currentAllowance.sub(value)\n    );\n\n    // Modify the allowance.\n    _approve(owner, spender, newAllowance);\n    success = true;\n  }\n\n  /**\n   * @notice Cancel a specific meta-transaction for modifying an allowance. The\n   * designated owner or spender can both cancel the given meta-transaction.\n   * @param owner address The account granting the modified allowance.\n   * @param spender address The account to modify the allowance for.\n   * @param value uint256 The amount to modify the allowance by.\n   * @param increase bool A flag that indicates whether the allowance will be\n   * increased by the specified value (if true) or decreased by it (if false).\n   * @param expiration uint256 A timestamp indicating how long the modification\n   * meta-transaction is valid for - a value of zero will signify no expiration.\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\n   * to the hash digest used to validate the signatures.\n   * @return success A boolean indicating whether the cancellation was\n   * successful.\n   */\n  function cancelAllowanceModificationMetaTransaction(\n    address owner,\n    address spender,\n    uint256 value,\n    bool increase,\n    uint256 expiration,\n    bytes32 salt\n  ) external override returns (bool success) {\n    require(expiration == 0 || now <= expiration, \"Meta-transaction expired.\");\n    require(\n      msg.sender == owner || msg.sender == spender,\n      \"Only owner or spender may cancel a given meta-transaction.\"\n    );\n\n    // Construct the meta-transaction's \"context\" information.\n    bytes memory context = abi.encodePacked(\n      address(this),\n      this.modifyAllowanceViaMetaTransaction.selector,\n      expiration,\n      salt,\n      abi.encode(owner, spender, value, increase)\n    );\n\n    // Construct the message hash using the provided context.\n    bytes32 messageHash = keccak256(context);\n\n    // Ensure message hash has not been used or cancelled and invalidate it.\n    require(\n      !_invalidMetaTxHashes[messageHash], \"Meta-transaction already invalid.\"\n    );\n    _invalidMetaTxHashes[messageHash] = true;\n\n    success = true;\n  }\n\n  /**\n   * @notice View function to determine a meta-transaction message hash, and to\n   * determine if it is still valid (i.e. it has not yet been used and is not\n   * expired). The returned message hash will need to be prefixed using EIP-191\n   * 0x45 and hashed again in order to generate a final digest for the required\n   * signature - in other words, the same procedure utilized by `eth_Sign`.\n   * @param functionSelector bytes4 The function selector for the given\n   * meta-transaction. There is only one function selector available for V1:\n   * `0x2d657fa5` (the selector for `modifyAllowanceViaMetaTransaction`).\n   * @param arguments bytes The abi-encoded function arguments (aside from the\n   * `expiration`, `salt`, and `signatures` arguments) that should be supplied\n   * to the given function.\n   * @param expiration uint256 A timestamp indicating how long the given\n   * meta-transaction is valid for - a value of zero will signify no expiration.\n   * @param salt bytes32 An arbitrary salt to be provided as an additional input\n   * to the hash digest used to validate the signatures.\n   * @return messageHash The message hash corresponding to the meta-transaction.\n   */\n  function getMetaTransactionMessageHash(\n    bytes4 functionSelector,\n    bytes calldata arguments,\n    uint256 expiration,\n    bytes32 salt\n  ) external view override returns (bytes32 messageHash, bool valid) {\n    // Construct the meta-transaction's message hash based on relevant context.\n    messageHash = keccak256(\n      abi.encodePacked(\n        address(this), functionSelector, expiration, salt, arguments\n      )\n    );\n\n    // The meta-transaction is valid if it has not been used and is not expired.\n    valid = (\n      !_invalidMetaTxHashes[messageHash] && (\n        expiration == 0 || now <= expiration\n      )\n    );\n  }\n\n  /**\n   * @notice View function to get the total Ether balance of an account.\n   * @param account address The account to check the Ether balance for.\n   * @return amount The Ether balance of the given account.\n   */\n  function balanceOf(\n    address account\n  ) external view override returns (uint256 amount) {\n    amount = account.balance;\n  }\n\n  /**\n   * @notice View function to get the total allowance that `spender` has to\n   * transfer Ether from the `owner` account using `triggerCallFrom`.\n   * @param owner address The account that is granting the allowance.\n   * @param spender address The account that has been granted the allowance.\n   * @return etherAllowance The allowance of the given spender for the given\n   * owner.\n   */\n  function allowance(\n    address owner, address spender\n  ) external view override returns (uint256 etherAllowance) {\n    etherAllowance = _allowances[owner][spender];\n  }\n\n  /**\n   * @notice Private function to set the allowance for `spender` to transfer up\n   * to `value` tokens on behalf of `owner`.\n   * @param owner address The account that has granted the allowance.\n   * @param spender address The account to grant the allowance.\n   * @param value uint256 The size of the allowance to grant.\n   */\n  function _approve(address owner, address spender, uint256 value) private {\n    require(owner != address(0), \"ERC20: approve for the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  /**\n   * @notice Private function to enforce that a given Meta-transaction has not\n   * been used before and that the signature is valid according to the owner\n   * (determined using ERC-1271).\n   * @param owner address The account originating the meta-transaction.\n   * @param context bytes Information about the meta-transaction.\n   * @param signatures bytes Signature or signatures used to validate\n   * the meta-transaction.\n   */\n  function _validateMetaTransaction(\n    address owner, bytes memory context, bytes memory signatures\n  ) private {\n    // Construct the message hash using the provided context.\n    bytes32 messageHash = keccak256(context);\n\n    // Ensure message hash has not been used or cancelled and invalidate it.\n    require(\n      !_invalidMetaTxHashes[messageHash], \"Meta-transaction no longer valid.\"\n    );\n    _invalidMetaTxHashes[messageHash] = true;\n\n    // Construct the digest to compare signatures against using EIP-191 0x45.\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    // Validate via ERC-1271 against the owner account.\n    bytes memory data = abi.encode(digest, context);\n    bytes4 magic = ERC1271Interface(owner).isValidSignature(data, signatures);\n    require(magic == bytes4(0x20c13b0b), \"Invalid signatures.\");\n  }\n}"
    }
  }
}