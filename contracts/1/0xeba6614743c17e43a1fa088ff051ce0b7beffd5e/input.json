{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"tokengenerator.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this;\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract SuperTokenGenerator is Ownable {\n    mapping (bytes32 => uint256) private _prices;\n    event Created(string serviceName, address indexed serviceAddress);\n    function pay(string memory serviceName) public payable {\n        require(msg.value == _prices[_toBytes32(serviceName)], \"Error: Incorrect Price\");\n        emit Created(serviceName, _msgSender());\n    }\n    function getPrice(string memory serviceName) public view returns (uint256) {\n        return _prices[_toBytes32(serviceName)];\n    }\n    function setPrice(string memory serviceName, uint256 amount) public onlyOwner {\n        _prices[_toBytes32(serviceName)] = amount;\n    }\n    function withdraw(uint256 amount) public onlyOwner {\n        payable(owner()).transfer(amount);\n    }\n    function _toBytes32(string memory serviceName) private pure returns (bytes32) {\n        return keccak256(abi.encode(serviceName));\n    }\n}"}}}