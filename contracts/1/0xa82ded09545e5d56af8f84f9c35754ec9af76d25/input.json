{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BabyNami..sol":{"content":"/*\nMetaNami is a mooner\nThis will moon\n\nhttps://t.me/BabyMetaNami\n*/\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal pure virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\n/**\n * SPDX-License-Identifier: MIT\n *\n * Copyright (c) 2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\ninterface IDexFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ninterface IDexRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n    external\n    payable\n    returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IDexRouter02 is IDexRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract BabyNami is Context, Ownable {\n    using Address for address;\n    \n    string private _name = \"Baby Nami\";\n    string private _symbol = \"BABYNAMI\";\n    uint8 private _decimals = 9;\n\n    mapping(address => uint256) private _rOwned;\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    address[] private _excluded;\n    mapping(address => bool) private _isExcludedFromRewards;\n\n    mapping(address => bool) private _taxWhitelist;\n    mapping(address => bool) private _liqProvWhitelist;\n\n    address public marketingWallet;\n    address public liquidityWallet;\n\n    uint256 private constant MAX = type(uint256).max;\n    uint256 private _tTotal = 100_000_000_000 * (10 ** _decimals);\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    address public burnAddress = 0x000000000000000000000000000000000000dEaD;\n    mapping (address => bool) public liquidityPools;\n    address public pair;\n    IDexRouter02 public router;\n\n    bool public swapAndLiquifyEnabled = true;\n    bool public inSwap = false;\n\n    uint256 public _taxFee = 10;\n    uint256 private _previousTaxFee = _taxFee;\n    uint256 public totalFeesToLP = 20;\n    uint256 public totalFeesToMarketing = 70;\n    uint256 public totalFeesToBurn = 0;\n    uint256 public _liquidityFee = 10;\n    uint256 private _previousLiquidityFee = _liquidityFee;\n    uint256 public sellBias = 10;\n    uint256 public previousSellBias = sellBias;\n\n    uint256 public minTokenNumberToSell = _tTotal / 10000;\n    \n    bool public liquidityLaunched = false;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n \n    modifier swapping() { inSwap = true; _; inSwap = false; }\n\n    constructor(address _marketing) {\n        _tOwned[msg.sender] = _tTotal;\n        _rOwned[msg.sender] = _rTotal;\n\n        address routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n        router = IDexRouter02(routerAddress);\n\n        pair = IDexFactory(router.factory()).createPair(\n            address(this),\n            router.WETH()\n        );\n        liquidityPools[pair] = true;\n\n        marketingWallet = _marketing;\n        liquidityWallet = msg.sender;\n\n        _taxWhitelist[msg.sender] = true;\n        _liqProvWhitelist[msg.sender] = true;\n        _taxWhitelist[_marketing] = true;\n        _taxWhitelist[address(this)] = true;\n        \n        _isExcludedFromRewards[address(this)] = true;\n        _excluded.push(address(this));\n        _isExcludedFromRewards[pair] = true;\n        _excluded.push(pair);\n        \n        _approve(address(this), routerAddress, _tTotal);\n        _approve(msg.sender, routerAddress, _tTotal);\n        \n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        if (_isExcludedFromRewards[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n    \n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcludedFromRewards[account];\n    }\n\n    function excludeFromReward(address account) public onlyOwner {\n        require(\n            !_isExcludedFromRewards[account],\n            \"Account is already excluded\"\n        );\n        if (_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcludedFromRewards[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeInReward(address account) public onlyOwner {\n        require(_isExcludedFromRewards[account], \"Account is not excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcludedFromRewards[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n\n    function allowance(address _owner, address spender)\n        public\n        view\n        returns (uint256)\n    {\n        return _allowances[_owner][spender];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()] - amount\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] - subtractedValue\n        );\n        return true;\n    }\n\n    function tokenFromReflection(uint256 rAmount)\n        public\n        view\n        returns (uint256)\n    {\n        require(rAmount <= _rTotal, \"Amount must < total reflections\");\n        uint256 currentRate = _getRate();\n        return rAmount / currentRate;\n    }\n\n    function setAccountWhitelisted(address account, bool whitelisted) public onlyOwner\n    {\n        _taxWhitelist[account] = whitelisted;\n    }\n\n    function setTaxFeePercent(uint256 taxFee) external onlyOwner {\n        \n        _taxFee = taxFee;\n        _previousTaxFee = _taxFee;\n    }\n\n    function setBNBFeePercent(uint256 totalBNBFee, uint256 _marketingFee, uint256 _lpFee, uint256 _burnFee, uint256 _sellbias) external onlyOwner {\n        _liquidityFee = totalBNBFee;\n        _previousLiquidityFee = _liquidityFee;\n        \n        totalFeesToLP = _lpFee;\n        totalFeesToMarketing = _marketingFee;\n        totalFeesToBurn = _burnFee;\n        \n        sellBias = _sellbias;\n        previousSellBias = sellBias;\n        \n        require(totalFeesToLP + totalFeesToMarketing + totalFeesToBurn <= _liquidityFee);\n    }\n    \n    function setAmountToSell(uint256 _divisor) external onlyOwner {\n        minTokenNumberToSell = _tTotal / _divisor;\n    }\n\n    function setMarketingWallet(address _newAddress) external onlyOwner {\n        marketingWallet = _newAddress;\n    }\n    \n    function setLiquidityWallet(address _newAddress) external onlyOwner {\n        liquidityWallet = _newAddress;\n    }\n\n    function setLiqidityProviderWhitelisted(address _address, bool _whitelisted) external onlyOwner {\n        _liqProvWhitelist[_address] = _whitelisted;\n        _taxWhitelist[_address] = _whitelisted; // tax whitelists LPs to avoid tax on initial LP\n        if (_whitelisted)\n            excludeFromReward(_address);\n        else\n            includeInReward(_address);\n    }\n\n    // view function for LP whitelist address values as set above\n    function getLPWhitelisted(address _account) external view returns (bool) {\n        return _liqProvWhitelist[_account];\n    }\n\n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n        swapAndLiquifyEnabled = _enabled;\n    }\n    \n    function addLiquidityPool(address lp, bool isPool) external onlyOwner {\n        liquidityPools[lp] = isPool;\n        excludeFromReward(lp);\n    }\n    \n    function updateRouter(address _market) external onlyOwner {\n        router = IDexRouter02(_market);\n    }\n\n    receive() external payable {}\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal - rFee;\n        _tFeeTotal = _tFeeTotal + tFee;\n    }\n\n    function _getValues(uint256 tAmount, bool selling)\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tLiquidity\n        ) = _getTValues(tAmount, selling);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n            tAmount,\n            tFee,\n            tLiquidity,\n            _getRate()\n        );\n        return (\n            rAmount,\n            rTransferAmount,\n            rFee,\n            tTransferAmount,\n            tFee,\n            tLiquidity\n        );\n    }\n\n    function _getTValues(uint256 tAmount, bool selling)\n        private\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 tFee = calculateTaxFee(tAmount, selling);\n        uint256 tLiquidity = calculateLiquidityFee(tAmount, selling);\n        uint256 tTransferAmount = tAmount - (tFee + tLiquidity);\n        return (tTransferAmount, tFee, tLiquidity);\n    }\n\n    function _getRValues(\n        uint256 tAmount,\n        uint256 tFee,\n        uint256 tLiquidity,\n        uint256 currentRate\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 rAmount = tAmount * currentRate;\n        uint256 rFee = tFee * currentRate;\n        uint256 rLiquidity = tLiquidity * currentRate;\n        uint256 rTransferAmount = rAmount - (rFee + rLiquidity);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() public view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply / tSupply;\n    }\n\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (\n                _rOwned[_excluded[i]] > rSupply ||\n                _tOwned[_excluded[i]] > tSupply\n            ) return (_rTotal, _tTotal);\n            rSupply -= _rOwned[_excluded[i]];\n            tSupply -= _tOwned[_excluded[i]];\n        }\n\n\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    function _takeLiquidity(uint256 tLiquidity) private {\n        uint256 currentRate = _getRate();\n        uint256 rLiquidity = tLiquidity * currentRate;\n        uint256 tBurn = (tLiquidity * totalFeesToBurn) / _liquidityFee;\n        uint256 rBurn = tBurn * currentRate;\n        tLiquidity -= tBurn;\n        rLiquidity -= rBurn;\n        _rOwned[address(this)] += rLiquidity;\n        if (_isExcludedFromRewards[address(this)])\n            _tOwned[address(this)] += tLiquidity;\n        \n        if (tBurn > 0) {\n            _rOwned[burnAddress] += rBurn;\n            if (_isExcludedFromRewards[burnAddress])\n                _tOwned[burnAddress] += tBurn;\n            \n            emit Transfer(address(this), burnAddress, tBurn);\n        }\n    }\n\n    function calculateTaxFee(uint256 _amount, bool selling) private view returns (uint256) {\n        if (!selling) return 0;\n        return (_amount * _taxFee) / 1000;\n    }\n\n    function calculateLiquidityFee(uint256 _amount, bool selling)\n        private\n        view\n        returns (uint256)\n    {\n        return (_amount * (selling ? _liquidityFee + sellBias : _liquidityFee - sellBias )) / 1000;\n    }\n\n    function removeAllFee() private {\n        if (_taxFee == 0 && _liquidityFee == 0) return;\n\n        _previousTaxFee = _taxFee;\n        _previousLiquidityFee = _liquidityFee;\n        previousSellBias = sellBias;\n\n        _taxFee = 0;\n        _liquidityFee = 0;\n        sellBias = 0;\n    }\n\n    function restoreAllFee() private {\n        _taxFee = _previousTaxFee;\n        _liquidityFee = _previousLiquidityFee;\n        sellBias = previousSellBias;\n    }\n\n    function isWhitelisted(address account) public view returns (bool) {\n        return _taxWhitelist[account];\n    }\n    \n    function _approve(\n        address _owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(_owner != address(0), \"BEP20: approve from zero address\");\n        require(spender != address(0), \"BEP20: approve to zero address\");\n\n        _allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"BEP20: transfer from 0x0\");\n        require(to != address(0), \"BEP20: transfer to 0x0\");\n        require(amount > 0, \"Amount must be > zero\");\n        \n        if (!liquidityLaunched) {\n            if (_liqProvWhitelist[from] && liquidityPools[to]) {\n                liquidityLaunched = true;\n            } else {\n                require(_liqProvWhitelist[from] || _liqProvWhitelist[to], \"Liquidity not launched yet\");\n            }\n        }\n        \n        if (shouldSwap(to)) swapAndLiquify();\n\n        bool takeFee = true;\n\n        if (_taxWhitelist[from] || _taxWhitelist[to]) {\n            takeFee = false;\n        }\n\n        _tokenTransfer(from, to, amount, takeFee);\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bool takeFee\n    ) private {\n        if (!takeFee) removeAllFee();\n\n        _transferStandard(sender, recipient, amount);\n\n        if (!takeFee) restoreAllFee();\n    }\n\n    function _transferStandard(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tLiquidity\n        ) = _getValues(tAmount, liquidityPools[recipient]);\n        _rOwned[sender] -= rAmount;\n        if (_isExcludedFromRewards[sender])\n            _tOwned[sender] -= tAmount;\n        if (_isExcludedFromRewards[recipient])\n            _tOwned[recipient] += tTransferAmount;\n        _rOwned[recipient] += rTransferAmount;\n        if(tLiquidity > 0)\n            _takeLiquidity(tLiquidity);\n        if(rFee > 0 || tFee > 0)\n            _reflectFee(rFee, tFee);\n        \n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n    \n    function shouldSwap(address to) internal view returns(bool) {\n        return \n            !inSwap &&\n            swapAndLiquifyEnabled &&\n            balanceOf(address(this)) >= minTokenNumberToSell &&\n            !liquidityPools[msg.sender] &&\n            liquidityPools[to] && \n            _liquidityFee > 0;\n    }\n\n    function swapAndLiquify() internal swapping {\n        uint256 swapFees = _liquidityFee - totalFeesToBurn;\n        uint256 tokensForLP = ((minTokenNumberToSell * totalFeesToLP) / swapFees) / 2;\n\n        swapTokensForEth(\n            minTokenNumberToSell - tokensForLP\n        );\n\n        uint256 toBeAddedToLiquidity = ((address(this).balance * totalFeesToLP) / (swapFees - totalFeesToLP / 2)) / 2;\n\n        if (toBeAddedToLiquidity > 0)\n            addLiquidity(liquidityWallet, tokensForLP, toBeAddedToLiquidity);\n\n        uint256 toBeAddedToMarketing = address(this).balance - toBeAddedToLiquidity;\n        \n        if (toBeAddedToMarketing > 0) {\n            payable(marketingWallet).transfer(toBeAddedToMarketing);\n        }\n    }\n\n    function swapTokensForEth(\n        uint256 tokenAmount\n    ) internal {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = router.WETH();\n\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function addLiquidity(\n        address owner,\n        uint256 tokenAmount,\n        uint256 ethAmount\n    ) internal {\n        router.addLiquidityETH{value : ethAmount}(\n            address(this),\n            tokenAmount,\n            0,\n            0,\n            owner,\n            block.timestamp + 360\n        );\n    }\n\t\n    function airdrop(address[] calldata _addresses, uint256[] calldata _amount) external onlyOwner\n    {\n        require(_addresses.length == _amount.length);\n        bool previousSwap = swapAndLiquifyEnabled;\n        swapAndLiquifyEnabled = false;\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            require(!liquidityPools[_addresses[i]]);\n            _transfer(msg.sender, _addresses[i], _amount[i] * (10 ** _decimals));\n        }\n        swapAndLiquifyEnabled = previousSwap;\n    }\n}"}}}