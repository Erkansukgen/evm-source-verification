{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/feiotherarb.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/v3pool.sol';\nimport './lib/SafeMath.sol';\n// import './lib/PoolAddress.sol';\n// import './lib/CusByteslib.sol';\n\n\ninterface IWETH {\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n}\n\n\n\ninterface v3quoter{\n  function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n}\n\n\ninterface v2pool{\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n\ninterface ethbondingcurve{\n    function purchase(address to, uint256 amountIn)\n        external\n        payable\n        returns (uint256 amountOut);\n        \n    function getAmountOut(uint256 amountIn)\n            external\n            view\n            returns (uint256 amountOut);\n}\n\n\n\n\ncontract feiotherarb {\n    using SafeMath for uint;\n\n    \n    address payable public owner;\n    \n    \n    // main net\n    \n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    \n    // address factory = address(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n    \n    \n    \n    v3quoter quoter = v3quoter(quoter_addr);\n\n    constructor() public {\n        owner = msg.sender;\n        IERC20(address(0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b)).approve(address(0xBf5721c5E1C370f6F1A3E21b3972E0AcE93A1E84), \n                    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        \n        IERC20(address(0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919)).approve(address(0x25d60212D47Dd8F6Ff0469367E4c6C98Cd3411A5), \n                    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);    \n                    \n        IERC20(address(0x6B175474E89094C44Da98b954EedeAC495271d0F)).approve(address(0xC0afe0E649e32528666F993ce63822c3840e941a), \n                    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);                        \n    \n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n    function withdrawethall() external onlyowner {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        \n        (uint256 raiout, uint256 flag, uint256 move_on) = abi.decode(_data, (uint256,uint256, uint256));\n        bytes memory data;\n\n        if(flag == 0){\n            // rai\n            if(move_on == 1){\n                // the next v3 swap to swap dai back to dai-rai pool, flash swap from dai-usdc pool\n                data = abi.encode(raiout, 0, 2);\n                v3pool(address(0x6c6Bc977E13Df9b0de53b251522280BB72383700)).swap(msg.sender, false, int256(-amount1Delta), \n                1461446703485210103287273052203988822378723970342 - 1, data);\n            }else if(move_on == 2){\n                // flash swap from fei-usdc pool to send usdc back to dai-usdc\n                data = abi.encode(raiout, 0, 0);\n                v3pool(address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26)).swap(msg.sender, true, int256(-amount1Delta), \n                4295128739 + 1, data);\n\n            }else{\n\n                // use rai to buy the fei and send back to fei-usdc\n                ethbondingcurve(address(0x25d60212D47Dd8F6Ff0469367E4c6C98Cd3411A5)).purchase(address(this), raiout); \n                \n                address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, amount0Delta));  \n            }\n        }else if(flag == 1){\n            \n            // dai\n            if(move_on == 1){\n                // flash swap from fei-usdc to transfer usdc back to the dai-usdc\n                data = abi.encode(raiout, 1, 0);\n                v3pool(address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26)).swap(msg.sender, true, int256(-amount1Delta), \n                4295128739 + 1, data);                \n              \n            }else{\n                // use dai to mint fei and send back to the fei-usdc pool\n                ethbondingcurve(address(0xC0afe0E649e32528666F993ce63822c3840e941a)).purchase(address(this), raiout); \n                \n                address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, amount0Delta));    \n                \n            }\n            \n        }else{\n            // rai 2\n            if(move_on == 1){\n                // flash swap fei-usdc pool to send back the usdc to usdc - rai\n                data = abi.encode(raiout, 2, 0);\n                v3pool(address(0x8c54aA2A32a779e6f6fBea568aD85a19E0109C26)).swap(msg.sender, true, int256(-amount1Delta), \n                4295128739 + 1, data);                     \n                \n            }else{\n                // use rai to mint the fei and send back to the fei-usdc pool\n                ethbondingcurve(address(0x25d60212D47Dd8F6Ff0469367E4c6C98Cd3411A5)).purchase(address(this), raiout); \n                address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, amount0Delta));                 \n                \n            }\n            \n            \n            \n        }\n        \n\n\n    }\n\n\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\n    \n        uint256 feiamount  = abi.decode(_data, (uint256));\n        \n        // dpi amount is amount0\n        uint256 amountout = ethbondingcurve(address(0xBf5721c5E1C370f6F1A3E21b3972E0AcE93A1E84)).purchase(address(this), _amount0);\n    \n        // transfer back fei\n        // IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).transfer(msg.sender, amountout);\n        address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, feiamount));\n    \n    }\n\n\n    function dpi_arb(uint256 dpiamount, uint256 feiamount) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            revert(\"7\");\n        }       \n        \n        bytes memory data = abi.encode(feiamount);\n        v2pool(address(0x8775aE5e83BC5D926b6277579c2B0d40c7D9b528)).swap(dpiamount, 0, address(this), data);\n        \n        feiamount = IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).balanceOf(address(this));\n\n        address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, feiamount));\n    }\n\n\n\n\n    function rai_arb(uint256 raiout, uint256 minout) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            revert(\"7\");\n        }         \n        \n        bytes memory data = abi.encode(raiout, 0, 1);\n        \n        // RAI-DAI pool\n        v3pool(address(0xcB0C5d9D92f4F2F80cce7aa271a1E148c226e19D)).swap(address(this), false, int256(-raiout), \n        1461446703485210103287273052203988822378723970342 - 1, data);\n        \n        // reuse raiout to store the amount of fei earned\n        raiout = IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).balanceOf(address(this));\n        require(raiout > minout, \"shit\");\n        address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, raiout));        \n        \n    }\n\n\n    function rai_arb_2(uint256 raiout, uint256 minout) public payable{\n        if(block.number > msg.value){\n            revert(\"7\");\n        }         \n\n        bytes memory data = abi.encode(raiout, 2, 1);\n        \n        // RAI-DAI pool\n        v3pool(address(0xFA7D7A0858a45C1b3b7238522A0C0d123900c118)).swap(address(this), false, int256(-raiout), \n        1461446703485210103287273052203988822378723970342 - 1, data);\n        \n        // reuse raiout to store the amount of fei earned\n        raiout = IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).balanceOf(address(this));\n        require(raiout > minout, \"shit\");\n        address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, raiout));       \n \n    }\n\n\n\n\n    function dai_arb(uint256 daiout, uint256 minout) public payable{\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            revert(\"7\");\n        }         \n        \n        bytes memory data = abi.encode(daiout, 1, 1);\n        \n        // DAI-USDC pool to flash swap DAI out\n        v3pool(address(0x6c6Bc977E13Df9b0de53b251522280BB72383700)).swap(address(this), false, int256(-daiout), \n        1461446703485210103287273052203988822378723970342 - 1, data);\n        \n        // reuse raiout to store the amount of fei earned\n        daiout = IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).balanceOf(address(this));\n        require(daiout >= minout, \"shit\");\n        address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, daiout));        \n        \n    }\n\n\n\n     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n          uint amountInWithFee = amountIn.mul(997);\n          uint numerator = amountInWithFee.mul(reserveOut);\n          uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n          amountOut = numerator / denominator;\n      } \n  \n\n\n    function v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\n    }\n\n    function dai_curve_best_out(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestprofit, uint256 best_dai_out){\n        uint256 curve_out;\n        uint256 amountin;\n        uint256 v3_usdc_out;\n        uint256 v3_dai_out;\n\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            curve_out = ethbondingcurve(address(0xC0afe0E649e32528666F993ce63822c3840e941a)).getAmountOut(amountin);\n            \n            v3_usdc_out = v3out(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA), address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), 500, curve_out);\n            v3_dai_out = v3out(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), address(0x6B175474E89094C44Da98b954EedeAC495271d0F), 500, v3_usdc_out);\n            \n            \n            if(v3_dai_out < amountin){\n                break;\n            }\n            \n            \n            if((v3_dai_out - amountin) > bestprofit){\n                bestprofit = v3_dai_out - amountin;\n                bestin = amountin;\n                best_dai_out = v3_dai_out;\n                lowerbound = lowerbound + step;\n            }else{\n                break;\n            }\n        }\n    }\n\n    \n\n    function rai_curve_best_out(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestprofit, uint256 bestraiout){\n        uint256 curve_out;\n        uint256 amountin;\n        uint256 v3_raiout;\n        uint256 v3_usdc_out;\n        uint256 v3_dai_out;\n\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            v3_raiout = v3out(address(0x6B175474E89094C44Da98b954EedeAC495271d0F), address(0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919), 500, amountin);\n            \n            // use rai to get fei out\n            curve_out = ethbondingcurve(address(0x25d60212D47Dd8F6Ff0469367E4c6C98Cd3411A5)).getAmountOut(v3_raiout);\n            \n            v3_usdc_out = v3out(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA), address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), 500, curve_out);\n            v3_dai_out = v3out(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), address(0x6B175474E89094C44Da98b954EedeAC495271d0F), 500, v3_usdc_out);\n            \n            if(v3_dai_out < amountin){\n                break;\n            }\n            \n            \n            if((v3_dai_out - amountin) > bestprofit){\n                bestprofit = v3_dai_out - amountin;\n                bestin = amountin;\n                lowerbound = lowerbound + step;\n                bestraiout = v3_raiout;\n            }else{\n                break;\n            }\n        }\n    }\n\n\n    function rai_curve_best_out_2(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestprofit, uint256 bestraiout){\n        uint256 curve_out;\n        uint256 amountin;\n        uint256 v3_raiout;\n        uint256 v3_usdc_out;\n\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            v3_raiout = v3out(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), address(0x03ab458634910AaD20eF5f1C8ee96F1D6ac54919), 500, amountin);\n            \n            // use rai to get fei out\n            curve_out = ethbondingcurve(address(0x25d60212D47Dd8F6Ff0469367E4c6C98Cd3411A5)).getAmountOut(v3_raiout);\n            \n            v3_usdc_out = v3out(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA), address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48), 500, curve_out);\n\n            \n            if(v3_usdc_out < amountin){\n                break;\n            }\n            \n            \n            if((v3_usdc_out - amountin) > bestprofit){\n                bestprofit = v3_usdc_out - amountin;\n                bestin = amountin;\n                lowerbound = lowerbound + step;\n                bestraiout = v3_raiout;\n            }else{\n                break;\n            }\n        }\n    }\n\n\n    function dpi_curve_best_out(uint256 lowerbound, uint256 higherbound , uint256 step) public returns(uint256 bestin, uint256 bestprofit, uint256 dpiout){\n        uint256 curve_out;\n        uint256 amountin;\n        uint256 v2_dpi_out;\n\n        // save some time to just use getreserve once\n        bytes memory returnData;\n        (, returnData) = address(0x8775aE5e83BC5D926b6277579c2B0d40c7D9b528).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n\n\n        while(lowerbound < higherbound){\n            amountin = lowerbound;\n            \n            v2_dpi_out = getAmountOut(amountin, reserve1, reserve0);\n            \n            // use rai to get fei out\n            curve_out = ethbondingcurve(address(0xBf5721c5E1C370f6F1A3E21b3972E0AcE93A1E84)).getAmountOut(v2_dpi_out);\n\n            if(curve_out < amountin){\n                break;\n            }\n            \n            \n            if((curve_out - amountin) > bestprofit){\n                bestprofit = curve_out - amountin;\n                bestin = amountin;\n                lowerbound = lowerbound + step;\n                dpiout = v2_dpi_out;\n            }else{\n                break;\n            }\n        }\n    }\n\n\n\n}"
    },
    "contracts/interfaces/v3pool.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    /*\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n    */\n\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n  \n}"
    }
  }
}