{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ESDBot.sol":{"content":"pragma solidity^0.7.4;\n\ninterface IClipper {\n    function redeem(address _user, uint256 _epoch, uint256 _couponAmount) external;\n    function getOffer(address _user) external view returns (uint256);\n    \n}\n\ninterface IESD {\n    function epoch() external view returns (uint256);\n    function epochTime() external view  returns (uint256);\n    function balanceOfCoupons(address account, uint256 _epoch) external view returns (uint256);\n    function advance() external;\n    function totalRedeemable() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address recipient) external view returns(uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\ncontract Ownable {\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == owner)\n      _;\n  }\n\n  function transferOwnership(address newOwner) onlyOwner public {\n    if (newOwner != address(0)) owner = newOwner;\n  }\n\n}\n\ncontract ESDBot is Ownable {\n    \n    IERC20 constant private ESD = IERC20(0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723);\n    IESD constant private ESDS = IESD(0x443D2f2755DB5942601fa062Cc248aAA153313D3);\n    IClipper constant private Clipper = IClipper(0xF176D56b9B5fB458AE9A223aCc5C3e35402deD12);\n    \n    modifier validRedeem(address toRedeem, uint256 epoch) {\n        if (isValidRedeem(toRedeem, epoch)) {\n            _;\n        }\n    }\n    \n    modifier checkLengths(address[] memory addresses, uint256[] memory epochs) {\n        require(addresses.length == epochs.length);\n        _;\n    }\n    \n    function isValidRedeem(address toRedeem, uint epoch) public view returns (bool) {\n        return ESD.allowance(toRedeem, address(Clipper)) >= ESDS.balanceOfCoupons(toRedeem, epoch);\n    }\n    \n    function getBotReward(address toRedeem, uint256 epoch) public view returns (uint256) {\n        if (!isValidRedeem(toRedeem, epoch)) {\n            return 0;\n        }\n        return ESDS.balanceOfCoupons(toRedeem, epoch) * Clipper.getOffer(toRedeem) / 10_000;\n    }\n\n    function getBotRewardByAmount(address toRedeem, uint256 amount) public view returns (uint256) {\n        return amount * Clipper.getOffer(toRedeem) / 10_000;\n    }\n    \n    function ownerWithdraw() public onlyOwner {\n        uint256 balance = getContractESDBalance();\n        ESD.transfer(owner, balance);\n    }\n    \n    function ownerWithdrawERC20(address token) public onlyOwner {\n        uint256 balance = getTokenBalance(token);\n        IERC20 erc20 = IERC20(token);\n        erc20.transfer(owner, balance);\n    }\n\n    function getContractESDBalance() public view returns(uint256) {\n        return ESD.balanceOf(address(this));\n    }\n    \n    function getTokenBalance(address token) public view returns(uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n    \n    function redeemAll(address[] memory addresses, uint256[] memory epochs, uint256 targetEpoch) public checkLengths(addresses, epochs) {\n        if (ESDS.epoch() < targetEpoch && ESDS.epochTime() == targetEpoch) {\n            ESDS.advance();\n        }\n        uint256 i = 0;\n        while (i < addresses.length && ESDS.totalRedeemable() > 0) {\n            redeemAddress(addresses[i], epochs[i]);\n            i++;\n        }\n    }\n    \n    function redeemAddress(address toRedeem, uint256 epoch) internal validRedeem(toRedeem, epoch) {\n        uint256 amount = getRedeemAmount(toRedeem, epoch);\n        if (amount > 0) {\n            Clipper.redeem(toRedeem, epoch, amount);\n        }\n    }\n    \n    function getRedeemAmount(address toRedeem, uint256 epoch) internal view returns (uint256) {\n        uint256 total = ESDS.totalRedeemable();\n        return getRedeemAmount(toRedeem, epoch, total);\n    }\n    \n    function getRedeemAmount(address toRedeem, uint256 epoch, uint256 total) internal view returns (uint256) {\n        uint256 redeemable = ESDS.balanceOfCoupons(toRedeem, epoch);\n        if (redeemable <= total) {\n            return redeemable;\n        }\n        return total;\n    }\n    \n    function getTotalBotReward(address[] memory addresses, uint256[] memory epochs, uint256 totalRedeemable) public view checkLengths(addresses, epochs) returns (uint256) {\n        uint256 totalReward = 0;\n        for (uint256 i = 0; i< addresses.length; i++) {\n            uint256 amount = getRedeemAmount(addresses[i], epochs[i], totalRedeemable);\n            totalReward += getBotRewardByAmount(addresses[i], amount);\n            totalRedeemable -= amount;\n        }\n        return totalReward;\n    }\n }"}}}