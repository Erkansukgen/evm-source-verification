{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/kernel_LP.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.8 < 0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n}\n\n/**\n * @dev Implement of the ERC20 standard Interface.\n * Use for make exchange with USD Coins.\n * Finally use for mint.\n */\ncontract AWorldLP is IERC20{\n \n    // --- ERC20 Data ---\n    string public name = \"AWorldLP\";\n    string public symbol = \"AWLP\";\n    string public version  = \"1.0\";\n    \n    uint8 public decimals = 4;\n    uint256 private _totalSupply;\n    \n    address public owner;\n    mapping (address => uint) private _balances;\n    mapping (address => mapping (address => uint)) private _allowances;\n    mapping (address => mapping(address=>uint256))  depositRecords;\n    mapping (address => bool) public availableTokenMapping; \n    mapping (address => bool) public frozenAccountMapping;\n    \n    event DepositToken(address indexed _from, address indexed _to, uint256 indexed _value);\n    event WithdrawToken(address indexed _from, address _contractAddress, uint256 indexed _value);\n    event FrozenAccount(address target, bool frozen);\n    event TransferGovernance(address _contractAddress, uint256 indexed _value);\n\n    constructor(uint256 totalSupplyValue) public {\n        owner = msg.sender;\n        _totalSupply = totalSupplyValue;\n        _balances[msg.sender] = totalSupplyValue;\n    }\n    \n    /**\n     * @dev Tools for check owner of contract.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /**\n     * @dev Modify owner of contract.\n     */\n    function transferOwnerShip(address _newOwer) public onlyOwner {\n        owner = _newOwer;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public override view returns (uint) {\n        return _totalSupply;\n    }\n    \n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address _account) public override view returns (uint) {\n        return _balances[_account];\n    }\n    \n    function balanceOfToken(address _account, address _contractAddress) public view returns (uint) {\n        return depositRecords[_account][_contractAddress];\n    }\n    \n    /**\n     * @dev Use for add available token for Exchange.\n     */\n    function enableToken(address _tokenAddress) public onlyOwner {\n        availableTokenMapping[_tokenAddress] = true;\n    }\n    \n    /**\n     * @dev Use for remove available token for Exchange.\n     */\n    function disableToken(address _tokenAddress) public onlyOwner {\n        availableTokenMapping[_tokenAddress] = false;\n    }\n    \n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    \n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    \n    function _mint(address account, uint _amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = add(_totalSupply, _amount);\n        _balances[account] = add(_balances[account], _amount);\n    }\n    \n    function _burn(address account, uint amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = sub(_balances[account], amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = sub(_totalSupply, amount);\n    }\n    \n    function _approve(address _from, address _spender, uint _amount) internal {\n        require(_from != address(0) && _spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[_from][_spender] = _amount;\n        emit Approval(_from, _spender, _amount);\n    }\n    \n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address _spender, uint _amount) public override virtual returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n    \n    function increaseAllowance(address _spender, uint _addedValue) public returns (bool) {\n        _approve(msg.sender, _spender, add(_allowances[msg.sender][_spender], _addedValue));\n        return true;\n    }\n    \n    function decreaseAllowance(address _spender, uint _subtractedValue) public returns (bool) {\n        _approve(msg.sender, _spender, sub(_allowances[msg.sender][_spender], _subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    \n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address _to, uint256 _amount)  public virtual override returns (bool success) {\n        _transfer(msg.sender, _to, _amount);\n\n        // Send Event.\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n    \n    function _transfer(address sender, address recipient, uint amount) internal {\n        require(frozenAccountMapping[sender] != true, \"Address is disabled\");\n        require(sender != address(0) && recipient != address(0), \"ERC20: transfer from the zero address\");\n        require(add(_balances[recipient], amount) >= _balances[recipient] && _balances[sender] >= amount);\n        \n        _balances[sender] = sub(_balances[sender], amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = add(_balances[recipient], amount);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public virtual override returns (bool success) {\n        require(_allowances[_from][_to] >= _value, \"ERC20: transfer amount exceeds allowance\");\n        \n        _transfer(_from, _to, _value);\n        _approve(_from, msg.sender, sub(_allowances[_from][msg.sender], _value, \"ERC20: transfer amount exceeds allowance\"));\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    \n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address _from, address spender) public override virtual view returns (uint) {\n        return _allowances[_from][spender];\n    }\n    \n    \n    /**\n     * @dev Exchange token with USDT/USDC/TUSD/DAI etc.\n     */\n    function depositToken(IERC20 _contractToken, uint256 _value, address _contractAddress) public returns (bool sucess) {\n        require(availableTokenMapping[_contractAddress] == true, \"Inavailable Token\");\n        bool result = _contractToken.transferFrom(msg.sender, address(this), _value);\n        // _e.callcode(bytes4(keccak256(\"setN(uint256)\")), _n);\n        if(result) {\n            depositRecords[msg.sender][_contractAddress] += _value;\n            _mint(msg.sender, _value);\n            \n            emit DepositToken(msg.sender, address(this), _value);\n            return true;\n        } else return false;\n    }\n    \n    /**\n     * @dev Withdraw token to USDT/USDC/TUSD/DAI etc.\n     */\n    function withdrawToken(IERC20 _contractToken, uint256 _value, address _contractAddress) public returns (bool sucess) {\n        require(_balances[msg.sender] >= _value && depositRecords[msg.sender][_contractAddress] >= _value);\n        require(frozenAccountMapping[msg.sender] != true, \"Address is disabled\");\n        \n        bool result = _contractToken.transfer(msg.sender, _value);\n        if(result) {\n            depositRecords[msg.sender][_contractAddress] -= _value;\n            _burn(msg.sender, _value);\n            \n            emit WithdrawToken(msg.sender, _contractAddress, _value);\n            return true;\n        } else return false;\n    }\n\n    /**\n     * @dev Use for transfer liquidity.\n     */\n    function transferGovernance(IERC20 _contractToken, uint256 _value, address _contractAddress) public onlyOwner returns (bool sucess) {\n        bool result = _contractToken.approve(_contractAddress, _value);\n        if(result) {\n            emit TransferGovernance(_contractAddress, _value);\n            return true;\n        } else return false;\n    }\n    \n    /**\n     * @dev Freeze specific account.\n     */\n    function freezeAccount(address target, bool freeze) public onlyOwner {\n        require(target != owner);\n        frozenAccountMapping[target] = freeze;\n        emit FrozenAccount(target, freeze);\n    }\n    \n}\n\n\n"}}}