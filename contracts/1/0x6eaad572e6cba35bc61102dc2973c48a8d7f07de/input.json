{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/DSA_READ/aave.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface AaveInterface {\n    function getUserReserveData(address _reserve, address _user) external view returns (\n        uint256 currentATokenBalance,\n        uint256 currentBorrowBalance,\n        uint256 principalBorrowBalance,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint256 liquidityRate,\n        uint256 originationFee,\n        uint256 variableBorrowIndex,\n        uint256 lastUpdateTimestamp,\n        bool usageAsCollateralEnabled\n    );\n\n    function getReserveConfigurationData(address _reserve)\n    external\n    view\n    returns (\n        uint256 ltv,\n        uint256 liquidationThreshold,\n        uint256 liquidationBonus,\n        address interestRateStrategyAddress,\n        bool usageAsCollateralEnabled,\n        bool borrowingEnabled,\n        bool stableBorrowRateEnabled,\n        bool isActive\n    );\n\n    function getUserAccountData(address _user) external view returns (\n        uint256 totalLiquidityETH,\n        uint256 totalCollateralETH,\n        uint256 totalBorrowsETH,\n        uint256 totalFeesETH,\n        uint256 availableBorrowsETH,\n        uint256 currentLiquidationThreshold,\n        uint256 ltv,\n        uint256 healthFactor\n    );\n}\n\ninterface AaveProviderInterface {\n    function getLendingPool() external view returns (address);\n    function getLendingPoolCore() external view returns (address);\n    function getPriceOracle() external view returns (address);\n}\n\ninterface AavePriceInterface {\n    function getAssetPrice(address _asset) external view returns (uint256);\n    function getAssetsPrices(address[] calldata _assets) external view returns(uint256[] memory);\n    function getSourceOfAsset(address _asset) external view returns(address);\n    function getFallbackOracle() external view returns(address);\n}\n\ninterface AaveCoreInterface {\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256);\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256);\n}\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        z = x - y <= x ? x - y : 0;\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n}\n\ncontract AaveHelpers is DSMath {\n    /**\n     * @dev get Aave Provider Address\n    */\n    function getAaveProviderAddress() internal pure returns (address) {\n        // return 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8; //mainnet\n        return 0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5; //kovan\n    }\n\n    struct AaveUserTokenData {\n        uint tokenPrice;\n        uint supplyBalance;\n        uint borrowBalance;\n        uint borrowFee;\n        uint supplyRate;\n        uint borrowRate;\n        uint borrowModal;\n        AaveTokenData aaveTokenData;\n    }\n\n    struct AaveUserData {\n        uint totalSupplyETH;\n        uint totalCollateralETH;\n        uint totalBorrowsETH;\n        uint totalFeesETH;\n        uint availableBorrowsETH;\n        uint currentLiquidationThreshold;\n        uint ltv;\n        uint healthFactor;\n    }\n\n    struct AaveTokenData {\n        uint ltv;\n        uint threshold;\n        bool usageAsCollEnabled;\n        bool borrowEnabled;\n        bool stableBorrowEnabled;\n        bool isActive;\n    }\n\n\n\n    function collateralData(AaveInterface aave, address token) internal view returns(AaveTokenData memory) {\n        AaveTokenData memory aaveTokenData;\n        (\n            aaveTokenData.ltv,\n            aaveTokenData.threshold,\n            ,\n            ,\n            aaveTokenData.usageAsCollEnabled,\n            aaveTokenData.borrowEnabled,\n            aaveTokenData.stableBorrowEnabled,\n            aaveTokenData.isActive\n        ) = aave.getReserveConfigurationData(token);\n        return aaveTokenData;\n    }\n\n    function getTokenData(\n        AaveCoreInterface aaveCore,\n        AaveInterface aave,\n        address user,\n        address token,\n        uint price)\n    internal view returns(AaveUserTokenData memory tokenData) {\n        (\n            uint supplyBal,\n            uint borrowBal,\n            ,\n            uint borrowModal,\n            ,\n            ,\n            uint fee,\n            ,,\n        ) = aave.getUserReserveData(token, user);\n\n        uint supplyRate = aaveCore.getReserveCurrentLiquidityRate(token);\n        uint borrowRate = aaveCore.getReserveCurrentVariableBorrowRate(token);\n        AaveTokenData memory aaveTokenData = collateralData(aave, token);\n\n        tokenData = AaveUserTokenData(\n            price,\n            supplyBal,\n            borrowBal,\n            fee,\n            supplyRate,\n            borrowRate,\n            borrowModal,\n            aaveTokenData\n        );\n    }\n\n    function getUserData(AaveInterface aave, address user)\n    internal view returns (AaveUserData memory userData) {\n        (\n            uint totalSupplyETH,\n            uint totalCollateralETH,\n            uint totalBorrowsETH,\n            uint totalFeesETH,\n            uint availableBorrowsETH,\n            uint currentLiquidationThreshold,\n            uint ltv,\n            uint healthFactor\n        ) = aave.getUserAccountData(user);\n\n        userData = AaveUserData(\n            totalSupplyETH,\n            totalCollateralETH,\n            totalBorrowsETH,\n            totalFeesETH,\n            availableBorrowsETH,\n            currentLiquidationThreshold,\n            ltv,\n            healthFactor\n        );\n    }\n}\n\ncontract Resolver is AaveHelpers {\n    function getPosition(address user, address[] memory tokens) public view returns(AaveUserTokenData[] memory, AaveUserData memory) {\n        AaveProviderInterface AaveProvider = AaveProviderInterface(getAaveProviderAddress());\n        AaveInterface aave = AaveInterface(AaveProvider.getLendingPool());\n        AaveCoreInterface aaveCore = AaveCoreInterface(AaveProvider.getLendingPoolCore());\n\n        AaveUserTokenData[] memory tokensData = new AaveUserTokenData[](tokens.length);\n        uint[] memory tokenPrices = AavePriceInterface(AaveProvider.getPriceOracle()).getAssetsPrices(tokens);\n        for (uint i = 0; i < tokens.length; i++) {\n            tokensData[i] = getTokenData(aaveCore, aave, user, tokens[i], tokenPrices[i]);\n        }\n        return (tokensData, getUserData(aave, user));\n    }\n}\n\ncontract InstaAaveResolver is Resolver {\n    string public constant name = \"Aave-Resolver-v1\";\n}"
    }
  }
}