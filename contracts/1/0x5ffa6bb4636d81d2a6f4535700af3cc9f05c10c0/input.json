{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/SuperBean.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.3;\npragma experimental ABIEncoderV2;\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"SafeMath: add overflow\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"SafeMath: sub underflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"SafeMath: mul overflow\");\n    }\n\n    function div(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint c = a / b;\n        return c;\n    }\n}\n\ncontract SuperBean {\n    using SafeMath for uint;\n\n    string public constant name = \"SuperBean\";\n    string public constant symbol = \"SBT\";\n    uint8 public constant decimals = 18;\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    address public rainmaker;\n    uint public FEEDING_END_BLOCK = 11688888;\n    uint public MIN_STAKE_VALUE = 50000000000000000;\n    uint public MAX_STAKE_VALUE = 10000000000000000000;\n    uint public MIN_TIER_1 = 10000000000000000000;\n    uint public MIN_TIER_2 = 50000000000000000000;\n    uint public MIN_TIER_3 = 100000000000000000000;\n\n    uint constant MATURITY = 300;\n    uint constant MIN_CHANCE = 1;\n    uint constant MAX_CHANCE = 95;\n    uint8 constant LEFT_MASK = 0xf0;\n    uint8 constant RIGHT_MASK = 0xf;\n\n    struct Stake {\n      uint blockNumber;\n      uint8 rnd;\n      uint8 chance;\n      uint value;\n      uint reward;\n    }\n\n    mapping (address => Stake[]) StakeMap;\n\n    constructor() {\n      rainmaker = msg.sender;\n    }\n\n    // events\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint value\n    );\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event StakeEvent(address sender, uint8 chance, uint value, uint amount);\n    event HarvestEvent(uint rnd, uint chance, uint value, uint reward);\n    event UnstakeEvent(address sender, uint beans, uint amount);\n    event SwapEvent(address sender, uint value, uint amount);\n    event FeedEvent(address sender, uint value, uint amount);\n\n    // modifiers\n    modifier onlyRainmaker {\n        require( msg.sender == rainmaker, \"SuperBeans: onlyRainmaker methods called by non-rainmaker.\" );\n        _;\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve( address owner, address spender, uint value ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer( address from, address to, uint value ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom( address from, address to, uint value ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub( value );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    // configuration\n    function setRainmaker(address newRainmaker) external onlyRainmaker {\n        rainmaker = newRainmaker;\n    }\n    function setStake(uint typ, uint value) external onlyRainmaker {\n        if (typ == 0) {\n            MIN_STAKE_VALUE = value;\n        } else if (typ == 1) {\n            MAX_STAKE_VALUE = value;\n        }\n    }\n    function setTier(uint tier, uint value) external onlyRainmaker {\n        if (tier == 1) {\n            MIN_TIER_1 = value;\n        } else if (tier == 2) {\n            MIN_TIER_2 = value;\n        } else if (tier == 3) {\n            MIN_TIER_3 = value;\n        }\n    }\n    function setFeedingEndBlock(uint value) external onlyRainmaker {\n        require( block.number + MATURITY < value, 'SuperBean: invalid feeding end block');\n        FEEDING_END_BLOCK = value;\n    }\n\n    // stake\n    function stake(uint chance) external payable {\n        uint value = msg.value;\n        require(chance >= MIN_CHANCE && chance <= MAX_CHANCE, \"SuperBean: invalid chance\");\n        require(value >= MIN_STAKE_VALUE && value <= MAX_STAKE_VALUE, \"SuperBean: invalid stake value\");\n\n        Stake[] storage stakes = StakeMap[msg.sender];\n        uint a = chance.mul(uint(100).sub(chance)).mul(uint(100).sub(chance));\n        uint minBeans = value.mul(chance).mul(uint(100).sub(chance))/uint(10000);\n        uint maxBeans = value.mul(uint(1000000).sub(a))/(chance.mul(uint(10000)));\n        uint fee = minBeans/uint(100);\n        uint amount = minBeans.sub(fee);\n        uint reward = maxBeans.sub(minBeans);\n        _mint(rainmaker, fee);\n        _mint(msg.sender, amount);\n        stakes.push(Stake(block.number, uint8(255), uint8(chance), value, reward));\n        emit StakeEvent(msg.sender, uint8(chance), value, amount);\n    }\n\n    // harvest\n    function harvest(address addr) external {\n        Stake[] storage stakes = StakeMap[addr];\n        require(stakes.length > 0, \"SuperBean: no stakes to harvest\");\n        require(stakes[0].blockNumber + MATURITY < block.number, \"SuperBean: stakes not mature\");\n        require(stakes[stakes.length - 1].rnd == uint8(255), \"SuperBean: no pending stakes\");\n\n        uint rewards = 0;\n        uint fees = 0;\n        for (uint i = 0; i < stakes.length; i++) {\n            if (stakes[i].rnd != uint8(255) || stakes[i].blockNumber + MATURITY > block.number) {\n                continue;\n            }\n            uint rnd = random(hash(stakes[i]));\n            stakes[i].rnd = uint8(rnd);\n            if (rnd < stakes[i].chance) {\n                uint fee = stakes[i].reward.div(uint(100));\n                fees = fees.add(fee);\n                rewards = rewards.add(stakes[i].reward);\n                emit HarvestEvent(rnd, stakes[i].chance, stakes[i].value, stakes[i].reward);\n             } else{\n                emit HarvestEvent(rnd, stakes[i].chance, stakes[i].value, 0);\n             }\n        }\n        if (rewards > 0) {\n            _mint(rainmaker, fees);\n            _mint(addr, rewards);\n        }\n    }\n\n    // unstake\n    function unstake(uint amount) external payable {\n        require(amount > 0 && balanceOf[msg.sender] >= amount && totalSupply > amount, \"SuperBean: inefficient beans\");\n        uint totalSeeds = payable(address(this)).balance;\n        uint seeds = amount.mul(totalSeeds)/totalSupply;\n        msg.sender.transfer(seeds);\n        _burn(msg.sender, amount);\n        emit UnstakeEvent(msg.sender, amount, seeds);\n    }\n\n    function swap() external payable {\n        require(msg.value > 0, \"SuperBean: inefficient funds to swap\");\n        uint totalSeeds = payable(address(this)).balance;\n        uint beans = 0;\n        if (totalSeeds > 0 && totalSeeds > msg.value && totalSupply > 0) {\n            beans = (msg.value).mul(totalSupply)/totalSeeds.sub(msg.value);\n        } else {\n            beans = msg.value;\n        }\n        uint fee = beans/100;\n        uint amount = beans.sub(fee);\n        _mint(msg.sender, amount);\n        _mint(rainmaker, fee);\n        emit SwapEvent(msg.sender, msg.value, beans);\n    }\n\n    function feed() external payable {\n        require(block.number < FEEDING_END_BLOCK, \"SuperBean: feeding is over\");\n        require(msg.value >= MIN_TIER_1, \"SuperBean: inefficient funds to feed\");\n        uint beans = 0;\n        if (msg.value >= MIN_TIER_3) {\n            beans = (msg.value).mul(9)/5;\n        } else if (msg.value >= MIN_TIER_2) {\n            beans = (msg.value).mul(7)/5;\n        } else {\n            beans = (msg.value).mul(6)/5;\n        }\n        uint fees = beans/10;\n        _mint(msg.sender, beans);\n        _mint(rainmaker, fees);\n        emit FeedEvent(msg.sender, msg.value, beans);\n    }\n\n    function hash(Stake memory s) internal view returns(bytes32) {\n        bytes32 hashStr = keccak256(abi.encodePacked(s.blockNumber, s.chance, s.value, block.difficulty, blockhash(block.number), block.timestamp));\n        return hashStr;\n    }\n\n    function random(bytes32 gene) internal pure returns(uint) {\n        uint first = 10;\n        uint second = 10;\n        uint cnt = 0;\n        for (uint i = gene.length - 1; i >= 0 && cnt < 2; i--) {\n            uint r = uint8(gene[i]) & RIGHT_MASK;\n            if (r < 10) {\n                if (cnt == 0) {\n                    first = r;\n                } else if (cnt == 1) {\n                    second = r;\n                }\n                cnt = cnt + 1;\n            }\n            uint l = (uint8(gene[i]) & LEFT_MASK) >> 4;\n            if (l < 10) {\n                if (cnt == 0) {\n                    first = l;\n                } else if (cnt == 1) {\n                    second = l;\n                }\n                cnt = cnt + 1;\n            }\n        }\n        return second * 10 + first;\n    }\n\n    function getStakes(address addr) public view returns (Stake[] memory) {\n      return StakeMap[addr];\n    }\n\n}\n"
    }
  }
}