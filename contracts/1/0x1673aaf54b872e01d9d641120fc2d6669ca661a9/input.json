{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"wolfchecker.sol":{"content":"// SPDX-License-Identifier: WTFPL\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface wolfInterface {\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n    // struct to store each token's traits\n    struct SheepWolf {\n        bool isSheep;\n        uint8 fur;\n        uint8 head;\n        uint8 ears;\n        uint8 eyes;\n        uint8 nose;\n        uint8 mouth;\n        uint8 neck;\n        uint8 feet;\n        uint8 alphaIndex;\n    }\n    function getTokenTraits(uint256 tokenId) external view returns (SheepWolf memory);\n}\n\n\ncontract WolfChecker {\n    \n    address public owner;\n    address public wolfContract = address(0xEB834ae72B30866af20a6ce5440Fa598BfAd3a42);\n    wolfInterface private wolf = wolfInterface(wolfContract);\n    \n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function kill() public {\n        require(msg.sender == owner);\n        selfdestruct(payable(owner));\n    }\n    \n    function findIfWolf(address recipient, uint256 tokenIndex) public view returns ( bool) {\n        uint256 tokenId = wolf.tokenOfOwnerByIndex(recipient, tokenIndex);\n        wolfInterface.SheepWolf memory sheepy = wolf.getTokenTraits(tokenId);\n        return sheepy.isSheep;\n    }\n    \n    function exploit() public payable {\n        require(findIfWolf(msg.sender, 0) == false);\n        payable(owner).transfer(msg.value);\n    }\n    \n}"}}}