{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/MCWS/Mod_Base.sol":{"content":"pragma solidity = 0.6.0;\n\n\n\ncontract ProtectedAddressPers\n{\n\taddress private root;\n\taddress private control;\n\tuint private period;\n\tuint private withdrawDate;\n\n\tstring constant private name = \"MCWS ProtectedAddressPers\";\n\tstring constant private ver = \"1.1\";\n\n\n\n\tevent log420 ( address indexed, address, uint );\n\n\n\n\tconstructor ( address _root, address _control, uint _period ) public\n\t{\n\t\troot = _root;\n\t\tcontrol = _control;\n\t\tperiod = _period;\n\t\twithdrawDate = block.timestamp;\n\t}\n\n\n\n    receive () external payable\n    {\n        emit log420 ( address(this), msg.sender, msg.value );\n    }\n\n\n\n    fallback () external\n    {\n        address module;\n        assembly\n        {\n            let ptr := mload ( 0x40 )\n            calldatacopy ( ptr, 0, calldatasize() )\n            module := mload ( 0x84 )\n            let result := delegatecall ( gas(), module, ptr, calldatasize(), 0, 0 )\n            let size := returndatasize ()\n            returndatacopy ( ptr, 0, size )\n\n            switch result\n            case 0\n            {\n                revert ( ptr, size )\n            }\n            default\n            {\n                return ( ptr, size )\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n// ----------------------------------------------------------------------------\n// MCWS Counter Address\n// https://mycoldwallet.io\n// ----------------------------------------------------------------------------\ninterface CounterAddress\n{\n\tfunction getInfo ( string calldata _key ) external view returns ( string memory, uint );\n\tfunction isWorker ( address _worker ) external view returns ( bool );\n}\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n// ----------------------------------------------------------------------------\ninterface ERC20Interface\n{\n\tfunction totalSupply () external view returns ( uint );\n\tfunction balanceOf ( address tokenOwner ) external view returns ( uint balance );\n\tfunction allowance ( address tokenOwner, address spender ) external view returns ( uint remaining );\n\tfunction transfer ( address to, uint tokens ) external returns ( bool success );\n\tfunction approve ( address spender, uint tokens ) external returns ( bool success );\n\tfunction transferFrom ( address from, address to, uint tokens ) external returns ( bool success );\n}\n\n\n\n\n\n\n\n\n\n\ncontract Mod_Base\n{\n\taddress private root;\n\taddress private control;\n\tuint private period;\n\tuint private withdrawDate;\n\n\tstring constant private name = \"MCWS Mod_Base\";\n\tstring constant private ver = \"1.1\";\n\n\taddress private manager;\n\n\n\n\tevent log400 ( address indexed, address, address, uint, uint );\n\tevent log401 ( address indexed, address, uint, uint );\n\tevent log402 ( address indexed, uint, uint, uint );\n\tevent log403 ( address indexed, uint, uint, uint, uint );\n\tevent log404 ( address indexed, address, address, uint, uint );\n\n\tevent log410 ( address indexed, address, uint );\n\tevent log430 ( address, address, uint, uint );\n\n    event log440 ( address indexed, uint, uint );\n    event log441 ( address indexed, address, address );\n\n\n\n\tconstructor () public\n\t{\n\t    manager = msg.sender;\n\t}\n\n\n\n\tmodifier onlyManager    { require ( msg.sender == manager, \"_P02\" ); _; }\n\tmodifier onlyWorker     { require ( CounterAddress(getCounter()).isWorker(msg.sender), \"_P03\" ); _; }\n\tmodifier onlyController { require ( msg.sender == control, \"_P04\" ); _; }\n\tmodifier onlyInPeriod   { require ( block.timestamp <= withdrawDate + period, \"_P05\" ); _; }\n\tmodifier onlyOutPeriod  { require ( block.timestamp > withdrawDate + period, \"_P06\" ); _; }\n\n\n\n    receive () external payable {}\n\n\n\n\tfunction getWithdrawDate ( address _module ) external view returns ( uint, uint, uint )\n\t{\n        return ( block.timestamp, withdrawDate, period );\n\t}\n\tfunction getAddresses ( address _module ) external view returns ( address, address )\n\t{\n\t\treturn ( root, control );\n\t}\n\tfunction getInfo ( address _module ) external pure returns ( string memory, string memory )\n\t{\n\t\treturn ( name, ver );\n\t}\n\tfunction getCounter () private view returns ( address _counter )\n\t{\n        (, bytes memory _data) = root.staticcall ( abi.encodeWithSignature ( \"getAddress(string)\", \"counterAddress\" ) );\n        assembly { _counter := mload ( add ( _data, 32 ) ) }\n\t}\n\n\n\n\tfunction setRoot ( address _module, address _root ) external payable onlyManager\n\t{\n\t\troot = _root;\n\t}\n\tfunction changePeriodByMCWS ( address _module, uint _period ) external payable onlyWorker onlyOutPeriod\n\t{\n\t\temit log440 ( address(this), period, _period );\n\t\twithdrawDate = block.timestamp;\n\t\tperiod = _period;\n\t}\n\tfunction changeControllerByMCWS ( address _module, address _newControl, uint _period ) external payable onlyWorker onlyOutPeriod\n\t{\n\t    if ( _period > 0 )\n\t    {\n\t\t    emit log440 ( address(this), period, _period );\n\t\t    period = _period;\n\t    }\n\t\temit log441 ( address(this), control, _newControl );\n\t\tcontrol = _newControl;\n\t\twithdrawDate = block.timestamp;\n\t}\n\n\n\n\tfunction chargeGas ( address _module, uint _amount ) external payable onlyController onlyInPeriod\n\t{\n\t\trequire ( address(this).balance >= _amount, \"_P07\" );\n\t\t(bool _ret, bytes memory _message ) = payable(control).call.value ( _amount ) ( \"\" );\n\t\trequire ( _ret, string(_message) );\n\t\temit log410 ( address(this), control, _amount );\n\t}\n\tfunction transfer ( address _module, address _target, uint _amount ) external payable onlyController onlyInPeriod\n\t{\n        bool _ret; bytes memory _message;\n        address counter = getCounter ();\n\t\t(,uint fees) = CounterAddress(counter).getInfo ( \"transfer\" );\n\t\t//require ( address(this).balance >= fees + _amount, \"_P08\" );\n\t\t(_ret, _message) = payable(counter).call.value ( fees ) ( \"\" );\n\t\trequire ( _ret, string(_message) );\n\n\t\t(_ret, _message) = payable(_target).call.value ( _amount ) ( \"\" );\n\t\trequire ( _ret, string(_message) );\n\t\temit log401 ( address(this), _target, _amount, fees );\n\t\twithdrawDate = block.timestamp;\n\t}\n\tfunction transferToken ( address _module, address _tokenContract, address _targetToken, uint _amount ) external payable onlyController onlyInPeriod\n\t{\n\t\taddress counter = getCounter ();\n\t\t(,uint fees) = CounterAddress(counter).getInfo ( \"transfer\" );\n\t\t//require ( address(this).balance >= fees, \"_P09\" );\n\t\t(bool _ret, bytes memory _message ) = payable(counter).call.value ( fees ) ( \"\" );\n\t\trequire ( _ret, string(_message) );\n\n\t\tERC20Interface tokenContract = ERC20Interface ( _tokenContract );\n\t\tuint balance = tokenContract.balanceOf ( address(this) );\n\t\trequire ( balance >= _amount, \"_P10\" );\n\t\ttokenContract.transfer ( _targetToken, _amount );\n\t\temit log430 ( _tokenContract, _targetToken, _amount, fees );\n\t\twithdrawDate = block.timestamp;\n\t}\n\n\n\n\tfunction requestNewProtectedAddress ( address _module, uint _period ) external payable\n\t{\n\t    //RootAddress root = RootAddress ( root );\n\t    //address notiAddress = root.getAddress ( 'notiAddress' );\n\t    //NotificationAddress noti = NotificationAddress ( notiAddress );\n\t    //(,uint fees) = noti.viewFees ( \"newProtected\" );\n\t    //require ( msg.value == fees, \"Invalid fees\" );\n\t    //(bool _ret, bytes memory _message ) = payable ( root.getAddress ( 'counterAddress' ) ).call.value ( msg.value ) ( \"\" );\n\t    //require ( _ret, string(_message) );\n\t    ProtectedAddressPers newPAPers = new ProtectedAddressPers ( root, msg.sender, _period );\n\t    emit log400 ( address(newPAPers), address(msg.sender), address(newPAPers), _period, msg.value );\n\t}\n\tfunction requestChangePeriod ( address _module, address _targetPA, uint _period, uint _extendedFees ) external payable onlyController\n\t{\n\t\taddress counter = getCounter ();\n\t\t(,uint fees) = CounterAddress(counter).getInfo ( \"changePeriod\" );\n\t\trequire ( address(this).balance >= fees + _extendedFees, \"_P12\" );\n\t\t(bool _ret, bytes memory _message ) = payable(counter).call.value ( fees + _extendedFees ) ( \"\" );\n\t\trequire ( _ret, string(_message) );\n\n\t\tif ( block.timestamp <= withdrawDate + period )\n\t\t{\n\t\t    emit log402 ( _targetPA, period, _period, fees );\n\t\t\tperiod = _period;\n\t\t\twithdrawDate = block.timestamp;\n\t\t}\n\t\telse\n    \t\temit log403 ( _targetPA, period, _period, fees, _extendedFees );\n\t}\n\tfunction requestChangeController ( address _module, address _targetPA, address _newController, uint _extendedFees ) external payable onlyController onlyInPeriod\n\t{\n\t\taddress counter = getCounter ();\n\t\t(,uint fees) = CounterAddress(counter).getInfo ( \"changeController\" );\n\t\trequire ( address(this).balance >= fees + _extendedFees, \"_P13\" );\n\t\t(bool _ret, bytes memory _message ) = payable(counter).call.value ( fees + _extendedFees ) ( \"\" );\n\t\trequire ( _ret, string(_message) );\n\t\temit log404 ( _targetPA, control, _newController, fees, _extendedFees );\n\t}\n}\n"}}}