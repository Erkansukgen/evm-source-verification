{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"MerkleDistributorFactory.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.7;\n\n// Allows anyone to claim a token if they exist in a merkle root\nabstract contract IMerkleDistributor {\n    // Time from the moment this contract is deployed and until the owner can withdraw leftover tokens\n    uint256 public constant timelapseUntilWithdrawWindow = 90 days;\n\n    // Returns the address of the token distributed by this contract\n    function token() virtual external view returns (address);\n    // Returns the merkle root of the merkle tree containing account balances available to claim\n    function merkleRoot() virtual external view returns (bytes32);\n    // Returns the timestamp when this contract was deployed\n    function deploymentTime() virtual external view returns (uint256);\n    // Returns the address for the owner of this contract\n    function owner() virtual external view returns (address);\n    // Returns true if the index has been marked claimed\n    function isClaimed(uint256 index) virtual external view returns (bool);\n    // Send tokens to an address without that address claiming them\n    function sendTokens(address dst, uint256 tokenAmount) virtual external;\n    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) virtual external;\n\n    // This event is triggered whenever an address is added to the set of authed addresses\n    event AddAuthorization(address account);\n    // This event is triggered whenever an address is removed from the set of authed addresses\n    event RemoveAuthorization(address account);\n    // This event is triggered whenever a call to #claim succeeds\n    event Claimed(uint256 index, address account, uint256 amount);\n    // This event is triggered whenever some tokens are sent to an address without that address claiming them\n    event SendTokens(address dst, uint256 tokenAmount);\n}\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract MerkleDistributor is IMerkleDistributor {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"MerkleDistributorFactory/account-not-authorized\");\n        _;\n    }\n    /*\n    * @notify Checks whether an address can send tokens out of this contract\n    */\n    modifier canSendTokens {\n        require(\n          either(authorizedAccounts[msg.sender] == 1, both(owner == msg.sender, now >= addition(deploymentTime, timelapseUntilWithdrawWindow))),\n          \"MerkleDistributorFactory/cannot-send-tokens\"\n        );\n        _;\n    }\n\n    // The token being distributed\n    address public immutable override token;\n    // The owner of this contract\n    address public immutable override owner;\n    // The merkle root of all addresses that get a distribution\n    bytes32 public immutable override merkleRoot;\n    // Timestamp when this contract was deployed\n    uint256 public immutable override deploymentTime;\n\n    // This is a packed array of booleans\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    constructor(address token_, bytes32 merkleRoot_) public {\n        authorizedAccounts[msg.sender] = 1;\n        owner                          = msg.sender;\n        token                          = token_;\n        merkleRoot                     = merkleRoot_;\n        deploymentTime                 = now;\n\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"MerkleDistributorFactory/add-uint-uint-overflow\");\n    }\n\n    // --- Boolean Logic ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Administration ---\n    /*\n    * @notice Send tokens to an authorized address\n    * @param dst The address to send tokens to\n    * @param tokenAmount The amount of tokens to send\n    */\n    function sendTokens(address dst, uint256 tokenAmount) external override canSendTokens {\n        require(dst != address(0), \"MerkleDistributorFactory/null-dst\");\n        IERC20(token).transfer(dst, tokenAmount);\n        emit SendTokens(dst, tokenAmount);\n    }\n\n    /*\n    * @notice View function returning whether an address has already claimed their tokens\n    * @param index The position of the address inside the merkle tree\n    */\n    function isClaimed(uint256 index) public view override returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n    /*\n    * @notice Mark an address as having claimed their distribution\n    * @param index The position of the address inside the merkle tree\n    */\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n    /*\n    * @notice Claim your distribution\n    * @param index The position of the address inside the merkle tree\n    * @param account The actual address from the tree\n    * @param amount The amount being distributed\n    * @param merkleProof The merkle path used to prove that the address is in the tree and can claim amount tokens\n    */\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {\n        require(!isClaimed(index), 'MerkleDistributor/drop-already-claimed');\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor/invalid-proof');\n\n        // Mark it claimed and send the token\n        _setClaimed(index);\n        require(IERC20(token).transfer(account, amount), 'MerkleDistributor/transfer-failed');\n\n        emit Claimed(index, account, amount);\n    }\n}\n\ncontract MerkleDistributorFactory {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"MerkleDistributorFactory/account-not-authorized\");\n        _;\n    }\n\n    // --- Variables ---\n    // Number of distributors created\n    uint256 public nonce;\n    // The token that's being distributed by every merkle distributor\n    address public distributedToken;\n    // Mapping of ID => distributor address\n    mapping(uint256 => address) public distributors;\n    // Tokens left to distribute to every distributor\n    mapping(uint256 => uint256) public tokensToDistribute;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DeployDistributor(uint256 id, address distributor, uint256 tokenAmount);\n    event SendTokensToDistributor(uint256 id);\n\n    constructor(address distributedToken_) public {\n        require(distributedToken_ != address(0), \"MerkleDistributorFactory/null-distributed-token\");\n\n        authorizedAccounts[msg.sender] = 1;\n        distributedToken               = distributedToken_;\n\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"MerkleDistributorFactory/add-uint-uint-overflow\");\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notice Deploy a new merkle distributor\n    * @param merkleRoot The merkle root used in the distributor\n    */\n    function deployDistributor(bytes32 merkleRoot, uint256 tokenAmount) external isAuthorized {\n        require(tokenAmount > 0, \"MerkleDistributorFactory/null-token-amount\");\n        nonce                     = addition(nonce, 1);\n        address newDistributor    = address(new MerkleDistributor(distributedToken, merkleRoot));\n        distributors[nonce]       = newDistributor;\n        tokensToDistribute[nonce] = tokenAmount;\n        emit DeployDistributor(nonce, newDistributor, tokenAmount);\n    }\n    /*\n    * @notice Send tokens to a distributor\n    * @param nonce The nonce/id of the distributor to send tokens to\n    */\n    function sendTokensToDistributor(uint256 id) external isAuthorized {\n        require(tokensToDistribute[id] > 0, \"MerkleDistributorFactory/nothing-to-send\");\n        uint256 tokensToSend = tokensToDistribute[id];\n        tokensToDistribute[id] = 0;\n        IERC20(distributedToken).transfer(distributors[id], tokensToSend);\n        emit SendTokensToDistributor(id);\n    }\n    /*\n    * @notice Sent distributedToken tokens out of this contract and to a custom destination\n    * @param dst The address that will receive tokens\n    * @param tokenAmount The token amount to send\n    */\n    function sendTokensToCustom(address dst, uint256 tokenAmount) external isAuthorized {\n        require(dst != address(0), \"MerkleDistributorFactory/null-dst\");\n        IERC20(distributedToken).transfer(dst, tokenAmount);\n    }\n    /*\n    * @notice This contract gives up on being an authorized address inside a specific distributor contract\n    */\n    function dropDistributorAuth(uint256 id) external isAuthorized {\n        MerkleDistributor(distributors[id]).removeAuthorization(address(this));\n    }\n    /*\n    * @notice Send tokens from a distributor contract to this contract\n    */\n    function getBackTokensFromDistributor(uint256 id, uint256 tokenAmount) external isAuthorized {\n        MerkleDistributor(distributors[id]).sendTokens(address(this), tokenAmount);\n    }\n}"}}}