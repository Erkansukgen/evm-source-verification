{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Authority.sol": {
      "content": "pragma solidity >= 0.6.2 < 0.7.0;\nimport \"./Owned.sol\";\n\n//dge方法授权\ncontract Authority is Owned {\n    /**\n    最高owner : 销毁 , 总锁\n    治理权限1级(次高级) : 开关锁,增发销毁,修改权限\n    治理权限2级(中级)(修改) : 发起投票,修改汇率\n    治理权限3级 : 其他次重要权限\n    治理权限4级(最低)(只读) : 查看信息\n    */\n    //1级别最高;1包含2,3;2包含3;\n    mapping(address =>bool) public govenors1;\n    mapping(address =>bool) public govenors2;\n    mapping(address =>bool) public govenors3;\n    mapping(address =>bool) public govenors4;\n    //开关锁\n    bool public ownersLock_open = true;\n    bool public govenors1_open = true;\n    bool public govenors2_open = true;\n    bool public govenors3_open = true;\n    bool public govenors4_open = true;\n\n    //合约创建的时候执行，执行合约的人是第一个owner\n    constructor() public {\n        setGovenors1(msg.sender, true);\n    }\n    modifier onlyGovenors1() {\n        require((govenors1[msg.sender]) && (govenors1_open) && (ownersLock_open), 'msg.sender no righte of govenors1');\n        _; //do something\n    }\n    modifier onlyGovenors2() {\n        require((govenors2[msg.sender]) && (govenors2_open) && (ownersLock_open), 'msg.sender no righte of govenors2');\n        _; //do something\n    }\n    modifier onlyGovenors3() {\n        require((govenors3[msg.sender]) && (govenors3_open) && (ownersLock_open), 'msg.sender no righte of govenors3');\n        _; //do something\n    }\n    modifier onlyGovenors4() {\n        require((govenors4[msg.sender]) && (govenors4_open) && (ownersLock_open), 'msg.sender no righte of govenors4');\n        _; //do something\n    }\n\n    //set lock flage\n    function setOwnersLock_open(bool _enable) public onlyOwner returns(bool _result) {\n        ownersLock_open = _enable;\n        return ownersLock_open;\n    }\n    function setGovenors1_open(bool _enable) public onlyOwner returns(bool _result) {\n        govenors1_open = _enable;\n        return govenors1_open;\n    }\n    function setGovenors2_open(bool _enable) public onlyGovenors1 returns(bool _result) {\n        govenors2_open = _enable;\n        return govenors2_open;\n    }\n    function setGovenors3_open(bool _enable) public onlyGovenors2 returns(bool _result) {\n        govenors3_open = _enable;\n        return govenors3_open;\n    }\n    function setGovenors4_open(bool _enable) public onlyGovenors3 returns(bool _result) {\n        govenors4_open = _enable;\n        return govenors4_open;\n    }\n\n    /////// set\n    function setGovenors1(address _user, bool _enable) public onlyOwner returns(bool _result) {\n        govenors1[_user] = _enable;\n        govenors2[_user] = _enable;\n        govenors3[_user] = _enable;\n        govenors4[_user] = _enable;\n        return govenors1[_user];\n    }\n    function setGovenors2(address _user, bool _enable) public onlyGovenors1 returns(bool _result) {\n        govenors2[_user] = _enable;\n        govenors3[_user] = _enable;\n        govenors4[_user] = _enable;\n        return govenors2[_user];\n    }\n    function setGovenors3(address _user, bool _enable) public onlyGovenors2 returns(bool _result) {\n        govenors3[_user] = _enable;\n        govenors4[_user] = _enable;\n        return govenors3[_user];\n    }\n    function setGovenors4(address _user, bool _enable) public onlyGovenors3 returns(bool _result) {\n        govenors4[_user] = _enable;\n        return govenors4[_user];\n    }\n}"
    },
    "browser/DGEUniswap.sol": {
      "content": "pragma solidity >= 0.6.2 < 0.7.0;\nimport \"./SafeMath.sol\";\nimport \"./IDGE.sol\";\nimport \"./ICToken.sol\";\nimport \"./IUniswapV2Router02.sol\";\nimport \"./IERC20.sol\";\n//import \"./Address.sol\";\nimport \"./Authority.sol\";\n//DGE通过uniswap交易获利ctoken的合约\ncontract DGEUniswap is Authority {\n    //初始化代币参数\n    constructor() public payable {}\n    //使用SafeMath\n    using SafeMath\n    for uint256;\n    ///\n    //uniswaop <-> ctoken\n    // rinkeby:\n    address public zhuAddr1 = 0x5f5E30Ea82952E6de5A318B7A5c8E7cEe78Cbd49;\n    \n\n    address public ctokenAddr = 0xdA631Adfe5C598705045129Ca4a528389F7c831C;\n\n    address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    address public dgeContractAddr1 = 0x19Dddb06D0629E92eEC3CAFab50E334863d11387;\n    \n\n    address public dgeContractAddr = 0x19Dddb06D0629E92eEC3CAFab50E334863d11387;\n\n    address public exPairsCtokenAddr = 0x1ECd69D1a623811593D90a20a81CEB1e388eE562;\n    address public uniswapV2Router02Addr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    uint256 public miniDealineTime = 120; //600; //10分钟\n    uint256 public mydeadline = 2000000000;\n\n    //地址 ETH,DAI等有多少参与了平台uniswap ,大写, uint256为eth等的数量\n    mapping(address =>mapping(string =>uint256)) public dgeWebExAmountT1;\n    //地址 ETH,DAI等参与了平台uniswap ,得到多少ctoken,大写, uint256为ctoken的数量\n    mapping(address =>mapping(string =>uint256)) public dgeWebExAmountT2;\n    //币种列表,币合约地址 大写\n    mapping(address =>string) public coinName;\n     //利息发放比例,97%, 单位1000, 970=97%\n    uint256 public interestRatetoUser = 970;\n     //利息发放出的总和,单位dge个数\n    uint256 public interestDGETotalAmount = 0;\n    \n    //用户参与eth等的数量\n    function getdgeWebExAmountT1(address _addr, string memory _ethdaiusdt) public view returns(uint256 _ethdaiusdtAmount) {\n\n        return dgeWebExAmountT1[_addr][_ethdaiusdt];\n    }\n    //用户参与获得的ctoken数量\n    function getdgeWebExAmountT2(address _addr, string memory _ethdaiusdt) public view returns(uint256 _ethdaiusdtAmount) {\n\n        return dgeWebExAmountT2[_addr][_ethdaiusdt];\n    }\n //user 赎回之前平台购买的eth,DAI等的利息,仅仅利息部分,ctoken数量不变ctoken=>dge(all in dege)\n    function withdrowUserETHorDaiLixi(address[] memory _tokenIndexs) public returns(bool _success) {\n         uint256 nowall = 0;\n         for (uint i = 0; i < _tokenIndexs.length; i++)  {\n           nowall = nowall.add(dgeWebExAmountT2[msg.sender][coinName[_tokenIndexs[i]]]) ;\n        } \n        payEarningDGE(nowall);\n        _burnToken(msg.sender, nowall);\n        _mintCtoken(msg.sender, nowall);\n        return true;\n    }\n      //user 赎回之前平台购买的eth,DAI等全部,全部,ctoken=>dge(all in dege)\n    function withdrowUserETHorDaiAll(address[] memory _tokenIndexs, uint256 _ctokenAmountall) public returns(bool _success) {\n         uint256 nowall = 0;\n         for (uint i = 0; i < _tokenIndexs.length; i++)  {\n           nowall = nowall.add(dgeWebExAmountT2[msg.sender][coinName[_tokenIndexs[i]]]) ;\n        } \n        require(nowall<=_ctokenAmountall,'err : nowall > _ctokenAmountall, _ctokenAmountall insufficient');\n        \n                for (uint i = 0; i < _tokenIndexs.length; i++)  {\n                   if(dgeWebExAmountT2[msg.sender][coinName[_tokenIndexs[i]]] > 0 ){\n                       withdrowUserETHorDai(  _tokenIndexs[i], dgeWebExAmountT2[msg.sender][coinName[_tokenIndexs[i]]]);\n                   }\n                  }\n        \n        return true;\n    }\n    //user 赎回之前平台购买的eth,DAI等,ctoken=>dge(all in dege)\n    function withdrowUserETHorDai(address _tokenIndex, uint256 _ctokenAmount) public returns(uint256[] memory _withdrawAmount) {\n        require(dgeWebExAmountT1[msg.sender][coinName[_tokenIndex]] > 0);\n        require(dgeWebExAmountT2[msg.sender][coinName[_tokenIndex]] > 0);\n        require(dgeWebExAmountT2[msg.sender][coinName[_tokenIndex]] >= _ctokenAmount);\n        require(_ctokenAmount > 0);\n\n        uint256 allEthDaiUsdtAmount = dgeWebExAmountT1[msg.sender][coinName[_tokenIndex]];\n        uint256 allCtokenAmount = dgeWebExAmountT2[msg.sender][coinName[_tokenIndex]];\n        uint256 leftCtokenAmount = allCtokenAmount.sub(_ctokenAmount);\n        // uint256 letfEthDaiUsdtAmount = (uint256(10000).mul(leftCtokenAmount)).div(allCtokenAmount).mul(allEthDaiUsdtAmount).div(1000);\n        uint256 letfEthDaiUsdtAmount = (uint256(10000000).mul(leftCtokenAmount)).mul(allEthDaiUsdtAmount).div(allCtokenAmount).div(10000000);\n\n        dgeWebExAmountT1[msg.sender][coinName[_tokenIndex]] = letfEthDaiUsdtAmount;\n        dgeWebExAmountT2[msg.sender][coinName[_tokenIndex]] = leftCtokenAmount;\n\n        IDGE idge = IDGE(dgeContractAddr);\n        if (utilCompareInternal(coinName[_tokenIndex], \"ETH\")) {\n            address[] memory path;\n            path = new address[](2);\n            path[0] = dgeContractAddr1;\n            path[1] = _tokenIndex;\n            \n               //打本金,换算成dge打\n            idge.transfer(msg.sender, _ctokenAmount);\n            //打利息dge\n            payEarningDGE(_ctokenAmount);\n            \n            uint[] memory amounts = myswapExactTokensForETHforWhithdraw(_ctokenAmount, path[0], path[1]);\n            //打eth\n            //   require(msg.sender != address(0));\n            //  msg.sender.transfer(amounts[1]);\n         \n\n            return amounts;\n        } else {\n            address[] memory path;\n            path = new address[](2);\n            path[0] = dgeContractAddr1;\n            path[1] = _tokenIndex;\n            \n            idge.transfer(msg.sender, _ctokenAmount);\n            //  msg.sender.transfer(amounts[1]);\n            //打利息dge\n            payEarningDGE(_ctokenAmount);\n            \n            uint[] memory amounts = myswapExactTokensForTokensforWhithdraw(path[0], path[1], _ctokenAmount);\n            //打Dai等\n            require(msg.sender != address(0));\n           // IERC20 ierc20 = IERC20(_tokenIndex);\n           // ierc20.transfer(msg.sender, amounts[0]);\n            //打本金,换算成dge打\n        \n            return amounts;\n        }\n    }\n\n\n    //打币dge,按利息打\n    function payEarningDGE(uint256 _dgeAmount) internal returns(bool _success) {\n        //打利息dge\n        IDGE idge = IDGE(dgeContractAddr);\n        //uint256 _value = payEarningDgeAllRateToSender(_dgeAmount).mul(_ethDaiAmount).mul(5).mul(_ethDaiAmount).div(_dgeAmount).div(100000000);\n        uint256 _value = payEarningDgeAllRateToSender(_dgeAmount).mul(_dgeAmount).mul(interestRatetoUser).mul(5).div(100000000).div(10000000000000);\n       interestDGETotalAmount = interestDGETotalAmount.add(_value);\n        return idge.transfer(msg.sender, _value);\n    }\n    // 1 token to token\n    function myswapExactTokensForTokens(address _addr1, address _addr2, uint amountIn) public returns(uint[] memory _amounts) {\n        uint amountOutMin = 1;\n        // address _addr1,address _addr2,\n        address[] memory path;\n        path = new address[](2);\n        path[0] = _addr1;\n        path[1] = _addr2;\n\n        //IERC20 ierc20 = IERC20(_tokenIndex);\n        //  IDGE idge1 = IDGE(dgeContractAddr1);\n        //  idge1.approve(uniswapV2Router02Addr, amountIn);\n        //  IDGE idge2 = IDGE(dgeContractAddr2);\n        IERC20 ierc201 = IERC20(_addr1);\n        ierc201.approve(uniswapV2Router02Addr, amountIn);\n\n        //    IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        //   uint256 amountADesired = uniswpair.getAmountsOut(amountIn, path)[1];\n        //   ierc202.approve(uniswapV2Router02Addr, amountADesired);\n        uint[] memory amounts = _swapExactTokensForTokens(amountIn, amountOutMin, path, zhuAddr1, mydeadline);\n        mintBurnCtoken(path, amounts);\n\n        address addrthis = address(this);\n        address payable payaddrthis = address(uint160(addrthis));\n        require(ierc201.allowance(msg.sender, payaddrthis) >= amountIn, \"ierc201.allowance(msg.sender, payaddrthis) is insufficient\");\n        ierc201.transferFrom(msg.sender, payaddrthis, amountIn);\n\n        IERC20 ierc202 = IERC20(_addr2);\n        if (path[1] != dgeContractAddr) {\n            ierc202.transfer(msg.sender, amounts[1]);\n        }\n\n        return amounts;\n    }\n    // 2 token to token\n    function myswapTokensForExactTokens(address _addr1, address _addr2, uint amountOut) public returns(uint[] memory _amounts) {\n        uint amountInMax = 1000000000000000000000000000;\n        address[] memory path;\n        path = new address[](2);\n        path[0] = _addr1;\n        path[1] = _addr2;\n\n        //IERC20 ierc20 = IERC20(_tokenIndex);\n        // IDGE idge1 = IDGE(path[0]);\n        IERC20 ierc201 = IERC20(path[0]);\n\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        uint256 amountADesired = uniswpair.getAmountsIn(amountOut, path)[0];\n        // uint256 amountADesired = uniswpair.getAmountsOut(amountIn, path)[1];\n        //    uint256 amountADesired = getDge1ExDge2Amount(amountOut)[0];\n        ierc201.approve(uniswapV2Router02Addr, amountADesired);\n        //   IERC20 ierc202 = IERC20(path[1]);\n        //   ierc202.approve(uniswapV2Router02Addr, amountOut);\n        uint[] memory amounts = _swapTokensForExactTokens(amountOut, amountInMax, path, zhuAddr1, mydeadline);\n        mintBurnCtoken(path, amounts);\n\n        address addrthis = address(this);\n        address payable payaddrthis = address(uint160(addrthis));\n        require(ierc201.allowance(msg.sender, payaddrthis) >= amountADesired, \"ierc201.allowance(msg.sender, payaddrthis) is insufficient\");\n        ierc201.transferFrom(msg.sender, payaddrthis, amountADesired);\n\n        IERC20 ierc202 = IERC20(_addr2);\n        if (path[1] != dgeContractAddr) {\n            ierc202.transfer(msg.sender, amounts[1]);\n        }\n\n        return amounts;\n    }\n    //3 eth to token\n    //3 putin exact eth , getout tokens\n    function myswapExactETHForTokens(address _addr1, address _addr2) public payable returns(uint[] memory _amounts) {\n        uint amountOutMin = 1;\n        address[] memory path;\n        path = new address[](2);\n        path[0] = _addr1;\n        path[1] = _addr2;\n\n        //IERC20 ierc20 = IERC20(_tokenIndex);\n        //  IERC20 ierc201 = IERC20(path[1]);\n        //   IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        //  uint256 amountDge1Desired = uniswpair.getAmountsOut(msg.value, path)[1];\n        // ierc201.approve(uniswapV2Router02Addr, amountDge1Desired);\n        uint[] memory amounts = _swapExactETHForTokens(amountOutMin, path, zhuAddr1, mydeadline);\n        mintBurnCtoken(path, amounts);\n\n        IERC20 ierc202 = IERC20(_addr2);\n        if (path[1] != dgeContractAddr) {\n            ierc202.transfer(msg.sender, amounts[1]);\n        }\n\n        return amounts;\n    }\n    //4 swapTokensForExactETH\n    //4 swapTokensForExactETH  //path = dge1:eth,so user send token ,get eth amount out  , dge1 => eth ok\n    function myswapTokensForExactETH(address _addr1, address _addr2, uint amountOut) public payable returns(uint[] memory _amounts) {\n        uint amountInMax = 10000000000000000000000000000;\n        // address _addr1,address _addr2,\n        address[] memory path;\n        path = new address[](2);\n        path[0] = _addr1;\n        path[1] = _addr2;\n\n        //IERC20 ierc20 = IERC20(_tokenIndex);\n        IERC20 ierc201 = IERC20(path[0]);\n\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        uint256 amountDge1Desired = uniswpair.getAmountsIn(amountOut, path)[0];\n\n        ierc201.approve(uniswapV2Router02Addr, amountDge1Desired);\n        uint[] memory amounts = _swapTokensForExactETH(amountOut, amountInMax, path, zhuAddr1, mydeadline);\n        mintBurnCtoken(path, amounts);\n\n        address addrthis = address(this);\n        address payable payaddrthis = address(uint160(addrthis));\n        require(ierc201.allowance(msg.sender, payaddrthis) >= amountDge1Desired, \"ierc201.allowance(msg.sender, payaddrthis) is insufficient\");\n        ierc201.transferFrom(msg.sender, payaddrthis, amountDge1Desired);\n        msg.sender.transfer(amountOut);\n\n        return amounts;\n    }\n    //5  swapExactTokensForETH  //path = dge1:eth,so user send token ,get eth amount out  , dge1 => eth ok\n    function myswapExactTokensForETH(uint amountIn, address _addr1, address _addr2) public returns(uint[] memory _amounts) {\n        uint amountOutMin = 1;\n        // address _addr1,address _addr2,\n        address[] memory path;\n        path = new address[](2);\n        path[0] = _addr1;\n        path[1] = _addr2;\n\n        //IERC20 ierc20 = IERC20(_tokenIndex);\n        IERC20 ierc201 = IERC20(path[0]);\n\n        ierc201.approve(uniswapV2Router02Addr, amountIn);\n        uint[] memory amounts = _swapExactTokensForETH(amountIn, amountOutMin, path, zhuAddr1, mydeadline);\n        mintBurnCtoken(path, amounts);\n\n        address addrthis = address(this);\n        address payable payaddrthis = address(uint160(addrthis));\n        require(ierc201.allowance(msg.sender, payaddrthis) >= amountIn, \"ierc201.allowance(msg.sender, payaddrthis) is insufficient\");\n        ierc201.transferFrom(msg.sender, payaddrthis, amountIn);\n        msg.sender.transfer(amounts[1]);\n\n        return amounts;\n    }\n    //6  swapETHForExactTokens  //path = eth:dge1,so user send value ,get dge1 amount out  , eth=>dge1 ok  no\n    function myswapETHForExactTokens(uint amountOut, address _addr1, address _addr2) public payable returns(uint[] memory _amounts) {\n        address[] memory path;\n        path = new address[](2);\n        path[0] = _addr1;\n        path[1] = _addr2;\n        //  uint[] memory amounts = _swapETHForExactTokens(  amountOut,  path,   zhuAddr1,   mydeadline);\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        uint[] memory amounts = uniswpair.swapETHForExactTokens.value(msg.value)(amountOut, path, zhuAddr1, mydeadline);\n        mintBurnCtoken(path, amounts);\n\n        IERC20 ierc202 = IERC20(_addr2);\n        if (path[1] != dgeContractAddr) {\n            ierc202.transfer(msg.sender, amounts[1]);\n        }\n\n        return amounts;\n    }\n\n    //dge网站赎回\n    //  function myRemoveLiquidityETH(address token, uint _ethAmount, uint _tokenAmount, uint amountTokenMin, uint amountETHMin) public returns(uint256 _amountCt, uint _amountToken, uint _amountETH) { \n    //      (uint amountToken, uint amountETH) = _removeLiquidityETH(token, _ethAmount * _tokenAmount, amountTokenMin, amountETHMin, msg.sender, mydeadline);\n    //      uint256 amountCt = amountToken / 2;\n    //      _burnToken(msg.sender, amountCt);\n    //     dgeWebExAmountT1[msg.sender]['ETH'] -= amountETH;\n    //     dgeWebExAmountT2[msg.sender]['ETH'] -= amountCt;\n    //     return (amountCt, amountToken, amountETH);\n    //  }\n    //设置币种列表,大写\n    function setCoinName(address _index, string memory _name) public onlyGovenors1 returns(bool _success) {\n        coinName[_index] = _name;\n        return true;\n    }\n    function getCoinName(address _index) public view returns(string memory _name) {\n        return coinName[_index];\n    }\n   \n    //设置交易对ADDr\n    function setAddrs(address _zhuAddr1) public onlyGovenors1 returns(bool _success) {\n        zhuAddr1 = _zhuAddr1;\n        return true;\n    }\n    //设置交易对ADDr\n    function setAddrs2(address _ctokenAddr, address _weth, address _dgeContractAddr1 , address _dgeContractAddr, address _exPairsCtokenAddr, \n    address _uniswapV2Router02Addr, uint256 _miniDealineTime, uint256 _mydeadline,uint256 _interestRatetoUser) public onlyGovenors1 returns(bool _success) {\n        ctokenAddr = _ctokenAddr;\n        weth = _weth;\n        dgeContractAddr1 = _dgeContractAddr1;\n        dgeContractAddr = _dgeContractAddr;\n        exPairsCtokenAddr = _exPairsCtokenAddr;\n        uniswapV2Router02Addr = _uniswapV2Router02Addr;\n        miniDealineTime = _miniDealineTime;\n        mydeadline = _mydeadline;\n        interestRatetoUser=_interestRatetoUser;\n        return true;\n    }\n\n    //utils\n    //1  swapExactTokensForTokens  //path = dge1:dge2,so user send dge1 amount ,get dge2 amount out , dge1=>dge2 ok\n    function _swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] memory path, address to, uint deadline) internal returns(uint[] memory amounts) {\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        return uniswpair.swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline);\n    }\n    //2  swapTokensForExactTokens  //path =  dge1:dge2, so user want get dge2 amount ,get dge1 need amount , dge1=>dge2 ok\n    function _swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] memory path, address to, uint deadline) internal returns(uint[] memory amounts) {\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        return uniswpair.swapTokensForExactTokens(amountOut, amountInMax, path, to, deadline);\n    }\n    //3  swapExactETHForTokens   //path = eth:dge1,so user send value ,get dge1 amount out  , eth=>dge1 ok\n    function _swapExactETHForTokens(uint amountOutMin, address[] memory path, address to, uint deadline) internal returns(uint[] memory amounts) {\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        return uniswpair.swapExactETHForTokens.value(msg.value)(amountOutMin, path, to, deadline);\n    }\n    //4  swapTokensForExactETH  //path = dge1:eth,so user send token ,get eth amount out  , dge1 => eth ok\n    function _swapTokensForExactETH(uint amountOut, uint amountInMax, address[] memory path, address to, uint deadline) internal returns(uint[] memory amounts) {\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        return uniswpair.swapTokensForExactETH(amountOut, amountInMax, path, to, deadline);\n    }\n    //5  swapExactTokensForETH  //path = dge1:eth,so user send token ,get eth amount out  , dge1 => eth ok\n    function _swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] memory path, address to, uint deadline) internal returns(uint[] memory amounts) {\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        return uniswpair.swapExactTokensForETH(amountIn, amountOutMin, path, to, deadline);\n    }\n\n    //6  swapETHForExactTokens  //path = eth:dge1,so user send value ,get dge1 amount out  , eth=>dge1 ok\n    function _swapETHForExactTokens(uint amountOut, address[] memory path, address to, uint deadline) public payable returns(uint[] memory amounts) {\n        IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        return uniswpair.swapETHForExactTokens(amountOut, path, to, deadline);\n    }\n    //path = _dgeContractAddr1:::_dgeContractAddr1N ,  _dgeContractAddr1=存入币种.... _dgeContractAddr1N=换出币种\n    function mintBurnCtoken(address[] memory _dgeContractAddr1, uint[] memory _dge1Amount) internal returns(bool _success) {\n        //销毁ctoken\n        if (_dgeContractAddr1[0] == dgeContractAddr) {\n            _burnToken(msg.sender, _dge1Amount[0]);\n            dgeWebExAmountT1[msg.sender][coinName[_dgeContractAddr1[1]]] =(dgeWebExAmountT1[msg.sender][coinName[_dgeContractAddr1[1]]]).sub(_dge1Amount[1]);\n            dgeWebExAmountT2[msg.sender][coinName[_dgeContractAddr1[1]]] =(dgeWebExAmountT2[msg.sender][coinName[_dgeContractAddr1[1]]]).sub(_dge1Amount[0]);\n        } else if (_dgeContractAddr1[1] == dgeContractAddr) {\n            _mintCtoken(msg.sender, _dge1Amount[1]);\n            dgeWebExAmountT1[msg.sender][coinName[_dgeContractAddr1[0]]] =(dgeWebExAmountT1[msg.sender][coinName[_dgeContractAddr1[0]]]).add(_dge1Amount[0]);\n            dgeWebExAmountT2[msg.sender][coinName[_dgeContractAddr1[0]]] =(dgeWebExAmountT2[msg.sender][coinName[_dgeContractAddr1[0]]]).add(_dge1Amount[1]);\n        } else {}\n        return true;\n    }\n      //path = _dgeContractAddr1:::_dgeContractAddr1N ,  _dgeContractAddr1=存入币种.... _dgeContractAddr1N=换出币种\n    function mintBurnCtokenWithdraw(address[] memory _dgeContractAddr1, uint[] memory _dge1Amount) internal returns(bool _success) {\n        //销毁ctoken\n        if (_dgeContractAddr1[0] == dgeContractAddr) {\n            _burnToken(msg.sender, _dge1Amount[0]);\n        } else if (_dgeContractAddr1[1] == dgeContractAddr) {\n            _mintCtoken(msg.sender, _dge1Amount[1]);\n        } else {}\n        return true;\n    }\n    //pay dge shouyi to user,return totalrate ;\n    function payEarningDgeAllRateToSender(uint256 _dge1Amount) public view returns(uint256 _rateAll) {\n        ICToken ict = ICToken(ctokenAddr); (uint256 _typesCount) = ict.getTypesCount(msg.sender);\n        //1000 * (74390.8362 / 72000) * 0.72 * （5*10-8）* 5760 = 0.21 USD = 0.2975 DGE\n        uint256 totalAmount = 0;\n        uint256 totalrateAmount = 0;\n        uint256 leftAmount = _dge1Amount;\n        for (uint i = 1; i <= _typesCount; i++) { \n             (uint256 _balanceOf,, uint256 _rate, uint256 _Blocknum) = ict.getCTokenAddrInfos(i, msg.sender);\n            if (leftAmount >= _balanceOf) {\n                leftAmount =(leftAmount).sub(_balanceOf);\n                totalAmount =totalAmount.add(_balanceOf);\n            //    totalrateAmount =(totalrateAmount).add((_balanceOf).mul(_rate).mul(10000000000).mul((block.timestamp.sub(_creatTime))).div(31536000));\n                totalrateAmount =(totalrateAmount).add((_balanceOf).mul(_rate).mul(10000000000).mul(block.number.sub(_Blocknum)));\n            } else {\n                totalAmount =(totalAmount).add(leftAmount);\n              //  totalrateAmount =(totalrateAmount).add((leftAmount).mul(_rate).mul(10000000000).mul((block.timestamp.sub(_creatTime))).div(31536000));\n                totalrateAmount =(totalrateAmount).add((leftAmount).mul(_rate).mul(10000000000).mul(block.number.sub(_Blocknum)));\n            }\n        }\n        uint256 rateAll = totalrateAmount.div(totalAmount).div(10000000000);\n        return rateAll;\n    }\n\n    function utilCompareInternal(string memory a, string memory b) internal pure returns(bool) {\n        if (bytes(a).length != bytes(b).length) {\n            return false;\n        }\n        for (uint i = 0; i < bytes(a).length; i++) {\n            if (bytes(a)[i] != bytes(b)[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //向当前合约账户转账\n    function _transferETHToThisContractByValue() public payable {\n        address addrthis = address(this);\n        address payable payaddrthis = address(uint160(addrthis));\n        payaddrthis.transfer(msg.value);\n    }\n    //发送ctoken\n    function _mintCtoken(address target, uint256 mintedAmount) internal {\n        ICToken ict = ICToken(ctokenAddr);\n        ict.mintToken(target, mintedAmount);\n    }\n    function _burnToken(address target, uint256 burnAmount) internal {\n        ICToken ict = ICToken(ctokenAddr);\n        ict.burnToken(target, burnAmount);\n    }\n  \n    event EFunction(address, uint);\n    receive() external payable {\n        emit EFunction(msg.sender, msg.value);\n    }\n    //withdraw util\n     function myswapExactTokensForETHforWhithdraw(uint amountIn, address _addr1, address _addr2) internal returns(uint[] memory _amounts) {\n        uint amountOutMin = 1;\n        // address _addr1,address _addr2,\n        address[] memory path;\n        path = new address[](2);\n        path[0] = _addr1;\n        path[1] = _addr2;\n\n        //IERC20 ierc20 = IERC20(_tokenIndex);\n        IERC20 ierc201 = IERC20(path[0]);\n\n        ierc201.approve(uniswapV2Router02Addr, amountIn);\n        uint[] memory amounts = _swapExactTokensForETH(amountIn, amountOutMin, path, zhuAddr1, mydeadline);\n        mintBurnCtokenWithdraw(path, amounts);\n\n        // address addrthis = address(this);\n        // address payable payaddrthis = address(uint160(addrthis));\n        // require(ierc201.allowance(msg.sender, payaddrthis) >= amountIn, \"ierc201.allowance(msg.sender, payaddrthis) is insufficient\");\n        // ierc201.transferFrom(msg.sender, payaddrthis, amountIn);\n        // msg.sender.transfer(amounts[1]);\n\n        return amounts;\n    }\n     function myswapExactTokensForTokensforWhithdraw(address _addr1, address _addr2, uint amountIn) internal returns(uint[] memory _amounts) {\n        uint amountOutMin = 1;\n        // address _addr1,address _addr2,\n        address[] memory path;\n        path = new address[](2);\n        path[0] = _addr1;\n        path[1] = _addr2;\n\n        //IERC20 ierc20 = IERC20(_tokenIndex);\n        //  IDGE idge1 = IDGE(dgeContractAddr1);\n        //  idge1.approve(uniswapV2Router02Addr, amountIn);\n        //  IDGE idge2 = IDGE(dgeContractAddr2);\n        IERC20 ierc201 = IERC20(_addr1);\n        ierc201.approve(uniswapV2Router02Addr, amountIn);\n\n        //    IUniswapV2Router02 uniswpair = IUniswapV2Router02(uniswapV2Router02Addr);\n        //   uint256 amountADesired = uniswpair.getAmountsOut(amountIn, path)[1];\n        //   ierc202.approve(uniswapV2Router02Addr, amountADesired);\n        uint[] memory amounts = _swapExactTokensForTokens(amountIn, amountOutMin, path, zhuAddr1, mydeadline);\n        mintBurnCtokenWithdraw(path, amounts);\n\n        // address addrthis = address(this);\n        // address payable payaddrthis = address(uint160(addrthis));\n        // require(ierc201.allowance(msg.sender, payaddrthis) >= amountIn, \"ierc201.allowance(msg.sender, payaddrthis) is insufficient\");\n        // ierc201.transferFrom(msg.sender, payaddrthis, amountIn);\n\n        // IERC20 ierc202 = IERC20(_addr2);\n        // if (path[1] != dgeContractAddr) {\n        //     ierc202.transfer(msg.sender, amounts[1]);\n        // }\n\n        return amounts;\n    }\n  \n\n}"
    },
    "browser/ICToken.sol": {
      "content": "pragma solidity >= 0.6.2 < 0.7.0;\ninterface ICToken {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event BurnTokenSuccess(address indexed _from, address indexed _to, uint256 _value);\n\n    function name() external view returns(string memory);\n    function symbol() external view returns(string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint);\n    function balanceOf(address owner) external view returns(uint);\n    function getRate() external view returns(uint256 _rate);\n    function setRate(uint256 _rate) external  returns(bool _success);\n    function getCTokenAddrInfos(uint256 _index, address _target) external view returns(uint256 _balanceOf, uint256 _creatTime, uint256 _rate, uint256 _blocknum);\n    function getTypesCount(address _target) external view returns(uint256 _typesCount);\n    function mintToken(address target, uint256 mintedAmount) external; //  public onlyGovenors1\n    function burnToken(address target, uint256 burnAmount) external; // external   onlyGovenors1\n    function burnFrom(address account, uint256 amount) external;\n    function transfer(address _to, uint256 _value) external returns(bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns(bool success);\n    function approve(address _spender, uint256 _value) external returns(bool success);\n    function allowance(address _owner, address _spender) external view returns(uint256 remaining);\n}"
    },
    "browser/IDGE.sol": {
      "content": "pragma solidity >= 0.6.2 < 0.7.0;\ninterface IDGE {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external view returns(string memory);\n    function symbol() external view returns(string memory);\n    function decimals() external view returns(uint8);\n    function totalSupply() external view returns(uint);\n    function balanceOf(address owner) external view returns(uint);\n    function mintToken(address target, uint256 mintedAmount) external; // public onlyGovenors1\n    function burnToken(address target, uint256 burnAmount) external; // public onlyGovenors1\n    function burnFrom(address account, uint256 amount) external;\n    function transfer(address _to, uint256 _value) external returns(bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns(bool success);\n    function approve(address _spender, uint256 _value) external returns(bool success);\n    function allowance(address _owner, address _spender) external view returns(uint256 remaining);\n}"
    },
    "browser/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.2 < 0.7.0;\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "browser/IUniswapV2Router01.sol": {
      "content": "pragma solidity >= 0.6.2 < 0.7.0;\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "browser/IUniswapV2Router02.sol": {
      "content": "pragma solidity >= 0.6.2 < 0.7.0;\nimport './IUniswapV2Router01.sol';\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "browser/Owned.sol": {
      "content": "pragma solidity >= 0.6.2 < 0.7.0;\n//设置代币控制合约的管理员\ncontract Owned {\n    // modifier(条件)，表示必须是权力所有者才能do something，类似administrator的意思\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _; //do something\n    }\n    //权力所有者\n    address public owner;\n    //合约创建的时候执行，执行合约的人是第一个owner\n    constructor() public {\n        owner = msg.sender;\n    }\n    //新的owner,初始为空地址，类似null\n    address newOwner = address(0);\n\n    //更换owner成功的事件\n    event OwnerUpdate(address _prevOwner, address _newOwner);\n    //现任owner把所有权交给新的owner(需要新的owner调用acceptOwnership方法才会生效)\n    function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != owner);\n        newOwner = _newOwner;\n    }\n    //新的owner接受所有权,权力交替正式生效\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}"
    },
    "browser/SafeMath.sol": {
      "content": "pragma solidity >= 0.6.2 < 0.7.0;\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\t/**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\t\t// benefit is lost if 'b' is also tested.\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 c = a * b;\n\t\trequire(c / a == b);\n\n\t\treturn c;\n\t}\n\n\t/**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0);\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n\n\t/**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b <= a);\n\t\tuint256 c = a - b;\n\n\t\treturn c;\n\t}\n\n\t/**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a);\n\n\t\treturn c;\n\t}\n\n\t/**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b != 0);\n\t\treturn a % b;\n\t}\n}\n"
    }
  }
}