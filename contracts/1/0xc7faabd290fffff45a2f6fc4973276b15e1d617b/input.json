{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Flags.sol": {
      "content": "pragma solidity 0.6.6;\n\n\n/**\n * @title The Owned contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract Owned {\n\n  address public owner;\n  address private pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address _to)\n    external\n    onlyOwner()\n  {\n    pendingOwner = _to;\n\n    emit OwnershipTransferRequested(owner, _to);\n  }\n\n  /**\n   * @dev Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n  {\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = owner;\n    owner = msg.sender;\n    pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @dev Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only callable by owner\");\n    _;\n  }\n\n}\n\ninterface AccessControllerInterface {\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\n}\n\n/**\n * @title SimpleWriteAccessController\n * @notice Gives access to accounts explicitly added to an access list by the\n * controller's owner.\n * @dev does not make any special permissions for externally, see\n * SimpleReadAccessController for that.\n */\ncontract SimpleWriteAccessController is AccessControllerInterface, Owned {\n\n  bool public checkEnabled;\n  mapping(address => bool) internal accessList;\n\n  event AddedAccess(address user);\n  event RemovedAccess(address user);\n  event CheckAccessEnabled();\n  event CheckAccessDisabled();\n\n  constructor()\n    public\n  {\n    checkEnabled = true;\n  }\n\n  /**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n  function hasAccess(\n    address _user,\n    bytes memory\n  )\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return accessList[_user] || !checkEnabled;\n  }\n\n  /**\n   * @notice Adds an address to the access list\n   * @param _user The address to add\n   */\n  function addAccess(address _user)\n    external\n    onlyOwner()\n  {\n    if (!accessList[_user]) {\n      accessList[_user] = true;\n\n      emit AddedAccess(_user);\n    }\n  }\n\n  /**\n   * @notice Removes an address from the access list\n   * @param _user The address to remove\n   */\n  function removeAccess(address _user)\n    external\n    onlyOwner()\n  {\n    if (accessList[_user]) {\n      accessList[_user] = false;\n\n      emit RemovedAccess(_user);\n    }\n  }\n\n  /**\n   * @notice makes the access check enforced\n   */\n  function enableAccessCheck()\n    external\n    onlyOwner()\n  {\n    if (!checkEnabled) {\n      checkEnabled = true;\n\n      emit CheckAccessEnabled();\n    }\n  }\n\n  /**\n   * @notice makes the access check unenforced\n   */\n  function disableAccessCheck()\n    external\n    onlyOwner()\n  {\n    if (checkEnabled) {\n      checkEnabled = false;\n\n      emit CheckAccessDisabled();\n    }\n  }\n\n  /**\n   * @dev reverts if the caller does not have access\n   */\n  modifier checkAccess() {\n    require(hasAccess(msg.sender, msg.data), \"No access\");\n    _;\n  }\n}\n\n/**\n * @title SimpleReadAccessController\n * @notice Gives access to:\n * - any externally owned account (note that offchain actors can always read\n * any contract storage regardless of onchain access control measures, so this\n * does not weaken the access control while improving usability)\n * - accounts explicitly added to an access list\n * @dev SimpleReadAccessController is not suitable for access controlling writes\n * since it grants any externally owned account access! See\n * SimpleWriteAccessController for that.\n */\ncontract SimpleReadAccessController is SimpleWriteAccessController {\n\n  /**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n  function hasAccess(\n    address _user,\n    bytes memory _calldata\n  )\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\n  }\n\n}\n\ninterface FlagsInterface {\n  function getFlag(address) external view returns (bool);\n  function getFlags(address[] calldata) external view returns (bool[] memory);\n  function raiseFlag(address) external;\n  function raiseFlags(address[] calldata) external;\n  function lowerFlags(address[] calldata) external;\n  function setRaisingAccessController(address) external;\n}\n\n/**\n * @title The Flags contract\n * @notice Allows flags to signal to any reader on the access control list.\n * The owner can set flags, or designate other addresses to set flags. The\n * owner must turn the flags off, other setters cannot. An expected pattern is\n * to allow addresses to raise flags on themselves, so if you are subscribing to\n * FlagOn events you should filter for addresses you care about.\n */\ncontract Flags is FlagsInterface, SimpleReadAccessController {\n\n  AccessControllerInterface public raisingAccessController;\n\n  mapping(address => bool) private flags;\n\n  event FlagRaised(\n    address indexed subject\n  );\n  event FlagLowered(\n    address indexed subject\n  );\n  event RaisingAccessControllerUpdated(\n    address indexed previous,\n    address indexed current\n  );\n\n  /**\n   * @param racAddress address for the raising access controller.\n   */\n  constructor(\n    address racAddress\n  )\n    public\n  {\n    setRaisingAccessController(racAddress);\n  }\n\n  /**\n   * @notice read the warning flag status of a contract address.\n   * @param subject The contract address being checked for a flag.\n   * @return A true value indicates that a flag was raised and a\n   * false value indicates that no flag was raised.\n   */\n  function getFlag(address subject)\n    external\n    view\n    override\n    checkAccess()\n    returns (bool)\n  {\n    return flags[subject];\n  }\n\n  /**\n   * @notice read the warning flag status of a contract address.\n   * @param subjects An array of addresses being checked for a flag.\n   * @return An array of bools where a true value for any flag indicates that\n   * a flag was raised and a false value indicates that no flag was raised.\n   */\n  function getFlags(address[] calldata subjects)\n    external\n    view\n    override\n    checkAccess()\n    returns (bool[] memory)\n  {\n    bool[] memory responses = new bool[](subjects.length);\n    for (uint256 i = 0; i < subjects.length; i++) {\n      responses[i] = flags[subjects[i]];\n    }\n    return responses;\n  }\n\n  /**\n   * @notice enable the warning flag for an address.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subject The contract address whose flag is being raised\n   */\n  function raiseFlag(address subject)\n    external\n    override\n  {\n    require(allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    tryToRaiseFlag(subject);\n  }\n\n  /**\n   * @notice enable the warning flags for multiple addresses.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subjects List of the contract addresses whose flag is being raised\n   */\n  function raiseFlags(address[] calldata subjects)\n    external\n    override\n  {\n    require(allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    for (uint256 i = 0; i < subjects.length; i++) {\n      tryToRaiseFlag(subjects[i]);\n    }\n  }\n\n  /**\n   * @notice allows owner to disable the warning flags for multiple addresses.\n   * @param subjects List of the contract addresses whose flag is being lowered\n   */\n  function lowerFlags(address[] calldata subjects)\n    external\n    override\n    onlyOwner()\n  {\n    for (uint256 i = 0; i < subjects.length; i++) {\n      address subject = subjects[i];\n\n      if (flags[subject]) {\n        flags[subject] = false;\n        emit FlagLowered(subject);\n      }\n    }\n  }\n\n  /**\n   * @notice allows owner to change the access controller for raising flags.\n   * @param racAddress new address for the raising access controller.\n   */\n  function setRaisingAccessController(\n    address racAddress\n  )\n    public\n    override\n    onlyOwner()\n  {\n    address previous = address(raisingAccessController);\n\n    if (previous != racAddress) {\n      raisingAccessController = AccessControllerInterface(racAddress);\n\n      emit RaisingAccessControllerUpdated(previous, racAddress);\n    }\n  }\n\n\n  // PRIVATE\n\n  function allowedToRaiseFlags()\n    private\n    view\n    returns (bool)\n  {\n    return msg.sender == owner ||\n      raisingAccessController.hasAccess(msg.sender, msg.data);\n  }\n\n  function tryToRaiseFlag(address subject)\n    private\n  {\n    if (!flags[subject]) {\n      flags[subject] = true;\n      emit FlagRaised(subject);\n    }\n  }\n\n}"
    }
  }
}