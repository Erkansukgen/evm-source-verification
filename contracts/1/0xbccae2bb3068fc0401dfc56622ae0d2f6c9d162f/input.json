{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.0;\n\ninterface IERC20 {\n\n  function totalSupply() external view returns (uint);\n  function balanceOf(address tokenOwner) external view returns (uint balance);\n  function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n  function transfer(address to, uint tokens) external returns (bool success);\n  function approve(address spender, uint tokens) external returns (bool success);\n  function transferFrom(address from, address to, uint tokens) external returns (bool success);\n\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.0;\n\ncontract Ownable {\n\n  address public owner;\n  address public transactionFee;\n  address public buyBack;\n\n  event OwnershipTransferred(address newOwner);\n  event TransactionFeeTransferred(address newTransactionFee);\n  event BuyBackTransferred(address newBuyBack);\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, 'You are not the owner!');\n    _;\n  }\n\n  function transferOwnership(address newOwner) onlyOwner internal {\n    owner = newOwner;\n  }\n\n  function transferTransactionFee(address newTransactionFee) onlyOwner internal {\n    transactionFee = newTransactionFee;\n  }\n\n  function transferBuyBack(address newBuyBack) onlyOwner internal {\n    buyBack = newBuyBack;\n  }\n\n}"},"SafeMathLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.0;\n\nlibrary SafeMath {\n\n  function add(uint a, uint b) internal pure returns(uint) {\n    uint c = a + b;\n    require(c >= a, \"Sum overflow!\");\n    return c;\n  }\n\n  function sub(uint a, uint b) internal pure returns(uint) {\n    uint c = a - b;\n    require(c <= a, \"Sub underflow!\");\n    return c;\n  }\n\n  function mul(uint a, uint b) internal pure returns(uint) {\n    if(a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    require(c / a == b, \"Mul overflow!\");\n    return c;\n  }\n  \n  function div(uint a, uint b) internal pure returns(uint) {\n    uint c = a / b;\n    return c;\n  }\n\n}"},"TreasuryBondsPlus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.0;\npragma experimental ABIEncoderV2;\nimport './IERC20.sol';\nimport './Ownable.sol';\nimport './SafeMathLib.sol';\n\ncontract TreasuryBondsPlus is Ownable, IERC20 {\n\n  using SafeMath for uint;\n\n  string public constant name = 'Treasury Bonds Plus';\n  string public constant symbol = 'TB+';\n  uint8 public constant decimals = 2;\n\n  uint private _totalSupply;\n  uint public tokenPrice;\n\n  struct PurchaseRecord {\n    uint date;\n    uint quantity;\n  }\n\n  mapping(address => uint) private _balances;\n  mapping(address => mapping(address => uint)) private _allowed;\n  mapping(address => PurchaseRecord[]) private _purchaseRecords;\n  mapping(address => bool) private _approvedKYC;\n  mapping(uint8 => uint8) public yieldPerMonth;\n\n  event Mint(address indexed to, uint tokens);\n  event Burn(address indexed account, uint tokens);\n  event Repurchase(address indexed tokenOwner, uint tokens);\n\n  constructor(address _transactionFee, address _buyBack) {\n    _totalSupply = 200000 * 10 **uint(decimals);\n    tokenPrice = 1; // 1 Dollar\n    transactionFee = _transactionFee;\n    buyBack = _buyBack;\n\n    for (uint8 i=12; i <= 120; i++) {\n      uint8 mpy;\n      if (i <= 23) mpy = 50; // 0,50 %\n      else if (i <= 35) mpy = 60; // 0,60 %\n      else if (i <= 47) mpy = 70; // 0,70 %\n      else if (i <= 59) mpy = 80; // 0,80 %\n      else if (i <= 71) mpy = 90; // 0,90 %\n      else if (i <= 83) mpy = 100; // 1,00 %\n      else if (i <= 95) mpy = 120; // 1,20 %\n      else if (i <= 107) mpy = 140; // 1,40 %\n      else if (i <= 119) mpy = 160; // 1,60 %\n      else mpy = 180; // 1,80 %\n      yieldPerMonth[i] = mpy;\n    }\n\n    _balances[owner] = _totalSupply;\n    emit Transfer(address(0), owner, _totalSupply);\n  }\n\n  function totalSupply() public override view returns (uint) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address tokenOwner) public override view returns (uint balance) {\n    return _balances[tokenOwner];\n  }\n\n  function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n    return _allowed[tokenOwner][spender];\n  }\n\n  function transfer(address to, uint tokens) public override returns (bool success) {  \n    uint tax = 0;\n    if (msg.sender != owner) {\n      require(tokens >= 100 * 10 **uint(decimals), 'The minimum token quantity is 100.');\n      tax = _setTax(tokens);\n    } else require(tokens >= 1 * 10 ** uint(decimals), 'The minimum that can be sold is 1.');\n\n    _transfer(msg.sender, to, tokens, tax);\n    return true;\n  }\n\n  function approve(address spender, uint tokens) public override returns (bool success) {\n    require(msg.sender != address(0), 'Invalid address!');\n    require(spender != address(0), 'Invalid address!');\n\n    _allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n    require(tokens >= 100 * 10 **uint(decimals), 'The minimum quantity of tokens that can be transferred is 100.');\n    require(_allowed[from][msg.sender] >= tokens, 'Quantity of tokens allowed is insufficient!');\n    require(to == msg.sender, 'The receiving address must be the same as the one calling the function!');\n\n    uint tax = _setTax(tokens);\n    _transfer(from, to, tokens, tax);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\n    return true;\n  }\n\n  function mint(address to, uint tokens) public onlyOwner {\n    require(to != address(0), 'Invalid address!');\n\n    _balances[to] = _balances[to].add(tokens);\n    _totalSupply = _totalSupply.add(tokens);\n    emit Mint(to, tokens);\n  }\n\n  function burn(address account, uint tokens) public onlyOwner {\n    require(account != address(0), 'Invalid address!');\n    require(_balances[account] >= tokens, 'Account balance is less than the number of tokens');\n\n    _balances[account] = _balances[account].sub(tokens);\n    _totalSupply = _totalSupply.sub(tokens);\n    emit Burn(account, tokens);\n  }\n\n  function repurchase(address tokenOwner, uint tokens) public onlyOwner returns (bool success) {\n    require(_balances[tokenOwner] >= tokens, 'Insufficient tokens!');\n\n    _balances[tokenOwner] = _balances[tokenOwner].sub(tokens);\n    _balances[buyBack] = _balances[buyBack].add(tokens);\n    \n    emit Repurchase(tokenOwner, tokens);\n    return true;\n  }\n\n  function purchaseRecords(address tokenOwner) public view onlyOwner returns (PurchaseRecord[] memory) {\n    return _purchaseRecords[tokenOwner];\n  }\n\n  function approveKYC(address account) public onlyOwner returns (bool success) {\n    require(!(_approvedKYC[account]), 'The address already exists!');\n\n    _approvedKYC[account] = true;\n    return true;\n  }\n\n  function getApprovedKYC(address account) public view onlyOwner returns (bool status) {\n    return _approvedKYC[account];\n  }\n\n  function newOwner(address account) public onlyOwner returns (bool success) {\n    require(account != owner, 'The address of the new owner must be different from the current one.');\n\n    address oldOwner = owner;\n    transferOwnership(account);\n    _balances[account] = _balances[oldOwner];\n    _balances[oldOwner] = 0;\n    OwnershipTransferred(account);\n    return true;\n  }\n\n  function newTransactionFee(address account) public onlyOwner returns (bool success) {\n    require(account != transactionFee, 'The address of the new transaction_fee must be different from the current one.');\n\n    address oldTransactionFee = transactionFee;\n    transferTransactionFee(account);\n    _balances[account] = _balances[oldTransactionFee];\n    _balances[oldTransactionFee] = 0;\n    TransactionFeeTransferred(account);\n    return true;\n  }\n\n  function newBuyBack(address account) public onlyOwner returns (bool success) {\n    require(account != buyBack, 'the address of the new buy_back must be different from the current one.');\n\n    address oldBuyBack = buyBack;\n    transferBuyBack(account);\n    _balances[account] = _balances[oldBuyBack];\n    _balances[oldBuyBack] = 0;\n    BuyBackTransferred(account);\n    return true;\n  }\n\n  function _setTax(uint tokens) private pure returns (uint) {\n    uint tokensInPercentage = tokens / 100;\n    uint tax;\n\n    if (tokens <= 10000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 2; // 0,50%\n    else if (tokens <= 50000 * 10 **uint(decimals)) tax = tokensInPercentage * 7 / 20; // 0,35%\n    else if (tokens <= 100000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 4; // 0,25%\n    else if (tokens <= 1000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 5; // 0,20%\n    else if (tokens <= 10000000 * 10 **uint(decimals)) tax = tokensInPercentage * 9 / 50; // 0,18%\n    else if (tokens <= 50000000 * 10 **uint(decimals)) tax = tokensInPercentage * 3 / 20; // 0,15%\n    else if (tokens <= 100000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 10; // 0,10%\n    else if (tokens <= 300000000 * 10 **uint(decimals)) tax = tokensInPercentage * 7 / 100; // 0,07%\n    else if (tokens <= 500000000 * 10 **uint(decimals)) tax = tokensInPercentage * 3 / 50; // 0,06%\n    else if (tokens <= 1000000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 20; // 0,05%\n    else tax = tokensInPercentage * 1 / 25; // 0,04%\n\n    return tax;\n  }\n\n  function _transfer(address sender, address recipient, uint tokens, uint tax) private {\n    require(sender != address(0), 'Invalid address!');\n    require(recipient != address(0), 'Invalid address!');\n    require(sender != recipient, 'Addresses must be different!');\n    require(_balances[sender] >= tokens, 'Insufficient tokens!');\n\n    uint tokensWithTax = tokens;\n    if (tax > 0) {\n      tokensWithTax = tokens - tax;\n      _balances[transactionFee] = _balances[transactionFee].add(tax);\n    }\n    \n    _balances[sender] = _balances[sender].sub(tokens);\n    _balances[recipient] = _balances[recipient].add(tokensWithTax);\n      \n    _purchaseRecords[recipient].push(PurchaseRecord({\n      date: block.timestamp,\n      quantity: tokensWithTax\n    }));\n\n    emit Transfer(sender, recipient, tokens);\n  }\n\n}"}}}