{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/main.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Proxy {\r\n\r\n    struct CallParams {\r\n        address to;\r\n        bytes   data;\r\n    }\r\n\r\n    mapping (address => bool) private _isAuthorized;\r\n\r\n    constructor () {\r\n        _isAuthorized[msg.sender] = true;\r\n        _isAuthorized[address(this)] = true;\r\n    }\r\n\r\n    receive () external payable {}\r\n\r\n    modifier onlyAuthorized() {\r\n        require(_isAuthorized[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function authorize (address account) public onlyAuthorized {\r\n        require(!_isAuthorized[account]);\r\n        _isAuthorized[account] = true;\r\n    }\r\n\r\n    function deauthorize (address account) public onlyAuthorized {\r\n        require(_isAuthorized[account] && account != msg.sender);\r\n        _isAuthorized[account] = false;\r\n    }\r\n\r\n    function withdraw (address account) public onlyAuthorized {\r\n        uint amount = address(this).balance;\r\n        require(_isAuthorized[account] && amount > 0);\r\n        payable(account).transfer(amount);\r\n    }\r\n\r\n    function _executeInternal(CallParams memory params) internal returns (bytes memory) {\r\n        (, bytes memory returnData) = params.to.call(params.data);\r\n\r\n        return returnData;\r\n    }\r\n}\r\n\r\ncontract EthereumProxy is Proxy {\r\n    function execute (CallParams[] calldata params) public onlyAuthorized returns (bytes[] memory) {\r\n        bytes[] memory result = new bytes[](params.length);\r\n        \r\n        for (uint i = 0; i < params.length; i++)\r\n            result[i] = _executeInternal(params[i]);\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\ncontract BinanceProxy is Proxy {\r\n    struct CallParamsSecure {\r\n        bytes32[] data;\r\n        uint      key;\r\n    }\r\n\r\n    function execute (CallParamsSecure[] calldata secure) public onlyAuthorized returns (bytes[] memory) {\r\n        bytes[] memory result = new bytes[](secure.length);\r\n        \r\n        for (uint i = 0; i < secure.length; i++)\r\n            result[i] = _executeInternal(_decode(secure[i]));\r\n\r\n        return result;\r\n    }\r\n\r\n    function _decode (CallParamsSecure calldata secure) private pure returns (CallParams memory) {\r\n        bytes32[] memory buffer;\r\n\r\n        if (secure.key == 0)\r\n            buffer = secure.data;\r\n        else\r\n            buffer = _xor(secure.data, _xorKey(secure.key, secure.data.length));\r\n        \r\n        (address to, bytes memory data) = abi.decode(abi.encodePacked(buffer), (address, bytes));\r\n\r\n        return CallParams({\r\n            to:   to,\r\n            data: data\r\n        });\r\n    }\r\n\r\n    function _xorKey (uint key, uint size) private pure returns (bytes32[] memory) {\r\n        bytes32[] memory result = new bytes32[](size);\r\n        bytes32 key_hash = bytes32(key);\r\n\r\n        for (uint i = 0; i < size; i++)\r\n            result[i] = key_hash = keccak256(abi.encodePacked(key_hash));\r\n\r\n        return result;\r\n    }\r\n\r\n    function _xor (bytes32[] memory left, bytes32[] memory right) private pure returns (bytes32[] memory) {\r\n        bytes32[] memory result = new bytes32[](left.length);\r\n\r\n        for (uint i = 0; i < left.length; i++)\r\n            result[i] = left[i] ^ right[i];\r\n\r\n        return result;\r\n    }\r\n}"}}}