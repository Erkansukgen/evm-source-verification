{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/CloneFactory.sol":{"content":"// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity 0.6.6;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2018 Murray Software, LLC.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), targetBytes)\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}\n"},"browser/EnumerableSet.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"},"browser/ITorro.sol":{"content":"// \"SPDX-License-Identifier: UNLICENSED\"\r\npragma solidity 0.6.6;\r\n\r\n/// @title Interface for ERC-20 Torro governing token.\r\n/// @notice ERC-20 token.\r\n/// @author ORayskiy - @robitnik_TorroDao\r\ninterface ITorro {\r\n\r\n  // Initializer.\r\n\r\n  /// @notice Initializes governing token.\r\n  /// @param dao_ address of cloned DAO.\r\n  /// @param factory_ address of factory.\r\n  /// @param supply_ total supply of tokens.\r\n  function initializeCustom(address dao_, address factory_, uint256 supply_) external;\r\n\r\n  // Public calls.\r\n\r\n  /// @notice Token's name.\r\n  /// @return string name of the token.\r\n  function name() external view returns (string memory);\r\n\r\n  /// @notice Token's symbol.\r\n  /// @return string symbol of the token.\r\n  function symbol() external view returns (string memory);\r\n\r\n  /// @notice Token's decimals.\r\n  /// @return uint8 demials of the token.\r\n  function decimals() external pure returns (uint8);\r\n\r\n  /// @notice Token's total supply.\r\n  /// @return uint256 total supply of the token.\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /// @notice Count of token holders.\r\n  /// @return uint256 number of token holders.\r\n  function holdersCount() external view returns (uint256);\r\n\r\n  /// @notice All token holders.\r\n  /// @return array of addresses of token holders.\r\n  function holders() external view returns (address[] memory);\r\n\r\n  /// @notice Available balance for address.\r\n  /// @param sender_ address to get available balance for.\r\n  /// @return uint256 amount of tokens available for given address.\r\n  function balanceOf(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Staked balance for address.\r\n  /// @param sender_ address to get staked balance for.\r\n  /// @return uint256 amount of staked tokens for given address.\r\n  function stakedOf(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Total balance for address = available + staked.\r\n  /// @param sender_ address to get total balance for.\r\n  /// @return uint256 total amount of tokens for given address.\r\n  function totalOf(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Locked staked balance for address\r\n  /// @param sender_ address to get locked staked balance for.\r\n  /// @return uint256 amount of locked staked tokens for given address.\r\n  function lockedOf(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Spending allowance.\r\n  /// @param owner_ token owner address.\r\n  /// @param spender_ token spender address.\r\n  /// @return uint256 amount of owner's tokens that spender can use.\r\n  function allowance(address owner_, address spender_) external view returns (uint256);\r\n\r\n  /// @notice Unstaked supply of token.\r\n  /// @return uint256 amount of tokens in circulation that are not staked.\r\n  function unstakedSupply() external view returns (uint256);\r\n\r\n  /// @notice Staked supply of token.\r\n  /// @return uint256 amount of tokens in circulation that are staked.\r\n  function stakedSupply() external view returns (uint256);\r\n\r\n  // Public transactions.\r\n\r\n  /// @notice Transfer tokens to recipient.\r\n  /// @param recipient_ address of tokens' recipient.\r\n  /// @param amount_ amount of tokens to transfer.\r\n  /// @return bool true if successful.\r\n  function transfer(address recipient_, uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Approve spender to spend an allowance.\r\n  /// @param spender_ address that will be allowed to spend specified amount of tokens.\r\n  /// @param amount_ amount of tokens that spender can spend.\r\n  /// @return bool true if successful.\r\n  function approve(address spender_, uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Approves DAO to spend tokens.\r\n  /// @param owner_ address whose tokens DAO can spend.\r\n  /// @param amount_ amount of tokens that DAO can spend.\r\n  /// @return bool true if successful.\r\n  function approveDao(address owner_, uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Locks account's staked tokens.\r\n  /// @param owner_ address whose tokens should be locked.\r\n  /// @param amount_ amount of tokens to lock.\r\n  /// @param id_ lock id.\r\n  function lockStakesDao(address owner_, uint256 amount_, uint256 id_) external;\r\n\r\n  /// @notice Unlocks account's staked tokens.\r\n  /// @param owner_ address whose tokens should be unlocked.\r\n  /// @param id_ unlock id.\r\n  function unlockStakesDao(address owner_, uint256 id_) external;\r\n\r\n  /// @notice Transfers tokens from owner to recipient by approved spender.\r\n  /// @param owner_ address of tokens' owner whose tokens will be spent.\r\n  /// @param recipient_ address of recipient that will recieve tokens.\r\n  /// @param amount_ amount of tokens to be spent.\r\n  /// @return bool true if successful.\r\n  function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Increases allowance for given spender.\r\n  /// @param spender_ spender to increase allowance for.\r\n  /// @param addedValue_ extra amount that spender can spend.\r\n  /// @return bool true if successful.\r\n  function increaseAllowance(address spender_, uint256 addedValue_) external returns (bool);\r\n\r\n  /// @notice Decreases allowance for given spender.\r\n  /// @param spender_ spender to decrease allowance for.\r\n  /// @param subtractedValue_ removed amount that spender can spend.\r\n  /// @return bool true if successful.\r\n  function decreaseAllowance(address spender_, uint256 subtractedValue_) external returns (bool);\r\n\r\n  /// @notice Stake tokens.\r\n  /// @param amount_ amount of tokens to be staked.\r\n  /// @return bool true if successful.\r\n  function stake(uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Unstake tokens.\r\n  /// @param amount_ amount of tokens to be unstaked.\r\n  /// @return bool true if successful.\r\n  function unstake(uint256 amount_) external returns (bool);\r\n\r\n  /// @notice Functionality for DAO to add benefits for all stakers.\r\n  /// @param amount_ amount of wei to be shared among stakers.\r\n  function addBenefits(uint256 amount_) external;\r\n\r\n  /// @notice Sets DAO and Factory addresses.\r\n  /// @param dao_ DAO address that this token governs.\r\n  /// @param factory_ Factory address.\r\n  function setDaoFactoryAddresses(address dao_, address factory_) external;\r\n\r\n  /// @notice Functionality for owner to burn tokens.\r\n  /// @param amount_ amount of tokens to burn.\r\n  function burn(uint256 amount_) external;\r\n}\r\n"},"browser/ITorroDao.sol":{"content":"// \"SPDX-License-Identifier: UNLICENSED\"\r\npragma solidity 0.6.6;\r\n\r\n/// @title DAO for proposals, voting and execution.\r\n/// @notice Interface for creation, voting and execution of proposals.\r\n/// @author ORayskiy - @robitnik_TorroDao\r\ninterface ITorroDao {\r\n\r\n  // Enums.\r\n\r\n  /// @notice Enum of available proposal functions.\r\n  enum DaoFunction {\r\n    BUY,\r\n    SELL,\r\n    ADD_LIQUIDITY,\r\n    REMOVE_LIQUIDITY,\r\n    ADD_ADMIN,\r\n    REMOVE_ADMIN,\r\n    INVEST,\r\n    WITHDRAW,\r\n    BURN,\r\n    SET_SPEND_PCT,\r\n    SET_MIN_PCT,\r\n    SET_QUICK_MIN_PCT,\r\n    SET_MIN_HOURS,\r\n    SET_MIN_VOTES,\r\n    SET_FREE_PROPOSAL_DAYS,\r\n    SET_BUY_LOCK_PER_ETH\r\n  }\r\n\r\n  // Initializer.\r\n  \r\n  /// @notice Initializer for DAO clones.\r\n  /// @param torroToken_ main torro token address.\r\n  /// @param governingToken_ torro token clone that's governing this dao.\r\n  /// @param factory_ torro factory address.\r\n  /// @param creator_ creator of cloned DAO.\r\n  /// @param maxCost_ maximum cost of all governing tokens for cloned DAO.\r\n  /// @param executeMinPct_ minimum percentage of votes needed for proposal execution.\r\n  /// @param votingMinHours_ minimum lifetime of proposal before it closes.\r\n  /// @param isPublic_ whether cloned DAO has public visibility.\r\n  /// @param hasAdmins_ whether cloned DAO has admins, otherwise all stakers are treated as admins.\r\n  function initializeCustom(\r\n    address torroToken_,\r\n    address governingToken_,\r\n    address factory_,\r\n    address creator_,\r\n    uint256 maxCost_,\r\n    uint256 executeMinPct_,\r\n    uint256 votingMinHours_,\r\n    bool isPublic_,\r\n    bool hasAdmins_\r\n  ) external;\r\n\r\n  // Public calls.\r\n\r\n  /// @notice Address of DAO creator.\r\n  /// @return DAO creator address.\r\n  function daoCreator() external view returns (address);\r\n\r\n  /// @notice Amount of tokens needed for a single vote.\r\n  /// @return uint256 token amount.\r\n  function voteWeight() external view returns (uint256);\r\n\r\n  /// @notice Amount of votes that holder has.\r\n  /// @param sender_ address of the holder.\r\n  /// @return number of votes.\r\n  function votesOf(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Address of the governing token.\r\n  /// @return address of the governing token.\r\n  function tokenAddress() external view returns (address);\r\n\r\n  /// @notice Saved addresses of tokens that DAO is holding.\r\n  /// @return array of holdings addresses.\r\n  function holdings() external view returns (address[] memory);\r\n\r\n  /// @notice Saved addresses of liquidity tokens that DAO is holding.\r\n  /// @return array of liquidity addresses.\r\n  function liquidities() external view returns (address[] memory);\r\n\r\n  /// @notice Calculates address of liquidity token from ERC-20 token address.\r\n  /// @param token_ token address to calculate liquidity address from.\r\n  /// @return address of liquidity token.\r\n  function liquidityToken(address token_) external view returns (address);\r\n\r\n  /// @notice Gets tokens and liquidity token addresses of DAO's liquidity holdings.\r\n  /// @return Arrays of tokens and liquidity tokens, should have the same length.\r\n  function liquidityHoldings() external view returns (address[] memory, address[] memory);\r\n\r\n  /// @notice DAO admins.\r\n  /// @return Array of admin addresses.\r\n  function admins() external view returns (address[] memory);\r\n\r\n  /// @notice DAO balance for specified token.\r\n  /// @param token_ token address to get balance for.\r\n  /// @return uint256 token balance.\r\n  function tokenBalance(address token_) external view returns (uint256);\r\n\r\n  /// @notice DAO balance for liquidity token.\r\n  /// @param token_ token address to get liquidity balance for.\r\n  /// @return uin256 token liquidity balance.\r\n  function liquidityBalance(address token_) external view returns (uint256);\r\n\r\n  /// @notice DAO ethereum balance.\r\n  /// @return uint256 wei balance.\r\n  function availableBalance() external view returns (uint256);\r\n\r\n  /// @notice DAO WETH balance.\r\n  /// @return uint256 wei balance.\r\n  function availableWethBalance() external view returns (uint256);\r\n\r\n  /// @notice Maximum cost for all tokens of cloned DAO.\r\n  /// @return uint256 maximum cost in wei.\r\n  function maxCost() external view returns (uint256);\r\n\r\n  /// @notice Minimum percentage of votes needed to execute a proposal.\r\n  /// @return uint256 minimum percentage of votes.\r\n  function executeMinPct() external view returns (uint256);\r\n\r\n  /// @notice Minimum percentage of votes needed for quick execution of proposal.\r\n  /// @return uint256 minimum percentage of votes.\r\n  function quickExecuteMinPct() external returns (uint256);\r\n\r\n  /// @notice Minimum lifetime of proposal before it closes.\r\n  /// @return uint256 minimum number of hours for proposal lifetime.\r\n  function votingMinHours() external view returns (uint256);\r\n\r\n  /// @notice Minimum votes a proposal needs to pass.\r\n  /// @return uint256 minimum unique votes.\r\n  function minProposalVotes() external view returns (uint256);\r\n\r\n  /// @notice Maximum spend limit on BUY, WITHDRAW and INVEST proposals.\r\n  /// @return uint256 maximum percentage of funds that can be spent.\r\n  function spendMaxPct() external view returns (uint256);\r\n\r\n  /// @notice Interval at which stakers can create free proposals.\r\n  /// @return uint256 number of days between free proposals.\r\n  function freeProposalDays() external view returns (uint256);\r\n\r\n  /// @notice Next free proposal time for staker.\r\n  /// @param sender_ address to check free proposal time for.\r\n  /// @return uint256 unix time of next free proposal or 0 if not available.\r\n  function nextFreeProposal(address sender_) external view returns (uint256);\r\n\r\n  /// @notice Amount of tokens that BUY proposal creator has to lock per each ETH spent in a proposal.\r\n  /// @return uint256 number for tokens per eth spent.\r\n  function lockPerEth() external view returns (uint256);\r\n\r\n  /// @notice Whether DAO is public or private.\r\n  /// @return bool true if public.\r\n  function isPublic() external view returns (bool);\r\n\r\n  /// @notice Whether DAO has admins.\r\n  /// @return bool true if DAO has admins.\r\n  function hasAdmins() external view returns (bool);\r\n\r\n  /// @notice Proposal ids of DAO.\r\n  /// @return array of proposal ids.\r\n  function getProposalIds() external view returns (uint256[] memory);\r\n\r\n  /// @notice Gets proposal info for proposal id.\r\n  /// @param id_ id of proposal to get info for.\r\n  /// @return proposalAddress address for proposal execution.\r\n  /// @return investTokenAddress secondary address for proposal execution, used for investment proposals if ICO and token addresses differ.\r\n  /// @return daoFunction proposal type.\r\n  /// @return amount proposal amount eth/token to use during execution.\r\n  /// @return creator address of proposal creator.\r\n  /// @return endLifetime epoch time when proposal voting ends.\r\n  /// @return votesFor amount of votes for the proposal.\r\n  /// @return votesAgainst amount of votes against the proposal.\r\n  /// @return votes number of stakers that voted for the proposal.\r\n  /// @return executed whether proposal has been executed or not.\r\n  function getProposal(uint256 id_) external view returns (\r\n    address proposalAddress,\r\n    address investTokenAddress,\r\n    DaoFunction daoFunction,\r\n    uint256 amount,\r\n    address creator,\r\n    uint256 endLifetime,\r\n    uint256 votesFor,\r\n    uint256 votesAgainst,\r\n    uint256 votes,\r\n    bool executed\r\n  );\r\n\r\n  /// @notice Whether a holder is allowed to vote for a proposal.\r\n  /// @param id_ proposal id to check whether holder is allowed to vote for.\r\n  /// @param sender_ address of the holder.\r\n  /// @return bool true if voting is allowed.\r\n  function canVote(uint256 id_, address sender_) external view returns (bool);\r\n\r\n  /// @notice Whether a holder is allowed to remove a proposal.\r\n  /// @param id_ proposal id to check whether holder is allowed to remove.\r\n  /// @param sender_ address of the holder.\r\n  /// @return bool true if removal is allowed.\r\n  function canRemove(uint256 id_, address sender_) external view returns (bool);\r\n\r\n  /// @notice Whether a holder is allowed to execute a proposal.\r\n  /// @param id_ proposal id to check whether holder is allowed to execute.\r\n  /// @param sender_ address of the holder.\r\n  /// @return bool true if execution is allowed.\r\n  function canExecute(uint256 id_, address sender_) external view returns (bool);\r\n\r\n  /// @notice Whether a holder is an admin.\r\n  /// @param sender_ address of holder.\r\n  /// @return bool true if holder is an admin (in DAO without admins all holders are treated as such).\r\n  function isAdmin(address sender_) external view returns (bool);\r\n\r\n  // Public transactions.\r\n\r\n  /// @notice Saves new holdings addresses for DAO.\r\n  /// @param tokens_ token addresses that DAO has holdings of.\r\n  function addHoldingsAddresses(address[] calldata tokens_) external;\r\n\r\n  /// @notice Saves new liquidity addresses for DAO.\r\n  /// @param tokens_ token addresses that DAO has liquidities of.\r\n  function addLiquidityAddresses(address[] calldata tokens_) external;\r\n\r\n  /// @notice Creates new proposal.\r\n  /// @param proposalAddress_ main address of the proposal, in investment proposals this is the address funds are sent to.\r\n  /// @param investTokenAddress_ secondary address of the proposal, used in investment proposals to specify token address.\r\n  /// @param daoFunction_ type of the proposal.\r\n  /// @param amount_ amount of funds to use in the proposal.\r\n  /// @param hoursLifetime_ voting lifetime of the proposal.\r\n  function propose(address proposalAddress_, address investTokenAddress_, DaoFunction daoFunction_, uint256 amount_, uint256 hoursLifetime_) external;\r\n\r\n  /// @notice Removes existing proposal.\r\n  /// @param id_ id of proposal to remove.\r\n  function unpropose(uint256 id_) external;\r\n\r\n  /// @notice Cancels buy proposal.\r\n  /// @param id_ buy proposal id to cancel.\r\n  function cancelBuy(uint256 id_) external;\r\n\r\n  /// @notice Voting for multiple proposals.\r\n  /// @param ids_ ids of proposals to vote for.\r\n  /// @param votes_ for or against votes for proposals.\r\n  function vote(uint256[] calldata ids_, bool[] calldata votes_) external;\r\n\r\n  /// @notice Executes a proposal.\r\n  /// @param id_ id of proposal to be executed.\r\n  function execute(uint256 id_) external;\r\n\r\n  /// @notice Buying tokens for cloned DAO.\r\n  function buy() external payable;\r\n\r\n  /// @notice Sell tokens back to cloned DAO.\r\n  /// @param amount_ amount of tokens to sell.\r\n  function sell(uint256 amount_) external;\r\n\r\n  // Owner transactions.\r\n\r\n  /// @notice Sets factory address.\r\n  /// @param factory_ address of TorroFactory.\r\n  function setFactoryAddress(address factory_) external;\r\n\r\n  /// @notice Sets vote weight divider.\r\n  /// @param weight_ weight divider for a single vote.\r\n  function setVoteWeightDivider(uint256 weight_) external;\r\n\r\n  /// @notice Sets new address for router.\r\n  /// @param router_ address for router.\r\n  function setRouter(address router_) external;\r\n\r\n  /// @notice Sets address of new token.\r\n  /// @param token_ token address.\r\n  /// @param torroToken_ address of main Torro DAO token.\r\n  function setNewToken(address token_, address torroToken_) external;\r\n\r\n  /// @notice Migrates balances of current DAO to a new DAO.\r\n  /// @param newDao_ address of the new DAO to migrate to.\r\n  function migrate(address newDao_) external;\r\n\r\n}"},"browser/ITorroFactory.sol":{"content":"// \"SPDX-License-Identifier: UNLICENSED\"\r\npragma solidity 0.6.6;\r\n\r\n/// @title Factory interface with benefits related methods exposed.\r\n/// @notice Interface for claiming, adding and depositing benefits.\r\n/// @author ORayskiy - @robitnik_TorroDao\r\ninterface ITorroFactory {\r\n\r\n  /// @notice Address of the main token.\r\n  /// @return address of the main token.  \r\n  function mainToken() external view returns (address);\r\n\r\n  /// @notice Address of the main DAO.\r\n  /// @return address of the main DAO.\r\n  function mainDao() external view returns (address);\r\n\r\n  /// @notice Checks whether provided address is a valid DAO.\r\n  /// @param dao_ address to check.\r\n  /// @return bool true if address is a valid DAO.\r\n  function isDao(address dao_) external view returns (bool);\r\n\r\n  /// @notice Claim available benefits for holder.\r\n  /// @param amount_ of wei to claim.\r\n  function claimBenefits(uint256 amount_) external;\r\n\r\n  /// @notice Adds withdrawal benefits for holder.\r\n  /// @param recipient_ holder that's getting benefits.\r\n  /// @param amount_ benefits amount to be added to holder's existing benefits.\r\n  function addBenefits(address recipient_, uint256 amount_) external;\r\n  \r\n  /// @notice Depositis withdrawal benefits.\r\n  /// @param token_ governing token for DAO that's depositing benefits.\r\n  function depositBenefits(address token_) external payable;\r\n}\r\n"},"browser/TorroFactory.sol":{"content":"// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity 0.6.6;\n\nimport \"./EnumerableSet.sol\";\n\nimport \"./ITorro.sol\";\nimport \"./ITorroDao.sol\";\nimport \"./ITorroFactory.sol\";\nimport \"./CloneFactory.sol\";\n\n/// @title Factory for creation of DAOs and their governing tokens.\n/// @notice Contract for creation of DAOs and their governing tokens, and handling benefits withdrawal for all available DAO pools.\n/// @author ORayskiy - @robitnik_TorroDao\ncontract TorroFactory is ITorroFactory, CloneFactory {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  uint256 private constant _customSupply = 1e22;\n  address private _owner;\n  address private _torroToken;\n  address private _torroDao;\n  mapping (address => uint256) private _benefits;\n  mapping (address => address) private _pools;\n  EnumerableSet.AddressSet private _poolTokens;\n  uint256 _createPrice;\n  uint256 _minMaxCost;\n  \n  /// @notice Event for dispatching when holder claimed benefits.\n  /// @param owner address that claimed benefits.\n  event ClaimBenefits(address indexed owner);\n\n  /// @notice Event for dispatching when new governing token and DAO pool have been created.\n  /// @param token token address.\n  /// @param dao DAO address.\n\tevent PoolCreated(address indexed token, address indexed dao);\n\n  constructor(address torroToken_, address torroDao_) public {\n    _owner = msg.sender;\n    _torroToken = torroToken_;\n    _torroDao = torroDao_;\n    // 0.2 eth\n    _createPrice = 2 * 10**17;\n    _minMaxCost = 1 ether;\n  }\n\n  /// @notice Bodifier for onlyOwner functions.\n  modifier onlyOwner() {\n    require(_owner == msg.sender);\n    _;\n  }\n\n  /// @notice All governing tokens created via factory.\n  /// @return array of all governing token addresses.\n  function poolTokens() public view returns (address[] memory) {\n    uint256 length = _poolTokens.length();\n    address[] memory poolTokenAddresses = new address[](length);\n    for (uint256 i = 0; i < length; i++) {\n      poolTokenAddresses[i] = _poolTokens.at(i);\n    }\n    return poolTokenAddresses;\n  }\n\n  /// @notice Gets DAO address for governing token.\n  /// @param token_ token address to get DAO address for.\n  /// @return DAO address.\n  function poolDao(address token_) public view returns (address) {\n    return _pools[token_];\n  }\n\n  /// @notice Gets addresses of governing tokens that are visible to holder.\n  /// @param holder_ holder address to get available tokens for.\n  /// @return array of token addresses that holder owns or can buy.\n  function poolTokensForHolder(address holder_) public view returns (address[] memory) {\n    uint256 length = _poolTokens.length();\n    if (length == 0) {\n      return new address[](0);\n    }\n    address[] memory poolTokenAddresses = new address[](length);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < length; i++) {\n      address token = _poolTokens.at(i);\n      if (token != address(0x0)) {\n        address dao = _pools[token];\n        if ((ITorro(token).totalOf(holder_) > 0) || ITorroDao(dao).isPublic() || ITorroDao(dao).daoCreator() == holder_) {\n          poolTokenAddresses[pointer++] = token;\n        }\n      }\n    }\n    return poolTokenAddresses;\n  }\n\n  /// @notice Address of the main token.\n  /// @return address of the main token.  \n  function mainToken() public view override returns (address) {\n    return _torroToken;\n  }\n\n  /// @notice Address of the main DAO.\n  /// @return address of the main DAO.\n  function mainDao() public view override returns (address) {\n    return _torroDao;\n  }\n\n  \n  /// @notice Checks whether provided address is a valid DAO.\n  /// @param dao_ address to check.\n  /// @return bool true if address is a valid DAO.\n  function isDao(address dao_) public view override returns (bool) {\n    if (dao_ == _torroDao) {\n      return true;\n    }\n    uint256 length = _poolTokens.length();\n    for (uint256 i = 0; i < length; i++) {\n      if (dao_ == _pools[_poolTokens.at(i)]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /// @notice Gets current price for DAO creation.\n  /// @return uint256 wei price for DAO creation.\n  function price() public view returns (uint256) {\n    return _createPrice;\n  }\n\n  /// @notice Checks available benefits of an address.\n  /// @param sender_ address to check benefits for.\n  /// @return uint256 amount of benefits available.\n  function benefitsOf(address sender_) public view returns (uint256) {\n    return _benefits[sender_];\n  }\n\n  /// @notice Creates a cloned DAO and governing token.\n  /// @param maxCost_ maximum cost of all governing tokens for created DAO.\n  /// @param executeMinPct_ minimum percentage of votes needed for proposal execution.\n  /// @param votingMinHours_ minimum lifetime of proposal before it closes.\n  /// @param isPublic_ whether DAO is publically visible.\n  /// @param hasAdmins_ whether DAO has admins or all holders should be treated as admins.\n  function create(uint256 maxCost_, uint256 executeMinPct_, uint256 votingMinHours_, bool isPublic_, bool hasAdmins_) public payable {\n    // Check that correct payment has been sent for creation.\n    require(msg.value == _createPrice);\n    // Check that maximum cost specified is equal or greater than required minimal maximum cost. \n    require(maxCost_ >= _minMaxCost);\n    \n    // Create clones of main governing token and DAO.\n    address tokenProxy = createClone(_torroToken);\n    address daoProxy = createClone(_torroDao);\n\n    // Initialize governing token and DAO.\n    ITorroDao(daoProxy).initializeCustom(_torroToken, tokenProxy, address(this), msg.sender, maxCost_, executeMinPct_, votingMinHours_, isPublic_, hasAdmins_);\n    ITorro(tokenProxy).initializeCustom(daoProxy, address(this), _customSupply);\n\n    // Save addresses of newly created governing token and DAO.\n    _poolTokens.add(tokenProxy);\n    _pools[tokenProxy] = daoProxy;\n    \n    // Forward payment to factory owner.\n    payable(_owner).transfer(msg.value);\n\n    // Emit event that new DAO pool has been created.\n    emit PoolCreated(tokenProxy, daoProxy);\n  }\n\n  /// @notice Claim available benefits for holder.\n  /// @param amount_ of wei to claim.\n  function claimBenefits(uint256 amount_) public override {\n    // Check that factory has enough eth to pay for withdrawal.\n    require(amount_ <= address(this).balance);\n    // Check that holder has enough benefits to withdraw specified amount.\n    uint256 amount = _benefits[msg.sender];\n    require(amount_ >= amount);\n\n    // Reduce holders available withdrawal benefits.\n    _benefits[msg.sender] = amount - amount_;\n    \n    // Transfer benefits to holder's address.\n    payable(msg.sender).transfer(amount_);\n\n    // Emit event that holder has claimed benefits.\n    emit ClaimBenefits(msg.sender);\n  }\n\n  /// @notice Adds withdrawal benefits for holder.\n  /// @param recipient_ holder that's getting benefits.\n  /// @param amount_ benefits amount to be added to holder's existing benefits.\n  function addBenefits(address recipient_, uint256 amount_) public override {\n    // Check that function is triggered by one of DAO governing tokens.\n    require(_torroToken == msg.sender || _poolTokens.contains(msg.sender));\n    // Add holders benefits.\n    _benefits[recipient_] = _benefits[recipient_] + amount_;\n  }\n\n  /// @notice Depositis withdrawal benefits.\n  /// @param token_ governing token for DAO that's depositing benefits.\n  function depositBenefits(address token_) public override payable {\n    // Check that governing token for DAO that's depositing benefits exists.\n    // And check that benefits deposition is sent by corresponding DAO.\n    if (token_ == _torroToken) {\n      require(msg.sender == _torroDao);\n    } else {\n      require(_poolTokens.contains(token_) && msg.sender == _pools[token_]);\n    }\n    // do nothing\n  }\n\n  /// @notice Creates clone of main DAO and migrates an existing DAO to it.\n  /// @param token_ Governing token that needs to migrate to new dao.\n  function migrate(address token_) public onlyOwner {\n    ITorroDao currentDao = ITorroDao(_pools[token_]);\n    // Create a new clone of main DAO.\n    address daoProxy = createClone(_torroDao);\n    // Initialize it with parameters from existing dao.\n    ITorroDao(daoProxy).initializeCustom(\n      _torroToken,\n      token_,\n      address(this),\n      currentDao.daoCreator(),\n      currentDao.maxCost(),\n      currentDao.executeMinPct(),\n      currentDao.votingMinHours(),\n      currentDao.isPublic(),\n      currentDao.hasAdmins()\n    );\n\n    // Update dao address reference for governing token.\n    _pools[token_] = daoProxy;\n\n    // Update governing token addresses.\n    ITorro(token_).setDaoFactoryAddresses(daoProxy, address(this));\n  }\n\n  /// @notice Sets price of DAO creation.\n  /// @param price_ wei price for DAO creation.\n  function setPrice(uint256 price_) public onlyOwner {\n    _createPrice = price_;\n  }\n\n  /// @notice Sets minimal maximum cost for new DAO creation.\n  /// @param cost_ minimal maximum cost of new DAO.\n  function setMinMaxCost(uint256 cost_) public onlyOwner {\n    _minMaxCost = cost_;\n  }\n\n  /// @notice Transfers ownership of Torro Factory to new owner.\n  /// @param newOwner_ address of new owner.\n  function transferOwnership(address newOwner_) public onlyOwner {\n    _owner = newOwner_;\n  }\n\n  /// @notice Sets address of new Main DAO.\n  /// @param torroDao_ address of new main DAO.\n  function setNewDao(address torroDao_) public onlyOwner {\n    _torroDao = torroDao_;\n  }\n}"}}}