{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Contract_Code_Min.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"SM: overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b <= a, \"SM: overflow\");\r\n        c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        require(c / a == b, \"SM: overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SM: div zero\");\r\n        c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title String\r\n * @dev This integrates the basic functions.\r\n */\r\nlibrary String {\r\n    /**\r\n     * @dev determine if strings are equal\r\n     * @param _str1 strings\r\n     * @param _str2 strings\r\n     * @return bool\r\n     */\r\n    function compareStr(string memory _str1, string memory _str2)\r\n        internal\r\n        pure\r\n        returns(bool)\r\n    {\r\n        return keccak256(abi.encodePacked(_str1)) == keccak256(abi.encodePacked(_str2));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        // bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an address access to this role\r\n     */\r\n    function add(Role storage _role, address _addr)\r\n        internal\r\n    {\r\n        require(!has(_role, _addr), \"R: has role\");\r\n        _role.bearer[_addr] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address' access to this role\r\n     */\r\n    function remove(Role storage _role, address _addr)\r\n        internal\r\n    {\r\n        require(has(_role, _addr), \"R: have't role\");\r\n        _role.bearer[_addr] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an address has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage _role, address _addr)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_addr != address(0), \"R: zero addr\");\r\n        return _role.bearer[_addr];\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IToken {\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnerTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnerTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev modifier Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"O: not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     * @return bool\r\n     */\r\n    function isOwner()\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner)\r\n        public\r\n        onlyOwner\r\n    {\r\n        //Allows abandonment of the contract owner // On-line adjustment\r\n        // require(newOwner != address(0), 'O: zero addr'); // On-line adjustment\r\n        emit OwnerTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return _owner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private roles = Roles.Role();\r\n\r\n    event RoleAdded(address indexed operator);\r\n    event RoleRemoved(address indexed operator);\r\n\r\n    /**\r\n     * @dev Throws if operator is not whitelisted.\r\n     */\r\n    modifier onlyIfWhitelisted() {\r\n        require(checkWhitelist(), \"W: not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev check current operator is in whitelist\r\n     * @return bool\r\n     */\r\n    function checkWhitelist()\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isWhitelist(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev add an address to the whitelist\r\n     * @param _operator address\r\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n     */\r\n    function addAddressToWhitelist(address _operator)\r\n        public\r\n        onlyOwner\r\n    {\r\n        roles.add(_operator);\r\n        emit RoleAdded(_operator);\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address from the whitelist\r\n     * @param _operator address\r\n     * @return true if the address was removed from the whitelist,\r\n     * false if the address wasn't in the whitelist in the first place\r\n     */\r\n    function removeAddressFromWhitelist(address _operator)\r\n        public\r\n        onlyOwner\r\n    {\r\n        roles.remove(_operator);\r\n        emit RoleRemoved(_operator);\r\n    }\r\n\r\n    /**\r\n     * @dev determine if address is in whitelist\r\n     * @param _operator address\r\n     * @return bool\r\n     */\r\n    function isWhitelist(address _operator)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return roles.has(_operator) || isOwner();\r\n    }\r\n}\r\n\r\n/**\r\n * @title DB\r\n * @dev This Provide database support services\r\n */\r\ncontract DB is Whitelist {\r\n    //lib using list\r\n\tusing String for string;\r\n\r\n\tstruct UserInfo {\r\n\t\tuint id;\r\n        address code;\r\n\t\taddress rCode;\r\n\t\tuint status;\r\n\t}\r\n\r\n\tuint _uid = 0;\r\n\tmapping(uint => address) indexMapping;//UID address Mapping\r\n    mapping(address => address) addressMapping;//inviteCode address Mapping\r\n    mapping(address => UserInfo) userInfoMapping;//address UserInfo Mapping\r\n    mapping(address => address[]) rCodeMapping;//rCode code Mapping\r\n\r\n    /**\r\n     * @dev modifier check Permission\r\n     */\r\n\tmodifier _checkPermission() {\r\n\t\trequire(checkWhitelist(), \"DB: Permission denied\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev modifier check User Permission\r\n     * @param addr user addr\r\n     */\r\n\tmodifier _checkUserPermission(address addr) {\r\n\t\tcheckUserPermission(addr);\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check User Permission\r\n     * @param addr user addr\r\n     */\r\n    function checkUserPermission(address addr)\r\n        private\r\n        view\r\n    {\r\n        require(checkWhitelist() || msg.sender == addr, \"DB: Permission denied\");\r\n\t}\r\n\r\n    /**\r\n     * @dev Create store user information\r\n     * @param addr user addr\r\n     * @param code user invite Code\r\n     * @param rCode recommend code\r\n     */\r\n    function _registerUser(address addr, address code, address rCode)\r\n        internal\r\n    {\r\n\t\tUserInfo storage userInfo = userInfoMapping[addr];\r\n        if (userInfo.id == 0) {\r\n            if (_uid != 0) {\r\n                require(isUsedCode(rCode), \"DB: rCode not exist\");\r\n                address pAddr = addressMapping[rCode];\r\n                require(pAddr != msg.sender, \"DB: rCode can't be self\");\r\n                userInfo.rCode = rCode;\r\n\r\n                if (rCode != address(0))\r\n                {\r\n                    rCodeMapping[rCode].push(code);\r\n                }\r\n            }\r\n\r\n            require(!isUsedCode(code), \"DB: code is used\");\r\n            require(code != address(0), \"DB: invalid code\");\r\n\r\n            _uid++;\r\n            userInfo.id = _uid;\r\n            userInfo.code = code;\r\n\r\n            addressMapping[code] = addr;\r\n            indexMapping[_uid] = addr;\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev Set store user information\r\n     * @param addr user addr\r\n     * @param status user status\r\n     */\r\n    function _setUser(address addr, uint status)\r\n        internal\r\n    {\r\n\t\tUserInfo storage userInfo = userInfoMapping[addr];\r\n        userInfo.status = status;\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if user invite code is use\r\n     * @param code user invite Code\r\n     * @return bool\r\n     */\r\n    function isUsedCode(address code)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn addressMapping[code] != address(0);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return address\r\n     */\r\n    function _getCodeMapping(address code)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        // addr = addressMapping[code];\r\n\t\t//checkUserPermission(addr);\r\n\t\treturn addressMapping[code];\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return address\r\n     */\r\n    function getCodeMapping(address code)\r\n        public\r\n        view\r\n        returns (address addr)\r\n    {\r\n        addr = _getCodeMapping(code);\r\n\t\tcheckUserPermission(addr); // On-line adjustment\r\n\t\treturn addr;\r\n\t}\r\n\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user id\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return address\r\n     */\r\n    function _getIndexMapping(uint uid)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n\t\treturn indexMapping[uid];\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user id\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return address\r\n     */\r\n    function getIndexMapping(uint uid)\r\n        public\r\n        view\r\n        returns (address addr)\r\n    {\r\n        addr = _getIndexMapping(uid);\r\n\t\tcheckUserPermission(addr); // On-line adjustment\r\n\t\treturn addr;\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding User info\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info[id,status],code,rCode\r\n     */\r\n    function _getUserInfo(address addr)\r\n        internal\r\n        view\r\n        returns (uint[2] memory info, address code, address rCode)\r\n    {\r\n\t\tUserInfo memory userInfo = userInfoMapping[addr];\r\n\t\tinfo[0] = userInfo.id;\r\n\t\tinfo[1] = userInfo.status;\r\n\r\n\t\treturn (info, userInfo.code, userInfo.rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding User info\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info[id,status],code,rCode\r\n     */\r\n    function getUserInfo(address addr)\r\n        public\r\n        view\r\n        _checkUserPermission(addr) // On-line adjustment\r\n        returns (uint[2] memory info, address code, address rCode)\r\n    {\r\n\t\treturn _getUserInfo(addr);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the current latest ID\r\n     * Authorization Required\r\n     * @return current uid\r\n     */\r\n    function _getCurrentUserID()\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn _uid;\r\n\t}\r\n\r\n    /**\r\n     * @dev get the rCodeMapping array length of the corresponding recommend Code\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @return rCodeMapping array length\r\n     */\r\n    function _getRCodeMappingLength(address rCode)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn rCodeMapping[rCode].length;\r\n\t}\r\n\r\n    /**\r\n     * @dev get the rCodeMapping array length of the corresponding recommend Code\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @return rCodeMapping array length\r\n     */\r\n    function getRCodeMappingLength(address rCode)\r\n        public\r\n        view\r\n        _checkPermission() // On-line adjustment\r\n        returns (uint)\r\n    {\r\n\t\treturn _getRCodeMappingLength(rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user invite code of the recommend Code [rCodeMapping] based on the index\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @param index the index of [rCodeMapping]\r\n     * @return user invite code\r\n     */\r\n    function _getRCodeMapping(address rCode, uint index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n\t\treturn rCodeMapping[rCode][index];\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user invite code of the recommend Code [rCodeMapping] based on the index\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @param index the index of [rCodeMapping]\r\n     * @return user invite code\r\n     */\r\n    function getRCodeMapping(address rCode, uint index)\r\n        public\r\n        view\r\n        _checkPermission() // On-line adjustment\r\n        returns (address)\r\n    {\r\n\t\treturn _getRCodeMapping(rCode, index);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user offspring\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     */\r\n    function _getRCodeOffspring(address rCode)\r\n        internal\r\n        view\r\n        returns (address[] memory offspring_CodeArr)\r\n    {\r\n        offspring_CodeArr = new address[](_getRCodeMappingLength(rCode));\r\n        for (uint i = 0; i < offspring_CodeArr.length; i++) {\r\n            offspring_CodeArr[i] = _getRCodeMapping(rCode, i);\r\n        }\r\n\t\treturn offspring_CodeArr;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Utillibrary\r\n * @dev This integrates the basic functions.\r\n */\r\ncontract Utillibrary is Whitelist {\r\n    //lib using list\r\n\tusing SafeMath for *;\r\n    using Address for address;\r\n\r\n    //Loglist\r\n    event TransferEvent(address indexed _from, address indexed _to, uint _value, uint time);\r\n    event TransferTokenEvent(address indexed _token, address indexed _from, address indexed _to, uint _value, uint time);\r\n\r\n    //base param setting\r\n    // uint internal ethWei = 1 ether;\r\n    uint internal USDTWei = 10 ** 6;\r\n    uint internal ETTWei = 10 ** 18;\r\n    uint internal USDT_ETTWei_Ratio = 10 ** 12;\r\n\r\n    /**\r\n     * @dev modifier to scope access to a Contract (uses tx.origin and msg.sender)\r\n     */\r\n\tmodifier isHuman() {\r\n\t\trequire(msg.sender == tx.origin, \"humans only\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check Zero Addr\r\n     */\r\n\tmodifier checkZeroAddr(address addr) {\r\n\t\trequire(addr != address(0), \"zero addr\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check Addr is Contract\r\n     */\r\n\tmodifier checkIsContract(address addr) {\r\n\t\trequire(addr.isContract(), \"not token addr\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check User ID\r\n     * @param uid user ID\r\n     */\r\n    function checkUserID(uint uid)\r\n        internal\r\n        pure\r\n    {\r\n        require(uid != 0, \"user not exist\");\r\n\t}\r\n\r\n    /**\r\n     * @dev Transfer to designated user\r\n     * @param _taddr token address\r\n     * @param _addr user address\r\n     * @param _val transfer-out amount\r\n     */\r\n\tfunction sendTokenToUser(address _taddr, address _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).transfer(_addr, _val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the amount from the specified user\r\n     * @param _taddr token address\r\n     * @param _addr user address\r\n     * @param _val transfer-get amount\r\n     */\r\n\tfunction getTokenFormUser(address _taddr, address _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).transferFrom(_addr, address(this), _val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev burn money\r\n     * @param _taddr token address\r\n     * @param _val burn amount\r\n     */\r\n\tfunction burnToken(address _taddr, uint _val)\r\n        internal\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).burn(_val, \"\");\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the current day index\r\n     * @return day index\r\n     */\r\n\tfunction getDayIndex()\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn now / 1 days;\r\n\t}\r\n\r\n    /**\r\n     * @dev Check and correct transfer amount\r\n     * @param sendMoney transfer-out amount\r\n     * @return bool,amount\r\n     */\r\n\tfunction isEnoughTokneBalance(address _taddr, uint sendMoney)\r\n        internal\r\n        view\r\n        returns (bool, uint tokneBalance)\r\n    {\r\n        tokneBalance = IToken(_taddr).balanceOf(address(this));\r\n\t\tif (sendMoney >= tokneBalance) {\r\n\t\t\treturn (false, tokneBalance);\r\n\t\t} else {\r\n\t\t\treturn (true, sendMoney);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev get Resonance Ratio for the Resonance ID\r\n     * @param value Resonance ID\r\n     * @return Resonance Ratio\r\n     */\r\n\tfunction getResonanceRatio(uint value)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        if (value == 1) {\r\n            return USDT_ETTWei_Ratio * 50;\r\n        }\r\n        if (value == 2) {\r\n            return USDT_ETTWei_Ratio * 45;\r\n        }\r\n        if (value == 3) {\r\n            return USDT_ETTWei_Ratio * 40;\r\n        }\r\n        if (value == 4) {\r\n            return USDT_ETTWei_Ratio * 35;\r\n        }\r\n        if (value == 5) {\r\n            return USDT_ETTWei_Ratio * 30;\r\n        }\r\n        if (value == 6) {\r\n            return USDT_ETTWei_Ratio * 25;\r\n        }\r\n        return USDT_ETTWei_Ratio * 20;\r\n\t}\r\n\r\n        /**\r\n     * @dev get Invest Limit for the Addup Invest\r\n     * @param value Addup Invest\r\n     * @return Invest Limit and isLimit\r\n     */\r\n\tfunction getInvestLimit(uint value)\r\n        internal\r\n        view\r\n        returns (uint dayInvestLimit, bool isLimit)\r\n    {\r\n        if(value < USDTWei * 150000000) {\r\n            if(value >= USDTWei * 70000000) {\r\n                dayInvestLimit = USDTWei * 5000000;\r\n                isLimit = true;\r\n            } else if(value >= USDTWei * 30000000) {\r\n                dayInvestLimit = USDTWei * 2400000;\r\n                isLimit = true;\r\n            } else if(value >= USDTWei * 14000000) {\r\n                dayInvestLimit = USDTWei * 1200000;\r\n                isLimit = true;\r\n            } else if(value >= USDTWei * 7000000) {\r\n                dayInvestLimit = USDTWei * 600000;\r\n                isLimit = true;\r\n            } else if(value >= USDTWei * 1400000) {\r\n                dayInvestLimit = USDTWei * 300000;\r\n                isLimit = true;\r\n            } else if(value >= USDTWei * 700000) {\r\n                dayInvestLimit = USDTWei * 150000;\r\n                isLimit = true;\r\n            } else {\r\n                dayInvestLimit = USDTWei * 70000;\r\n                isLimit = true;\r\n            }\r\n        }\r\n        return (dayInvestLimit, isLimit);\r\n\t}\r\n\r\n    /**\r\n     * @dev get UserLevel for the Cumulative Invest (7 generations)\r\n     * @param value team Cumulative Invest (7 generations)\r\n     * @return UserLevel\r\n     */\r\n\tfunction getLevel(uint value)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\tif (value >= USDTWei * 200000 && value < USDTWei * 500000) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tif (value >= USDTWei * 500000 && value < USDTWei * 1200000) {\r\n\t\t\treturn 2;\r\n\t\t}\r\n\t\tif (value >= USDTWei * 1200000) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n    /**\r\n     * @dev get scale for the level (*scale/100)\r\n     * @param level level\r\n     * @return scale\r\n     */\r\n\tfunction getScaleByLevel(uint level)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n\t\tif (level == 1) {\r\n\t\t\treturn 5;\r\n\t\t}\r\n\t\tif (level == 2) {\r\n\t\t\treturn 10;\r\n\t\t}\r\n\t\tif (level == 3) {\r\n\t\t\treturn 15;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n    /**\r\n     * @dev get scale for the Algebra (*scale/100)\r\n     * @param algebra algebra\r\n     * @return scale\r\n     */\r\n\tfunction getScaleByAlgebra(uint algebra)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n\t\tif (algebra == 1) {\r\n\t\t\treturn 40;\r\n\t\t}\r\n\t\tif (algebra >= 2 && algebra <= 5) {\r\n\t\t\treturn 3;\r\n\t\t}\r\n\t\tif (algebra >= 6 && algebra <= 20) {\r\n\t\t\treturn 5;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n}\r\n\r\n\r\ncontract znhyContract is DB, Utillibrary {\r\n    //lib using list\r\n\tusing SafeMath for *;\r\n    using String for string;\r\n\r\n    //struct\r\n\tstruct User {\r\n\t\tuint id;\r\n\t\taddress userAddress;\r\n\t\tuint level;//user level\r\n        uint levelLockDemotion;//level Lock Demotion\r\n        uint nodeLevel;//user node Level\r\n        uint buyMaxMoney;//max buy amount\r\n        uint investAmountMax;//add up invest Amount Max\r\n        uint investAmount;//add up invest Amount\r\n        uint investAmountOut;//add up invest Amount Out\r\n        uint investIndex;//invest Index\r\n        uint maxInvestIndex;//Max invest Index\r\n        mapping(uint => InvestData) investData;\r\n        mapping(uint => uint) rewardIndex;\r\n        mapping(uint => mapping(uint => AwardData)) rewardData;\r\n        uint bonusStaticAmount;//add up static bonus amonut (static bonus)\r\n\t\tuint bonusDynamicAmonut;//add up dynamic bonus amonut (dynamic bonus)\r\n        uint recommendAlgebraAmonut;//add up dynamic bonus amonut (recommend Algebra bonus)\r\n        uint teamCumulativeInvest;//Team cumulative invest (7 generations)\r\n        uint takeBonusWallet;//takeBonus Wallet\r\n        uint addupTakeBonus;//add up takeBonus\r\n\t}\r\n    struct ResonanceData {\r\n        uint time;//Resonance time\r\n        uint ratio;//Resonance amount\r\n        uint sellMoney;//sell Money\r\n\t}\r\n    struct InvestData {\r\n        uint money;//invest amount\r\n        uint lastRwTime;//last settlement time\r\n        uint adduoStaticBonus;//add up settlement static bonus amonut\r\n        uint adduoDynamicBonus;//add up settlement dynamic bonus amonut\r\n        uint status;//invest status, 0:normal,1:out\r\n\t}\r\n\tstruct AwardData {\r\n        uint time;//settlement bonus time\r\n        uint amount;//bonus of reward amount\r\n\t}\r\n\r\n    //Loglist\r\n    event BuyTicketEvent(address indexed _addr, uint _value, uint _ratio, uint _value2, uint time);\r\n    event InvestEvent(address indexed _addr, address indexed _code, address indexed _rCode, uint _value, uint time);\r\n    event TakeBonusEvent(address indexed _addr, uint _value, uint time);\r\n\r\n    //ERC Token addr\r\n    address USDTToken;//USDT contract\r\n    address EntranceTicketToken;//entrance ticket\r\n\r\n    //base param setting\r\n\taddress devAddr;//The special account\r\n    address[] shuntAddrs;//buy Ticket shunt address Arr\r\n\r\n    //addup\r\n    uint AddupInvestUSD = 0;\r\n    uint AddupSellETT = 0;\r\n    uint AddupBurnETT = 0;\r\n\r\n    //start Time setting\r\n    uint startTime = 0;\r\n\tuint canSetStartTime = 1;\r\n\r\n    //resonance\r\n    uint rid = 1;//sell Round id\r\n\t//uint period = 10 days;\r\n    mapping(uint => ResonanceData) resonanceDataMapping;//RoundID ResonanceData Mapping\r\n\r\n    //Round setting\r\n\tuint sid = 1;//sell Round id\r\n    uint bid = 1;//burn Round id\r\n    mapping(uint => uint) sellAmountMapping;//sellRoundID sellAmount Mapping\r\n    mapping(uint => uint) burnAmountMapping;//burnRoundID sellamount Mapping\r\n    //address User Mapping\r\n\tmapping(address => User) userMapping;\r\n    mapping(uint => uint) DayInvestUSDMapping;//day index InvestUSD Mapping\r\n\r\n\r\n    /**\r\n     * @dev the content of contract is Beginning\r\n     */\r\n\tconstructor (\r\n        // address _devAddr,\r\n        address _USDTAddr,\r\n        address _EntranceTicketAddr\r\n    )\r\n        public\r\n    {\r\n        //set addr\r\n        // devAddr = _devAddr;\r\n        USDTToken = _USDTAddr;\r\n        EntranceTicketToken = _EntranceTicketAddr;\r\n        devAddr = address(0x5cb50ED2B9fB3F20BbDbc8F7037927B6b3a40aCD);\r\n        //opentime\r\n        startTime = now;\r\n\t\tcanSetStartTime = 0;\r\n        //init ResonanceData\r\n        ResonanceData storage resonance = resonanceDataMapping[rid];\r\n        if (resonance.ratio == 0) {\r\n            resonance.time = now;\r\n            resonance.ratio = getResonanceRatio(rid);\r\n        }\r\n        //set shuntAddrs\r\n        shuntAddrs.push(address(0x4FAA66a641eE0e0f2178F3c200Aa450C129E233C));\r\n        shuntAddrs.push(address(0xf0628daCcE8DA7b91154b94f683B8B1c4d91F0C8));\r\n        shuntAddrs.push(address(0x2F3Da7F5b8525aD33410c9FE921497CdfE3033C0));\r\n        shuntAddrs.push(address(0x7f4ae7C0ccA732b6004b91A717112716EDBd31C1));\r\n        shuntAddrs.push(address(0x8ba525b7c5997A73BfFf5b59b55d0Ad9c9CFE20c));\r\n        shuntAddrs.push(address(0xcb6a27D496bC6C6e4a9f52F626f448858c984953));\r\n        shuntAddrs.push(address(0xd39b7cf3067721B132486db6338235e229d90f92));\r\n        shuntAddrs.push(address(0x5Dd6041a402B5e34Bc358b0e643aF7303E78eBA4));\r\n        shuntAddrs.push(address(0xe3934580171b97929bB7555EBde34728AC618E2D));\r\n        shuntAddrs.push(address(0x400E5823CA04c974A32a3B72551918eE02ADad52));\r\n        //set Initializing member\r\n        address initAddr = address(0xb7Cd97D25365cc83c2B651cE91AD93737f187389);\r\n        _registerUser(initAddr, initAddr, address(0));\r\n        User storage user = userMapping[initAddr];\r\n        user.level = 3;\r\n        user.levelLockDemotion = 1;\r\n\t}\r\n\r\n\r\n    /**\r\n     * @dev modifier check contract is Open\r\n     */\r\n\tmodifier _isOpen() {\r\n\t\trequire(isOpen(), \"no open\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev Set user nodeLevel\r\n     * @param addr user address\r\n     * @param nodeLevel user nodeLevel\r\n     */\r\n\tfunction actUserNodeLevel(address addr, uint nodeLevel)\r\n        external\r\n        onlyIfWhitelisted\r\n    {\r\n\t\trequire(nodeLevel == 0 || nodeLevel == 1, \"bad parameter\");\r\n        User storage user = userMapping[addr];\r\n        user.nodeLevel = nodeLevel;\r\n\t}\r\n\r\n    /**\r\n     * @dev To buy tickets\r\n     * @param money USDT amount for purchase of tickets\r\n     */\r\n\tfunction buyTicket(uint money)\r\n        public\r\n        isHuman()\r\n        _isOpen()\r\n    {\r\n        require(money >= USDTWei * 10 && money <= USDTWei * 50000, \"invalid buy range\");\r\n\r\n        uint ratio = resonanceDataMapping[rid].ratio;\r\n        uint ETTMoney = money.mul(ratio);\r\n\r\n        //Transfer USDT Token to Contract\r\n        getTokenFormUser(USDTToken, msg.sender, money);\r\n        //Transfer ETT Token to User\r\n        sendTokenToUser(EntranceTicketToken, msg.sender, ETTMoney);\r\n\r\n        //update Ratio\r\n        updateRatio(ETTMoney, 0);\r\n\r\n        //addup\r\n        User storage user = userMapping[msg.sender];\r\n\r\n        if(user.buyMaxMoney < money) {\r\n            user.buyMaxMoney = money;\r\n        }\r\n        if(user.nodeLevel == 0 && user.buyMaxMoney >= USDTWei * 5000) {\r\n            user.nodeLevel = 1;\r\n        }\r\n\r\n        //shunt\r\n        if (shuntAddrs.length > 0) {\r\n            uint shuntMoney = money * 40 / 100 / shuntAddrs.length;\r\n            for (uint i = 0; i < shuntAddrs.length; i++) {\r\n                if (shuntAddrs[i] != address(0)) {\r\n                    sendTokenToUser(USDTToken, shuntAddrs[i], shuntMoney);\r\n                }\r\n            }\r\n        }\r\n\r\n        emit BuyTicketEvent(msg.sender, money, ratio, ETTMoney, now);\r\n\t}\r\n\r\n    /**\r\n     * @dev the invest of contract is Beginning\r\n     * @param money USDT amount for invest\r\n     * @param rCode recommend code\r\n     */\r\n\tfunction invest(uint money, address rCode)\r\n        public\r\n        isHuman()\r\n        _isOpen()\r\n    {\r\n        address code = msg.sender;\r\n\t\trequire(money >= USDTWei * 100 && money <= USDTWei * 300000, \"invalid investment range\");\r\n\r\n        //check Limit\r\n        uint dayInvestLimit = 0;\r\n        bool isLimit = false;\r\n        (dayInvestLimit, isLimit) = getInvestLimit(AddupInvestUSD);\r\n        if(isLimit) {\r\n            require(DayInvestUSDMapping[getDayIndex()] + money <= dayInvestLimit, \"day Invest Limit\");\r\n        }\r\n        AddupInvestUSD += money;\r\n        DayInvestUSDMapping[getDayIndex()] += money;\r\n\r\n        uint ETTMoney = money.mul(resonanceDataMapping[rid].ratio).div(10);\r\n\r\n        //Transfer USDT Token to Contract\r\n        getTokenFormUser(USDTToken, msg.sender, money);\r\n        //Transfer ETT Token to Contract\r\n        getTokenFormUser(EntranceTicketToken, msg.sender, ETTMoney);\r\n\r\n        //check Burn ETT\r\n        if(AddupBurnETT < ETTWei * 36000000) {\r\n            burnToken(EntranceTicketToken, ETTMoney);\r\n\r\n            //update Ratio\r\n            updateRatio(0, ETTMoney);\r\n        }\r\n\r\n        //send USDT Token to dev addr\r\n        sendTokenToUser(USDTToken, devAddr, money.div(20));\r\n\r\n        //init userInfo\r\n        uint[2] memory user_data;\r\n        (user_data, , ) = _getUserInfo(msg.sender);\r\n        uint user_id = user_data[0];\r\n\t\tif (user_id == 0) {\r\n\t\t\t_registerUser(msg.sender, code, rCode);\r\n            (user_data, , ) = _getUserInfo(msg.sender);\r\n            user_id = user_data[0];\r\n\t\t}\r\n\r\n\t\tUser storage user = userMapping[msg.sender];\r\n\t\tif (user.id == 0) {\r\n            user.id = user_id;\r\n\t\t\tuser.userAddress = msg.sender;\r\n\t\t}\r\n\r\n        user.investAmount += money;\r\n        InvestData storage investData = user.investData[user.investIndex];\r\n        investData.lastRwTime = now;\r\n        investData.money = money;\r\n        user.investIndex ++;\r\n        if(user.investAmountMax < money) {\r\n            user.investAmountMax = money;\r\n        }\r\n        user.maxInvestIndex = getMaxInvestData(msg.sender);\r\n\r\n        //reacquire rCode\r\n        (, , rCode) = _getUserInfo(msg.sender);\r\n\r\n        //Calculate the bonus (All) and update Parent User\r\n        countBonus_All(rCode, money);\r\n\r\n        emit InvestEvent(msg.sender, code, rCode, money, now);\r\n\t}\r\n\r\n    /**\r\n     * @dev the take bonus of contract is Beginning\r\n     */\r\n    function takeBonus()\r\n        public\r\n        isHuman()\r\n        _isOpen()\r\n    {\r\n\t\tUser storage user = userMapping[msg.sender];\r\n\t\tcheckUserID(user.id);\r\n\r\n\t\trequire(user.takeBonusWallet >= USDTWei * 1, \"invalid amount\");\r\n\r\n\t\tuint resultMoney = 0;\r\n\r\n\t\t( , resultMoney) = isEnoughTokneBalance(USDTToken, user.takeBonusWallet);\r\n\r\n        require(resultMoney >= USDTWei * 1, \"not enough balance\");\r\n\r\n\t\trequire(user.takeBonusWallet >= USDTWei * 1, \"invalid amount.\");//Secondary efficacy\r\n        user.takeBonusWallet = user.takeBonusWallet.sub(resultMoney);\r\n        user.addupTakeBonus = user.addupTakeBonus.add(resultMoney);\r\n\r\n        //Transfer USDT Token to Contract\r\n        getTokenFormUser(EntranceTicketToken, msg.sender, resultMoney.mul(resonanceDataMapping[rid].ratio).mul(3).div(100));\r\n        //Transfer USDT Token to User\r\n        sendTokenToUser(USDTToken, msg.sender, resultMoney);\r\n\r\n        emit TakeBonusEvent(msg.sender, resultMoney, now);\r\n\t}\r\n\r\n    /**\r\n     * @dev settlement\r\n     * @param _type settlement type (0:Static,1:Node,2:DailyDividend,3:ServiceFees,4:SameLevel)\r\n     */\r\n    function settlement(uint _type)\r\n        public\r\n        isHuman()\r\n        _isOpen()\r\n    {\r\n\t\tUser storage user = userMapping[msg.sender];\r\n        checkUserID(user.id);\r\n\r\n        //reacquire rCode\r\n        address rCode;\r\n        uint[2] memory user_data;\r\n        (user_data, , rCode) = _getUserInfo(msg.sender);\r\n        uint user_status = user_data[1];\r\n\r\n        if (_type == 0) {\r\n            require(user_status != 1, \"user status is lock(Static)\");\r\n\r\n            //-----------Static Start\r\n            uint settlementCountTotal = 0;\r\n            for (uint i = 0; i < user.investIndex; i++) {\r\n                InvestData storage investData = user.investData[i];\r\n                uint settlementNumber_base = (now - investData.lastRwTime) / 1 days;\r\n                if (investData.status == 0 && settlementNumber_base > 0) {\r\n                    //Handling fee safety\r\n                    if (settlementCountTotal >= 10) {\r\n                        break;\r\n                    }\r\n                    settlementCountTotal ++;\r\n\r\n                    uint moneyBonus_base = investData.money * 5 / 1000;\r\n                    uint settlementNumber = settlementNumber_base;\r\n                    uint settlementMaxMoney = 0;\r\n                    if(investData.money * 3 >= investData.adduoStaticBonus + investData.adduoDynamicBonus) {\r\n                       settlementMaxMoney = investData.money * 3 - (investData.adduoStaticBonus + investData.adduoDynamicBonus);\r\n                    }\r\n                    uint moneyBonus = 0;\r\n                    if (moneyBonus_base * settlementNumber > settlementMaxMoney) {\r\n                        settlementNumber = settlementMaxMoney / moneyBonus_base;\r\n                        if (moneyBonus_base * settlementNumber < settlementMaxMoney) {\r\n                            settlementNumber ++;\r\n                        }\r\n                        if (settlementNumber > settlementNumber_base) {\r\n                            settlementNumber = settlementNumber_base;\r\n                        }\r\n                        // moneyBonus = moneyBonus_base * settlementNumber;\r\n                        moneyBonus = settlementMaxMoney;\r\n                    } else {\r\n                        moneyBonus = moneyBonus_base * settlementNumber;\r\n                    }\r\n\r\n                    user.takeBonusWallet += moneyBonus;\r\n                    user.bonusStaticAmount += moneyBonus;\r\n\r\n                    investData.adduoStaticBonus += moneyBonus;\r\n                    investData.lastRwTime += settlementNumber * 1 days;\r\n                    //check out\r\n                    if (investData.adduoStaticBonus + investData.adduoDynamicBonus >= investData.money * 3) {\r\n                        investData.status = 1;\r\n                        user.investAmountOut += investData.money;\r\n\t\t\t\t\t\tuser.maxInvestIndex = getMaxInvestData(msg.sender);\r\n                    }\r\n\r\n                    //Calculate the bonus (Daily Dividend)\r\n                    // countBonus_DailyDividend(rCode, moneyBonus, investData.money);\r\n                    countBonus_DailyDividend(rCode, moneyBonus_base * settlementNumber, investData.money);\r\n                }\r\n            }\r\n            //-----------Static End\r\n        } else if (_type == 1 || _type == 2 || _type == 3 || _type == 4) {\r\n\r\n            require(user_status == 0, \"user status is lock(Dynamic)\");\r\n\r\n            //-----------Node/DailyDividend/ServiceFees/SameLevel Start\r\n            AwardData storage awData = user.rewardData[_type][user.rewardIndex[_type]];\r\n\r\n            require(awData.amount > 0, \"amount is zero\");\r\n\r\n            user.rewardIndex[_type] ++;\r\n            awData.time = now;\r\n            user.takeBonusWallet += awData.amount;\r\n            //-----------Node/DailyDividend/ServiceFees/SameLevel End\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev Show contract state view\r\n     * @return contract state view\r\n     */\r\n    function stateView()\r\n        public\r\n        view\r\n        returns (uint[16] memory info, bool)\r\n    {\r\n        uint dayInvestLimit = 0;\r\n        bool isLimit = false;\r\n        (dayInvestLimit, isLimit) = getInvestLimit(AddupInvestUSD);\r\n\r\n        info[0] = _getCurrentUserID();\r\n        info[1] = startTime;\r\n        info[2] = canSetStartTime;\r\n        info[3] = rid;\r\n        info[4] = resonanceDataMapping[rid].ratio;\r\n        info[5] = resonanceDataMapping[rid].sellMoney;\r\n        info[6] = resonanceDataMapping[rid].time;\r\n        info[7] = sid;\r\n        info[8] = sellAmountMapping[sid];\r\n        info[9] = bid;\r\n        info[10] = burnAmountMapping[bid];\r\n        info[11] = AddupInvestUSD;\r\n        info[12] = AddupSellETT;\r\n        info[13] = AddupBurnETT;\r\n        info[14] = DayInvestUSDMapping[getDayIndex()];\r\n        info[15] = dayInvestLimit;\r\n\r\n\t\treturn (info, isLimit);\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if contract open\r\n     * @return bool\r\n     */\r\n\tfunction isOpen()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn startTime != 0 && now > startTime;\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user info based\r\n     * @param addr user addressrd\r\n     * @return user info\r\n     */\r\n\tfunction getUserByAddress(\r\n        address addr\r\n    )\r\n        public\r\n        view\r\n        _checkUserPermission(addr) // On-line adjustment\r\n        returns (uint[25] memory info, address code, address rCode, address raddr)\r\n    {\r\n        uint[2] memory user_data;\r\n        (user_data, code, rCode) = _getUserInfo(addr);\r\n        uint user_id = user_data[0];\r\n        uint user_status = user_data[1];\r\n\r\n\t\tUser storage user = userMapping[addr];\r\n\r\n\t\tinfo[0] = user_id;\r\n        info[1] = user_status;//user status\r\n        info[2] = user.level;//user level\r\n        info[3] = user.levelLockDemotion;//level Lock Demotion\r\n        info[4] = user.nodeLevel;//user node Level\r\n        info[5] = user.buyMaxMoney;//max buy amount\r\n        info[6] = user.investAmountMax;//add up invest Amount Max\r\n        info[7] = user.investAmount;//add up invest Amount\r\n        info[8] = user.investAmountOut;//add up invest Amount Out\r\n        info[9] = user.investIndex;//invest Index\r\n        info[10] = user.bonusStaticAmount;//add up static bonus amonut (static bonus)\r\n        info[11] = user.bonusDynamicAmonut;//add up dynamic bonus amonut (dynamic bonus)\r\n        info[12] = user.teamCumulativeInvest;//Team cumulative invest (7 generations)\r\n        info[13] = user.recommendAlgebraAmonut;//add up dynamic bonus amonut (recommend Algebra bonus)\r\n        info[14] = user.takeBonusWallet;//takeBonus Wallet\r\n        info[15] = user.addupTakeBonus;//add up takeBonus\r\n        info[16] = user.rewardData[1][user.rewardIndex[1]].amount;//raward (Node) 1\r\n        info[17] = user.rewardData[2][user.rewardIndex[2]].amount;//raward (Daily Dividend) 2\r\n        info[18] = user.rewardData[3][user.rewardIndex[3]].amount;//raward (Service Fees) 3\r\n        info[19] = user.rewardData[4][user.rewardIndex[4]].amount;//raward (Same Level) 4\r\n\r\n        //Static\r\n        uint rewardDataStaticAmount = 0;\r\n        for (uint i = 0; i < user.investIndex; i++) {\r\n            InvestData memory investData = user.investData[i];\r\n            uint settlementNumber_base = (now - investData.lastRwTime) / 1 days;\r\n            if (investData.status == 0 && settlementNumber_base > 0) {\r\n                uint moneyBonus_base = investData.money * 5 / 1000;\r\n                uint settlementNumber = settlementNumber_base;\r\n                uint settlementMaxMoney = 0;\r\n                if(investData.money * 3 >= investData.adduoStaticBonus + investData.adduoDynamicBonus) {\r\n                    settlementMaxMoney = investData.money * 3 - (investData.adduoStaticBonus + investData.adduoDynamicBonus);\r\n                }\r\n                if (moneyBonus_base * settlementNumber > settlementMaxMoney) {\r\n                    // settlementNumber = settlementMaxMoney / moneyBonus_base;\r\n                    // if (moneyBonus_base * settlementNumber < settlementMaxMoney) {\r\n                    //     settlementNumber ++;\r\n                    // }\r\n                    // if (settlementNumber > settlementNumber_base) {\r\n                    //     settlementNumber = settlementNumber_base;\r\n                    // }\r\n                    // rewardDataStaticAmount += moneyBonus_base * settlementNumber;\r\n                    rewardDataStaticAmount += settlementMaxMoney;\r\n                } else {\r\n                    rewardDataStaticAmount += moneyBonus_base * settlementNumber;\r\n                }\r\n            }\r\n        }\r\n        info[20] = rewardDataStaticAmount;\r\n\r\n        InvestData memory investDataMax = user.investData[user.maxInvestIndex];\r\n        info[21] = investDataMax.status;\r\n        info[22] = investDataMax.lastRwTime + 1 days;\r\n        if(investDataMax.money * 3 >= investDataMax.adduoStaticBonus + investDataMax.adduoDynamicBonus) {\r\n            info[23] = investDataMax.money * 3 - (investDataMax.adduoStaticBonus + investDataMax.adduoDynamicBonus);\r\n        } else {\r\n            info[23] = 0;\r\n        }\r\n        info[24] = _getRCodeMappingLength(code);\r\n\r\n        raddr = _getCodeMapping(rCode);\r\n\r\n\t\treturn (info, code, rCode, raddr);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the DailyDividend\r\n     * @param addr user addressrd\r\n     * @return DailyDividend amount\r\n     */\r\n\tfunction getDailyDividendByAddress(\r\n        address addr\r\n    )\r\n        public\r\n        view\r\n        _checkUserPermission(addr) // On-line adjustment\r\n        returns (uint amount)\r\n    {\r\n        amount = countBonus_DailyDividend_Offspring(addr);\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n    /**\r\n     * @dev get the Reward Data\r\n     * @param addr user addressrd\r\n     * @param _type settlement type (1:Node,2:DailyDividend,3:ServiceFees,4:SameLevel)\r\n     * @param index rewardData index\r\n     * @return Reward data\r\n     */\r\n\tfunction getRewardDataByAddress(\r\n        address addr,\r\n        uint _type,\r\n        uint index\r\n    )\r\n        public\r\n        view\r\n        _checkUserPermission(addr) // On-line adjustment\r\n        returns (uint[2] memory info, uint)\r\n    {\r\n\t\tUser storage user = userMapping[addr];\r\n\r\n        info[0] = user.rewardData[_type][index].amount;//raward (type) index\r\n        info[1] = user.rewardData[_type][index].time;//raward (type) index\r\n\r\n\t\treturn (info, user.rewardIndex[1]);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the invest Data\r\n     * @param addr user addressrd\r\n     * @param index investData index\r\n     * @return invest data\r\n     */\r\n\tfunction getInvestDataByAddress(\r\n        address addr,\r\n        uint index\r\n    )\r\n        public\r\n        view\r\n        _checkUserPermission(addr) // On-line adjustment\r\n        returns (uint[5] memory info, uint)\r\n    {\r\n\t\tUser storage user = userMapping[addr];\r\n\r\n        info[0] = user.investData[index].money;//invest index\r\n        info[1] = user.investData[index].lastRwTime;//invest index\r\n        info[2] = user.investData[index].adduoStaticBonus;//invest index\r\n        info[3] = user.investData[index].adduoDynamicBonus;//invest index\r\n        info[4] = user.investData[index].status;//invest index\r\n\r\n\t\treturn (info, user.investIndex);\r\n\t}\r\n\r\n    /**\r\n     * @dev update Resonance Ratio\r\n     * @param sellMoney sell ETT amount\r\n     * @param burnMoney burn ETT amount\r\n     */\r\n\tfunction updateRatio(uint sellMoney, uint burnMoney)\r\n        private\r\n    {\r\n        ResonanceData storage resonance = resonanceDataMapping[rid];\r\n        resonance.sellMoney += sellMoney;\r\n        AddupSellETT += sellMoney;\r\n        AddupBurnETT += burnMoney;\r\n\r\n        //check\r\n        uint newRatio = 0;\r\n        uint newResonanceSellMoney = 0;\r\n        if(rid <= 6){\r\n            if(resonance.sellMoney >= ETTWei * 2000000 || now - resonance.time >= 10 days) {\r\n                newRatio = getResonanceRatio(rid + 1);\r\n                if(resonance.sellMoney >= ETTWei * 2000000) {\r\n                    newResonanceSellMoney = resonance.sellMoney - ETTWei * 2000000;\r\n                    resonance.sellMoney = ETTWei * 2000000;\r\n                }\r\n            }\r\n        } else {\r\n            sellAmountMapping[sid] += sellMoney;\r\n            burnAmountMapping[bid] += burnMoney;\r\n\r\n            if(sellAmountMapping[sid] >= ETTWei * 70000) {\r\n                uint newSellAmount = sellAmountMapping[sid] - ETTWei * 70000;\r\n                sellAmountMapping[sid] = ETTWei * 70000;\r\n                sid ++;\r\n                newRatio = resonance.ratio * 99 / 100;\r\n                sellAmountMapping[sid] = newSellAmount;\r\n                if(resonance.sellMoney >= ETTWei * 70000) {\r\n                    newResonanceSellMoney = resonance.sellMoney - ETTWei * 70000;\r\n                    resonance.sellMoney = ETTWei * 70000;\r\n                }\r\n            } else if(burnAmountMapping[bid] >= ETTWei * 50000) {\r\n                uint newBurnAmount = burnAmountMapping[bid] - ETTWei * 50000;\r\n                burnAmountMapping[bid] = ETTWei * 50000;\r\n                bid ++;\r\n                newRatio = resonance.ratio * 99 / 100;\r\n                burnAmountMapping[bid] = newBurnAmount;\r\n            }\r\n        }\r\n        if (newRatio > 0) {\r\n            rid ++;\r\n            resonance = resonanceDataMapping[rid];\r\n            resonance.time = now;\r\n            resonance.ratio = newRatio;\r\n            //Continuous rise\r\n            resonance.sellMoney = newResonanceSellMoney;\r\n            if(rid == 7) {\r\n                sellAmountMapping[sid] = newResonanceSellMoney;\r\n            }\r\n            updateRatio(0, 0);\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev get Max Invest Data\r\n     * @param addr user address\r\n     */\r\n\tfunction getMaxInvestData(address addr)\r\n        private\r\n        view\r\n        returns (uint maxInvestDataIndex)\r\n    {\r\n        uint maxInvest = 0;\r\n        User storage user = userMapping[addr];\r\n        for (uint i = 0; i < user.investIndex; i++) {\r\n            InvestData memory investData = user.investData[i];\r\n            if (investData.status == 0 && maxInvest <= investData.money) {\r\n                maxInvest = investData.money;\r\n                maxInvestDataIndex = i;\r\n            }\r\n        }\r\n        return maxInvestDataIndex;\r\n\t}\r\n\r\n    /**\r\n     * @dev Update and Check Invest Out (dynamic Bonus)\r\n     * @param addr user address\r\n     * @param dynamicBonusAmount dynamic Bonus Amount\r\n     * @return bonus amount\r\n     */\r\n\tfunction update_DynamicBonusCheckInvestOut(address addr, uint dynamicBonusAmount)\r\n        private\r\n        returns (uint bonusAmount)\r\n    {\r\n        User storage user = userMapping[addr];\r\n\r\n        InvestData storage investData = user.investData[user.maxInvestIndex];\r\n\r\n        if (investData.status == 0) {\r\n            if (investData.adduoStaticBonus + investData.adduoDynamicBonus + dynamicBonusAmount >= investData.money * 3) {\r\n                investData.status = 1;\r\n                user.investAmountOut += investData.money;\r\n                user.maxInvestIndex = getMaxInvestData(addr);\r\n\r\n                bonusAmount = investData.money * 3 - (investData.adduoStaticBonus + investData.adduoDynamicBonus);\r\n                bonusAmount += update_DynamicBonusCheckInvestOut(addr, dynamicBonusAmount);\r\n            } else {\r\n                bonusAmount = dynamicBonusAmount;\r\n            }\r\n        }\r\n\r\n        user.bonusDynamicAmonut += bonusAmount;\r\n        investData.adduoDynamicBonus += bonusAmount;\r\n        return bonusAmount;\r\n\t}\r\n\r\n    /**\r\n     * @dev Calculate the bonus (All) and update Parent User\r\n     * @param rCode user recommend code\r\n     * @param money invest money\r\n     */\r\n\tfunction countBonus_All(address rCode, uint money)\r\n        private\r\n    {\r\n        bool isSettlement_Node = false;\r\n        uint maxLevel_ServiceFees = 0;\r\n        uint[] memory level_baseMoney_ServiceFees = new uint[](4);\r\n\r\n\t\taddress tmpReferrerCode = rCode;\r\n        uint[2] memory user_data;\r\n        address tmpUser_rCode;\r\n        uint user_status = 0;\r\n\r\n        uint moneyBonus = 0;\r\n\r\n\t\tfor (uint i = 1; i <= 21; i++) {\r\n\t\t\tif (tmpReferrerCode == address(0)) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n            User storage user = userMapping[_getCodeMapping(tmpReferrerCode)];\r\n\r\n            //last rRcode and currUserInfo\r\n            (user_data, , tmpUser_rCode) = _getUserInfo(user.userAddress);\r\n            user_status = user_data[1];\r\n\r\n            //-----------updateUser_Parent Start\r\n            if (i <= 7) {\r\n                user.teamCumulativeInvest += money;\r\n                if (user.levelLockDemotion == 0 || user.level < getLevel(user.teamCumulativeInvest)) {\r\n                    user.level = getLevel(user.teamCumulativeInvest);\r\n\t\t\t\t\tuser.levelLockDemotion = 0;\r\n                }\r\n            }\r\n            //-----------updateUser_Parent End\r\n\r\n            //-----------Node Start\r\n            if (isSettlement_Node == false && user.nodeLevel == 1) {\r\n                if (user.investAmount > user.investAmountOut && user_status == 0) {\r\n                    moneyBonus = money / 20;\r\n\r\n                    AwardData storage awData_Node = user.rewardData[1][user.rewardIndex[1]];\r\n                    //check out\r\n                    awData_Node.amount += update_DynamicBonusCheckInvestOut(user.userAddress, moneyBonus);\r\n                }\r\n\r\n                //break;\r\n                isSettlement_Node = true;\r\n            }\r\n            //-----------Node End\r\n\r\n            //-----------RecommendAlgebra Start\r\n            if (user.investAmount > user.investAmountOut && user_status == 0 && i <= 10 && _getRCodeMappingLength(tmpReferrerCode) >= i) {\r\n                moneyBonus = money / 100;\r\n                //burns\r\n                if (user.investAmountMax < USDTWei * 700 && user.investAmountMax < money) {\r\n                    moneyBonus = user.investAmountMax / 100;\r\n                }\r\n\r\n                //check out\r\n                moneyBonus = update_DynamicBonusCheckInvestOut(user.userAddress, moneyBonus);\r\n\r\n                user.recommendAlgebraAmonut += moneyBonus;\r\n\r\n                //send USDT Token to user addr\r\n                sendTokenToUser(USDTToken, user.userAddress, moneyBonus);\r\n            }\r\n            //-----------RecommendAlgebra End\r\n\r\n            //-----------ServiceFees Start\r\n            if (user.level >= 1) {\r\n                if (user.level > maxLevel_ServiceFees) {\r\n                    moneyBonus = money * (getScaleByLevel(user.level) - getScaleByLevel(maxLevel_ServiceFees)) / 100;\r\n\r\n                    if(user.investAmount > user.investAmountOut && user_status == 0) {\r\n                        AwardData storage awData_ServiceFees = user.rewardData[3][user.rewardIndex[3]];\r\n                        //check out\r\n                        awData_ServiceFees.amount += update_DynamicBonusCheckInvestOut(user.userAddress, moneyBonus);\r\n                    }\r\n\r\n                    level_baseMoney_ServiceFees[user.level] = moneyBonus;\r\n                    maxLevel_ServiceFees = user.level;\r\n                } else {\r\n                    //-----------SameLevel Start\r\n                    moneyBonus = level_baseMoney_ServiceFees[user.level] / 20;\r\n\r\n                    if(user.investAmount > user.investAmountOut && user_status == 0) {\r\n                        AwardData storage awData_SameLevel = user.rewardData[4][user.rewardIndex[4]];\r\n                        //check out\r\n                        awData_SameLevel.amount += update_DynamicBonusCheckInvestOut(user.userAddress, moneyBonus);\r\n                    }\r\n\r\n                    level_baseMoney_ServiceFees[user.level] = moneyBonus;\r\n                    //-----------SameLevel End\r\n                }\r\n            }\r\n            //-----------ServiceFees End\r\n\r\n            tmpReferrerCode = tmpUser_rCode;\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Calculate the bonus (Daily Dividend)\r\n     * @param rCode user recommend code\r\n     * @param money base money\r\n     * @param investMoney invest money\r\n     */\r\n\tfunction countBonus_DailyDividend(address rCode, uint money, uint investMoney)\r\n        private\r\n    {\r\n\t\taddress tmpReferrerCode = rCode;\r\n        uint[2] memory user_data;\r\n        address tmpUser_rCode;\r\n        uint user_status = 0;\r\n\r\n\t\tfor (uint i = 1; i <= 20; i++) {\r\n\t\t\tif (tmpReferrerCode == address(0)) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tUser storage user = userMapping[_getCodeMapping(tmpReferrerCode)];\r\n\r\n            //last rRcode and currUserInfo\r\n            (user_data, , tmpUser_rCode) = _getUserInfo(user.userAddress);\r\n            user_status = user_data[1];\r\n\r\n            //-----------DailyDividend Start\r\n            if (user.investAmount > user.investAmountOut && user_status == 0) {\r\n                uint moneyBonusDailyDividend = 0;\r\n                uint referrals = _getRCodeMappingLength(tmpReferrerCode);\r\n                if ((i <= 10 && referrals >= i) || (referrals >= 12 && user.teamCumulativeInvest >= USDTWei * 90000)) {\r\n                    moneyBonusDailyDividend = getScaleByAlgebra(i) * money / 100;\r\n                    //burns\r\n                    if (user.investAmountMax < USDTWei * 700 && user.investAmountMax < investMoney) {\r\n                        moneyBonusDailyDividend = moneyBonusDailyDividend * user.investAmountMax / investMoney;\r\n                    }\r\n                    if (moneyBonusDailyDividend > 0) {\r\n                        AwardData storage awData_DailyDividend = user.rewardData[2][user.rewardIndex[2]];\r\n                        //check out\r\n                        awData_DailyDividend.amount += update_DynamicBonusCheckInvestOut(user.userAddress, moneyBonusDailyDividend);\r\n                    }\r\n                }\r\n            }\r\n            //-----------DailyDividend End\r\n\r\n            tmpReferrerCode = tmpUser_rCode;\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Calculate the bonus (Daily Dividend) Offspring\r\n     * @param addr user addr\r\n     * @return DailyDividend amount\r\n     */\r\n\tfunction countBonus_DailyDividend_Offspring\r\n    (\r\n        address addr\r\n    )\r\n        private\r\n        view\r\n        returns (uint amount)\r\n    {\r\n        User storage userRoot = userMapping[addr];\r\n\r\n        address tmpParentCode;\r\n        uint[2] memory user_data;\r\n        uint user_status = 0;\r\n        (user_data, tmpParentCode, ) = _getUserInfo(userRoot.userAddress);\r\n        user_status = user_data[1];\r\n\r\n        if (!(userRoot.investAmount > userRoot.investAmountOut && user_status == 0)) {\r\n            return 0;\r\n        }\r\n\r\n        uint userRoot_referrals = _getRCodeMappingLength(tmpParentCode);\r\n        uint userRoot_teamCumulativeInvest = userRoot.teamCumulativeInvest;\r\n        uint userRoot_investAmountMax = userRoot.investAmountMax;\r\n\r\n        address[] memory offspring_CodeArr;\r\n        address[] memory offspring_CodeArr_Temp;\r\n\r\n        //root offspring\r\n        offspring_CodeArr = _getRCodeOffspring(tmpParentCode);\r\n\r\n        for (uint i = 1; i <= 20; i++) {\r\n            offspring_CodeArr_Temp = offspring_CodeArr;\r\n\r\n            for (uint j = 0; j < offspring_CodeArr_Temp.length; j++) {\r\n                amount += countBonus_DailyDividend_User(offspring_CodeArr_Temp[j], userRoot_referrals, userRoot_teamCumulativeInvest, userRoot_investAmountMax, i);\r\n            }\r\n\r\n            if (i >= 20) {\r\n                break;\r\n            }\r\n\r\n            //offspring info\r\n            uint offspring_CodeLength = 0;\r\n            for (uint j = 0; j < offspring_CodeArr_Temp.length; j++) {\r\n                offspring_CodeLength += _getRCodeMappingLength(offspring_CodeArr_Temp[j]);\r\n            }\r\n            offspring_CodeArr = new address[](offspring_CodeLength);\r\n            uint offspring_CodeArrIndex = 0;\r\n            for (uint j = 0; j < offspring_CodeArr_Temp.length; j++) {\r\n                uint l = _getRCodeMappingLength(offspring_CodeArr_Temp[j]);\r\n                for (uint k = 0; k < l; k++) {\r\n                    offspring_CodeArr[offspring_CodeArrIndex] = _getRCodeMapping(offspring_CodeArr_Temp[j], k);\r\n                    offspring_CodeArrIndex ++;\r\n                }\r\n            }\r\n        }\r\n\r\n        //check out\r\n        InvestData memory investData = userRoot.investData[userRoot.maxInvestIndex];\r\n        if (investData.status == 0) {\r\n            if (investData.adduoStaticBonus + investData.adduoDynamicBonus + amount >= investData.money * 3) {\r\n                amount = investData.money * 3 - (investData.adduoStaticBonus + investData.adduoDynamicBonus);\r\n            } else {\r\n                amount = amount;\r\n            }\r\n        } else {\r\n            amount = 0;\r\n        }\r\n\r\n\t\treturn amount;\r\n\t}\r\n\r\n    /**\r\n     * @dev Calculate the bonus (Daily Dividend) User 1 generations\r\n     * @return DailyDividend amount\r\n     */\r\n\tfunction countBonus_DailyDividend_User\r\n    (\r\n        address tmpUserCode,\r\n        uint userRoot_referrals,\r\n        uint userRoot_teamCumulativeInvest,\r\n        uint userRoot_investAmountMax,\r\n        uint generations\r\n    )\r\n        private\r\n        view\r\n        returns (uint amount)\r\n    {\r\n        //Calculate the bonus\r\n        User storage user = userMapping[_getCodeMapping(tmpUserCode)];\r\n\r\n        //-----------DailyDividend Start\r\n        for (uint k = 0; k < user.investIndex; k++) {\r\n            InvestData memory investData = user.investData[k];\r\n            if (investData.status != 0) {\r\n                continue;\r\n            }\r\n            uint settlementNumber = (now - investData.lastRwTime) / 1 days;\r\n            uint settlementMaxMoney = 0;\r\n            if(investData.money * 3 >= investData.adduoStaticBonus + investData.adduoDynamicBonus) {\r\n                settlementMaxMoney = investData.money * 3 - (investData.adduoStaticBonus + investData.adduoDynamicBonus);\r\n            }\r\n            if (investData.money * 5 / 1000 * settlementNumber > settlementMaxMoney) {\r\n                settlementNumber = settlementMaxMoney / investData.money * 5 / 1000;\r\n                if (investData.money * 5 / 1000 * settlementNumber < settlementMaxMoney) {\r\n                    settlementNumber ++;\r\n                }\r\n                if (settlementNumber > (now - investData.lastRwTime) / 1 days) {\r\n                    settlementNumber = (now - investData.lastRwTime) / 1 days;\r\n                }\r\n            }\r\n\r\n            if ((generations <= 10 && userRoot_referrals >= generations) || (userRoot_referrals >= 12 && userRoot_teamCumulativeInvest >= USDTWei * 90000)) {\r\n                uint moneyBonusDailyDividend = getScaleByAlgebra(generations);\r\n                //burns\r\n                if (userRoot_investAmountMax < USDTWei * 700 && userRoot_investAmountMax < investData.money) {\r\n                    amount += moneyBonusDailyDividend * (userRoot_investAmountMax * 5 / 1000 * settlementNumber) / 100;\r\n                } else {\r\n                    amount += moneyBonusDailyDividend * (investData.money * 5 / 1000 * settlementNumber) / 100;\r\n                }\r\n            }\r\n        }\r\n        //-----------DailyDividend End\r\n\r\n\t\treturn (amount);\r\n\t}\r\n}"}}}