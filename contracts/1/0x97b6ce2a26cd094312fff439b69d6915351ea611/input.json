{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/TolikChainSwap/OneInchEth.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\n\nimport './vendors/uniswap-v2-router/interfaces/IERC20.sol';\nimport './vendors/uniswap-lib/libraries/TransferHelper.sol';\n\ncontract OneInch {\n    address private constant ROUTER = 0x1111111254fb6c44bAC0beD2854e76F90643097d; //ETH\n\n    address private _owner;\n\n    constructor () {\n        _owner = msg.sender;\n    }\n\n    function transferBase(address to, uint amount) external {\n        checkOwnership();\n        TransferHelper.safeTransferETH(to, amount);\n    }\n\n    function transferToken(address token, address to, uint amount) external {\n        checkOwnership();\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    function transSwap(bytes calldata callData) external returns (bool success, bytes memory data) {\n        checkOwnership();\n        (success, data) = ROUTER.call(callData);\n    }\n\n    function encSwap(uint256 key, address token, uint256 encAmount, bytes calldata encCallData) external returns (bool success, bytes memory data) {\n        checkOwnership();\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), encAmount ^ key);\n        bytes memory rcall = new bytes(encCallData.length);\n        assembly {\n            calldatacopy(add(rcall, 32), 164, mload(rcall))\n            //0xe449022e\n            mstore8(add(rcall, 32), 0xe4)\n            mstore8(add(rcall, 33), 0x49)\n            mstore8(add(rcall, 34), 0x02)\n            mstore8(add(rcall, 35), 0x2e)\n            mstore(add(rcall, 36), xor(mload(add(rcall, 36)), key))\n        }\n        (success, data) = ROUTER.call(rcall);\n    }\n\n    function approve(address token, address spender, uint amount) external {\n        checkOwnership();\n        safeApprove(IERC20(token), spender, amount);\n    }\n\n    receive() external payable {}\n    \n    function checkOwnership() internal view {\n        require(_owner == msg.sender, \"ACCESS DENIED\");\n    }\n\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        // require((value == 0) || (token.allowance(address(this), spender) == 0),\n        //     \"SafeERC20: approve from non-zero to non-zero allowance\"\n        // );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n    * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n    * on the return value: the return value is optional (but if data is returned, it must not be false).\n    * @param token The token targeted by the call.\n    * @param data The call data (encoded using abi.encode or one of its variants).\n    */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        //require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n\n}\n"},"contracts/TolikChainSwap/vendors/uniswap-lib/libraries/TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"},"contracts/TolikChainSwap/vendors/uniswap-v2-router/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"}}}