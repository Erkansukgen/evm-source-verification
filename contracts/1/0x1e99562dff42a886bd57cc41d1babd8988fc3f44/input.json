{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/admevarbp3.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/v3pool.sol';\nimport './lib/SafeMath.sol';\nimport './lib/PoolAddress.sol';\n\n\n\ninterface IWETH {\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n}\n\n\ninterface chitoken {\n  function freeUpTo(uint256 value) external returns (uint256 freed);\n}\n\ninterface v3quoter{\n  function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n}\n\n\ninterface v2pool{\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n\ncontract mevarbp3 {\n    using SafeMath for uint;\n    \n    address payable public owner;\n    \n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n    \n    // ropsten\n    /*\n    address wethaddr = address(0xc778417E063141139Fce010982780140Aa0cD5Ab);\n    IWETH private constant WETH = IWETH(address(0xc778417E063141139Fce010982780140Aa0cD5Ab));\n    */\n    \n    // goerli\n    \n    /*\n    address wethaddr = address(0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6);\n    IWETH private constant WETH = IWETH(address(0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6));\n    */\n    \n    // main net\n    \n    address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IWETH private constant WETH = IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    \n    \n    address factory = address(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n    \n    \n    \n    // chi\n    chitoken chi = chitoken(address(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c));\n    v3quoter quoter = v3quoter(quoter_addr);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier discountCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        chi.freeUpTo((gasSpent + 14154) / 41947);\n    }\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n    function withdrawethall() external onlyowner {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n\n\n\n    struct SwapInfo {\n        uint256[] poolinfo;\n        address[] tokens;\n        uint256[] amounts;\n        uint256 param;\n        uint256 cur; // point to the current swap pool, plus one after every swap\n    }\n\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        /// require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapInfo memory data = abi.decode(_data, (SwapInfo));\n\n        uint256[] memory local_poolinfo = data.poolinfo;\n        address[] memory local_tokens = data.tokens;\n        uint256 local_cur = data.cur;\n        uint256 cur_pool_info = local_poolinfo[local_cur];\n        uint256 token_in_index = (cur_pool_info >> 168) & 0x000000ff;\n        uint256 token_out_index = (cur_pool_info  >> 160) & 0x00000000ff;\n        // uint256 rc_index = cur_pool_info >> 192;\n        //uint256 v3num = data.param >> 248;\n        // uint24 fee = uint24((cur_pool_info  >> 176) & 0x00ffff);\n        // v3num first stores the fee, then v3num \n        uint256 v3num = (cur_pool_info  >> 176) & 0x00ffff;\n        address receiver;\n        \n        \n        \n        // verify caller to make it safe\n        address addr_p = PoolAddress.computeAddress(factory, PoolAddress.getPoolKey(local_tokens[token_in_index], local_tokens[token_out_index], uint24(v3num)));\n        require(msg.sender == addr_p);\n        \n        v3num = data.param >> 248;\n\n\n        \n        // if last v3 swap, send weth to the first pool\n        // and do all the v2 swaps\n        if(local_cur + 1 == v3num){\n            _safeTransfer(wethaddr, address(local_poolinfo[(data.param >> 240) & 0x00ff] & 0x00ffffffffffffffffffffffffffffffffffffffff), (data.param >> 120) & 0x0000ffffffffffffffffffffffffffffff );\n            \n            // do the v2 swaps\n            if(v3num == local_poolinfo.length){\n                return;\n            }else{\n                // the pools after data.cur is all v2 pools\n                for(uint i = local_cur + 1; i < local_poolinfo.length; i++){\n                    // reuse the token_in_index to save some gas\n                    token_in_index = local_poolinfo[i] >> 168;\n                    \n                    //reuse the addr_p as the new v2 pool to save some gas\n                    addr_p = address(local_poolinfo[i] & 0x00ffffffffffffffffffffffffffffffffffffffff);\n                    \n                    if(token_in_index == local_poolinfo.length){\n                        receiver = address(this);\n                    }else{\n                        receiver = address(local_poolinfo[token_in_index] & 0x00ffffffffffffffffffffffffffffffffffffffff);\n                    }                 \n            \n                    // reuse v3num here to save some gas\n                    if(i % 2 == 1){\n                        // the left 128 bits contains the amount \n                        v3num = data.amounts[i/2] >> 128;\n                    }else{\n                        // the right 128bits contains the first amount\n                        v3num = data.amounts[i/2] & 0xffffffffffffffffffffffffffffffff;\n                    }\n            \n                    if((local_poolinfo[i] >> 160 & 0x00ff) == 1 ){\n                        v2pool(addr_p).swap(0, v3num, receiver, new bytes(0));\n                    }else{\n                        v2pool(addr_p).swap(v3num, 0, receiver, new bytes(0));\n                    }\n                }\n            }\n            \n            return;\n\n        }\n        \n        // not the last v3 swap, so swap v3 again\n        local_cur = local_cur + 1;\n        data.cur = local_cur;\n        // reuse cur_pool_info to save some gas\n        cur_pool_info = local_poolinfo[local_cur];\n        // uint256 rc_index = cur_pool_info >> 192;\n        // reuse the token_out_index instead of the rc_index to save some gas\n        token_out_index = cur_pool_info >> 192;\n     \n        bytes memory callbackdata = abi.encode(data);  \n\n        if(token_out_index == local_poolinfo.length){\n            receiver = address(this);\n        }else{\n            receiver = address(local_poolinfo[token_out_index] & 0x00ffffffffffffffffffffffffffffffffffffffff);\n        }\n\n\n        token_in_index = (cur_pool_info >> 168) & 0x000000ff;\n        token_out_index = (cur_pool_info  >> 160) & 0x00000000ff;  \n\n        bool zeroForOne = local_tokens[token_in_index] < local_tokens[token_out_index];\n        addr_p = address(cur_pool_info & 0x00ffffffffffffffffffffffffffffffffffffffff);\n        \n        // reuse v3num to store the amount\n        if(local_cur % 2 == 1){\n            v3num = data.amounts[local_cur / 2] >> 128;\n        }else{\n            v3num = data.amounts[local_cur / 2] & 0xffffffffffffffffffffffffffffffff;\n        }\n        \n        v3pool(addr_p).swap(receiver, zeroForOne, int256(v3num), \n                       zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, callbackdata);   \n\n    }\n\n\n\n\n\n\n\n\n    function arbswap(uint256[] memory poolinfo,  address[] memory tokens, uint256[] memory amounts, uint256 param) public discountCHI{\n      \n        // check the blknum to avoid the uncle blk pack\n        if(block.number > (param >> 96) & 0xffffff){\n            return;\n        }\n      \n        uint256 gasstart = gasleft();\n        uint256 balance;\n        balance = IERC20(wethaddr).balanceOf(address(this)) + address(this).balance;\n      \n        uint256 firstpoolinfo = poolinfo[0];\n\n        uint256 rc_index = firstpoolinfo >> 192;\n        address pool_addr = address(firstpoolinfo & 0x00ffffffffffffffffffffffffffffffffffffffff);        \n        \n        \n        bool zeroForOne = tokens[(firstpoolinfo >> 168) & 0x000000ff] < tokens[(firstpoolinfo >> 160) & 0x00000000ff];\n        \n        address receiver;\n        \n        if(rc_index == poolinfo.length){\n            receiver = address(this);\n        }else{\n            receiver = address(poolinfo[rc_index]  & 0x00ffffffffffffffffffffffffffffffffffffffff);\n        }        \n        \n        bytes memory callbackdata = abi.encode(SwapInfo({poolinfo: poolinfo, tokens: tokens, amounts: amounts, param: param, cur:0}));\n        // amounts occupys 16bytes\n        int256 firstsend = int256(amounts[0] & 0xffffffffffffffffffffffffffffffff);\n        v3pool(pool_addr).swap(receiver, zeroForOne, firstsend, \n                       zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, callbackdata);\n                      \n        block.coinbase.call{value: (param & 0xffffffffffffffffffffffff)}(new bytes(0));\n        \n\n        param = IERC20(wethaddr).balanceOf(address(this)) + address(this).balance;\n        \n\n        require(param > balance + (tx.gasprice * (gasstart - gasleft())), \"i\");     \n      \n    }\n\n\n\n    function arbswapn(uint256[] memory poolinfo,  address[] memory tokens, uint256[] memory amounts, uint256 param) public{\n      \n        // check the blknum to avoid the uncle blk pack\n        if(block.number > (param >> 96) & 0xffffff){\n            return;\n        }\n      \n        uint256 gasstart = gasleft();\n        uint256 balance;\n        balance = IERC20(wethaddr).balanceOf(address(this)) + address(this).balance;\n      \n        uint256 firstpoolinfo = poolinfo[0];\n\n        uint256 rc_index = firstpoolinfo >> 192;\n        address pool_addr = address(firstpoolinfo & 0x00ffffffffffffffffffffffffffffffffffffffff);        \n        \n        \n        bool zeroForOne = tokens[(firstpoolinfo >> 168) & 0x000000ff] < tokens[(firstpoolinfo >> 160) & 0x00000000ff];\n        \n        address receiver;\n        \n        if(rc_index == poolinfo.length){\n            receiver = address(this);\n        }else{\n            receiver = address(poolinfo[rc_index]  & 0x00ffffffffffffffffffffffffffffffffffffffff);\n        }        \n        \n        bytes memory callbackdata = abi.encode(SwapInfo({poolinfo: poolinfo, tokens: tokens, amounts: amounts, param: param, cur:0}));\n        // amounts occupys 16bytes\n        int256 firstsend = int256(amounts[0] & 0xffffffffffffffffffffffffffffffff);\n        v3pool(pool_addr).swap(receiver, zeroForOne, firstsend, \n                       zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1, callbackdata);\n                      \n        block.coinbase.call{value: (param & 0xffffffffffffffffffffffff)}(new bytes(0));\n        \n\n        param = IERC20(wethaddr).balanceOf(address(this)) + address(this).balance;\n        \n\n        require(param > balance + (tx.gasprice * (gasstart - gasleft())), \"i\");     \n      \n    }\n\n\n\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    } \n\n\n    // the first flag indicts whether the token transferred to the pool is the token0\n    function v2out(address pool, bool first, uint256 amountIn) private returns (uint256 amountOut){\n        bytes memory returnData;\n        (, returnData) = pool.staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n        \n        (uint reserveInput, uint reserveOutput) = (first) ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        amountOut = getAmountOut(amountIn, reserveInput, reserveOutput);\n        \n        return(amountOut);\n    }\n    \n    \n    function v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\n    }\n    \n    // simulate a swap and returns the exact output amount through trace_call\n    function simulateoutput(uint256 amountin,  address[] memory pools, address[] memory tokens, uint256[] memory flags) public returns(uint256[] memory amounts){\n \n        amounts = new uint256[](pools.length);\n        // loop all the pools and do the swap\n        for(uint i = 0; i < flags.length; i++){\n            // the pool going to swap is v2 pool\n            if((flags[i] >> 128) == 0){\n                amountin = v2out(pools[i], tokens[i] < tokens[i+1], amountin);\n                amounts[i] = amountin;\n            } else{\n                amountin = v3out(tokens[i], tokens[i+1], uint24(flags[i] & 0x00ffffffffffffffffffffffffffffffff), amountin);\n                amounts[i] = amountin;\n            } \n   \n        }\n        \n        \n    }\n\n    function unwrapweth(uint256 amount) public onlyowner {\n        WETH.withdraw(amount);\n    }\n    \n\n}"
    },
    "contracts/interfaces/v3pool.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n}\n"
    },
    "contracts/lib/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        //require(key.token0 < key.token1);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n  \n}"
    }
  }
}