{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"/home/mak/Documents/repos/blank/smart-contracts/contracts/libs/Address.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/libs/Counters.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/libs/SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n\n        return a % b;\n    }\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/libs/Signature.sol":{"content":"pragma solidity ^0.5.0;\n\nlibrary Signature {\n\n    /**\n     * @dev Splits signature\n     */\n    function splitSignature(bytes memory sig) private pure returns (uint8 v, bytes32 r, bytes32 s) {\n        require(sig.length == 65);\n\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(sig, 32))\n            // second 32 bytes.\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    /**\n     * @dev Recovers signer\n     */\n    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n\n        return ecrecover(message, v, r, s);\n    }\n\n    /**\n     * @dev Builds a prefixed hash to mimic the behavior of eth_sign.\n     */\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/libs/Strings.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @title Strings\n * @dev String operations.\n */\nlibrary Strings {\n\n    /**\n     * @dev Converts a `uint256` to a `string`.\n     * via OraclizeAPI - MIT licence\n     * https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n     */\n    function fromUint256(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n\n        temp = value;\n\n        while (temp != 0) {\n            buffer[index--] = byte(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n\n        return string(buffer);\n    }\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/minter/BlankGroupCollectionV2.sol":{"content":"pragma solidity ^0.5.0;\n\npragma experimental ABIEncoderV2;\n\nimport \"./../libs/SafeMath.sol\";\nimport \"./../libs/Counters.sol\";\nimport \"./../libs/Address.sol\";\nimport \"./../libs/Strings.sol\";\nimport \"./../libs/Signature.sol\";\n\nimport \"./../token/erc721/IERC721.sol\";\nimport \"./../token/erc721/IERC721Metadata.sol\";\nimport \"./../token/erc721/IERC721Receiver.sol\";\n\nimport \"./IBlankCollectionFactory.sol\";\nimport \"./BlankOwnable.sol\";\n\ncontract BlankGroupCollectionV2 is BlankOwnable, IERC721, IERC721Metadata {\n\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n    using Strings for uint256;\n    using Signature for bytes32;\n\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n    bytes4 private constant _INTERFACE_ID_BLANK_GROUP = 0x42df37a1;\n\n    event ParticipantAdded(address account, uint256 nonce);\n    event ParticipantRemoved(address account);\n    event ParticipantRemovedByOwner(address account);\n\n    event BatchMint(address account, uint256[] ids, string[] uris, uint256 royalty);\n\n    // The \"CollectionFactory\" smart contract\n    IBlankCollectionFactory private _factoryContract;\n\n    uint256 private _autoIncrement;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // The total amount of tokens\n    uint256 private _totalSupply;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    // Mapping from token ID to creator\n    mapping(uint256 => address) private _creators;\n\n    // Mapping address of accounts in whitelist\n    mapping(address => bool) private _participants;\n\n    // The total accounts in whitelist\n    uint256 private _totalParticipants;\n\n    mapping(address => uint256) private _nonces;\n\n    /**\n     * @dev Initial function that proxies point to\n     */\n    function initialize(address creator, string memory name, string memory symbol)\n        public\n    {\n        _factoryContract = IBlankCollectionFactory(_msgSender());\n\n        require(_factoryContract.isWhitelist(7, creator), \"Collection: caller is not in whitelist\");\n\n        initialize(creator);\n\n        _name = name;\n        _symbol = symbol;\n        _participants[creator] = true;\n\n        _totalParticipants = 1;\n        _autoIncrement = 1;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        returns (bool)\n    {\n        if (interfaceId == _INTERFACE_ID_BLANK_GROUP) {\n            return true;\n        }\n\n        return _factoryContract.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Gets address of the \"CollectionFactory\" smart contract.\n     * @return address representing the \"CollectionFactory\" smart contract\n     */\n    function factoryContract()\n        public\n        view\n        returns (address)\n    {\n        return address(_factoryContract);\n    }\n\n    /**\n     * @dev Gets the token name.\n     * @return string representing the token name\n     */\n    function name()\n        public\n        view\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol.\n     * @return string representing the token symbol\n     */\n    function symbol()\n        public\n        view\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner)\n        public\n        view\n        returns (uint256)\n    {\n        require(owner != address(0), \"Collection: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        returns (address)\n    {\n        address owner = _tokenOwner[tokenId];\n\n        require(owner != address(0), \"Collection: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId)\n        public\n    {\n        address msgSender = _msgSender();\n\n        address owner = ownerOf(tokenId);\n\n        require(to != owner, \"Collection: approval to current owner\");\n\n        require(msgSender == owner || isApprovedForAll(owner, msgSender),\n            \"Collection: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        returns (address)\n    {\n        require(_exists(tokenId), \"Collection: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved)\n        public\n    {\n        address msgSender = _msgSender();\n\n        require(to != msgSender, \"Collection: approve to caller\");\n\n        _operatorApprovals[msgSender][to] = approved;\n\n        emit ApprovalForAll(msgSender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId)\n        public\n    {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"Collection: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId)\n        public\n    {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data)\n        public\n    {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"Collection: transfer caller is not owner nor approved\");\n\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data)\n        internal\n    {\n        _transferFrom(from, to, tokenId);\n\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"Collection: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        return _tokenOwner[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        returns (bool)\n    {\n        require(_exists(tokenId), \"Collection: operator query for nonexistent token\");\n\n        address owner = ownerOf(tokenId);\n\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId)\n        internal\n    {\n        require(to != address(0), \"Collection: mint to the zero address\");\n        require(!_exists(tokenId), \"Collection: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n        _totalSupply = _totalSupply.add(1);\n\n        _creators[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId)\n        internal\n    {\n        require(ownerOf(tokenId) == owner, \"Collection: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _tokenOwner[tokenId] = address(0);\n        _ownedTokensCount[owner].decrement();\n        _totalSupply = _totalSupply.sub(1);\n\n        emit Transfer(owner, address(0), tokenId);\n\n        delete _creators[tokenId];\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId)\n        internal\n    {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId)\n        internal\n    {\n        require(ownerOf(tokenId) == from, \"Collection: transfer of token that is not own\");\n        require(to != address(0), \"Collection: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal\n        returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ));\n\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n\n            } else {\n                revert(\"Collection: transfer to non ERC721Receiver implementer\");\n            }\n\n        } else {\n            bytes4 retval = abi.decode(returndata, (bytes4));\n            return (retval == _ERC721_RECEIVED);\n        }\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId)\n        private\n    {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n\n    /**\n     * @dev Returns the URI for a given token ID. May return an empty string.\n     *\n     * If a base URI is set (via {_setBaseURI}), it is added as a prefix to the\n     * token's own URI (via {_setTokenURI}).\n     *\n     * If there is a base URI but no token URI, the token's ID will be used as\n     * its URI when appending it to the base URI. This pattern for autogenerated\n     * token URIs can lead to large gas savings.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        returns (string memory)\n    {\n        require(_exists(tokenId), \"Collection: URI query for nonexistent token\");\n\n        string memory _baseURI = baseURI();\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // If there is no base URI, return the token URI.\n        if (bytes(_baseURI).length == 0) {\n            return _tokenURI;\n        }\n\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(_baseURI, tokenId.fromUint256()));\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token.\n     *\n     * Reverts if the token ID does not exist.\n     *\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\n     * `http://api.myproject.com/token/<id>`), use {_setBaseURI} to store\n     * it and save gas.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI)\n        internal\n    {\n        require(_exists(tokenId), \"Collection: URI set of nonexistent token\");\n\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Returns the base URI set via {_setBaseURI}. This will be\n     * automatically added as a preffix in {tokenURI} to each token's URI, when\n     * they are non-empty.\n     */\n    function baseURI()\n        public\n        view\n        returns (string memory)\n    {\n        return _factoryContract.baseURI();\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract.\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply()\n        public\n        view\n        returns (uint256)\n    {\n        return _totalSupply;\n    }\n\n    /**\n      * @dev Returns total accounts in whitelist\n      */\n    function totalParticipants()\n        public\n        view\n        returns (uint256)\n    {\n        return _totalParticipants;\n    }\n\n    /**\n      * @dev Returns value greater than zero if account is in whitelist\n      */\n    function participants(address account)\n        public\n        view\n        returns (uint256)\n    {\n        if (!_participants[account]) {\n            return 0;\n        }\n\n        if (account == owner()) {\n            return 1;\n        }\n\n        return 2;\n    }\n\n    /**\n     * @dev Mints token\n     */\n    function mint(string[] memory uris)\n        public\n    {\n        uint256 length = uris.length;\n\n        require(length > 0, \"Collection: length of array is invalid\");\n\n        uint256 id = _autoIncrement;\n\n        address owner = _msgSender();\n\n        require(_participants[owner], \"Collection: account doesn't have permission to mint\");\n\n        uint256[] memory ids = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            _mint(owner, id);\n            _setTokenURI(id, uris[i]);\n\n            ids[i] = id;\n\n            id++;\n        }\n\n        _autoIncrement = id;\n\n        emit BatchMint(owner, ids, uris, 0);\n    }\n\n    /**\n     * @dev Burns a specific token\n     */\n    function burn(uint256 tokenId)\n        public\n    {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"Collection: burn of token that is not own nor approved\");\n\n        _burn(tokenId);\n    }\n\n    /**\n     * @dev Gets token creator\n     */\n    function creator(uint256 tokenId)\n        public\n        view\n        returns (address)\n    {\n        return _creators[tokenId];\n    }\n\n    /**\n     * @dev Adds account to whitelist\n     */\n    function addParticipant(address[] memory accounts, uint256 index, uint256 expire, uint256 nonce, bytes memory signature)\n        public\n    {\n        address owner = owner();\n\n        bytes32 message = keccak256(abi.encodePacked(accounts, expire, nonce, this)).prefixed();\n\n        require(message.recoverSigner(signature) == owner, \"Collection: signature is invalid\");\n\n        address msgSender = _msgSender();\n\n        require(msgSender != owner && msgSender == accounts[index], \"Collection: caller is owner or not in the invitation list\");\n\n        require(!_participants[msgSender], \"Collection: caller was added\");\n\n        require(expire > now, \"Collection: signature was expired\");\n\n        require(_nonces[msgSender] < nonce, \"Collection: nonce is invalid\");\n\n        _nonces[msgSender] = nonce;\n\n        _participants[msgSender] = true;\n\n        _totalParticipants = _totalParticipants.add(1);\n\n        emit ParticipantAdded(msgSender, nonce);\n    }\n\n    /**\n     * @dev Internal function to remove account in whitelist\n     */\n    function _removeParticipant(address account)\n        internal\n    {\n        require(account != owner() && _participants[account], \"Collection: caller is owner or not in whitelist\");\n\n        _participants[account] = false;\n\n        _totalParticipants = _totalParticipants.sub(1);\n    }\n\n    /**\n     * @dev Removes account in whitelist\n     */\n    function removeParticipant()\n        public\n    {\n        address msgSender = _msgSender();\n\n        _removeParticipant(msgSender);\n\n        emit ParticipantRemoved(msgSender);\n    }\n\n    /**\n     * @dev Removes accounts in whitelist by admin\n     */\n    function removeParticipants(address[] memory accounts)\n        public\n        onlyOwner\n    {\n        address owner = _msgSender();\n\n        uint256 length = accounts.length;\n\n        uint256 count = 0;\n\n        for (uint256 i = 0; i < length; i++) {\n            address account = accounts[i];\n\n            if (account == owner || !_participants[account]) {\n                continue;\n            }\n\n            _participants[account] = false;\n            \n            count++;\n\n            emit ParticipantRemovedByOwner(account);\n        }\n\n        if (count > 0) {\n            _totalParticipants = _totalParticipants.sub(count);\n        }\n    }\n\n    /**\n     * @dev Returns nonce was used\n     */\n    function nonces(address account)\n        public\n        view\n        returns (uint256)\n    {\n        return _nonces[account];\n    }\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/minter/BlankOwnable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport '@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol';\n\ncontract BlankOwnable is Context {\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    address private _owner;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function initialize(address sender)\n        internal\n        initializer\n    {\n        _owner = sender;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner()\n        public\n        view\n        returns (address)\n    {\n        return _owner;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner()\n        public\n        view\n        returns (bool)\n    {\n        return _msgSender() == _owner;\n    }\n\n    uint256[50] private ______gap;\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/minter/IBlankCollectionFactory.sol":{"content":"pragma solidity ^0.5.0;\n\ninterface IBlankCollectionFactory {\n\n    function baseURI() external view returns (string memory);\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    function isWhitelist(uint256 logicType, address account) external view returns (bool);\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/token/erc721/IERC721.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 {\n\n    /**\n     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from`, `to` cannot be zero.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/token/erc721/IERC721Metadata.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n}"},"/home/mak/Documents/repos/blank/smart-contracts/contracts/token/erc721/IERC721Receiver.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n\n}"},"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"@openzeppelin/upgrades/contracts/Initializable.sol":{"content":"pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"}}}