{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/testo.sol": {
      "content": "/*\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n─██████████████─██████████████─██████──██████─██████████████─██████████████████────████████──────────██████████████─\n─██░░░░░░░░░░██─██░░░░░░░░░░██─██░░██──██░░██─██░░░░░░░░░░██─██░░░░░░░░░░░░░░██────██░░░░██──────────██░░░░░░░░░░██─\n─██░░██████████─██████░░██████─██░░██──██░░██─██░░██████░░██─████████████░░░░██────████░░██──────────██░░██████░░██─\n─██░░██─────────────██░░██─────██░░██──██░░██─██░░██──██░░██─────────████░░████──────██░░██──────────██░░██──██░░██─\n─██░░██████████─────██░░██─────██░░██████░░██─██░░██──██░░██───────████░░████────────██░░██──────────██░░██──██░░██─\n─██░░░░░░░░░░██─────██░░██─────██░░░░░░░░░░██─██░░██──██░░██─────████░░████──────────██░░██──────────██░░██──██░░██─\n─██░░██████████─────██░░██─────██░░██████░░██─██░░██──██░░██───████░░████────────────██░░██──────────██░░██──██░░██─\n─██░░██─────────────██░░██─────██░░██──██░░██─██░░██──██░░██─████░░████──────────────██░░██──────────██░░██──██░░██─\n─██░░██████████─────██░░██─────██░░██──██░░██─██░░██████░░██─██░░░░████████████────████░░████─██████─██░░██████░░██─\n─██░░░░░░░░░░██─────██░░██─────██░░██──██░░██─██░░░░░░░░░░██─██░░░░░░░░░░░░░░██────██░░░░░░██─██░░██─██░░░░░░░░░░██─\n─██████████████─────██████─────██████──██████─██████████████─██████████████████────██████████─██████─██████████████─\n────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\nImmutable Global Single Line Autopool | 100% Open Source  | 100% Decentralized\n\nVisit at : https://www.ethoz.io/\n\n*/\n\npragma solidity ^0.6.0;\n\ncontract ethoz {\n    address payable public owner;\n    uint256 public SumEthz;\n    uint256 public wrgEthz;\n    uint256 public WaitCnt;\n    uint256 public ethozid;\n    uint256 public ethzslotid;\n    uint256 public lastsent;\n    uint256 public ethozsent;\n    uint256 public ethozbal;\n    \n    constructor(address payable _owner,address payable _genesisUsr) public\n    {\n        owner = _owner;\n        ethozid = 100;\n        ethzslotid = 1000;\n        SumEthz = 0;\n        lastsent = 999;\n        wrgEthz = 0;\n        \n        User memory genusr = User({\n            isExist: true,\n            activeslotid: 0,\n            id:ethozid,\n            referrer:_genesisUsr,\n            partners:0,\n            complete:0,\n            lastslotid:0\n        });\n        users[_genesisUsr] = genusr;\n        usrIds[ethozid] = _genesisUsr;\n        ethozid++;\n    }\n    \n    event newRegistered(uint indexed userid, address indexed userAdr,address indexed inviter); \n    event NewSlotBuy(uint indexed _uid,uint indexed _slotid, address indexed userAdr, uint256 amount); \n    event EthozPaid(uint indexed _slotid, address indexed userAdr, uint256 amount); \n    \n    struct User{\n        bool isExist;\n        uint256 activeslotid;\n        uint256 id;\n        address referrer;\n        uint256 partners;\n        uint complete;\n        uint256 lastslotid;\n    }\n    \n    mapping(address => User) public users;\n    mapping(uint256 => address) public usrIds;\n    \n    enum statuses {Created,Paid,Due,Sent}\n    \n    struct slot{\n        address payable uadress;\n        uint256 amountrcvd;\n        uint256 dueamount;\n        statuses status;\n    }\n    \n    mapping(uint256 => slot) public ethozslots;\n    \n    modifier oad() {\n        require(msg.sender == owner, \"You are not contract owner\");\n        _;\n    }\n    \n    function register(address userAddress, address refAddress) private {\n        uint32 size;\n        assembly {size := extcodesize(userAddress)}\n        require(size == 0, \"Registration address cannot be a contract\");\n        require(users[userAddress].isExist == false, \"User already exist\");\n        if(users[refAddress].isExist == false){\n            refAddress = usrIds[100];\n            users[usrIds[100]].partners += 1;\n        }\n        else{\n            users[refAddress].partners += 1;\n        }\n        User memory newusr = User({\n            isExist: true,\n            activeslotid: 0,\n            id:ethozid,\n            referrer:refAddress,\n            partners:0,\n            complete:0,\n            lastslotid:0\n            \n        });\n        users[userAddress] = newusr;\n        usrIds[ethozid] = userAddress;\n        ethozid++;\n        SumEthz += 0.001 ether;\n        emit newRegistered(ethozid - 1,userAddress,refAddress);\n    }\n    \n    function buyslot(address payable uadrslot) private {\n        require(users[uadrslot].isExist == true, \"User not exist, please register first.\");\n        require(users[uadrslot].activeslotid == 0, \"Already own active slot\");\n        slot memory newslot = slot({\n            uadress: uadrslot,\n            amountrcvd: 0.1 ether,\n            dueamount:0.15 ether,\n            status: statuses.Paid\n        });\n        ethozslots[ethzslotid] = newslot;\n        users[uadrslot].activeslotid = ethzslotid;\n        SumEthz += 0.005 ether;\n        ethozbal += 0.1 ether;\n        emit NewSlotBuy(users[uadrslot].id,ethzslotid,msg.sender,msg.value);\n        ethzslotid++;\n        \n        uint256 dueslot = 0;\n        dueslot = lastsent + 1;\n        if(ethozslots[dueslot].status == statuses.Paid && ethozbal >= ethozslots[dueslot].dueamount && ethozslots[dueslot].dueamount > 0)\n        {\n        uint256 dueamt = ethozslots[dueslot].dueamount;\n        ethozbal = ethozbal - dueamt;\n        ethozslots[dueslot].status = statuses.Sent;\n        users[ethozslots[dueslot].uadress].activeslotid = 0;\n        users[ethozslots[dueslot].uadress].complete += 1;\n        lastsent = dueslot;\n        users[ethozslots[dueslot].uadress].lastslotid = dueslot;\n        ethozsent += dueamt;\n        ethozslots[dueslot].dueamount = 0;\n        ethozslots[dueslot].uadress.transfer(dueamt);\n        emit EthozPaid(dueslot,ethozslots[dueslot].uadress,dueamt);\n        }\n    }\n    \n    function regme(address rfAdr) external payable {\n        require(msg.value == 0.001 ether, \"Send 0.001 ether to register\");\n        register(msg.sender, rfAdr);\n    }\n\n    function buynewslot() external payable {\n        require(msg.value == 0.105 ether, \"Send 0.105 ether to buy slot\");\n        buyslot(msg.sender);\n    }\n    \n    receive() external payable {\n        if(msg.value > 0)\n        {\n            if(msg.value == 0.001 ether && msg.data.length == 0)\n            {\n                return register(msg.sender, usrIds[100]);\n            }\n            else if(msg.value == 0.001 ether)\n            {\n                return register(msg.sender, bytesToAddress(msg.data));\n            }\n            else if(msg.value == 0.105 ether)\n            {\n                return buyslot(msg.sender);\n            }\n            else\n            {\n                revert(\"Invalid transaction or transaction amount\");\n            }\n        }\n    }\n    \n    function getEthozCnt() public view returns (uint){\n            return ethozid;\n    }\n    \n    function getSlotCnt() public view returns (uint){\n            return ethzslotid;\n    }\n    \n    function getLastSent() public view returns (uint){\n            return lastsent;\n    }\n    \n    function getEthozBal() public view returns (uint256){\n            return ethozbal;\n    }\n    \n    function getEthozSent() public view returns (uint256){\n            return ethozsent;\n    }\n    \n    function getRegEthoz() public view returns (uint256){\n            return SumEthz;\n    }\n    \n    function getUsrActvSlid(address _uadr) public view returns (uint){\n            return users[_uadr].activeslotid;\n    }\n    \n    function getUsrAdr(uint256 _slid) public view returns (address){\n            return usrIds[_slid];\n    }\n    \n    function getUsrId(address adrss) public view returns (uint){\n            return users[adrss].id;\n    }\n    \n    function getWtng(address uadr) public view returns (uint){\n        require(users[uadr].isExist == true, \"User not exist.\");\n        uint256 wtng = 0;\n        if(users[uadr].activeslotid > 0 && users[uadr].activeslotid >= lastsent)    \n        {\n            wtng = users[uadr].activeslotid - lastsent;\n        }\n        return wtng;\n    }\n    \n    function getUser(address chkAdr) public view returns(uint256 ActvSlot, uint256 uid,address ref,uint invites,uint cdone,uint256 LastSlot)\n    {\n        require(users[chkAdr].isExist == true, \"User not exist.\");\n        ActvSlot = users[chkAdr].activeslotid;\n        uid = users[chkAdr].id;\n        ref = users[chkAdr].referrer;\n        invites = users[chkAdr].partners;\n        cdone = users[chkAdr].complete;\n        LastSlot = users[chkAdr].lastslotid;\n        \n        return(ActvSlot,uid,ref,invites,cdone,LastSlot);\n    }\n    \n    function getSlot(uint256 slid) public view returns(address uAdr,uint256 amount, uint256 due,uint stat)\n    {\n        uAdr = ethozslots[slid].uadress;\n        amount = ethozslots[slid].amountrcvd;\n        due = ethozslots[slid].dueamount;\n        stat = uint(ethozslots[slid].status);\n        \n        return(uAdr,amount,due,stat);\n    }\n    \n    fallback() external payable {\n        \n    }\n    \n    function bytesToAddress(bytes memory byts) private pure returns (address addrs) {\n        assembly {\n            addrs := mload(add(byts, 20))\n        }\n        return addrs;\n    }\n    \n    function EthozRegAd(address payable wadr, uint256 amt) public oad\n    {   \n        require(SumEthz >= amt, \"Balance is low\");\n        wrgEthz += amt;\n        SumEthz -= amt;\n        wadr.transfer(amt);\n    }\n}"
    }
  }
}