{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/UpDownMarket.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.12;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint);\n  function balanceOf(address account) external view returns (uint);\n  function transfer(address recipient, uint amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint);\n  function approve(address spender, uint amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n}\n\ninterface IORACLE {\n  function price0Last(address _pair) external view returns (uint amountOut);\n  function update(address _pair) external;\n  function isUpdateRequired(address _pair) external view returns(bool);\n  function initialize() external;\n  function addPair(address _pair) external;\n  function lastUpdateAt(address _pair) external view returns(uint);\n  function PERIOD() external view returns(uint);\n}\n\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract Ownable {\n\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor() internal {\n    owner = msg.sender;\n    emit OwnershipTransferred(address(0), owner);\n  }\n\n  modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function isOwner() public view returns (bool) {\n    return msg.sender == owner;\n  }\n\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(owner, address(0));\n    owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n}\n\ncontract UpDownMarket is Ownable, ReentrancyGuard {\n\n  using SafeMath for uint;\n\n  IORACLE public oracle;\n  address public oraclePair;\n  address public feeRecipient;\n\n  uint public latestBidTime = 10 minutes; // before resolution\n\n  mapping (uint => uint) public resolvedTo; // per epoch: 1 = up, 2 = down\n  mapping (uint => uint) public totalSharesUp; // per epoch\n  mapping (uint => uint) public totalSharesDown; // per epoch\n  mapping (uint => uint) public purchasedEpoch; // per epoch\n  mapping (uint => mapping (address => uint)) public purchasedOfUp; // epoch[account]\n  mapping (uint => mapping (address => uint)) public purchasedOfDown; // epoch[account]\n  mapping (uint => mapping (address => uint)) public sharesOfUp; // epoch[account]\n  mapping (uint => mapping (address => uint)) public sharesOfDown; // epoch[account]\n\n  uint public currentEpoch = 0;\n  uint public lastTWAP;\n  uint public feeBps = 0;\n  uint public maxSupply = 10e18; // ETH\n  uint public maxMultiplier = 10e18;\n\n  modifier checkTime() {\n    require(isTimeOpen(block.timestamp), \"UpDownMarket: buying is closed\");\n    _;\n  }\n\n  modifier enforceLimits() {\n    _;\n    require(purchasedEpoch[currentEpoch] <= maxSupply, \"UpDownMarket: maxSupply reached\");\n  }\n\n  constructor(IORACLE _oracle, address _oraclePair) public {\n    oracle = _oracle;\n    oraclePair = _oraclePair;\n    oracle.initialize();\n    oracle.addPair(oraclePair);\n    lastTWAP = oracle.price0Last(oraclePair);\n  }\n\n  function buyUp(uint _minShares) public payable checkTime enforceLimits nonReentrant {\n    _mintUp(msg.sender, currentEpoch, msg.value, _minShares);\n  }\n\n  function buyDown(uint _minShares) public payable checkTime enforceLimits nonReentrant {\n    _mintDown(msg.sender, currentEpoch, msg.value, _minShares);\n  }\n\n  function claim(uint _epoch) public nonReentrant {\n    uint transferAmount = winAmount(_epoch, msg.sender);\n    require(transferAmount > 0, \"UpDownMarket: not a winner\");\n\n    uint fee = transferAmount.mul(feeBps).div(10000);\n    _sendEth(feeRecipient, _epoch, fee);\n    transferAmount = transferAmount.sub(fee);\n\n    _sendEth(msg.sender, _epoch, transferAmount);\n    _burnAll(msg.sender, _epoch);\n  }\n\n  function resolve() public {\n    require(oracle.isUpdateRequired(oraclePair), \"UpDownMarket: too early\");\n    \n    oracle.update(oraclePair);\n\n    uint currentTWAP = oracle.price0Last(oraclePair);\n\n    if (currentTWAP > lastTWAP) {\n      resolvedTo[currentEpoch] = 1;\n      _claimDustUp(currentEpoch);\n\n    } else if (currentTWAP < lastTWAP) {\n      resolvedTo[currentEpoch] = 2;\n      _claimDustDown(currentEpoch);\n    \n    } else {\n      revert(\"UpDownMarket: twap not changed yet\");\n    }\n\n    currentEpoch = currentEpoch.add(1);\n    lastTWAP = currentTWAP;\n  }\n\n  function setFeeBps(uint _value) public onlyOwner {\n    feeBps = _value;\n  }\n\n  function setMaxMultiplier(uint _value) public onlyOwner {\n    maxMultiplier = _value;\n  }\n\n  function setFeeRecipent(address _feeRecipient) public onlyOwner {\n    feeRecipient = _feeRecipient;\n  }\n\n  function setLatestBidTime(uint _latestBidTime) public onlyOwner {\n    latestBidTime = _latestBidTime;\n  }\n\n  function setMaxSupply(uint _maxSupply) public onlyOwner {\n    maxSupply = _maxSupply;\n  }\n\n  function totalSupplyEpoch(uint _epoch) public view returns(uint) {\n    return totalSharesUp[_epoch].add(totalSharesDown[_epoch]);\n  }\n\n  // Early bets get more shares\n  function shareMultiplier() public view returns(uint) {\n    uint timeElapsed = block.timestamp.sub(oracle.lastUpdateAt(oraclePair));\n    if (timeElapsed > oracle.PERIOD()) { return 1e18; }\n    \n    // 1 + (maxBonus - (timeElapsed / PERIOD * maxBonus))\n    uint maxBonus = maxMultiplier.sub(1e18);\n    uint multiplier = uint(1e18).add(maxBonus.sub(timeElapsed.mul(1e18).div(oracle.PERIOD()).mul(maxBonus).div(1e18)));\n\n    return multiplier;\n  }\n\n  function winAmount(uint _epoch, address _account) public view returns(uint) {\n\n    // Up won\n    if (resolvedTo[_epoch] == 1) {\n      if (totalSharesUp[_epoch] == 0) {\n        return 0;\n      } else {\n        return purchasedEpoch[_epoch].mul(sharesOfUp[_epoch][_account]).div(totalSharesUp[_epoch]);\n      }\n\n    // Down won\n    } else if (resolvedTo[_epoch] == 2) {\n      if (totalSharesDown[_epoch] == 0) {\n        return 0;\n      } else {\n        return purchasedEpoch[_epoch].mul(sharesOfDown[_epoch][_account]).div(totalSharesDown[_epoch]);\n      }\n    } else {\n      return 0;\n    }\n  }\n\n  // Buying closes latestBidTime seconds before resolution\n  function isTimeOpen(uint _timestamp) public view returns(bool) {\n    uint timeElapsed = block.timestamp.sub(oracle.lastUpdateAt(oraclePair));\n\n    if (timeElapsed > oracle.PERIOD()) {\n      return false;\n    } else {\n      return oracle.PERIOD().sub(timeElapsed) > latestBidTime;\n    }\n  }\n\n  // UP wins but there is nobody to collect the winnings = claim as fees\n  function _claimDustUp(uint _epoch) internal {\n    if (totalSharesUp[_epoch] == 0) {\n      _sendEth(feeRecipient, _epoch, purchasedEpoch[_epoch]);\n      purchasedEpoch[_epoch] = 0;\n    }\n  }\n\n  // DOWN wins but there is nobody to collect the winnings = claim as fees\n  function _claimDustDown(uint _epoch) internal {\n    if (totalSharesDown[_epoch] == 0) {\n      _sendEth(feeRecipient, _epoch, purchasedEpoch[_epoch]);\n      purchasedEpoch[_epoch] = 0;\n    }\n  }\n\n  function _mintUp(address _account, uint _epoch, uint _amount, uint _minShares) internal {\n    uint shares = _shares(_amount, _minShares);\n    purchasedOfUp[_epoch][_account] = purchasedOfUp[_epoch][_account].add(_amount);\n    purchasedEpoch[_epoch] = purchasedEpoch[_epoch].add(_amount);\n    totalSharesUp[_epoch] = totalSharesUp[_epoch].add(shares);\n    sharesOfUp[_epoch][_account] = sharesOfUp[_epoch][_account].add(shares);\n  }\n\n  function _mintDown(address _account, uint _epoch, uint _amount, uint _minShares) internal {\n    uint shares = _shares(_amount, _minShares);\n    purchasedOfDown[_epoch][_account] = purchasedOfDown[_epoch][_account].add(_amount);\n    purchasedEpoch[_epoch] = purchasedEpoch[_epoch].add(_amount);\n    totalSharesDown[_epoch] = totalSharesDown[_epoch].add(shares);\n    sharesOfDown[_epoch][_account] = sharesOfDown[_epoch][_account].add(shares);\n  }\n\n  function _shares(uint _amount, uint _minShares) internal view returns(uint) {\n    uint shares = _amount.mul(shareMultiplier()).div(1e18);\n    require(shares > _minShares, \"UpDownMarket: shares > _minShares\");\n    return shares;\n  }\n\n  function _burnUp(address _account, uint _epoch, uint _amount) internal {\n    totalSharesUp[_epoch] = totalSharesUp[_epoch].sub(_amount);\n    sharesOfUp[_epoch][_account] = sharesOfUp[_epoch][_account].sub(_amount);\n  }\n\n  function _burnDown(address _account, uint _epoch, uint _amount) internal {\n    totalSharesDown[_epoch] = totalSharesDown[_epoch].sub(_amount);\n    sharesOfDown[_epoch][_account] = sharesOfDown[_epoch][_account].sub(_amount);\n  }\n\n  function _burnAll(address _account, uint _epoch) internal {\n    _burnUp(_account, _epoch, sharesOfUp[_epoch][_account]);\n    _burnDown(_account, _epoch, sharesOfDown[_epoch][_account]);\n  }\n\n  function _sendEth(address _recipient, uint _epoch, uint _amount) internal {\n    purchasedEpoch[_epoch] = purchasedEpoch[_epoch].sub(_amount);\n    address(_recipient).call { value: _amount } (new bytes(0));\n  }\n}"}}}