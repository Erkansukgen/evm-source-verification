{"language":"Solidity","settings":{"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"contracts/interfaces/IChickenNoodle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IChickenNoodle {\n    // struct to store each token's traits\n    struct ChickenNoodleTraits {\n        bool minted;\n        bool isChicken;\n        uint8 backgrounds;\n        uint8 snakeBodies;\n        uint8 mouthAccessories;\n        uint8 pupils;\n        uint8 bodyAccessories;\n        uint8 hats;\n        uint8 tier;\n    }\n\n    function MAX_TOKENS() external view returns (uint256);\n\n    function PAID_TOKENS() external view returns (uint256);\n\n    function tokenTraits(uint256 tokenId)\n        external\n        view\n        returns (ChickenNoodleTraits memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address tokenOwner) external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function mint(address to, uint16 tokenId) external;\n\n    function finalize(\n        uint16 tokenId,\n        ChickenNoodleTraits memory traits,\n        address thief\n    ) external;\n}\n"},"contracts/libraries/ChickenNoodleLookupLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '../interfaces/IChickenNoodle.sol';\n\nlibrary ChickenNoodleLookupLibrary {\n    function totalNoodles(address chickenNoodleAddress)\n        public\n        view\n        returns (uint16)\n    {\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\n\n        uint16 counter = 0;\n\n        uint16 supply = uint16(chickenNoodle.totalSupply());\n\n        for (uint16 tokenId = 1; tokenId <= supply; tokenId++) {\n            if (\n                chickenNoodle.tokenTraits(tokenId).minted &&\n                !chickenNoodle.tokenTraits(tokenId).isChicken\n            ) {\n                counter++;\n            }\n        }\n\n        return counter;\n    }\n\n    function getTokensForOwner(\n        address chickenNoodleAddress,\n        address tokenOwner,\n        uint16 limit,\n        uint16 page\n    ) public view returns (uint16[] memory) {\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\n\n        uint256 tokensOwned = chickenNoodle.balanceOf(tokenOwner);\n\n        uint256 pageStart = limit * page;\n        uint256 pageEnd = limit * (page + 1);\n        uint256 tokensSize = tokensOwned >= pageEnd\n            ? limit\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\n\n        uint16[] memory tokens = new uint16[](tokensSize);\n\n        uint16 skipCounter = 0;\n        uint16 counter = 0;\n\n        uint16 supply = uint16(chickenNoodle.totalSupply());\n\n        for (\n            uint16 tokenId = 1;\n            tokenId <= supply && counter < tokens.length;\n            tokenId++\n        ) {\n            if (chickenNoodle.ownerOf(tokenId) == tokenOwner) {\n                if (skipCounter < pageStart) {\n                    skipCounter++;\n                    continue;\n                }\n\n                tokens[counter] = tokenId;\n                counter++;\n            }\n        }\n\n        return tokens;\n    }\n\n    function getTokenTypesBalanceOf(\n        address chickenNoodleAddress,\n        address tokenOwner\n    )\n        public\n        view\n        returns (\n            uint16 chickens,\n            uint16 noodles,\n            uint16 tier5Noodles,\n            uint16 tier4Noodles,\n            uint16 tier3Noodles,\n            uint16 tier2Noodles,\n            uint16 tier1Noodles,\n            uint16 unminted\n        )\n    {\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\n\n        uint16 supply = uint16(chickenNoodle.totalSupply());\n\n        for (uint16 tokenId = 1; tokenId <= supply; tokenId++) {\n            if (chickenNoodle.ownerOf(tokenId) != tokenOwner) {\n                continue;\n            }\n\n            if (!chickenNoodle.tokenTraits(tokenId).minted) {\n                unminted++;\n                continue;\n            }\n\n            if (chickenNoodle.tokenTraits(tokenId).isChicken) {\n                chickens++;\n            } else {\n                uint8 tier = chickenNoodle.tokenTraits(tokenId).tier;\n\n                if (tier == 5) {\n                    tier5Noodles++;\n                } else if (tier == 4) {\n                    tier4Noodles++;\n                } else if (tier == 3) {\n                    tier3Noodles++;\n                } else if (tier == 2) {\n                    tier2Noodles++;\n                } else if (tier == 1) {\n                    tier1Noodles++;\n                }\n            }\n        }\n\n        noodles =\n            tier5Noodles +\n            tier4Noodles +\n            tier3Noodles +\n            tier2Noodles +\n            tier1Noodles;\n    }\n\n    function getMintedForOwner(\n        address chickenNoodleAddress,\n        address tokenOwner,\n        uint16 limit,\n        uint16 page\n    ) public view returns (uint16[] memory) {\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\n\n        (, , , , , , , uint16 tokensOwned) = getTokenTypesBalanceOf(\n            chickenNoodleAddress,\n            tokenOwner\n        );\n\n        uint256 pageStart = limit * page;\n        uint256 pageEnd = limit * (page + 1);\n        uint256 tokensSize = tokensOwned >= pageEnd\n            ? limit\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\n\n        uint16[] memory tokens = new uint16[](tokensSize);\n\n        uint16 skipCounter = 0;\n        uint16 counter = 0;\n\n        uint16 supply = uint16(chickenNoodle.totalSupply());\n\n        for (\n            uint16 tokenId = 1;\n            tokenId <= supply && counter < tokens.length;\n            tokenId++\n        ) {\n            if (chickenNoodle.ownerOf(tokenId) != tokenOwner) {\n                continue;\n            }\n\n            if (chickenNoodle.tokenTraits(tokenId).minted) {\n                if (skipCounter < pageStart) {\n                    skipCounter++;\n                    continue;\n                }\n\n                tokens[counter] = tokenId;\n                counter++;\n            }\n        }\n\n        return tokens;\n    }\n\n    function getUnmintedForOwner(\n        address chickenNoodleAddress,\n        address tokenOwner,\n        uint16 limit,\n        uint16 page\n    ) public view returns (uint16[] memory) {\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\n\n        (, , , , , , , uint16 tokensOwned) = getTokenTypesBalanceOf(\n            chickenNoodleAddress,\n            tokenOwner\n        );\n\n        uint256 pageStart = limit * page;\n        uint256 pageEnd = limit * (page + 1);\n        uint256 tokensSize = tokensOwned >= pageEnd\n            ? limit\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\n\n        uint16[] memory tokens = new uint16[](tokensSize);\n\n        uint16 skipCounter = 0;\n        uint16 counter = 0;\n\n        uint16 supply = uint16(chickenNoodle.totalSupply());\n\n        for (\n            uint16 tokenId = 1;\n            tokenId <= supply && counter < tokens.length;\n            tokenId++\n        ) {\n            if (chickenNoodle.ownerOf(tokenId) != tokenOwner) {\n                continue;\n            }\n\n            if (!chickenNoodle.tokenTraits(tokenId).minted) {\n                if (skipCounter < pageStart) {\n                    skipCounter++;\n                    continue;\n                }\n\n                tokens[counter] = tokenId;\n                counter++;\n            }\n        }\n\n        return tokens;\n    }\n\n    function getChickensForOwner(\n        address chickenNoodleAddress,\n        address tokenOwner,\n        uint16 limit,\n        uint16 page\n    ) public view returns (uint16[] memory) {\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\n\n        (uint16 tokensOwned, , , , , , , ) = getTokenTypesBalanceOf(\n            chickenNoodleAddress,\n            tokenOwner\n        );\n\n        uint256 pageStart = limit * page;\n        uint256 pageEnd = limit * (page + 1);\n        uint256 tokensSize = tokensOwned >= pageEnd\n            ? limit\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\n\n        uint16[] memory tokens = new uint16[](tokensSize);\n\n        uint16 skipCounter = 0;\n        uint16 counter = 0;\n\n        uint16 supply = uint16(chickenNoodle.totalSupply());\n\n        for (\n            uint16 tokenId = 1;\n            tokenId <= supply && counter < tokens.length;\n            tokenId++\n        ) {\n            if (\n                !chickenNoodle.tokenTraits(tokenId).minted ||\n                chickenNoodle.ownerOf(tokenId) != tokenOwner\n            ) {\n                continue;\n            }\n\n            if (chickenNoodle.tokenTraits(tokenId).isChicken) {\n                if (skipCounter < pageStart) {\n                    skipCounter++;\n                    continue;\n                }\n\n                tokens[counter] = tokenId;\n                counter++;\n            }\n        }\n\n        return tokens;\n    }\n\n    function getNoodlesForOwner(\n        address chickenNoodleAddress,\n        address tokenOwner,\n        uint16 limit,\n        uint16 page\n    ) public view returns (uint16[] memory) {\n        IChickenNoodle chickenNoodle = IChickenNoodle(chickenNoodleAddress);\n\n        (, uint16 tokensOwned, , , , , , ) = getTokenTypesBalanceOf(\n            chickenNoodleAddress,\n            tokenOwner\n        );\n\n        uint256 pageStart = limit * page;\n        uint256 pageEnd = limit * (page + 1);\n        uint256 tokensSize = tokensOwned >= pageEnd\n            ? limit\n            : (tokensOwned > pageStart ? tokensOwned - pageStart : 0);\n\n        uint16[] memory tokens = new uint16[](tokensSize);\n\n        uint16 skipCounter = 0;\n        uint16 counter = 0;\n\n        uint16 supply = uint16(chickenNoodle.totalSupply());\n\n        for (\n            uint16 tokenId = 1;\n            tokenId <= supply && counter < tokens.length;\n            tokenId++\n        ) {\n            if (\n                !chickenNoodle.tokenTraits(tokenId).minted ||\n                chickenNoodle.ownerOf(tokenId) != tokenOwner\n            ) {\n                continue;\n            }\n\n            if (!chickenNoodle.tokenTraits(tokenId).isChicken) {\n                if (skipCounter < pageStart) {\n                    skipCounter++;\n                    continue;\n                }\n\n                tokens[counter] = tokenId;\n                counter++;\n            }\n        }\n\n        return tokens;\n    }\n}\n"}}}