{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Behodler.sol":{"content":"pragma solidity ^0.6.0;\nimport \"./Secondary.sol\";\nimport \"./Secondary.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Lachesis.sol\";\nimport \"./Kharon.sol\";\nimport \"./ERC20Like.sol\";\nimport \"./SafeOperations.sol\";\nimport \"./Scarcity.sol\";\nimport \"./Chronos.sol\";\n/*\n\tBehodler orchestrates trades using an omnischedule bonding curve.\n\tThe name is inspired by the Beholder of D&D, a monster with multiple arms ending in eyes peering in all directions.\n\tThe Behodler is a smart contract that can see the prices of all tokens simultaneously without need for composition or delay.\n\tThe hodl part of Behodler refers to the fact that with every trade of a token pair, the liquidity pool of each token held by Behodler increases\n */\ncontract Behodler is Secondary\n{\n\tusing SafeMath for uint;\n\tusing SafeOperations for uint;\n\tuint constant factor = 128;\n\tLachesis lachesis;\n\tKharon kharon;\n\tChronos chronos;\n\taddress janus;\n\tmapping (address=>uint) public tokenScarcityObligations; //marginal scarcity price of token\n\n\tfunction seed(address lachesisAddress, address kharonAddress, address janusAddress, address chronosAddress) external onlyPrimary {\n\t\tkharon = Kharon(kharonAddress);\n\t\tlachesis = Lachesis(lachesisAddress);\n\t\tjanus = janusAddress;\n\t\tchronos = Chronos(chronosAddress);\n\t}\n\n\tfunction calculateAverageScarcityPerToken(address tokenAddress, uint value) external view returns (uint avg) { // S/T\n\t\trequire (value > 0, \"Non-zero token value expected to avoid division by zero.\");\n\n\t\tuint amountToPurchaseWith = value.sub(kharon.toll(tokenAddress,value));\n\n\t\tuint currentTokens = tokenScarcityObligations[tokenAddress].square().safeRightShift(factor);\n\t\tuint finalTokens = currentTokens.add(amountToPurchaseWith);\n\t\tuint finalScarcity = (finalTokens.safeLeftShift(factor)).sqrtImprecise();\n\t\tuint scarcityToPrint = finalScarcity.sub(tokenScarcityObligations[tokenAddress]);\n\t\tavg = scarcityToPrint.div(amountToPurchaseWith);\n\t}\n\n\tfunction getScarcityAddress() private view returns (address){\n\t\treturn address(lachesis.scarcity());\n\t}\n\n\tfunction buyScarcityDelegate(address sender, address tokenAddress, uint value, uint minPrice) external returns (uint){\n\t\trequire(msg.sender == janus, \"External users forbidden from delegating trade.\");\n\t\treturn buy(tokenAddress,value,sender, minPrice);\n\t}\n\n\tfunction sellScarcityDelegate(address sender, address tokenAddress, uint value, uint maxPrice) external returns (uint){\n\t\trequire(msg.sender == janus, \"External users forbidden from delegating trade.\");\n\t\treturn sell(tokenAddress,value,sender, maxPrice);\n\t}\n\n\tfunction buyScarcity(address tokenAddress, uint value, uint minPrice) external returns (uint){\n\t\treturn buy(tokenAddress,value,msg.sender, minPrice);\n\t}\n\n\tfunction sellScarcity(address tokenAddress, uint value, uint maxPrice) external returns (uint){\n\t\treturn sell(tokenAddress,value,msg.sender, maxPrice);\n\t}\n\n\tfunction buy (address tokenAddress, uint value, address purchaser, uint minPrice) private returns (uint){\n\t\tlachesis.cut(tokenAddress);\n\t\tERC20Like(tokenAddress).transferFrom(purchaser, address(this),value);\n\t\tERC20Like(tokenAddress).approve(address(kharon),uint(-1));\n\t\tuint amountToPurchaseWith = value.sub(kharon.demandPayment(tokenAddress,value,purchaser));\n\n\t\tuint currentTokens = tokenScarcityObligations[tokenAddress].square().safeRightShift(factor);\n\t\tuint finalTokens = currentTokens.add(amountToPurchaseWith);\n\t\tuint finalScarcity = (finalTokens.safeLeftShift(factor)).sqrtImprecise();\n\t\tuint scarcityToPrint = finalScarcity.sub(tokenScarcityObligations[tokenAddress]);\n\n\t\trequire(minPrice == 0 || scarcityToPrint >= minPrice.mul(amountToPurchaseWith).div(1 ether), \"price slippage (min) exceeded tolerance.\");\n\t\trequire(scarcityToPrint > 0, \"No scarcity generated.\");\n\n\t\t//bookkeeping\n\t\ttokenScarcityObligations[tokenAddress] = finalScarcity;\n\t\t//issue scarcity\n\t\tScarcity(getScarcityAddress()).mint(purchaser, scarcityToPrint);\n\t\temit scarcityBought(tokenAddress,scarcityToPrint, value);\n\t\treturn scarcityToPrint;\n\t}\n\n\tfunction buyDryRun (address tokenAddress, uint value, uint minPrice) public view returns (uint) {\n\t\tlachesis.cut(tokenAddress);\n\t\tuint amountToPurchaseWith = value.sub(kharon.toll(tokenAddress,value));\n\n\t\tuint currentTokens = tokenScarcityObligations[tokenAddress].square().safeRightShift(factor);\n\t\tuint finalTokens = currentTokens.add(amountToPurchaseWith);\n\t\tuint finalScarcity = (finalTokens.safeLeftShift(factor)).sqrtImprecise();\n\t\tuint scarcityToPrint = finalScarcity.sub(tokenScarcityObligations[tokenAddress]);\n\n\t\trequire(minPrice == 0 || scarcityToPrint >= minPrice.mul(amountToPurchaseWith).div(1 ether), \"price slippage (min) exceeded tolerance.\");\n\t\trequire(scarcityToPrint > 0, \"No scarcity generated.\");\n\t\treturn scarcityToPrint;\n\t}\n\n\tfunction sell (address tokenAddress, uint scarcityValue, address seller, uint maxPrice) private returns (uint tokensToSendToUser){\n\t\tlachesis.cut(tokenAddress);\n\t\taddress scarcityAddress = getScarcityAddress();\n\t\tScarcity(scarcityAddress).transferToBehodler(seller, scarcityValue);\n\n\t\tuint currentObligation = tokenScarcityObligations[tokenAddress];\n\n\t\trequire(scarcityValue <= currentObligation,\"value of scarcity sold exceeds token reserves\");\n\t\tERC20Like(scarcityAddress).approve(address(kharon),uint(-1));\n\t\tuint scarcityToSell = scarcityValue.sub(kharon.demandPayment(scarcityAddress,scarcityValue,seller));\n\n\t\tScarcity(scarcityAddress).burn(scarcityToSell);\n\n\t\tuint scarcityAfter = currentObligation.sub(scarcityToSell);\n\t\tuint tokenObligations = currentObligation.square().safeRightShift(factor);\n\t\tuint tokensAfter = scarcityAfter.square().safeRightShift(factor);\n\n\t\ttokensToSendToUser = (tokenObligations.sub(tokensAfter));//no spread\n\n\t\trequire(tokensToSendToUser > 0, \"No tokens released.\");\n\t\trequire(maxPrice == 0 || scarcityToSell <= maxPrice.mul(tokensToSendToUser).div(1 ether), \"price slippage (max) exceeded tolerance.\");\n\n\t\ttokenScarcityObligations[tokenAddress] = scarcityAfter;\n\t\tERC20Like(tokenAddress).transfer(seller,tokensToSendToUser);\n\t\temit scarcitySold(tokenAddress,scarcityValue, tokensToSendToUser);\n\t\tchronos.stamp(tokenAddress,scarcityValue,tokensToSendToUser);\n\t}\n\n\n\tfunction sellDryRun (address tokenAddress, uint scarcityValue, uint maxPrice) public view returns (uint tokensToSendToUser){\n\t\tlachesis.cut(tokenAddress);\n\t\taddress scarcityAddress = getScarcityAddress();\n\t\tuint currentObligation = tokenScarcityObligations[tokenAddress];\n\t\trequire(scarcityValue <= currentObligation,\"value of scarcity sold exceeds token reserves\");\n\t\tuint scarcityToSell = scarcityValue.sub(kharon.toll(scarcityAddress,scarcityValue));\n\n\t\tuint scarcityAfter = currentObligation.sub(scarcityToSell);\n\t\tuint tokenObligations = currentObligation.square().safeRightShift(factor);\n\t\tuint tokensAfter = scarcityAfter.square().safeRightShift(factor);\n\n\t\ttokensToSendToUser = (tokenObligations.sub(tokensAfter));//no spread\n\n\t\trequire(tokensToSendToUser > 0, \"No tokens released.\");\n\t\trequire(maxPrice == 0 || scarcityToSell <= maxPrice.mul(tokensToSendToUser).div(1 ether), \"price slippage (max) exceeded tolerance.\");\n\t}\n\n\n\tevent scarcitySold(address token, uint scx,uint tokenValue);\n\tevent scarcityBought(address token, uint scx,uint tokenValue);\n}"},"browser/Bellows.sol":{"content":"pragma solidity ^0.6.0;\nimport \"./Secondary.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Lachesis.sol\";\nimport \"./PyroTokenRegistry.sol\";\nimport \"./PyroTokenLike.sol\";\nimport \"./ERC20Like.sol\";\n/*\n\tA bellow is the reserve of a Pyrotoken. It contains the base token.\n\tWhen a bellow is added to, it is 'opened'. When a pyrotoken is redeemed, the bellow 'blasts'.\n\tThe Bellows contract uses a mapping to hold reserves for all pyrotokens.\n\tThe Bellows maintain the redeem rate for each token.\n */\ncontract Bellows is Secondary {\n\tusing SafeMath for uint;\n\tLachesis lachesis;\n\tPyroTokenRegistry registry;\n\n\tfunction seed(address lachesisAddress, address pyroTokenRegistry) external onlyPrimary {\n\t\tlachesis = Lachesis(lachesisAddress);\n\t\tregistry = PyroTokenRegistry(pyroTokenRegistry);\n\t}\n\n\tfunction open(address baseToken,uint value) external {\n\t\tlachesis.cut(baseToken);\n\t\trequire (ERC20Like(registry.baseTokenMapping(baseToken)).totalSupply()>0,\"bellow cannot be opened before pyrotokens minted\");\n\t\trequire(ERC20Like(baseToken).transferFrom(msg.sender,address(this),value),\"Transfer from holder failed\");\n\t}\n\n\tfunction blast(address pyroToken, uint value) external {\n\t\tlachesis.cut(registry.pyroTokenMapping(pyroToken));\n\t\trequire(ERC20Like(pyroToken).transferFrom(msg.sender,address(this),value),\"Transfer from holder failed\");\n\t\tuint redeemRate = getRedeemRate(pyroToken);\n\t\tuint valueBurnt = PyroTokenLike(pyroToken).burn(value);\n\t\trequire(PyroTokenLike(pyroToken).bellows() == address(this),\"pyroToken reserve mismatch\");\n\t\tuint baseTokenPayable = valueBurnt.mul(redeemRate).div(10000);\n\t\taddress baseTokenAddress = registry.pyroTokenMapping(pyroToken);\n\t\trequire(ERC20Like(baseTokenAddress).transfer(msg.sender,baseTokenPayable),\"unable to pay base token from reserve\");\n\t}\n\n\tfunction getRedeemRate(address pyroToken) public view returns (uint) {//pyroPerMyriadToken\n\t\tuint pyroTotalSupply = ERC20Like(pyroToken).totalSupply();\n\t\tuint baseBalance = ERC20Like(registry.pyroTokenMapping(pyroToken)).balanceOf(address(this));\n\n\t\tif(pyroTotalSupply == 0)\n\t\t\treturn 100;\n\n\t\treturn baseBalance\n\t\t.mul(10000) //scale by a myriad\n\t\t.div(pyroTotalSupply);\n\t}\n}\n"},"browser/Chronos.sol":{"content":"pragma solidity ^0.6.0;\nimport \"./SafeMath.sol\";\nimport \"./Secondary.sol\";\n/*\n\tChronos is an oracle that records the trades of Behodler over time.\n\tWhile one would think that logging would suffice, this isn't accessible to contracts.\n\tChronos keeps a moving average of the last 10, 100 and 1000 trades for a token pair.\n\tThis provides attack resistant stability for anyone wishing to use it as an oracle.\n\tScarcity (Scx) is the unit of account in the Behodler dapp and so all data is recorded in\n\tterms of Scarcity\n */\n\n\ncontract RingAverage{\n\tuint[] public data;\n\tuint[] public blockStamp;\n\tuint public total;\n\tuint public first;\n\tuint public last;\n\tuint length;\n\n\tconstructor (uint l) public {\n\t\tlength = l;\n\t\tfirst = 0;\n\t\tlast = l-1;\n\t}\n\n\tfunction push(uint value) external {\n\t\ttotal += value;\n\n\t\tif(data.length < length) {\n\t\t\tdata.push(value);\n\t\t\tblockStamp.push(block.number);\n\t\t}\n\t\telse{\n\t\t\ttotal -= data[first];\n\t\t\tfirst = (first + 1) % length;\n\t\t\tlast = (last + 1) % length;\n\t\t\tdata[last] = value;\n\t\t\tblockStamp[last] = block.number;\n\t\t}\n\t}\n\n\tfunction calculatedAverage() external view returns (uint) {\n\t\treturn total/data.length;\n\t}\n}\n\n\ncontract Chronos is Secondary {\n\taddress behodlerAddress;\n\tusing SafeMath for uint;\n\tmapping (address => bool) initialized;\n\tmapping (address => RingAverage[]) public stampData; // tokens per billion scx\n\tuint BILLION = 10**9;\n\n\tmodifier onlyBehodler(){\n\t\trequire(behodlerAddress != address(0), \"Behodler contract not set.\");\n\t\trequire(msg.sender == behodlerAddress, \"Only the Behodler contract can invoke this function.\");\n\t\t_;\n\t}\n\n\tfunction seed (address beh) external {\n\t\tbehodlerAddress = beh;\n\t}\n\n\tfunction stamp(address tokenAddress, uint scxValue, uint tokenValue) public onlyBehodler {\n\t\tuint gigaValue = tokenValue*BILLION;\n\t\tif(gigaValue<scxValue)\n\t\t\treturn;\n\t\tuint average = gigaValue/scxValue;\n\t\tif(!initialized[tokenAddress]){\n\t\t\tstampData[tokenAddress].push(new RingAverage(10));\n\t\t\tstampData[tokenAddress].push(new RingAverage(100));\n\t\t\tstampData[tokenAddress].push(new RingAverage(1000));\n\t\t\tinitialized[tokenAddress] = true;\n\t\t}\n\n\t\tstampData[tokenAddress][0].push(average);\n\t\tstampData[tokenAddress][1].push(average);\n\t\tstampData[tokenAddress][2].push(average);\n\t}\n}"},"browser/ERC20.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public override view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public override view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"},"browser/ERC20Like.sol":{"content":"pragma solidity ^0.6.1;\n\nabstract contract ERC20Like\n{\n\tfunction totalSupply() external virtual view returns (uint256);\n\tfunction balanceOf(address account) external virtual view returns (uint256);\n\tfunction transfer(address recipient, uint256 amount) external virtual returns (bool);\n\tfunction allowance(address owner, address spender) external virtual view returns (uint256);\n\tfunction approve(address spender, uint256 amount) external virtual returns (bool);\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external virtual returns (bool);\n}"},"browser/IERC20.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"browser/Kharon.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./Bellows.sol\";\nimport \"./PatienceRegulationEngineLike.sol\";\nimport \"./WeiDaiBankLike.sol\";\nimport \"./Behodler.sol\";\nimport \"./Prometheus.sol\";\nimport \"./PyroTokenLike.sol\";\nimport \"./PyroTokenRegistry.sol\";\nimport \"./Secondary.sol\";\nimport \"./ERC20Like.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Scarcity.sol\";\nimport \"./WeiDaiLike.sol\";\n/*\n\tKharon exacts fees from input tokens in a behodler trade. If the input token is a pyrotoken, the fee is used to increase the reserve.\n\tIf the token is dai, it is used to instantly buy and burn WeiDai. If the token is WeiDai or Scarcity, it is burnt. Burning scarcity helps to gradually\n\tincrease the liquidity pool of the output token.\n\tKharon has logic for knowing when to stop burning scarcity (too much liquidity)\n\tIt also has logic for knowing when to not charge a fee. For instance, the user could have an NFT that exempts fees. This can be an external dependency.\n\tBefore burning, Kharon asks Prometheus how much 'he' wants.\n */\n\ncontract Kharon is Secondary{\n\tusing SafeMath for uint;\n\tBellows public bellows;\n\tBehodler public behodler;\n\tPrometheus public prometheus;\n\tPatienceRegulationEngineLike public PatienceRegulationEngine;\n\tPyroTokenRegistry public tokenRegistry;\n\taddress public WeiDaiBank;\n\taddress public Dai;\n\taddress public scarcityAddress;\n\taddress weidaiAddress;\n\taddress public donationAddress;\n\tuint public scarcityBurnCuttoff;\n\tuint public tollRate = 24;\n\n\tfunction setTollRate(uint t) public onlyPrimary {\n\t\trequire(t<1000, \"toll rate is a percentage expressed as a number between 0 and 1000\");\n\t\ttollRate = t;\n\t}\n\n\tfunction seed (address bl, address bh, address pm, address pr, address ban,address dai, address weidai, address scar, uint cut, address d) external onlyPrimary {\n\t\tbellows = Bellows(bl);\n\t\tbehodler = Behodler(bh);\n\t\tprometheus = Prometheus(pm);\n\t\ttokenRegistry = prometheus.tokenRegistry();\n\t\tPatienceRegulationEngine = PatienceRegulationEngineLike(pr);\n\t\tWeiDaiBank = ban;\n\t\tDai = dai;\n\t\tscarcityAddress = scar;\n\t\tscarcityBurnCuttoff = cut;\n\t\tdonationAddress = d;\n\t\tweidaiAddress = weidai;\n\t}\n\n\tfunction toll(address token, uint value) public view returns (uint){//percentage expressed as number between 0 and 1000\n\t\t//if the token isn't scarcity, we burn toll rate. If it is scarcity, we first check if we should burn anymore\n\t\tif(token != scarcityAddress || behodler.tokenScarcityObligations(token) <= scarcityBurnCuttoff){\n\t\t\treturn uint(tollRate).mul(value).div(1000);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction demandPaymentRewardDryRun(address token, uint value) external view returns (uint) {\n\t\tuint tollValue = toll(token,value);\n\t\tif(tollValue == 0)\n\t\t\treturn 0;\n\n\t\tuint reward = prometheus.stealFlameDryRun(token,tollValue);\n\t\treturn reward;\n\t}\n\n\tfunction demandPayment (address token, uint value, address buyer) external returns (uint tollValue) {\n\t\trequire(msg.sender == address(behodler), \"only Behodler can invoke this function\");\n\t\ttollValue = toll(token,value);\n\t\tif(tollValue == 0)\n\t\t\treturn 0;\n\n\t\trequire(ERC20Like(token).transferFrom(msg.sender, address(this), tollValue),\"toll taking failed\");\n\t\tERC20Like(token).approve(address(prometheus),uint(-1));\n\t\tuint reward = prometheus.stealFlame(token,tollValue, buyer);\n\t\tuint netToll = tollValue.sub(reward);\n\t\t//get split rate and calculate portion to burn. Remaining is a donation\n\t\tuint donationSplit = PatienceRegulationEngine.getDonationSplit(buyer);\n\t\tuint netSplitRate = uint(100).sub(donationSplit);\n\t\tuint amountToBurn = netToll.mul(netSplitRate).div(100);\n\t\tif(token == Dai){\n\t\t\tERC20Like(token).approve(WeiDaiBank,uint(-1));\n\t\t\tPatienceRegulationEngine.buyWeiDai(netToll,donationSplit);\n\t\t\tPatienceRegulationEngine.claimWeiDai();\n\t\t}else if(token == scarcityAddress) {\n\t\t\tScarcity(token).burn(netToll);\n\t\t}else if(token == weidaiAddress){\n\t\t\tuint thisDonationSplit = PatienceRegulationEngine.getDonationSplit(address(this));\n\t\t\tPatienceRegulationEngine.setDonationSplit(donationSplit);\n\t\t\tWeiDaiLike(token).burn(address(this), netToll);\n\t\t\tPatienceRegulationEngine.setDonationSplit(thisDonationSplit);\n\t\t}\n\t\t else if(tokenRegistry.baseTokenMapping(token) != address(0)){\n\t\t\tERC20Like(token).approve(address(bellows),amountToBurn);\n\t\t\tbellows.open(token,amountToBurn);\n\t\t}\n\t\telse {\n\t\t\trevert(\"invalid token trade.\");\n\t\t}\n\t}\n\n\tfunction withdrawDonations(address token) external onlyPrimary{\n\t\trequire(donationAddress != address(0),\"donation address not set\");\n\t\tuint balance = ERC20Like(token).balanceOf(address(this));\n\t\tif(balance>0)\n\t\t\tERC20Like(token).transfer(donationAddress,balance);\n\t}\n}"},"browser/Lachesis.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./Secondary.sol\";\nimport \"./Scarcity.sol\";\n\n/*\n\tLachesis, one of the three Moirai, the inflexible, decides which tokens are active within behodler.\n */\n\ncontract Lachesis is Secondary{\n\tmapping (address => bool) public tokens;\n\tScarcity public scarcity;\n\n\tfunction measure (address token, bool valid) external onlyPrimary {\n\t\ttokens[token] = valid;\n\t}\n\n\tfunction setScarcity(address s) external onlyPrimary {\n\t\tscarcity = Scarcity(s);\n\t}\n\n\tfunction cut(address token) external view {\n\t\trequire(tokens[token],\"invalid token.\");\n\t}\n}"},"browser/PatienceRegulationEngineLike.sol":{"content":"pragma solidity ^0.6.1;\n\nabstract contract PatienceRegulationEngineLike{\n\tfunction setDonationSplit(uint split) public virtual;\n\tfunction getDonationSplit(address user) external virtual view returns (uint);\n\tfunction buyWeiDai(uint dai, uint split) external virtual;\n\tfunction claimWeiDai() external virtual;\n}"},"browser/Prometheus.sol":{"content":"pragma solidity ^0.6.0;\nimport \"./Secondary.sol\";\nimport \"./ERC20Like.sol\";\nimport \"./SafeMath.sol\";\nimport \"./PyroTokenLike.sol\";\nimport \"./PyroTokenRegistry.sol\";\n/*\n\tPrometheus takes a portion of the fees from Kharon, wraps as a Pyrotoken and gives it to the user as a reward.\n\tIf the input token is scx, dai or weidai, Prometheus doesn't take any.\n\tA simple implementation of Prometheus immediately hands over the reward to the user. \n\tA more complex version might hold onto rewards for 10 trades or 1 month before handing over. We'll have to see. The benefit of handing over after many trades:\n\t\t1. Incentive for user to trade often\n\t\t2. Can increase reward over time, rewarding frequent traders.\n\t\t3. When reward finally comes through, it looks large\n\tDownsides:\n\t\t1. added complexity\n\t\t2. users might get disinterested, waiting for pyrotokens.\n\n\tProbably no need to give users the ability to engulf (wrap) tokens into pyrotokens. These tokens are for rewards only.\n */\n\ncontract Prometheus is Secondary {\n\tusing SafeMath for uint;\n\taddress public kharonAddress;\n\taddress public scarcity;\n\taddress public weiDai;\n\taddress public dai;\n\tPyroTokenRegistry public tokenRegistry;\n\n\tfunction seed(address k, address scx, address weidai, address d, address registry) public{\n\t\tkharonAddress = k;\n\t\tscarcity = scx;\n\t\tweiDai = weidai;\n\t\tdai = d;\n\t\ttokenRegistry = PyroTokenRegistry(registry);\n\t}\n\n\tfunction stealFlameDryRun(address token, uint kharonToll) external view returns (uint){\n\t\tuint gift = kharonToll.div(2);\n\t\tif(token == scarcity || token == weiDai || token == dai || gift == 0)\n\t\t\treturn 0;\n\t\treturn gift;\n\t}\n\n\tfunction stealFlame(address token, uint kharonToll, address buyer) external returns (uint){//takes from behodler and returns amountTakenNum\n\t\trequire(msg.sender == kharonAddress,\"only Kharon can invoke this function\");\n\t\tuint gift = kharonToll.div(2);\n\t\tif(token == scarcity || token == weiDai || token == dai || gift == 0)\n\t\t\treturn 0;\n\n\t\trequire(ERC20Like(token).transferFrom(kharonAddress,address(this),gift),\"prometheus flame theft failed.\");\n\n\t\t//gifting logic\n\t\taddress pyroTokenAddress = tokenRegistry.baseTokenMapping(token);\n\t\trequire(pyroTokenAddress != address(0),\"token not registered for trade\");\n\t\tPyroTokenLike pyroToken = PyroTokenLike(pyroTokenAddress);\n\t\tERC20Like(token).approve(pyroTokenAddress,uint(-1));\n\t\tpyroToken.engulf(buyer, gift);\n\t\treturn gift;\n\t}\n}"},"browser/PyroToken.sol":{"content":"pragma solidity ^0.6.1;\nimport \"./ERC20.sol\";\nimport \"./Secondary.sol\";\nimport \"./Bellows.sol\";\nimport \"./PyroTokenRegistry.sol\";\nimport \"./PatienceRegulationEngineLike.sol\";\nimport \"./ERC20Like.sol\";\nimport \"./Kharon.sol\";\n/*\nPyroTokens wrap tokens traded on Behodler (except for Dai, WeiDai and Scarcity).\nPyroTokens are ERC20 tokens that can engulf (wrap) a token. The base token is then added to a Bellow by opening it.\nUnwrapping happens at the Bellows as a 'blast'.\nHandling of Weth/Eth issues happesn at the Swap level.\ngeneric contract for all pyro tokens. This contract is instantiated in real time with programmable name, symbol etc.\n*/\n\ncontract PyroToken is Secondary, ERC20{\n\tstring public name;\n\tstring public symbol;\n\tBellows public bellows;\n\tKharon public kharon;\n\tPyroTokenRegistry public registry;\n\n\tconstructor (string memory n, string memory s, address bellow,address k, address r) public{\n\t\tname = n;\n\t\tsymbol = s;\n\t\tbellows = Bellows(bellow);\n\t\tregistry = PyroTokenRegistry(r);\n\t\tkharon = Kharon(k);\n\t}\n\n\tfunction decimals() external pure returns (uint8) {\n\t\treturn 18;\n\t}\n\n\tfunction engulf (address pyroRecipient, uint value) external returns (bool) {\n\t\taddress baseTokenAddress = registry.pyroTokenMapping(address(this));\n\t\trequire(ERC20Like(baseTokenAddress).transferFrom(msg.sender,address(this),value),\"transfer of base token from sender failed\");\n\t\tuint redeemRate = bellows.getRedeemRate(address(this));\n\t\tuint pyroToProduce = value.mul(10000).div(redeemRate);\n\t\t_mint(address(this),pyroToProduce);\n\t\tERC20Like(baseTokenAddress).approve(address(bellows),value);\n\t\tbellows.open(baseTokenAddress,value);\n\t\tERC20Like(address(this)).transfer(pyroRecipient,pyroToProduce);\n\t}\n\n\tfunction burn (uint value) external returns (uint) {\n\t\tuint splitRate = kharon.PatienceRegulationEngine().getDonationSplit(msg.sender);\n\t\tuint donation = splitRate.mul(value).div(100);\n\t\tuint valueToBurn = value;\n\t\tif(donation > 0) {\n\t\t\t_transfer(msg.sender, address(kharon), donation);\n\t\t}\n\t\tvalueToBurn = value.sub(donation);\n\t\t_burn(msg.sender, valueToBurn);\n\t\treturn valueToBurn;\n\t}\n}"},"browser/PyroTokenLike.sol":{"content":"pragma solidity ^0.6.0;\n/*\nPyroTokens wrap tokens traded on Behodler (except for Dai, WeiDai and Scarcity).\nPyroTokens are ERC20 tokens that can engulf (wrap) a token. The base token is then added to a Bellow by opening it.\nUnwrapping happens at the Bellows as a 'blast'.\n*/\nabstract contract PyroTokenLike {\n\tfunction bellows() external virtual view returns (address);\n\tfunction baseToken() external virtual view returns (address);\n\tfunction engulf (address sender, uint value) external virtual returns (bool);\n\tfunction burn (uint value) external virtual returns (uint);\n}"},"browser/PyroTokenRegistry.sol":{"content":"pragma solidity ^0.6.1;\n\nimport \"./Secondary.sol\";\nimport \"./PyroToken.sol\";\nimport \"./Lachesis.sol\";\n\ncontract PyroTokenRegistry is Secondary{\n\tmapping (address=>address) public baseTokenMapping;\n\tmapping (address=>address) public pyroTokenMapping;\n\taddress public bellows;\n\taddress public kharon;\n\tLachesis lachesis;\n\n\tfunction seed(address b, address l, address k) external onlyPrimary {\n\t\tbellows = b;\n\t\tlachesis = Lachesis(l);\n\t\tkharon = k;\n\t}\n\n\tfunction addToken(string calldata name, string calldata symbol, address baseToken) external onlyPrimary {\n\t\tlachesis.cut(baseToken);\n\t\tPyroToken t = new PyroToken(name, symbol, bellows, kharon, address(this));\n\t\taddress pTokenAddress = address(t);\n\t\tbaseTokenMapping[baseToken] = pTokenAddress;\n\t\tpyroTokenMapping[pTokenAddress] = baseToken;\n\t\trequire(address(t) != address(0),\"deploy contract failed\");\n\t}\n}"},"browser/SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"browser/SafeOperations.sol":{"content":"pragma solidity  0.6;\nimport \"./SafeMath.sol\";\n\nlibrary SafeOperations {\n\tusing SafeMath for uint;\n\tuint constant uintMax = 2<<254;\n\t\n\tfunction safeRightShift(uint number, uint factor) internal pure returns (uint) {\n\t\tuint value = number >> factor;\n\t\trequire (value <= number);\n\t\treturn value;\t\n\t}\n\n\tfunction safeLeftShift(uint number, uint factor) internal pure returns (uint) {\n\t\tuint value = number << factor;\n\t\trequire (value >= number);\n\t\treturn value;\t\n\t}\n\n\tfunction square(uint value) internal pure returns (uint) {\n\t\tuint product = value.mul(value);\n\t\tif(product < value)\n\t\t\treturn uintMax;\n\t\treturn product;\n\t}\n\n\tfunction sqrtImprecise(uint x) internal pure returns (uint y) {\n\t\tuint z = (x + 1) / 2;\n\t\ty = x;\n\t\twhile (z < y) {\n\t\t\ty = z;\n\t\t\tz = (x / z + z) / 2;\n\t\t}\n\t\tif(y>x)\n\t\t\ty = 0;\n\t}\n\n\tfunction sqrt(uint x) internal pure returns (uint y) {\n\t\tuint z = (x + 1) / 2;\n\t\ty = x;\n\t\twhile (z < y) {\n\t\t\ty = z;\n\t\t\tz = (x / z + z) / 2;\n\t\t}\n\t\tif(y>x)\n\t\t\ty = 0;\n\t\trequire(y*y<=z, \"invariant\");\n\t}\n}"},"browser/Scarcity.sol":{"content":"pragma solidity ^0.6.0;\nimport \"./ERC20.sol\";\nimport \"./Secondary.sol\";\n\n\ncontract Scarcity is ERC20, Secondary\n{\n\taddress behodler;\n\tmodifier onlyBehodler(){\n\t\trequire(behodler != address(0), \"Behodler contract not set.\");\n\t\trequire(msg.sender == behodler, \"Only the Behodler contract can invoke this function.\");\n\t\t_;\n\t}\n\n\tfunction setBehodler(address b) external onlyPrimary {\n\t\tbehodler = b;\n\t}\n\n\tfunction mint(address recipient, uint value) external onlyBehodler{\n\t\t_mint(recipient, value);\n\t}\n\n\tfunction burn (uint value) external {\n\t\t_burn(msg.sender,value);\n\t}\n\n\tfunction transferToBehodler(address holder, uint value) external onlyBehodler returns (bool){\n\t\t_transfer(holder, behodler, value);\n\t\treturn true;\n\t}\n\n\tfunction name() external pure returns (string memory) {\n\t\treturn \"Scarcity\";\n\t}\n\n\tfunction symbol() external pure returns (string memory) {\n\t\treturn \"SCX\";\n\t}\n\n\tfunction decimals() external pure returns (uint8) {\n\t\treturn 18;\n\t}\n}"},"browser/Secondary.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\n */\ncontract Secondary {\n    address private _primary;\n\n    /**\n     * @dev Emitted when the primary contract changes.\n     */\n    event PrimaryTransferred(\n        address recipient\n    );\n\n    /**\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\n     */\n    constructor () internal {\n        _primary = msg.sender;\n        emit PrimaryTransferred(_primary);\n    }\n\n    /**\n     * @dev Reverts if called from any account other than the primary.\n     */\n    modifier onlyPrimary() {\n        require(msg.sender == _primary, \"Secondary: caller is not the primary account\");\n        _;\n    }\n\n    /**\n     * @return the address of the primary.\n     */\n    function primary() public view returns (address) {\n        return _primary;\n    }\n\n    /**\n     * @dev Transfers contract to a new primary.\n     * @param recipient The address of new primary.\n     */\n    function transferPrimary(address recipient) public onlyPrimary {\n        require(recipient != address(0), \"Secondary: new primary is the zero address\");\n        _primary = recipient;\n        emit PrimaryTransferred(_primary);\n    }\n}\n"},"browser/WeiDaiBankLike.sol":{"content":"pragma solidity ^0.6.1;\n\nabstract contract WeiDaiBankLike {\n\tfunction redeemWeiDai(uint weiDai) external virtual;\n}"},"browser/WeiDaiLike.sol":{"content":"pragma solidity ^0.6.1;\n\nabstract contract WeiDaiLike\n{\n    function burn (address holder, uint value) external virtual;\n}"}}}