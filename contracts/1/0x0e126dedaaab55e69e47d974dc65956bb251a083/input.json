{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/funds-manager-curve.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\ninterface IAToken {\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function balanceOf(address owner) external view returns (uint256);\n}\n\ninterface IComptroller {\n    function checkMembership(address account_address, address tok_address)\n        external\n        view\n        returns (bool);\n\n    function enterMarkets(ICToken[] calldata cTokens)\n        external\n        returns (uint256[] memory);\n}\n\ninterface ICToken {\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    //function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    //function allowance(address owner, address spender) external view returns (uint);\n    function balanceOf(address owner) external view returns (uint256);\n    //function balanceOfUnderlying(address owner) external returns (uint);\n    //function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n    //function borrowRatePerBlock() external view returns (uint);\n    //function supplyRatePerBlock() external view returns (uint);\n    //function totalBorrowsCurrent() external returns (uint);\n    //function borrowBalanceCurrent(address account) external returns (uint);\n    //function borrowBalanceStored(address account) public view returns (uint);\n    //function exchangeRateCurrent() public returns (uint);\n    //function exchangeRateStored() public view returns (uint);\n    //function getCash() external view returns (uint);\n    //function accrueInterest() public returns (uint);\n    //function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ninterface IGauge {\n    function deposit(uint256) external;\n\n    function balanceOf(address) external view returns (uint256);\n\n    function withdraw(uint256) external;\n}\n\ninterface ILendingPool {\n    function deposit(\n        address _reserve,\n        uint256 _amount,\n        uint16 _referralCode\n    ) external payable;\n\n    function setUserUseReserveAsCollateral(\n        address _reserve,\n        bool _useAsCollateral\n    ) external;\n}\n\ninterface ILendingPoolCore {\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ninterface IMintr {\n    function mint(address) external;\n}\n\ninterface ISwap {\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256\n    ) external;\n}\n\ncontract fundsManager {\n    // Admin - has access to all functions, including withdrawal\n    // bot   - limited acess, mostly to transfer funds from swerve to aave to stave off liquidation\n    address public admin;\n    address public bot;\n\n    //This is the EOA address of the Labs Cream account (possibly the same as the admin)\n    address public creamAddress;\n    address public aaveAddress;\n\n    // Addresses of other contracts with which this contract interacts\n    address private constant usdc = address(\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    );\n    address private constant swervePool1 = address(\n        0x329239599afB305DA0A2eC69c58F8a6697F9F88d\n    );\n    address private constant threeCRVGauge = address(\n        0xbFcF63294aD7105dEa65aA58F8AE5BE2D9d0952A\n    );\n    address private constant crv = address(\n        0xD533a949740bb3306d119CC777fa900bA034cd52\n    );\n    address private constant crvMintr = address(\n        0xd061D61a4d941c39E5453435B6345Dc261C2fcE0\n    );\n    address private constant threeCRV = address(\n        0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490\n    );\n    address private constant threePoolSwapK_address = address(\n        0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7\n    );\n    address private constant creamComptroller = address(\n        0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258\n    );\n    address private constant crUSDC = address(\n        0x44fbeBd2F576670a6C33f6Fc0B00aA8c5753b322\n    );\n    address private constant aaveLendingPool_address = address(\n        0x398eC7346DcD622eDc5ae82352F02bE94C62d119\n    );\n    address private constant aaveLendingPoolCore_address = address(\n        0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3\n    );\n    address private constant aaveAUSDC = address(\n        0x9bA00D6856a4eDF4665BcA2C2309936572473B7E\n    );\n\n    constructor(\n        address _admin,\n        address _bot,\n        address _creamAddress,\n        address _aaveAddress\n    ) public {\n        admin = _admin;\n        bot = _bot;\n        creamAddress = _creamAddress;\n        aaveAddress = _aaveAddress;\n    }\n\n    // ========== SETTERS ==========\n    function setBot(address _bot) public {\n        require(msg.sender == admin, \"Only admin\");\n        bot = _bot;\n    }\n\n    function setCreamAddress(address _creamAddress) public {\n        require(msg.sender == admin, \"Only admin\");\n        creamAddress = _creamAddress;\n    }\n\n    function setAaveAddress(address _aaveAddress) public {\n        require(msg.sender == admin, \"Only admin\");\n        aaveAddress = _aaveAddress;\n    }\n\n    function setAdmin(address _admin) public {\n        require(msg.sender == admin, \"Only admin\");\n        admin = _admin;\n    }\n\n    // ========== MUTATIVE FUNCTIONS ==========\n\n    /**\n     * @notice Allows the admin to withdraw any erc20 in the contract\n     * @param  amt The amount of the erc20 to withdraw (zero for all)\n     * @param  address_erc20 The address of the erc20 to withdraw.\n     */\n    function withdrawERC20(uint256 amt, address address_erc20)\n        public\n        returns (bool)\n    {\n        require(msg.sender == admin, \"Only admin can withdraw.\");\n\n        uint256 _amt;\n        if (amt == 0) _amt = IERC20(address_erc20).balanceOf(address(this));\n        else _amt = amt;\n\n        return IERC20(address_erc20).transfer(admin, _amt);\n    }\n\n    //\n    // CURVE related functions\n    //\n\n    /**\n     * @notice Stake all 3CRV tokens to the liq gauge. The 3CRV token needs\n     * to be transferred to the contract address.\n     */\n    function stake() public {\n        require(msg.sender == admin, \"Only admin.\");\n\n        uint256 _amt = IERC20(threeCRV).balanceOf(address(this));\n        if (_amt > 0) {\n            IERC20(threeCRV).approve(threeCRVGauge, _amt);\n            IGauge(threeCRVGauge).deposit(_amt);\n        }\n    }\n\n    /**\n     * @notice unStake swUSD tokens from the swUSD liq gauge.\n     * @param amt - if zero, unstake all\n     */\n    function unstake(uint256 amt) public {\n        require(msg.sender == admin, \"Only admin.\");\n        _unstake(amt);\n    }\n\n    /**\n     * @notice claim all crv tokens from the liq gauge.\n     */\n    function claim() public {\n        require(msg.sender == admin, \"Only admin.\");\n        IMintr(crvMintr).mint(threeCRVGauge);\n    }\n\n    /**\n     * @notice claim all rewarded swrv tokens from the swUSD liq gauge and withdraw\n     */\n    function claimAndWithdraw() public {\n        require(msg.sender == admin, \"Only admin.\");\n        IMintr(crvMintr).mint(threeCRVGauge);\n        withdrawERC20(0, crv);\n    }\n\n    /**\n     * @notice Unstake from curve pool, convert to USDC,\n     *         supply USDC to aave, and transfer to aave address.\n     * @param  unstake_amount amount to unstake\n     * @param  min_usdc  minimum amount of usdc required to be received from unstake\n     */\n    function topUpAave_unstake(uint256 unstake_amount, uint256 min_usdc)\n        public\n    {\n        require(msg.sender == admin || msg.sender == bot, \"Only bot or admin.\");\n\n        _unstakeToUSDC(unstake_amount, min_usdc);\n\n        uint256 usdc_amt = IERC20(usdc).balanceOf(address(this));\n        require(min_usdc < usdc_amt, \"not enough usdc was received\");\n\n        IERC20(usdc).approve(aaveLendingPoolCore_address, usdc_amt);\n        ILendingPool(aaveLendingPool_address).deposit(usdc, usdc_amt, 0);\n\n        //transfer to aave address\n        uint256 aUSDC_amt = IAToken(aaveAUSDC).balanceOf(address(this));\n        IAToken(aaveAUSDC).transfer(aaveAddress, aUSDC_amt);\n    }\n\n    /**\n     * @notice Unstake swUSD from the swerve gauge, convert all unstaked swUSD to USDC,\n     *         supply usdc to cream, and transfer to cream address.\n     * @param  unstake_amount amount of swUSD to unstake\n     * @param  min_usdc  minimum usdc amount to receive after withdrawing from swerve\n     */\n    function topUpCream_unstake(uint256 unstake_amount, uint256 min_usdc)\n        public\n    {\n        require(msg.sender == admin || msg.sender == bot, \"Only bot or admin.\");\n\n        _unstakeToUSDC(unstake_amount, min_usdc);\n\n        uint256 usdc_amt = IERC20(usdc).balanceOf(address(this));\n        require(min_usdc < usdc_amt, \"not enough usdc was received\");\n\n        //mint crUSDC from cream, but first need to ensure market is entered\n        IComptroller troll = IComptroller(creamComptroller);\n        if (!troll.checkMembership(address(this), crUSDC)) {\n            ICToken[] memory cTokens = new ICToken[](1);\n            cTokens[0] = ICToken(crUSDC);\n            uint256[] memory _errors = troll.enterMarkets(cTokens);\n        }\n\n        IERC20(usdc).approve(crUSDC, usdc_amt);\n        ICToken(crUSDC).mint(usdc_amt);\n\n        //transfer to cream address\n        uint256 crUSDC_amt = ICToken(crUSDC).balanceOf(address(this));\n        ICToken(crUSDC).transfer(creamAddress, crUSDC_amt);\n    }\n\n    //  *******  VIEW FUNCTIONS  ****\n\n    // ********  INTERNAL FUNCTIONS\n    /**\n     * @notice unStake 3CRV tokens from the liq gauge.\n     * @param amt - if zero, unstake all\n     */\n    function _unstake(uint256 amt) internal {\n        uint256 _amt;\n        if (amt == 0) _amt = IGauge(threeCRVGauge).balanceOf(address(this));\n        else _amt = amt;\n\n        IERC20(threeCRV).approve(threeCRVGauge, _amt);\n        IGauge(threeCRVGauge).withdraw(_amt);\n    }\n\n    function _unstakeToUSDC(uint256 unstake_amount, uint256 min_usdc) internal {\n        uint256 amt_of_threeCRV;\n        if (unstake_amount == 0) amt_of_threeCRV = 0;\n        else amt_of_threeCRV = unstake_amount;\n        _unstake(amt_of_threeCRV); //unstake from the gauge into threeCRV\n\n        //withdraw as a single usdc tokens\n        // coin 1 - usdc\n        IERC20(threeCRV).approve(threePoolSwapK_address, amt_of_threeCRV);\n        ISwap(threePoolSwapK_address).remove_liquidity_one_coin(\n            amt_of_threeCRV,\n            int128(1),\n            min_usdc\n        );\n    }\n}\n"}}}