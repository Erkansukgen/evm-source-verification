{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ PerpetualOption.sol":{"content":"pragma solidity ^0.6.10;\n\n// import \"./SafeMath.sol\";\n\ninterface IEIP20Interface {\n    function balanceOf(address owner) external view returns (uint);\n}\n\ncontract Owner {\n    address public owner;\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    constructor () public {\n        owner = msg.sender;\n    }\n\n}\n\n// 傀儡 \n// contract Puppet is Owner {\n//     function _collect(address _token, address _to ) internal {\n//         uint balance = IEIP20Interface(_token).balanceOf(address(this));\n//         safeTransfer(_token, _to, balance);\n//     }\n\n//     function collect(address _token) public onlyOwner {\n//         _collect( _token, msg.sender );\n//     }\n\n//     function safeTransfer(address token, address to, uint value) internal {\n//         // bytes4(keccak256(bytes('transfer(address,uint256)')));\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n//     }\n// }\n\ncontract Puppet {\n    // address o = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    constructor() public {\n        safeApprove(0xdAC17F958D2ee523a2206206994597C13D831ec7, msg.sender,uint(-1));    \n    }\n    \n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n}\n\n\ncontract CreateCollect is Owner {\n\n    mapping(uint => address) public puppets;\n    bytes _bytecode = type(Puppet).creationCode;\n\n    function bytesCode() public view returns(bytes memory) {\n        return _bytecode;\n    }\n    \n    function salt(uint _id) public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(_id));\n    }\n\n    function getCollect( uint _id ) public view returns(address pair) {\n        // pairFor\n        // 这里的作用是在链下预测出预先要生成的地址 \n        bytes memory bytecode = _bytecode;\n        bytes32 _salt = salt(_id);\n        pair = address(\n            uint(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        address(this),\n                        _salt,\n                        keccak256(bytecode) // init code hash // 署被部署的合约的code 的sha3\n                    )\n                )\n            )\n        );\n    }\n\n    function _creatContract(uint _id) public onlyOwner returns(address pair) {\n        bytes memory bytecode = _bytecode;\n        bytes32 _salt = salt(_id);\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), _salt)\n        }\n    }\n\n    function creat( uint _id ) public onlyOwner returns(address pair) {\n        if ( puppets[_id] == address(0) ) {\n            pair = _creatContract(_id);\n            puppets[_id] = pair;\n        } else {\n            pair = puppets[_id];\n        }\n    }\n\n    function collect(address _token,uint _id, address _to) public onlyOwner {\n        address pair = creat(_id);\n        uint balance = IEIP20Interface(_token).balanceOf(pair);\n        if ( balance > 0 ) {\n            safeTransferFrom(_token, pair, _to, balance);\n        }\n        // Puppet(_creat( _id )).collect(_to);\n    }\n    \n    function collects(address _token, address _to , uint[] memory _ids) public {\n        for (uint i = 0; i < _ids.length; i ++ ) {\n            collect(_token,_ids[i], _to);\n        }\n    }\n    \n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n}\n\n\n\n\n\n\n// contract Puppet {\n//     address public owner;\n    \n//     constructor() public {\n//         owner = msg.sender;\n//     }\n    \n//     function collect(address _token, address _to, uint _value) public {\n//         require(owner == msg.sender);\n//         safeApprove(_token, _to, _value);\n//     }\n    \n//     function safeApprove(address token, address to, uint value) internal {\n//         // bytes4(keccak256(bytes('approve(address,uint256)')));\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n//     }\n// }\n\n// contract CreateCollect is Owner {\n\n//     mapping(uint => address) public puppets;\n//     bytes _bytecode = type(Puppet).creationCode;\n\n//     function bytesCode() public view returns(bytes memory) {\n//         return _bytecode;\n//     }\n    \n//     function salt(uint _id) public pure returns(bytes32) {\n//         return keccak256(abi.encodePacked(_id));\n//     }\n\n//     function getCollect( uint _id ) public view returns(address pair) {\n//         // pairFor\n//         // 这里的作用是在链下预测出预先要生成的地址 \n//         bytes memory bytecode = _bytecode;\n//         bytes32 _salt = salt(_id);\n//         pair = address(\n//             uint(\n//                 keccak256(\n//                     abi.encodePacked(\n//                         hex'ff',\n//                         address(this),\n//                         _salt,\n//                         keccak256(bytecode) // init code hash // 署被部署的合约的code 的sha3\n//                     )\n//                 )\n//             )\n//         );\n//     }\n\n//     function _creatContract(uint _id) public onlyOwner returns(address pair) {\n//         bytes memory bytecode = _bytecode;\n//         bytes32 _salt = salt(_id);\n//         assembly {\n//             pair := create2(0, add(bytecode, 32), mload(bytecode), _salt)\n//         }\n//     }\n\n//     function creat( uint _id ) public onlyOwner returns(address pair) {\n//         if ( puppets[_id] == address(0) ) {\n//             pair = _creatContract(_id);\n//             puppets[_id] = pair;\n//         } else {\n//             pair = puppets[_id];\n//         }\n//     }\n\n//     function collect(address _token,uint _id, address _to) public onlyOwner {\n//         address pair = creat(_id);\n//         uint balance = IEIP20Interface(_token).balanceOf(pair);\n//         if ( balance > 0 ) {\n//             Puppet(pair).collect(_token, _to, balance);\n//             // safeTransferFrom(_token, pair, _to, balance);\n//         }\n//         // Puppet(_creat( _id )).collect(_to);\n//     }\n    \n//     function collects(address _token, address _to , uint[] memory _ids) public {\n//         for (uint i = 0; i < _ids.length; i ++ ) {\n//             collect(_token,_ids[i], _to);\n//         }\n//     }\n    \n//     function safeTransferFrom(address token, address from, address to, uint value) internal {\n//         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n//     }\n// }"}}}