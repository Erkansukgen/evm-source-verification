{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/1_Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    _setOwner(_msgSender());\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _setOwner(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _setOwner(newOwner);\n  }\n\n  function _setOwner(address newOwner) private {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\n   *\n   * _Available since v3.4._\n   */\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      uint256 c = a + b;\n      if (c < a) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n   *\n   * _Available since v3.4._\n   */\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b > a) return (false, 0);\n      return (true, a - b);\n    }\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n   *\n   * _Available since v3.4._\n   */\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n      // benefit is lost if 'b' is also tested.\n      // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n      if (a == 0) return (true, 0);\n      uint256 c = a * b;\n      if (c / a != b) return (false, 0);\n      return (true, c);\n    }\n  }\n\n  /**\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\n   *\n   * _Available since v3.4._\n   */\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a / b);\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n   *\n   * _Available since v3.4._\n   */\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      if (b == 0) return (false, 0);\n      return (true, a % b);\n    }\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator.\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a % b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {trySub}.\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b <= a, errorMessage);\n      return a - b;\n    }\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a / b;\n    }\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * reverting with custom message when dividing by zero.\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {tryMod}.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a % b;\n    }\n  }\n}\n\ninterface IFacelessNFT {\n  function totalSupply() external view returns (uint256);\n\n  function mint(address to, uint256 tokenId) external;\n}\n\n/**\n * Meta Kings - 4\n * Metavatars - 9\n * Archaeons - 19\n * Aeons - 69\n * Eos - 900\n *\n * Total number of NFTs: 1001\n */\n\ncontract NFTInitialSeller is Ownable {\n  using Counters for Counters.Counter;\n  using SafeMath for uint256;\n\n  enum SaleStep {\n    None,\n    EarlyBirdSale,\n    Airdrop,\n    SecondSale,\n    SoldOut\n  }\n\n  uint16 public constant MAX_NFT_SUPPLY = 1001;\n\n  // Early bird sale prices\n  uint256 public constant METAKING_PRICE = 0.5 ether;\n  uint256 public constant METAVATARS_PRICE = 0.5 ether;\n  uint256 public constant ARCHAEONS_PRICE = 0.3 ether;\n  uint256 public constant AEONS_PRICE = 0.3 ether;\n  uint256 public constant EOS_PRICE = 0.19 ether;\n\n  // Second sale price\n  uint256 public constant SECOND_SALE_PRICE = 0.3 ether;\n\n  uint256 public startTime;\n\n  uint16 public pendingCount = MAX_NFT_SUPPLY;\n\n  bool[1002] public minted;\n\n  IFacelessNFT public facelessNFT;\n\n  uint16[10000] private _pendingIds;\n\n  // First sale is Early Bird Sale\n  SaleStep private _currentSale = SaleStep.None;\n\n  modifier airdropPeriod() {\n    require(\n      _currentSale == SaleStep.Airdrop,\n      \"NFTInitialSeller: Airdrop ended\"\n    );\n    _;\n  }\n\n  modifier earlyBirdSalePeriod() {\n    require(\n      _currentSale == SaleStep.EarlyBirdSale,\n      \"NFTInitialSeller: Early Bird Sale ended\"\n    );\n    _;\n  }\n\n  modifier secondSalePeriod() {\n    require(\n      _currentSale == SaleStep.SecondSale,\n      \"NFTInitialSeller: Second Sale ended\"\n    );\n    _;\n  }\n\n  modifier periodStarted() {\n    require(\n      block.timestamp >= startTime,\n      \"NFTInitialSeller: Period not started\"\n    );\n    _;\n  }\n\n  constructor(address nftAddress) {\n    facelessNFT = IFacelessNFT(nftAddress);\n  }\n\n  function setCurrentSale(SaleStep _sale) external onlyOwner {\n    require(_currentSale != _sale, \"NFTInitialSeller: step already set\");\n    _currentSale = _sale;\n  }\n\n  function setStartTime(uint256 _startTime) external onlyOwner {\n    require(_startTime > 0, \"NFTInitialSeller: invalid _startTime\");\n    require(_startTime > block.timestamp, \"NFTInitialSeller: old start time\");\n    startTime = _startTime;\n  }\n\n  function airdropTransfer(address to, uint16 tokenId)\n    external\n    airdropPeriod\n    onlyOwner\n  {\n    uint16 nftIndex = _getPendingIndexById(tokenId, 647, 200);\n    require(nftIndex >= 647, \"NFTInitialSeller: too low index\");\n    require(nftIndex <= 846, \"NFTInitialSeller: too high index\");\n    require(!minted[tokenId], \"NFTInitialSeller: already minted\");\n    _popPendingAtIndex(nftIndex);\n    minted[tokenId] = true;\n    facelessNFT.mint(to, tokenId);\n  }\n\n  function standardPurchase(uint16 tokenId)\n    external\n    payable\n    earlyBirdSalePeriod\n    periodStarted\n  {\n    uint16 nftIndex = _getPendingIndexById(tokenId, 847, 155);\n    require(nftIndex >= 847, \"NFTInitialSeller: too low index\");\n    require(nftIndex <= 1001, \"NFTInitialSeller: too high index\");\n    require(!minted[tokenId], \"NFTInitialSeller: already minted\");\n    require(\n      msg.value == _getMintPrice(tokenId),\n      \"NFTInitialSeller: invalid ether value\"\n    );\n    _popPendingAtIndex(nftIndex);\n    minted[tokenId] = true;\n    facelessNFT.mint(msg.sender, tokenId);\n  }\n\n  /**\n   * @dev Mint 'numberOfNfts' new tokens\n   */\n  function randomPurchase(uint256 numberOfNfts)\n    external\n    payable\n    secondSalePeriod\n    periodStarted\n  {\n    require(pendingCount > 0, \"NFTInitialSeller: All minted\");\n    require(numberOfNfts > 0, \"NFTInitialSelle: numberOfNfts cannot be 0\");\n    require(\n      numberOfNfts <= 20,\n      \"NFTInitialSeller: You may not buy more than 20 NFTs at once\"\n    );\n    require(\n      facelessNFT.totalSupply().add(numberOfNfts) <= MAX_NFT_SUPPLY,\n      \"NFTInitialSeller: sale already ended\"\n    );\n    require(\n      SECOND_SALE_PRICE.mul(numberOfNfts) == msg.value,\n      \"NFTInitialSeller: invalid ether value\"\n    );\n\n    for (uint i = 0; i < numberOfNfts; i++) {\n      _randomMint(msg.sender);\n    }\n  }\n\n  /**\n   * @dev Withdraw total eth balance on the contract to owner\n   */\n  function withdraw() external onlyOwner {\n    (bool sent, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n    require(sent, \"NFTInitialSeller: Failed to withdraw\");\n  }\n\n  function getPendingAtIndex(uint16 _index) public view returns (uint16) {\n    return _pendingIds[_index] + _index;\n  }\n\n  function _getPendingIndexById(\n    uint16 tokenId,\n    uint16 startIndex,\n    uint16 totalCount\n  ) internal view returns (uint16) {\n    for (uint16 i = 0; i < totalCount; i++) {\n      uint16 pendingTokenId = getPendingAtIndex(i + startIndex);\n      if (pendingTokenId == tokenId) {\n        return i + startIndex;\n      }\n    }\n    revert(\"NFTInitialSeller: invalid token id(pending index)\");\n  }\n\n  function _getMintPrice(uint16 tokenId) internal pure returns (uint256) {\n    require(tokenId >= 847, \"NFTInitialSeller: low token id\");\n    if (tokenId <= 848) return METAKING_PRICE;\n    if (tokenId <= 851) return METAVATARS_PRICE;\n    if (tokenId <= 862) return ARCHAEONS_PRICE;\n    if (tokenId <= 901) return AEONS_PRICE;\n    if (tokenId <= 1001) return EOS_PRICE;\n    revert(\"NFTInitialSeller: invalid token id(mint price)\");\n  }\n\n  function _popPendingAtIndex(uint16 _index) internal returns (uint16) {\n    uint16 tokenId = getPendingAtIndex(_index);\n    if (_index != pendingCount) {\n      uint16 lastPendingId = getPendingAtIndex(pendingCount);\n      _pendingIds[_index] = lastPendingId - _index;\n    }\n    pendingCount--;\n    return tokenId;\n  }\n\n  function _randomMint(address _to) internal {\n    uint16 index = uint16((_getRandom() % pendingCount) + 1);\n    uint256 tokenId = _popPendingAtIndex(index);\n    minted[tokenId] = true;\n    facelessNFT.mint(_to, index);\n  }\n\n  function _getRandom() internal view returns (uint256) {\n    return\n      uint256(\n        keccak256(\n          abi.encodePacked(block.difficulty, block.timestamp, pendingCount)\n        )\n      );\n  }\n}\n"
    }
  }
}