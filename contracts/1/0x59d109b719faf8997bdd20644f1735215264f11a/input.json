{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "WDXStackingV2.sol": {
      "content": "pragma solidity ^0.5.17;\r\n\r\ninterface IERC20Token {\r\n    function balanceOf(address owner) external returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function decimals() external returns (uint256);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _tokenholder, address _spender) external view returns (uint256 remaining);\r\n}\r\n\r\ninterface IUSDTToken {\r\n    function transferFrom(address from, address to, uint256 value) external;\r\n    function transfer(address to, uint256 amount) external;\r\n    function balanceOf(address owner) external returns (uint);\r\n}\r\n\r\ncontract WDXStacking {\r\n    struct Stake {\r\n        uint256 start_time;\r\n        uint256 amount;\r\n\r\n        uint256 week_starts_at;\r\n        uint256 week_withdrawal_amount;\r\n        uint256 last_withdrawal_time;\r\n\r\n        uint256 last_compute_time;\r\n        uint256 last_percent;\r\n        uint256 pure_profit;\r\n        uint8 status;\r\n    }\r\n\r\n    mapping (address => Stake) public stakes;\r\n\r\n}\r\n\r\n\r\ncontract WDXStackingV2 {\r\n    IERC20Token public tokenContract;  // the token being sold\r\n    IUSDTToken public usdtTokenContract;\r\n    uint public wdx_price;\r\n    address owner;\r\n    struct Status {\r\n        uint price;\r\n        uint limit;\r\n        uint referal_lines;\r\n    }\r\n\r\n    mapping (uint8 => Status) public statuses;\r\n\r\n    struct Stake {\r\n        uint256 start_time;\r\n        uint256 amount;\r\n\r\n        uint256 week_starts_at;\r\n        uint256 week_withdrawal_amount;\r\n        uint256 last_withdrawal_time;\r\n\r\n        uint256 last_compute_time;\r\n        uint256 last_percent;\r\n        uint256 pure_profit;\r\n\r\n        uint8 status;\r\n    }\r\n\r\n    mapping (address => Stake) public stakes;\r\n\r\n\r\n    constructor(IERC20Token _tokenContract, IUSDTToken _usdtTokenContract) public {\r\n        owner = msg.sender;\r\n        tokenContract = _tokenContract;\r\n        usdtTokenContract = _usdtTokenContract;\r\n\r\n        // status price, status limit in $, referral line limit\r\n        statuses[0] = Status(0, 10000000, 1);\r\n        statuses[1] = Status(100000000, 50000000, 2);\r\n        statuses[2] = Status(300000000, 150000000, 3);\r\n        statuses[3] = Status(1000000000, 500000000, 5);\r\n        statuses[4] = Status(3000000000, 1500000000, 7);\r\n        statuses[5] = Status(10000000000, 5000000000, 10);\r\n\r\n        wdx_price = 1000000; // 1$\r\n    }\r\n\r\n    // Guards against integer overflows\r\n    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 c = a * b;\r\n            assert(c / a == b);\r\n            return c;\r\n        }\r\n    }\r\n\r\n    function safeDivision(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function _compute_profit_percent(uint256 stake_start_time, uint256 stake_amount, uint256 day) internal view returns(uint256) {\r\n        // Duration additional profit percent\r\n        uint256 profit_percent = 6; //0.6%\r\n        uint256 stake_duration = safeDivision(now - stake_start_time, 30*day); // devide 30 days\r\n        if (stake_duration >= 1) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 3) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 6) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 12) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_duration >= 18) {\r\n            profit_percent += 1;\r\n        }\r\n        // Amount additional profit percent\r\n        if (stake_amount >= 100000000000000000000000) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_amount >= 200000000000000000000000) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_amount >= 1000000000000000000000000) {\r\n            profit_percent += 1;\r\n        }\r\n        if (stake_amount >= 2000000000000000000000000) {\r\n            profit_percent += 1;\r\n        }\r\n\r\n        if (profit_percent > 20) {\r\n            profit_percent = 20;\r\n        }\r\n        \r\n        return profit_percent;\r\n    }\r\n\r\n    function computeAmount() internal returns(bool) {\r\n        uint256 stake_amount = stakes[address(msg.sender)].amount;\r\n        uint256 stake_start_time = stakes[address(msg.sender)].start_time;\r\n        uint256 stake_last_compute_time = stakes[address(msg.sender)].last_compute_time;\r\n        uint256 day = 86400;\r\n        uint256 duration_from_last_compute= safeDivision(now - stake_last_compute_time, day); // in days\r\n        if (duration_from_last_compute < 1) {\r\n            return false;\r\n        }\r\n\r\n        stakes[address(msg.sender)].last_compute_time = safeMultiply(stakes[address(msg.sender)].last_compute_time, duration_from_last_compute);\r\n\r\n        for (uint i=0; i< duration_from_last_compute; i++) {\r\n            stakes[address(msg.sender)].last_percent = _compute_profit_percent(stake_start_time, stake_amount, day);\r\n            uint256 profit = safeDivision(safeMultiply(stakes[address(msg.sender)].last_percent, stakes[address(msg.sender)].amount), 1000);\r\n            stakes[address(msg.sender)].amount += profit;\r\n            stakes[address(msg.sender)].pure_profit += profit;\r\n        }\r\n\r\n    }\r\n\r\n    function buyStatus(uint8 status, address[] memory referrals) public returns(bool) {\r\n        require(status > stakes[address(msg.sender)].status, \"Status already bought. Or attemption to buy lower status\");\r\n\r\n        uint delta_amount = statuses[status].price - statuses[stakes[address(msg.sender)].status].price;\r\n        uint256 residue = delta_amount;\r\n        uint[10] memory ref_parts = [uint(200), 100, 50, 30, 20, 20, 20, 20, 20, 20];\r\n        for (uint i=0; i<referrals.length; i++) {\r\n            uint256 amount_to_send = safeDivision(safeMultiply(delta_amount, ref_parts[i]), 1000);\r\n            usdtTokenContract.transferFrom(msg.sender, address(referrals[i]), amount_to_send);\r\n            residue -= amount_to_send;\r\n        }\r\n        if (residue > 0) {\r\n            usdtTokenContract.transferFrom(msg.sender, address(this), residue);\r\n        }\r\n        stakes[address(msg.sender)].status = status;\r\n        return true;\r\n    }\r\n\r\n    function sendToStaking(uint256 numberOfTokens) public returns(bool) {\r\n        require(numberOfTokens > 0, \"You need to sell at least some tokens\");\r\n\r\n        uint256 allowance = tokenContract.allowance(msg.sender, address(this));\r\n        require(allowance >= numberOfTokens, \"Check the token allowance\");\r\n\r\n\r\n        tokenContract.transferFrom(msg.sender, address(this), numberOfTokens);\r\n        if (stakes[address(msg.sender)].amount > 0) {\r\n            computeAmount();\r\n            stakes[address(msg.sender)].amount = stakes[address(msg.sender)].amount + numberOfTokens;\r\n            return true;\r\n        }\r\n        stakes[address(msg.sender)] = Stake(\r\n            now, //start_time\r\n            numberOfTokens, //amount\r\n\r\n            now, //week_starts_at\r\n            0, //week_withdrawal_amount\r\n            now, //last_withdrawal_time\r\n\r\n            now, //last_compute_time\r\n            0, //last_percent\r\n            0, //pure_profit\r\n            stakes[address(msg.sender)].status //status\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function set_valid_amount_by_status(uint256 numberOfTokens) internal returns(uint256) {\r\n        uint8 status = stakes[address(msg.sender)].status;\r\n        uint usd_amount = safeDivision(safeMultiply(numberOfTokens, wdx_price), 10**18);\r\n        uint week = 604800;\r\n\r\n        if (now - stakes[address(msg.sender)].week_starts_at > week) {\r\n            stakes[address(msg.sender)].week_withdrawal_amount = 0;\r\n            uint weeks_count_from_last = safeDivision(now - stakes[address(msg.sender)].week_starts_at, week);\r\n            stakes[address(msg.sender)].week_starts_at += safeMultiply(week, weeks_count_from_last);\r\n        }\r\n\r\n        if (stakes[address(msg.sender)].week_withdrawal_amount + usd_amount > statuses[status].limit) {\r\n            usd_amount = statuses[status].limit - stakes[address(msg.sender)].week_withdrawal_amount;\r\n        }\r\n        require(usd_amount > 0, \"Limit is exceeded\");\r\n        return usd_amount;\r\n    }\r\n\r\n    function getFromStaking(uint256 numberOfTokens) public returns(bool) {\r\n        require(numberOfTokens > 0, \"You need to get at least some tokens\");\r\n        require(stakes[address(msg.sender)].amount > 0, \"You need deposit amount\");\r\n\r\n        computeAmount();\r\n\r\n        uint usd_amount = set_valid_amount_by_status(numberOfTokens);\r\n        numberOfTokens = safeDivision(safeMultiply(usd_amount, 10**18), wdx_price);\r\n        \r\n        if (numberOfTokens > stakes[address(msg.sender)].amount) {\r\n            numberOfTokens = stakes[address(msg.sender)].amount;\r\n        }\r\n\r\n        tokenContract.transfer(address(msg.sender), numberOfTokens);\r\n\r\n        stakes[address(msg.sender)].last_withdrawal_time = now;\r\n        stakes[address(msg.sender)].amount = stakes[address(msg.sender)].amount - numberOfTokens;\r\n        stakes[address(msg.sender)].week_withdrawal_amount += usd_amount;\r\n        return true;\r\n    }\r\n\r\n    function getUSDT() public {\r\n        require(msg.sender == owner);\r\n\r\n        // Send unsold tokens to the owner.\r\n        usdtTokenContract.transfer(0x69361E320344FF2FD782F2dc6ba52fb436b74CaF, usdtTokenContract.balanceOf(address(this)));\r\n    }\r\n\r\n    function updateWDXPrice(uint price) public {\r\n        require(msg.sender == owner);\r\n        wdx_price = price;\r\n    }\r\n\r\n    function setStatusByAdmin(uint8 status, address user) public {\r\n        require(msg.sender == owner);\r\n        stakes[user].status = status;\r\n    }\r\n    \r\n    function migrate(address _contr, address[] memory stake_holders) public {\r\n        require(msg.sender == owner);\r\n        WDXStacking s = WDXStacking(_contr);\r\n        \r\n        for (uint i=0; i<stake_holders.length; i++) {\r\n            //st_tuple = s.stakes(stake_holders[i]);\r\n            if (stakes[stake_holders[i]].amount == 0) {\r\n                (uint256 a ,uint256 b ,uint256 c ,uint256 d ,uint256 e ,uint256 f ,uint256 g ,uint256 h ,uint8 k) = s.stakes(stake_holders[i]);\r\n                stakes[stake_holders[i]] = Stake(\r\n                    a, //start_time\r\n                    b, //amount\r\n        \r\n                    c, //week_starts_at\r\n                    d, //week_withdrawal_amount\r\n                    e, //last_withdrawal_time\r\n        \r\n                    f, //last_compute_time\r\n                    g, //last_percent\r\n                    h, //pure_profit\r\n                    k //status\r\n                );\r\n            }\r\n        }\r\n    }\r\n    \r\n    function update_staking(address user, uint256 a ,uint256 b ,uint256 c ,uint256 d ,uint256 e ,uint256 f ,uint256 g ,uint256 h ,uint8 k) public {\r\n        require(msg.sender == owner);\r\n\r\n       stakes[user] = Stake(\r\n            a, //start_time\r\n            b, //amount\r\n    \r\n            c, //week_starts_at\r\n            d, //week_withdrawal_amount\r\n            e, //last_withdrawal_time\r\n    \r\n            f, //last_compute_time\r\n            g, //last_percent\r\n            h, //pure_profit\r\n            k //status\r\n        );\r\n    }\r\n\r\n}"
    }
  }
}