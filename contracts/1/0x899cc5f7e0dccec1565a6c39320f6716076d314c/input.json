{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Contract_Code_v2_Base.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return a / b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title String\r\n * @dev This integrates the basic functions.\r\n */\r\nlibrary String {\r\n    /**\r\n     * @dev determine if strings are equal\r\n     * @param _str1 strings\r\n     * @param _str2 strings\r\n     * @return bool\r\n     */\r\n    function compareStr(string memory _str1, string memory _str2)\r\n        internal\r\n        pure\r\n        returns(bool)\r\n    {\r\n        return keccak256(abi.encodePacked(_str1)) == keccak256(abi.encodePacked(_str2));\r\n    }\r\n}\r\n\r\n/**\r\n * @title Rand\r\n * @dev Rand operations.\r\n */\r\ncontract Rand {\r\n\r\n    mapping(uint8 => uint) internal rNGMapping;\r\n\r\n    /**\r\n     * @dev the content of contract is Beginning\r\n     */\r\n\tconstructor () public\r\n    {\r\n        //init\r\n        rNGMapping[1] = _rand() % block.difficulty;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the get Random\r\n     * @param _length Random _length\r\n     * @return random Random\r\n     */\r\n    function rand(uint _length)\r\n        internal\r\n        returns(uint random)\r\n    {\r\n        random = _rand();\r\n        rNGMapping[1] = random;\r\n        return random % _length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the get Random\r\n     * @return Random\r\n     */\r\n    function _rand()\r\n        private\r\n        returns(uint)\r\n    {\r\n        return uint(keccak256(abi.encodePacked(\r\n            block.difficulty, block.gaslimit, now, tx.gasprice , tx.origin,\r\n            ++rNGMapping[0], rNGMapping[1]\r\n        )));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnerTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnerTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev modifier Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: it is not called by the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     * @return bool\r\n     */\r\n    function isOwner()\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n        emit OwnerTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner()\r\n        external\r\n        view\r\n        returns(address)\r\n    {\r\n        return _owner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an address access to this role\r\n     */\r\n    function add(Role storage _role, address _addr)\r\n        internal\r\n    {\r\n        require(!has(_role, _addr), \"Roles: addr already has role\");\r\n        _role.bearer[_addr] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address' access to this role\r\n     */\r\n    function remove(Role storage _role, address _addr)\r\n        internal\r\n    {\r\n        require(has(_role, _addr), \"Roles: addr do not have role\");\r\n        _role.bearer[_addr] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an address has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage _role, address _addr)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_addr != address(0), \"Roles: not the zero address\");\r\n        return _role.bearer[_addr];\r\n    }\r\n}\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable {\r\n    using Roles for Roles.Role;\r\n\r\n    Roles.Role private roles = Roles.Role();\r\n\r\n    event RoleAdded(address indexed operator);\r\n    event RoleRemoved(address indexed operator);\r\n\r\n    /**\r\n     * @dev Throws if operator is not whitelisted.\r\n     */\r\n    modifier onlyIfWhitelisted() {\r\n        require(checkWhitelist(), \"Whitelist: The operator is not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev check current operator is in whitelist\r\n     * @return bool\r\n     */\r\n    function checkWhitelist()\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return isWhitelist(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev add an address to the whitelist\r\n     * @param _operator address\r\n     */\r\n    function addAddressToWhitelist(address _operator)\r\n        external\r\n        onlyOwner\r\n    {\r\n        roles.add(_operator);\r\n        emit RoleAdded(_operator);\r\n    }\r\n\r\n    /**\r\n     * @dev remove an address from the whitelist\r\n     * @param _operator address\r\n     */\r\n    function removeAddressFromWhitelist(address _operator)\r\n        external\r\n        onlyOwner\r\n    {\r\n        roles.remove(_operator);\r\n        emit RoleRemoved(_operator);\r\n    }\r\n\r\n    /**\r\n     * @dev determine if address is in whitelist\r\n     * @param _operator address\r\n     * @return bool\r\n     */\r\n    function isWhitelist(address _operator)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return roles.has(_operator) || isOwner();\r\n    }\r\n}\r\n\r\n/**\r\n * @title DB interface\r\n * @dev This Provide database support services interface\r\n */\r\ninterface IDB {\r\n    /**\r\n     * @dev Create store user information\r\n     * @param addr user addr\r\n     * @param code user invite Code\r\n     * @param rCode recommend code\r\n     */\r\n    function registerUser(address addr, string calldata code, string calldata rCode) external;\r\n    /**\r\n     * @dev Set store user information\r\n     * @param addr user addr\r\n     * @param status user status\r\n     */\r\n    function setUser(address addr, uint8 status) external;\r\n    /**\r\n     * @dev Set store user information [level]\r\n     * @param addr user addr\r\n     * @param level user level\r\n     * @param levelStatus user level status\r\n     */\r\n    function setUserLevel(address addr, uint8 level, uint8 levelStatus) external;\r\n    /**\r\n     * @dev determine if user invite code is use (db)\r\n     * @param code user invite Code\r\n     * @return bool\r\n     */\r\n    function isUsedCode(string calldata code) external view returns (bool);\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code (db)\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return address\r\n     */\r\n    function getCodeMapping(string calldata code) external view returns (address);\r\n    /**\r\n     * @dev get the user address of the corresponding user id (db)\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return address\r\n     */\r\n    function getIndexMapping(uint uid) external view returns (address);\r\n    /**\r\n     * @dev get the user address of the corresponding User info (db)\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info info[id,status,level,levelStatus]\r\n     * @return code code\r\n     * @return rCode rCode\r\n     */\r\n    function getUserInfo(address addr) external view returns (uint[4] memory info, string memory code, string memory rCode);\r\n    /**\r\n     * @dev get the current latest ID (db)\r\n     * Authorization Required\r\n     * @return current uid\r\n     */\r\n    function getCurrentUserID() external view returns (uint);\r\n    /**\r\n     * @dev get the rCodeMapping array length of the corresponding recommend Code (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @return rCodeMapping array length\r\n     */\r\n    function getRCodeMappingLength(string calldata rCode) external view returns (uint);\r\n    /**\r\n     * @dev get the user invite code of the recommend Code [rCodeMapping] based on the index (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @param index the index of [rCodeMapping]\r\n     * @return user invite code\r\n     */\r\n    function getRCodeMapping(string calldata rCode, uint index) external view returns (string memory);\r\n    /**\r\n     * @dev get the user offspring\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     */\r\n    function getRCodeOffspring(string calldata rCode) external view returns (string[] memory);\r\n}\r\n\r\n/**\r\n * @title DBUtilli\r\n * @dev This Provide database support services (db)\r\n */\r\ncontract DBUtilli is Whitelist {\r\n\r\n    //include other contract\r\n    IDB private db;\r\n\r\n    /**\r\n     * @dev DBUtilli is Beginning\r\n     * @param _dbAddr db contract addr\r\n     */\r\n    constructor(address _dbAddr)\r\n        public\r\n    {\r\n        db = IDB(_dbAddr);\r\n    }\r\n\r\n    /**\r\n     * @dev modifier check Permission\r\n     */\r\n\tmodifier _checkPermission() {\r\n\t\trequire(checkWhitelist(), \"DBUtilli: Permission denied\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev modifier check User Permission\r\n     * @param addr user addr\r\n     */\r\n\tmodifier _checkUserPermission(address addr) {\r\n\t\tcheckUserPermission(addr);\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check User Permission\r\n     * @param addr user addr\r\n     */\r\n    function checkUserPermission(address addr)\r\n        private\r\n        view\r\n    {\r\n        require(checkWhitelist() || msg.sender == addr, \"DBUtilli: Permission denied for view user's privacy\");\r\n\t}\r\n\r\n    /**\r\n     * @dev Create store user information (db)\r\n     * @param addr user address\r\n     * @param code user invite Code\r\n     * @param rCode recommend code\r\n     */\r\n    function _registerUser(address addr, string memory code, string memory rCode)\r\n        internal\r\n    {\r\n        db.registerUser(addr, code, rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev Set store user information\r\n     * @param addr user addr\r\n     * @param status user status\r\n     */\r\n    function _setUser(address addr, uint8 status)\r\n        internal\r\n    {\r\n\t\tdb.setUser(addr, status);\r\n\t}\r\n\r\n    /**\r\n     * @dev Set store user information [level]\r\n     * @param addr user addr\r\n     * @param level user level\r\n     * @param levelStatus user level status\r\n     */\r\n    function _setUserLevel(address addr, uint8 level, uint8 levelStatus)\r\n        internal\r\n    {\r\n        db.setUserLevel(addr, level, levelStatus);\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if user invite code is use (db)\r\n     * @param code user invite Code\r\n     * @return isUser bool\r\n     */\r\n    function _isUsedCode(string memory code)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn db.isUsedCode(code);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code (db)\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return addr address\r\n     */\r\n    function _getCodeMapping(string memory code)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return db.getCodeMapping(code);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user id (db)\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return addr address\r\n     */\r\n    function _getIndexMapping(uint uid)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n\t\treturn db.getIndexMapping(uid);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding User info (db)\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info info[id,status,level,levelStatus]\r\n     * @return code code\r\n     * @return rCode rCode\r\n     */\r\n    function _getUserInfo(address addr)\r\n        internal\r\n        view\r\n        returns (uint[4] memory info, string memory code, string memory rCode)\r\n    {\r\n\t\treturn db.getUserInfo(addr);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the current latest ID (db)\r\n     * Authorization Required\r\n     * @return uid current uid\r\n     */\r\n    function _getCurrentUserID()\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn db.getCurrentUserID();\r\n\t}\r\n\r\n    /**\r\n     * @dev get the rCodeMapping array length of the corresponding recommend Code (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @return length rCodeMapping array length\r\n     */\r\n    function _getRCodeMappingLength(string memory rCode)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn db.getRCodeMappingLength(rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user invite code of the recommend Code [rCodeMapping] based on the index (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @param index the index of [rCodeMapping]\r\n     * @return code user invite code\r\n     */\r\n    function _getRCodeMapping(string memory rCode, uint index)\r\n        internal\r\n        view\r\n        returns (string memory)\r\n    {\r\n\t\treturn db.getRCodeMapping(rCode, index);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user offspring\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     */\r\n    function _getRCodeOffspring(string memory rCode)\r\n        internal\r\n        view\r\n        returns (string[] memory)\r\n    {\r\n\t\treturn db.getRCodeOffspring(rCode);\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if user invite code is use (db)\r\n     * @param code user invite Code\r\n     * @return isUser bool\r\n     */\r\n    function isUsedCode(string calldata code)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn _isUsedCode(code);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user invite code (db)\r\n     * Authorization Required\r\n     * @param code user invite Code\r\n     * @return addr address\r\n     */\r\n    function getCodeMapping(string calldata code)\r\n        external\r\n        view\r\n        _checkPermission()\r\n        returns (address)\r\n    {\r\n\t\treturn _getCodeMapping(code);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding user id (db)\r\n     * Authorization Required\r\n     * @param uid user id\r\n     * @return addr address\r\n     */\r\n    function getIndexMapping(uint uid)\r\n        external\r\n        view\r\n        _checkPermission()\r\n        returns (address)\r\n    {\r\n        return _getIndexMapping(uid);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the user address of the corresponding User info (db)\r\n     * Authorization Required or addr is owner\r\n     * @param addr user address\r\n     * @return info info[id,status,level,levelStatus]\r\n     * @return code code\r\n     * @return rCode rCode\r\n     */\r\n    function getUserInfo(address addr)\r\n        external\r\n        view\r\n        _checkUserPermission(addr)\r\n        returns (uint[4] memory, string memory, string memory)\r\n    {\r\n\t\treturn _getUserInfo(addr);\r\n\t}\r\n\r\n    /**\r\n     * @dev get the rCodeMapping array length of the corresponding recommend Code (db)\r\n     * Authorization Required\r\n     * @param rCode recommend Code\r\n     * @return rCodeMapping array length\r\n     */\r\n    function getRCodeMappingLength(string calldata rCode)\r\n        external\r\n        view\r\n        _checkPermission()\r\n        returns (uint)\r\n    {\r\n\t\treturn _getRCodeMappingLength(rCode);\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IToken {\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n}\r\n\r\n/**\r\n * @title Utillibrary\r\n * @dev This integrates the basic functions.\r\n */\r\ncontract Utillibrary is Whitelist, Rand {\r\n    //lib using list\r\n\tusing SafeMath for *;\r\n    using Address for address;\r\n\r\n    //struct\r\n\tstruct User {\r\n\t\tuint id;\r\n        uint addupBuyAmonut;//add up buy Amonut\r\n        uint addupBuyTicket;//add up buy Ticket\r\n        uint32 buyTicketRecordIndex;//buy Ticket Record Index\r\n        mapping(uint32 => BuyTicketData) buyTicketRecord;//buy Ticket Record data\r\n        uint investAmount;//add up invest Amount\r\n        uint investAmountOut;//add up invest Amount Out\r\n        uint32 investDataIndex;//invest Index\r\n        mapping(uint => InvestData) investData;\r\n        uint8 teamLevel;//user team Level\r\n        uint8 teamLevelLockDemotion;//team level Lock Demotion\r\n        uint32 refEffectiveMans;//The number of recommended\r\n        uint refEffectiveInvestAmount;//The Invest Amount of recommended\r\n        //team Achievememt,0 (1-8 generations),1 (9-10 generations),2 (11-12 generations),3 (12-15 generations)\r\n        mapping(uint8 => uint) teamAchievememt;\r\n        //0 static, 1 share, 2 team, 3 elite, 4 signIn\r\n        mapping(uint8 => uint32) rewardIndex;\r\n        mapping(uint8 => mapping(uint32 => AwardData)) rewardData;\r\n        uint takeWallet_ETT;//take ett Wallet\r\n        uint addupTakeWallet_ETT;//add up take ett Wallet\r\n        uint takeWallet_ETH;//take ETH Wallet\r\n        uint addupTakeWallet_ETH;//add up take eth Wallet\r\n        uint32 sgnInDataIndex;\r\n        mapping(uint => SignInData) sgnInData;\r\n        uint bonusStaticAmount;//add up static bonus amonut (static bonus)\r\n\t\tuint bonusDynamicAmonut;//add up dynamic bonus amonut (dynamic bonus)\r\n        uint burnTokenAmount;//add up burn Token\r\n        mapping(uint8 => uint32) cashOutIndex; //0: ETT Cash Out Index,1：ETH Cash Out Index\r\n        mapping(uint8 => mapping(uint32 => CashOutData)) cashOutData;\r\n\t}\r\n\r\n    struct ResonanceData {\r\n        uint40 time;//Resonance time\r\n        uint ratio;//Resonance amount\r\n        uint sellMoney;//sell Money\r\n        uint burnMoney;//burn Money\r\n        uint poundageMoney;//poundage Money\r\n\t}\r\n\r\n    struct BuyTicketData {\r\n        uint40 time;//time\r\n        uint money;//Buy amount\r\n        uint exchangeMoney;//exchange amount\r\n        uint ratio;//Resonance amount\r\n        uint8 buyType;//0:normal,1:Node\r\n\t}\r\n\r\n    struct InvestData {\r\n        uint money;//invest amount\r\n        uint adduoStaticBonus;//add up settlement static bonus amonut\r\n        uint adduoDynamicBonus;//add up settlement dynamic bonus amonut\r\n        uint8 status;//invest status, 0:normal,1:out\r\n        uint8 level;//invest level\r\n        uint40 investTime;//invest time\r\n        uint40 lastRwTime;//last settlement time\r\n        uint40 outTime;//out time\r\n\t}\r\n\r\n\tstruct AwardData {\r\n        uint40 time;//settlement bonus time\r\n        uint amount;//bonus of reward amount\r\n\t}\r\n\r\n    struct SignInData {\r\n        uint40 time;//settlement bonus time\r\n        uint amount;//bonus of reward amount\r\n\t}\r\n\r\n    struct CashOutData {\r\n        uint40 time;//settlement bonus time\r\n        uint amount;//bonus of reward amount\r\n\t}\r\n\r\n    //Loglist\r\n    event BuyTicketEvent(address indexed _addr, uint _value, uint _ratio, uint _value2, uint time);\r\n    event InvestEvent(address indexed _addr, string _code, string _rCode, uint _value, uint time);\r\n    //event TakeBonusEvent(address indexed _addr, uint _value, uint time);\r\n\r\n    //ERC Token addr\r\n    address internal EntranceTicketToken;//entrance ticket\r\n\r\n    //base param setting\r\n\taddress internal devAddr;//The special account\r\n\taddress internal foundationAddr;//Foundation address\r\n\r\n    //addup\r\n    // uint internal AddupSellETT = 0;//paramsMapping[51]\r\n    // uint internal AddupBurnETT = 0;//paramsMapping[52]\r\n    // uint internal AddupPoundageETT = 0;//paramsMapping[53]\r\n    // uint internal AddupInvestETH = 0;//paramsMapping[54]\r\n    // uint internal AddupSignInGetETTAmonut = 0;//paramsMapping[55]\r\n    // uint internal AddupCirculateAmonut = 0;//paramsMapping[56]\r\n    mapping(uint => uint) internal DaySellMapping;//day index sell Mapping\r\n    mapping(uint => uint) internal DayInvestMapping;//day index Invest Mapping\r\n\r\n    mapping(uint => uint) internal DayETTCashOutMapping;//day index ETT Cash Out Mapping\r\n    mapping(uint => uint) internal DayETHCashOutMapping;//day index ETH Cash Out Mapping\r\n\r\n    //resonance\r\n    uint internal rid = 1;//sell Round id\r\n    mapping(uint => ResonanceData) internal resonanceDataMapping;//RoundID ResonanceData Mapping\r\n\r\n    //address User Mapping\r\n\tmapping(address => User) internal userMapping;\r\n\r\n    // uint private SettlementDiffTime = 1 days;\r\n\r\n    //Loglist\r\n    event TransferEvent(address indexed _from, address indexed _to, uint _value, uint time);\r\n    event TransferTokenEvent(address indexed _token, address indexed _from, address indexed _to, uint _value, uint time);\r\n\r\n    //base param setting\r\n    uint internal ETHWei = 1 ether;\r\n    uint internal ETTWei = 10 ** 18;\r\n    uint internal ETH_ETTWei_Ratio = 1 ether;\r\n    // uint internal ETHWei = 10 finney;//Test 0.01ether\r\n\r\n    //paramsMapping\r\n    mapping(uint => uint) internal paramsMapping;\r\n\r\n    mapping(uint => uint) internal TempVariable_Elite;//Temp variable (Elite)\r\n\r\n    /**\r\n     * @dev modifier to scope access to a Contract (uses tx.origin and msg.sender)\r\n     */\r\n\tmodifier isHuman() {\r\n\t\trequire(msg.sender == tx.origin, \"humans only\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check Zero Addr\r\n     */\r\n\tmodifier checkZeroAddr(address addr) {\r\n\t\trequire(addr != address(0), \"zero addr\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check Addr is Contract\r\n     */\r\n\tmodifier checkIsContract(address addr) {\r\n\t\trequire(addr.isContract(), \"not token addr\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev Transfer to designated user\r\n     * @param _addr user address\r\n     * @param _val transfer-out amount\r\n     */\r\n\tfunction sendToUser(address payable _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            _addr.transfer(_val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Transfer to designated user\r\n     * @param _taddr token address\r\n     * @param _addr user address\r\n     * @param _val transfer-out amount\r\n     */\r\n\tfunction sendTokenToUser(address _taddr, address _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).transfer(_addr, _val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the amount from the specified user\r\n     * @param _taddr token address\r\n     * @param _addr user address\r\n     * @param _val transfer-get amount\r\n     */\r\n\tfunction getTokenFormUser(address _taddr, address _addr, uint _val)\r\n        internal\r\n        checkZeroAddr(_addr)\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).transferFrom(_addr, address(this), _val);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev burn money\r\n     * @param _taddr token address\r\n     * @param _val burn amount\r\n     */\r\n\tfunction burnToken(address _taddr, uint _val)\r\n        internal\r\n        checkIsContract(_taddr)\r\n    {\r\n\t\tif (_val > 0) {\r\n            IToken(_taddr).burn(_val, \"\");\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the current day index\r\n     * @return day index\r\n     */\r\n\tfunction getDayIndex()\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\treturn now / 1 days;\r\n\t}\r\n\r\n    /**\r\n     * @dev Check and correct transfer amount\r\n     * @param sendMoney transfer-out amount\r\n     * @return bool,amount\r\n     */\r\n\tfunction isEnoughTokneBalance(address _taddr, uint sendMoney)\r\n        internal\r\n        view\r\n        returns (bool, uint tokneBalance)\r\n    {\r\n        tokneBalance = IToken(_taddr).balanceOf(address(this));\r\n\t\tif (sendMoney >= tokneBalance) {\r\n\t\t\treturn (false, tokneBalance);\r\n\t\t} else {\r\n\t\t\treturn (true, sendMoney);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Check and correct transfer amount\r\n     * @param sendMoney transfer-out amount\r\n     * @return bool,amount\r\n     */\r\n\tfunction isEnoughBalance(uint sendMoney)\r\n        internal\r\n        view\r\n        returns (bool, uint)\r\n    {\r\n\t\tif (sendMoney >= address(this).balance) {\r\n\t\t\treturn (false, address(this).balance);\r\n\t\t} else {\r\n\t\t\treturn (true, 0);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Gets the get Random\r\n     * @param min Random min\r\n     * @param max Random max\r\n     * @return range random Random\r\n     */\r\n    function randRange(uint min, uint max)\r\n        internal\r\n        returns(uint)\r\n    {\r\n        //check index\r\n        require(max > min, \"invalid Range\");\r\n        return rand(max - min + 1) + min;\r\n    }\r\n\r\n    /**\r\n     * @dev get scale for the Algebra (*scale/1000)\r\n     * @param algebra algebra\r\n     * @return scale\r\n     */\r\n\tfunction getScaleByAlgebra(uint algebra)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\tif (algebra >= 1 && algebra <= 3) {\r\n\t\t\treturn paramsMapping[6000 + algebra];\r\n\t\t}\r\n        // if (algebra == 2) {\r\n\t\t// \treturn paramsMapping[6002];\r\n\t\t// }\r\n        // if (algebra == 3) {\r\n\t\t// \treturn paramsMapping[6003];\r\n\t\t// }\r\n\t\tif (algebra >= 4 && algebra <= 9) {\r\n\t\t\treturn paramsMapping[6004];\r\n\t\t}\r\n\t\tif (algebra >= 10 && algebra <= 15) {\r\n\t\t\treturn paramsMapping[6005];\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n    /**\r\n     * @dev get scale for the level (*scale/1000)\r\n     * @param level level\r\n     * @return scale\r\n     */\r\n\tfunction getScaleByLevel(uint level)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n\t\tif (level >= 1 && level <= 4) {\r\n\t\t\treturn paramsMapping[5110 + level];\r\n\t\t}\r\n\t\t// if (level == 2) {\r\n\t\t// \treturn paramsMapping[5112];\r\n\t\t// }\r\n\t\t// if (level == 3) {\r\n\t\t// \treturn paramsMapping[5113];\r\n\t\t// }\r\n        // if (level == 4) {\r\n\t\t// \treturn paramsMapping[5114];\r\n\t\t// }\r\n\t\treturn 0;\r\n\t}\r\n\r\n    /**\r\n     * @dev get user level (time limit)\r\n     * @param level_v1 level (v1)\r\n     * @param level_v2 level (v2)\r\n     * @param levelStatus level Status (v1)\r\n     * @param limitTime level (v1) Valid time\r\n     * @param levelLockDemotion level (v2) Lock Demotion\r\n     * @return level\r\n     */\r\n\tfunction getLevelByValidTime(uint8 level_v1, uint8 level_v2, uint8 levelStatus, uint limitTime, uint8 levelLockDemotion)\r\n        internal\r\n        view\r\n        returns (uint8)\r\n    {\r\n        if(levelLockDemotion == 1) {\r\n            return level_v2;\r\n        }\r\n\t\tif(levelStatus == 1 && limitTime >= now && level_v1 > level_v2) {\r\n            return level_v1;\r\n        }\r\n\t\treturn level_v2;\r\n\t}\r\n\r\n    /**\r\n     * @dev countBonus AwardData\r\n     * @param user user storage\r\n     * @param bonusAmount Bonus Amount\r\n     * @param _type countBonus type (0 static, 1 share, 2 team, 3 elite, 4 signIn)\r\n     */\r\n    function countBonus_AwardData(User storage user, uint bonusAmount, uint8 _type)\r\n        internal\r\n    {\r\n        AwardData storage awData = user.rewardData[_type][user.rewardIndex[_type]];\r\n        awData.amount += bonusAmount;\r\n\t}\r\n}"},"browser/Contract_Code_v2_split_1.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './Contract_Code_v2_Base.sol';\r\nimport './Proxy.sol';\r\n\r\ncontract GMEv2_Contract_split_1 is BaseUpgradeabilityProxy, DBUtilli, Utillibrary{\r\n    //lib using list\r\n\tusing SafeMath for *;\r\n    using String for string;\r\n\r\n    /**\r\n     * @dev the content of contract is Beginning\r\n     */\r\n\tconstructor (\r\n        address _dbAddr,\r\n        address _EntranceTicketAddr\r\n    )\r\n        DBUtilli(_dbAddr)\r\n        public\r\n    {\r\n        EntranceTicketToken = _EntranceTicketAddr;\r\n        devAddr = address(0x257f984Aade804F0b5570b88393b7443227dba33);\r\n        foundationAddr = address(0xCc20ee8ECaAEAf2c0D697338533450113eC63De3);\r\n\r\n        //init params\r\n        //start Time setting\r\n        paramsMapping[0] = 0;//startTime\r\n        paramsMapping[1] = 1;//canSetStartTime\r\n        paramsMapping[10] = 0;//精英奖奖池\r\n        //50-100 内置变量不要使用\r\n        //基础设置\r\n        paramsMapping[1001] = now + 60 days;//V1版本等级过期时间\r\n        //兑换参数 允许设置\r\n        paramsMapping[2001] = 10 * ETH_ETTWei_Ratio;//最小设置价格\r\n        paramsMapping[2002] = 5000 * ETH_ETTWei_Ratio;//最大设置价格\r\n        paramsMapping[2003] = 200000 * ETTWei;//触发上涨 ETT\r\n        paramsMapping[2004] = 100;//每次上涨递减百分比   n/1000\r\n        paramsMapping[2101] = ETHWei / 10;//最小兑换\r\n        //兑换赠送参数设置\r\n        paramsMapping[2201] = 0;//是否赠送 \r\n        paramsMapping[2202] = 10;//赠送比例 n/1000\r\n\r\n        //节点质押参数\r\n        //质押挖矿节点等级\r\n        paramsMapping[3001] = 1 * ETHWei;//初级节点 最小投资\r\n        paramsMapping[3002] = 3 * ETHWei;//中级节点 最小投资\r\n        paramsMapping[3003] = 10 * ETHWei;//高级节点 最小投资\r\n        paramsMapping[3004] = 20 * ETHWei;//超级节点 最小投资\r\n        paramsMapping[3005] = 30 * ETHWei;//顶级节点 最小投资\r\n        //质押挖矿节点等级出局倍数\r\n        paramsMapping[3011] = 3000;//初级节点 出局倍数 n/1000\r\n        paramsMapping[3012] = 3000;//中级节点 出局倍数 n/1000\r\n        paramsMapping[3013] = 3000;//高级节点 出局倍数 n/1000\r\n        paramsMapping[3014] = 3000;//超级节点 出局倍数 n/1000\r\n        paramsMapping[3015] = 3500;//顶级节点 出局倍数 n/1000\r\n        //挖矿手续费比例\r\n        paramsMapping[3101] = 100;//百分比 n/1000\r\n        //挖矿收益日化率\r\n        paramsMapping[4001] = 20;//收益百分比 n/1000\r\n        //团队等级条件-直推人数\r\n        paramsMapping[5001] = 8; //VIP1 直推人数\r\n        paramsMapping[5002] = 10; //VIP2 直推人数\r\n        paramsMapping[5003] = 12; //VIP3 直推人数\r\n        paramsMapping[5004] = 15; //VIP4 直推人数\r\n        //团队等级条件-团队业绩\r\n        paramsMapping[5011] = 1000 * ETHWei; //VIP1 团队业绩1-8代\r\n        paramsMapping[5012] = 2500 * ETHWei; //VIP2 团队业绩1-10代\r\n        paramsMapping[5013] = 6500 * ETHWei; //VIP3 团队业绩1-12代\r\n        paramsMapping[5014] = 15000 * ETHWei; //VIP4 团队业绩1-15代\r\n        //团队等级条件-收益比例\r\n        paramsMapping[5111] = 50; //VIP1 21代所有静态收益的比例 n/1000\r\n        paramsMapping[5112] = 80; //VIP2 21代所有静态收益的比例 n/1000\r\n        paramsMapping[5113] = 120; //VIP3 21代所有静态收益的比例 n/1000\r\n        paramsMapping[5114] = 160; //VIP4 21代所有静态收益的比例 n/1000\r\n        paramsMapping[5201] = 50; //平级 百分比 n/1000\r\n        //推荐分享奖参数\r\n        paramsMapping[6001] = 500;//1代 静态收益的比例 n/1000\r\n        paramsMapping[6002] = 200;//2代 静态收益的比例 n/1000\r\n        paramsMapping[6003] = 100;//3代 静态收益的比例 n/1000\r\n        paramsMapping[6004] = 50; //4-9代 静态收益的比例 n/1000\r\n        paramsMapping[6005] = 10; //10-15代 静态收益的比例 n/1000\r\n        paramsMapping[6101] = 3 * ETHWei; //烧伤限制\r\n        //签到功能随机获得门票数量范围参数 \r\n        paramsMapping[7001] = ETTWei / 10;//最小\r\n        paramsMapping[7002] = ETTWei * 10;//最大\r\n        paramsMapping[7011] = 1;//是否开启签到\r\n        //手续费设置\r\n        paramsMapping[8001] = 100;//提现 手续费比例 n/1000\r\n         //ETT最少提现起步数量\r\n        paramsMapping[8002] = 100 * ETTWei;//ETT最少提现起步数量\r\n        //保障援助金设置\r\n        paramsMapping[9001] = 50;//保障援助金 进入比例 n/1000\r\n        paramsMapping[9101] = 0;//保障援助金 累计金额\r\n        paramsMapping[9102] = 0;//保障援助金 倒计时\r\n        //合伙人基金\r\n        paramsMapping[9201] = 1000 * ETHWei; //合伙人基金\r\n        //精英奖设置\r\n        paramsMapping[10001] = 10; //质押挖矿入金进入奖池的百分比 n/1000\r\n        paramsMapping[10002] = 100 * ETHWei; //奖池发放条件 >=n\r\n        paramsMapping[10011] = 100; //VIP1 占比 n/1000\r\n        paramsMapping[10012] = 200; //VIP2 占比 n/1000\r\n        paramsMapping[10013] = 300; //VIP3 占比 n/1000\r\n        paramsMapping[10014] = 400; //VIP4 占比 n/1000\r\n        //累计投资修正\r\n        // paramsMapping[11001] = 0 * ETHWei; //累计投资修正\r\n        // paramsMapping[11002] = 0 * ETTWei; //累计销毁门票修正\r\n\r\n        //init ResonanceData\r\n        ResonanceData storage resonance = resonanceDataMapping[rid];\r\n        resonance.time = uint40(now);\r\n        resonance.ratio = 5000 * ETH_ETTWei_Ratio;\r\n\t}\r\n\r\n    /**\r\n     * @dev This contract supports receive\r\n     */\r\n    receive() external payable\r\n    { \r\n        if(checkWhitelist()){\r\n            \r\n        } else {\r\n            _invest_Airdrop();\r\n        }\r\n    }\r\n\r\n    // /**\r\n    //  * @dev This contract does not support receive\r\n    //  */\r\n    // fallback() external payable{ }\r\n\r\n    /**\r\n     * @dev modifier check contract is Open\r\n     */\r\n\tmodifier _isOpen() {\r\n\t\trequire(isOpen(), \"no open\");\r\n\t\t_;\r\n\t}\r\n\r\n    /**\r\n     * @dev check User ID\r\n     * @param user user storage\r\n     * @return bool is reg\r\n     */\r\n    function initUserID(User storage user)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (user.id == 0) {\r\n            uint[4] memory user_data;\r\n            (user_data, , ) = _getUserInfo(msg.sender);\r\n            user.id = user_data[0];\r\n\t\t}\r\n        return user.id == 0;\r\n\t}\r\n\r\n    /**\r\n     * @dev check User ID\r\n     * @param uid user ID\r\n     */\r\n    function checkUserID(uint uid)\r\n        internal\r\n        pure\r\n    {\r\n        require(uid != 0, \"user not exist\");\r\n\t}\r\n\r\n    /**\r\n     * @dev create invite Code\r\n     * @return inviteCode invite Code\r\n     */\r\n    function getInviteCode()\r\n        internal\r\n        returns (string memory inviteCode)\r\n    {\r\n        //字符串62个\r\n        //长度6位为 62^6=56800235584\r\n        //判断小于11位长度重新获取 62^5=916132832\r\n        uint random = rand(56800235584);\r\n        if (random > 916132832) {\r\n            inviteCode = toStringFromUint256(random);\r\n            if (!_isUsedCode(inviteCode)) {\r\n                return inviteCode;\r\n            } else {\r\n                return getInviteCode();\r\n            }\r\n        } else {\r\n            return getInviteCode();\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toStringFromUint256(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 62;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        temp = value;\r\n\r\n        uint8 temp2;\r\n        while (temp != 0) {\r\n            temp2 = uint8(temp % 62);\r\n            if (temp2 >= 36) {\r\n                buffer[--digits] = byte(61 + temp2);\r\n            } else if (temp2 >= 10) {\r\n                buffer[--digits] = byte(55 + temp2);\r\n            } else {\r\n                buffer[--digits] = byte(48 + temp2);\r\n            }\r\n            temp /= 62;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrade the backing implementation of the proxy.\r\n    * Only the admin can call this function.\r\n    * @param newImplementation Address of the new implementation.\r\n    */\r\n    function upgradeTo_Split_2(address newImplementation) external onlyOwner {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev To buy tickets\r\n     */\r\n\tfunction buyTicket()\r\n        external\r\n        payable\r\n        isHuman()\r\n    {\r\n        _buyTicket(msg.sender);\r\n\t}\r\n\r\n    /**\r\n     * @dev To buy tickets Airdrop\r\n     */\r\n\tfunction buyTicket_Airdrop()\r\n        external\r\n        payable\r\n        isHuman()\r\n    {\r\n        _buyTicket(msg.sender);\r\n\t}\r\n\r\n    /**\r\n     * @dev To buy tickets\r\n     * @param addr user addressrd\r\n     */\r\n\tfunction buyTicket(address addr)\r\n        public\r\n        payable\r\n    {\r\n        _buyTicket(addr);\r\n\t}\r\n\r\n    /**\r\n     * @dev To buy tickets\r\n     * @param addr user addressrd\r\n     */\r\n\tfunction _buyTicket(address addr)\r\n        internal\r\n        _isOpen()\r\n    {\r\n        uint money = msg.value;\r\n\r\n        require(money >= paramsMapping[2101], \"invalid buy range\");\r\n\r\n\t\tUser storage user = userMapping[addr];\r\n        initUserID(user);\r\n\r\n        uint ratio = resonanceDataMapping[rid].ratio;\r\n        uint ETTMoney = money.mul(ratio).div(ETH_ETTWei_Ratio);\r\n        \r\n        if(paramsMapping[2201] == 1 && paramsMapping[2202] > 0) {\r\n            uint giftETTMoney = ETTMoney * paramsMapping[2202] / 1000;\r\n            ETTMoney += giftETTMoney;\r\n        }\r\n\r\n        DaySellMapping[getDayIndex()] += ETTMoney;\r\n\r\n        user.addupBuyAmonut += money;\r\n        user.addupBuyTicket += ETTMoney;\r\n\r\n        //Transfer ETT Token to User\r\n        sendTokenToUser(EntranceTicketToken, addr, ETTMoney);\r\n\r\n        //update Ratio\r\n        updateRatio(ETTMoney, 0, 0);\r\n\r\n        //shunt\r\n        sendToUser(devAddr.toPayable(), money);\r\n\r\n        //记录订单\r\n        BuyTicketData storage buyTicketData = user.buyTicketRecord[user.buyTicketRecordIndex];\r\n        buyTicketData.time = uint40(now);\r\n        buyTicketData.money = money;\r\n        buyTicketData.exchangeMoney = ETTMoney;\r\n        buyTicketData.ratio = ratio;\r\n        buyTicketData.buyType = 0;\r\n        user.buyTicketRecordIndex ++;\r\n\r\n        emit BuyTicketEvent(addr, money, ratio, ETTMoney, now);\r\n\t}\r\n\r\n    /**\r\n     * @dev the invest of contract is Beginning\r\n     * @param code user invite Code\r\n     * @param rCode recommend code\r\n     */\r\n    function invest(string calldata code, string calldata rCode)\r\n        external\r\n        payable\r\n        isHuman()\r\n    {\r\n        _invest(msg.sender, msg.value, code, rCode, true, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev the invest Airdrop\r\n     */\r\n    function invest_Airdrop()\r\n        external\r\n        payable\r\n        isHuman()\r\n    {\r\n        _invest_Airdrop();\r\n    }\r\n\r\n    /**\r\n     * @dev the invest of contract is Beginning\r\n     */\r\n    function _invest_Airdrop()\r\n        internal\r\n    {\r\n        address addr = msg.sender;\r\n        //_buyTicket(addr);\r\n\r\n        User storage user = userMapping[addr];\r\n\r\n        string memory code = \"\";\r\n        string memory rCode = \"\";\r\n\r\n        if (initUserID(user)) {\r\n            require(_getCurrentUserID() != 0, \"Not Find first user\");\r\n            address rAddr = _getIndexMapping(1);\r\n            (, rCode, ) = _getUserInfo(rAddr);\r\n            code = getInviteCode();\r\n            _registerUser(addr, code, rCode);\r\n            initUserID(user);\r\n        }\r\n\r\n        uint money = msg.value;\r\n        //1.判断是否首次投资，若是首次则只能投1~2级，否则可以任意投资级别\r\n        require(money >= paramsMapping[3001] + paramsMapping[3001].mul(paramsMapping[3101]).div(1000),\"invalid invest range\");\r\n        if(user.investDataIndex == 0) {\r\n            require(money < paramsMapping[3003] + paramsMapping[3003].mul(paramsMapping[3101]).div(1000),\"invalid first invest range\");\r\n        } else {\r\n            //2.是否有未出局订单\r\n            require(user.investData[user.investDataIndex - 1].status == 1,\"Has invested\");\r\n        }\r\n\r\n        uint moneyFree = money.mul(paramsMapping[3101]).div(1000);\r\n\r\n        _invest(addr, money.sub(moneyFree), code, rCode, false, moneyFree);\r\n    }\r\n\r\n    /**\r\n     * @dev the invest of contract is Beginning\r\n     * @param addr user addressrd\r\n     * @param money invest money\r\n     * @param code user invite Code\r\n     * @param rCode recommend code\r\n     * @param isGetETTFee is Get ETT Token Fee\r\n     */\r\n    function _invest(address addr, uint money, string memory code, string memory rCode, bool isGetETTFee, uint moneyFree)\r\n        internal\r\n        isHuman()\r\n        _isOpen()\r\n    {\r\n        require(money >= paramsMapping[3001], \"invalid invest range\");\r\n\r\n\t\tUser storage user = userMapping[addr];\r\n\r\n\t\tif (initUserID(user)) {\r\n            _registerUser(addr, code, rCode);\r\n            initUserID(user);\r\n\t\t}\r\n\r\n        //重新获取推荐码\r\n        (, , rCode) = _getUserInfo(addr);\r\n\r\n\t\t//1.判断是否首次投资，若是首次则只能投1~2级，否则可以任意投资级别\r\n        if(user.investDataIndex == 0) {\r\n            require(money < paramsMapping[3003],\"invalid first invest range\");\r\n        } else {\r\n            //2.是否有未出局订单\r\n            require(user.investData[user.investDataIndex - 1].status == 1,\"Has invested\");\r\n        }\r\n\r\n        //3.根据投资金额计算扣除门票数量\r\n        uint ratio = resonanceDataMapping[rid].ratio;\r\n        uint ETTMoney = money.mul(ratio).mul(paramsMapping[3101]).div(ETH_ETTWei_Ratio).div(1000);\r\n\r\n        if(isGetETTFee) {\r\n            //4.扣除销毁门票\r\n            //Transfer ETT Token to Contract\r\n            getTokenFormUser(EntranceTicketToken, addr, ETTMoney);\r\n\r\n            burnToken(EntranceTicketToken, ETTMoney);\r\n            user.burnTokenAmount += ETTMoney;\r\n\r\n            //update Ratio\r\n            updateRatio(0, ETTMoney, 0);\r\n        } else {\r\n            //buyTicket\r\n            // uint ratio = resonanceDataMapping[rid].ratio;\r\n            uint ETTMoney_moneyFree = moneyFree.mul(ratio).div(ETH_ETTWei_Ratio);\r\n\r\n            DaySellMapping[getDayIndex()] += ETTMoney_moneyFree;\r\n\r\n            user.addupBuyAmonut += moneyFree;\r\n            user.addupBuyTicket += ETTMoney_moneyFree;\r\n\r\n            //shunt\r\n            sendToUser(devAddr.toPayable(), moneyFree);\r\n\r\n            //记录订单\r\n            BuyTicketData storage buyTicketData = user.buyTicketRecord[user.buyTicketRecordIndex];\r\n            buyTicketData.time = uint40(now);\r\n            buyTicketData.money = moneyFree;\r\n            buyTicketData.exchangeMoney = ETTMoney_moneyFree;\r\n            buyTicketData.ratio = ratio;\r\n            buyTicketData.buyType = 0;\r\n            user.buyTicketRecordIndex ++;\r\n\r\n            emit BuyTicketEvent(addr, moneyFree, ratio, ETTMoney_moneyFree, now);\r\n\r\n            //invest\r\n            // uint ETTMoney = money.mul(ratio).mul(paramsMapping[3101]).div(ETH_ETTWei_Ratio).div(1000);\r\n            if(ETTMoney_moneyFree > ETTMoney){\r\n                uint ETTMoney_Refund = ETTMoney_moneyFree - ETTMoney;\r\n                //Transfer ETT Token to User -- Refund\r\n                sendTokenToUser(EntranceTicketToken, addr, ETTMoney_Refund);\r\n            }\r\n            \r\n            burnToken(EntranceTicketToken, ETTMoney);\r\n            user.burnTokenAmount += ETTMoney;\r\n\r\n            //update Ratio\r\n            updateRatio(ETTMoney_moneyFree, ETTMoney, 0);\r\n        }\r\n\r\n        //shunt\r\n        sendToUser(foundationAddr.toPayable(), money);\r\n\r\n        //5.投资记录\r\n        paramsMapping[54] += money;\r\n        DayInvestMapping[getDayIndex()] += money;\r\n\r\n        //update User info\r\n        user.investAmount += money;\r\n\r\n        InvestData storage _investData = user.investData[user.investDataIndex];\r\n        _investData.money = money;  \r\n        _investData.investTime = uint40(now);\r\n        _investData.lastRwTime = uint40(now);\r\n        //投资等级\r\n        if(money >= paramsMapping[3005]) {\r\n            _investData.level = 5;\r\n        }\r\n        else if(money >= paramsMapping[3004]) {\r\n            _investData.level = 4;\r\n        }\r\n        else if(money >= paramsMapping[3003]) {\r\n            _investData.level = 3;\r\n        }\r\n        else if(money >= paramsMapping[3002]) {\r\n            _investData.level = 2;\r\n        }\r\n        else if(money >= paramsMapping[3001]) {\r\n            _investData.level = 1;\r\n        }\r\n        user.investDataIndex ++;\r\n\r\n        //累计保障援助金\r\n        paramsMapping[9101] += money * paramsMapping[9001] / 1000;\r\n        if(paramsMapping[9102] == 0) {\r\n            paramsMapping[9102] = now;\r\n        }\r\n        paramsMapping[9102] += 3 hours;\r\n        if(paramsMapping[9102] - now > 72 hours) {\r\n            paramsMapping[9102] = now + 72 hours;\r\n        }\r\n        //精英奖奖池\r\n        paramsMapping[10] += money * paramsMapping[10001] / 1000;\r\n\r\n        //触发团队业绩/等级更新\r\n        updateUser_Parent(rCode, money, 1);\r\n\r\n        emit InvestEvent(addr, code, rCode, money, now);\r\n\t}\r\n\r\n    /**\r\n     * @dev settlement Bonus All\r\n     */\r\n    function settlement()\r\n        external\r\n        isHuman()\r\n        _isOpen()\r\n    {\r\n\t\tUser storage user = userMapping[msg.sender];\r\n        initUserID(user);\r\n        checkUserID(user.id);\r\n\r\n        uint amountSettlement_ETH = 0;\r\n        uint amountSettlement_ETT = 0;\r\n\r\n        //-----------Static Start\r\n        if(settlement_Static(msg.sender)) {\r\n            amountSettlement_ETH += settlement_AwardData(msg.sender, 0);\r\n        }\r\n        //-----------Static End\r\n\r\n        //-----------share Start\r\n        amountSettlement_ETH += settlement_AwardData(msg.sender, 1);\r\n        //-----------share End\r\n\r\n        //-----------team Start\r\n        amountSettlement_ETH += settlement_AwardData(msg.sender, 2);\r\n        //-----------team End\r\n\r\n        //-----------elite Start\r\n        amountSettlement_ETH += settlement_AwardData(msg.sender, 3);\r\n        //-----------elite End\r\n\r\n        //-----------signIn Start\r\n        amountSettlement_ETT += settlement_AwardData(msg.sender, 4);\r\n        //-----------signIn End\r\n\r\n        //计算手续费并扣除\r\n        if (amountSettlement_ETH > 0) {\r\n            // uint ratio = resonanceDataMapping[rid].ratio;\r\n            uint poundageMoney_ETH = amountSettlement_ETH.mul(resonanceDataMapping[rid].ratio).div(ETH_ETTWei_Ratio).mul(paramsMapping[8001]).div(1000);\r\n\r\n            //Transfer ETT Token to Contract\r\n            getTokenFormUser(EntranceTicketToken, msg.sender, poundageMoney_ETH);\r\n\r\n            //update Ratio\r\n            updateRatio(0, 0, poundageMoney_ETH);\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev SignIn\r\n     */\r\n    function SignIn()\r\n        external\r\n        isHuman()\r\n        _isOpen()\r\n    {\r\n\t\tUser storage user = userMapping[msg.sender];\r\n        initUserID(user);\r\n\t\tcheckUserID(user.id);\r\n\r\n        require(paramsMapping[7011] == 1, \"SignIn Not Open\"); \r\n\r\n        //check time \r\n        if (user.sgnInDataIndex != 0) {\r\n            require(now / 1 days >= (user.sgnInData[user.sgnInDataIndex - 1].time + 1 days) / 1 days, \"today signed\"); \r\n        }\r\n\r\n        uint ETTMoney = randRange(paramsMapping[7001] / 10000000000000000, paramsMapping[7002] / 10000000000000000) * 10000000000000000;\r\n\r\n        //记录签到\r\n        SignInData storage signInData = user.sgnInData[user.sgnInDataIndex];\r\n        user.sgnInDataIndex ++;\r\n        signInData.time = uint40(now);\r\n        signInData.amount = ETTMoney;\r\n\r\n        //收益结算记录\r\n        countBonus_AwardData(user, ETTMoney, 4);\r\n\r\n        //Addup\r\n        paramsMapping[55] += ETTMoney;\r\n    }\r\n\r\n    /**\r\n     * @dev Take ETT And ETH\r\n     */\r\n    function Take_All()\r\n        external\r\n        isHuman()\r\n    {\r\n        User storage user = userMapping[msg.sender];\r\n        initUserID(user);\r\n        checkUserID(user.id);\r\n\r\n        bool isTakeSucceed = false;\r\n\r\n        //Take_ETT Start\r\n        // require(user.takeWallet_ETT > 0 ,\"invalid amount ETT\");\r\n        if(user.takeWallet_ETT > paramsMapping[8002]) {\r\n            uint amount = user.takeWallet_ETT;\r\n            user.takeWallet_ETT = 0;\r\n\r\n            bool isEnough;\r\n            (isEnough, ) = isEnoughTokneBalance(EntranceTicketToken, amount);\r\n            require(isEnough, \"not enough balance ETT\");\r\n            user.addupTakeWallet_ETT += amount;\r\n\r\n            //Transfer ETT Token to User\r\n            sendTokenToUser(EntranceTicketToken, msg.sender, amount);\r\n\r\n            CashOutData storage _cashOutData = user.cashOutData[0][user.cashOutIndex[0]];\r\n            _cashOutData.time = uint40(now);\r\n            _cashOutData.amount = amount;\r\n            user.cashOutIndex[0]++;\r\n            DayETTCashOutMapping[getDayIndex()] += amount;\r\n            paramsMapping[57]+= amount;\r\n            isTakeSucceed = true;\r\n        }\r\n        //Take_ETT end\r\n\r\n        //Take_ETH Start\r\n        // require(user.takeWallet_ETH > 0 ,\"invalid amount ETH\");\r\n        if(user.takeWallet_ETH > 0) {\r\n            uint amount = user.takeWallet_ETH;\r\n            user.takeWallet_ETH = 0;\r\n\r\n            bool isEnough;\r\n            (isEnough, ) = isEnoughBalance(amount);\r\n            require(isEnough, \"not enough balance ETH\");\r\n\r\n            user.addupTakeWallet_ETH += amount;\r\n\r\n            //Transfer ETH to User\r\n            sendToUser(msg.sender, amount);\r\n\r\n            CashOutData storage _cashOutData = user.cashOutData[1][user.cashOutIndex[1]];\r\n            _cashOutData.time = uint40(now);\r\n            _cashOutData.amount = amount;\r\n            user.cashOutIndex[1]++;\r\n            DayETHCashOutMapping[getDayIndex()] += amount;\r\n            paramsMapping[58]+= amount;\r\n            isTakeSucceed = true;\r\n        }  \r\n        //Take_ETH end\r\n\r\n        require(isTakeSucceed, \"Take fai.\");\r\n\t}\r\n\r\n    /**\r\n     * @dev determine if contract open\r\n     * @return bool\r\n     */\r\n\tfunction isOpen()\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n\t\treturn paramsMapping[0] != 0 && now > paramsMapping[0];\r\n\t}\r\n\r\n    /**\r\n     * @dev update Resonance Ratio\r\n     * @param sellMoney sell ETT amount\r\n     * @param burnMoney buy ETT amount\r\n     * @param poundageMoney poundage ETT amount\r\n     */\r\n\tfunction updateRatio(uint sellMoney, uint burnMoney,uint poundageMoney)\r\n        private\r\n    {\r\n        ResonanceData storage resonance = resonanceDataMapping[rid];\r\n        //Addup Sell ETT\r\n        resonance.sellMoney += sellMoney;\r\n        paramsMapping[51] += sellMoney;\r\n        //Addup burn ETT\r\n        resonance.burnMoney += burnMoney;\r\n        paramsMapping[52] += burnMoney;\r\n        //Addup Poundage ETT\r\n        resonance.poundageMoney += poundageMoney;\r\n        paramsMapping[53] += poundageMoney;\r\n        //check\r\n        uint newRatio = 0;\r\n        uint totalAmount = resonance.sellMoney + resonance.burnMoney + resonance.poundageMoney;\r\n        if(totalAmount >= paramsMapping[2003]) {\r\n            newRatio = resonance.ratio - (resonance.ratio * paramsMapping[2004] / 1000);\r\n            if(newRatio < paramsMapping[2001]) {\r\n                newRatio = paramsMapping[2001];\r\n            }\r\n        }\r\n        if (newRatio > 0) {\r\n            rid ++;\r\n            resonance = resonanceDataMapping[rid];\r\n            resonance.time = uint40(now);\r\n            resonance.ratio = newRatio;\r\n            //Continuous rise\r\n            if(sellMoney > 0) {\r\n                resonance.sellMoney = totalAmount - paramsMapping[2003];\r\n            }\r\n            if(burnMoney > 0) {\r\n                resonance.burnMoney = totalAmount - paramsMapping[2003];\r\n            }\r\n            if(poundageMoney > 0) {\r\n                resonance.poundageMoney = totalAmount - paramsMapping[2003];\r\n            }\r\n            updateRatio(0, 0, 0);\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev update Parent User\r\n     * @param rCode user recommend code\r\n     * @param money invest money\r\n     * @param _type chenag type: 1 add 0 out\r\n     */\r\n\tfunction updateUser_Parent(string memory rCode, uint money, uint8 _type)\r\n        private\r\n    {\r\n\t\tstring memory tmpReferrerCode = rCode;\r\n\t\tfor (uint i = 1; i <= 15; i++) {\r\n\t\t\tif (tmpReferrerCode.compareStr(\"\")) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n            address userAddress = _getCodeMapping(tmpReferrerCode);\r\n            User storage user = userMapping[userAddress];\r\n\r\n            //-----------updateUser_Parent Start\r\n            if (i == 1) {\r\n                if (_type == 1) {\r\n                    user.refEffectiveMans++;\r\n                    user.refEffectiveInvestAmount += money;\r\n                } else if (_type == 0) {\r\n                    user.refEffectiveMans--;\r\n                    user.refEffectiveInvestAmount -= money;\r\n                }\r\n            }\r\n            if (i <= 8) {\r\n                updateUser_Level(user, money, 0, _type);\r\n            } else if (i <= 10) {\r\n                updateUser_Level(user, money, 1, _type);\r\n            } else if (i <= 12) {\r\n                updateUser_Level(user, money, 2, _type);\r\n            } else if (i <= 15) {\r\n                updateUser_Level(user, money, 3, _type);\r\n            }\r\n            //-----------updateUser_Parent End\r\n\r\n            (, , tmpReferrerCode) = _getUserInfo(userAddress);\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev update Parent User\r\n     * @param user user storage\r\n     * @param money invest money\r\n     * @param _indexTeam chenag Team Achievememt:0 (1-8 generations),1 (9-10 generations),2 (11-12 generations),3 (12-15 generations)\r\n     * @param _type chenag type: 1 add 0 out\r\n     */\r\n\tfunction updateUser_Level(User storage user, uint money, uint8 _indexTeam, uint8 _type)\r\n        private\r\n    {\r\n\t\tif (_type == 1) {\r\n            user.teamAchievememt[_indexTeam] += money;\r\n        } else if (_type == 0) {\r\n            user.teamAchievememt[_indexTeam] -= money;\r\n        }\r\n        //check and user teamLevel\r\n        uint8 teamLevel = user.teamLevel;\r\n        if(user.refEffectiveMans >= paramsMapping[5004] \r\n            && user.teamAchievememt[0] + user.teamAchievememt[1] + user.teamAchievememt[2] + user.teamAchievememt[3] >= paramsMapping[5014]\r\n        )\r\n        {\r\n            teamLevel = 4;\r\n        }\r\n        else if(user.refEffectiveMans >= paramsMapping[5003] \r\n            && user.teamAchievememt[0] + user.teamAchievememt[1] + user.teamAchievememt[2] >= paramsMapping[5013]\r\n        )\r\n        {\r\n            teamLevel = 3;\r\n        }\r\n        else if(user.refEffectiveMans >= paramsMapping[5002] \r\n            && user.teamAchievememt[0] + user.teamAchievememt[1] >= paramsMapping[5012]\r\n        )\r\n        {\r\n            teamLevel = 2;\r\n        }\r\n        else if(user.refEffectiveMans >= paramsMapping[5001] \r\n            && user.teamAchievememt[0] >= paramsMapping[5011]\r\n        )\r\n        {\r\n            teamLevel = 1;\r\n        }\r\n        else {\r\n            teamLevel = 0;\r\n        }\r\n\r\n        if (user.teamLevelLockDemotion == 0 && user.teamLevel != teamLevel) {\r\n            user.teamLevel = teamLevel;\r\n        } else if (user.teamLevelLockDemotion == 1 && user.teamLevel <= teamLevel) {\r\n            user.teamLevel = teamLevel;\r\n            user.teamLevelLockDemotion = 0;\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev settlement Static Bonus\r\n     * @param addr user addressr\r\n     * @return bool\r\n     */\r\n    function settlement_Static(address addr)\r\n        private\r\n        returns (bool)\r\n    {\r\n\t\tUser storage user = userMapping[addr];\r\n        // checkUserID(user.id);\r\n\r\n        //reacquire rCode\r\n        string memory rCode;\r\n        uint[4] memory user_data;\r\n        (user_data, , rCode) = _getUserInfo(addr);\r\n        uint user_status = user_data[1];\r\n\r\n        //require(user_status != 1, \"user status is lock(Static)\");\r\n        if (user.investDataIndex == 0 || user_status == 1) {\r\n            return false;\r\n        }\r\n        //-----------Static Start\r\n        InvestData storage investData = user.investData[user.investDataIndex - 1];\r\n        // uint settlementNumber_base = (now - investData.lastRwTime) / SettlementDiffTime;\r\n        uint settlementNumber_base = (now - investData.lastRwTime) / 1 days;\r\n        // if (investData.status == 0 && settlementNumber_base > 0 && (settlementNumber_base == 1 || settlementNumber_base >= 5)) {\r\n        if (investData.status == 0 && settlementNumber_base > 0) {\r\n            //settlement Number limt\r\n            // if(!(settlementNumber_base == 1 || settlementNumber_base >= 5))\r\n            // {\r\n            //     return false;\r\n            // }\r\n            uint moneyBonus_base = investData.money * paramsMapping[4001] / 1000;\r\n            uint settlementNumber = settlementNumber_base;\r\n            uint settlementMaxMoney = 0;\r\n\r\n            if(investData.money * paramsMapping[3010 + investData.level] / 1000 >= investData.adduoStaticBonus + investData.adduoDynamicBonus) {\r\n                settlementMaxMoney = investData.money * paramsMapping[3010 + investData.level] / 1000 - (investData.adduoStaticBonus + investData.adduoDynamicBonus);\r\n            }\r\n            uint moneyBonus = 0;\r\n            if (moneyBonus_base * settlementNumber > settlementMaxMoney) {\r\n                settlementNumber = settlementMaxMoney / moneyBonus_base;\r\n                if (moneyBonus_base * settlementNumber < settlementMaxMoney) {\r\n                    settlementNumber ++;\r\n                }\r\n                if (settlementNumber > settlementNumber_base) {\r\n                    settlementNumber = settlementNumber_base;\r\n                }\r\n                // moneyBonus = moneyBonus_base * settlementNumber;\r\n                moneyBonus = settlementMaxMoney;\r\n            } else {\r\n                moneyBonus = moneyBonus_base * settlementNumber;\r\n            }\r\n\r\n            investData.lastRwTime += uint40(settlementNumber * 1 days);\r\n\r\n            // AwardData storage awData = user.rewardData[0][user.rewardIndex[0]];\r\n            // // awData.amount += moneyBonus;\r\n            // awData.amount += update_CheckInvestOut(user, investData, moneyBonus, 0, rCode);\r\n\r\n            // investData.adduoStaticBonus += moneyBonus;\r\n            // //check out\r\n            // if (investData.adduoStaticBonus + investData.adduoDynamicBonus >= investData.money * paramsMapping[3010 + investData.level] / 1000) {\r\n            //     investData.status = 1;\r\n            //     investData.outTime = uint40(now);\r\n\r\n            //     updateUser_Parent(rCode, investData.money, 0);\r\n\r\n            //     user.investAmountOut += investData.money;\r\n            // }\r\n\r\n            update_CheckInvestOut(user, investData, moneyBonus, 0, rCode);\r\n\r\n            //Calculate the bonus (Daily Dividend)\r\n            countBonus_DailyDividend(rCode, moneyBonus, investData.money);\r\n            //countBonus_DailyDividend(rCode, moneyBonus_base * settlementNumber, investData.money);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n        //-----------Static End\r\n\t}\r\n\r\n    /**\r\n     * @dev Calculate the bonus (Daily Dividend)\r\n     * @param rCode user recommend code\r\n     * @param money base money\r\n     * @param investMoney invest money\r\n     */\r\n\tfunction countBonus_DailyDividend(string memory rCode, uint money, uint investMoney)\r\n        private\r\n    {\r\n        uint baseMoney = money;\r\n\r\n        uint maxLevel_team = 0;\r\n        uint haveTakeScale = 0;\r\n        uint lastLevel_team = 0;\r\n        uint lastlevel_team_baseMoney = 0;\r\n\r\n\t\tstring memory tmpReferrerCode = rCode;\r\n\r\n\t\tfor (uint i = 1; i <= 21; i++) {\r\n\t\t\tif (tmpReferrerCode.compareStr(\"\")) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n            address userAddress = _getCodeMapping(tmpReferrerCode);\r\n\t\t\tUser storage user = userMapping[userAddress];\r\n\r\n            //last rRcode and currUserInfo\r\n            uint[4] memory user_data;\r\n            string memory tmpUser_rCode;\r\n            uint user_status = 0;\r\n            (user_data, , tmpUser_rCode) = _getUserInfo(userAddress);\r\n            user_status = user_data[1];\r\n\r\n\t\t\tInvestData storage investData = user.investData[user.investDataIndex - 1];\r\n\r\n            //-----------share Start\r\n            if(i <= 15 && user.investDataIndex > 0 && investData.status == 0 && user.refEffectiveMans >= i && user_status == 0) {\r\n                uint moneyBonus = baseMoney * getScaleByAlgebra(i) / 1000;\r\n                //burns\r\n                if (investData.money < paramsMapping[6101] && investData.money < investMoney) {\r\n                    moneyBonus = moneyBonus * investData.money / investMoney;\r\n                }\r\n                if (moneyBonus > 0) {\r\n                    update_CheckInvestOut(user, investData, moneyBonus, 1, tmpUser_rCode);\r\n                    // AwardData storage awData_share = user.rewardData[1][user.rewardIndex[1]];\r\n                    // //check out\r\n                    // awData_share.amount += update_CheckInvestOut(user, investData, moneyBonus, 1, tmpUser_rCode);\r\n                    // if (investData.status == 0) {\r\n                    //     investData.adduoDynamicBonus += moneyBonus;\r\n                    //     if (investData.adduoStaticBonus + investData.adduoDynamicBonus >= investData.money * paramsMapping[3010 + investData.level] / 1000) {\r\n                    //         investData.status = 1;\r\n                    //         investData.outTime = uint40(now);\r\n                    //         updateUser_Parent(tmpUser_rCode, investData.money, 0);\r\n\r\n                    //         user.investAmountOut += investData.money;\r\n\r\n                    //         awData_share.amount += investData.money * paramsMapping[3010 + investData.level] / 1000 - (investData.adduoStaticBonus + investData.adduoDynamicBonus);\r\n                    //     } else {\r\n                    //         awData_share.amount += moneyBonus;\r\n                    //     }\r\n                    // }\r\n                }\r\n            }\r\n            //-----------share End\r\n\r\n            //-----------team Start\r\n            uint8 userLevel = getLevelByValidTime(uint8(user_data[2]) ,user.teamLevel, uint8(user_data[3]), paramsMapping[1001], user.teamLevelLockDemotion);\r\n\r\n            if (userLevel >= 1 && userLevel > maxLevel_team) {\r\n                uint moneyBonus = 0;\r\n                uint userLevelScale = getScaleByLevel(userLevel);\r\n                if(userLevelScale > haveTakeScale) {\r\n                    moneyBonus = baseMoney;\r\n                    moneyBonus = moneyBonus * (userLevelScale - haveTakeScale) / 1000;\r\n                    haveTakeScale += (userLevelScale - haveTakeScale);\r\n                }\r\n                if (moneyBonus > 0 && user.investDataIndex > 0 && investData.status == 0 && user_status == 0) {\r\n                    countBonus_AwardData(user, moneyBonus, 2);\r\n                }\r\n                maxLevel_team = userLevel;\r\n                lastLevel_team = userLevel;\r\n                lastlevel_team_baseMoney = moneyBonus;\r\n            } else if (userLevel >= 1 && userLevel == lastLevel_team) {\r\n                //-----------SameLevel Start\r\n                uint moneyBonus = lastlevel_team_baseMoney * paramsMapping[5201] / 1000;\r\n                if (moneyBonus > 0 && user.investDataIndex > 0 && investData.status == 0 && user_status == 0) {\r\n                    countBonus_AwardData(user, moneyBonus, 2);\r\n                }\r\n                lastLevel_team = 0;\r\n                lastlevel_team_baseMoney = 0;\r\n                //-----------SameLevel End\r\n            } else {\r\n                lastLevel_team = 0;\r\n                lastlevel_team_baseMoney = 0;\r\n            }\r\n            //-----------team End           \r\n            tmpReferrerCode = tmpUser_rCode;\r\n\t\t}\r\n\t}\r\n\r\n    /**\r\n     * @dev Update and Check Invest Out (all Bonus)\r\n     * @param user user storage\r\n     * @param investData user investData storage\r\n     * @param bonusAmount Bonus Amount\r\n     * @param bonusType 0static 1dynamic\r\n     * @param rCode user rCode\r\n     */\r\n\tfunction update_CheckInvestOut(User storage user, InvestData storage investData, uint bonusAmount, uint8 bonusType, string memory rCode)\r\n        private\r\n    {\r\n        if (investData.status == 0) {\r\n            if (investData.adduoStaticBonus + investData.adduoDynamicBonus + bonusAmount >= investData.money * paramsMapping[3010 + investData.level] / 1000) {\r\n                investData.status = 1;\r\n                investData.outTime = uint40(now);\r\n                updateUser_Parent(rCode, investData.money, 0);\r\n\r\n                user.investAmountOut += investData.money;\r\n\r\n                bonusAmount = investData.money * paramsMapping[3010 + investData.level] / 1000 - (investData.adduoStaticBonus + investData.adduoDynamicBonus);\r\n            }\r\n            if(bonusType == 0) {\r\n                investData.adduoStaticBonus += bonusAmount;\r\n            } else if(bonusType == 1) {\r\n                investData.adduoDynamicBonus += bonusAmount;\r\n            }\r\n\r\n            countBonus_AwardData(user, bonusAmount, bonusType);\r\n        }\r\n\t}\r\n\r\n    /**\r\n     * @dev settlement AwardData\r\n     * @param addr user addressr\r\n     * @param _type settlement type (0 static, 1 share, 2 team, 3 elite, 4 signIn)\r\n     * @return amount amount\r\n     */\r\n    function settlement_AwardData(address addr, uint8 _type)\r\n        private\r\n        returns (uint amount)\r\n    {\r\n\t\tUser storage user = userMapping[addr];\r\n\r\n        AwardData storage awData = user.rewardData[_type][user.rewardIndex[_type]];\r\n        if(awData.amount > 0) {\r\n            user.rewardIndex[_type] ++;\r\n            awData.time = uint40(now);\r\n            if(_type == 0) {\r\n                user.takeWallet_ETH += awData.amount;\r\n                user.bonusStaticAmount += awData.amount;\r\n            } else if(_type == 1 || _type == 2 || _type == 3) {\r\n                user.takeWallet_ETH += awData.amount;\r\n                user.bonusDynamicAmonut += awData.amount;\r\n            } else if(_type == 4) {\r\n                uint poundageMoney_ETT = awData.amount * paramsMapping[8001] / 1000;\r\n                user.takeWallet_ETT += awData.amount.sub(poundageMoney_ETT);\r\n\r\n                //update Ratio\r\n                updateRatio(0, 0, poundageMoney_ETT);\r\n            }\r\n            amount = awData.amount;\r\n        }\r\n        return amount;\r\n\t}\r\n\r\n    \r\n}"},"browser/Proxy.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\nimport './Contract_Code_v2_Base.sol';\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n    * @dev Fallback function.\r\n    * Implemented entirely in `_fallback`.\r\n    */\r\n    fallback() external payable{\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n    * @return The Address of the implementation.\r\n    */\r\n    function _implementation() internal view virtual returns (address);\r\n\r\n    /**\r\n    * @dev Delegates execution to an implementation contract.\r\n    * This is a low level function that doesn't return to its internal call site.\r\n    * It will return to the external caller whatever the implementation returns.\r\n    * @param implementation Address to delegate.\r\n    */\r\n    function _delegate(address implementation) internal {\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Function that is run as the first thing in the fallback function.\r\n    * Can be redefined in derived contracts to add functionality.\r\n    * Redefinitions must call super._willFallback().\r\n    */\r\n    function _willFallback() internal virtual {\r\n    }\r\n\r\n    /**\r\n    * @dev fallback implementation.\r\n    * Extracted to enable manual triggering.\r\n    */\r\n    function _fallback() internal {\r\n        _willFallback();\r\n        _delegate(_implementation());\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n    using Address for address;\r\n\r\n    /**\r\n    * @dev Emitted when the implementation is upgraded.\r\n    * @param implementation Address of the new implementation.\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n    * @dev Storage slot with the address of the current implementation.\r\n    * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n    * validated in the constructor.\r\n    */\r\n    //bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n    * @dev Returns the current implementation.\r\n    * @return impl Address of the current implementation\r\n    */\r\n    function _implementation() internal view override returns (address impl) {\r\n        bytes32 slot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the proxy to a new implementation.\r\n    * @param newImplementation Address of the new implementation.\r\n    */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the implementation address of the proxy.\r\n    * @param newImplementation Address of the new implementation.\r\n    */\r\n    function _setImplementation(address newImplementation) internal {\r\n        require(newImplementation.isContract(), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n        bytes32 slot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n"}}}