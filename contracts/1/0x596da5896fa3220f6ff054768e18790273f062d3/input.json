{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/tests/DoTxGameContract.sol":{"content":"pragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"https://raw.githubusercontent.com/DefiOfThrones/DOTTokenContract/master/IDotTokenContract.sol\";\r\nimport \"https://raw.githubusercontent.com/DefiOfThrones/DOTTokenContract/master/libs/SafeMath.sol\";\r\n\r\n\r\ninterface IDoTxLib{\r\n    function queryChainLinkPrice(string calldata _fsym, string calldata _fsymId, int256 _multiplicator, bytes4 _selector) external;\r\n    function fetchFirstDayPrices(string calldata firstHouseTicker, string calldata secondHouseTicker, string calldata firstHouseId, string calldata secondHouseId, int256 multiplicator, uint256 warIndex) external;\r\n    function fetchLastDayPrices(string calldata firstHouseTicker, string calldata currentSecondHouseTicker, string calldata firstHouseId, string calldata secondHouseId, int256 multiplicator, uint256 warIndex) external;\r\n    function setDoTxGame(address gameAddress) external;\r\n    function calculateHousePerf(int256 open, int256 close, int256 precision) external pure returns(int256);\r\n    function calculatePercentage(uint256 amount, uint256 percentage, uint256 selecteWinnerPrecision) external pure returns(uint256);\r\n    function calculateReward(uint256 dotxUserBalance, uint256 totalDoTxWinningHouse, uint256 totalDoTxLosingHouse) external view returns(uint256);\r\n    function getWarIndex() external view returns(uint256);\r\n}\r\n\r\ncontract Context {\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address private _owner2;\r\n    address public dotxLibAddress;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    function owner2() public view returns (address) {\r\n        return _owner2;\r\n    }\r\n    \r\n    function setOwner2(address ownerAddress) public onlyOwner {\r\n        _owner2 = ownerAddress;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender() || _owner2 == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwnerOrDoTxLib() {\r\n        require(_owner == _msgSender() || dotxLibAddress == _msgSender() || _owner2 == _msgSender(), \"Ownable: caller is not the owner or the lib\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyDoTxLib() {\r\n        require(dotxLibAddress == _msgSender(), \"Ownable: caller is not the owner or the lib\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title DeFi Of Thrones Game Contract\r\n * @author Maxime Reynders - DefiOfThrones (https://github.com/DefiOfThrones/DOTTokenContract)\r\n */\r\ncontract DoTxGameContract is Ownable {\r\n    using SafeMath for uint256;\r\n    //Burn x% of the losing house tickets to Vitalik Address\r\n    address constant public BURN_ADDRESS = 0x0000000000000000000000000000000000000001;\r\n\r\n    //War struct, for each war a War variable will be created \r\n    struct War {\r\n        uint256 startTime;\r\n        uint256 duration;\r\n        uint256 ticketPrice;\r\n        uint256 purchasePeriod;\r\n        bytes32 winningHouse;\r\n        uint256 warFeesPercent;\r\n        int256 multiplicator;\r\n        uint256 burnPercentage;\r\n        uint256 stakingPercentage;\r\n        House firstHouse;\r\n        House secondHouse;\r\n        mapping(address => User) users;\r\n    }\r\n    //House struct, each war contains an map of 2 houses\r\n    struct House {\r\n        bytes32 houseTicker;\r\n        bytes32 houseId;\r\n        uint256 openPrice;\r\n        uint256 closePrice;\r\n        uint256 ticketsBought;\r\n    }\r\n    //User struct, each war contains a map of users\r\n    //Each user can pledge allegiance to a house, buy tickets and switch house by paying fees (x% of its bought tickets)\r\n    struct User {\r\n        bytes32 houseTicker;\r\n        uint256 ticketsBought;\r\n        bool rewardClaimed;\r\n    }\r\n    \r\n    //BURN STAKING INFORMATION\r\n    struct BurnStake {\r\n        uint256 firstHouseBurnDoTx;\r\n        uint256 firstHouseStakingDoTx;\r\n        uint256 secondHouseBurnDoTx;\r\n        uint256 secondHouseStakingDoTx;\r\n    }\r\n    \r\n    struct WarHouses {\r\n        uint256 index;\r\n        bytes32 firstHouse;\r\n        bytes32 secondHouse;\r\n        uint256 startTime;\r\n        uint256 duration;\r\n    }\r\n    \r\n    //DOTX Token Contract Address\r\n    IDotTokenContract private dotxToken;\r\n    //DOTX Game lib\r\n    IDoTxLib private dotxLib;\r\n    //x% of the losing house tickets are sent to the throne vault\r\n    address stakingAddress = address(0x1c2206f3115CaC3750acCb899d18d50b774C2f21);\r\n    \r\n    //Map of Wars \r\n    mapping(uint256 => War) public wars;\r\n    \r\n    //GENERAL VARS\r\n    //Total fees paid by users\r\n    uint256 public totalFees;\r\n    //Precision for the select winner calculation\r\n    uint256 public selecteWinnerPrecision = 100000;\r\n    \r\n    uint256 public burnPercentage = 5;\r\n    uint256 public stakingPercentage = 5;\r\n    int256 public multiplicator = 10000;\r\n    \r\n    //EVENTS\r\n    event WarStarted(uint256 warIndex);\r\n    event TicketBought(uint256 warIndex, string house, uint256 valueInDoTx, address sender, string txType);\r\n    event ClaimReward(uint256 warIndex, uint256 reward, uint256 balance, address sender, string txType);\r\n    event SwitchHouse(uint256 warIndex, string from, string to, address sender, uint256 valueInDoTx);\r\n    event openPriceFetched(uint256 warIndex);\r\n    event closePriceFetched(uint256 warIndex);\r\n    event StakeBurn(uint256 warIndex, uint256 burnValue, uint256 stakeValue);\r\n\r\n    //MODIFIERS\r\n    modifier onlyIfCurrentWarFinished(uint256 warIndex) {\r\n        require(wars[warIndex].startTime.add(wars[warIndex].duration) <= now || warIndex == 0, \"Current war not finished\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfCurrentWarNotFinished(uint256 warIndex) {\r\n        require(wars[warIndex].startTime.add(wars[warIndex].duration) > now, \"Current war finished\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfTicketsPurchasable(uint256 warIndex) {\r\n        require(now.sub(wars[warIndex].startTime) < wars[warIndex].purchasePeriod,\r\n        \"Purchase tickets period ended\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyIfPricesFetched(uint256 warIndex){\r\n        require(wars[warIndex].firstHouse.openPrice != 0 && wars[warIndex].secondHouse.openPrice != 0, \"Open prices not fetched\");\r\n        require(wars[warIndex].firstHouse.closePrice != 0 && wars[warIndex].secondHouse.closePrice != 0, \"Close prices not fetched\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Game contract constructor\r\n     * Just pass the DoTx token contract address in parameter\r\n     **/\r\n    constructor(address dotxTokenAddress, address dotxLibAddr, bool setupAddressInLib) public {\r\n        //Implement DoTx contract interface by providing address\r\n        dotxToken = IDotTokenContract(dotxTokenAddress);\r\n        \r\n        setDoTxLib(dotxLibAddr, setupAddressInLib);\r\n    }\r\n    \r\n    /**************************\r\n            WAR METHODS\r\n    ***************************/\r\n    \r\n    /**\r\n     * Start a war only if the previous is finished\r\n     * Parameters :\r\n     * _firstHouseTicker First house ticker \r\n     * _secondHouseTicker Second house ticker \r\n     * _duration Duration of the war in seconds \r\n     * _ticketPrice Ticket price : Number of DoTx needed to buy a ticket (in wei precision)\r\n     * purchasePeriod Number of seconds where the users can buy tickets from the starting date\r\n     * _warFeesPercent How many % fees it will cost to user to switch house \r\n     * _warIndex Index of the war in mapping\r\n     **/\r\n    function startWar(string memory _firstHouseTicker, string memory _secondHouseTicker, string memory _firstHouseId, string memory _secondHouseId, \r\n    uint256 _duration, uint256 _ticketPrice, uint256 _purchasePeriod, uint256 _warFeesPercent, uint256 _warIndex) \r\n    public onlyOwner returns(bool) {\r\n        //Just prevent to replace a war\r\n        require(_warIndex > dotxLib.getWarIndex(), \"War index already exists\");\r\n        \r\n        //Create war  \r\n        wars[_warIndex] = War(now, _duration, _ticketPrice, _purchasePeriod, 0, _warFeesPercent, multiplicator, burnPercentage, stakingPercentage, \r\n        House(stringToBytes32(_firstHouseTicker), stringToBytes32(_firstHouseId), 0, 0, 0),\r\n        House(stringToBytes32(_secondHouseTicker), stringToBytes32(_secondHouseId), 0, 0, 0));\r\n        \r\n        emit WarStarted(_warIndex);\r\n        \r\n        fetchFirstDayPrices(_warIndex);\r\n        \r\n        return true;\r\n    }\r\n    \r\n     /**\r\n     * Buy ticket(s) for the current war - only if tickets are purchasable -> purchasePeriod\r\n     * Parameters :\r\n     * _houseTicker House ticker \r\n     * _numberOfTicket The number of tickets the user wants to buy\r\n     **/\r\n    function buyTickets(string memory _houseTicker, uint _numberOfTicket, uint256 warIndex) public onlyIfTicketsPurchasable(warIndex) {\r\n        bytes32 houseTicker = stringToBytes32(_houseTicker);\r\n        //Get house storage\r\n        House storage userHouse = getHouseStg(houseTicker, warIndex);\r\n        \r\n        //Allow user to only buy tickets for one single House and the one passed in parameter\r\n        bytes32 userHouseTicker = wars[warIndex].users[msg.sender].houseTicker;\r\n        require(userHouse.houseTicker == houseTicker && (userHouseTicker == houseTicker || userHouseTicker == 0), \"You can not buy tickets for the other house\");\r\n\r\n        wars[warIndex].users[msg.sender].houseTicker = userHouse.houseTicker;\r\n\r\n        //Update user tickets\r\n        wars[warIndex].users[msg.sender].ticketsBought = wars[warIndex].users[msg.sender].ticketsBought.add(_numberOfTicket);\r\n        \r\n        //Increase tickets bought for the house\r\n        userHouse.ticketsBought = userHouse.ticketsBought.add(_numberOfTicket);\r\n        \r\n        uint256 valueInDoTx = wars[warIndex].ticketPrice.mul(_numberOfTicket);\r\n        \r\n        //Propagate TicketBought event\r\n        emit TicketBought(warIndex, _houseTicker, valueInDoTx, msg.sender, \"BOUGHT\");\r\n        \r\n        //Transfer DoTx\r\n        dotxToken.transferFrom(msg.sender, address(this), valueInDoTx);\r\n    }\r\n    \r\n    /**\r\n     * Switch house for the user - only if tickets are purchasable -> purchasePeriod\r\n     * Parameters :\r\n     * _fromHouseTicker Current house user pledged allegiance \r\n     * _toHouseTicker the house user wants to join\r\n     **/\r\n    function switchHouse(string memory _fromHouseTicker, string memory _toHouseTicker, uint256 warIndex) public onlyIfTicketsPurchasable(warIndex) {\r\n\r\n        bytes32 fromHouseTicker = stringToBytes32(_fromHouseTicker);\r\n        bytes32 toHouseTicker = stringToBytes32(_toHouseTicker);\r\n        \r\n        //Check if toHouse is in competition && different of fromHouse\r\n        require(checkIfHouseInCompetition(toHouseTicker, warIndex) && fromHouseTicker != toHouseTicker, \"House not in competition\");\r\n        //Check if user belongs to _fromHouse \r\n        require(wars[warIndex].users[msg.sender].houseTicker == fromHouseTicker, \"User doesn't belong to fromHouse\");\r\n        \r\n        House storage fromHouse = getHouseStg(fromHouseTicker, warIndex);\r\n        House storage toHouse = getHouseStg(toHouseTicker, warIndex);\r\n        \r\n        //Switch house for user\r\n        wars[warIndex].users[msg.sender].houseTicker = toHouseTicker;\r\n        \r\n        //Update fromHouse tickets\r\n        uint256 ticketsBoughtByUser = wars[warIndex].users[msg.sender].ticketsBought;\r\n        fromHouse.ticketsBought = fromHouse.ticketsBought.sub(ticketsBoughtByUser);\r\n        \r\n        //Update toHouse tickets\r\n        toHouse.ticketsBought = toHouse.ticketsBought.add(ticketsBoughtByUser);\r\n        \r\n        //Get fees\r\n        uint256 feesToBePaid = getFeesForSwitchHouse(msg.sender, warIndex);\r\n        //Update total fees\r\n        totalFees = totalFees.add(feesToBePaid);\r\n        \r\n        emit SwitchHouse(warIndex, _fromHouseTicker, _toHouseTicker, msg.sender, feesToBePaid);\r\n        \r\n        //Get fees from user wallet\r\n        dotxToken.transferFrom(msg.sender, address(this), feesToBePaid);\r\n    }\r\n    \r\n    /**\r\n     * Allow users who pledged allegiance to the winning house to claim bought tickets + reward\r\n     * Parameters :\r\n     **/\r\n    function claimRewardAndTickets(uint256 warIndex) public onlyIfCurrentWarFinished(warIndex) returns(bool) {\r\n        //Only claim reward one times\r\n        require(wars[warIndex].users[msg.sender].rewardClaimed == false, \"You already claimed your reward\");\r\n        \r\n        //Check if user belongs to winning house\r\n        require(wars[warIndex].users[msg.sender].ticketsBought > 0 && wars[warIndex].users[msg.sender].houseTicker == wars[warIndex].winningHouse, \"User doesn't belong to winning house\");\r\n        \r\n        //Set rewardClaimed to true\r\n        wars[warIndex].users[msg.sender].rewardClaimed = true;\r\n        \r\n        //DoTx in user balance (tickets bought) & reward\r\n        uint256 reward = getCurrentReward(wars[warIndex].winningHouse, msg.sender, warIndex);\r\n        uint256 balance = getUserDoTxInBalance(warIndex, msg.sender);\r\n        \r\n        dotxToken.transfer(msg.sender, reward.add(balance));\r\n        \r\n        emit ClaimReward(warIndex, reward, balance, msg.sender, \"CLAIM\");\r\n    }\r\n\r\n    \r\n    /*****************************\r\n            PRICES METHODS\r\n    ******************************/\r\n    \r\n    /**\r\n     * Fetch the prices for the 2 houses the first day for the current war\r\n     **/\r\n    function fetchFirstDayPrices(uint256 warIndex) public onlyOwner {\r\n        require(wars[warIndex].firstHouse.openPrice == 0 && wars[warIndex].secondHouse.openPrice == 0, \"Open prices already fetched\");\r\n        \r\n        string memory firstHouse = bytes32ToString(wars[warIndex].firstHouse.houseTicker);\r\n        string memory secondHouse = bytes32ToString(wars[warIndex].secondHouse.houseTicker);\r\n        \r\n        dotxLib.fetchFirstDayPrices(firstHouse, secondHouse, bytes32ToString(wars[warIndex].firstHouse.houseId), bytes32ToString(wars[warIndex].secondHouse.houseId), wars[warIndex].multiplicator, warIndex);\r\n    }\r\n\r\n    /**\r\n     * Fetch the prices for the 2 houses the last day for the current war\r\n     **/\r\n    function fetchLastDayPrices(uint256 warIndex) public onlyOwner onlyIfCurrentWarFinished(warIndex) {\r\n        require(wars[warIndex].firstHouse.closePrice == 0 && wars[warIndex].secondHouse.closePrice == 0, \"Close prices already fetched\");\r\n        \r\n        string memory firstHouse = bytes32ToString(wars[warIndex].firstHouse.houseTicker);\r\n        string memory secondHouse = bytes32ToString(wars[warIndex].secondHouse.houseTicker);\r\n        \r\n        dotxLib.fetchLastDayPrices(firstHouse, secondHouse, bytes32ToString(wars[warIndex].firstHouse.houseId), bytes32ToString(wars[warIndex].secondHouse.houseId), wars[warIndex].multiplicator, warIndex);\r\n    }\r\n    \r\n    /**\r\n     * Elect the winner based on open prices & close prices\r\n     **/\r\n    function selectWinner(uint256 warIndex) public onlyOwner onlyIfCurrentWarFinished(warIndex) onlyIfPricesFetched(warIndex) {\r\n        require(wars[warIndex].winningHouse == 0, \"Winner already selected\");\r\n        \r\n        int256 precision = int256(selecteWinnerPrecision);\r\n        \r\n        int256 firstHousePerf =  dotxLib.calculateHousePerf(int256(wars[warIndex].firstHouse.openPrice), int256(wars[warIndex].firstHouse.closePrice), precision);\r\n        int256 secondHousePerf = dotxLib.calculateHousePerf(int256(wars[warIndex].secondHouse.openPrice), int256(wars[warIndex].secondHouse.closePrice), precision);\r\n        \r\n        //Set winner house\r\n        wars[warIndex].winningHouse = (firstHousePerf > secondHousePerf ? wars[warIndex].firstHouse : wars[warIndex].secondHouse).houseTicker;\r\n        House memory losingHouse = (firstHousePerf > secondHousePerf ? wars[warIndex].secondHouse : wars[warIndex].firstHouse);\r\n        \r\n        /*\r\n        BURN X% OF LOSING HOUSE'S DOTX\r\n        */\r\n        uint256 burnValue = calculateBurnStaking(losingHouse, true, warIndex);\r\n        dotxToken.transfer(BURN_ADDRESS, burnValue);\r\n        \r\n        /*\r\n        SEND X% OF LOSING HOUSE'S DOTX TO STAKING ADDRESS\r\n        */\r\n        uint256 stakingValue = calculateBurnStaking(losingHouse, true, warIndex);\r\n        dotxToken.transfer(stakingAddress, stakingValue);\r\n        \r\n        emit StakeBurn(warIndex, burnValue, stakingValue);\r\n    }\r\n\r\n    \r\n    /*******************************\r\n            CHAINLINK METHODS\r\n    ********************************/\r\n    \r\n    /**\r\n     * Handler method called by Chainlink for the first house open price \r\n     **/\r\n    function firstHouseOpen(uint256 _price, uint256 warIndex) external onlyDoTxLib {\r\n        wars[warIndex].firstHouse.openPrice = _price;\r\n        openPriceEvent(warIndex);\r\n    }\r\n    /**\r\n     * Handler method called by Chainlink for the second house open price \r\n     **/\r\n    function secondHouseOpen(uint256 _price, uint256 warIndex) external onlyDoTxLib {\r\n        wars[warIndex].secondHouse.openPrice = _price;\r\n        openPriceEvent(warIndex);\r\n    }\r\n    /**\r\n     * Handler method called by Chainlink for the first house close price \r\n     **/\r\n    function firstHouseClose(uint256 _price, uint256 warIndex) external onlyDoTxLib {\r\n        wars[warIndex].firstHouse.closePrice = _price;\r\n        closePriceEvent(warIndex);\r\n    }\r\n    /**\r\n     * Handler method called by Chainlink for the second house close price \r\n     **/\r\n    function secondHouseClose(uint256 _price, uint256 warIndex) external onlyDoTxLib {\r\n        wars[warIndex].secondHouse.closePrice = _price;\r\n        closePriceEvent(warIndex);\r\n    }\r\n    /**\r\n     * Emit openPriceFetched event if needed\r\n     **/\r\n    function openPriceEvent(uint256 warIndex) private {\r\n        if(wars[warIndex].firstHouse.openPrice != 0 && wars[warIndex].secondHouse.openPrice != 0){\r\n            emit openPriceFetched(warIndex);\r\n        }\r\n    }\r\n    /**\r\n     * Emit closePriceFetched event if needed\r\n     **/\r\n    function closePriceEvent(uint256 warIndex) private {\r\n        if(wars[warIndex].firstHouse.closePrice != 0 && wars[warIndex].secondHouse.closePrice != 0){\r\n            emit closePriceFetched(warIndex);\r\n        }\r\n    }\r\n    \r\n    /*****************************\r\n            GETTER METHODS\r\n    ******************************/\r\n    \r\n    /**\r\n     * Get user (ticketsBought * ticketPrice) - user fees\r\n     **/\r\n    function getUserDoTxInBalance(uint256 _warIndex, address userAddress) public view returns(uint256){\r\n        return wars[_warIndex].users[userAddress].ticketsBought.mul(wars[_warIndex].ticketPrice);\r\n    }\r\n    \r\n    \r\n    function getFeesForSwitchHouse(address userAddress, uint256 warIndex) public view returns(uint256){\r\n        return (getUserDoTxInBalance(warIndex, userAddress).mul(wars[warIndex].warFeesPercent)).div(100);\r\n    }\r\n    \r\n    /**\r\n     * Returns the current user\r\n     **/\r\n    function getUser(uint256 _warIndex, address userAddress) public view returns(User memory){\r\n        return wars[_warIndex].users[userAddress];\r\n    }\r\n    \r\n    /**\r\n     * Return house for a specific war\r\n     **/\r\n    function getHouse(uint256 _warIndex, string memory houseTicker) public view returns(House memory){\r\n        bytes32 ticker = stringToBytes32(houseTicker);\r\n        return wars[_warIndex].firstHouse.houseTicker == ticker ? wars[_warIndex].firstHouse : wars[_warIndex].secondHouse;\r\n    }\r\n    /**\r\n     * Return burn stake information\r\n     **/\r\n    function getBurnStake(uint256 warIndex) public view returns(BurnStake memory){\r\n        return BurnStake(calculateBurnStaking(wars[warIndex].firstHouse, true, warIndex), calculateBurnStaking(wars[warIndex].firstHouse, false, warIndex),\r\n        calculateBurnStaking(wars[warIndex].secondHouse, true, warIndex), calculateBurnStaking(wars[warIndex].secondHouse, false, warIndex));\r\n    }\r\n    \r\n    function getWarsHouses(uint256 min, uint256 max) public view returns (WarHouses[20] memory){\r\n        WarHouses[20] memory houses;\r\n        uint256 i = min;\r\n        uint256 index = 0;\r\n        while(index < 20 && i <= (max - min) + 1){\r\n            houses[index] = (WarHouses(i, wars[i].firstHouse.houseTicker, wars[i].secondHouse.houseTicker, wars[i].startTime, wars[i].duration));\r\n            i++;\r\n            index++;\r\n        }\r\n        return houses;\r\n    }\r\n    /*****************************\r\n            ADMIN METHODS\r\n    ******************************/\r\n    \r\n    /**\r\n     * Set the select winner precision used for calculate the best house's performance\r\n     **/\r\n    function setSelectWinnerPrecision(uint256 _precision) public onlyOwner{\r\n        selecteWinnerPrecision = _precision;\r\n    }\r\n\r\n     /**\r\n     * Set staking % of the losing house's DoTx to send for the currentWar\r\n     **/\r\n    function setStakingBurnPercentageWar(uint256 _burnPercentage, uint256 _stakingPercentage, uint256 warIndex) public onlyOwner{\r\n        wars[warIndex].burnPercentage = _burnPercentage;\r\n        wars[warIndex].stakingPercentage = _stakingPercentage;\r\n    }\r\n    \r\n    /**\r\n     * Set staking % of the losing house's DoTx to send\r\n     **/\r\n    function setStakingBurnPercentage(uint256 _burnPercentage, uint256 _stakingPercentage) public onlyOwner{\r\n        burnPercentage = _burnPercentage;\r\n        stakingPercentage = _stakingPercentage;\r\n    }\r\n    \r\n    /**\r\n     * Precision of the prices receive from WS\r\n     **/\r\n    function setMultiplicatorWar(int256 _multiplicator, uint256 warIndex) public onlyOwner{\r\n        wars[warIndex].multiplicator = _multiplicator;\r\n    }\r\n    \r\n    /**\r\n     * Precision of the prices receive from WS\r\n     **/\r\n    function setMultiplicator(int256 _multiplicator) public onlyOwner{\r\n        multiplicator = _multiplicator;\r\n    }\r\n    \r\n    /**\r\n     * Let owner withdraw DoTx fees (in particular to pay the costs generated by Chainlink)\r\n     **/\r\n    function withdrawFees() public onlyOwner {\r\n        //Fees from switch house\r\n        dotxToken.transfer(owner(), totalFees);\r\n        \r\n        totalFees = 0;\r\n    }\r\n    \r\n    /**\r\n     * Let owner set the DoTxLib address\r\n     **/\r\n    function setDoTxLib(address dotxLibAddr, bool setupAddressInLib) public onlyOwner {\r\n        //DOTX lib mainly uses for Chainlink\r\n        dotxLibAddress = dotxLibAddr;\r\n        dotxLib = IDoTxLib(dotxLibAddress);\r\n        if(setupAddressInLib){\r\n            dotxLib.setDoTxGame(address(this));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Let owner update stakingAddress\r\n     **/\r\n    function setStakingAddress(address stakingAdr) public onlyOwner {\r\n        stakingAddress = stakingAdr;\r\n    }\r\n\r\n    /****************************\r\n            UTILS METHODS\r\n    *****************************/\r\n    \r\n    function getHouseStg(bytes32 ticker, uint256 warIndex) private view returns(House storage){\r\n        return wars[warIndex].firstHouse.houseTicker == ticker ? wars[warIndex].firstHouse : wars[warIndex].secondHouse;\r\n    }\r\n    \r\n    /**\r\n     * Check if the house passed in parameter is in the current war\r\n     **/\r\n    function checkIfHouseInCompetition(bytes32 _houseTicker, uint256 warIndex) private view returns(bool){\r\n        return wars[warIndex].firstHouse.houseTicker == _houseTicker || wars[warIndex].secondHouse.houseTicker == _houseTicker;\r\n    }\r\n    \r\n    /**\r\n     * Calculate the reward for the current user\r\n     **/\r\n    function getCurrentRewardString(string memory _winningHouse, address userAddress, uint256 warIndex) public view returns(uint256){\r\n        bytes32 winningHouseTicker = stringToBytes32(_winningHouse);\r\n        return getCurrentReward(winningHouseTicker, userAddress, warIndex);\r\n    } \r\n    \r\n    function getCurrentReward(bytes32 _winningHouse, address userAddress, uint256 warIndex) public view returns(uint256){\r\n        //Losing house\r\n        House memory losingHouse = wars[warIndex].firstHouse.houseTicker == _winningHouse ? wars[warIndex].secondHouse : wars[warIndex].firstHouse;\r\n        \r\n        //Total DoTx in house's balance\r\n        uint256 totalDoTxWinningHouse = getHouseStg(_winningHouse, warIndex).ticketsBought.mul(wars[warIndex].ticketPrice);\r\n        uint256 totalDoTxLosingHouse = losingHouse.ticketsBought.mul(wars[warIndex].ticketPrice).sub(calculateBurnStaking(losingHouse, true, warIndex)).sub(calculateBurnStaking(losingHouse, false, warIndex));\r\n        \r\n        return dotxLib.calculateReward(getUserDoTxInBalance(warIndex, userAddress), totalDoTxWinningHouse, totalDoTxLosingHouse);\r\n    }\r\n    \r\n    function calculateBurnStaking(House memory house, bool isBurn, uint256 warIndex) public view returns(uint256){\r\n        uint256 ticketsBoughtValueDoTx = house.ticketsBought.mul(wars[warIndex].ticketPrice);\r\n        uint256 percentage =  isBurn ? wars[warIndex].burnPercentage : wars[warIndex].stakingPercentage;\r\n        //Calculate tickets remaining after burn\r\n        return dotxLib.calculatePercentage(ticketsBoughtValueDoTx, percentage, selecteWinnerPrecision);\r\n    }\r\n    \r\n    /**\r\n     * Convert string to bytes32\r\n     **/\r\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n    \r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Convert bytes32 to string\r\n     **/\r\n    function bytes32ToString(bytes32 x) public pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}"},"https://raw.githubusercontent.com/DefiOfThrones/DOTTokenContract/master/IDotTokenContract.sol":{"content":"\npragma solidity 0.6.12;\n\ninterface IDotTokenContract{\n  function balanceOf(address account) external view returns (uint256);\n  function totalSupply() external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n}"},"https://raw.githubusercontent.com/DefiOfThrones/DOTTokenContract/master/libs/SafeMath.sol":{"content":"pragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}}