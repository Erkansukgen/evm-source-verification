{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Cycle.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\nimport \"./IGroupSchema.sol\";\r\nimport \"./StorageOwners.sol\";\r\nimport \"./SafeMath.sol\";\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Cycles is IGroupSchema, StorageOwners {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // list of Group Cycles\r\n    Cycle[] Cycles;\r\n    CycleFinancial[] private CycleFinancials;\r\n    \r\n    \r\n    \r\n\r\n    //Mapping that enables ease of traversal of the cycle records. Key is cycle id\r\n    mapping(uint256 => RecordIndex) private CycleIndexer;\r\n\r\n    //Mapping that enables ease of traversal of cycle records by the group. key is group id\r\n    mapping(uint256 => RecordIndex[]) private GroupCycleIndexer;\r\n\r\n    //Mapping that enables ease of traversal of the cycle financials records. Key is cycle id\r\n    mapping(uint256 => RecordIndex) private CycleFinancialsIndexer;\r\n\r\n    //Mapping that enables ease of traversal of cycle financials records by the group. key is group id\r\n    mapping(uint256 => RecordIndex[]) private GroupCycleFinancialsIndexer;\r\n\r\n    CycleMember[] private CycleMembers;\r\n\r\n    //Mapping of a cycle members. key is the cycle id\r\n    mapping(uint256 => RecordIndex[]) private CycleMembersIndexer;\r\n    //Mapping of a cycle members, key is depositor address\r\n    mapping(address => RecordIndex[]) private CycleMembersIndexerByDepositor;\r\n    //Mapping that enables easy traversal of cycle members in a group. outer key is the cycle id, inner key is the member address\r\n    mapping(uint256 => mapping(address => RecordIndex))\r\n        private CycleMembersDeepIndexer;\r\n\r\n    uint256 lastCycleId;\r\n\r\n    function getCycleInfoByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 id,\r\n            uint256 groupId,\r\n            uint256 numberOfDepositors,\r\n            uint256 cycleStartTimeStamp,\r\n            uint256 cycleDuration,\r\n            uint256 maximumSlots,\r\n            bool hasMaximumSlots,\r\n            uint256 cycleStakeAmount,\r\n            uint256 totalStakes,\r\n            uint256 stakesClaimed,\r\n            CycleStatus cycleStatus,\r\n            uint256 stakesClaimedBeforeMaturity\r\n        )\r\n    {\r\n        Cycle memory cycle = Cycles[index];\r\n\r\n        return (\r\n            cycle.id,\r\n            cycle.groupId,\r\n            cycle.numberOfDepositors,\r\n            cycle.cycleStartTimeStamp,\r\n            cycle.cycleDuration,\r\n            cycle.maximumSlots,\r\n            cycle.hasMaximumSlots,\r\n            cycle.cycleStakeAmount,\r\n            cycle.totalStakes,\r\n            cycle.stakesClaimed,\r\n            cycle.cycleStatus,\r\n            cycle.stakesClaimedBeforeMaturity\r\n        );\r\n    }\r\n\r\n    function getCycleInfoById(uint256 cycleId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 id,\r\n            uint256 groupId,\r\n            uint256 numberOfDepositors,\r\n            uint256 cycleStartTimeStamp,\r\n            uint256 cycleDuration,\r\n            uint256 maximumSlots,\r\n            bool hasMaximumSlots,\r\n            uint256 cycleStakeAmount,\r\n            uint256 totalStakes,\r\n            uint256 stakesClaimed,\r\n            CycleStatus cycleStatus,\r\n            uint256 stakesClaimedBeforeMaturity\r\n        )\r\n    {\r\n        uint256 index = _getCycleIndex(cycleId);\r\n\r\n        Cycle memory cycle = Cycles[index];\r\n\r\n        return (\r\n            cycle.id,\r\n            cycle.groupId,\r\n            cycle.numberOfDepositors,\r\n            cycle.cycleStartTimeStamp,\r\n            cycle.cycleDuration,\r\n            cycle.maximumSlots,\r\n            cycle.hasMaximumSlots,\r\n            cycle.cycleStakeAmount,\r\n            cycle.totalStakes,\r\n            cycle.stakesClaimed,\r\n            cycle.cycleStatus,\r\n            cycle.stakesClaimedBeforeMaturity\r\n        );\r\n    }\r\n    \r\n    function getCycles() external view returns (Cycle [] memory) {\r\n        return Cycles;\r\n    }\r\n    \r\n    function getCycleMember() external view returns (CycleMember [] memory) {\r\n        return CycleMembers;\r\n    }\r\n\r\n    function getCycleFinancialsByIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 cycleId,\r\n            uint256 underlyingTotalDeposits,\r\n            uint256 underlyingTotalWithdrawn,\r\n            uint256 underlyingBalance,\r\n            uint256 derivativeBalance,\r\n            uint256 underylingBalanceClaimedBeforeMaturity,\r\n            uint256 derivativeBalanceClaimedBeforeMaturity\r\n        )\r\n    {\r\n        CycleFinancial memory cycleFinancial = CycleFinancials[index];\r\n\r\n        return (\r\n            cycleFinancial.cycleId,\r\n            cycleFinancial.underlyingTotalDeposits,\r\n            cycleFinancial.underlyingTotalWithdrawn,\r\n            cycleFinancial.underlyingBalance,\r\n            cycleFinancial.derivativeBalance,\r\n            cycleFinancial.underylingBalanceClaimedBeforeMaturity,\r\n            cycleFinancial.derivativeBalanceClaimedBeforeMaturity\r\n        );\r\n    }\r\n\r\n    function getCycleFinancialsByCycleId(uint256 cycleId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 underlyingTotalDeposits,\r\n            uint256 underlyingTotalWithdrawn,\r\n            uint256 underlyingBalance,\r\n            uint256 derivativeBalance,\r\n            uint256 underylingBalanceClaimedBeforeMaturity,\r\n            uint256 derivativeBalanceClaimedBeforeMaturity\r\n        )\r\n    {\r\n        uint256 index = _getCycleFinancialIndex(cycleId);\r\n        CycleFinancial memory cycleFinancial = CycleFinancials[index];\r\n\r\n        return (\r\n            cycleFinancial.underlyingTotalDeposits,\r\n            cycleFinancial.underlyingTotalWithdrawn,\r\n            cycleFinancial.underlyingBalance,\r\n            cycleFinancial.derivativeBalance,\r\n            cycleFinancial.underylingBalanceClaimedBeforeMaturity,\r\n            cycleFinancial.derivativeBalanceClaimedBeforeMaturity\r\n        );\r\n    }\r\n\r\n    function getCycleMembersLength() external view returns (uint256) {\r\n        return CycleMembers.length;\r\n    }\r\n\r\n    function getCycleMember(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 cycleId,\r\n            uint256 groupId,\r\n            address payable _address,\r\n            uint256 totalLiquidityAsPenalty,\r\n            uint256 numberOfCycleStakes,\r\n            uint256 stakesClaimed,\r\n            bool hasWithdrawn\r\n        )\r\n    {\r\n        CycleMember memory cycleMember = _getCycleMember(index);\r\n\r\n        return (\r\n            cycleMember.cycleId,\r\n            cycleMember.groupId,\r\n            cycleMember._address,\r\n            cycleMember.totalLiquidityAsPenalty,\r\n            cycleMember.numberOfCycleStakes,\r\n            cycleMember.stakesClaimed,\r\n            cycleMember.hasWithdrawn\r\n        );\r\n    }\r\n\r\n    function createCycleMember(\r\n        uint256 cycleId,\r\n        uint256 groupId,\r\n        address payable depositor,\r\n        uint256 totalLiquidityAsPenalty,\r\n        uint256 numberOfCycleStakes,\r\n        uint256 stakesClaimed,\r\n        bool hasWithdrawn\r\n    ) external onlyStorageOracle {\r\n        bool exist = _doesCycleMemberExist(cycleId, depositor);\r\n        require(exist == false, \"Cycle member already exist\");\r\n\r\n        CycleMember memory cycleMember = CycleMember(\r\n            true,\r\n            cycleId,\r\n            groupId,\r\n            depositor,\r\n            totalLiquidityAsPenalty,\r\n            numberOfCycleStakes,\r\n            stakesClaimed,\r\n            hasWithdrawn\r\n        );\r\n\r\n        uint256 index = CycleMembers.length;\r\n\r\n        RecordIndex memory recordIndex = RecordIndex(true, index);\r\n\r\n        CycleMembers.push(cycleMember);\r\n        CycleMembersIndexer[cycleId].push(recordIndex);\r\n        CycleMembersIndexerByDepositor[depositor].push(recordIndex);\r\n\r\n        CycleMembersDeepIndexer[cycleId][depositor] = recordIndex;\r\n    }\r\n\r\n    function updateCycleMember(\r\n        uint256 cycleId,\r\n        address payable depositor,\r\n        uint256 totalLiquidityAsPenalty,\r\n        uint256 numberOfCycleStakes,\r\n        uint256 stakesClaimed,\r\n        bool hasWithdrawn\r\n    ) external {\r\n        CycleMember memory cycleMember = _getCycleMember(cycleId, depositor);\r\n        cycleMember._address = depositor;\r\n        cycleMember.totalLiquidityAsPenalty = totalLiquidityAsPenalty;\r\n        cycleMember.numberOfCycleStakes = numberOfCycleStakes;\r\n        cycleMember.stakesClaimed = stakesClaimed;\r\n        cycleMember.hasWithdrawn = hasWithdrawn;\r\n\r\n        _updateCycleMember(cycleMember);\r\n    }\r\n\r\n    function getCyclesLength() external view returns (uint256) {\r\n        return Cycles.length;\r\n    }\r\n\r\n    function createCycle(\r\n        uint256 groupId,\r\n        uint256 numberOfDepositors,\r\n        uint256 startTimeStamp,\r\n        uint256 duration,\r\n        uint256 maximumSlots,\r\n        bool hasMaximumSlots,\r\n        uint256 cycleStakeAmount,\r\n        uint256 totalStakes,\r\n        uint256 stakesClaimed,\r\n        CycleStatus cycleStatus,\r\n        uint256 stakesClaimedBeforeMaturity\r\n    ) external onlyStorageOracle returns (uint256) {\r\n        lastCycleId  = lastCycleId.add(1);\r\n        Cycle memory cycle = Cycle(\r\n            true,\r\n            lastCycleId,\r\n            groupId,\r\n            numberOfDepositors,\r\n            startTimeStamp,\r\n            duration,\r\n            maximumSlots,\r\n            hasMaximumSlots,\r\n            cycleStakeAmount,\r\n            totalStakes,\r\n            stakesClaimed,\r\n            cycleStatus,\r\n            stakesClaimedBeforeMaturity\r\n        );\r\n\r\n        uint256 index = Cycles.length;\r\n        RecordIndex memory recordIndex = RecordIndex(true, index);\r\n\r\n        Cycles.push(cycle);\r\n        CycleIndexer[lastCycleId] = recordIndex;\r\n        GroupCycleIndexer[cycle.groupId].push(recordIndex);\r\n        return lastCycleId;\r\n    }\r\n\r\n    function createCycleFinancials(\r\n        uint256 cycleId,\r\n        uint256 groupId,\r\n        uint256 underlyingTotalDeposits,\r\n        uint256 underlyingTotalWithdrawn,\r\n        uint256 underlyingBalance,\r\n        uint256 derivativeBalance,\r\n        uint256 underylingBalanceClaimedBeforeMaturity,\r\n        uint256 derivativeBalanceClaimedBeforeMaturity\r\n    ) external onlyStorageOracle {\r\n        RecordIndex memory recordIndex = CycleIndexer[cycleId];\r\n        require(recordIndex.exists == true, \"Cycle not found\");\r\n        CycleFinancial memory cycleFinancial = CycleFinancial(\r\n            true,\r\n            cycleId,\r\n            underlyingTotalDeposits,\r\n            underlyingTotalWithdrawn,\r\n            underlyingBalance,\r\n            derivativeBalance,\r\n            underylingBalanceClaimedBeforeMaturity,\r\n            derivativeBalanceClaimedBeforeMaturity\r\n        );\r\n        CycleFinancials.push(cycleFinancial);\r\n        CycleFinancialsIndexer[cycleId] = recordIndex;\r\n        GroupCycleFinancialsIndexer[groupId].push(recordIndex);\r\n    }\r\n\r\n    function updateCycle(\r\n        uint256 cycleId,\r\n        uint256 numberOfDepositors,\r\n        uint256 startTimeStamp,\r\n        uint256 duration,\r\n        uint256 maximumSlots,\r\n        bool hasMaximumSlots,\r\n        uint256 cycleStakeAmount,\r\n        uint256 totalStakes,\r\n        uint256 stakesClaimed,\r\n        CycleStatus cycleStatus,\r\n        uint256 stakesClaimedBeforeMaturity\r\n    ) external onlyStorageOracle {\r\n        Cycle memory cycle = _getCycle(cycleId);\r\n        cycle.numberOfDepositors = numberOfDepositors;\r\n        cycle.cycleStartTimeStamp = startTimeStamp;\r\n        cycle.cycleDuration = duration;\r\n        cycle.maximumSlots = maximumSlots;\r\n        cycle.hasMaximumSlots = hasMaximumSlots;\r\n        cycle.cycleStakeAmount = cycleStakeAmount;\r\n\r\n        cycle.totalStakes = totalStakes;\r\n        cycle.stakesClaimed = stakesClaimed;\r\n        cycle.cycleStatus = cycleStatus;\r\n        cycle.stakesClaimedBeforeMaturity = stakesClaimedBeforeMaturity;\r\n\r\n        _updateCycle(cycle);\r\n    }\r\n\r\n    function updateCycleFinancials(\r\n        uint256 cycleId,\r\n        uint256 underlyingTotalDeposits,\r\n        uint256 underlyingTotalWithdrawn,\r\n        uint256 underlyingBalance,\r\n        uint256 derivativeBalance,\r\n        uint256 underylingBalanceClaimedBeforeMaturity,\r\n        uint256 derivativeBalanceClaimedBeforeMaturity\r\n    ) external onlyStorageOracle {\r\n        uint256 index = _getCycleFinancialIndex(cycleId);\r\n\r\n        CycleFinancial memory cycleFinancial = CycleFinancials[index];\r\n        cycleFinancial.underlyingTotalDeposits = underlyingTotalDeposits;\r\n        cycleFinancial.underlyingTotalWithdrawn = underlyingTotalWithdrawn;\r\n        cycleFinancial.underlyingBalance = underlyingBalance;\r\n        cycleFinancial.derivativeBalance = derivativeBalance;\r\n        cycleFinancial\r\n            .underylingBalanceClaimedBeforeMaturity = underylingBalanceClaimedBeforeMaturity;\r\n        cycleFinancial\r\n            .derivativeBalanceClaimedBeforeMaturity = derivativeBalanceClaimedBeforeMaturity;\r\n        _updateCycleFinancial(cycleFinancial);\r\n    }\r\n\r\n    function getCycleIndex(uint256 cycleId) external view returns (uint256) {\r\n        uint256 index = _getCycleIndex(cycleId);\r\n        return index;\r\n    }\r\n\r\n    function getCycleFinancialIndex(uint256 cycleId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 index = _getCycleFinancialIndex(cycleId);\r\n        return index;\r\n    }\r\n\r\n    function _getCycleIndex(uint256 cycleId) internal view returns (uint256) {\r\n        bool doesCycleExist = CycleIndexer[cycleId].exists;\r\n        require(doesCycleExist == true, \"Cycle not found\");\r\n\r\n        uint256 index = CycleIndexer[cycleId].index;\r\n        return index;\r\n    }\r\n\r\n    function getRecordIndexForCycleMembersIndexerByDepositor(\r\n        uint256 cycleId,\r\n        uint256 recordIndexLocation\r\n    ) external view returns (bool, uint256) {\r\n\r\n            RecordIndex memory recordIndex\r\n         = CycleMembersIndexer[cycleId][recordIndexLocation];\r\n        return (recordIndex.exists, recordIndex.index);\r\n    }\r\n\r\n    function getRecordIndexForCycleMembersIndexer(\r\n        address depositorAddress,\r\n        uint256 recordIndexLocation\r\n    ) external view returns (bool, uint256) {\r\n\r\n            RecordIndex memory recordIndex\r\n         = CycleMembersIndexerByDepositor[depositorAddress][recordIndexLocation];\r\n        return (recordIndex.exists, recordIndex.index);\r\n    }\r\n\r\n    function getRecordIndexLengthForCycleMembers(uint256 cycleId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return CycleMembersIndexer[cycleId].length;\r\n    }\r\n\r\n    function getRecordIndexLengthForGroupCycleIndexer(uint256 groupId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GroupCycleIndexer[groupId].length;\r\n    }\r\n\r\n    function getRecordIndexForGroupCycle(\r\n        uint256 groupId,\r\n        uint256 recordIndexLocation\r\n    ) external view returns (bool, uint256) {\r\n\r\n            RecordIndex memory recordIndex\r\n         = GroupCycleIndexer[groupId][recordIndexLocation];\r\n        return (recordIndex.exists, recordIndex.index);\r\n    }\r\n\r\n    function getRecordIndexLengthForCycleMembersByDepositor(\r\n        address depositorAddress\r\n    ) external view returns (uint256) {\r\n        return CycleMembersIndexerByDepositor[depositorAddress].length;\r\n    }\r\n\r\n    function getCycleMemberIndex(uint256 cycleId, address payable memberAddress)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _getCycleMemberIndex(cycleId, memberAddress);\r\n    }\r\n    \r\n    \r\n\r\n    function _getCycleMember(uint256 cycleId, address payable depositor)\r\n        internal\r\n        view\r\n        returns (CycleMember memory)\r\n    {\r\n        uint256 index = _getCycleMemberIndex(cycleId, depositor);\r\n        CycleMember memory cycleMember = _getCycleMember(index);\r\n        return cycleMember;\r\n    }\r\n\r\n    function _getCycleMember(uint256 index)\r\n        internal\r\n        view\r\n        returns (CycleMember memory)\r\n    {\r\n        return CycleMembers[index];\r\n    }\r\n\r\n    function _getCycleMemberIndex(uint256 cycleId, address payable depositor)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        bool doesCycleMemberExist = CycleMembersDeepIndexer[cycleId][depositor]\r\n            .exists;\r\n        require(doesCycleMemberExist == true, \"Cycle member not found\");\r\n\r\n        uint256 index = CycleMembersDeepIndexer[cycleId][depositor].index;\r\n        return index;\r\n    }\r\n\r\n    function _getCycleFinancialIndex(uint256 cycleId)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        bool doesCycleFinancialExist = CycleFinancialsIndexer[cycleId].exists;\r\n        require(doesCycleFinancialExist == true, \"Cycle financials not found\");\r\n\r\n        uint256 index = CycleFinancialsIndexer[cycleId].index;\r\n        return index;\r\n    }\r\n\r\n    function _updateCycleMember(CycleMember memory cycleMember) internal {\r\n        uint256 index = _getCycleMemberIndex(\r\n            cycleMember.cycleId,\r\n            cycleMember._address\r\n        );\r\n        CycleMembers[index] = cycleMember;\r\n    }\r\n\r\n    function _updateCycle(Cycle memory cycle) internal {\r\n        uint256 index = _getCycleIndex(cycle.id);\r\n        Cycles[index] = cycle;\r\n    }\r\n\r\n    function _updateCycleFinancial(CycleFinancial memory cycleFinancial)\r\n        internal\r\n    {\r\n        uint256 index = _getCycleIndex(cycleFinancial.cycleId);\r\n        CycleFinancials[index] = cycleFinancial;\r\n    }\r\n\r\n    function _getCycle(uint256 cycleId) internal view returns (Cycle memory) {\r\n        uint256 index = _getCycleIndex(cycleId);\r\n\r\n        Cycle memory cycle = Cycles[index];\r\n        return cycle;\r\n    }\r\n\r\n    function _getCycleFinancial(uint256 cycleId)\r\n        internal\r\n        view\r\n        returns (CycleFinancial memory)\r\n    {\r\n        uint256 index = _getCycleFinancialIndex(cycleId);\r\n\r\n        CycleFinancial memory cycleFinancial = CycleFinancials[index];\r\n        return cycleFinancial;\r\n    }\r\n\r\n    function doesCycleMemberExist(uint256 cycleId, address depositor)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _doesCycleMemberExist(cycleId, depositor);\r\n    }\r\n\r\n    function _doesCycleMemberExist(uint256 cycleId, address depositor)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bool exist = CycleMembersDeepIndexer[cycleId][depositor].exists;\r\n\r\n        if (exist) return true;\r\n        else return false;\r\n    }\r\n}"
    },
    "IGroupSchema.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\ninterface IGroupSchema {\r\n    struct Group {\r\n        bool exists;\r\n        uint256 id;\r\n        string name;\r\n        string symbol;\r\n        address payable creatorAddress;\r\n    }\r\n\r\n    struct Cycle {\r\n        bool exists;\r\n        uint256 id;\r\n        uint256 groupId;\r\n        uint256 numberOfDepositors;\r\n        uint256 cycleStartTimeStamp;\r\n        uint256 cycleDuration;\r\n        uint256 maximumSlots;\r\n        bool hasMaximumSlots;\r\n        uint256 cycleStakeAmount;\r\n        // represents the total stakes of every cycle member deposits\r\n        uint256 totalStakes;\r\n        //represents the total stakes of every cycle member withdrawal\r\n        uint256 stakesClaimed;\r\n        CycleStatus cycleStatus;\r\n        // represents the number of cycle stakes that user's have cashed out on before the cycle has ended\r\n        uint256 stakesClaimedBeforeMaturity;\r\n    }\r\n\r\n    struct CycleFinancial {\r\n        bool exists;\r\n        uint256 cycleId;\r\n        //total underlying asset deposited into contract\r\n        uint256 underlyingTotalDeposits;\r\n        //total underlying asset that have been withdrawn by cycle members\r\n        uint256 underlyingTotalWithdrawn;\r\n        // underlying amount gotten after lending period has ended and shares have been reedemed for underlying asset;\r\n        uint256 underlyingBalance;\r\n        // lending shares representation of amount deposited in lending protocol\r\n        uint256 derivativeBalance;\r\n        // represents the total underlying crypto amount that has been cashed out before the cycle ended\r\n        uint256 underylingBalanceClaimedBeforeMaturity;\r\n        // represents the total derivative crypto amount that has been cashed out on before the cycle ended\r\n        uint256 derivativeBalanceClaimedBeforeMaturity;\r\n    }\r\n\r\n    struct CycleMember {\r\n        bool exist;\r\n        uint256 cycleId;\r\n        uint256 groupId;\r\n        address payable _address;\r\n        uint256 totalLiquidityAsPenalty;\r\n        uint256 numberOfCycleStakes;\r\n        uint256 stakesClaimed;\r\n        bool hasWithdrawn;\r\n    }\r\n\r\n    struct Member {\r\n        bool exists;\r\n        address payable _address;\r\n    }\r\n\r\n    struct GroupMember {\r\n        bool exists;\r\n        address payable _address;\r\n        uint256 groupId;\r\n    }\r\n\r\n    struct RecordIndex {\r\n        bool exists;\r\n        uint256 index;\r\n    }\r\n\r\n    enum CycleStatus {NOT_STARTED, ONGOING, ENDED}\r\n}\r\n"
    },
    "SafeMath.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "StorageOwners.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\ncontract StorageOwners {\r\n    address owner;\r\n    mapping(address => bool) private storageOracles;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function activateStorageOracle(address oracle) external onlyOwner {\r\n        storageOracles[oracle] = true;\r\n    }\r\n\r\n    function deactivateStorageOracle(address oracle) external onlyOwner {\r\n        storageOracles[oracle] = false;\r\n    }\r\n\r\n    function reAssignStorageOracle(address newOracle)\r\n        external\r\n        onlyStorageOracle\r\n    {\r\n        storageOracles[msg.sender] = false;\r\n        storageOracles[newOracle] = true;\r\n    }\r\n\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"unauthorized access to contract\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyStorageOracle() {\r\n        bool hasAccess = storageOracles[msg.sender];\r\n        require(hasAccess, \"unauthorized access to contract\");\r\n        _;\r\n    }\r\n}\r\n"
    }
  }
}