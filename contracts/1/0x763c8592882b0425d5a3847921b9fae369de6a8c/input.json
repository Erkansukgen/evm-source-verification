{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"GeneralToken.sol":{"content":"// SPDX-License-Identifier: GPLv3\npragma solidity ^0.6.12;\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint c = a - b;\n\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint c = a / b;\n\n        return c;\n    }\n}\n\ncontract StandardToken {\n    using SafeMath for uint;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Burn(address indexed from, uint value);\n\n    uint public totalSupply;\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) internal allowed;\n\n    function balanceOf(address _owner) public view returns (uint) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        require(_value <= allowed[_from][msg.sender], \"Insufficient allowed\");\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        return _transfer(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint) {\n        return allowed[_owner][_spender];\n    }\n\n    function burn(uint _value) public returns (bool) {\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal returns (bool) {\n        require(_from != address(0), \"Address is null\");\n        require(_to != address(0), \"Address is null\");\n        require(_value <= balances[_from], \"Insufficient balance\");\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n\ncontract Ownable {\n    address owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner returns (bool) {\n        require(newOwner != address(0), \"address is null\");\n        owner = newOwner;\n        return true;\n    }\n}\n\ncontract GeneralToken is StandardToken, Ownable {\n    string  public name;\n    string  public symbol;\n    uint    public decimals;\n\n    event Issue(uint amount);\n    event Redeem(uint amount);\n\n    constructor(string memory _name, string memory _symbol, uint _decimals, uint _totalSupply) public {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply * (10 ** decimals);\n        balances[msg.sender] = totalSupply;\n    }\n\n    // Issue a new amount of tokens.\n    // these tokens are deposited into the owner address\n    // @param amount Number of tokens to be issued\n    function issue(uint amount) public onlyOwner returns (bool) {\n        balances[owner] = balances[owner].add(amount);\n        totalSupply = totalSupply.add(amount);\n        emit Issue(amount);\n        emit Transfer(address(0), owner, amount);\n        return true;\n    }\n\n    // Redeem tokens.\n    // These tokens are withdrawn from the owner address\n    // if the balance must be enough to cover the redeem\n    // or the call will fail.\n    // @param amount Number of tokens to be redeem\n    function redeem(uint amount) public onlyOwner returns (bool){\n        totalSupply = totalSupply.sub(amount);\n        balances[owner] = balances[owner].sub(amount);\n        emit Redeem(amount);\n        emit Transfer(owner, address(0), amount);\n        return true;\n    }\n}"}}}