{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/1_Storage.sol":{"content":"\n// File: @openzeppelin/contracts/GSN/Context.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/interfaces/IUniswapV1.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ninterface IUniswapV1Factory {\n    function getExchange(IERC20 token) external view returns (IUniswapV1Exchange exchange);\n}\n\ninterface IUniswapV1Exchange {\n    function getEthToTokenInputPrice(uint256 ethSold) external view returns (uint256 tokensBought);\n    function getTokenToEthInputPrice(uint256 tokensSold) external view returns (uint256 ethBought);\n\n    function ethToTokenSwapInput(uint256 minTokens, uint256 deadline)\n        external payable returns (uint256 tokensBought);\n    function tokenToEthSwapInput(uint256 tokensSold, uint256 minEth, uint256 deadline)\n        external returns (uint256 ethBought);\n}\n\n// File: contracts/interfaces/IUniswapV2.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ninterface IUniswapV2Factory {\n    function getPair(IERC20 tokenA, IERC20 tokenB) external view returns (IUniswapV2Exchange pair);\n}\n\ninterface IUniswapV2Exchange {\n    function getReserves() external view returns(uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n}\n\n// File: contracts/interfaces/IBalancer.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ninterface IBalancerPool {\n    function getSwapFee() external view returns (uint256 balance);\n    function getDenormalizedWeight(IERC20 token) external view returns (uint256 balance);\n    function getBalance(IERC20 token) external view returns (uint256 balance);\n\n    function swapExactAmountIn(\n        IERC20 tokenIn,\n        uint256 tokenAmountIn,\n        IERC20 tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    )\n        external\n        returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n}\n\ninterface IBalancerRegistry {\n    // Get info about pool pair for 1 SLOAD\n    function getPairInfo(address pool, IERC20 fromToken, IERC20 destToken)\n        external view returns(uint256 weight1, uint256 weight2, uint256 swapFee);\n\n    // Pools\n    function checkAddedPools(address pool)\n        external view returns(bool);\n    function getAddedPoolsLength()\n        external view returns(uint256);\n    function getAddedPools()\n        external view returns(address[] memory);\n    function getAddedPoolsWithLimit(uint256 offset, uint256 limit)\n        external view returns(address[] memory result);\n\n    // Tokens\n    function getAllTokensLength()\n        external view returns(uint256);\n    function getAllTokens()\n        external view returns(address[] memory);\n    function getAllTokensWithLimit(uint256 offset, uint256 limit)\n        external view returns(address[] memory result);\n\n    // Pairs\n    function getPoolsLength(IERC20 fromToken, IERC20 destToken)\n        external view returns(uint256);\n    function getPools(IERC20 fromToken, IERC20 destToken)\n        external view returns(IBalancerPool[] memory);\n    function getPoolsWithLimit(IERC20 fromToken, IERC20 destToken, uint256 offset, uint256 limit)\n        external view returns(IBalancerPool[] memory result);\n    function getBestPools(IERC20 fromToken, IERC20 destToken)\n        external view returns(IBalancerPool[] memory pools);\n    function getBestPoolsWithLimit(IERC20 fromToken, IERC20 destToken, uint256 limit)\n        external view returns(IBalancerPool[] memory pools);\n\n    // Get swap rates\n    function getPoolReturn(address pool, IERC20 fromToken, IERC20 destToken, uint256 amount)\n        external view returns(uint256);\n    function getPoolReturns(address pool, IERC20 fromToken, IERC20 destToken, uint256[] calldata amounts)\n        external view returns(uint256[] memory result);\n\n    // Add and update registry\n    function addPool(address pool) external returns(uint256 listed);\n    function addPools(address[] calldata pools) external returns(uint256[] memory listed);\n    function updatedIndices(address[] calldata tokens, uint256 lengthLimit) external;\n}\n\n// File: contracts/interfaces/IAaveRegistry.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ninterface IAaveRegistry {\n    function tokenByAToken(IERC20 aToken) external view returns(IERC20);\n    function aTokenByToken(IERC20 token) external view returns(IERC20);\n}\n\n// File: contracts/interfaces/ICompoundRegistry.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ninterface ICompoundRegistry {\n    function tokenByCToken(IERC20 cToken) external view returns(IERC20);\n    function cTokenByToken(IERC20 token) external view returns(IERC20);\n}\n\n// File: contracts/IOneRouter.sol\n\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\n\ninterface IOneRouterView {\n    struct Swap {\n        IERC20 destToken;\n        uint256 flags;\n        uint256 destTokenEthPriceTimesGasPrice;\n        address[] disabledDexes;\n    }\n\n    struct Path {\n        Swap[] swaps;\n    }\n\n    struct SwapResult {\n        uint256[] returnAmounts;\n        uint256[] estimateGasAmounts;\n        uint256[][] distributions;\n        address[][] dexes;\n    }\n\n    struct PathResult {\n        SwapResult[] swaps;\n    }\n\n    function getReturn(\n        IERC20 fromToken,\n        uint256[] calldata amounts,\n        Swap calldata swap\n    )\n        external\n        view\n        returns(\n            Path[] memory paths,\n            PathResult[] memory pathResults,\n            SwapResult memory splitResult\n        );\n\n    function getSwapReturn(\n        IERC20 fromToken,\n        uint256[] calldata amounts,\n        Swap calldata swap\n    )\n        external\n        view\n        returns(SwapResult memory result);\n\n    function getPathReturn(\n        IERC20 fromToken,\n        uint256[] calldata amounts,\n        Path calldata path\n    )\n        external\n        view\n        returns(PathResult memory result);\n\n    function getMultiPathReturn(\n        IERC20 fromToken,\n        uint256[] calldata amounts,\n        Path[] calldata paths\n    )\n        external\n        view\n        returns(\n            PathResult[] memory pathResults,\n            SwapResult memory splitResult\n        );\n}\n\n\nabstract contract IOneRouter is IOneRouterView {\n    struct Referral {\n        address payable ref;\n        uint256 fee;\n    }\n\n    struct SwapInput {\n        IERC20 fromToken;\n        IERC20 destToken;\n        uint256 amount;\n        uint256 minReturn;\n        Referral referral;\n    }\n\n    struct SwapDistribution {\n        uint256[] weights;\n    }\n\n    struct PathDistribution {\n        SwapDistribution[] swapDistributions;\n    }\n\n    function makeSwap(\n        SwapInput calldata input,\n        Swap calldata swap,\n        SwapDistribution calldata swapDistribution\n    )\n        external\n        payable\n        virtual\n        returns(uint256 returnAmount);\n\n    function makePathSwap(\n        SwapInput calldata input,\n        Path calldata path,\n        PathDistribution calldata pathDistribution\n    )\n        external\n        payable\n        virtual\n        returns(uint256 returnAmount);\n\n    function makeMultiPathSwap(\n        SwapInput calldata input,\n        Path[] calldata paths,\n        PathDistribution[] calldata pathDistributions,\n        SwapDistribution calldata interPathsDistribution\n    )\n        external\n        payable\n        virtual\n        returns(uint256 returnAmount);\n}\n\n// File: contracts/ISource.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ninterface ISource {\n    function calculate(IERC20 fromToken, uint256[] calldata amounts, IOneRouterView.Swap calldata swap)\n        external view returns(uint256[] memory rets, address dex, uint256 gas);\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) external;\n}\n\n// File: contracts/OneRouterConstants.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ncontract OneRouterConstants {\n    uint256 constant internal _FLAG_DISABLE_ALL_SOURCES          = 0x100000000000000000000000000000000;\n    uint256 constant internal _FLAG_DISABLE_RECALCULATION        = 0x200000000000000000000000000000000;\n    uint256 constant internal _FLAG_ENABLE_CHI_BURN              = 0x400000000000000000000000000000000;\n    uint256 constant internal _FLAG_ENABLE_CHI_BURN_ORIGIN       = 0x800000000000000000000000000000000;\n    uint256 constant internal _FLAG_ENABLE_REFERRAL_GAS_DISCOUNT = 0x1000000000000000000000000000000000;\n\n\n    uint256 constant internal _FLAG_DISABLE_KYBER_ALL =\n        _FLAG_DISABLE_KYBER_1 +\n        _FLAG_DISABLE_KYBER_2 +\n        _FLAG_DISABLE_KYBER_3 +\n        _FLAG_DISABLE_KYBER_4;\n    uint256 constant internal _FLAG_DISABLE_CURVE_ALL =\n        _FLAG_DISABLE_CURVE_COMPOUND +\n        _FLAG_DISABLE_CURVE_USDT +\n        _FLAG_DISABLE_CURVE_Y +\n        _FLAG_DISABLE_CURVE_BINANCE +\n        _FLAG_DISABLE_CURVE_SYNTHETIX +\n        _FLAG_DISABLE_CURVE_PAX +\n        _FLAG_DISABLE_CURVE_RENBTC +\n        _FLAG_DISABLE_CURVE_TBTC +\n        _FLAG_DISABLE_CURVE_SBTC;\n    uint256 constant internal _FLAG_DISABLE_BALANCER_ALL =\n        _FLAG_DISABLE_BALANCER_1 +\n        _FLAG_DISABLE_BALANCER_2 +\n        _FLAG_DISABLE_BALANCER_3;\n    uint256 constant internal _FLAG_DISABLE_BANCOR_ALL =\n        _FLAG_DISABLE_BANCOR_1 +\n        _FLAG_DISABLE_BANCOR_2 +\n        _FLAG_DISABLE_BANCOR_3;\n\n    uint256 constant internal _FLAG_DISABLE_UNISWAP_V1      = 0x1;\n    uint256 constant internal _FLAG_DISABLE_UNISWAP_V2      = 0x2;\n    uint256 constant internal _FLAG_DISABLE_MOONISWAP       = 0x4;\n    uint256 constant internal _FLAG_DISABLE_KYBER_1         = 0x8;\n    uint256 constant internal _FLAG_DISABLE_KYBER_2         = 0x10;\n    uint256 constant internal _FLAG_DISABLE_KYBER_3         = 0x20;\n    uint256 constant internal _FLAG_DISABLE_KYBER_4         = 0x40;\n    uint256 constant internal _FLAG_DISABLE_CURVE_COMPOUND  = 0x80;\n    uint256 constant internal _FLAG_DISABLE_CURVE_USDT      = 0x100;\n    uint256 constant internal _FLAG_DISABLE_CURVE_Y         = 0x200;\n    uint256 constant internal _FLAG_DISABLE_CURVE_BINANCE   = 0x400;\n    uint256 constant internal _FLAG_DISABLE_CURVE_SYNTHETIX = 0x800;\n    uint256 constant internal _FLAG_DISABLE_CURVE_PAX       = 0x1000;\n    uint256 constant internal _FLAG_DISABLE_CURVE_RENBTC    = 0x2000;\n    uint256 constant internal _FLAG_DISABLE_CURVE_TBTC      = 0x4000;\n    uint256 constant internal _FLAG_DISABLE_CURVE_SBTC      = 0x8000;\n    uint256 constant internal _FLAG_DISABLE_BALANCER_1      = 0x10000;\n    uint256 constant internal _FLAG_DISABLE_BALANCER_2      = 0x20000;\n    uint256 constant internal _FLAG_DISABLE_BALANCER_3      = 0x40000;\n    uint256 constant internal _FLAG_DISABLE_BANCOR_1        = 0x80000;\n    uint256 constant internal _FLAG_DISABLE_BANCOR_2        = 0x100000;\n    uint256 constant internal _FLAG_DISABLE_BANCOR_3        = 0x200000;\n    uint256 constant internal _FLAG_DISABLE_OASIS           = 0x400000;\n    uint256 constant internal _FLAG_DISABLE_DFORCE_SWAP     = 0x800000;\n    uint256 constant internal _FLAG_DISABLE_SHELL           = 0x1000000;\n    uint256 constant internal _FLAG_DISABLE_MSTABLE_MUSD    = 0x2000000;\n    uint256 constant internal _FLAG_DISABLE_BLACK_HOLE_SWAP = 0x4000000;\n\n    IERC20 constant internal _DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    IERC20 constant internal _USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 constant internal _USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IERC20 constant internal _TUSD = IERC20(0x0000000000085d4780B73119b644AE5ecd22b376);\n    IERC20 constant internal _BUSD = IERC20(0x4Fabb145d64652a948d72533023f6E7A623C7C53);\n    IERC20 constant internal _SUSD = IERC20(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\n    IERC20 constant internal _PAX = IERC20(0x8E870D67F660D95d5be530380D0eC0bd388289E1);\n    IERC20 constant internal _RENBTC = IERC20(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);\n    IERC20 constant internal _WBTC = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n    IERC20 constant internal _SBTC = IERC20(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);\n    IERC20 constant internal _CHI = IERC20(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/libraries/Algo.sol\n\n\npragma solidity ^0.6.0;\n\n\n\nlibrary Algo {\n    using SafeMath for uint256;\n\n    int256 public constant VERY_NEGATIVE_VALUE = -1e72;\n\n    function findBestDistribution(int256[][] memory amounts, uint256 parts)\n        internal\n        pure\n        returns(\n            int256[] memory returnAmounts,\n            uint256[][] memory distributions\n        )\n    {\n        uint256 n = amounts.length;\n\n        int256[][] memory answer = new int256[][](n); // int[n][parts+1]\n        uint256[][] memory parent = new uint256[][](n); // int[n][parts+1]\n\n        for (uint i = 0; i < n; i++) {\n            answer[i] = new int256[](parts + 1);\n            parent[i] = new uint256[](parts + 1);\n        }\n\n        for (uint j = 0; j <= parts; j++) {\n            answer[0][j] = amounts[0][j];\n            for (uint i = 1; i < n; i++) {\n                answer[i][j] = VERY_NEGATIVE_VALUE;\n            }\n            parent[0][j] = 0;\n        }\n\n        for (uint i = 1; i < n; i++) {\n            for (uint j = 0; j <= parts; j++) {\n                answer[i][j] = answer[i - 1][j];\n                parent[i][j] = j;\n\n                for (uint k = 1; k <= j; k++) {\n                    if (answer[i - 1][j - k] + amounts[i][k] > answer[i][j]) {\n                        answer[i][j] = answer[i - 1][j - k] + amounts[i][k];\n                        parent[i][j] = j - k;\n                    }\n                }\n            }\n        }\n\n        distributions = new uint256[][](parts);\n        returnAmounts = new int256[](parts);\n        for (uint256 i = 1; i <= parts; i++) {\n            uint256 partsLeft = i;\n            distributions[i - 1] = new uint256[](n);\n            for (uint curExchange = n - 1; partsLeft > 0; curExchange--) {\n                distributions[i - 1][curExchange] = partsLeft - parent[curExchange][partsLeft];\n                partsLeft = parent[curExchange][partsLeft];\n            }\n\n            returnAmounts[i - 1] = (answer[n - 1][i] == VERY_NEGATIVE_VALUE) ? 0 : answer[n - 1][i];\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: contracts/libraries/Address2.sol\n\n\npragma solidity ^0.6.0;\n\n\n\nlibrary Address2 {\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(Address.isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// File: contracts/libraries/UniERC20.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\n\nlibrary UniERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    IERC20 public constant ZERO_ADDRESS = IERC20(0);\n\n    function isETH(IERC20 token) internal pure returns(bool) {\n        return (token == ZERO_ADDRESS || token == ETH_ADDRESS);\n    }\n\n    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {\n        if (isETH(token)) {\n            return account.balance;\n        } else {\n            return token.balanceOf(account);\n        }\n    }\n\n    function uniTransfer(IERC20 token, address payable to, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                to.transfer(amount);\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function uniTransferFromSender(IERC20 token, address payable target, uint256 amount) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                require(msg.value >= amount, \"UniERC20: not enough value\");\n                target.transfer(amount);\n                if (msg.value > amount) {\n                    // Return remainder if exist\n                    msg.sender.transfer(msg.value.sub(amount));\n                }\n            } else {\n                token.safeTransferFrom(msg.sender, target, amount);\n            }\n        }\n    }\n\n    function uniApprove(IERC20 token, address to, uint256 amount) internal {\n        if (!isETH(token)) {\n            if (amount == 0) {\n                token.safeApprove(to, 0);\n                return;\n            }\n\n            uint256 allowance = token.allowance(address(this), to);\n            if (allowance < amount) {\n                if (allowance > 0) {\n                    token.safeApprove(to, 0);\n                }\n                token.safeApprove(to, amount);\n            }\n        }\n    }\n\n    function uniDecimals(IERC20 token) internal view returns (uint256) {\n        if (isETH(token)) {\n            return 18;\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{ gas: 20000 }(\n            abi.encodeWithSignature(\"decimals()\")\n        );\n        if (!success) {\n            (success, data) = address(token).staticcall{ gas: 20000 }(\n                abi.encodeWithSignature(\"DECIMALS()\")\n            );\n        }\n\n        return success ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function uniSymbol(IERC20 token) internal view returns(string memory) {\n        if (isETH(token)) {\n            return \"ETH\";\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall{ gas: 20000 }(\n            abi.encodeWithSignature(\"symbol()\")\n        );\n        if (!success) {\n            (success, data) = address(token).staticcall{ gas: 20000 }(\n                abi.encodeWithSignature(\"SYMBOL()\")\n            );\n        }\n\n        if (success && data.length >= 96) {\n            (uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\n            if (offset == 0x20 && len > 0 && len <= 256) {\n                return string(abi.decode(data, (bytes)));\n            }\n        }\n\n        if (success && data.length == 32) {\n            uint len = 0;\n            while (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\n                len++;\n            }\n\n            if (len > 0) {\n                bytes memory result = new bytes(len);\n                for (uint i = 0; i < len; i++) {\n                    result[i] = data[i];\n                }\n                return string(result);\n            }\n        }\n\n        return _toHex(address(token));\n    }\n\n    function _toHex(address account) private pure returns(string memory) {\n        return _toHex(abi.encodePacked(account));\n    }\n\n    function _toHex(bytes memory data) private pure returns(string memory) {\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        uint j = 2;\n        for (uint i = 0; i < data.length; i++) {\n            uint a = uint8(data[i]) >> 4;\n            uint b = uint8(data[i]) & 0x0f;\n            str[j++] = byte(uint8(a + 48 + (a/10)*39));\n            str[j++] = byte(uint8(b + 48 + (b/10)*39));\n        }\n\n        return string(str);\n    }\n}\n\n// File: contracts/libraries/RevertReason.sol\n\n\npragma solidity ^0.6.0;\n\n\nlibrary RevertReason {\n    function parse(bytes memory data, string memory message) internal pure returns (string memory) {\n        (, string memory reason) = abi.decode(abi.encodePacked(bytes28(0), data), (uint256, string));\n        return string(abi.encodePacked(message, reason));\n    }\n}\n\n// File: contracts/libraries/FlagsChecker.sol\n\n\npragma solidity ^0.6.0;\n\n\nlibrary FlagsChecker {\n    function check(uint256 flags, uint256 flag) internal pure returns(bool) {\n        return (flags & flag) != 0;\n    }\n}\n\n// File: contracts/libraries/DynamicMemoryArray.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\nlibrary DynamicMemoryArray {\n    using SafeMath for uint256;\n\n    struct Addresses {\n        uint256 length;\n        address[1000] _arr;\n    }\n\n    function at(DynamicMemoryArray.Addresses memory self, uint256 index) internal pure returns(address) {\n        require(index < self.length, \"DynMemArr: out of range\");\n        return self._arr[index];\n    }\n\n    function push(DynamicMemoryArray.Addresses memory self, address item) internal pure returns(uint256) {\n        require(self.length < self._arr.length, \"DynMemArr: out of limit\");\n        self._arr[self.length++] = item;\n        return self.length;\n    }\n\n    function pop(DynamicMemoryArray.Addresses memory self) internal pure returns(address) {\n        require(self.length > 0, \"DynMemArr: already empty\");\n        return self._arr[--self.length];\n    }\n\n    function copy(DynamicMemoryArray.Addresses memory self) internal pure returns(address[] memory arr) {\n        arr = new address[](self.length);\n        for (uint i = 0; i < arr.length; i++) {\n            arr[i] = self._arr[i];\n        }\n    }\n}\n\n// File: contracts/sources/UniswapV1Source.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\n\n\n\ncontract UniswapV1SourceView {\n    using SafeMath for uint256;\n    using UniERC20 for IERC20;\n\n    IUniswapV1Factory constant private _FACTORY = IUniswapV1Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\n\n    function _calculateUniswapV1Formula(uint256 fromBalance, uint256 toBalance, uint256 amount) private pure returns(uint256) {\n        if (amount > 0) {\n            return amount.mul(toBalance).mul(997).div(\n                fromBalance.mul(1000).add(amount.mul(997))\n            );\n        }\n    }\n\n    function _calculateUniswapV1(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        rets = new uint256[](amounts.length);\n\n        if (fromToken.isETH() || swap.destToken.isETH()) {\n            IUniswapV1Exchange exchange = _FACTORY.getExchange(fromToken.isETH() ? swap.destToken : fromToken);\n            if (exchange == IUniswapV1Exchange(0)) {\n                return (rets, address(0), 0);\n            }\n\n            for (uint t = 0; t < swap.disabledDexes.length; t++) {\n                if (swap.disabledDexes[t] == address(exchange)) {\n                    return (rets, address(0), 0);\n                }\n            }\n\n            uint256 fromBalance = fromToken.uniBalanceOf(address(exchange));\n            uint256 destBalance = swap.destToken.uniBalanceOf(address(exchange));\n            for (uint i = 0; i < amounts.length; i++) {\n                rets[i] = _calculateUniswapV1Formula(fromBalance, destBalance, amounts[i]);\n            }\n            return (rets, address(exchange), 60_000);\n        }\n    }\n}\n\n\ncontract UniswapV1SourceSwap {\n    using UniERC20 for IERC20;\n\n    IUniswapV1Factory constant private _FACTORY = IUniswapV1Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\n\n    function _swapOnUniswapV1(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount,\n        uint256 /*flags*/\n    ) internal {\n        IUniswapV1Exchange exchange = _FACTORY.getExchange(fromToken.isETH() ? destToken : fromToken);\n        fromToken.uniApprove(address(exchange), amount);\n        if (fromToken.isETH()) {\n            exchange.ethToTokenSwapInput{ value: amount }(1, block.timestamp);\n        } else {\n            exchange.tokenToEthSwapInput(amount, 1, block.timestamp);\n        }\n    }\n}\n\n\ncontract UniswapV1SourcePublic is ISource, UniswapV1SourceView, UniswapV1SourceSwap {\n    receive() external payable {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\n    }\n\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateUniswapV1(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnUniswapV1(fromToken, destToken, amount, flags);\n    }\n}\n\n// File: @openzeppelin/contracts/math/Math.sol\n\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n\n// File: contracts/interfaces/IWETH.sol\n\n\npragma solidity ^0.6.0;\n\n\n\nabstract contract IWETH is IERC20 {\n    function deposit() external payable virtual;\n    function withdraw(uint256 amount) external virtual;\n}\n\n// File: contracts/sources/UniswapV2Source.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\n\n\n\n\n\nlibrary UniswapV2Helper {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using UniERC20 for IERC20;\n\n    IUniswapV2Factory constant public FACTORY = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n    IWETH constant public WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    function getReturns(\n        IUniswapV2Exchange exchange,\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256[] memory amounts\n    ) internal view returns (\n        uint256[] memory results,\n        uint256 reserveIn,\n        uint256 reverseOut,\n        bool needSync,\n        bool needSkim\n    ) {\n        return _getReturns(\n            exchange,\n            fromToken.isETH() ? UniswapV2Helper.WETH : fromToken,\n            destToken.isETH() ? UniswapV2Helper.WETH : destToken,\n            amounts\n        );\n    }\n\n    function _getReturns(\n        IUniswapV2Exchange exchange,\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256[] memory amounts\n    ) private view returns (\n        uint256[] memory results,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        bool needSync,\n        bool needSkim\n    ) {\n        reserveIn = fromToken.uniBalanceOf(address(exchange));\n        reserveOut = destToken.uniBalanceOf(address(exchange));\n        (uint112 reserve0, uint112 reserve1,) = exchange.getReserves();\n        if (fromToken > destToken) {\n            (reserve0, reserve1) = (reserve1, reserve0);\n        }\n        needSync = (reserveIn < reserve0 || reserveOut < reserve1);\n        needSkim = !needSync && (reserveIn > reserve0 || reserveOut > reserve1);\n\n        reserveIn = Math.min(reserveIn, reserve0);\n        reserveOut = Math.min(reserveOut, reserve1);\n\n        results = new uint256[](amounts.length);\n        for (uint i = 0; i < amounts.length; i++) {\n            results[i] = calculateUniswapV2Formula(reserveIn, reserveOut, amounts[i]);\n        }\n    }\n\n    function calculateUniswapV2Formula(uint256 reserveIn, uint256 reserveOut, uint256 amount) internal pure returns(uint256) {\n        if (amount > 0) {\n            return amount.mul(reserveOut).mul(997).div(\n                reserveIn.mul(1000).add(amount.mul(997))\n            );\n        }\n    }\n}\n\n\ncontract UniswapV2SourceView {\n    using SafeMath for uint256;\n    using UniERC20 for IERC20;\n    using UniswapV2Helper for IUniswapV2Exchange;\n\n    function _calculateUniswapV2(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        rets = new uint256[](amounts.length);\n\n        IERC20 fromTokenWrapped = fromToken.isETH() ? UniswapV2Helper.WETH : fromToken;\n        IERC20 destTokenWrapped = swap.destToken.isETH() ? UniswapV2Helper.WETH : swap.destToken;\n        IUniswapV2Exchange exchange = UniswapV2Helper.FACTORY.getPair(fromTokenWrapped, destTokenWrapped);\n        if (exchange == IUniswapV2Exchange(0)) {\n            return (rets, address(0), 0);\n        }\n\n        for (uint t = 0; t < swap.disabledDexes.length; t++) {\n            if (swap.disabledDexes[t] == address(exchange)) {\n                return (rets, address(0), 0);\n            }\n        }\n\n        (rets,,,,) = exchange.getReturns(fromToken, swap.destToken, amounts);\n        return (rets, address(exchange), 50_000 + (fromToken.isETH() || swap.destToken.isETH() ? 0 : 30_000));\n    }\n}\n\n\ncontract UniswapV2SourceSwap {\n    using UniERC20 for IERC20;\n    using SafeMath for uint256;\n    using UniswapV2Helper for IUniswapV2Exchange;\n\n    function _swapOnUniswapV2(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\n        if (fromToken.isETH()) {\n            UniswapV2Helper.WETH.deposit{ value: amount }();\n        }\n\n        _swapOnUniswapV2Wrapped(\n            fromToken.isETH() ? UniswapV2Helper.WETH : fromToken,\n            destToken.isETH() ? UniswapV2Helper.WETH : destToken,\n            amount,\n            flags\n        );\n\n        if (destToken.isETH()) {\n            UniswapV2Helper.WETH.withdraw(UniswapV2Helper.WETH.balanceOf(address(this)));\n        }\n    }\n\n    function _swapOnUniswapV2Wrapped(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) private {\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        IUniswapV2Exchange exchange = UniswapV2Helper.FACTORY.getPair(fromToken, destToken);\n        (\n            /*uint256[] memory returnAmounts*/,\n            uint256 reserveIn,\n            uint256 reserveOut,\n            bool needSync,\n            bool needSkim\n        ) = exchange.getReturns(fromToken, destToken, amounts);\n\n        if (needSync) {\n            exchange.sync();\n        }\n        else if (needSkim) {\n            exchange.skim(0x68a17B587CAF4f9329f0e372e3A78D23A46De6b5);\n        }\n\n        fromToken.uniTransfer(payable(address(exchange)), amount);\n        uint256 confirmed = fromToken.uniBalanceOf(address(exchange)).sub(reserveIn);\n        uint256 returnAmount = UniswapV2Helper.calculateUniswapV2Formula(reserveIn, reserveOut, confirmed);\n\n        if (fromToken < destToken) {\n            exchange.swap(0, returnAmount, address(this), \"\");\n        } else {\n            exchange.swap(returnAmount, 0, address(this), \"\");\n        }\n    }\n}\n\n\ncontract UniswapV2SourcePublic is ISource, UniswapV2SourceView, UniswapV2SourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateUniswapV2(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnUniswapV2(fromToken, destToken, amount, flags);\n    }\n}\n\n// File: contracts/interfaces/IMooniswap.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ninterface IMooniswapRegistry {\n    function pools(IERC20 token1, IERC20 token2) external view returns(IMooniswap);\n    function isPool(address addr) external view returns(bool);\n}\n\n\ninterface IMooniswap {\n    function fee() external view returns (uint256);\n    function tokens(uint256 i) external view returns (IERC20);\n    function getBalanceForAddition(IERC20 token) external view returns(uint256);\n    function getBalanceForRemoval(IERC20 token) external view returns(uint256);\n    function getReturn(IERC20 fromToken, IERC20 destToken, uint256 amount) external view returns(uint256 returnAmount);\n\n    function deposit(uint256[] calldata amounts, uint256[] calldata minAmounts) external payable returns(uint256 fairSupply);\n    function withdraw(uint256 amount, uint256[] calldata minReturns) external;\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 minReturn, address referral) external payable returns(uint256 returnAmount);\n}\n\n// File: contracts/sources/MooniswapSource.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\n\n\n\nlibrary MooniswapHelper {\n    using SafeMath for uint256;\n    using UniERC20 for IERC20;\n\n    IMooniswapRegistry constant public REGISTRY = IMooniswapRegistry(0x71CD6666064C3A1354a3B4dca5fA1E2D3ee7D303);\n\n    function getReturn(\n        IMooniswap mooniswap,\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount\n    ) internal view returns(uint256 ret) {\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n        uint256[] memory rets = getReturns(mooniswap, fromToken, destToken, amounts);\n        if (rets.length > 0) {\n            return rets[0];\n        }\n    }\n\n    function getReturns(\n        IMooniswap mooniswap,\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256[] memory amounts\n    ) internal view returns(uint256[] memory rets) {\n        rets = new uint256[](amounts.length);\n\n        uint256 fee = mooniswap.fee();\n        uint256 fromBalance = mooniswap.getBalanceForAddition(fromToken.isETH() ? UniERC20.ZERO_ADDRESS : fromToken);\n        uint256 destBalance = mooniswap.getBalanceForRemoval(destToken.isETH() ? UniERC20.ZERO_ADDRESS : destToken);\n        if (fromBalance > 0 && destBalance > 0) {\n            for (uint i = 0; i < amounts.length; i++) {\n                uint256 amount = amounts[i].sub(amounts[i].mul(fee).div(1e18));\n                rets[i] = amount.mul(destBalance).div(\n                    fromBalance.add(amount)\n                );\n            }\n        }\n    }\n}\n\n\ncontract MooniswapSourceView {\n    using SafeMath for uint256;\n    using UniERC20 for IERC20;\n    using MooniswapHelper for IMooniswap;\n\n    function _calculateMooniswap(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        IMooniswap mooniswap = MooniswapHelper.REGISTRY.pools(\n            fromToken.isETH() ? UniERC20.ZERO_ADDRESS : fromToken,\n            swap.destToken.isETH() ? UniERC20.ZERO_ADDRESS : swap.destToken\n        );\n        if (mooniswap == IMooniswap(0)) {\n            return (new uint256[](0), address(0), 0);\n        }\n\n        for (uint t = 0; t < swap.disabledDexes.length; t++) {\n            if (swap.disabledDexes[t] == address(mooniswap)) {\n                return (new uint256[](0), address(0), 0);\n            }\n        }\n\n        rets = mooniswap.getReturns(fromToken, swap.destToken, amounts);\n        if (rets.length == 0 || rets[0] == 0) {\n            return (new uint256[](0), address(0), 0);\n        }\n\n        return (rets, address(mooniswap), (fromToken.isETH() || swap.destToken.isETH()) ? 80_000 : 110_000);\n    }\n}\n\n\ncontract MooniswapSourceSwap {\n    using UniERC20 for IERC20;\n\n    function _swapOnMooniswap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        IMooniswap mooniswap = MooniswapHelper.REGISTRY.pools(\n            fromToken.isETH() ? UniERC20.ZERO_ADDRESS : fromToken,\n            destToken.isETH() ? UniERC20.ZERO_ADDRESS : destToken\n        );\n\n        fromToken.uniApprove(address(mooniswap), amount);\n        mooniswap.swap{ value: fromToken.isETH() ? amount : 0 }(\n            fromToken.isETH() ? UniERC20.ZERO_ADDRESS : fromToken,\n            destToken.isETH() ? UniERC20.ZERO_ADDRESS : destToken,\n            amount,\n            0,\n            0x68a17B587CAF4f9329f0e372e3A78D23A46De6b5\n        );\n    }\n}\n\n\ncontract MooniswapSourcePublic is ISource, MooniswapSourceView, MooniswapSourceSwap {\n    receive() external payable {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\n    }\n\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateMooniswap(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnMooniswap(fromToken, destToken, amount, flags);\n    }\n}\n\n// File: contracts/interfaces/IKyber.sol\n\n\npragma solidity ^0.6.0;\n\n\n\ninterface IKyberStorage {\n    function getReserveIdsPerTokenSrc(IERC20 token) external view returns (bytes32[] memory);\n    function getReserveAddressesByReserveId(bytes32 reserveId) external view returns (IKyberReserve[] memory reserveAddresses);\n}\n\n\ninterface IKyberReserve {\n    function getConversionRate(IERC20 src, IERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\n}\n\n\ninterface IKyberHintHandler {\n    enum TradeType {\n        BestOfAll,\n        MaskIn,\n        MaskOut,\n        Split\n    }\n\n    function buildTokenToEthHint(\n        IERC20 tokenSrc,\n        TradeType tokenToEthType,\n        bytes32[] calldata tokenToEthReserveIds,\n        uint256[] calldata tokenToEthSplits\n    ) external view returns (bytes memory hint);\n\n    function buildEthToTokenHint(\n        IERC20 tokenDest,\n        TradeType ethToTokenType,\n        bytes32[] calldata ethToTokenReserveIds,\n        uint256[] calldata ethToTokenSplits\n    ) external view returns (bytes memory hint);\n}\n\n\ninterface IKyberNetworkProxy {\n    function getExpectedRateAfterFee(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcQty,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external view returns (uint256 expectedRate);\n\n    function tradeWithHintAndFee(\n        IERC20 src,\n        uint256 srcAmount,\n        IERC20 dest,\n        address payable destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address payable platformWallet,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external payable returns (uint256 destAmount);\n}\n\n// File: contracts/sources/KyberSource.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\n\n\n\n\n\nlibrary KyberHelper {\n    using UniERC20 for IERC20;\n\n    IKyberNetworkProxy constant public PROXY = IKyberNetworkProxy(0x9AAb3f75489902f3a48495025729a0AF77d4b11e);\n    IKyberStorage constant public STORAGE = IKyberStorage(0xC8fb12402cB16970F3C5F4b48Ff68Eb9D1289301);\n    IKyberHintHandler constant public HINT_HANDLER = IKyberHintHandler(0xa1C0Fa73c39CFBcC11ec9Eb1Afc665aba9996E2C);\n\n    // https://github.com/CryptoManiacsZone/1inchProtocol/blob/master/KyberReserves.md\n    bytes1 constant public RESERVE_BRIDGE_PREFIX = 0xbb;\n    bytes32 constant public RESERVE_ID_1 = 0xff4b796265722046707200000000000000000000000000000000000000000000; // 0x63825c174ab367968EC60f061753D3bbD36A0D8F\n    bytes32 constant public RESERVE_ID_2 = 0xffabcd0000000000000000000000000000000000000000000000000000000000; // 0x7a3370075a54B187d7bD5DceBf0ff2B5552d4F7D\n    bytes32 constant public RESERVE_ID_3 = 0xff4f6e65426974205175616e7400000000000000000000000000000000000000; // 0x4f32BbE8dFc9efD54345Fc936f9fEF1048746fCF\n\n    function getReserveId(IERC20 fromToken, IERC20 destToken) internal view returns(bytes32) {\n        if (fromToken.isETH() || destToken.isETH()) {\n            bytes32[] memory reserveIds = STORAGE.getReserveIdsPerTokenSrc(\n                fromToken.isETH() ? destToken : fromToken\n            );\n\n            for (uint i = 0; i < reserveIds.length; i++) {\n                if (reserveIds[i][0] != RESERVE_BRIDGE_PREFIX &&\n                    reserveIds[i] != RESERVE_ID_1 &&\n                    reserveIds[i] != RESERVE_ID_2 &&\n                    reserveIds[i] != RESERVE_ID_3)\n                {\n                    return reserveIds[i];\n                }\n            }\n        }\n    }\n}\n\n\ncontract KyberSourceView is OneRouterConstants {\n    using SafeMath for uint256;\n    using UniERC20 for IERC20;\n    using FlagsChecker for uint256;\n\n    function _calculateKyber1(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateKyber(fromToken, amounts, swap, KyberHelper.RESERVE_ID_1);\n    }\n\n    function _calculateKyber2(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateKyber(fromToken, amounts, swap, KyberHelper.RESERVE_ID_2);\n    }\n\n    function _calculateKyber3(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateKyber(fromToken, amounts, swap, KyberHelper.RESERVE_ID_3);\n    }\n\n    function _calculateKyber4(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        bytes32 reserveId = KyberHelper.getReserveId(fromToken, swap.destToken);\n        if (reserveId != 0) {\n            return _calculateKyber(fromToken, amounts, swap, reserveId);\n        }\n    }\n\n    // Fix for \"Stack too deep\"\n    struct Decimals {\n        uint256 fromTokenDecimals;\n        uint256 destTokenDecimals;\n    }\n\n    function _calculateKyber(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap, bytes32 reserveId) private view returns(uint256[] memory rets, address dex, uint256 gas) {\n        rets = new uint256[](amounts.length);\n\n        IKyberReserve reserve = KyberHelper.STORAGE.getReserveAddressesByReserveId(reserveId)[0];\n\n        for (uint t = 0; t < swap.disabledDexes.length; t++) {\n            if (swap.disabledDexes[t] == address(reserve)) {\n                return (rets, address(0), 0);\n            }\n        }\n\n        Decimals memory decimals = Decimals({\n            fromTokenDecimals: 10 ** IERC20(fromToken).uniDecimals(),\n            destTokenDecimals: 10 ** IERC20(swap.destToken).uniDecimals()\n        });\n        for (uint i = 0; i < amounts.length; i++) {\n            if (i > 0 && rets[i - 1] == 0) {\n                break;\n            }\n\n            uint256 amount = amounts[0].mul(uint256(1e18).sub((swap.flags >> 255) * 1e15)).div(1e18);\n            try reserve.getConversionRate(\n                fromToken.isETH() ? UniERC20.ETH_ADDRESS : fromToken,\n                swap.destToken.isETH() ? UniERC20.ETH_ADDRESS : swap.destToken,\n                amount,\n                block.number\n            )\n            returns(uint256 rate) {\n                uint256 preResult = amounts[i].mul(rate).mul(decimals.destTokenDecimals);\n                rets[i] = preResult.div(decimals.fromTokenDecimals).div(1e18);\n            } catch {\n            }\n        }\n\n        return (rets, address(reserve), 100_000);\n    }\n}\n\n\ncontract KyberSourceSwap {\n    using UniERC20 for IERC20;\n\n    function _swapOnKyber1(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\n        _swapOnKyber(fromToken, destToken, amount, flags, KyberHelper.RESERVE_ID_1);\n    }\n\n    function _swapOnKyber2(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\n        _swapOnKyber(fromToken, destToken, amount, flags, KyberHelper.RESERVE_ID_2);\n    }\n\n    function _swapOnKyber3(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\n        _swapOnKyber(fromToken, destToken, amount, flags, KyberHelper.RESERVE_ID_3);\n    }\n\n    function _swapOnKyber4(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) internal {\n        _swapOnKyber(fromToken, destToken, amount, flags, KyberHelper.getReserveId(fromToken, destToken));\n    }\n\n    function _swapOnKyber(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags, bytes32 reserveId) internal {\n        bytes32[] memory reserveIds = new bytes32[](1);\n        reserveIds[0] = reserveId;\n\n        bytes memory hint;\n        if (fromToken.isETH()) {\n            hint = KyberHelper.HINT_HANDLER.buildEthToTokenHint(destToken, IKyberHintHandler.TradeType.MaskIn, reserveIds, new uint256[](0));\n        }\n        else {\n            hint = KyberHelper.HINT_HANDLER.buildTokenToEthHint(fromToken, IKyberHintHandler.TradeType.MaskIn, reserveIds, new uint256[](0));\n        }\n\n        fromToken.uniApprove(address(KyberHelper.PROXY), amount);\n        KyberHelper.PROXY.tradeWithHintAndFee{ value: fromToken.isETH() ? amount : 0 }(\n            fromToken,\n            amount,\n            destToken,\n            payable(address(this)),\n            uint256(-1),\n            0,\n            0x68a17B587CAF4f9329f0e372e3A78D23A46De6b5,\n            (flags >> 255) * 10,\n            hint\n        );\n    }\n\n    function _kyberGetHint(IERC20 fromToken, IERC20 destToken, bytes32 reserveId) private view returns(bytes memory) {\n        bytes32[] memory reserveIds = new bytes32[](1);\n        reserveIds[0] = reserveId;\n\n        if (fromToken.isETH()) {\n            try KyberHelper.HINT_HANDLER.buildEthToTokenHint(destToken, IKyberHintHandler.TradeType.MaskIn, reserveIds, new uint256[](0))\n            returns (bytes memory data) {\n                return data;\n            } catch {}\n        }\n\n        if (destToken.isETH()) {\n            try KyberHelper.HINT_HANDLER.buildTokenToEthHint(fromToken, IKyberHintHandler.TradeType.MaskIn, reserveIds, new uint256[](0))\n            returns (bytes memory data) {\n                return data;\n            } catch {}\n        }\n    }\n}\n\n\ncontract KyberSourcePublic1 is ISource, KyberSourceView, KyberSourceSwap {\n    receive() external payable {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\n    }\n\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateKyber1(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnKyber1(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract KyberSourcePublic2 is ISource, KyberSourceView, KyberSourceSwap {\n    receive() external payable {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\n    }\n\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateKyber2(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnKyber2(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract KyberSourcePublic3 is ISource, KyberSourceView, KyberSourceSwap {\n    receive() external payable {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\n    }\n\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateKyber3(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnKyber3(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract KyberSourcePublic4 is ISource, KyberSourceView, KyberSourceSwap {\n    receive() external payable {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\n    }\n\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateKyber4(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnKyber4(fromToken, destToken, amount, flags);\n    }\n}\n\n// File: contracts/interfaces/ICurve.sol\n\n\npragma solidity ^0.6.0;\n\n\ninterface ICurve {\n    // solhint-disable-next-line func-name-mixedcase\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns(uint256 dy);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256 dy);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 minDy) external;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function exchange(int128 i, int128 j, uint256 dx, uint256 minDy) external;\n}\n\n\ninterface ICurveRegistry {\n    // solhint-disable-next-line func-name-mixedcase\n    function get_pool_info(address pool)\n        external\n        view\n        returns(\n            uint256[8] memory balances,\n            uint256[8] memory underlyingBalances,\n            uint256[8] memory decimals,\n            uint256[8] memory underlyingDecimals,\n            address lpToken,\n            uint256 a,\n            uint256 fee\n        );\n}\n\n\ninterface ICurveCalculator {\n    // solhint-disable-next-line func-name-mixedcase\n    function get_dy(\n        int128 nCoins,\n        uint256[8] calldata balances,\n        uint256 amp,\n        uint256 fee,\n        uint256[8] calldata rates,\n        uint256[8] calldata precisions,\n        bool underlying,\n        int128 i,\n        int128 j,\n        uint256[100] calldata dx\n    ) external view returns(uint256[100] memory dy);\n}\n\n// File: contracts/sources/CurveSource.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\n\n\n\n\n\nlibrary CurveHelper {\n    ICurve constant public CURVE_COMPOUND = ICurve(0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56);\n    ICurve constant public CURVE_USDT = ICurve(0x52EA46506B9CC5Ef470C5bf89f17Dc28bB35D85C);\n    ICurve constant public CURVE_Y = ICurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);\n    ICurve constant public CURVE_BINANCE = ICurve(0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27);\n    ICurve constant public CURVE_SYNTHETIX = ICurve(0xA5407eAE9Ba41422680e2e00537571bcC53efBfD);\n    ICurve constant public CURVE_PAX = ICurve(0x06364f10B501e868329afBc005b3492902d6C763);\n    ICurve constant public CURVE_RENBTC = ICurve(0x93054188d876f558f4a66B2EF1d97d16eDf0895B);\n    ICurve constant public CURVE_SBTC = ICurve(0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714);\n\n    function dynarr(IERC20[2] memory tokens) internal pure returns(IERC20[] memory result) {\n        result = new IERC20[](tokens.length);\n        for (uint i = 0; i < tokens.length; i++) {\n            result[i] = tokens[i];\n        }\n    }\n\n    function dynarr(IERC20[3] memory tokens) internal pure returns(IERC20[] memory result) {\n        result = new IERC20[](tokens.length);\n        for (uint i = 0; i < tokens.length; i++) {\n            result[i] = tokens[i];\n        }\n    }\n\n    function dynarr(IERC20[4] memory tokens) internal pure returns(IERC20[] memory result) {\n        result = new IERC20[](tokens.length);\n        for (uint i = 0; i < tokens.length; i++) {\n            result[i] = tokens[i];\n        }\n    }\n}\n\n\ncontract CurveSourceView is OneRouterConstants {\n    using SafeMath for uint256;\n    using UniERC20 for IERC20;\n    using FlagsChecker for uint256;\n\n    ICurveCalculator constant private _CURVE_CALCULATOR = ICurveCalculator(0xc1DB00a8E5Ef7bfa476395cdbcc98235477cDE4E);\n    ICurveRegistry constant private _CURVE_REGISTRY = ICurveRegistry(0x7002B727Ef8F5571Cb5F9D70D13DBEEb4dFAe9d1);\n\n    function _calculateCurveCompound(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_COMPOUND, true, CurveHelper.dynarr([_DAI, _USDC])), address(CurveHelper.CURVE_COMPOUND), 720_000);\n    }\n\n    function _calculateCurveUSDT(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_USDT, true, CurveHelper.dynarr([_DAI, _USDC, _USDT])), address(CurveHelper.CURVE_USDT), 720_000);\n    }\n\n    function _calculateCurveY(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_Y, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _TUSD])), address(CurveHelper.CURVE_Y), 1_400_000);\n    }\n\n    function _calculateCurveBinance(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_BINANCE, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _BUSD])), address(CurveHelper.CURVE_BINANCE), 1_400_000);\n    }\n\n    function _calculateCurveSynthetix(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_SYNTHETIX, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _SUSD])), address(CurveHelper.CURVE_SYNTHETIX), 200_000);\n    }\n\n    function _calculateCurvePAX(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_PAX, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _PAX])), address(CurveHelper.CURVE_PAX), 1_000_000);\n    }\n\n    function _calculateCurveRENBTC(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_RENBTC, false, CurveHelper.dynarr([_RENBTC, _WBTC])), address(CurveHelper.CURVE_RENBTC), 130_000);\n    }\n\n    function _calculateCurveSBTC(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) internal view returns(uint256[] memory rets, address dex, uint256 gas) {\n        return (_calculateCurveSelector(fromToken, swap, amounts, CurveHelper.CURVE_SBTC, false, CurveHelper.dynarr([_RENBTC, _WBTC, _SBTC])), address(CurveHelper.CURVE_SBTC), 150_000);\n    }\n\n    function _calculateCurveSelector(\n        IERC20 fromToken,\n        IOneRouterView.Swap memory swap,\n        uint256[] memory amounts,\n        ICurve curve,\n        bool haveUnderlying,\n        IERC20[] memory tokens\n    ) private view returns(uint256[] memory rets) {\n        rets = new uint256[](amounts.length);\n\n        for (uint t = 0; t < swap.disabledDexes.length; t++) {\n            if (swap.disabledDexes[t] == address(curve)) {\n                return rets;\n            }\n        }\n\n        int128 i = 0;\n        int128 j = 0;\n        for (uint t = 0; t < tokens.length; t++) {\n            if (fromToken == tokens[t]) {\n                i = int128(t + 1);\n            }\n            if (swap.destToken == tokens[t]) {\n                j = int128(t + 1);\n            }\n        }\n\n        if (i == 0 || j == 0) {\n            return rets;\n        }\n\n        bytes memory data = abi.encodePacked(\n            uint256(haveUnderlying ? 1 : 0),\n            uint256(i - 1),\n            uint256(j - 1),\n            _toFixedArray100(amounts)\n        );\n\n        (\n            uint256[8] memory balances,\n            uint256[8] memory precisions,\n            uint256[8] memory rates,\n            uint256 amp,\n            uint256 fee\n        ) = _getCurvePoolInfo(curve, haveUnderlying);\n\n        bool success;\n        (success, data) = address(_CURVE_CALCULATOR).staticcall(\n            abi.encodePacked(\n                abi.encodeWithSelector(\n                    _CURVE_CALCULATOR.get_dy.selector,\n                    tokens.length,\n                    balances,\n                    amp,\n                    fee,\n                    rates,\n                    precisions\n                ),\n                data\n            )\n        );\n\n        if (!success || data.length == 0) {\n            return rets;\n        }\n\n        uint256[100] memory dy = abi.decode(data, (uint256[100]));\n        for (uint t = 0; t < amounts.length; t++) {\n            rets[t] = dy[t];\n        }\n    }\n\n    function _getCurvePoolInfo(\n        ICurve curve,\n        bool haveUnderlying\n    ) private view returns(\n        uint256[8] memory balances,\n        uint256[8] memory precisions,\n        uint256[8] memory rates,\n        uint256 amp,\n        uint256 fee\n    ) {\n        uint256[8] memory underlyingBalances;\n        uint256[8] memory decimals;\n        uint256[8] memory underlyingDecimals;\n\n        (\n            balances,\n            underlyingBalances,\n            decimals,\n            underlyingDecimals,\n            /*address lpToken*/,\n            amp,\n            fee\n        ) = _CURVE_REGISTRY.get_pool_info(address(curve));\n\n        for (uint k = 0; k < 8 && balances[k] > 0; k++) {\n            precisions[k] = 10 ** (18 - (haveUnderlying ? underlyingDecimals : decimals)[k]);\n            if (haveUnderlying) {\n                rates[k] = underlyingBalances[k].mul(1e18).div(balances[k]);\n            } else {\n                rates[k] = 1e18;\n            }\n        }\n    }\n\n    function _toFixedArray100(uint256[] memory values) private pure returns(uint256[100] memory rets) {\n        for (uint i = 0; i < values.length; i++) {\n            rets[i] = values[i];\n        }\n    }\n}\n\n\ncontract CurveSourceSwap is OneRouterConstants {\n    using UniERC20 for IERC20;\n\n    function _swapOnCurveCompound(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        _swapOnCurve(CurveHelper.CURVE_COMPOUND, true, CurveHelper.dynarr([_DAI, _USDC]), fromToken, destToken, amount);\n    }\n\n    function _swapOnCurveUSDT(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        _swapOnCurve(CurveHelper.CURVE_USDT, true, CurveHelper.dynarr([_DAI, _USDC, _USDT]), fromToken, destToken, amount);\n    }\n\n    function _swapOnCurveY(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        _swapOnCurve(CurveHelper.CURVE_Y, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _TUSD]), fromToken, destToken, amount);\n    }\n\n    function _swapOnCurveBinance(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        _swapOnCurve(CurveHelper.CURVE_BINANCE, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _BUSD]), fromToken, destToken, amount);\n    }\n\n    function _swapOnCurveSynthetix(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        _swapOnCurve(CurveHelper.CURVE_SYNTHETIX, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _SUSD]), fromToken, destToken, amount);\n    }\n\n    function _swapOnCurvePAX(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        _swapOnCurve(CurveHelper.CURVE_PAX, true, CurveHelper.dynarr([_DAI, _USDC, _USDT, _PAX]), fromToken, destToken, amount);\n    }\n\n    function _swapOnCurveRENBTC(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        _swapOnCurve(CurveHelper.CURVE_RENBTC, false, CurveHelper.dynarr([_RENBTC, _WBTC]), fromToken, destToken, amount);\n    }\n\n    function _swapOnCurveSBTC(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 /*flags*/) internal {\n        _swapOnCurve(CurveHelper.CURVE_SBTC, false, CurveHelper.dynarr([_RENBTC, _WBTC, _SBTC]), fromToken, destToken, amount);\n    }\n\n    function _swapOnCurve(\n        ICurve curve,\n        bool underlying,\n        IERC20[] memory tokens,\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount\n    ) private {\n        int128 i = 0;\n        int128 j = 0;\n        for (uint t = 0; t < tokens.length; t++) {\n            if (fromToken == tokens[t]) {\n                i = int128(t + 1);\n            }\n            if (destToken == tokens[t]) {\n                j = int128(t + 1);\n            }\n        }\n\n        fromToken.uniApprove(address(curve), amount);\n        if (underlying) {\n            curve.exchange_underlying(i - 1, j - 1, amount, 0);\n        } else {\n            curve.exchange(i - 1, j - 1, amount, 0);\n        }\n    }\n}\n\n\ncontract CurveSourcePublicCompound is ISource, CurveSourceView, CurveSourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateCurveCompound(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnCurveCompound(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract CurveSourcePublicUSDT is ISource, CurveSourceView, CurveSourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateCurveUSDT(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnCurveUSDT(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract CurveSourcePublicY is ISource, CurveSourceView, CurveSourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateCurveY(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnCurveY(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract CurveSourcePublicBinance is ISource, CurveSourceView, CurveSourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateCurveBinance(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnCurveBinance(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract CurveSourcePublicSynthetix is ISource, CurveSourceView, CurveSourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateCurveSynthetix(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnCurveSynthetix(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract CurveSourcePublicPAX is ISource, CurveSourceView, CurveSourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateCurvePAX(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnCurvePAX(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract CurveSourcePublicRENBTC is ISource, CurveSourceView, CurveSourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateCurveRENBTC(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnCurveRENBTC(fromToken, destToken, amount, flags);\n    }\n}\n\n\ncontract CurveSourcePublicSBTC is ISource, CurveSourceView, CurveSourceSwap {\n    function calculate(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap) public view override returns(uint256[] memory rets, address dex, uint256 gas) {\n        return _calculateCurveSBTC(fromToken, amounts, swap);\n    }\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 flags) public override {\n        return _swapOnCurveSBTC(fromToken, destToken, amount, flags);\n    }\n}\n\n// File: contracts/OneRouter.sol\n\n\npragma solidity ^0.6.0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// import \"./sources/BalancerSource.sol\";\n\n\ncontract PathsAdvisor is OneRouterConstants {\n    using UniERC20 for IERC20;\n\n    IAaveRegistry constant private _AAVE_REGISTRY = IAaveRegistry(0xEd8b133B7B88366E01Bb9E38305Ab11c26521494);\n    ICompoundRegistry constant private _COMPOUND_REGISTRY = ICompoundRegistry(0xF451Dbd7Ba14BFa7B1B78A766D3Ed438F79EE1D1);\n\n    function getPathsForTokens(IERC20 fromToken, IERC20 destToken) external view returns(IERC20[][] memory paths) {\n        IERC20[4] memory midTokens = [_DAI, _USDC, _USDT, _WBTC];\n        paths = new IERC20[][](2 + midTokens.length);\n\n        IERC20 aFromToken = _AAVE_REGISTRY.aTokenByToken(fromToken);\n        IERC20 aDestToken = _AAVE_REGISTRY.aTokenByToken(destToken);\n        if (aFromToken != IERC20(0)) {\n            aFromToken = _COMPOUND_REGISTRY.cTokenByToken(fromToken);\n        }\n        if (aDestToken != IERC20(0)) {\n            aDestToken = _COMPOUND_REGISTRY.cTokenByToken(destToken);\n        }\n\n        uint index = 0;\n        paths[index] = new IERC20[](0);\n        index++;\n\n        if (!fromToken.isETH() && !aFromToken.isETH() && !destToken.isETH() && !aDestToken.isETH()) {\n            paths[index] = new IERC20[](1);\n            paths[index][0] = UniERC20.ETH_ADDRESS;\n            index++;\n        }\n\n        for (uint i = 0; i < midTokens.length; i++) {\n            if (fromToken != midTokens[i] && aFromToken != midTokens[i] && destToken != midTokens[i] && aDestToken != midTokens[i]) {\n                paths[index] = new IERC20[](\n                    1 +\n                    ((aFromToken != IERC20(0)) ? 1 : 0) +\n                    ((aDestToken != IERC20(0)) ? 1 : 0)\n                );\n\n                paths[index][0] = aFromToken;\n                paths[index][paths[index].length / 2] = midTokens[i];\n                if (aDestToken != IERC20(0)) {\n                    paths[index][paths[index].length - 1] = aDestToken;\n                }\n                index++;\n            }\n        }\n\n        IERC20[][] memory paths2 = new IERC20[][](index);\n        for (uint i = 0; i < paths2.length; i++) {\n            paths2[i] = paths[i];\n        }\n        paths = paths2;\n    }\n}\n\n\ncontract HotSwapSources is Ownable {\n    uint256 public sourcesCount = 15;\n    mapping(uint256 => ISource) public sources;\n    PathsAdvisor public pathsAdvisor;\n\n    constructor() public {\n        pathsAdvisor = new PathsAdvisor();\n    }\n\n    function setSource(uint256 index, ISource source) external onlyOwner {\n        require(index <= sourcesCount, \"Router: index is too high\");\n        sources[index] = source;\n        sourcesCount = Math.max(sourcesCount, index + 1);\n    }\n\n    function setPathsForTokens(PathsAdvisor newPathsAdvisor) external onlyOwner {\n        pathsAdvisor = newPathsAdvisor;\n    }\n\n    function _getPathsForTokens(IERC20 fromToken, IERC20 destToken) internal view returns(IERC20[][] memory paths) {\n        return pathsAdvisor.getPathsForTokens(fromToken, destToken);\n    }\n}\n\n\ncontract OneRouterView is\n    OneRouterConstants,\n    IOneRouterView,\n    HotSwapSources,\n    UniswapV1SourceView,\n    UniswapV2SourceView,\n    MooniswapSourceView,\n    KyberSourceView,\n    CurveSourceView\n    // BalancerSourceView\n{\n    using UniERC20 for IERC20;\n    using SafeMath for uint256;\n    using FlagsChecker for uint256;\n    using DynamicMemoryArray for DynamicMemoryArray.Addresses;\n\n    function getReturn(IERC20 fromToken, uint256[] memory amounts, Swap memory swap)\n        public\n        view\n        override\n        returns(\n            Path[] memory paths,\n            PathResult[] memory pathResults,\n            SwapResult memory splitResult\n        )\n    {\n        IERC20[][] memory midTokens = _getPathsForTokens(fromToken, swap.destToken);\n\n        paths = new Path[](midTokens.length);\n        pathResults = new PathResult[](paths.length);\n        DynamicMemoryArray.Addresses memory disabledDexes;\n        for (uint i = 0; i < paths.length; i++) {\n            paths[i] = Path({swaps: new Swap[](1 + midTokens[i - 1].length)});\n            for (uint j = 0; j < midTokens[i - 1].length; j++) {\n                if (fromToken == midTokens[i - 1][j] || swap.destToken == midTokens[i - 1][j]) {\n                    paths[i] = Path({swaps: new Swap[](1)});\n                    break;\n                }\n\n                paths[i].swaps[j] = Swap({\n                    destToken: midTokens[i - 1][j],\n                    flags: swap.flags,\n                    destTokenEthPriceTimesGasPrice: _scaleDestTokenEthPriceTimesGasPrice(fromToken, midTokens[i - 1][j], swap.destTokenEthPriceTimesGasPrice),\n                    disabledDexes: disabledDexes.copy()\n                });\n            }\n            paths[i].swaps[paths[i].swaps.length - 1] = swap;\n\n            pathResults[i] = getPathReturn(fromToken, amounts, paths[i]);\n            for (uint j = 0; j < pathResults[i].swaps.length; j++) {\n                for (uint k = 0; k < pathResults[i].swaps[j].dexes.length; k++) {\n                    for (uint t = 0; t < pathResults[i].swaps[j].dexes[k].length; t++) {\n                        if (pathResults[i].swaps[j].dexes[k][t] != address(0)) {\n                            disabledDexes.push(pathResults[i].swaps[j].dexes[k][t]);\n                        }\n                    }\n                }\n            }\n        }\n\n        splitResult = bestDistributionAmongPaths(paths, pathResults);\n    }\n\n    function getMultiPathReturn(IERC20 fromToken, uint256[] memory amounts, Path[] memory paths)\n        public\n        view\n        override\n        returns(\n            PathResult[] memory pathResults,\n            SwapResult memory splitResult\n        )\n    {\n        pathResults = new PathResult[](paths.length);\n        for (uint i = 0; i < paths.length; i++) {\n            pathResults[i] = getPathReturn(fromToken, amounts, paths[i]);\n        }\n        splitResult = bestDistributionAmongPaths(paths, pathResults);\n    }\n\n    function bestDistributionAmongPaths(Path[] memory paths, PathResult[] memory pathResults) public pure returns(SwapResult memory) {\n        uint256[][] memory input = new uint256[][](paths.length);\n        uint256[][] memory gases = new uint256[][](paths.length);\n        uint256[][] memory costs = new uint256[][](paths.length);\n        for (uint i = 0; i < pathResults.length; i++) {\n            Swap memory subSwap = paths[i].swaps[paths[i].swaps.length - 1];\n            SwapResult memory swapResult = pathResults[i].swaps[pathResults[i].swaps.length - 1];\n\n            input[i] = new uint256[](swapResult.returnAmounts.length);\n            gases[i] = new uint256[](swapResult.returnAmounts.length);\n            costs[i] = new uint256[](swapResult.returnAmounts.length);\n            for (uint j = 0; j < swapResult.returnAmounts.length; j++) {\n                input[i][j] = swapResult.returnAmounts[j];\n                gases[i][j] = swapResult.estimateGasAmounts[j];\n                costs[i][j] = swapResult.estimateGasAmounts[j].mul(subSwap.destTokenEthPriceTimesGasPrice).div(1e18);\n            }\n        }\n        return _findBestDistribution(input, costs, gases, input[0].length);\n    }\n\n    function getPathReturn(IERC20 fromToken, uint256[] memory amounts, Path memory path)\n        public\n        view\n        override\n        returns(PathResult memory result)\n    {\n        result.swaps = new SwapResult[](path.swaps.length);\n\n        for (uint i = 0; i < path.swaps.length; i++) {\n            result.swaps[i] = getSwapReturn(fromToken, amounts, path.swaps[i]);\n            fromToken = path.swaps[i].destToken;\n            amounts = result.swaps[i].returnAmounts;\n        }\n    }\n\n    function getSwapReturn(IERC20 fromToken, uint256[] memory amounts, Swap memory swap)\n        public\n        view\n        override\n        returns(SwapResult memory result)\n    {\n        if (fromToken == swap.destToken) {\n            result.returnAmounts = amounts;\n            return result;\n        }\n\n        function(IERC20,uint256[] memory,Swap memory) view returns(uint256[] memory, address, uint256)[15] memory reserves = [\n            _calculateUniswapV1,\n            _calculateUniswapV2,\n            _calculateMooniswap,\n            _calculateKyber1,\n            _calculateKyber2,\n            _calculateKyber3,\n            _calculateKyber4,\n            _calculateCurveCompound,\n            _calculateCurveUSDT,\n            _calculateCurveY,\n            _calculateCurveBinance,\n            _calculateCurveSynthetix,\n            _calculateCurvePAX,\n            _calculateCurveRENBTC,\n            _calculateCurveSBTC\n            // _calculateBalancer1,\n            // _calculateBalancer2,\n            // _calculateBalancer3,\n            // calculateBancor,\n            // calculateOasis,\n            // calculateDforceSwap,\n            // calculateShell,\n            // calculateMStableMUSD,\n            // calculateBlackHoleSwap\n        ];\n\n        uint256[][] memory input = new uint256[][](sourcesCount);\n        uint256[][] memory gases = new uint256[][](sourcesCount);\n        uint256[][] memory costs = new uint256[][](sourcesCount);\n        bool disableAll = swap.flags.check(_FLAG_DISABLE_ALL_SOURCES);\n        for (uint i = 0; i < sourcesCount; i++) {\n            uint256 gas;\n            if (disableAll == swap.flags.check(1 << i)) {\n                if (sources[i] != ISource(0)) {\n                    (input[i], , gas) = sources[i].calculate(fromToken, amounts, swap);\n                }\n                else if (i < reserves.length) {\n                    (input[i], , gas) = reserves[i](fromToken, amounts, swap);\n                }\n            }\n\n            gases[i] = new uint256[](amounts.length);\n            costs[i] = new uint256[](amounts.length);\n            uint256 fee = gas.mul(swap.destTokenEthPriceTimesGasPrice).div(1e18);\n            for (uint j = 0; j < amounts.length; j++) {\n                gases[i][j] = gas;\n                costs[i][j] = fee;\n            }\n        }\n\n        result = _findBestDistribution(input, costs, gases, amounts.length);\n    }\n\n    function _calculateNoReturn(IERC20 fromToken, uint256[] memory amounts, IOneRouterView.Swap memory swap)\n        private view returns(uint256[] memory rets, uint256 gas)\n    {\n    }\n\n    function _scaleDestTokenEthPriceTimesGasPrice(IERC20 fromToken, IERC20 destToken, uint256 destTokenEthPriceTimesGasPrice) private view returns(uint256) {\n        if (fromToken == destToken) {\n            return destTokenEthPriceTimesGasPrice;\n        }\n\n        uint256 mul = _cheapGetPrice(UniERC20.ETH_ADDRESS, destToken, 0.001 ether);\n        uint256 div = _cheapGetPrice(UniERC20.ETH_ADDRESS, fromToken, 0.001 ether);\n        return (div == 0) ? 0 : destTokenEthPriceTimesGasPrice.mul(mul).div(div);\n    }\n\n    function _cheapGetPrice(IERC20 fromToken, IERC20 destToken, uint256 amount) private view returns(uint256 returnAmount) {\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        uint256 flags = _FLAG_DISABLE_RECALCULATION |\n            _FLAG_DISABLE_ALL_SOURCES |\n            _FLAG_DISABLE_UNISWAP_V1 |\n            _FLAG_DISABLE_UNISWAP_V2;\n\n        return this.getSwapReturn(\n            fromToken,\n            amounts,\n            Swap({\n                destToken: destToken,\n                flags: flags,\n                destTokenEthPriceTimesGasPrice: 0,\n                disabledDexes: new address[](0)\n            })\n        ).returnAmounts[0];\n    }\n\n    function _findBestDistribution(uint256[][] memory input, uint256[][] memory costs, uint256[][] memory gases, uint256 parts)\n        private pure returns(SwapResult memory result)\n    {\n        int256[][] memory matrix = new int256[][](input.length);\n        for (uint i = 0; i < input.length; i++) {\n            matrix[i] = new int256[](1 + parts);\n            matrix[i][0] = Algo.VERY_NEGATIVE_VALUE;\n            for (uint j = 0; j < parts; j++) {\n                matrix[i][j + 1] =\n                    (j < input[i].length && input[i][j] != 0)\n                    ? int256(input[i][j]) - int256(costs[i][j])\n                    : Algo.VERY_NEGATIVE_VALUE;\n            }\n        }\n\n        (, result.distributions) = Algo.findBestDistribution(matrix, parts);\n\n        result.returnAmounts = new uint256[](parts);\n        result.estimateGasAmounts = new uint256[](parts);\n        for (uint i = 0; i < input.length; i++) {\n            for (uint j = 0; j < parts; j++) {\n                if (result.distributions[j][i] > 0) {\n                    uint256 index = result.distributions[j][i] - 1;\n                    result.returnAmounts[j] = result.returnAmounts[j].add(index < input[i].length ? input[i][index] : 0);\n                    result.estimateGasAmounts[j] = result.estimateGasAmounts[j].add(gases[i][j]);\n                }\n            }\n        }\n    }\n}\n\n\ncontract OneRouter is\n    OneRouterConstants,\n    IOneRouter,\n    HotSwapSources,\n    UniswapV1SourceSwap,\n    UniswapV2SourceSwap,\n    MooniswapSourceSwap,\n    KyberSourceSwap,\n    CurveSourceSwap\n    // BalancerSourceSwap\n{\n    using UniERC20 for IERC20;\n    using SafeMath for uint256;\n    using Address2 for address;\n    using FlagsChecker for uint256;\n\n    IOneRouterView public oneRouterView;\n\n    constructor(IOneRouterView _oneRouterView) public {\n        oneRouterView = _oneRouterView;\n    }\n\n    receive() external payable {\n        // solhint-disable-next-line avoid-tx-origin\n        require(msg.sender != tx.origin, \"ETH deposit rejected\");\n    }\n\n    function getReturn(\n        IERC20 fromToken,\n        uint256[] calldata amounts,\n        Swap calldata swap\n    )\n        external\n        view\n        override\n        returns(\n            Path[] memory paths,\n            PathResult[] memory pathResults,\n            SwapResult memory splitResult\n        )\n    {\n        return oneRouterView.getReturn(fromToken, amounts, swap);\n    }\n\n    function getSwapReturn(\n        IERC20 fromToken,\n        uint256[] calldata amounts,\n        Swap calldata swap\n    )\n        external\n        view\n        override\n        returns(SwapResult memory result)\n    {\n        return oneRouterView.getSwapReturn(fromToken, amounts, swap);\n    }\n\n    function getPathReturn(\n        IERC20 fromToken,\n        uint256[] calldata amounts,\n        Path calldata path\n    )\n        external\n        view\n        override\n        returns(PathResult memory result)\n    {\n        return oneRouterView.getPathReturn(fromToken, amounts, path);\n    }\n\n    function getMultiPathReturn(\n        IERC20 fromToken,\n        uint256[] calldata amounts,\n        Path[] calldata paths\n    )\n        external\n        view\n        override\n        returns(\n            PathResult[] memory pathResults,\n            SwapResult memory splitResult\n        )\n    {\n        return oneRouterView.getMultiPathReturn(fromToken, amounts, paths);\n    }\n\n    function makeSwap(\n        SwapInput memory input,\n        Swap memory swap,\n        SwapDistribution memory swapDistribution\n    )\n        public\n        payable\n        override\n        returns(uint256 returnAmount)\n    {\n        Path memory path = Path({\n            swaps: new IOneRouterView.Swap[](1)\n        });\n        path.swaps[0] = swap;\n\n        PathDistribution memory pathDistribution = PathDistribution({\n            swapDistributions: new SwapDistribution[](1)\n        });\n        pathDistribution.swapDistributions[0] = swapDistribution;\n\n        return makePathSwap(input, path, pathDistribution);\n    }\n\n    function makePathSwap(\n        SwapInput memory input,\n        Path memory path,\n        PathDistribution memory pathDistribution\n    )\n        public\n        payable\n        override\n        returns(uint256 returnAmount)\n    {\n        Path[] memory paths = new Path[](1);\n        paths[0] = path;\n\n        PathDistribution[] memory pathDistributions = new PathDistribution[](1);\n        pathDistributions[0] = pathDistribution;\n\n        SwapDistribution memory swapDistribution = SwapDistribution({\n            weights: new uint256[](1)\n        });\n        swapDistribution.weights[0] = 1;\n\n        return makeMultiPathSwap(input, paths, pathDistributions, swapDistribution);\n    }\n\n    struct Indexes {\n        uint p; // path\n        uint s; // swap\n        uint i; // index\n    }\n\n    function makeMultiPathSwap(\n        SwapInput memory input,\n        Path[] memory paths,\n        PathDistribution[] memory pathDistributions,\n        SwapDistribution memory interPathsDistribution\n    )\n        public\n        payable\n        override\n        returns(uint256 returnAmount)\n    {\n        require(msg.value == (input.fromToken.isETH() ? input.amount : 0), \"Wrong msg.value\");\n        require(paths.length == pathDistributions.length, \"Wrong arrays length\");\n        require(paths.length == interPathsDistribution.weights.length, \"Wrong arrays length\");\n\n        input.fromToken.uniTransferFromSender(address(this), input.amount);\n\n        function(IERC20,IERC20,uint256,uint256)[15] memory reserves = [\n            _swapOnUniswapV1,\n            _swapOnUniswapV2,\n            _swapOnMooniswap,\n            _swapOnKyber1,\n            _swapOnKyber2,\n            _swapOnKyber3,\n            _swapOnKyber4,\n            _swapOnCurveCompound,\n            _swapOnCurveUSDT,\n            _swapOnCurveY,\n            _swapOnCurveBinance,\n            _swapOnCurveSynthetix,\n            _swapOnCurvePAX,\n            _swapOnCurveRENBTC,\n            _swapOnCurveSBTC\n            // _swapOnBalancer1,\n            // _swapOnBalancer2,\n            // _swapOnBalancer3,\n            // _swapOnBancor,\n            // _swapOnOasis,\n            // _swapOnDforceSwap,\n            // _swapOnShell,\n            // _swapOnMStableMUSD,\n            // _swapOnBlackHoleSwap\n        ];\n\n        uint256 interTotalWeight = 0;\n        for (uint i = 0; i < interPathsDistribution.weights.length; i++) {\n            interTotalWeight = interTotalWeight.add(interPathsDistribution.weights[i]);\n        }\n\n        Indexes memory z;\n        for (z.p = 0; z.p < pathDistributions.length && interTotalWeight > 0; z.p++) {\n            uint256 confirmed = input.fromToken.uniBalanceOf(address(this))\n                    .mul(interPathsDistribution.weights[z.p])\n                    .div(interTotalWeight);\n            interTotalWeight = interTotalWeight.sub(interPathsDistribution.weights[z.p]);\n\n            IERC20 token = input.fromToken;\n            for (z.s = 0; z.s < pathDistributions[z.p].swapDistributions.length; z.s++) {\n                uint256 totalSwapWeight = 0;\n                for (z.i = 0; z.i < pathDistributions[z.p].swapDistributions[z.s].weights.length; z.i++) {\n                    totalSwapWeight = totalSwapWeight.add(pathDistributions[z.p].swapDistributions[z.s].weights[z.i]);\n                }\n\n                for (z.i = 0; z.i < pathDistributions[z.p].swapDistributions[z.s].weights.length && totalSwapWeight > 0; z.i++) {\n                    uint256 amount = ((z.s == 0) ? confirmed : token.uniBalanceOf(address(this)))\n                        .mul(pathDistributions[z.p].swapDistributions[z.s].weights[z.i])\n                        .div(totalSwapWeight);\n                    totalSwapWeight = totalSwapWeight.sub(pathDistributions[z.p].swapDistributions[z.s].weights[z.i]);\n\n                    if (sources[z.i] != ISource(0)) {\n                        address(sources[z.i]).functionDelegateCall(\n                            abi.encodeWithSelector(\n                                sources[z.i].swap.selector,\n                                input.fromToken,\n                                input.destToken,\n                                amount,\n                                paths[z.p].swaps[z.s].flags\n                            ),\n                            \"Delegatecall failed\"\n                        );\n                    }\n                    else if (z.i < reserves.length) {\n                        reserves[z.i](input.fromToken, input.destToken, amount, paths[z.p].swaps[z.s].flags);\n                    }\n                }\n\n                token = paths[z.p].swaps[z.s].destToken;\n            }\n        }\n\n        uint256 remaining = input.fromToken.uniBalanceOf(address(this));\n        returnAmount = input.destToken.uniBalanceOf(address(this));\n        require(returnAmount >= input.minReturn, \"Min returns is not enough\");\n        input.fromToken.uniTransfer(msg.sender, remaining);\n        input.destToken.uniTransfer(msg.sender, returnAmount);\n    }\n}\n"}}}