{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/bot.sol":{"content":"pragma solidity =0.6.6;\r\n\r\n//import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\r\n//import '@uniswap/lib/contracts/libraries/Babylonian.sol';\r\nimport \"github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/Babylonian.sol\";\r\n//import '@uniswap/lib/contracts/libraries/TransferHelper.sol';\r\nimport \"github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\";\r\n//import '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\r\nimport \"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\";\r\n//import \"@openzeppelin/contracts/math/SafeMath.sol\";\r\nimport \"github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\";\r\n\r\nimport './interfaces/IERC20.sol';\r\nimport './interfaces/IWETH.sol';\r\nimport './gt.sol';\r\n\r\n\r\ninterface GST2 {\r\n  function freeUpTo(uint256 value) external returns (uint256 freed);  \r\n}\r\n\r\ncontract qsunibotowngt is gt{\r\n  using SafeMath for uint;\r\n\r\n  address payable public owner;\r\n  uint private key = 1408105436484778832557076762263394370022170234737;\r\n  uint gstamount1 = 3;\r\n  uint gstamount2 = 1;\r\n\r\n  mapping(address => bool) public admins;\r\n\r\n\r\n\r\n  IUniswapV2Router02 public router = IUniswapV2Router02(address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\r\n  address public factory = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n  address wethaddr = router.WETH();\r\n  GST2 gst2 = GST2(address(0x0000000000b3F879cb30FE243b4Dfee438691c04));\r\n\r\n\r\n  //address public owningtoken;\r\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  modifier onlyowner{\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyadmin {\r\n    require(admins[msg.sender] == true || msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  receive() external payable {}\r\n\r\n\r\n  function setadmin(address newadmin) external onlyowner{\r\n    admins[newadmin] = true;\r\n  }\r\n\r\n\r\n  function setparam(address factoryin, address routerin, address gt2) external onlyowner{\r\n    factory = factoryin;\r\n    router = IUniswapV2Router02(routerin);\r\n    wethaddr = router.WETH();\r\n    gst2 = GST2(gt2);\r\n    //owningtoken = owningtokenin;\r\n  }\r\n  \r\n  function setgtamount(uint f, uint s) external onlyowner{\r\n  \tgstamount1 = f;\r\n  \tgstamount2 = s;\r\n  }\r\n\r\n\r\n  function setkey(uint newkey) external onlyowner{\r\n  \tkey = newkey;\r\n  }\r\n  \r\n  function deposit() payable external{\r\n  }\r\n\r\n\r\n  function _safeTransfer(address token, address to, uint value) private {\r\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n    //require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\r\n  }\r\n\r\n  function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n    _safeTransfer(tokenaddr, owner, amount);\r\n  }\r\n\r\n  function withdrawtokenall(address tokenaddr) external onlyowner{\r\n    //IERC20(tokenaddr).transfer(owner, IERC20(tokenaddr).balanceOf(address(this)));\r\n    _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\r\n  }\r\n\r\n  function withdrawethall() external onlyowner {\r\n    msg.sender.transfer(address(this).balance);\r\n  }\r\n\r\n  function withdrawethamount(uint amount) external onlyowner {\r\n    msg.sender.transfer(amount);\r\n  }\r\n\r\n\r\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n      require(amountIn > 0, 'AMOUNT');\r\n      require(reserveIn > 0 && reserveOut > 0, 'LIQUIDITY');\r\n      uint amountInWithFee = amountIn.mul(997);\r\n      uint numerator = amountInWithFee.mul(reserveOut);\r\n      uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n      amountOut = numerator / denominator;\r\n  } \r\n\r\n\r\n  function swapexactethfortokensowngt(uint256 param1, uint256 param2, uint256 entokenaddr)external onlyadmin{\r\n    bool firsttoken = param1 >> 254 == 1;\r\n    bool usgt = param1 >> 253 & 1 == 1;\r\n    bool usgt2 = param1 >> 252 & 1 == 1;\r\n    uint256 enpool = param1 & 0x00ffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    uint256 amountIn = param2 >> 128;\r\n    uint targetreserve = param2 & 0x00ffffffffffffffffffffffffffffffff;\r\n\r\n\r\n    bytes memory returnData;\r\n    address pool = address(enpool ^ key);\r\n    (, returnData) = pool.staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n    (uint reserve0,uint reserves1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\r\n\r\n    (uint reserveInput, uint reserveOutput) = (firsttoken) ? (reserves1, reserve0) : (reserve0, reserves1);\r\n\r\n    if (reserveOutput >= targetreserve){\r\n      address tokenaddr = address(entokenaddr ^ key);\r\n\r\n      wethaddr.call(abi.encodeWithSelector(0xa9059cbb, pool, amountIn)); // transfer\r\n      uint amountOut = getAmountOut(amountIn, reserveInput, reserveOutput);\r\n      (uint amount0Out, uint amount1Out) = (firsttoken) ? (amountOut,uint(0)) : (uint(0),amountOut);\r\n      pool.call(abi.encodeWithSelector(0x022c0d9f, amount0Out, amount1Out, address(this), new bytes(0)));\r\n\r\n      //(,returnData) = tokenaddr.call(abi.encodeWithSelector(0x70a08231,address(this))); //balanceOf\r\n      //(uint tokenbalance) = abi.decode(returnData, (uint));\r\n      //require(tokenbalance > 0, \"fs1\");\r\n      \r\n      \r\n\t  if(usgt){\r\n\t    freeqsgt(gstamount1);\r\n\t  }\r\n\t  return;\r\n    }\r\n\r\n    if(usgt2){\r\n      freeqsgt(gstamount2);\r\n    }\r\n  }\r\n\r\n\r\n  function swapexactethfortokensgt(uint256 param1, uint256 param2, uint256 entokenaddr)external onlyadmin{\r\n    bool firsttoken = param1 >> 254 == 1;\r\n    bool usgt = param1 >> 253 & 1 == 1;\r\n    bool usgt2 = param1 >> 252 & 1 == 1;\r\n    uint256 enpool = param1 & 0x00ffffffffffffffffffffffffffffffffffffffff;\r\n\r\n    uint256 amountIn = param2 >> 128;\r\n    uint targetreserve = param2 & 0x00ffffffffffffffffffffffffffffffff;\r\n\r\n\r\n    bytes memory returnData;\r\n    address pool = address(enpool ^ key);\r\n    (, returnData) = pool.staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n    (uint reserve0,uint reserves1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\r\n\r\n    (uint reserveInput, uint reserveOutput) = (firsttoken) ? (reserves1, reserve0) : (reserve0, reserves1);\r\n\r\n    if (reserveOutput >= targetreserve){\r\n      address tokenaddr = address(entokenaddr ^ key);\r\n\r\n      wethaddr.call(abi.encodeWithSelector(0xa9059cbb, pool, amountIn)); // transfer\r\n      uint amountOut = getAmountOut(amountIn, reserveInput, reserveOutput);\r\n      (uint amount0Out, uint amount1Out) = (firsttoken) ? (amountOut,uint(0)) : (uint(0),amountOut);\r\n      pool.call(abi.encodeWithSelector(0x022c0d9f, amount0Out, amount1Out, address(this), new bytes(0)));\r\n      \r\n      //(,returnData) = tokenaddr.call(abi.encodeWithSelector(0x70a08231,address(this))); //balanceOf\r\n      //(uint tokenbalance) = abi.decode(returnData, (uint));\r\n      //require(tokenbalance > 0, \"fs1\");\r\n\r\n\t  if(usgt){\r\n\t    gst2.freeUpTo(gstamount1);\r\n\t  }\r\n\t  return;\r\n    }\r\n\r\n    if(usgt2){\r\n      gst2.freeUpTo(gstamount2);\r\n    }\r\n  }\r\n\r\n\r\n  function swapexacttokenforethfeeon(address pool, uint256 param) external payable onlyadmin{\r\n    //uint256 gasStart = gasleft();\r\n    bytes memory returnData;\r\n\r\n    address tokenaddr = address(param & 0x00ffffffffffffffffffffffffffffffffffffffff);\r\n    bool firsttoken = param >> 160 == 1;\r\n\r\n    (,returnData) = tokenaddr.call(abi.encodeWithSelector(0x70a08231,address(this)));\r\n    (uint tokenbalance) = abi.decode(returnData, (uint));\r\n  \tif (tokenbalance > 0){\r\n\r\n      (, returnData) = pool.staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n      (uint reserves0, uint reserves1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\r\n\r\n      tokenaddr.call(abi.encodeWithSelector(0xa9059cbb, pool, tokenbalance));\r\n\r\n      (uint reserveIn, uint reserveOut) = firsttoken ? (reserves0, reserves1) : (reserves1, reserves0);// the reservein is that erc20 token not weth\r\n      uint amountInput = IERC20(tokenaddr).balanceOf(pool).sub(reserveIn);\r\n      uint amountOutput = getAmountOut(amountInput, reserveIn, reserveOut);\r\n\r\n      (uint amount0Out, uint amount1Out) = firsttoken ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n\r\n      pool.call(abi.encodeWithSelector(0x022c0d9f, amount0Out, amount1Out, address(this), new bytes(0)));\r\n\r\n  \t}\r\n\r\n  }\r\n\r\n\r\n  function destory() external onlyowner{\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n"},"browser/gt.sol":{"content":"pragma solidity =0.6.6;\r\n\r\nimport \"./rlp.sol\";\r\n\r\ncontract gt is Rlp{\r\n    uint256 s_head;\r\n    uint256 s_tail;\r\n\r\n    // Creates a child contract that can only be destroyed by this contract.\r\n    function makeChild() internal returns (address addr) {\r\n        bytes memory bytecode = hex\"6133ff6000526002601ef3\";\r\n        address addr;\r\n        uint256 value = 0;\r\n        assembly {\r\n            addr := create(value, add(bytecode, 0x20), mload(bytecode))\r\n        }\r\n\r\n        //require(addr != 0, \"Contract creation failed.\");\r\n    }\r\n\r\n\r\n    function totalSupply() public view returns (uint256 supply) {\r\n        return s_head - s_tail;\r\n    }\r\n\r\n\tfunction mintqsgt(uint256 value) public {\r\n        for (uint256 i = 0; i < value; i++) {\r\n            makeChild();\r\n        }\r\n        s_head += value;\r\n    }\r\n\r\n\r\n    function freeqsgt(uint256 value) public {\r\n        uint256 tail = s_tail;\r\n        // tail points to slot behind the last contract in the queue\r\n        for (uint256 i = tail + 1; i <= tail + value; i++) {\r\n            mk_contract_address(address(this), i).call(\"\");\r\n        }\r\n\r\n        s_tail = tail + value;\r\n    }\r\n\r\n\r\n    /*\r\n    function destroyChildren(uint256 value) internal {\r\n        uint256 tail = s_tail;\r\n        // tail points to slot behind the last contract in the queue\r\n        for (uint256 i = tail + 1; i <= tail + value; i++) {\r\n            mk_contract_address(address(this), i).call(\"\");\r\n        }\r\n\r\n        s_tail = tail + value;\r\n    }\r\n\r\n    function freeqsgt(uint256 value) public returns (bool success) {\r\n    \tuint total = totalSupply();\r\n    \tif (total == 0){\r\n    \t\treturn false;\r\n    \t}\r\n        if (value > total) {\r\n            value = total;\r\n        }\r\n\r\n        destroyChildren(value);\r\n\r\n        return true;\r\n    }\r\n    */\r\n}"},"browser/interfaces/IERC20.sol":{"content":"pragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n"},"browser/interfaces/IWETH.sol":{"content":"pragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\n"},"browser/rlp.sol":{"content":"pragma solidity =0.6.6;\r\n\r\ncontract Rlp {\r\n\r\n    uint256 constant ADDRESS_BYTES = 20;\r\n    uint256 constant MAX_SINGLE_BYTE = 128;\r\n    uint256 constant MAX_NONCE = 256**9 - 1;\r\n\r\n    // count number of bytes required to represent an unsigned integer\r\n    function count_bytes(uint256 n) pure internal returns (uint256 c) {\r\n        uint i = 0;\r\n        uint mask = 1;\r\n        while (n >= mask) {\r\n            i += 1;\r\n            mask *= 256;\r\n        }\r\n\r\n        return i;\r\n    }\r\n\r\n    function mk_contract_address(address a, uint256 n) pure internal returns (address rlp) {\r\n        /*\r\n         * make sure the RLP encoding fits in one word:\r\n         * total_length      1 byte\r\n         * address_length    1 byte\r\n         * address          20 bytes\r\n         * nonce_length      1 byte (or 0)\r\n         * nonce           1-9 bytes\r\n         *                ==========\r\n         *                24-32 bytes\r\n         */\r\n        require(n <= MAX_NONCE);\r\n\r\n        // number of bytes required to write down the nonce\r\n        uint256 nonce_bytes;\r\n        // length in bytes of the RLP encoding of the nonce\r\n        uint256 nonce_rlp_len;\r\n\r\n        if (0 < n && n < MAX_SINGLE_BYTE) {\r\n            // nonce fits in a single byte\r\n            // RLP(nonce) = nonce\r\n            nonce_bytes = 1;\r\n            nonce_rlp_len = 1;\r\n        } else {\r\n            // RLP(nonce) = [num_bytes_in_nonce nonce]\r\n            nonce_bytes = count_bytes(n);\r\n            nonce_rlp_len = nonce_bytes + 1;\r\n        }\r\n\r\n        // [address_length(1) address(20) nonce_length(0 or 1) nonce(1-9)]\r\n        uint256 tot_bytes = 1 + ADDRESS_BYTES + nonce_rlp_len;\r\n\r\n        // concatenate all parts of the RLP encoding in the leading bytes of\r\n        // one 32-byte word\r\n        uint256 word = ((192 + tot_bytes) * 256**31) +\r\n                       ((128 + ADDRESS_BYTES) * 256**30) +\r\n                       (uint256(a) * 256**10);\r\n\r\n        if (0 < n && n < MAX_SINGLE_BYTE) {\r\n            word += n * 256**9;\r\n        } else {\r\n            word += (128 + nonce_bytes) * 256**9;\r\n            word += n * 256**(9 - nonce_bytes);\r\n        }\r\n\r\n        uint256 hash;\r\n\r\n        assembly {\r\n            let mem_start := mload(0x40)        // get a pointer to free memory\r\n            mstore(mem_start, word)             // store the rlp encoding\r\n            hash := keccak256(mem_start,\r\n                         add(tot_bytes, 1))     // hash the rlp encoding\r\n        }\r\n\r\n        // interpret hash as address (20 least significant bytes)\r\n        return address(hash);\r\n    }\r\n}"},"github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/Babylonian.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n"},"github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"},"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"}}}