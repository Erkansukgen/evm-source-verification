{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/new399.sol": {
      "content": "pragma solidity >=0.4.16 <0.7.0;\n\nlibrary SafeMath {\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Register  {\n    \n    using SafeMath for *;\n    uint256 public id;\n    uint256 public deposit;\n    address private owner;\n\n    struct AddressList{\n        uint256 id;\n        address user;\n     //   string mat;\n        \n    }\n    \n    struct Account {\n    address referrer;\n    uint256 joinCount;\n    uint256 referredCount;\n    uint256 depositTotal;\n    uint256 joinDate;\n    uint256 withdrawHis;\n    uint256 currentCReward;\n    uint256 currentCUpdatetime;\n    uint256 championReward;\n    uint256 cWithdrawTime;\n    uint256 isAdminAccount;\n    }\n    \n    struct CheckIn{\n    address user;\n    uint256 totalCheck;\n    uint256 amt;\n    uint256 checkTime;\n    uint256 dynamic;\n    }\n\n    struct Limit{\n        uint256 special;\n    }\n    \n    struct RewardWinner{\n    uint256 winId;\n    uint256 time;\n    address winner;\n    uint256 totalRefer;\n    uint256 winPayment;\n    }\n    \n    mapping (address => uint256) public balanceOf;\n    mapping (uint256 => RewardWinner) internal rewardHistory;\n    mapping (address => Account) public accounts;\n    mapping (address => CheckIn) public loginCount;\n    mapping (uint256 => AddressList) public idList;\n    mapping (address => AddressList) public userList;\n    mapping (address => Limit) public limitList;\n    \n    event RegisteredReferer(address referee, address referrer);\n    event RegisteredRefererRejoin(address referee, address referrer);\n    event RegisteredRefererFailed(address referee, address referrer);\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    modifier isNotRegister(address _user) {\n        require(userList[_user].user==address(0), \"Address registered!\");\n        _;\n    }\n    \n    modifier isCorrectAddress(address _user) {\n        require(_user !=address(0), \"Invalid Address!\");\n        _;\n    }\n    \n    modifier isNotReferrer(address currentUser,address user) {\n        require(currentUser !=user, \"Referrer cannot register as its own Referee\");\n       \n        _;\n    }\n    modifier hasReferrer(address _user) {\n        require(accounts[_user].referrer !=address(0), \"Referee has registered!\");\n        _;\n    }\n    \n    modifier isRegister(address _user) {\n        require(userList[_user].user!=address(0), \"Address not register!\");\n        _;\n    }\n    \n    modifier hasDepositTotal(address _user) {\n        require(accounts[_user].depositTotal>=0.5 ether, \"No Deposit!\");\n        _;\n    }\n    \n    modifier hasCReward() {\n        require(accounts[msg.sender].currentCReward>0, \"No Champion Reward!\");\n        _;\n    }\n    constructor() public {\n        owner = msg.sender;\n        emit OwnerSet(address(0), owner);\n    }\n    \n    function() external payable {\n        require(accounts[msg.sender].joinCount<0,\"Invalid Join\");\n        revert();\n    }\n    \n    function newReg(address referrer) public \n    isCorrectAddress(msg.sender) isRegister(referrer) isNotReferrer(msg.sender,referrer) \n    payable returns (bool){\n          require(checkJoinAmt(msg.sender,msg.value),\"Invalid participation deposit\");\n    if(checkJoinCount(msg.sender)==0 && checkJoinAmt(msg.sender,msg.value)){\n          require(userList[msg.sender].user==address(0), \"User registered!\");\n          deposit=deposit.add(msg.value);\n          accounts[msg.sender].joinCount=checkJoinCount(msg.sender);\n          accounts[msg.sender].referrer = referrer;\n          accounts[msg.sender].depositTotal = msg.value;\n          accounts[referrer].referredCount = accounts[referrer].referredCount.add(1);\n          accounts[msg.sender].joinDate=getTime();\n          id++;\n          userList[msg.sender].id = id;\n          userList[msg.sender].user=msg.sender;\n          idList[id].id = id;\n          idList[id].user=msg.sender;\n          loginCount[msg.sender].user=msg.sender;\n          emit RegisteredReferer(msg.sender, referrer);\n          return true;\n    }else if(checkJoinCount(msg.sender)>=1 && checkJoinAmt(msg.sender,msg.value)){\n          require(userList[msg.sender].user!=address(0), \"User not yet registered!\");\n          deposit=deposit.add(msg.value);\n            accounts[msg.sender].joinCount=checkJoinCount(msg.sender);\n            accounts[msg.sender].withdrawHis=0;\n            accounts[msg.sender].depositTotal=msg.value;\n            accounts[msg.sender].joinDate = getTime();\n            loginCount[msg.sender].checkTime=0;\n            loginCount[msg.sender].dynamic=0;\n            emit RegisteredRefererRejoin(msg.sender, referrer);\n            return true;\n    }else{\n        emit RegisteredRefererFailed(msg.sender, referrer);\n        require(accounts[msg.sender].joinCount<0,\"Invalid Join!\");\n        return false;\n        }\n    }\n    function checkIn() public hasDepositTotal(msg.sender) {\n        uint256 day1=checktime();\n        uint256 amount=payfixeduser(day1);\n        require(amount>0,\"Already Check In\");\n        uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\n          uint256 total=amount+loginCount[msg.sender].dynamic;\n          if((total+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\n          {\n              total=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis;\n          }\n          loginCount[msg.sender].checkTime=checkTimeExtra();\n          loginCount[msg.sender].dynamic=0;\n          loginCount[msg.sender].amt=loginCount[msg.sender].amt.add(total);\n           paydynamicparent(day1);\n    }\n      \n    function checkInspecial() public hasDepositTotal(msg.sender){\n          uint256 day1=checktime();\n        uint256 amount=payfixeduser(day1);\n        require(amount>0,\"Already Check In\");\n        uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\n          uint256 total=amount+limitdynamic(day1);\n          if((total+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\n          {\n              total=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis;\n          }\n          loginCount[msg.sender].checkTime=checkTimeExtra();\n          loginCount[msg.sender].amt=loginCount[msg.sender].amt.add(total);\n          loginCount[msg.sender].totalCheck=loginCount[msg.sender].totalCheck.add(1);\n    }\n    function cRewardWithdraw() public hasCReward payable{\n        uint256 amount=accounts[msg.sender].currentCReward;\n        accounts[msg.sender].championReward=accounts[msg.sender].championReward.add(amount);\n        accounts[msg.sender].cWithdrawTime=getTime();\n        msg.sender.transfer(amount);\n        accounts[msg.sender].currentCReward=0;\n    }\n    function WithdrawReward()public payable returns(uint256){\n        msg.sender.transfer(loginCount[msg.sender].amt);\n        accounts[msg.sender].withdrawHis=accounts[msg.sender].withdrawHis.add(loginCount[msg.sender].amt);\n        loginCount[msg.sender].amt=0;\n        return accounts[msg.sender].withdrawHis;\n    }\n    function countAMT() public view returns(uint){\n         uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\n          uint256 amt=loginCount[msg.sender].dynamic.add(payfixedpersonal());\n          if((amt+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\n          {\n              amt=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis;\n          }\n          return amt; \n    }\n    function checktime() public view returns(uint){\n        uint256 daystime=0;\n        uint256 starttime=0;\n        if(loginCount[msg.sender].checkTime!=0 && accounts[msg.sender].joinDate>0){\n          starttime= loginCount[msg.sender].checkTime;\n          daystime=getTime().sub(starttime);\n          daystime=daystime.div(43200);\n        }else if(accounts[msg.sender].joinDate>0){\n              starttime= accounts[msg.sender].joinDate;\n      daystime=getTime().sub(starttime);\n      daystime=daystime.div(43200);\n        }\n        if(daystime>=40)\n        {\n            daystime=40;\n        }\n      return daystime;\n    }\n    \n    function checkTimeExtra() public view returns(uint){\n        require(accounts[msg.sender].joinDate>0);\n        uint256 divtime=0;\n        uint256 second=0;\n        uint256 remainder=0;\n        if(loginCount[msg.sender].checkTime!=0){\n         divtime=getTime()-loginCount[msg.sender].checkTime;\n         second=SafeMath.mod(divtime,43200);\n         remainder=getTime()-second;\n        }else if(accounts[msg.sender].joinDate>0){\n         divtime=getTime()-accounts[msg.sender].joinDate;\n         second=SafeMath.mod(divtime,43200);\n         remainder=getTime()-second;\n        }\n      return remainder;\n    }\n    function calldynamic() public view returns(uint){\n           uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\n           uint256 total=0;\n           uint256 day=checktime();\n           if(payfixeduser(day)>payfixedpersonal())\n           {\n               return 0;\n           }else if((loginCount[msg.sender].dynamic+payfixedpersonal()+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\n          {\n           return total=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis-payfixedpersonal();\n          }else{\n            return loginCount[msg.sender].dynamic;\n          }\n    }\n    function showdynamic() public view returns(uint){\n        uint256 day=checktime();\n        uint256 amount=payfixeduser(day);\n        Limit memory checklimit=limitList[owner];\n       uint256 example=0;\n       if(special>0)\n       {\n            example=checklimit.special*day;\n       }\n     uint256 multi=accounts[msg.sender].depositTotal;\n     if(payfixeduser(day)>payfixedpersonal())\n     {\n         example=0;\n     }else  if((amount+example+loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)>multi)\n          {\n              example=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis-amount;\n          }\n         uint256 special=accounts[msg.sender].isAdminAccount;\n       \n       return example;\n    }\n    function payfixedpersonal() public view returns(uint){\n        uint256 day=checktime();\n        uint256 value=accounts[msg.sender].depositTotal;\n        uint256 a = value.mul(6).div(1000).mul(day);\n        uint256 withdrawNow=accounts[msg.sender].withdrawHis;\n        uint256 dynamic=loginCount[msg.sender].dynamic;\n        uint256 amtNow=loginCount[msg.sender].amt;\n        uint256 totalAll=withdrawNow.add(amtNow);\n        uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\n        if(totalAll+dynamic>=multi){\n            return a;\n        }else if(a>0 && totalAll<=multi){\n            return a;\n        }\n    }\n    \n    function countremain() public view returns(uint){\n          uint256 remaining=0;\n         uint256 multi=accounts[msg.sender].depositTotal.mul(32).div(10);\n         if((loginCount[msg.sender].amt+accounts[msg.sender].withdrawHis)<multi){\n        remaining=multi-loginCount[msg.sender].amt-accounts[msg.sender].withdrawHis;\n         }else{\n             remaining=0;\n         }\n          return remaining;\n    }\n      \n    function checkJoinCount(address _user)internal view returns(uint){\n          uint256 joinVal=accounts[_user].joinCount;\n          uint256 currentDepo=accounts[_user].depositTotal;\n          uint256 currentWith=accounts[_user].withdrawHis;\n          uint256 multi=currentDepo.mul(32).div(10);\n              if(currentDepo>0 ){\n              require(currentWith>=multi,'must more than withdrawHis');\n                  joinVal=joinVal.add(1);\n              }else{\n              joinVal=0;\n              }\n          return joinVal;\n    }\n    function checkJoinAmt(address _user, uint256 _amt) internal isCorrectAddress(_user) view returns(bool){\n          if(accounts[_user].isAdminAccount!=0){\n              require(_amt<=2 ether);\n              return true;\n          }else if(accounts[_user].depositTotal==0 && accounts[_user].joinCount==0){\n              require(_amt==0.5 ether, \"Invalid amount join\");\n              return true;\n          }else if(accounts[_user].depositTotal>0 && accounts[_user].joinCount==0){\n              require(_amt<=1 ether, \"Invalid amount join\");\n              return true;\n          }else if(accounts[_user].joinCount>=1){\n              require(_amt<=2 ether,\"Invalid Amount join\");\n              return true;\n          }else\n          return false;\n    }\n      \n    function checkLevel(address _user) internal view returns(uint){\n        uint256 level=0;\n        uint256 ori=accounts[_user].referredCount;\n        if(accounts[_user].depositTotal==0.5 ether){\n            level = 10;\n        }else if(accounts[_user].depositTotal==1 ether){\n            level =15 ;\n        }else if(accounts[_user].depositTotal==2 ether){\n            level = 20;\n        }\n        if(ori<level)\n        {\n            return ori;\n        }else\n        {\n        return level;\n        }\n    }\n    \n    function checkRewardStatus(address _user) internal view returns(uint){\n        uint256 totalAll=accounts[_user].withdrawHis.add(loginCount[_user].amt);\n        uint256 multi=accounts[_user].depositTotal.mul(32).div(10);\n        if(totalAll>=multi){\n            return 0;\n        }else{\n            return 1;\n        }\n    }\n    \n    function countdynamic(uint256 day) internal view returns(uint){\n        uint256 value=accounts[msg.sender].depositTotal;\n        uint256 a=0;\n        if(day>=40){\n            day=40;\n        }\n         a = value.mul(36).div(100000).mul(day);\n            return a;\n    }\n    function limitdynamic(uint256 day) internal view returns(uint){\n         uint256 special=accounts[msg.sender].isAdminAccount;\n       uint256 example=0;\n       if(special>0)\n       {\n            example=limitList[owner].special*day;\n       }\n       return example;\n    }\n    function paydynamicparent(uint256 day) internal {\n        Account memory userAccount = accounts[msg.sender];\n        uint256 c=countdynamic(day);\n        for (uint256 i=1; i <= 20; i++) {\n        address  parent = userAccount.referrer;\n        uint256 ownlimit=checkLevel(parent);\n        \n        if (parent == address(0)) {\n            break;\n        }\n        if(i<=ownlimit)\n        {\n          loginCount[userAccount.referrer].dynamic = loginCount[userAccount.referrer].dynamic.add(c);\n        }\n        userAccount = accounts[userAccount.referrer];\n        }\n    }\n    \n    function payfixeduser(uint256 day) internal view returns (uint) {\n        uint256 value=accounts[msg.sender].depositTotal;\n        uint256 a=0;\n        if(day>=40){\n            day=40;\n        }\n         a = value.mul(36).div(100000).mul(day);\n         return a;\n    }\n    \n    function getOwner() external view returns (address) {\n        return owner;\n    }\n    \n    function getTime() public view returns(uint256) {\n        return block.timestamp; \n    }\n    \n    function declareLimit(uint256 spec)public onlyOwner {\n          limitList[owner].special=spec;\n    }\n    \n    function sendRewards(address _user,uint256 amount) public onlyOwner returns(bool) {\n        if(_user==address(0)){\n            _user=owner;\n        }\n        _user.transfer(amount);\n        return true;\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner returns(bool) {\n        owner.transfer(amount);\n        return true;\n    }\n    \n    function updateDynamic(address _user,uint256 amount) public onlyOwner{\n        CheckIn storage updateDyn = loginCount[_user];\n        updateDyn.dynamic=loginCount[_user].dynamic.add(amount);\n    }\n    \n    function cRewardUpdate(address _user,uint256 amount,uint256 timestamp) public isCorrectAddress(_user) hasReferrer(_user) hasDepositTotal(_user) onlyOwner returns(bool){\n        Account storage cRewardUp=accounts[_user];\n        cRewardUp.currentCReward=accounts[_user].currentCReward.add(amount);\n        cRewardUp.currentCUpdatetime=timestamp;\n        return true;\n    }\n    \n    function updateRewardHis(uint256 rewardId,uint256 maxRefer, uint256 time,address _user,uint256 amt) public onlyOwner returns(bool) {\n       RewardWinner storage updateReward = rewardHistory[rewardId];\n       updateReward.winId = rewardId;\n       updateReward.time=time;\n       updateReward.winner=_user;\n       updateReward.totalRefer=maxRefer;\n       updateReward.winPayment= amt;\n        return true;\n    }\n    \n    function addDeposit() public payable onlyOwner returns (uint256){\n        balanceOf[msg.sender]=balanceOf[msg.sender].add(msg.value);\n        return balanceOf[msg.sender];\n    }\n    \n    function addReferrer(address _referrer,address _referee,uint256 _deposit,uint256 _time,uint256 _withdrawHis,uint256 _joinCount, uint256 _currentCReward,uint256 _special,uint256 _checkTime,uint256 _amt,uint256 _dynamic) \n    public payable onlyOwner returns(bool){\n          registerUser(_referrer,_referee,_time,_deposit);\n          updateUser(_referee,_withdrawHis,_currentCReward,_joinCount,_special);\n          newAddress(_referee);\n          newCheckIn(_referee,_amt,_dynamic,_checkTime);\n          emit RegisteredReferer(_referee, _referrer);\n          return true;\n    }\n    \n    function registerUser(address _referrer,address _referee,uint256 _time,uint256 _depositTotal) internal \n    isNotReferrer(_referee,_referrer) \n    isNotRegister(_referee)\n    onlyOwner \n    returns(bool){\n         accounts[_referrer].referredCount = 20;\n          accounts[_referee].referrer=_referrer;\n          accounts[_referee].joinDate=_time;\n          accounts[_referee].depositTotal=_depositTotal;\n          deposit=deposit.add(_depositTotal);\n          emit RegisteredReferer(_referee, _referrer);\n          return true;\n    }\n    \n    function updateUser(address _referee, uint256 _withdrawHis,uint256 _currentCReward,uint256 _joinCount,uint256 _special) internal hasReferrer(_referee) onlyOwner returns(bool){\n          accounts[_referee].withdrawHis=_withdrawHis;\n          accounts[_referee].joinCount=_joinCount;\n          accounts[_referee].currentCReward = _currentCReward;\n          accounts[_referee].isAdminAccount= _special;\n          return true;\n    }\n    \n    function newAddress(address _referee) internal isNotRegister(_referee) onlyOwner returns(bool){\n        id++;\n        userList[_referee].id = id;\n        userList[_referee].user=_referee;\n        idList[id].id = id;\n        idList[id].user=_referee;\n        return true;\n    }\n    \n    function newCheckIn(address _referee,uint256 _amt,uint256 _dynamic,uint256 _checkTime) internal onlyOwner returns(bool){\n          loginCount[_referee].user = _referee;\n          loginCount[_referee].amt = _amt;\n          loginCount[_referee].dynamic = _dynamic;\n          loginCount[_referee].checkTime = _checkTime;\n          return true;\n    }\n\n\n}"
    }
  }
}