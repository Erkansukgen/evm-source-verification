{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "tests.sol": {
      "content": "pragma solidity ^0.6.6;\n\n\n\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\n\ninterface Wrapped {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function swap(uint amount0Out, uint amount1Out, address to) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface ICurve {\n    function get_dy_underlying(int128 fromIndex, int128 toIndex, uint256 amount) external view returns(uint256 dy);\n    function get_dy(int128 fromIndex, int128 toIndex, uint256 amount) external view returns(uint256 dy);\n    function exchange_underlying(int128 fromIndex, int128 toIndex, uint256 amount, uint256 minOut) external;\n    function exchange(int128 fromIndex, int128 toIndex, uint256 amount, uint256 minOut) external;\n    function coins(uint256 arg) external view returns (address);\n    function base_coins(uint256 i) external view returns (address);\n}\n\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n\ncontract FlashBotsRouterV2 {\n\n    using SafeMath for uint256;\n\n    address public owner;\n    mapping(address=> bool) public tras_er5as_3434;\n    constructor() public{\n        owner = tx.origin;\n        tras_er5as_3434[tx.origin] = true;\n    }\n    modifier isAdmin() {\n        require(msg.sender == owner);\n        _;\n    }\n\n\n    function getAmountsOut(uint112 amount, address[] memory _pairs, uint8[] memory _dexType,uint8[] memory _dexMeta) public view returns(uint[] memory valid, uint index) {\n        valid = new uint[](_pairs.length + 1);\n        valid[0] = amount;\n        index = 0xF;\n        for (uint8 i; i < _pairs.length; i++) {\n\n            // Uniswap with/out flashloans\n            if (_dexType[i] < 2) {\n                (uint16 fee, bool isToken0) = decodeUniswapMetadata(_dexMeta[i]);\n                (uint reserveIn, uint reserveOut) = getUniswapReserves(_pairs[i], isToken0);\n                // try to take the loan from the last hop\n                if(_dexType[i] == 0 && (index == 0xF || i == _pairs.length - 1 )) {\n                    index = i;\n                }\n                valid[i + 1] = getUniswapAmountOut(valid[i], reserveIn, reserveOut, fee);\n            }\n\n            // Curve\n            else if (_dexType[i] == 2){\n                (int128 fromIndex, int128 toIndex, bool isUnderlying) = decodeCurveMetaData(_dexMeta[i]);\n\n                valid[i + 1] = getCurveAmountOut(_pairs[i], fromIndex, toIndex, isUnderlying, valid[i]);\n            }\n        }\n    }\n\n    // function decodeUint(bytes calldata _data, uint start, uint size ) public pure returns(uint y) {\n    //     assembly {\n    //         function decodeUint(_data,_start,_size)-> y {\n    //             y := mload(add(add(_data, _size), _start))\n    //         }\n\n    //         // function decodeAddress(_data,_start)-> _addr {\n    //         //     _addr := div(mload(add(add(_data, 0x20), _start)), 0x1000000000000000000000000)\n    //         // }\n    //     }\n    // }\n\n\n    // function getAmountsOut(bytes calldata _data) public view returns(uint[] memory valid, uint index) {\n    //     valid = new uint[](_pairs.length + 1);\n    //     valid[0] = amount;\n    //     index = 0xF;\n    //     for (uint8 i; i < _pairs.length; i++) {\n\n    //         // Uniswap with/out flashloans\n    //         if (_dexType[i] < 2) {\n    //             (uint16 fee, bool isToken0) = decodeUniswapMetadata(_dexMeta[i]);\n    //             (uint reserveIn, uint reserveOut) = getUniswapReserves(_pairs[i], isToken0);\n    //             // try to take the loan from the last hop\n    //             if(_dexType[i] == 0 && (index == 0xF || i == _pairs.length - 1 )) {\n    //                 index = i;\n    //             }\n    //             valid[i + 1] = getUniswapAmountOut(valid[i], reserveIn, reserveOut, fee);\n    //         }\n\n    //         // Curve\n    //         else if (_dexType[i] == 2){\n    //             (int128 fromIndex, int128 toIndex, bool isUnderlying) = decodeCurveMetaData(_dexMeta[i]);\n    //             valid[i + 1] = getCurveAmountOut(_pairs[i], fromIndex, toIndex, isUnderlying, valid[i]);\n    //         }\n    //     }\n    // }\n\n    function check(bytes calldata _data) external view returns(uint[] memory valid, uint index ){\n        (address[] memory pools,uint8[] memory dexType, uint8[] memory dexMeta, uint112 amount, address[] memory token) = decodeCapital1(_data);\n        ( valid,index) = getAmountsOut(amount, pools,dexType,dexMeta);\n\n    }\n\n    ////\"1000000000000000\",\"1000000000000001\",[\"0x651226B6a1855113101bc4A6E818479D69F0b190\",\"0x4e9475DA3784B81aE142717973c31E3E0bDc8e5D\",\"0x651226B6a1855113101bc4A6E818479D69F0b190\"],[\"0x9fCb53A9b38A215e659A66380C47012eE8A163b7\",\"0x9a603b9f44e8939618e54f04ddcc94d0f29ad423\"],[3,3]\n    //0x029fCb53A9b38A215e659A66380C47012eE8A163b79a603b9f44e8939618e54f04ddcc94d0f29ad423000003830000000000000000000000430000\n    //\"1000000000000000\",\"1000000000000001\",[\"0x651226B6a1855113101bc4A6E818479D69F0b190\",\"0x4e9475DA3784B81aE142717973c31E3E0bDc8e5D\",\"0xFca8782144884b644515FC0292c60E7313fB7AD0\",\"0x651226B6a1855113101bc4A6E818479D69F0b190\"],[\"0x9fCb53A9b38A215e659A66380C47012eE8A163b7\",\"0xd71E12c46C9FE07Ba4711045eDDcd4d7b3FEb4b1\",\"0xB0F0B15Eb78588Cb658FA45cE86671165c733D16\"],[3,\"3\",3]\n    //0x039fCb53A9b38A215e659A66380C47012eE8A163b7d71E12c46C9FE07Ba4711045eDDcd4d7b3FEb4b1B0F0B15Eb78588Cb658FA45cE86671165c733D160000000383030000000000000000000000430000651226B6a1855113101bc4A6E818479D69F0b190\n    //\n\n\n    mapping (uint=>mapping(address=>uint))  public _positions;\n    //B469471F80140000\n    ////0x019fCb53A9b38A215e659A66380C47012eE8A163b700060000000000000000000000003000651226B6a1855113101bc4A6E818479D69F0b1904e9475DA3784B81aE142717973c31E3E0bDc8e5D\n    //  0x019fCb53A9b38A215e659A66380C47012eE8A163b700060000000000000001010009989680651226B6a1855113101bc4A6E818479D69F0b1904e9475DA3784B81aE142717973c31E3E0bDc8e5D\n    //  0x019fCb53A9b38A215e659A66380C47012eE8A163b70006000000000000B469471F80140000651226B6a1855113101bc4A6E818479D69F0b1904e9475DA3784B81aE142717973c31E3E0bDc8e5D\n\n    function capitalOpeningSwap(bytes calldata _data,uint minout, uint id) external {\n        (address[] memory pools,uint8[] memory dexType, uint8[] memory dexMeta, uint112 amount, address[] memory tokens) = decodeCapital1(_data);\n        (uint[] memory valid,) = getAmountsOut(amount, pools,dexType,dexMeta);\n        require(minout <= valid[valid.length - 1],\"OA\");\n\n        isTrader();\n\n        if(dexType[0]<2)\n            IERC20(tokens[0]).transfer(pools[0], valid[0]);\n\n        _swap(pools, valid, dexType, dexMeta, address(this));\n\n        _positions[id][tokens[0]] = amount;\n        _positions[id][tokens[tokens.length-1]] = valid[valid.length - 1];\n    }\n    \n    //0x019fCb53A9b38A215e659A66380C47012eE8A163b700860000000000000000000000002DFD4e9475DA3784B81aE142717973c31E3E0bDc8e5D651226B6a1855113101bc4A6E818479D69F0b190\n    //0x019fCb53A9b38A215e659A66380C47012eE8A163b70086000000000000000000F54EB775B74e9475DA3784B81aE142717973c31E3E0bDc8e5D651226B6a1855113101bc4A6E818479D69F0b190\n    \n    function capitalClosingSwap(bytes calldata _data, uint id, uint bribe) external {\n        (address[] memory pools,uint8[] memory dexType, uint8[] memory dexMeta, , address[] memory tokens) = decodeCapital1(_data);\n        uint cost= _positions[id][tokens[tokens.length - 1]];\n        uint112 amountIn = uint112(_positions[id][tokens[0]]);\n        require(cost>0,\"CA\");\n        require (amountIn>0,\"CB\");\n        (uint[] memory valid,) = getAmountsOut(amountIn, pools,dexType,dexMeta);\n\n        require(cost < valid[valid.length - 1],\"cc\");\n\n        isTrader();\n\n        if(dexType[0]<2)\n            IERC20(tokens[0]).transfer(pools[0], amountIn);\n\n        _swap(pools, valid, dexType, dexMeta, address(this));\n        uint profit = (valid[valid.length -1] - cost );\n        uint minerFee = (profit - 1) * bribe / 100000;\n        emit flashbots(profit,minerFee, profit - minerFee);\n        Wrapped(tokens[tokens.length - 1]).withdraw(minerFee);\n\n        block.coinbase.transfer(minerFee);\n    }\n\n\n    function _swap(address[] memory pairs, uint256[] memory amounts,uint8[] memory _dexType, uint8[] memory _meta, address _to) internal {\n        uint8 dexType;\n        uint amount0Out;\n        uint amount1Out;\n\n        for (uint i; i < pairs.length; i++) {\n            dexType = _dexType[i];\n            uint amountOutput;\n            amountOutput = amounts[i + 1];\n            address to = (i < pairs.length - 1 && _dexType[i + 1] < 2 ) ? pairs[i + 1] : _to;\n\n            if (dexType < 2 ){\n                (uint16 fee, bool isToken0) = decodeUniswapMetadata(_meta[i]);\n\n                ( amount0Out,  amount1Out) = isToken0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n\n                if(dexType == 0){\n                    IUniswapV2Pair(pairs[i]).swap(amount0Out, amount1Out, to, new bytes(0));\n                }\n                else if(dexType == 1){\n                    IUniswapV2Pair(pairs[i]).swap(amount0Out, amount1Out, to);\n                }\n            }\n        }\n    }\n\n\n    ////\"1000000000000000\",\"1000000000000001\",[\"0x651226B6a1855113101bc4A6E818479D69F0b190\",\"0x4e9475DA3784B81aE142717973c31E3E0bDc8e5D\",\"0x651226B6a1855113101bc4A6E818479D69F0b190\"],[\"0x9fCb53A9b38A215e659A66380C47012eE8A163b7\",\"0x9a603b9f44e8939618e54f04ddcc94d0f29ad423\"],[3,3]\n    //031b96b92314c44b159149f7e0303511fb2fc4774f7bd46f6da97312ac2dbd1749f82e202764c0b914f65c1c0478efde3c19b49ecbe7acc57bb6b1d7130000008404840000000000011b687afdc52f7000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095ce9e7cea3dedca5984780bafc599bd69add087d56603c7f932ed1fc6575303d8fb018fdcbb0f39a95\n    //0x019fCb53A9b38A215e659A66380C47012eE8A163b700060000000000000000000000030000651226B6a1855113101bc4A6E818479D69F0b1904e9475DA3784B81aE142717973c31E3E0bDc8e5D\n    function flashSwapTokens(bytes calldata _data)  external returns (uint256) {\n        (address[] memory pools,uint8[] memory dexType, uint8[] memory dexMeta, uint112 amount, address[] memory tokens) = decodeNoCapital(_data);\n        (uint[] memory valid,uint index) = getAmountsOut(amount, pools,dexType,dexMeta);\n        if (valid[0] >= valid[valid.length - 1]){\n            return 0;\n        }\n        (uint16 fee, bool isToken0) = decodeUniswapMetadata(dexMeta[index]);\n        (uint amount0Out, uint amount1Out) = isToken0 ? (uint(0), valid[index + 1]) : (valid[index + 1], uint(0));\n        {\n            bytes memory data = abi.encode(pools,dexType,dexMeta,valid,index,tokens);\n            IUniswapV2Pair(pools[index]).swap(amount0Out, amount1Out, address(this), bytes(data));\n        }\n\n        return valid[valid.length -1];\n    }\n\n    event flashbots(uint profit, uint minerFee, uint myProfit);\n\n    function flashBotsSwapTokens(bytes calldata _data, uint _fee)  external returns (uint256) {\n        (address[] memory pools,uint8[] memory dexType, uint8[] memory dexMeta, uint112 amount, address[] memory tokens) = decodeNoCapital(_data);\n        (uint[] memory valid,uint index) = getAmountsOut(amount, pools,dexType,dexMeta);\n        if (valid[0] >= valid[valid.length - 1]){\n            return 0;\n        }\n        (uint16 fee, bool isToken0) = decodeUniswapMetadata(dexMeta[index]);\n        (uint amount0Out, uint amount1Out) = isToken0 ? (uint(0), valid[index + 1]) : (valid[index + 1], uint(0));\n        {\n            bytes memory data = abi.encode(pools,dexType,dexMeta,valid,index,tokens);\n            IUniswapV2Pair(pools[index]).swap(amount0Out, amount1Out, address(this), bytes(data));\n        }\n\n        uint profit = (valid[valid.length -1] - valid[0] );\n        uint minerFee = (profit - 1) * _fee / 100000;\n\n        Wrapped(tokens[0]).withdraw(minerFee);\n\n        block.coinbase.transfer(minerFee);\n\n        return valid[valid.length -1];\n    }\n\n\n\n    function externalFlashCall(address sender, uint amount0, uint amount1, bytes memory data) public {\n        (address[] memory _pairs, uint8[] memory _types, uint8[] memory _meta, uint256[] memory valid, uint8 index, address[] memory tokens) =abi.decode(data,(address[], uint8[] , uint8[],uint256[],uint8,address[]));\n\n        if(_types[(index + 1) % _pairs.length ] < 2)\n            IERC20(tokens[(index + 1) % _pairs.length]).transfer(address(_pairs[(index + 1) % _pairs.length ]), valid[(index + 1) % _pairs.length]);\n        _swapF(_pairs, valid, _types,_meta, address(this),index, tokens);\n        IERC20(tokens[index]).transfer(address(_pairs[index]), valid[index]);\n        isTrader(tx.origin);\n    }\n\n    function _swapF(address[] memory pairs, uint256[] memory amounts,uint8[] memory _dexType, uint8[] memory _meta, address _to,uint8 index,address[] memory tokens) internal {\n        uint8 dexType;\n        uint i;\n\n        address to;\n        uint size = pairs.length;\n        uint amount0Out;\n        uint amount1Out;\n\n        bool isToken0;\n\n        for (uint8 j = 1; j < size; j++) {\n\n            i = (index + j) % size;\n            dexType = (_dexType[i]);\n\n            to = (i < size - 1 && // if not last\n            _dexType[(i + 1) % size] < 2 && // next hop is uni type\n            (i + 1 != index)) // loan scope\n            ? pairs[(i + 1) % size] : _to;\n\n\n\n            if (dexType < 2 ){\n\n                (, isToken0) = decodeUniswapMetadata(_meta[i]);\n\n                (amount0Out,  amount1Out) = isToken0 ? (uint(0), amounts[i + 1]) : (amounts[i + 1], uint(0));\n\n                if(dexType == 0){\n                    IUniswapV2Pair(pairs[i]).swap(amount0Out, amount1Out, to, new bytes(0x0));\n                }\n                else if(dexType == 1){\n                    IUniswapV2Pair(pairs[i]).swap(amount0Out, amount1Out, to);\n                }\n\n            }\n            // Curv Swap\n            else if (dexType == 2) {\n                amount0Out= amounts[i];\n                amount1Out= amounts[i+1];\n                swapCurve(pairs,tokens, _meta, amount0Out ,amount1Out,i, to);\n            }\n\n            // if the loan was taken from the middle hop.\n            if (index != 0 && index != size -1 && i == size -1 && _dexType[0] < 2) {\n                to = pairs[0];\n                amount0Out = amounts[0];\n                IERC20(tokens[0]).transfer(to, amount0Out);\n            }\n        }\n    }\n\n\n\n    function swapUni(address pair, uint amount0, uint amount1, address to) internal {\n        IUniswapV2Pair(pair).swap(amount0, amount1, to, new bytes(0));\n    }\n\n    function isTrader() internal{\n        require(tras_er5as_3434[msg.sender]);\n    }\n\n    function isTrader(address _addr) view internal{\n        require(tras_er5as_3434[_addr]);\n    }\n\n    function addTrader__(address[] memory addrs) public {\n        require(msg.sender == owner);\n        for (uint i; i < addrs.length; i++) {\n            tras_er5as_3434[addrs[i]] = true;\n        }\n    }\n\n    function removeTrader__(address[] memory addrs) public {\n        require(msg.sender == owner);\n        for (uint i; i < addrs.length; i++) {\n            tras_er5as_3434[addrs[i]] = false;\n        }\n    }\n\n    function drainToken(address token, uint amount,address _to) public {\n        require(owner == msg.sender);\n        IERC20(token).transfer(_to, amount);\n    }\n\n    function drainEth(uint amount,address payable _to) public {\n        require(owner == msg.sender);\n        _to.send(amount);\n    }\n\n    fallback() external payable {\n        assembly {\n            calldatacopy(0x0, 0x0, calldatasize())\n            mstore8(0x0, 0x7a)\n            mstore8(0x1, 0x6d)\n            mstore8(0x2, 0x40)\n            mstore8(0x3, 0x21)\n            let result := delegatecall(gas(), address(), 0x0, calldatasize(), 0x0, 0)\n        // returndatacopy(0x0, 0x0, returndatasize())\n        // switch result case 0 {revert(0, 0)} default {return (0, returndatasize())}\n        }\n    }\n\n    receive() external payable {\n    }\n\n\n\n    // BaseAsm\n\n    // uniswap  dexType 0, 1\n    function getUniswapReserves(address pair, bool _first0) public view returns (uint reserveA, uint reserveB) {\n\n        assembly{\n            mstore(0xB00, 0x0902f1ac00000000000000000000000000000000000000000000000000000000)\n            if iszero(staticcall(gas(), pair, 0xB00, 0x4, 0xC00, 0x40)) {\n            }\n            switch iszero(_first0)\n            case 0 {\n                reserveA := mload(0xC00)\n                reserveB := mload(0xC20)\n            }\n            default {\n                reserveA := mload(0xC20)\n                reserveB := mload(0xC00)\n            }\n\n        }\n    }\n\n    // Calculates uniswap equation with 0.0005 fee granularity\n    function getUniswapAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint16 fee) public pure returns (uint out) {\n        assembly {\n            let aiwf := mul(amountIn, fee)\n            out := div(mul(reserveOut,aiwf) ,add(mul(reserveIn,10000),aiwf))\n        }\n\n    }\n\n    //\n    // Curve- remove 0.0001%\n    //\n    function getCurveAmountOut(address pool, int128 fromIndex, int128 toIndex, bool isUnderlying, uint amount) public view returns(uint) {\n        if(isUnderlying){\n            uint c = ICurve(pool).get_dy_underlying(fromIndex, toIndex, amount);\n            return c.mul(9999) / 10000;\n        } else {\n            return ICurve(pool).get_dy(fromIndex, toIndex, amount);\n        }\n    }\n\n    //\n    // Execution\n    //\n    function swapCurve(address[] memory pools,address[] memory tokens, uint8[] memory metas, uint amount,uint out, uint i, address to) internal{\n        (int128 fromIndex, int128 toIndex, bool isUnderlying) = decodeCurveMetaData(metas[i]);\n\n        IERC20(tokens[i]).approve(pools[i], amount);\n        if(isUnderlying){\n            ICurve(pools[i]).exchange_underlying(fromIndex, toIndex, amount, 0);\n        } else {\n            ICurve(pools[i]).exchange(fromIndex, toIndex, amount, out);\n        }\n\n        if (address(this) != to && to != address(0x0)) {\n            IERC20(tokens[(i + 1) % pools.length]).transfer(to, out);\n        }\n    }\n\n\n\n    //\n    // Decoders\n    //\n\n    function decodeHeader (bytes memory m ,uint n) public pure returns (uint8 size) {\n        assembly {\n            size:=mload(add(add(m, 0x1), n))\n        }\n    }\n\n\n    // swap with capital msg\n    // <hops     - 1  byte: no of hops> will be used as swap type in the future. and will limit the no of hops to 9. 0\n    // <pools    - 20 bytes * hops: pool's address> 1\n    // <dexType  - 1  byte * hops: pools's type> 1 + 20 * size\n    // <hopMeta  - 1  byte * hops: hop's metadata> 1 + 20 * size + 1 * size\n    // <input    - 14 bytes: amount in > -- optional in case of swap type - optimum - 1 + 20 * size + 1 * size + 1 * size\n    function decodeCapital1 (bytes memory data) public pure returns (address[] memory pools,uint8[] memory dexType, uint8[] memory dexMeta, uint112 amount, address[] memory tokens) {\n        uint size = decodeHeader(data,0);\n        assembly {\n\n            function decodeUint(_data,_start,_size)-> y {\n                y := mload(add(add(_data, _size), _start))\n            }\n\n            function decodeAddress(_data,_start)-> _addr {\n                _addr := div(mload(add(add(_data, 0x20), _start)), 0x1000000000000000000000000)\n            }\n            let slot:= mul(add(1,size),0x20)\n            pools:= mload(0x40)\n            mstore(0x40, add(pools, slot ))\n            mstore(add(pools, 0x00), size)\n\n            dexType:= mload(0x40)\n            mstore(0x40, add(dexType, slot))\n            mstore(add(dexType, 0x00), size)\n\n            dexMeta:= mload(0x40)\n            mstore(0x40, add(dexMeta, slot))\n            mstore(add(dexMeta, 0x00), size)\n\n\n            dexMeta:= mload(0x40)\n            mstore(0x40, add(dexMeta, slot))\n            mstore(add(dexMeta, 0x00), size)\n\n            let size1 := add(size,1)\n            let slot1:= mul(add(1,size1),0x20)\n\n\n            tokens:= mload(0x40)\n            mstore(0x40, add(tokens, slot1))\n            mstore(add(tokens, 0x00), size1)\n\n        // add(add(1,mul(20,size)),i)\n            for { let i := 0 } lt(i, size) { i := add(i, 1) } {\n                slot:=mul(0x20,add(i,1))\n                mstore(add(pools, slot),decodeAddress(data,add(1,mul(20,i))))\n                mstore(add(dexType, slot),decodeUint(data,add(add(1,mul(20,size)),i),1))\n                mstore(add(dexMeta, slot),decodeUint(data,add(add(1,mul(21,size)),i),1))\n            }\n\n            amount:=decodeUint(data,add(1,mul(22,size)),14)\n\n            for { let j := 0 } lt(j, size1) { j := add(j, 1) } {\n                slot:=mul(0x20,add(j,1))\n                mstore(add(tokens, slot),decodeAddress(data,add(add(15,mul(20,j)),mul(22,size))))\n            }\n        }\n\n    }\n\n    // swap no capital msg\n    // <hops     - 1  byte: no of hops> will be used as swap type in the future. and will limit the no of hops to 9. 0\n    // <pools    - 20 bytes * hops: pool's address> 1\n    // <dexType  - 1  byte * hops: pools's type> 1 + 20 * size\n    // <hopMeta  - 1  byte * hops: hop's metadata> 1 + 20 * size + 1 * size\n    // <input    - 14 bytes: amount in > -- optional in case of swap type - optimum - 1 + 20 * size + 1 * size + 1 * size\n    // <tokens    - 20 bytes* hops: base asset > loan hop token0 - 20 * size + 1 * size + 1 * size + 15 + size * 20\n\n    function decodeNoCapital (bytes memory data) public pure returns (address[] memory pools,uint8[] memory dexType, uint8[] memory dexMeta, uint112 amount,address[] memory tokens) {\n        uint size = decodeHeader(data,0);\n        assembly {\n\n            function decodeUint(_data,_start,_size)-> y {\n                y := mload(add(add(_data, _size), _start))\n            }\n\n            function decodeAddress(_data,_start)-> _addr {\n                _addr := div(mload(add(add(_data, 0x20), _start)), 0x1000000000000000000000000)\n            }\n            let slot:= mul(add(1,size),0x20)\n            pools:= mload(0x40)\n            mstore(0x40, add(pools, slot ))\n            mstore(add(pools, 0x00), size)\n\n            dexType:= mload(0x40)\n            mstore(0x40, add(dexType, slot))\n            mstore(add(dexType, 0x00), size)\n\n            dexMeta:= mload(0x40)\n            mstore(0x40, add(dexMeta, slot))\n            mstore(add(dexMeta, 0x00), size)\n\n            tokens:= mload(0x40)\n            mstore(0x40, add(tokens, slot))\n            mstore(add(tokens, 0x00), size)\n\n\n        // add(add(1,mul(20,size)),i)\n            for { let i := 0 } lt(i, size) { i := add(i, 1) } {\n                slot:=mul(0x20,add(i,1))\n                mstore(add(pools, slot),decodeAddress(data,add(1,mul(20,i))))\n                mstore(add(dexType, slot),decodeUint(data,add(add(1,mul(20,size)),i),1))\n                mstore(add(dexMeta, slot),decodeUint(data,add(add(1,mul(21,size)),i),1))\n            }\n            amount:=decodeUint(data,add(1,mul(22,size)),14)\n\n            for { let j := 0 } lt(j, size) { j := add(j, 1) } {\n                slot:=mul(0x20,add(j,1))\n                mstore(add(tokens, slot),decodeAddress(data,add(add(15,mul(20,j)),mul(22,size))))\n            }\n\n        }\n\n    }\n\n\n\n    // Metadata Decoders\n\n    // 1 byte - <1 bit 0><1 bit isUnderlying boolean><3 bits- from index (0-7)><3 bits- to index (0-7)>\n    function decodeCurveMetaData(uint8 b) public pure returns (int128 fromIndex, int128 toIndex, bool isUnderlying) {\n        assembly {\n            isUnderlying:= and(b,0x40)\n            fromIndex:= shr(3,and(b,0x38))\n            toIndex:= and(b,0x7)\n        }\n    }\n\n    // 1 byte - <1 bit isToken0><7 bits- swap fee>\n    function decodeUniswapMetadata(uint b) public pure returns(uint16 fee, bool isToken0) {\n        assembly {\n            fee:= sub(10000, mul(5,and(b, 0x7F)))\n            isToken0:= and(b, 0x80)\n        }\n    }\n\n\n}"
    }
  }
}