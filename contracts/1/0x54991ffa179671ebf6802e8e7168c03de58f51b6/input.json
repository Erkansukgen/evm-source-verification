{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "swapForBot.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ncontract Swap {\n\n    bool private swaping = false;\n\n    modifier onlyOwner {\n        require (msg.sender == 0xDCDaFD08214a39e9eB54e4bDED5952b2e4f836C7, \"Unauthorized call\");\n        _;\n    }\n\n    receive() external payable  {} // Fallback function pour ajout ether\n\n    function withdrawToken(address tokenAddress, uint amount) external onlyOwner {\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n\n            /************************* token transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), origin()) // address dest\n            mstore(add(ptr,0x24), amount) // token amount\n\n            let result := call(\n                gas(), // gas limit\n                tokenAddress,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n\n    }\n\n    function withdrawETH() external onlyOwner {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function v2GetTokenAmountOut(address pairAddress, bool zeroForOne, uint amountIn) internal returns (uint amountOut) {\n        uint reserve0;\n        uint reserve1;\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            // put getReserves function signature at memory spot\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000) // sig = 0x0902f1ac\n\n            let result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                4, // Inputs are 4 bytes long\n                ptr,  //Store output over input\n                96) //Outputs are 96 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0, 32)\n            reserve0 := mload(ptr)\n\n            returndatacopy(ptr, 32, 32)\n            reserve1 := mload(ptr)\n\n            // calculating amounts out\n            if eq(zeroForOne, 1) {\n                // token 1 out\n                amountOut := div(mul(mul(reserve1, amountIn), 997), add(mul(1000, reserve0),mul(amountIn, 997)))\n            }\n\n            if eq(zeroForOne, 0) {\n                // token 0 out\n                amountOut := div(mul(mul(reserve0, amountIn), 997), add(mul(1000, reserve1),mul(amountIn, 997)))\n            }\n        }\n    }\n\n    \n\n    function v2SwapETHforExactToken(address routerAddress, address tokenOutAddress, uint amountOut) external payable onlyOwner {\n        address[] memory path = new address[](2);\n        path[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n        path[1] = tokenOutAddress;\n\n        bytes memory payload = abi.encodeWithSelector(bytes4(keccak256(\"swapETHForExactTokens(uint256,address[],address,uint256)\")), \n        amountOut,\n        path,\n        address(this),\n        block.timestamp + (60 seconds));\n\n        (bool success,) = routerAddress.call{value: msg.value}(payload);\n\n        require(success);\n\n        // Refund ether\n        payable(msg.sender).transfer(address(this).balance);\n\n    }\n\n    function v2SwapExactETHforToken(address routerAddress, address pairAddress, address tokenOutAddress, bool zeroForOne) external payable onlyOwner {\n        uint amountOutMin = v2GetTokenAmountOut(pairAddress, zeroForOne, msg.value);\n\n        address[] memory path = new address[](2);\n        path[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n        path[1] = tokenOutAddress;\n\n        bytes memory payload = abi.encodeWithSelector(bytes4(keccak256(\"swapExactETHForTokens(uint256,address[],address,uint256)\")), \n        amountOutMin,\n        path,\n        address(this),\n        block.timestamp + (60 seconds));\n\n        (bool success,) = routerAddress.call{value: msg.value}(payload);\n\n        require(success);\n\n        // Refund ether\n        payable(msg.sender).transfer(address(this).balance);\n\n    }\n\n    function swapTokenForETH(address routerAddress, address tokenInAddress) external payable onlyOwner {\n        uint balanceToken;\n\n        // getBalance and approve\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            /************* Get Balance ************/\n            // put balanceOf function signature at memory spot\n            mstore(ptr, 0x70a0823100000000000000000000000000000000000000000000000000000000) // sig = 0x70a08231\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), address()) // address\n\n            let result := call(\n                gas(), // gas limit\n                tokenInAddress,  // token contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x24, // Inputs are 36 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0,0)\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0x0, 0x20)\n            balanceToken := mload(ptr)\n\n            /************* Approve token ************/\n            // put balanceOf function signature at memory spot\n            mstore(ptr, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // sig = 0x095ea7b3\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), routerAddress) // address\n            mstore(add(ptr,0x24), balanceToken) // amount\n\n            result := call(\n                gas(), // gas limit\n                tokenInAddress,  // token contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 36 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0,0)\n            }\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = tokenInAddress;\n        path[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n        bytes memory payload = abi.encodeWithSelector(bytes4(keccak256(\"swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)\")), \n        balanceToken,\n        10,\n        path,\n        msg.sender,\n        block.timestamp + (60 seconds));\n\n        (bool success,) = routerAddress.call(payload);\n\n        require(success);\n    }\n\n\n}\n"
    }
  }
}