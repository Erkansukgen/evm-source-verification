{"language":"Solidity","settings":{"evmVersion":"constantinople","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@aragon/os/contracts/acl/ACLSyntaxSugar.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract ACLSyntaxSugar {\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}\n\n\ncontract ACLHelpers {\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}\n"},"@aragon/os/contracts/acl/IACL.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IACL {\n    function initialize(address permissionsCreator) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}\n"},"@aragon/os/contracts/apps/AppStorage.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../common/UnstructuredStorage.sol\";\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppStorage {\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_POSITION = keccak256(\"aragonOS.appStorage.kernel\");\n    bytes32 internal constant APP_ID_POSITION = keccak256(\"aragonOS.appStorage.appId\");\n    */\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\n\n    function kernel() public view returns (IKernel) {\n        return IKernel(KERNEL_POSITION.getStorageAddress());\n    }\n\n    function appId() public view returns (bytes32) {\n        return APP_ID_POSITION.getStorageBytes32();\n    }\n\n    function setKernel(IKernel _kernel) internal {\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\n    }\n\n    function setAppId(bytes32 _appId) internal {\n        APP_ID_POSITION.setStorageBytes32(_appId);\n    }\n}\n"},"@aragon/os/contracts/apps/AragonApp.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./AppStorage.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../common/Autopetrified.sol\";\nimport \"../common/ConversionHelpers.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/VaultRecoverable.sol\";\nimport \"../evmscript/EVMScriptRunner.sol\";\n\n\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\n// that they can never be initialized.\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\n// are included so that they are automatically usable by subclassing contracts\ncontract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\n    string private constant ERROR_AUTH_FAILED = \"APP_AUTH_FAILED\";\n\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] _params) {\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    /**\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\n    * @param _sender Sender of the call\n    * @param _role Role on this app\n    * @param _params Permission params for the role\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\n    *         Always returns false if the app hasn't been initialized yet.\n    */\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\n        if (!hasInitialized()) {\n            return false;\n        }\n\n        IKernel linkedKernel = kernel();\n        if (address(linkedKernel) == address(0)) {\n            return false;\n        }\n\n        return linkedKernel.hasPermission(\n            _sender,\n            address(this),\n            _role,\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\n        );\n    }\n\n    /**\n    * @dev Get the recovery vault for the app\n    * @return Recovery vault address for the app\n    */\n    function getRecoveryVault() public view returns (address) {\n        // Funds recovery via a vault is only available when used with a kernel\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\n    }\n}\n"},"@aragon/os/contracts/common/Autopetrified.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Petrifiable.sol\";\n\n\ncontract Autopetrified is Petrifiable {\n    constructor() public {\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\n        // This renders them uninitializable (and unusable without a proxy).\n        petrify();\n    }\n}\n"},"@aragon/os/contracts/common/ConversionHelpers.sol":{"content":"pragma solidity ^0.4.24;\n\n\nlibrary ConversionHelpers {\n    string private constant ERROR_IMPROPER_LENGTH = \"CONVERSION_IMPROPER_LENGTH\";\n\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\n        // Force cast the uint256[] into a bytes array, by overwriting its length\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 byteLength = _input.length * 32;\n        assembly {\n            output := _input\n            mstore(output, byteLength)\n        }\n    }\n\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\n        // Force cast the bytes array into a uint256[], by overwriting its length\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 intsLength = _input.length / 32;\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\n\n        assembly {\n            output := _input\n            mstore(output, intsLength)\n        }\n    }\n}\n"},"@aragon/os/contracts/common/EtherTokenConstant.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\n// contracts where both tokens and ETH are accepted\ncontract EtherTokenConstant {\n    address internal constant ETH = address(0);\n}\n"},"@aragon/os/contracts/common/IVaultRecoverable.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IVaultRecoverable {\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\n\n    function transferToVault(address token) external;\n\n    function allowRecoverability(address token) external view returns (bool);\n    function getRecoveryVault() external view returns (address);\n}\n"},"@aragon/os/contracts/common/Initializable.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./TimeHelpers.sol\";\nimport \"./UnstructuredStorage.sol\";\n\n\ncontract Initializable is TimeHelpers {\n    using UnstructuredStorage for bytes32;\n\n    // keccak256(\"aragonOS.initializable.initializationBlock\")\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\n\n    string private constant ERROR_ALREADY_INITIALIZED = \"INIT_ALREADY_INITIALIZED\";\n    string private constant ERROR_NOT_INITIALIZED = \"INIT_NOT_INITIALIZED\";\n\n    modifier onlyInit {\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\n        _;\n    }\n\n    modifier isInitialized {\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @return Whether the contract has been initialized by the time of the current block\n    */\n    function hasInitialized() public view returns (bool) {\n        uint256 initializationBlock = getInitializationBlock();\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization to enable the contract\n    *      at a future block number rather than immediately.\n    */\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n    }\n}\n"},"@aragon/os/contracts/common/IsContract.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract IsContract {\n    /*\n    * NOTE: this should NEVER be used for authentication\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n    *\n    * This is only intended to be used as a sanity check that an address is actually a contract,\n    * RATHER THAN an address not being a contract.\n    */\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"},"@aragon/os/contracts/common/Petrifiable.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Initializable.sol\";\n\n\ncontract Petrifiable is Initializable {\n    // Use block UINT256_MAX (which should be never) as the initializable date\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\n\n    function isPetrified() public view returns (bool) {\n        return getInitializationBlock() == PETRIFIED_BLOCK;\n    }\n\n    /**\n    * @dev Function to be called by top level contract to prevent being initialized.\n    *      Useful for freezing base contracts when they're used behind proxies.\n    */\n    function petrify() internal onlyInit {\n        initializedAt(PETRIFIED_BLOCK);\n    }\n}\n"},"@aragon/os/contracts/common/ReentrancyGuard.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../common/UnstructuredStorage.sol\";\n\n\ncontract ReentrancyGuard {\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\"aragonOS.reentrancyGuard.mutex\");\n    */\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\n\n    string private constant ERROR_REENTRANT = \"REENTRANCY_REENTRANT_CALL\";\n\n    modifier nonReentrant() {\n        // Ensure mutex is unlocked\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\n\n        // Lock mutex before function call\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\n\n        // Perform function call\n        _;\n\n        // Unlock mutex after function call\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\n    }\n}\n"},"@aragon/os/contracts/common/SafeERC20.sol":{"content":"// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\n\npragma solidity ^0.4.24;\n\nimport \"../lib/token/ERC20.sol\";\n\n\nlibrary SafeERC20 {\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \"SAFE_ERC_20_BALANCE_REVERTED\";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \"SAFE_ERC_20_ALLOWANCE_REVERTED\";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}\n"},"@aragon/os/contracts/common/TimeHelpers.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Uint256Helpers.sol\";\n\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n"},"@aragon/os/contracts/common/Uint256Helpers.sol":{"content":"pragma solidity ^0.4.24;\n\n\nlibrary Uint256Helpers {\n    uint256 private constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}\n"},"@aragon/os/contracts/common/UnstructuredStorage.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\nlibrary UnstructuredStorage {\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}\n"},"@aragon/os/contracts/common/VaultRecoverable.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../lib/token/ERC20.sol\";\nimport \"./EtherTokenConstant.sol\";\nimport \"./IsContract.sol\";\nimport \"./IVaultRecoverable.sol\";\nimport \"./SafeERC20.sol\";\n\n\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\n    using SafeERC20 for ERC20;\n\n    string private constant ERROR_DISALLOWED = \"RECOVER_DISALLOWED\";\n    string private constant ERROR_VAULT_NOT_CONTRACT = \"RECOVER_VAULT_NOT_CONTRACT\";\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \"RECOVER_TOKEN_TRANSFER_FAILED\";\n\n    /**\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\n     *         but in case it does, this function allows one to recover them.\n     * @param _token Token balance to be sent to recovery vault.\n     */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\n        address vault = getRecoveryVault();\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = address(this).balance;\n            vault.transfer(balance);\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }\n\n    /**\n    * @dev By default deriving from AragonApp makes it recoverable\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }\n\n    // Cast non-implemented interface to be public so we can use it internally\n    function getRecoveryVault() public view returns (address);\n}\n"},"@aragon/os/contracts/evmscript/EVMScriptRunner.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"../apps/AppStorage.sol\";\nimport \"../kernel/KernelConstants.sol\";\nimport \"../common/Initializable.sol\";\n\n\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \"EVMRUN_EXECUTOR_UNAVAILABLE\";\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \"EVMRUN_PROTECTED_STATE_MODIFIED\";\n\n    /* This is manually crafted in assembly\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \"EVMRUN_EXECUTOR_INVALID_RETURN\";\n    */\n\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\n\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\n    }\n\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\n        internal\n        isInitialized\n        protectState\n        returns (bytes)\n    {\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\n\n        bytes4 sig = executor.execScript.selector;\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\n\n        bytes memory output;\n        assembly {\n            let success := delegatecall(\n                gas,                // forward all gas\n                executor,           // address\n                add(data, 0x20),    // calldata start\n                mload(data),        // calldata length\n                0,                  // don't write output (we'll handle this ourselves)\n                0                   // don't write output\n            )\n\n            output := mload(0x40) // free mem ptr get\n\n            switch success\n            case 0 {\n                // If the call errored, forward its full error data\n                returndatacopy(output, 0, returndatasize)\n                revert(output, returndatasize)\n            }\n            default {\n                switch gt(returndatasize, 0x3f)\n                case 0 {\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\n                    // revert with \"EVMRUN_EXECUTOR_INVALID_RETURN\"\n                    // See remix: doing a `revert(\"EVMRUN_EXECUTOR_INVALID_RETURN\")` always results in\n                    // this memory layout\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\n\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n                }\n                default {\n                    // Copy result\n                    //\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\n                    //    [ output length (32 bytes) ]\n                    //    [ output content (N bytes) ]\n                    //\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\n                    let copysize := sub(returndatasize, 0x20)\n                    returndatacopy(output, 0x20, copysize)\n\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\n                }\n            }\n        }\n\n        emit ScriptResult(address(executor), _script, _input, output);\n\n        return output;\n    }\n\n    modifier protectState {\n        address preKernel = address(kernel());\n        bytes32 preAppId = appId();\n        _; // exec\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\n    }\n}\n"},"@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IEVMScriptExecutor {\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n    function executorType() external pure returns (bytes32);\n}\n"},"@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./IEVMScriptExecutor.sol\";\n\n\ncontract EVMScriptRegistryConstants {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\"evmreg\");\n    */\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\n}\n\n\ninterface IEVMScriptRegistry {\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\n}\n"},"@aragon/os/contracts/kernel/IKernel.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../acl/IACL.sol\";\nimport \"../common/IVaultRecoverable.sol\";\n\n\ninterface IKernelEvents {\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\n}\n\n\n// This should be an interface, but interfaces can't inherit yet :(\ncontract IKernel is IKernelEvents, IVaultRecoverable {\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\n}\n"},"@aragon/os/contracts/kernel/KernelConstants.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract KernelAppIds {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\"kernel\");\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\"acl\");\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\"vault\");\n    */\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\n}\n\n\ncontract KernelNamespaceConstants {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\"core\");\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\"base\");\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\"app\");\n    */\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\n}\n"},"@aragon/os/contracts/lib/math/SafeMath.sol":{"content":"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n"},"@aragon/os/contracts/lib/token/ERC20.sol":{"content":"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"contracts/0.4.24/interfaces/IBeaconReportReceiver.sol":{"content":"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.4.24;\n\n\n/**\n  * @title Interface defining a callback that the quorum will call on every quorum reached\n  */\ninterface IBeaconReportReceiver {\n    /**\n      * @notice Callback to be called by the oracle contract upon the quorum is reached\n      * @param _postTotalPooledEther total pooled ether on Lido right after the quorum value was reported\n      * @param _preTotalPooledEther total pooled ether on Lido right before the quorum value was reported\n      * @param _timeElapsed time elapsed in seconds between the last and the previous quorum\n      */\n    function processLidoOracleReport(uint256 _postTotalPooledEther,\n                                     uint256 _preTotalPooledEther,\n                                     uint256 _timeElapsed) external;\n}\n"},"contracts/0.4.24/interfaces/ILido.sol":{"content":"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.4.24;\n\n\n/**\n  * @title Liquid staking pool\n  *\n  * For the high-level description of the pool operation please refer to the paper.\n  * Pool manages withdrawal keys and fees. It receives ether submitted by users on the ETH 1 side\n  * and stakes it via the deposit_contract.sol contract. It doesn't hold ether on it's balance,\n  * only a small portion (buffer) of it.\n  * It also mints new tokens for rewards generated at the ETH 2.0 side.\n  */\ninterface ILido {\n    /**\n     * @dev From ISTETH interface, because \"Interfaces cannot inherit\".\n     */\n    function totalSupply() external view returns (uint256);\n    function getTotalShares() external view returns (uint256);\n\n    /**\n      * @notice Stop pool routine operations\n      */\n    function stop() external;\n\n    /**\n      * @notice Resume pool routine operations\n      */\n    function resume() external;\n\n    event Stopped();\n    event Resumed();\n\n\n    /**\n      * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results\n      * @param _feeBasisPoints Fee rate, in basis points\n      */\n    function setFee(uint16 _feeBasisPoints) external;\n\n    /**\n      * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.\n      */\n    function setFeeDistribution(\n        uint16 _treasuryFeeBasisPoints,\n        uint16 _insuranceFeeBasisPoints,\n        uint16 _operatorsFeeBasisPoints)\n        external;\n\n    /**\n      * @notice Returns staking rewards fee rate\n      */\n    function getFee() external view returns (uint16 feeBasisPoints);\n\n    /**\n      * @notice Returns fee distribution proportion\n      */\n    function getFeeDistribution() external view returns (uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints,\n                                                         uint16 operatorsFeeBasisPoints);\n\n    event FeeSet(uint16 feeBasisPoints);\n\n    event FeeDistributionSet(uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints);\n\n\n    /**\n      * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`\n      * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.\n      * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by\n      *        the deposit_contract.deposit function\n      */\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external;\n\n    /**\n      * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched\n      */\n    function getWithdrawalCredentials() external view returns (bytes);\n\n\n    event WithdrawalCredentialsSet(bytes32 withdrawalCredentials);\n\n\n    /**\n      * @notice Ether on the ETH 2.0 side reported by the oracle\n      * @param _epoch Epoch id\n      * @param _eth2balance Balance in wei on the ETH 2.0 side\n      */\n    function pushBeacon(uint256 _epoch, uint256 _eth2balance) external;\n\n\n    // User functions\n\n    /**\n      * @notice Adds eth to the pool\n      * @return StETH Amount of StETH generated\n      */\n    function submit(address _referral) external payable returns (uint256 StETH);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `_amount` of ether was sent to the deposit_contract.deposit function.\n    event Unbuffered(uint256 amount);\n\n    /**\n      * @notice Issues withdrawal request. Large withdrawals will be processed only after the phase 2 launch.\n      * @param _amount Amount of StETH to burn\n      * @param _pubkeyHash Receiving address\n      */\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external;\n\n    // Requested withdrawal of `etherAmount` to `pubkeyHash` on the ETH 2.0 side, `tokenAmount` burned by `sender`,\n    // `sentFromBuffer` was sent on the current Ethereum side.\n    event Withdrawal(address indexed sender, uint256 tokenAmount, uint256 sentFromBuffer,\n                     bytes32 indexed pubkeyHash, uint256 etherAmount);\n\n\n    // Info functions\n\n    /**\n      * @notice Gets the amount of Ether controlled by the system\n      */\n    function getTotalPooledEther() external view returns (uint256);\n\n    /**\n      * @notice Gets the amount of Ether temporary buffered on this contract balance\n      */\n    function getBufferedEther() external view returns (uint256);\n\n    /**\n      * @notice Returns the key values related to Beacon-side\n      * @return depositedValidators - number of deposited validators\n      * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles\n      * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)\n      */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance);\n}\n"},"contracts/0.4.24/interfaces/ILidoOracle.sol":{"content":"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.4.24;\n\nimport \"../interfaces/ILido.sol\";\n\n\n/**\n * @title ETH 2.0 -> ETH oracle\n *\n * The goal of the oracle is to inform other parts of the system about balances controlled by the\n * DAO on the ETH 2.0 side. The balances can go up because of reward accumulation and can go down\n * because of slashing.\n */\ninterface ILidoOracle {\n    event AllowedBeaconBalanceAnnualRelativeIncreaseSet(uint256 value);\n    event AllowedBeaconBalanceRelativeDecreaseSet(uint256 value);\n    event BeaconReportReceiverSet(address callback);\n    event MemberAdded(address member);\n    event MemberRemoved(address member);\n    event QuorumChanged(uint256 quorum);\n    event ExpectedEpochIdUpdated(uint256 epochId);\n    event BeaconSpecSet(\n        uint64 epochsPerFrame,\n        uint64 slotsPerEpoch,\n        uint64 secondsPerSlot,\n        uint64 genesisTime\n    );\n    event BeaconReported(\n        uint256 epochId,\n        uint128 beaconBalance,\n        uint128 beaconValidators,\n        address caller\n    );\n    event Completed(\n        uint256 epochId,\n        uint128 beaconBalance,\n        uint128 beaconValidators\n    );\n    event PostTotalShares(\n         uint256 postTotalPooledEther,\n         uint256 preTotalPooledEther,\n         uint256 timeElapsed,\n         uint256 totalShares);\n    event ContractVersionSet(uint256 version);\n\n    /**\n     * @notice Return the Lido contract address\n     */\n    function getLido() public view returns (ILido);\n\n    /**\n     * @notice Return the number of exactly the same reports needed to finalize the epoch\n     */\n    function getQuorum() public view returns (uint256);\n\n    /**\n     * @notice Return the upper bound of the reported balance possible increase in APR\n     */\n    function getAllowedBeaconBalanceAnnualRelativeIncrease() external view returns (uint256);\n\n    /**\n     * @notice Return the lower bound of the reported balance possible decrease\n     */\n    function getAllowedBeaconBalanceRelativeDecrease() external view returns (uint256);\n\n    /**\n     * @notice Set the upper bound of the reported balance possible increase in APR to `_value`\n     */\n    function setAllowedBeaconBalanceAnnualRelativeIncrease(uint256 _value) external;\n\n    /**\n     * @notice Set the lower bound of the reported balance possible decrease to `_value`\n     */\n    function setAllowedBeaconBalanceRelativeDecrease(uint256 _value) external;\n\n    /**\n     * @notice Return the receiver contract address to be called when the report is pushed to Lido\n     */\n    function getBeaconReportReceiver() external view returns (address);\n\n    /**\n     * @notice Set the receiver contract address to be called when the report is pushed to Lido\n     */\n    function setBeaconReportReceiver(address _addr) external;\n\n    /**\n     * @notice Return the current reporting bitmap, representing oracles who have already pushed\n     * their version of report during the expected epoch\n     */\n    function getCurrentOraclesReportStatus() external view returns (uint256);\n\n    /**\n     * @notice Return the current reporting array size\n     */\n    function getCurrentReportVariantsSize() external view returns (uint256);\n\n    /**\n     * @notice Return the current reporting array element with the given index\n     */\n    function getCurrentReportVariant(uint256 _index)\n        external\n        view\n        returns (\n            uint64 beaconBalance,\n            uint32 beaconValidators,\n            uint16 count\n        );\n\n    /**\n     * @notice Return epoch that can be reported by oracles\n     */\n    function getExpectedEpochId() external view returns (uint256);\n\n    /**\n     * @notice Return the current oracle member committee list\n     */\n    function getOracleMembers() external view returns (address[]);\n\n    /**\n     * @notice Return the initialized version of this contract starting from 0\n     */\n    function getVersion() external view returns (uint256);\n\n    /**\n     * @notice Return beacon specification data\n     */\n    function getBeaconSpec()\n        external\n        view\n        returns (\n            uint64 epochsPerFrame,\n            uint64 slotsPerEpoch,\n            uint64 secondsPerSlot,\n            uint64 genesisTime\n        );\n\n    /**\n     * Updates beacon specification data\n     */\n    function setBeaconSpec(\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime\n    )\n        external;\n\n    /**\n     * Returns the epoch calculated from current timestamp\n     */\n    function getCurrentEpochId() external view returns (uint256);\n\n    /**\n     * @notice Return currently reportable epoch (the first epoch of the current frame) as well as\n     * its start and end times in seconds\n     */\n    function getCurrentFrame()\n        external\n        view\n        returns (\n            uint256 frameEpochId,\n            uint256 frameStartTime,\n            uint256 frameEndTime\n        );\n\n    /**\n     * @notice Return last completed epoch\n     */\n    function getLastCompletedEpochId() external view returns (uint256);\n\n    /**\n     * @notice Report beacon balance and its change during the last frame\n     */\n    function getLastCompletedReportDelta()\n        external\n        view\n        returns (\n            uint256 postTotalPooledEther,\n            uint256 preTotalPooledEther,\n            uint256 timeElapsed\n        );\n\n    /**\n     * @notice Initialize the contract v2 data, with sanity check bounds\n     * (`_allowedBeaconBalanceAnnualRelativeIncrease`, `_allowedBeaconBalanceRelativeDecrease`)\n     * @dev Original initialize function removed from v2 because it is invoked only once\n     */\n    function initialize_v2(\n        uint256 _allowedBeaconBalanceAnnualRelativeIncrease,\n        uint256 _allowedBeaconBalanceRelativeDecrease\n    )\n        external;\n\n    /**\n     * @notice Add `_member` to the oracle member committee list\n     */\n    function addOracleMember(address _member) external;\n\n    /**\n     * @notice Remove '_member` from the oracle member committee list\n     */\n    function removeOracleMember(address _member) external;\n\n    /**\n     * @notice Set the number of exactly the same reports needed to finalize the epoch to `_quorum`\n     */\n    function setQuorum(uint256 _quorum) external;\n\n    /**\n     * @notice Accept oracle committee member reports from the ETH 2.0 side\n     * @param _epochId Beacon chain epoch\n     * @param _beaconBalance Balance in gwei on the ETH 2.0 side (9-digit denomination)\n     * @param _beaconValidators Number of validators visible in this epoch\n     */\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators) external;\n}\n"},"contracts/0.4.24/oracle/LidoOracle.sol":{"content":"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\n\nimport \"../interfaces/IBeaconReportReceiver.sol\";\nimport \"../interfaces/ILido.sol\";\nimport \"../interfaces/ILidoOracle.sol\";\n\nimport \"./ReportUtils.sol\";\n\n/**\n * @title Implementation of an ETH 2.0 -> ETH oracle\n *\n * The goal of the oracle is to inform other parts of the system about balances controlled by the\n * DAO on the ETH 2.0 side. The balances can go up because of reward accumulation and can go down\n * because of slashing.\n *\n * The timeline is divided into consecutive frames. Every oracle member may push its report once\n * per frame. When the equal reports reach the configurable 'quorum' value, this frame is\n * considered finalized and the resulting report is pushed to Lido.\n *\n * Not all frames may come to a quorum. Oracles may report only to the first epoch of the frame and\n * only if no quorum is reached for this epoch yet.\n */\ncontract LidoOracle is ILidoOracle, AragonApp {\n    using SafeMath for uint256;\n    using ReportUtils for uint256;\n\n    struct BeaconSpec {\n        uint64 epochsPerFrame;\n        uint64 slotsPerEpoch;\n        uint64 secondsPerSlot;\n        uint64 genesisTime;\n    }\n\n    /// ACL\n    bytes32 constant public MANAGE_MEMBERS =\n        0xbf6336045918ae0015f4cdb3441a2fdbfaa4bcde6558c8692aac7f56c69fb067; // keccak256(\"MANAGE_MEMBERS\")\n    bytes32 constant public MANAGE_QUORUM =\n        0xa5ffa9f45fa52c446078e834e1914561bd9c2ab1e833572d62af775da092ccbc; // keccak256(\"MANAGE_QUORUM\")\n    bytes32 constant public SET_BEACON_SPEC =\n        0x16a273d48baf8111397316e6d961e6836913acb23b181e6c5fb35ec0bd2648fc; // keccak256(\"SET_BEACON_SPEC\")\n    bytes32 constant public SET_REPORT_BOUNDARIES =\n        0x44adaee26c92733e57241cb0b26ffaa2d182ed7120ba3ecd7e0dce3635c01dc1; // keccak256(\"SET_REPORT_BOUNDARIES\")\n    bytes32 constant public SET_BEACON_REPORT_RECEIVER =\n        0xe22a455f1bfbaf705ac3e891a64e156da92cb0b42cfc389158e6e82bd57f37be; // keccak256(\"SET_BEACON_REPORT_RECEIVER\")\n\n    /// Maximum number of oracle committee members\n    uint256 public constant MAX_MEMBERS = 256;\n\n    /// Eth1 denomination is 18 digits, while Eth2 has 9 digits. Because we work with Eth2\n    /// balances and to support old interfaces expecting eth1 format, we multiply by this\n    /// coefficient.\n    uint128 internal constant DENOMINATION_OFFSET = 1e9;\n\n    uint256 internal constant MEMBER_NOT_FOUND = uint256(-1);\n\n    /// Number of exactly the same reports needed to finalize the epoch\n    bytes32 internal constant QUORUM_POSITION =\n        0xd43b42c1ba05a1ab3c178623a49b2cdb55f000ec70b9ccdba5740b3339a7589e; // keccak256(\"lido.LidoOracle.quorum\")\n\n    /// Address of the Lido contract\n    bytes32 internal constant LIDO_POSITION =\n        0xf6978a4f7e200f6d3a24d82d44c48bddabce399a3b8ec42a480ea8a2d5fe6ec5; // keccak256(\"lido.LidoOracle.lido\")\n\n    /// Storage for the actual beacon chain specification\n    bytes32 internal constant BEACON_SPEC_POSITION =\n        0x805e82d53a51be3dfde7cfed901f1f96f5dad18e874708b082adb8841e8ca909; // keccak256(\"lido.LidoOracle.beaconSpec\")\n\n    /// Version of the initialized contract data, v1 is 0\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\n        0x75be19a3f314d89bd1f84d30a6c84e2f1cd7afc7b6ca21876564c265113bb7e4; // keccak256(\"lido.LidoOracle.contractVersion\")\n\n    /// Epoch that we currently collect reports\n    bytes32 internal constant EXPECTED_EPOCH_ID_POSITION =\n        0x65f1a0ee358a8a4000a59c2815dc768eb87d24146ca1ac5555cb6eb871aee915; // keccak256(\"lido.LidoOracle.expectedEpochId\")\n\n    /// The bitmask of the oracle members that pushed their reports\n    bytes32 internal constant REPORTS_BITMASK_POSITION =\n        0xea6fa022365e4737a3bb52facb00ddc693a656fb51ffb2b4bd24fb85bdc888be; // keccak256(\"lido.LidoOracle.reportsBitMask\")\n\n    /// Historic data about 2 last completed reports and their times\n    bytes32 internal constant POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION =\n        0xaa8433b13d2b111d4f84f6f374bc7acbe20794944308876aa250fa9a73dc7f53; // keccak256(\"lido.LidoOracle.postCompletedTotalPooledEther\")\n    bytes32 internal constant PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION =\n        0x1043177539af09a67d747435df3ff1155a64cd93a347daaac9132a591442d43e; // keccak256(\"lido.LidoOracle.preCompletedTotalPooledEther\")\n    bytes32 internal constant LAST_COMPLETED_EPOCH_ID_POSITION =\n        0xdad15c0beecd15610092d84427258e369d2582df22869138b4c5265f049f574c; // keccak256(\"lido.LidoOracle.lastCompletedEpochId\")\n    bytes32 internal constant TIME_ELAPSED_POSITION =\n        0x8fe323f4ecd3bf0497252a90142003855cc5125cee76a5b5ba5d508c7ec28c3a; // keccak256(\"lido.LidoOracle.timeElapsed\")\n\n    /// Receiver address to be called when the report is pushed to Lido\n    bytes32 internal constant BEACON_REPORT_RECEIVER_POSITION =\n        0xb59039ed37776bc23c5d272e10b525a957a1dfad97f5006c84394b6b512c1564; // keccak256(\"lido.LidoOracle.beaconReportReceiver\")\n\n    /// Upper bound of the reported balance possible increase in APR, controlled by the governance\n    bytes32 internal constant ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION =\n        0x613075ab597bed8ce2e18342385ce127d3e5298bc7a84e3db68dc64abd4811ac; // keccak256(\"lido.LidoOracle.allowedBeaconBalanceAnnualRelativeIncrease\")\n\n    /// Lower bound of the reported balance possible decrease, controlled by the governance\n    ///\n    /// @notice When slashing happens, the balance may decrease at a much faster pace. Slashing are\n    /// one-time events that decrease the balance a fair amount - a few percent at a time in a\n    /// realistic scenario. Thus, instead of sanity check for an APR, we check if the plain relative\n    /// decrease is within bounds.  Note that it's not annual value, its just one-jump value.\n    bytes32 internal constant ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION =\n        0x92ba7776ed6c5d13cf023555a94e70b823a4aebd56ed522a77345ff5cd8a9109; // keccak256(\"lido.LidoOracle.allowedBeaconBalanceDecrease\")\n\n    /// This variable is from v1: the last reported epoch, used only in the initializer\n    bytes32 internal constant V1_LAST_REPORTED_EPOCH_ID_POSITION =\n        0xfe0250ed0c5d8af6526c6d133fccb8e5a55dd6b1aa6696ed0c327f8e517b5a94; // keccak256(\"lido.LidoOracle.lastReportedEpochId\")\n\n    /// Contract structured storage\n    address[] private members;                /// slot 0: oracle committee members\n    uint256[] private currentReportVariants;  /// slot 1: reporting storage\n\n\n    /**\n     * @notice Return the Lido contract address\n     */\n    function getLido() public view returns (ILido) {\n        return ILido(LIDO_POSITION.getStorageAddress());\n    }\n\n    /**\n     * @notice Return the number of exactly the same reports needed to finalize the epoch\n     */\n    function getQuorum() public view returns (uint256) {\n        return QUORUM_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return the upper bound of the reported balance possible increase in APR\n     */\n    function getAllowedBeaconBalanceAnnualRelativeIncrease() external view returns (uint256) {\n        return ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return the lower bound of the reported balance possible decrease\n     */\n    function getAllowedBeaconBalanceRelativeDecrease() external view returns (uint256) {\n        return ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Set the upper bound of the reported balance possible increase in APR to `_value`\n     */\n    function setAllowedBeaconBalanceAnnualRelativeIncrease(uint256 _value) external auth(SET_REPORT_BOUNDARIES) {\n        ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.setStorageUint256(_value);\n        emit AllowedBeaconBalanceAnnualRelativeIncreaseSet(_value);\n    }\n\n    /**\n     * @notice Set the lower bound of the reported balance possible decrease to `_value`\n     */\n    function setAllowedBeaconBalanceRelativeDecrease(uint256 _value) external auth(SET_REPORT_BOUNDARIES) {\n        ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.setStorageUint256(_value);\n        emit AllowedBeaconBalanceRelativeDecreaseSet(_value);\n    }\n\n    /**\n     * @notice Return the receiver contract address to be called when the report is pushed to Lido\n     */\n    function getBeaconReportReceiver() external view returns (address) {\n        return address(BEACON_REPORT_RECEIVER_POSITION.getStorageUint256());\n    }\n\n    /**\n     * @notice Set the receiver contract address to `_addr` to be called when the report is pushed\n     * @dev Specify 0 to disable this functionality\n     */\n    function setBeaconReportReceiver(address _addr) external auth(SET_BEACON_REPORT_RECEIVER) {\n        BEACON_REPORT_RECEIVER_POSITION.setStorageUint256(uint256(_addr));\n        emit BeaconReportReceiverSet(_addr);\n    }\n\n    /**\n     * @notice Return the current reporting bitmap, representing oracles who have already pushed\n     * their version of report during the expected epoch\n     * @dev Every oracle bit corresponds to the index of the oracle in the current members list\n     */\n    function getCurrentOraclesReportStatus() external view returns (uint256) {\n        return REPORTS_BITMASK_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return the current reporting variants array size\n     */\n    function getCurrentReportVariantsSize() external view returns (uint256) {\n        return currentReportVariants.length;\n    }\n\n    /**\n     * @notice Return the current reporting array element with index `_index`\n     */\n    function getCurrentReportVariant(uint256 _index)\n        external\n        view\n        returns (\n            uint64 beaconBalance,\n            uint32 beaconValidators,\n            uint16 count\n        )\n    {\n        return currentReportVariants[_index].decodeWithCount();\n    }\n\n    /**\n     * @notice Returns epoch that can be reported by oracles\n     */\n    function getExpectedEpochId() external view returns (uint256) {\n        return EXPECTED_EPOCH_ID_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return the current oracle member committee list\n     */\n    function getOracleMembers() external view returns (address[]) {\n        return members;\n    }\n\n    /**\n     * @notice Return the initialized version of this contract starting from 0\n     */\n    function getVersion() external view returns (uint256) {\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Return beacon specification data\n     */\n    function getBeaconSpec()\n        external\n        view\n        returns (\n            uint64 epochsPerFrame,\n            uint64 slotsPerEpoch,\n            uint64 secondsPerSlot,\n            uint64 genesisTime\n        )\n    {\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        return (\n            beaconSpec.epochsPerFrame,\n            beaconSpec.slotsPerEpoch,\n            beaconSpec.secondsPerSlot,\n            beaconSpec.genesisTime\n        );\n    }\n\n    /**\n     * @notice Update beacon specification data\n     */\n    function setBeaconSpec(\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime\n    )\n        external\n        auth(SET_BEACON_SPEC)\n    {\n        _setBeaconSpec(\n            _epochsPerFrame,\n            _slotsPerEpoch,\n            _secondsPerSlot,\n            _genesisTime\n        );\n    }\n\n    /**\n     * @notice Return the epoch calculated from current timestamp\n     */\n    function getCurrentEpochId() external view returns (uint256) {\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        return _getCurrentEpochId(beaconSpec);\n    }\n\n    /**\n     * @notice Return currently reportable epoch (the first epoch of the current frame) as well as\n     * its start and end times in seconds\n     */\n    function getCurrentFrame()\n        external\n        view\n        returns (\n            uint256 frameEpochId,\n            uint256 frameStartTime,\n            uint256 frameEndTime\n        )\n    {\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        uint64 genesisTime = beaconSpec.genesisTime;\n        uint64 secondsPerEpoch = beaconSpec.secondsPerSlot * beaconSpec.slotsPerEpoch;\n\n        frameEpochId = _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec);\n        frameStartTime = frameEpochId * secondsPerEpoch + genesisTime;\n        frameEndTime = (frameEpochId + beaconSpec.epochsPerFrame) * secondsPerEpoch + genesisTime - 1;\n    }\n\n    /**\n     * @notice Return last completed epoch\n     */\n    function getLastCompletedEpochId() external view returns (uint256) {\n        return LAST_COMPLETED_EPOCH_ID_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Report beacon balance and its change during the last frame\n     */\n    function getLastCompletedReportDelta()\n        external\n        view\n        returns (\n            uint256 postTotalPooledEther,\n            uint256 preTotalPooledEther,\n            uint256 timeElapsed\n        )\n    {\n        postTotalPooledEther = POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION.getStorageUint256();\n        preTotalPooledEther = PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION.getStorageUint256();\n        timeElapsed = TIME_ELAPSED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Initialize the contract v2 data, with sanity check bounds\n     * (`_allowedBeaconBalanceAnnualRelativeIncrease`, `_allowedBeaconBalanceRelativeDecrease`)\n     * @dev Original initialize function removed from v2 because it is invoked only once\n     */\n    function initialize_v2(\n        uint256 _allowedBeaconBalanceAnnualRelativeIncrease,\n        uint256 _allowedBeaconBalanceRelativeDecrease\n    )\n        external\n    {\n        require(CONTRACT_VERSION_POSITION.getStorageUint256() == 0, \"ALREADY_INITIALIZED\");\n        CONTRACT_VERSION_POSITION.setStorageUint256(1);\n        emit ContractVersionSet(1);\n\n        ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION\n            .setStorageUint256(_allowedBeaconBalanceAnnualRelativeIncrease);\n        emit AllowedBeaconBalanceAnnualRelativeIncreaseSet(_allowedBeaconBalanceAnnualRelativeIncrease);\n\n        ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION\n            .setStorageUint256(_allowedBeaconBalanceRelativeDecrease);\n        emit AllowedBeaconBalanceRelativeDecreaseSet(_allowedBeaconBalanceRelativeDecrease);\n\n        // set last completed epoch as V1's contract last reported epoch, in the vast majority of\n        // cases this is true, in others the error is within a frame\n        uint256 lastReportedEpoch = V1_LAST_REPORTED_EPOCH_ID_POSITION.getStorageUint256();\n        LAST_COMPLETED_EPOCH_ID_POSITION.setStorageUint256(lastReportedEpoch);\n\n        // set expected epoch to the first epoch for the next frame\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        uint256 expectedEpoch = _getFrameFirstEpochId(lastReportedEpoch, beaconSpec) + beaconSpec.epochsPerFrame;\n        EXPECTED_EPOCH_ID_POSITION.setStorageUint256(expectedEpoch);\n        emit ExpectedEpochIdUpdated(expectedEpoch);\n    }\n\n    /**\n     * @notice Add `_member` to the oracle member committee list\n     */\n    function addOracleMember(address _member) external auth(MANAGE_MEMBERS) {\n        require(address(0) != _member, \"BAD_ARGUMENT\");\n        require(MEMBER_NOT_FOUND == _getMemberId(_member), \"MEMBER_EXISTS\");\n\n        members.push(_member);\n        require(members.length < MAX_MEMBERS, \"TOO_MANY_MEMBERS\");\n        emit MemberAdded(_member);\n    }\n\n    /**\n     * @notice Remove '_member` from the oracle member committee list\n     */\n    function removeOracleMember(address _member) external auth(MANAGE_MEMBERS) {\n        uint256 index = _getMemberId(_member);\n        require(index != MEMBER_NOT_FOUND, \"MEMBER_NOT_FOUND\");\n        uint256 last = members.length - 1;\n        if (index != last) members[index] = members[last];\n        members.length--;\n        emit MemberRemoved(_member);\n\n        // delete the data for the last epoch, let remained oracles report it again\n        REPORTS_BITMASK_POSITION.setStorageUint256(0);\n        delete currentReportVariants;\n    }\n\n    /**\n     * @notice Set the number of exactly the same reports needed to finalize the epoch to `_quorum`\n     */\n    function setQuorum(uint256 _quorum) external auth(MANAGE_QUORUM) {\n        require(0 != _quorum, \"QUORUM_WONT_BE_MADE\");\n        uint256 oldQuorum = QUORUM_POSITION.getStorageUint256();\n        QUORUM_POSITION.setStorageUint256(_quorum);\n        emit QuorumChanged(_quorum);\n\n        // If the quorum value lowered, check existing reports whether it is time to push\n        if (oldQuorum > _quorum) {\n            (bool isQuorum, uint256 report) = _getQuorumReport(_quorum);\n            if (isQuorum) {\n                (uint64 beaconBalance, uint32 beaconValidators) = report.decode();\n                _push(\n                     EXPECTED_EPOCH_ID_POSITION.getStorageUint256(),\n                     DENOMINATION_OFFSET * uint128(beaconBalance),\n                     beaconValidators,\n                     _getBeaconSpec()\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Accept oracle committee member reports from the ETH 2.0 side\n     * @param _epochId Beacon chain epoch\n     * @param _beaconBalance Balance in gwei on the ETH 2.0 side (9-digit denomination)\n     * @param _beaconValidators Number of validators visible in this epoch\n     */\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators) external {\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\n        uint256 expectedEpoch = EXPECTED_EPOCH_ID_POSITION.getStorageUint256();\n        require(_epochId >= expectedEpoch, \"EPOCH_IS_TOO_OLD\");\n\n        // if expected epoch has advanced, check that this is the first epoch of the current frame\n        // and clear the last unsuccessful reporting\n        if (_epochId > expectedEpoch) {\n            require(_epochId == _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec), \"UNEXPECTED_EPOCH\");\n            _clearReportingAndAdvanceTo(_epochId);\n        }\n\n        uint128 beaconBalanceEth1 = DENOMINATION_OFFSET * uint128(_beaconBalance);\n        emit BeaconReported(_epochId, beaconBalanceEth1, _beaconValidators, msg.sender);\n\n        // make sure the oracle is from members list and has not yet voted\n        uint256 index = _getMemberId(msg.sender);\n        require(index != MEMBER_NOT_FOUND, \"MEMBER_NOT_FOUND\");\n        uint256 bitMask = REPORTS_BITMASK_POSITION.getStorageUint256();\n        uint256 mask = 1 << index;\n        require(bitMask & mask == 0, \"ALREADY_SUBMITTED\");\n        REPORTS_BITMASK_POSITION.setStorageUint256(bitMask | mask);\n\n        // push this report to the matching kind\n        uint256 report = ReportUtils.encode(_beaconBalance, _beaconValidators);\n        uint256 quorum = getQuorum();\n        uint256 i = 0;\n\n        // iterate on all report variants we already have, limited by the oracle members maximum\n        while (i < currentReportVariants.length && currentReportVariants[i].isDifferent(report)) ++i;\n        if (i < currentReportVariants.length) {\n            if (currentReportVariants[i].getCount() + 1 >= quorum) {\n                _push(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\n            } else {\n                ++currentReportVariants[i]; // increment report counter, see ReportUtils for details\n            }\n        } else {\n            if (quorum == 1) {\n                _push(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\n            } else {\n                currentReportVariants.push(report + 1);\n            }\n        }\n    }\n\n    /**\n     * @notice Return beacon specification data\n     */\n    function _getBeaconSpec()\n        internal\n        view\n        returns (BeaconSpec memory beaconSpec)\n    {\n        uint256 data = BEACON_SPEC_POSITION.getStorageUint256();\n        beaconSpec.epochsPerFrame = uint64(data >> 192);\n        beaconSpec.slotsPerEpoch = uint64(data >> 128);\n        beaconSpec.secondsPerSlot = uint64(data >> 64);\n        beaconSpec.genesisTime = uint64(data);\n        return beaconSpec;\n    }\n\n    /**\n     * @notice Return whether the `_quorum` is reached and the final report\n     */\n    function _getQuorumReport(uint256 _quorum) internal view returns (bool isQuorum, uint256 report) {\n        // check most frequent cases first: all reports are the same or no reports yet\n        if (currentReportVariants.length == 1) {\n            return (currentReportVariants[0].getCount() >= _quorum, currentReportVariants[0]);\n        } else if (currentReportVariants.length == 0) {\n            return (false, 0);\n        }\n\n        // if more than 2 kind of reports exist, choose the most frequent\n        uint256 maxind = 0;\n        uint256 repeat = 0;\n        uint16 maxval = 0;\n        uint16 cur = 0;\n        for (uint256 i = 0; i < currentReportVariants.length; ++i) {\n            cur = currentReportVariants[i].getCount();\n            if (cur >= maxval) {\n                if (cur == maxval) {\n                    ++repeat;\n                } else {\n                    maxind = i;\n                    maxval = cur;\n                    repeat = 0;\n                }\n            }\n        }\n        return (maxval >= _quorum && repeat == 0, currentReportVariants[maxind]);\n    }\n\n    /**\n     * @notice Set beacon specification data\n     */\n    function _setBeaconSpec(\n        uint64 _epochsPerFrame,\n        uint64 _slotsPerEpoch,\n        uint64 _secondsPerSlot,\n        uint64 _genesisTime\n    )\n        internal\n    {\n        require(_epochsPerFrame > 0, \"BAD_EPOCHS_PER_FRAME\");\n        require(_slotsPerEpoch > 0, \"BAD_SLOTS_PER_EPOCH\");\n        require(_secondsPerSlot > 0, \"BAD_SECONDS_PER_SLOT\");\n        require(_genesisTime > 0, \"BAD_GENESIS_TIME\");\n\n        uint256 data = (\n            uint256(_epochsPerFrame) << 192 |\n            uint256(_slotsPerEpoch) << 128 |\n            uint256(_secondsPerSlot) << 64 |\n            uint256(_genesisTime)\n        );\n        BEACON_SPEC_POSITION.setStorageUint256(data);\n        emit BeaconSpecSet(\n            _epochsPerFrame,\n            _slotsPerEpoch,\n            _secondsPerSlot,\n            _genesisTime);\n    }\n\n    /**\n     * @notice Push the given report to Lido and performs accompanying accounting\n     * @param _epochId Beacon chain epoch, proven to be >= expected epoch and <= current epoch\n     * @param _beaconBalanceEth1 Validators balance in eth1 (18-digit denomination)\n     * @param _beaconSpec current beacon specification data\n     */\n    function _push(\n        uint256 _epochId,\n        uint128 _beaconBalanceEth1,\n        uint128 _beaconValidators,\n        BeaconSpec memory _beaconSpec\n    )\n        internal\n    {\n        emit Completed(_epochId, _beaconBalanceEth1, _beaconValidators);\n\n        // now this frame is completed, so the expected epoch should be advanced to the first epoch\n        // of the next frame\n        _clearReportingAndAdvanceTo(_epochId + _beaconSpec.epochsPerFrame);\n\n        // report to the Lido and collect stats\n        ILido lido = getLido();\n        uint256 prevTotalPooledEther = lido.totalSupply();\n        lido.pushBeacon(_beaconValidators, _beaconBalanceEth1);\n        uint256 postTotalPooledEther = lido.totalSupply();\n\n        PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION.setStorageUint256(prevTotalPooledEther);\n        POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION.setStorageUint256(postTotalPooledEther);\n        uint256 timeElapsed = (_epochId - LAST_COMPLETED_EPOCH_ID_POSITION.getStorageUint256()) *\n            _beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot;\n        TIME_ELAPSED_POSITION.setStorageUint256(timeElapsed);\n        LAST_COMPLETED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\n\n        // rollback on boundaries violation\n        _reportSanityChecks(postTotalPooledEther, prevTotalPooledEther, timeElapsed);\n\n        // emit detailed statistics and call the quorum delegate with this data\n        emit PostTotalShares(postTotalPooledEther, prevTotalPooledEther, timeElapsed, lido.getTotalShares());\n        IBeaconReportReceiver receiver = IBeaconReportReceiver(BEACON_REPORT_RECEIVER_POSITION.getStorageUint256());\n        if (address(receiver) != address(0)) {\n            receiver.processLidoOracleReport(postTotalPooledEther, prevTotalPooledEther, timeElapsed);\n        }\n    }\n\n    /**\n     * @notice Remove the current reporting progress and advances to accept the later epoch `_epochId`\n     */\n    function _clearReportingAndAdvanceTo(uint256 _epochId) internal {\n        REPORTS_BITMASK_POSITION.setStorageUint256(0);\n        EXPECTED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\n        delete currentReportVariants;\n        emit ExpectedEpochIdUpdated(_epochId);\n    }\n\n    /**\n     * @notice Performs logical consistency check of the Lido changes as the result of reports push\n     * @dev To make oracles less dangerous, we limit rewards report by 10% _annual_ increase and 5%\n     * _instant_ decrease in stake, with both values configurable by the governance in case of\n     * extremely unusual circumstances.\n     **/\n    function _reportSanityChecks(\n        uint256 _postTotalPooledEther,\n        uint256 _preTotalPooledEther,\n        uint256 _timeElapsed)\n        internal\n        view\n    {\n        if (_postTotalPooledEther >= _preTotalPooledEther) {\n            // increase                 = _postTotalPooledEther - _preTotalPooledEther,\n            // relativeIncrease         = increase / _preTotalPooledEther,\n            // annualRelativeIncrease   = relativeIncrease / (timeElapsed / 365 days),\n            // annualRelativeIncreaseBp = annualRelativeIncrease * 10000, in basis points 0.01% (1e-4)\n            uint256 allowedAnnualRelativeIncreaseBp =\n                ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.getStorageUint256();\n            // check that annualRelativeIncreaseBp <= allowedAnnualRelativeIncreaseBp\n            require(uint256(10000 * 365 days).mul(_postTotalPooledEther - _preTotalPooledEther) <=\n                    allowedAnnualRelativeIncreaseBp.mul(_preTotalPooledEther).mul(_timeElapsed),\n                    \"ALLOWED_BEACON_BALANCE_INCREASE\");\n        } else {\n            // decrease           = _preTotalPooledEther - _postTotalPooledEther\n            // relativeDecrease   = decrease / _preTotalPooledEther\n            // relativeDecreaseBp = relativeDecrease * 10000, in basis points 0.01% (1e-4)\n            uint256 allowedRelativeDecreaseBp =\n                ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.getStorageUint256();\n            // check that relativeDecreaseBp <= allowedRelativeDecreaseBp\n            require(uint256(10000).mul(_preTotalPooledEther - _postTotalPooledEther) <=\n                    allowedRelativeDecreaseBp.mul(_preTotalPooledEther),\n                    \"ALLOWED_BEACON_BALANCE_DECREASE\");\n        }\n    }\n\n    /**\n     * @notice Return `_member` index in the members list or MEMBER_NOT_FOUND\n     */\n    function _getMemberId(address _member) internal view returns (uint256) {\n        uint256 length = members.length;\n        for (uint256 i = 0; i < length; ++i) {\n            if (members[i] == _member) {\n                return i;\n            }\n        }\n        return MEMBER_NOT_FOUND;\n    }\n\n    /**\n     * @notice Return the epoch calculated from current timestamp\n     */\n    function _getCurrentEpochId(BeaconSpec memory _beaconSpec) internal view returns (uint256) {\n        return (_getTime() - _beaconSpec.genesisTime) / (_beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot);\n    }\n\n    /**\n     * @notice Return the first epoch of the frame that `_epochId` belongs to\n     */\n    function _getFrameFirstEpochId(uint256 _epochId, BeaconSpec memory _beaconSpec) internal view returns (uint256) {\n        return _epochId / _beaconSpec.epochsPerFrame * _beaconSpec.epochsPerFrame;\n    }\n\n    /**\n     * @notice Return the current timestamp\n     */\n    function _getTime() internal view returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n}\n"},"contracts/0.4.24/oracle/ReportUtils.sol":{"content":"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.4.24;\n\n/**\n * Utility functions for effectively storing reports within a single storage slot\n *\n * +00 | uint16 | count            | 0..256  | number of reports received exactly like this\n * +16 | uint32 | beaconValidators | 0..1e9  | number of Lido's validators in beacon chain\n * +48 | uint64 | beaconBalance    | 0..1e18 | total amout of their balance\n *\n * Note that the 'count' is the leftmost field here. Thus it is possible to apply addition\n * operations to it when it is encoded, provided that you watch for the overflow.\n */\nlibrary ReportUtils {\n    uint256 constant internal COUNT_OUTMASK = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000;\n\n    function encode(uint64 beaconBalance, uint32 beaconValidators) internal pure returns (uint256) {\n        return uint256(beaconBalance) << 48 | uint256(beaconValidators) << 16;\n    }\n\n    function decode(uint256 value) internal pure returns (uint64 beaconBalance, uint32 beaconValidators) {\n        beaconBalance = uint64(value >> 48);\n        beaconValidators = uint32(value >> 16);\n    }\n\n    function decodeWithCount(uint256 value)\n        internal pure\n        returns (\n            uint64 beaconBalance,\n            uint32 beaconValidators,\n            uint16 count\n        ) {\n        beaconBalance = uint64(value >> 48);\n        beaconValidators = uint32(value >> 16);\n        count = uint16(value);\n    }\n\n    /// @notice Check if the given reports are different, not considering the counter of the first\n    function isDifferent(uint256 value, uint256 that) internal pure returns(bool) {\n        return (value & COUNT_OUTMASK) != that;\n    }\n\n    function getCount(uint256 value) internal pure returns(uint16) {\n        return uint16(value);\n    }\n}\n"}}}