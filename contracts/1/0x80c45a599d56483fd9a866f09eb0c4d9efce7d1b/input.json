{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DefiVusdc.sol":{"content":"// SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.6.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this;\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    address private _previousOwner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n}\n\ninterface IController {\n    function aaveReferralCode() external view returns (uint16);\n\n    function feeCollector(address) external view returns (address);\n\n    function founderFee() external view returns (uint256);\n\n    function founderVault() external view returns (address);\n\n    function interestFee(address) external view returns (uint256);\n\n    function isPool(address) external view returns (bool);\n\n    function pools() external view returns (address);\n\n    function strategy(address) external view returns (address);\n\n    function rebalanceFriction(address) external view returns (uint256);\n\n    function poolRewards(address) external view returns (address);\n\n    function treasuryPool() external view returns (address);\n\n    function uniswapRouter() external view returns (address);\n\n    function withdrawFee(address) external view returns (uint256);\n}\n\ninterface IPoolRewards {\n    function notifyRewardAmount(uint256) external;\n\n    function claimReward(address) external;\n\n    function updateReward(address) external;\n\n    function rewardForDuration() external view returns (uint256);\n\n    function claimable(address) external view returns (uint256);\n\n    function pool() external view returns (address);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n}\n\ninterface VTokenBase {\n    function deposit(uint256) external;\n    function rebalance() external;\n    function withdraw(uint256) external;\n    function getPricePerShare() external view returns (uint256);\n    function token() external view returns (address);\n    function totalValue() external view returns (uint256);\n    function withdrawFee() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ncontract DefiVusdc is Context, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using Address for address;\n    \n    VTokenBase private _vTokenPool;\n    IController private _controller;\n    IPoolRewards private _poolRewards;\n    \n    IERC20 public _stakingToken;\n    \n    mapping(address => Stake[]) public _userStakes;\n    mapping(address => UserTotals) public _userTotals;\n    \n    uint256 public _totalStakingShares = 0;\n    uint256 public _totalStakingShareSeconds = 0;\n    uint256 public _lastAccountingTimestampSec = now;\n    uint256 public _initialSharesPerToken = 0;\n    \n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant VESPER = 0x1b40183EFB4Dd766f11bDa7A7c3AD8982e998421;\n     \n    struct Stake {\n        uint256 stakingShares;\n        uint256 timestampSec;\n    }\n    \n    struct UserTotals {\n        uint256 stakingShares;\n        uint256 stakingShareSeconds;\n        uint256 lastAccountingTimestampSec;\n    }\n    \n    event Staked(address indexed user, uint256 amount, uint256 vamount);\n    event Unstaked(address indexed user, uint256 amount);\n    \n    constructor (\n                    address vTokenPool,\n                    address controller,\n                    address poolRewards,\n                    address stakingToken,\n                    uint256 initialSharesPerToken\n    ) public {\n        _controller = IController(controller);\n        \n        require(_controller.isPool(vTokenPool), \"ERR: this is not correct pool.\");\n        _vTokenPool = VTokenBase(vTokenPool);\n        \n        require(_vTokenPool.token() == stakingToken, \"ERR: token is not correct for the pool.\");\n        _stakingToken = IERC20(stakingToken);\n        \n        require(_controller.poolRewards(vTokenPool) == poolRewards, \"ERR: this is not correct poolRewards.\");\n        _poolRewards = IPoolRewards(poolRewards);\n\n        _initialSharesPerToken = initialSharesPerToken;\n        \n        _stakingToken.approve(vTokenPool, type(uint256).max);\n    }\n    \n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, 'ERR: stake amount is zero');\n\n        require(_totalStakingShares == 0 || totalStaked() > 0,\n                'ERR: Invalid state. Staking shares exist, but no staking tokens do');\n\n        // interactions\n        _stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        _vTokenPool.deposit(amount);\n        \n        uint256 vTokenBalance = _vTokenPool.balanceOf(address(this));\n                        \n        uint256 mintedStakingShares = (_totalStakingShares > 0)\n            ? _totalStakingShares.mul(vTokenBalance).div(totalStaked())\n            : vTokenBalance.mul(_initialSharesPerToken);\n        require(mintedStakingShares > 0, 'ERR: Stake amount is too small');\n        \n        updateAccounting();\n        \n        // 1. User Accounting\n        UserTotals storage totals = _userTotals[msg.sender];\n        totals.stakingShares = totals.stakingShares.add(mintedStakingShares);\n        totals.lastAccountingTimestampSec = now;\n        \n        Stake memory newStake = Stake(mintedStakingShares, now);\n        _userStakes[msg.sender].push(newStake);\n        \n        // 2. Global Accounting\n        _totalStakingShares = _totalStakingShares.add(mintedStakingShares);\n        \n        Staked(msg.sender, amount, vTokenBalance);\n    }\n    \n    function withdraw(uint256 amount) external nonReentrant {\n        updateAccounting();\n        \n        require(amount > 0, 'ERR: unstake amount is zero');\n        require(totalStakedFor(msg.sender) >= amount,\n            'ERR: unstake amount is greater than total user stakes');\n        uint256 stakingSharesToBurn = _totalStakingShares.mul(amount).div(totalStaked());\n        require(stakingSharesToBurn > 0, 'ERR: Unable to unstake amount this small');\n        \n        // 1. User Accounting\n        UserTotals storage totals = _userTotals[msg.sender];\n        Stake[] storage accountStakes = _userStakes[msg.sender];\n        \n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 stakingShareSecondsToBurn = 0;\n        uint256 sharesLeftToBurn = stakingSharesToBurn;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec = now.sub(lastStake.timestampSec);\n            uint256 newStakingShareSecondsToBurn = 0;\n            if (lastStake.stakingShares <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                newStakingShareSecondsToBurn = lastStake.stakingShares.mul(stakeTimeSec);\n                stakingShareSecondsToBurn = stakingShareSecondsToBurn.add(newStakingShareSecondsToBurn);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.stakingShares);\n                accountStakes.pop();\n            } else {\n                // partially redeem a past stake\n                newStakingShareSecondsToBurn = sharesLeftToBurn.mul(stakeTimeSec);\n                stakingShareSecondsToBurn = stakingShareSecondsToBurn.add(newStakingShareSecondsToBurn);\n                lastStake.stakingShares = lastStake.stakingShares.sub(sharesLeftToBurn);\n                sharesLeftToBurn = 0;\n            }\n        }\n        totals.stakingShareSeconds = totals.stakingShareSeconds.sub(stakingShareSecondsToBurn);\n        totals.stakingShares = totals.stakingShares.sub(stakingSharesToBurn);\n        \n        // 2. Global Accounting\n        _totalStakingShareSeconds = _totalStakingShareSeconds.sub(stakingShareSecondsToBurn);\n        _totalStakingShares = _totalStakingShares.sub(stakingSharesToBurn);\n        \n        // interactions\n        compound(false);\n        uint256 stakingTokenBalance = _stakingToken.balanceOf(address(this));\n        uint256 vaultAmount = stakingTokenBalance.mul(totalStaked().sub(amount)).div(totalStaked());\n        \n        _vTokenPool.withdraw(amount);\n        stakingTokenBalance = _stakingToken.balanceOf(address(this));\n        _stakingToken.safeTransfer(msg.sender, stakingTokenBalance.sub(vaultAmount));\n        \n        _vTokenPool.deposit(_stakingToken.balanceOf(address(this)));\n\n        emit Unstaked(msg.sender, amount);\n\n        require(_totalStakingShares == 0 || totalStaked() > 0,\n                \"ERR: Error unstaking. Staking shares exist, but no staking tokens do\");\n\n    }\n    \n    function updateAccounting() public {\n        // Global accounting\n        uint256 newStakingShareSeconds =\n            now\n            .sub(_lastAccountingTimestampSec)\n            .mul(_totalStakingShares);\n        _totalStakingShareSeconds = _totalStakingShareSeconds.add(newStakingShareSeconds);\n        _lastAccountingTimestampSec = now;\n        \n        // User Accounting\n        UserTotals storage totals = _userTotals[msg.sender];\n        uint256 newUserStakingShareSeconds =\n            now\n            .sub(totals.lastAccountingTimestampSec)\n            .mul(totals.stakingShares);\n        totals.stakingShareSeconds =\n            totals.stakingShareSeconds\n            .add(newUserStakingShareSeconds);\n        totals.lastAccountingTimestampSec = now;\n    }\n    \n    function compound(bool vaultFlag) internal nonReentrant {\n        _poolRewards.claimReward(address(this));\n        uint256 vesperAmount = IERC20(VESPER).balanceOf(address(this));\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(_controller.uniswapRouter());\n        address[] memory path = _getPath(VESPER, address(_stakingToken));\n        uint256 amountOut = uniswapRouter.getAmountsOut(vesperAmount, path)[path.length - 1];\n        if (amountOut != 0) {\n            IERC20(VESPER).safeApprove(address(uniswapRouter), 0);\n            IERC20(VESPER).safeApprove(address(uniswapRouter), vesperAmount);\n            uniswapRouter.swapExactTokensForTokens(vesperAmount, 1, path, address(this), now + 30);\n            if(vaultFlag)\n                _vTokenPool.deposit(_stakingToken.balanceOf(address(this)));\n        }\n    }\n    \n    function harvest() external nonReentrant {\n        compound(true);\n    }\n    \n    function totalStaked() public view returns (uint256) {\n        return _vTokenPool.balanceOf(address(this));\n    }\n    \n    function totalStakedFor(address addr) public view returns (uint256) {\n        return _totalStakingShares > 0 ?\n            totalStaked().mul(_userTotals[addr].stakingShares).div(_totalStakingShares) : 0;\n    }\n    \n    function _getPath(address _from, address _to) internal pure returns (address[] memory) {\n        address[] memory path;\n        if (_from == WETH || _to == WETH) {\n            path = new address[](2);\n            path[0] = _from;\n            path[1] = _to;\n        } else {\n            path = new address[](3);\n            path[0] = _from;\n            path[1] = WETH;\n            path[2] = _to;\n        }\n        return path;\n    }\n}"}}}