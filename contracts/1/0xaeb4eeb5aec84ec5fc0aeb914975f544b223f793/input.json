{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "aave permissioned/checkReserveBalance.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IProtocolDataProvider {\n  function getReserveConfigurationData(address asset) external view returns (uint256 decimals, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus, uint256 reserveFactor, bool usageAsCollateralEnabled, bool borrowingEnabled, bool stableBorrowRateEnabled, bool isActive, bool isFrozen);\n  function getReserveData(address asset) external view returns (uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp);\n  function getUserReserveData(address asset, address user) external view returns (uint256 currentATokenBalance, uint256 currentStableDebt, uint256 currentVariableDebt, uint256 principalStableDebt, uint256 scaledVariableDebt, uint256 stableBorrowRate, uint256 liquidityRate, uint40 stableRateLastUpdated, bool usageAsCollateralEnabled);\n  function getReserveTokensAddresses(address asset) external view returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);\n}\n\ninterface ILendingPool {\n  function getUserAccountData(address user) external view returns (\n      uint256 totalCollateralETH,\n      uint256 totalDebtETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n  );\n}\n\ninterface IERC20 {\n    function balanceOf(address _owner) external view returns(uint balance);\n}\n\ncontract checkBalance {\n    receive() external payable {}\n\n    address[] public reserves;\n    address[] public aTokens;\n    address[] public sdTokens;\n    address[] public vdTokens;\n\n    struct Position {\n        address account;\n        address token;\n        uint256 balance;\n        uint256 what;\n    }\n\n    IProtocolDataProvider public dataProvider = IProtocolDataProvider(address(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d));\n    ILendingPool public lendingPool = ILendingPool(address(0x37D7306019a38Af123e4b245Eb6C28AF552e0bB0));\n\n    function executeOperation(address[] memory users) public view returns (Position[] memory) {\n        Position[] memory result = new Position[](users.length*reserves.length);\n\n        uint256 x;\n        uint256 y;\n\n        for(x = 0; x < users.length; x++) {\n            for(y = 0; y < reserves.length; y++) {\n                if (reserves[y] != 0x0000000000000000000000000000000000000000) {\n                    uint256 balance;\n                    uint256 what;\n                    uint256 currentATokenBalance;\n                    uint256 currentStableDebt;\n                    uint256 currentVariableDebt;\n\n                    currentATokenBalance = IERC20(aTokens[y]).balanceOf(users[x]);\n                    currentVariableDebt = IERC20(sdTokens[y]).balanceOf(users[x]);\n                    currentStableDebt = IERC20(vdTokens[y]).balanceOf(users[x]);\n\n                    if (currentATokenBalance > 0 && currentVariableDebt == 0 && currentStableDebt == 0) {\n                        balance = currentATokenBalance;\n                        what = 0;\n                    } else if (currentATokenBalance == 0 && currentVariableDebt > 0 && currentStableDebt == 0) {\n                        balance = currentVariableDebt;\n                        what = 1;\n                    } else if (currentATokenBalance == 0 && currentVariableDebt == 0 && currentStableDebt > 0) {\n                        balance = currentStableDebt;\n                        what = 2;\n                    }\n\n                    Position memory newPosition = Position(users[x], reserves[y], balance, what);\n                    result[x * reserves.length + y] = newPosition;\n                }\n            }\n        }\n        return result;\n    }\n\n    function addTokens(address[] memory tokens) public {\n        uint256 i;\n        for(i = 0; i < tokens.length; i++) {\n            (address at, address sd, address vd) = dataProvider.getReserveTokensAddresses(tokens[i]);\n            reserves.push(tokens[i]);\n            aTokens.push(at);\n            sdTokens.push(sd);\n            vdTokens.push(vd);\n        }\n    }\n\n    function delTokens(uint256[] memory tokens) public {\n        uint256 i;\n        for(i = 0; i < tokens.length; i++) {\n            delete reserves[tokens[i]];\n            delete aTokens[tokens[i]];\n            delete sdTokens[tokens[i]];\n            delete vdTokens[tokens[i]];\n        }\n    }\n}\n\n// 0xB6f00E1F24F96e6390f9397B7fC888BD6b81310C\n// [{ \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"} ], \"name\": \"aTokens\", \"outputs\": [ { \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\"} ], \"stateMutability\": \"view\", \"type\": \"function\"}, { \"inputs\": [ { \"internalType\": \"address[]\", \"name\": \"tokens\", \"type\": \"address[]\"} ], \"name\": \"addTokens\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\"}, { \"inputs\": [], \"name\": \"dataProvider\", \"outputs\": [ { \"internalType\": \"contract IProtocolDataProvider\", \"name\": \"\", \"type\": \"address\"} ], \"stateMutability\": \"view\", \"type\": \"function\"}, { \"inputs\": [ { \"internalType\": \"uint256[]\", \"name\": \"tokens\", \"type\": \"uint256[]\"} ], \"name\": \"delTokens\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\"}, { \"inputs\": [ { \"internalType\": \"address[]\", \"name\": \"users\", \"type\": \"address[]\"} ], \"name\": \"executeOperation\", \"outputs\": [ { \"components\": [ { \"internalType\": \"address\", \"name\": \"account\", \"type\": \"address\"}, { \"internalType\": \"address\", \"name\": \"token\", \"type\": \"address\"}, { \"internalType\": \"uint256\", \"name\": \"balance\", \"type\": \"uint256\"}, { \"internalType\": \"uint256\", \"name\": \"what\", \"type\": \"uint256\"} ], \"internalType\": \"struct checkBalance.Position[]\", \"name\": \"\", \"type\": \"tuple[]\"} ], \"stateMutability\": \"view\", \"type\": \"function\"}, { \"inputs\": [], \"name\": \"lendingPool\", \"outputs\": [ { \"internalType\": \"contract ILendingPool\", \"name\": \"\", \"type\": \"address\"} ], \"stateMutability\": \"view\", \"type\": \"function\"}, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"} ], \"name\": \"reserves\", \"outputs\": [ { \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\"} ], \"stateMutability\": \"view\", \"type\": \"function\"}, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"} ], \"name\": \"sdTokens\", \"outputs\": [ { \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\"} ], \"stateMutability\": \"view\", \"type\": \"function\"}, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\"} ], \"name\": \"vdTokens\", \"outputs\": [ { \"internalType\": \"address\", \"name\": \"\", \"type\": \"address\"} ], \"stateMutability\": \"view\", \"type\": \"function\"}, { \"stateMutability\": \"payable\", \"type\": \"receive\"}]"
    }
  }
}