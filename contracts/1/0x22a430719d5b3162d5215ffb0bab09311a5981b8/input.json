{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/DepositFund.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./OBOControl.sol\";\nimport \"./WithdrawFundsControl.sol\";\n\ncontract DepositFund is OBOControl, WithdrawFundsControl {\n    struct ReturnRequest {\n        address payable toAddress;\n        uint256 requestId;\n        uint256 metadataId;\n        uint256 amount;\n    }\n    struct RequestStatus {\n        uint256 requestId;\n        bool status;\n    }\n    bool public refundsEnabled = false;\n    mapping (uint256 => bool) public closedRequests;\n    // metadata id to boolean\n    mapping (uint256 => bool) public returnedMetadata;\n\n    event DepositEvent(\n        address fromAddress,\n        uint256 amountInWei,\n        uint256 requestId,\n        uint256 metadataId);\n    event RequestCloseEvent(\n        uint256 requestId,\n        bool status);\n    event ReturnEvent(\n        address toAddress,\n        uint256 amountInWei,\n        uint256 requestId,\n        uint256 metadataId);\n    event WithdrawEvent(\n        address withdrawAddress);\n\n    constructor (\n            address _oboAddress,\n            address _withdrawAddress) {\n        addApprovedOBOImmediately(_oboAddress);\n        addApprovedWithdrawAddressImmediately(_withdrawAddress);\n    }\n\n    // Call this function to know what kind of contract this is\n    function typeOfContract() public pure returns (bytes32) {\n        // bytes32(\"depositfund\")\n        return 0x6465706f73697466756e64000000000000000000000000000000000000000000;\n    }\n\n    // External user can deposit money into this contract\n    // we listen for this event and do the needful.\n    // We will assign a requestId for each request.\n    function deposit(uint256 requestId, uint256 metadataId) external payable whenNotPaused {\n        require(msg.value > 0, \"set msg.value\");\n        require(closedRequests[requestId] != true, \"requestId closed\");\n        emit DepositEvent(msg.sender, msg.value, requestId, metadataId);\n    }\n\n    // Once a drop is closed we will like to stop taking deposits on some\n    // requests. We can set those requests to closed that way we dont have\n    // to refund that money and loose money on gas.\n    function closeRequests(RequestStatus[] memory requests) external isApprovedOBO {\n        for (uint32 i=0; i < requests.length; i++) {\n            RequestStatus memory request = requests[i];\n            if (request.status == true) {\n                closedRequests[request.requestId] = request.status;\n            } else {\n                delete closedRequests[request.requestId];\n            }\n            emit RequestCloseEvent(request.requestId, request.status);\n        }\n    }\n\n    // Refund many users at once. Only approveOBO addresses can call this.\n    // Before calling this function the enableRefunds bool needs to be set\n    // to true by owner.\n    function refundRequests(ReturnRequest[] memory requests) external isApprovedOBO {\n        require(refundsEnabled == true, \"returns disabled\");\n        for (uint32 i=0; i < requests.length; i++) {\n            ReturnRequest memory request = requests[i];\n            require(returnedMetadata[request.metadataId] == false, \"already returned\");\n            returnedMetadata[request.metadataId] = true;\n            request.toAddress.transfer(request.amount);\n            emit ReturnEvent(request.toAddress, request.amount,\n                request.requestId, request.metadataId);\n        }\n    }\n\n    // Enable refunds as a global flag. Only owner can do it.\n    function toggleRefundStatus(bool status) external onlyOwner {\n        refundsEnabled = status;\n    }\n\n    /**\n     * Withdraws all the funds to a specified non-zero address.\n     */\n    function withdrawFunds(address payable _withdrawAddress) public isApprovedOBO {\n        require(isApprovedWithdrawAddress(_withdrawAddress), \"unapproved withdrawAddress\");\n        _withdrawAddress.transfer(address(this).balance);\n        emit WithdrawEvent(_withdrawAddress);\n    }\n}"},"localhost/OBOControl.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\nimport \"./framework/Ownable.sol\";\n\n\ncontract OBOControl is Ownable {\n    uint256 constant public newAddressWaitPeriod = 60 * 60 * 24 * 2;\n    bool public isInitialOBOAdded = false;\n\n    // List of approved on behalf of users.\n    mapping (address => uint256) public approvedOBOs;\n\n    event NewOBOAddressEvent(\n        address OBOAddress,\n        bool action);\n\n    /**\n     * Add a new approvedOBO address. The address can be used after wait period.\n     */\n    function addApprovedOBO(address _oboAddress) external onlyOwner {\n        require(_oboAddress != address(0), \"cant set to 0x\");\n        approvedOBOs[_oboAddress] = block.timestamp;\n        emit NewOBOAddressEvent(_oboAddress, true);\n    }\n\n    /**\n     * Removes an approvedOBO immediately.\n     */\n    function removeApprovedOBO(address _oboAddress) external onlyOwner {\n        delete approvedOBOs[_oboAddress];\n        emit NewOBOAddressEvent(_oboAddress, false);\n    }\n\n    /*\n     * Add OBOAddress for immediate use. This is an internal only Fn that is called\n     * only when the contract is deployed.\n     */\n    function addApprovedOBOImmediately(address _oboAddress) internal onlyOwner {\n        if (_oboAddress != address(0)) {\n            // set the date to one in past so that address is active immediately.\n            approvedOBOs[_oboAddress] = block.timestamp - newAddressWaitPeriod - 1;\n            emit NewOBOAddressEvent(_oboAddress, true);\n        }\n    }\n\n    function addApprovedOBOAfterDeploy(address _oboAddress) external onlyOwner {\n        require(isInitialOBOAdded == false, \"Initial OBO already added\");\n        addApprovedOBOImmediately(_oboAddress);\n        isInitialOBOAdded = true;\n    }\n\n    /*\n     * Helper function to verify is a given address is a valid approvedOBO address.\n     */\n    function isValidApprovedOBO(address _oboAddress) public view returns (bool) {\n        uint256 createdAt = approvedOBOs[_oboAddress];\n        if (createdAt == 0) {\n            return false;\n        }\n        return block.timestamp - createdAt > newAddressWaitPeriod;\n    }\n\n    /**\n    * @dev Modifier to make the obo calls only callable by approved addressess\n    */\n    modifier isApprovedOBO() {\n        require(isValidApprovedOBO(msg.sender), \"unauthorized OBO user\");\n        _;\n    }\n}"},"localhost/WithdrawFundsControl.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\nimport \"./framework/Ownable.sol\";\nimport \"./framework/Pausable.sol\";\n\n\ncontract WithdrawFundsControl is Ownable, Pausable {\n\n    // List of approved on withdraw addresses\n    mapping (address => uint256) public approvedWithdrawAddresses;\n    bool public isInitialWithdrawAddressAdded = false;\n\n    // Full week wait period before an approved withdraw address becomes active\n    uint256 constant public withdrawApprovalWaitPeriod = 60 * 60 * 24 * 3;\n\n    event WithdrawAddressAdded(address withdrawAddress);\n    event WithdrawAddressRemoved(address widthdrawAddress);\n\n    /**\n     * Add a new approved on behalf of user address.\n     */\n    function addApprovedWithdrawAddress(address _withdrawAddress) external onlyOwner {\n        approvedWithdrawAddresses[_withdrawAddress] = block.timestamp;\n        emit WithdrawAddressAdded(_withdrawAddress);\n    }\n\n    /*\n     * Add new withdrawAddress for immediate use. This is an internal only Fn that is called\n     * only when the contract is deployed.\n     */\n    function addApprovedWithdrawAddressImmediately(address _withdrawAddress) internal onlyOwner {\n        if (_withdrawAddress != address(0)) {\n            // set the date to one in past so that address is active immediately.\n            approvedWithdrawAddresses[_withdrawAddress] = block.timestamp - withdrawApprovalWaitPeriod - 1;\n            emit WithdrawAddressAdded(_withdrawAddress);\n        }\n    }\n\n    /**\n     * Removes an approved on bhealf of user address.\n     */\n    function removeApprovedWithdrawAddress(address _withdrawAddress) external onlyOwner {\n        delete approvedWithdrawAddresses[_withdrawAddress];\n        emit WithdrawAddressRemoved(_withdrawAddress);\n    }\n\n    function addApprovedWithdrawAddressAfterDeploy(address _withdrawAddress) external onlyOwner {\n        require(isInitialWithdrawAddressAdded == false, \"Initial withdraw address already added\");\n        addApprovedWithdrawAddressImmediately(_withdrawAddress);\n        isInitialWithdrawAddressAdded = true;\n    }\n\n    /**\n     * Checks that a given withdraw address ia approved and is past it's required\n     * wait time.\n     */\n    function isApprovedWithdrawAddress(address _withdrawAddress) internal view returns (bool)  {\n        uint256 approvalTime = approvedWithdrawAddresses[_withdrawAddress];\n        require (approvalTime > 0, \"withdraw address is not registered\");\n        return block.timestamp - approvalTime > withdrawApprovalWaitPeriod;\n    }\n}"},"localhost/framework/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"localhost/framework/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"localhost/framework/Pausable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}"}}}