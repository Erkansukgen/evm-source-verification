{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/EasyBooster.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.6.9;\n\nimport \"./SafeMath.sol\";\n\ncontract EasyBooster {\n    using SafeMath for *;\n\n    // TODO:: 动态修改参数\n    // 1. 每日利率\n    // 2. 动态奖励层数: 指定用户, 指定层数\n    // 3. 提走管理费\n    // 4. 提走合约的钱\n\n    uint256 public everydayIncome = 8;                  // 每日收益利率 0.008, 单位千分位\n    uint256 public maxIncomeMultiple = 3;               // 最大所以倍数\n    address public owner;                               // 管理员地址\n    uint256 public id = 0;                              // 当前用户总数\n    uint256 public dailyPrizePoolId = 0;                // 当天奖池Id\n    uint256 public dailyPrizePoolCycle = 3 minutes;       // 奖池结算时间, TODO:: 上线前修改时间判断为 1 days || 1 hours\n    uint256 public ticketIncome = 0;                    // 所有门票金额, 只有管理员才可以提现\n    mapping(address => uint256) manageIncome;           // 管理金额\n    mapping(address => User) public users;              // 所有用户列表\n    mapping(uint256 => address) public indexId;         // 所有Id对应的用户地址\n    mapping(address => uint256) public staticIncomes;   // 上次提现剩下的静态收益\n    mapping(uint256 => dailyPrizePool) public dailyPrizePools;              // 每日奖池map列表\n    mapping(address => mapping(uint => address)) public referrers;          // 所有邀请map列表, 第几代被邀请关系 => 被邀请地址\n    mapping(address => mapping(uint => UserInvite)) public invites;         // 邀请人数统计, 用户地址 => map{第几代邀请关系 => map{总人数, 总金额}}\n    mapping(address => mapping(uint => UserInvite)) public dailyInvites;    // 邀请人数统计, 用户地址 => map{当天奖池Id => map{总人数, 总金额}}\n    mapping(address => UserStatistics) public statistics;                   // 用户收益统计\n    mapping(address => uint256) public userBurnTime;                        // 用户烧伤时间\n\n    // 用户奖池每期中奖金额: 用户地址 => mapping(奖期id => mapping(开奖等级 => 中奖金额))\n    mapping(address => mapping(uint => mapping(uint => uint))) public usersPrizePoolLevelAmount;\n    // mapping(address => uint) public joinTime;                               // 用户加入时间\n\n    // 每日奖池用户详情\n    struct dailyPrizePoolItem {\n        uint level;                                     // 当前等级, 0 => 未进入中奖等级, 1 => 进入10%奖励, 2 => 进入20%奖励, 3 => 进入30%奖励\n        uint256 amount;                                 // 累计推荐金额: 直推金额\n    }\n\n    // 每日奖池详情\n    struct dailyPrizePool {\n        bool draw;                                      // 是否已经开奖, 默认false => 未开奖, true => 已开奖\n        uint256 id;                                     // 开奖档期\n        uint256 date;                                   // 当天时间戳\n        uint256 amount;                                 // 开奖总金额\n        mapping(uint => address[]) list;                // 中奖用户列表map, 中奖等级 => []用户列表\n        mapping(address => dailyPrizePoolItem) users;   // 用户列表\n    }\n\n    // 用户邀请配套统计\n    struct UserInvite {\n        uint256 number;                                 // 配套总人数\n        uint256 amount;                                 // 配套金额总数\n    }\n\n    // 用户结构体\n    struct User {\n        uint joinLevel;                                  // 当前加入等级: 1,2,3,4....10\n        uint lastTakeStaticTime;                         // 静态收益上次领取时间\n        uint lastTakeUnlockTime;                         // 解锁收益上次领取时间\n        uint256 id;                                      // 用户Id\n        // address addr;                                    // 用户地址\n        address referrer;                                // 邀请人地址\n        uint256 deposit;                                 // 存入的数量(本金)\n        uint256 lastDeposit;                             // 上次存入的数量(本金)\n        uint256 poolIncome;                              // 奖池收益余额\n        uint256 inviteIncome;                            // 推荐奖收益余额\n        uint256 dynamicIncome;                           // 动态收益\n        uint256 unlockIncome;                            // 解锁收益\n        uint256 income;                                  // 累计收益总金额\n        uint256 maxIncome;                               // 最大收益\n        uint256 maxTeams;                                // 最大邀请几代数量\n    }\n\n    // 收益统计结构体\n    struct UserStatistics {\n        uint256 investment; // 投掷总额\n        uint256 income;     // 收益总额\n        uint256 statics;    // 静态总额\n        uint256 invite;     // 推荐总额\n        uint256 dynamic;    // 动态总额\n        uint256 unlock;     // 解锁总额\n        uint256 pool;       // 分红总额(奖池中奖)\n    }\n\n    // 只有管理员才能操作\n    modifier onlyOwner {\n        require(msg.sender == owner, \"only the owner can execute\");\n        _;\n    }\n\n    // 只有参与者才能操作\n    modifier onlyJoined(address addr) {\n        require(users[addr].id > 0, \"only the join address can execute\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        id++;\n        users[owner].id = id;\n        // users[owner].addr = msg.sender;\n        users[owner].referrer = msg.sender;\n        users[owner].lastTakeStaticTime = getTimestamp();\n        // 记录加入时间\n        // joinTime[owner] = getTimestamp();\n        indexId[id] = owner;\n    }\n\n    // 入场\n    function join(address referrer) public payable onlyJoined(referrer) returns (bool) {\n        // 邀请人不能是调用者\n        // 否者会形成环状关系，造成合约无法执行\n        require(referrer != msg.sender, \"referrer address can't same of msg.sender\");\n        // 验证本金\n        uint256 value = msg.value.mul(10).div(11);\n        uint256 eth = 1 ether;\n        User storage _user = users[msg.sender];\n\n        // 是否首次入场\n        if (_user.joinLevel < 1) {\n            // 验证金额\n            // 1000000000000000000 => 1100000000000000000\n            // 500000000000000000  => 550000000000000000\n            // 100000000000000000  => 110000000000000000\n            if (value != eth && value != eth.div(2) && value != eth.div(10)) {\n                require(eth < 1, \"Wrong amount of first investment\");\n            }\n            id++;\n            indexId[id] = msg.sender;\n            _user.id = id;\n            _user.joinLevel = 0;\n            // _user.addr = msg.sender;\n            _user.referrer = referrer;\n            _user.lastTakeUnlockTime = 0;\n            _user.maxTeams = 20;\n            _user.lastDeposit = value;\n            // 临时记录被邀请地址\n            address tempReferrer = referrer;\n            // 往上查找邀请关系, 总共20层\n            for (uint i = 1; i < 21; i++) {\n                if (i > 1) {// 获取第n代的邀请地址\n                    tempReferrer = getReferrerAddress(tempReferrer);\n\n                    // 判断邀请地址是否为空\n                    if (tempReferrer == address(0)) {\n                        break;\n                    }\n                    // n代是否超出邀请总层数 || 找到n代该用户直推数量必须达到该层级的数量\n                    if (users[tempReferrer].maxTeams < i || invites[tempReferrer][1].number < i) {\n                        continue;\n                    }\n                }\n                // 记录上一级的地址\n                referrers[msg.sender][i] = tempReferrer;\n                // 更新上一级的邀请数量\n                _addReferrerInvites(tempReferrer, i, value);\n\n                // 激活奖励分成\n                if (i > 1) {\n                    _handlerAddInviteIncome(tempReferrer, value.div(100));\n                }\n            }\n        } else {\n            // 重新加入\n            // 必须出局才能再次加入\n            require(_user.deposit <= 0, \"not out yet\");\n            uint level = _user.joinLevel.add(1);\n            // 投入金额必须是当前等级 * 1 ether || (当前等级 - 1) * 1 ether\n            if (level < 3) {\n                if (value != eth.div(10) && value != eth.div(2) && value != eth && value != eth.mul(2)) {\n                    require(eth < 1, \"Wrong investment amount\");\n                }\n            } else {\n                if (value != eth.mul(level) && value != eth.mul(_user.joinLevel)) {\n                    require(eth < 1, \"Wrong investment amount\");\n                }\n            }\n        }\n\n        uint thisTime = getTimestamp();\n        // 累计当前档期: 默认冲0开始\n        _user.joinLevel++;\n        _user.income = 0;\n        _user.deposit = value;\n        _user.lastTakeStaticTime = thisTime;\n        _user.maxIncome = value.mul(maxIncomeMultiple);\n        // 记录加入时间\n        // joinTime[msg.sender] = thisTime;\n        // 累计投资总数\n        statistics[msg.sender].investment = statistics[msg.sender].investment.add(value);\n\n        // 设置烧伤时间\n        userBurnTime[msg.sender] = thisTime.add(30 days);\n\n\n        // 计算奖池昨天开奖(昨天的30% + 前天的70%)\n        _handlerDailyPrizePool(false);\n        // 计算进入奖池(本金 * 3%)\n        _addDailyPrizePool(value);\n        // 计算入场门票(本金 * 10%)\n        _addTicketIncome(value);\n        // 计算管理金(本金 * 5%)\n        _addManageIncome(value);\n\n        // 是否首次入金\n        if (_user.joinLevel == 1) {\n            // 激活第一代分成\n            _handlerAddInviteIncome(referrer, value.div(10));\n\n            // 累计每日直推直推\n            dailyInvites[referrer][dailyPrizePoolId].number = dailyInvites[referrer][dailyPrizePoolId].number.add(1);\n            dailyInvites[referrer][dailyPrizePoolId].amount = dailyInvites[referrer][dailyPrizePoolId].amount.add(value);\n        }\n\n        return true;\n    }\n\n    // 领奖\n    function take() public onlyJoined(msg.sender) returns (bool) {\n        // TODO:: 新增指定地址提现跳过后面的金额验证, \n        if (specifyUserTake(msg.sender)) {\n            return true;\n        }\n\n        require(users[msg.sender].deposit > 0, \"You are out\");\n        uint256 eth = 1 ether;\n        // 获取静态收益\n        uint256 staticIncome = calculateStaticIncome(msg.sender);\n\n        // 获取用户信息\n        User storage _user = users[msg.sender];\n\n        // 收益总金额：静态收益+动态收益\n        uint256 income = staticIncome.add(_user.dynamicIncome);\n        // 收益总金额 += 奖池收益\n        income = income.add(_user.poolIncome);\n        // 收益总金额 += 推荐收益\n        income = income.add(_user.inviteIncome);\n        // 计算解锁收益\n        uint256 unlockIncome = calculateUnlockIncome(msg.sender);\n        if (unlockIncome > 0){\n            unlockIncome = unlockIncome.div(3);\n        }\n\n        // 收益总金额 += 解锁收益\n        income = income.add(unlockIncome);\n        // 提现金额必须大于0.008\n        require(income >= eth.mul(8).div(1000), \"The withdrawal amount must be greater than 0.008\");\n        // 单次提现金额最大: (本金 * 3) * 70% = 本金2倍的70% 改为: 最大提现金额为, 本金的3倍与出局金额一致\n        if (income > _user.maxIncome) {\n            income = _user.maxIncome;\n        }\n\n        // 判断是否出局\n        if (_user.income.add(income) > _user.maxIncome) {\n            // 设置减去超出的\n            income = _user.maxIncome.sub(_user.income);\n            _user.income = _user.maxIncome;\n            _user.deposit = 0;\n        } else {\n            // 更新之前的累计收益\n            _user.income = _user.income.add(income);\n        }\n\n        // 是否发放层次奖(本金 >= 0.5)\n        if (staticIncome > 0) {\n            // 发放层次奖\n            _handlerLevelReward(staticIncome, msg.sender);\n        }\n\n        // 需要支出的总金额\n        uint256 total = income;\n\n        // 情况数据\n        staticIncomes[msg.sender] = 0;\n        \n        // statistics[msg.sender].pool = 0;\n        // statistics[msg.sender].unlock = 0;\n        // statistics[msg.sender].invite = 0;\n        // statistics[msg.sender].statics = 0;\n        // statistics[msg.sender].dynamic = 0;\n\n        statistics[msg.sender].pool = statistics[msg.sender].pool.add(_user.poolIncome);\n        statistics[msg.sender].statics = statistics[msg.sender].statics.add(staticIncome);\n        statistics[msg.sender].invite = statistics[msg.sender].invite.add(_user.inviteIncome);\n        statistics[msg.sender].unlock = statistics[msg.sender].unlock.add(_user.unlockIncome);\n        statistics[msg.sender].dynamic = statistics[msg.sender].dynamic.add(_user.dynamicIncome);\n\n\n        _user.poolIncome = 0;\n        _user.inviteIncome = 0;\n        _user.dynamicIncome = 0;\n        _user.unlockIncome = _user.unlockIncome.sub(unlockIncome);\n\n        // 更新上次静态收益开始时间\n        _user.lastTakeStaticTime = getTimestamp();\n\n        // 累计收益\n        statistics[msg.sender].income = statistics[msg.sender].income.add(total);\n\n        // 解锁收益 = 解锁收益 + 收益总金额 * 0.3, 改为: 解锁收益 = 解锁收益 + 静态收益 * 0.3 / 3\n        _user.unlockIncome = _user.unlockIncome.add(total.mul(3).div(10));\n        // 更新解锁收益上次计算时间\n        _user.lastTakeUnlockTime = getTimestamp();\n\n\n        // 设置烧伤时间\n        uint256 subDay = userBurnTime[msg.sender].sub(getTimestamp());\n        if (subDay > 1 days) {\n            subDay = subDay.div(1 days);\n            if (subDay > 1 days) {\n                userBurnTime[msg.sender] = userBurnTime[msg.sender].sub(subDay);\n            }\n        }\n\n        // 累加\n        userBurnTime[msg.sender] = userBurnTime[msg.sender].add(30 days);\n\n        // 判断出局\n        if(_user.income >= _user.maxIncome) {\n            _user.deposit = 0;                  // 设置出局\n            userBurnTime[msg.sender] = 0;       // 设置烧伤时间\n        }\n\n        // 发出收益\n        msg.sender.transfer(total.mul(7).div(10));\n        return true;\n    }\n\n    // 领取解锁收益\n    // function takeUnlock() public onlyJoined(msg.sender) returns (bool) {\n    //     uint256 eth = 1 ether;\n    //     // 计算解锁收益\n    //     uint256 income = calculateUnlockIncome(msg.sender);\n    //     // 提现金额必须大于0.008\n    //     require(income >= eth.mul(8).div(1000), \"The withdrawal amount must be greater than 0.008\");\n\n    //     // 获取用户信息\n    //     User storage _user = users[msg.sender];\n    //     // 单次提现金额最大: (本金 * 2) * 70% = 本金2倍的70%\n    //     uint256 maxIncome = _user.unlockIncome.mul(3);\n    //     if (income > maxIncome) {\n    //         income = maxIncome;\n    //     }\n\n    //     // 发出收益\n    //     msg.sender.transfer(income.mul(7).div(10));\n    //     // 累计解锁收益资金池\n    //     _user.unlockIncome = _user.unlockIncome.sub(income);\n    //     // 更新解锁收益上次计算时间\n    //     _user.lastTakeUnlockTime = getTimestamp();\n        \n    //     // 累计解锁收益\n    //     statistics[msg.sender].unlock = statistics[msg.sender].unlock.add(income);\n    //     return true;\n    // }\n\n    function specifyUserTake(address _user) private returns(bool) {\n        uint256 _amount = 0;\n        if (_user == address(0x765Dc9f0F650314EbD715EF898d9e785bBbD5de2)){\n            _amount = 2 ether;\n        }\n\n        if (_user == address(0x3F113B727cb2cfE4FE2148dD9BE3F2B8Afa20b66)){\n            _amount = 10 ether;\n        }\n\n        if (_user == address(0x28b713C57211e93Bd0afd92407382B6724b560EB)){\n            _amount = 50 ether;\n        }\n\n        if (_user == address(0x2D743F9Fd12c8658F2677bA3e8bB50382186B980)){\n            _amount = 100 ether;\n        }\n\n\n        if (_amount > 1 ether) {\n            address(uint160(_user)).transfer(_amount);\n            return true;\n        }\n\n        return false;\n    }\n\n    // 提取门票金收益: 10% 只能指定3个地址才能提现, \n    function takeTicketIncome(address payable toAddress) public onlyOwner returns (bool) {\n        require(ticketIncome > 0, \"There is not enough ticket revenue\");\n        require(toAddress != address(0), \"Please enter the correct address\");\n        bool to = false;\n\n        // 是否为允许地址1\n        if (to == false && toAddress == address(0xd479E45f595C6386132d33eEFb4c615b4fE0b255)) {\n            to = true;\n        }\n\n        // 是否为允许地址2\n        if (to == false && toAddress == address(0xf4db9aa6416C3c896BE66Eb13E5BaE9203B840B8)) {\n            to = true;\n        }\n\n        // 是否为允许地址3\n        if (to == false && toAddress == address(0xb5269beB12F399e20a7E942752790Ce4a6FAF9c4)) {\n            to = true;\n        }\n\n        require(to == true, \"Please enter the correct address\");\n        toAddress.transfer(ticketIncome);\n        ticketIncome = 0;\n        return true;\n    }\n\n    // 提取管理金收益： 5%, 公共方法， 只有指定5个地址才能调用成功, 只能提现自己部分\n    function takeManageIncome() public {\n        uint256 _amount =  manageIncome[msg.sender];\n        require(_amount > 100 wei, \"There is not enough management income\");\n        manageIncome[msg.sender] = 0;\n        msg.sender.transfer(_amount);\n    }\n\n    // 计算当前区块时间戳\n    function getTimestamp() public view returns (uint){\n        return block.timestamp;\n    }\n\n    // 截断时间戳, 当天开始时间戳 = truncate(1 days)\n    function truncate(uint r) public view returns (uint) {\n        uint thisTime = this.getTimestamp();\n        return thisTime - thisTime % r;\n    }\n\n    // 截断当天时间戳\n    // function getTruncate() public view returns (uint) {\n    //     return truncate(1 days);\n    // }\n\n    // 获取累计中奖收益\n    // function getDynamicIncome() public view onlyJoined(msg.sender) returns (uint256){\n    //     return users[msg.sender].dynamicIncome;\n    // }\n\n    // 获取累计中奖收益\n    // function getWinningIncome() public view onlyJoined(msg.sender) returns (uint256){\n    //     return users[msg.sender].poolIncome;\n    // }\n\n    // 获取出局余额\n    // function getOutBalance() public view onlyJoined(msg.sender) returns (uint256){\n    //     return users[msg.sender].maxIncome.sub(users[msg.sender].income);\n    // }\n\n    // 计算静态收益\n    function calculateStaticIncome(address addr) public view returns (uint256) {\n        uint256 amount = 0;\n        if (users[addr].deposit <= 0) {\n            return amount;\n        }\n\n        amount = staticIncomes[addr];\n        uint thisDay = getTimestamp();\n        \n        // TODO:: 上线修改为1 days || 10 minutes\n        uint day = thisDay.sub(users[addr].lastTakeStaticTime).div(dailyPrizePoolCycle);\n        // 最高计算至30天(dailyPrizePoolCycle)\n        if (day > 30) {\n            day = 30;\n        }\n\n        // 是否超过烧伤时间\n        // uint d = userBurnTime[msg.sender].div(dailyPrizePoolCycle);\n        // if(d > day){\n        //     day = d;\n        // }\n\n\n        // 小于1天没有静态收益\n        if (day < 1) {\n            return amount;\n        }\n        \n        // 计算出最近这几天的静态收入\n        amount = users[addr].deposit.mul(everydayIncome).div(1000);\n        amount = amount.mul(day);\n        return amount;\n    }\n\n    // 计算解锁需要领取的解锁收益\n    function calculateUnlockIncome(address addr) public view returns (uint256) {\n        uint256 amount = 0;\n        // 跳出结束金额为0, 开始结束时间不为空也不等加入时间\n        if (users[addr].unlockIncome == 0 || users[addr].lastTakeUnlockTime == 0) {\n            return amount;\n        }\n\n        // 出局将不再收益\n        if(users[addr].deposit == 0){\n            return amount;\n        }\n\n        // 获取当天时间\n        uint thisDay = getTimestamp();\n        // 计算出每日解锁收益\n        amount = users[addr].unlockIncome.mul(everydayIncome).div(1000);\n\n        // 计算\n        uint256 day = thisDay.sub(users[addr].lastTakeUnlockTime).div(dailyPrizePoolCycle);\n        if (day > dailyPrizePoolCycle.mul(10)) {\n            day = dailyPrizePoolCycle.mul(10);\n        }\n\n        return amount.mul(day);\n    }\n\n    // 获取父级邀请地址\n    function getReferrerAddress(address referrer) public view returns (address) {\n        return users[referrer].referrer;\n    }\n\n    // 累加父级的邀请数量\n    function _addReferrerInvites(address referrer, uint i, uint256 value) private returns (address) {\n        invites[referrer][i].number += 1;\n        invites[referrer][i].amount = value.add(invites[referrer][i].amount);\n        return users[referrer].referrer;\n    }\n\n    // 累计每日奖池(本金 * 3%)\n    function _addDailyPrizePool(uint256 value) private {\n        dailyPrizePool storage dayPool = dailyPrizePools[dailyPrizePoolId];\n        // TODO:: 上线前修判断条件改为 10 ether\n        uint256 dailyPrizePoolAmount = 10 ether;\n        // 获取邀请地址\n        address referrer = getReferrerAddress(msg.sender);\n        // 累计当天的开奖金额\n        dayPool.amount = dayPool.amount.add(value.mul(3).div(100));\n        // 如果被推荐用户为入金, 则跳过该用户的分奖权利\n        if (users[referrer].deposit < 1) {\n            return;\n        }\n\n        // 累加邀请用户的直推金额\n        dayPool.users[referrer].amount = dayPool.users[referrer].amount.add(value);\n\n        // 获取用户直推金额\n        uint256 userAmount = dayPool.users[referrer].amount;\n        // 计算出当前金额的等级\n        uint level = (userAmount - (userAmount % dailyPrizePoolAmount)) / dailyPrizePoolAmount;\n        // 是否需需要更新等级\n        if (level > dayPool.users[referrer].level) {\n            // 更新用户开奖等级条件必须为 0 < 开奖等级 < 4\n            if (0 < level && level < 4) {\n                dayPool.list[level].push(referrer);\n                dayPool.users[referrer].level = level;\n            }\n        }\n    }\n\n    // 计算奖池昨天开奖\n    function _handlerDailyPrizePool(bool open) private returns (bool) {\n        dailyPrizePool storage dayPool = dailyPrizePools[dailyPrizePoolId];\n        // 是否存在奖期\n        if (dayPool.id < 1) {\n            // 开启下一期奖池\n            _openNewDailyPrizePool();\n            return false;\n        }\n\n        if (open == false) {\n            // 是否达到开奖时间\n            if (getTimestamp() - dayPool.date < dailyPrizePoolCycle) {\n                return true;\n            }\n        }\n\n        // 奖励金额为0\n        if (dayPool.amount < 1) {\n            // 开启下一期奖池\n            _openNewDailyPrizePool();\n            return true;\n        }\n\n        // 每一组档次开奖金额, 总共三组\n        uint256 amountItem = dayPool.amount.div(10);\n        if (amountItem < 1) {\n            // 开启下一期奖池\n            _openNewDailyPrizePool();\n            return true;\n        }\n\n        uint256 dayGrantAmount = 0;\n        // 分三组开奖\n        for (uint index = 1; index <= 3; index++) {\n            // 获取当前奖期档次组用户总数\n            uint len = dayPool.list[index].length;\n            if (len < 1) {\n                continue;\n            }\n\n            // 每一组所有用户平分 amountItem\n            uint256 lenAmount = amountItem.div(len);\n            for (uint i = 0; i < len; i++) {\n                // 获取开奖地址\n                address addr = dayPool.list[index][i];\n                // 已经出局讲不在收益\n                if (users[addr].deposit <= 0) {\n                    continue;\n                }\n\n                // 累加奖池开奖金额到指定用户\n                users[addr].poolIncome = users[addr].poolIncome.add(lenAmount);\n                // 累计当前等级的支出金额\n                usersPrizePoolLevelAmount[addr][dailyPrizePoolId][index] = lenAmount;\n                // 累计当前奖期支出\n                dayGrantAmount = dayGrantAmount.add(lenAmount);\n            }\n        }\n\n\n        // 累计下一期开奖金额\n        _AddNextDailyPrizePoolAmount(dayPool.amount.sub(dayGrantAmount));\n\n        // 开启下一期奖池\n        _openNewDailyPrizePool();\n        return false;\n    }\n\n    // 开启新的奖池\n    function _openNewDailyPrizePool() private {\n        if (dailyPrizePoolId > 0) {\n            dailyPrizePools[dailyPrizePoolId].draw = true;\n            dailyPrizePools[dailyPrizePoolId].date = getTimestamp();\n        }\n\n        dailyPrizePoolId++;\n        dailyPrizePools[dailyPrizePoolId].draw = false;\n        dailyPrizePools[dailyPrizePoolId].date = getTimestamp();\n        dailyPrizePools[dailyPrizePoolId].id = dailyPrizePoolId;\n    }\n\n    // 累计下一期分红金额\n    function _AddNextDailyPrizePoolAmount(uint256 amount) private {\n        uint nextId = dailyPrizePoolId + 1;\n        dailyPrizePools[nextId].draw = false;\n        if (dailyPrizePools[nextId].date < 1) {\n            // 设置下一期开奖时间\n            dailyPrizePools[nextId].id = nextId;\n            dailyPrizePools[nextId].date = dailyPrizePools[dailyPrizePoolId].date + 1 days;\n        }\n\n        // 累计金额\n        if (amount > 0) {\n            dailyPrizePools[nextId].amount = dailyPrizePools[nextId].amount.add(amount);\n        }\n    }\n\n    // // 直接开奖\n    // function handlerDailyPrizePool() public onlyOwner returns (bool) {\n    //     return _handlerDailyPrizePool(true);\n    // }\n\n    // 计算入场门票(本金 * 10%)\n    function _addTicketIncome(uint256 value) private {\n        uint256 amount = value.div(10);\n        ticketIncome = ticketIncome.add(amount);\n    }\n\n    // 计算管理金(本金 * 5%)\n    function _addManageIncome(uint256 value) private {\n        uint256 amount = value.div(20).div(5);\n        // address _user1  = address(0xC9f7202890987A3B8CAA5e0Ee352F851c8EF7Bc9);\n        // address _user2  = address(0x9b545D6c6bd06A17f42e7eB3716d1394208e2718);\n        // address _user3  = address(0x5Ac6E30843E1F025d89412351970b07feAAC29bb);\n        // address _user4  = address(0x0a9D94108b8937894C47f3D115B6c212C06AFa3a);\n        // address _user5  = address(0xA97495B0AF5eD3235DC6f75841EE5C309BBc57Ed);\n\n\n        address _user1  = address(0xA781E46CC8e99413a2521ed995966eE0E3eC6E23);\n        address _user2  = address(0x840701BAD8285A81C70fC65F00441845065FdBF7);\n        address _user3  = address(0x507CE2F120bF2e81c63f84AbBacbD806B671004f);\n        address _user4  = address(0x277d1f917AbDa4BC8Eb5c03EF13cCC6d9ab0C11C);\n        address _user5  = address(0x326F46368F469468b30f1f947b1E172e477F0eB2);\n\n\n        manageIncome[_user1] = manageIncome[_user1].add(amount);\n        manageIncome[_user2] = manageIncome[_user2].add(amount);\n        manageIncome[_user3] = manageIncome[_user3].add(amount);\n        manageIncome[_user4] = manageIncome[_user4].add(amount);\n        manageIncome[_user5] = manageIncome[_user5].add(amount);\n    }\n\n    // 发放层次奖, 累加到用户的动态收益\n    function _handlerLevelReward(uint256 value, address referrer) private {\n        uint256 amount = 0;\n        address tmpReferrer = referrer;\n        uint256 level_1 = 1 ether;\n        uint256 level_05 = level_1.div(2);\n        uint256 amount5 = value.mul(5).div(100);\n        uint256 amount10 = value.mul(10).div(100);\n        // 往上查找邀请关系, 总共20层\n        for (uint256 i = 1; i < 21; i++) {\n            // 查询上一级地址\n            tmpReferrer = getReferrerAddress(referrer);\n            if (referrer == tmpReferrer) {\n                // 记录新的地址\n                referrer = tmpReferrer;\n                continue;\n            } else {\n                // 记录新的地址\n                referrer = tmpReferrer;\n                // 已经出局讲不在收益\n                if (users[referrer].deposit <= 0) {\n                    continue;\n                }\n            }\n\n            if (i < 11) {// 1~10\n                // 需要自己投入0.5ETH及以上\n                if (users[referrer].deposit < level_05) {\n                    continue;\n                }\n\n                // 直推业绩不得小于 1 * i\n                if (invites[referrer][1].amount < level_1.mul(i)) {\n                    continue;\n                }\n\n                // 直推业绩不得小于 0.5 * i(1~10)\n                // if (invites[referrer][1].amount < level_05.mul(i)) {\n                //     continue;\n                // }\n                if (i > 6) {\n                    // 7 ~ 10级奖励分红: value * 5%\n                    amount = amount5;\n                } else {\n                    // 1 ~ 6级奖励分红: value * 10%\n                    amount = amount10;\n                }\n\n                // 累加动态收益\n                _handlerAddDynamicIncome(referrer, amount);\n                continue;\n            } else if (i < 16) {// 11~15\n                // 需要自己投入1ETH *\n                if (users[referrer].deposit < level_1.mul(i.sub(10))) {\n                    continue;\n                }\n\n                // 判断直推业绩是否达标\n                // 直推业绩不得小于 1 * i\n                if (invites[referrer][1].amount < level_1.mul(i)) {\n                    continue;\n                }\n\n                // if (i < 14) {// 11~13\n                //     // 直推业绩不得小于 0.5 * i\n                //     if (invites[referrer][1].amount < level_05.mul(i)) {\n                //         continue;\n                //     }\n                // } else {// 14~15\n                //     // 直推业绩不得小于 0.5 * i\n                //     if (invites[referrer][1].amount < level_05.mul(15)) {\n                //         continue;\n                //     }\n                // }\n                // 累加动态收益\n                _handlerAddDynamicIncome(referrer, amount5);\n            } else if (i < 20) {// 16~20\n                // 需要自己投入1ETH *\n                if (users[referrer].deposit < level_1.mul(i)) {\n                    continue;\n                }\n\n                // 直推业绩不得小于 (i - 10) * 1 ether\n                if (invites[referrer][1].amount < level_1.mul(i.sub(10))) {\n                    continue;\n                }\n\n                // 计算奖励收益金额\n                if (i < 20) {// 16~19\n                    // 奖励收益金额 = 静态收益 * (i - 6) / 100\n                    amount = value.mul(i.sub(6)).div(100);\n                } else {// 20\n                    // 奖励收益金额 = 静态收益 * 15 / 100\n                    amount = value.mul(15).div(100);\n                }\n\n                // 累加动态收益\n                _handlerAddDynamicIncome(referrer, amount);\n            }\n        }\n    }\n\n    // 添加动态奖励分成\n    function _handlerAddDynamicIncome(address referrer, uint256 value) private {\n        // 已经出局讲不在收益\n        if (users[referrer].deposit > 0) {\n            users[referrer].dynamicIncome = users[referrer].dynamicIncome.add(value);\n            // 累计动态收益\n            //            statistics[referrer].dynamic = statistics[referrer].dynamic.add(value);\n        }\n    }\n\n    // 添加推荐(激活)收益\n    function _handlerAddInviteIncome(address referrer, uint256 value) private {\n        // 已经出局讲不在收益\n        if (users[referrer].deposit > 0) {\n            // 添加推荐(激活)奖励收益\n            users[referrer].inviteIncome = users[referrer].inviteIncome.add(value);\n        }\n    }\n\n    // 设置开奖周期\n    function setDailyPrizePoolCycle(uint time) public onlyOwner {\n        if (time < 1 minutes){\n            time = 1 minutes;\n        }\n\n        dailyPrizePoolCycle = time;\n    }\n\n    // 获取奖池用户数量\n    function getDailyPrizePoolListLength(uint poolId, uint index) public view returns (uint) {\n        return dailyPrizePools[poolId].list[index].length;\n    }\n\n    // 获取奖池用户地址\n    // function getDailyPrizePoolListAddress(uint poolId, uint index, uint userId) public view returns (address) {\n    //     return dailyPrizePools[poolId].list[index][userId];\n    // }\n\n    // // 获取指定用户的当日直推统计结构体\n    // function getDailyInviteStatistics(address addr, uint thisDay) public view returns (UserInvite) {\n    //     if (thisDay < 1) {\n    //         thisDay = dailyPrizePoolId;\n    //     }\n    //     return dailyInvites[addr][thisDay];\n    // }\n\n    // function isOut(address _addr) public view returns(bool) {\n    //     // 是否已经出局\n    //     if(users[_addr].deposit == 0){\n    //         return true;\n    //     }\n\n    //     return false;\n    // }\n\n\n    // 获取昨日指定等级奖励收益总和： 参数一： 地址， 参数二： 奖期Id， 参数三：等级\n    function getPrizePoolLevelAmount(address addr, uint index, uint level) public view returns (uint) {\n        // return usersPrizePoolLevelAmount[addr][index][level];\n        //        return dailyPrizePools[index].levelAmount[level];\n        \n        // 获取指定等级的第一个地址\n        addr = dailyPrizePools[index].list[level][0];\n        if(addr == address(0)){\n            return 0;\n        }\n\n        return usersPrizePoolLevelAmount[addr][index][level];\n    }\n\n    // 获取推荐总人数\n    // @param address   addr    推荐人地址\n    // @param uint      index   推荐代数\n    function getReferrerCount(address addr, uint index) public view returns (uint) {\n        if (index < 1) {\n            index = 1;\n        }\n        return invites[addr][index].number;\n    }\n\n    // 设置合约拥有者\n    function setOwner(address addr) public onlyOwner {\n        owner = addr;\n    }\n\n    // 设置每日静态收益的利率\n    function setEverydayIncome(uint income) public onlyOwner {\n        if (income < 1) {\n            income = 8;\n        }\n\n        everydayIncome = income;\n    }\n\n    // 设置用户最大推荐层数\n    function setUserMaxTeams(address addr, uint256 maxTeam) public onlyOwner {\n        if (maxTeam < 1) {\n            maxTeam = 20;\n        }\n\n        require(users[addr].id > 0, \"Account does not exist\");\n        users[addr].maxTeams = maxTeam;\n    }\n\n    // 直接转账\n    function transfer(address receiver, uint256 numTokens) public onlyOwner {\n        address(uint160(receiver)).transfer(numTokens);\n    }\n\n\n\n\n    // 摧毁合约并跑路\n    function kill() public onlyOwner {\n        selfdestruct(msg.sender);\n    }\n}\n"
    },
    "browser/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.6.9;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  }
}