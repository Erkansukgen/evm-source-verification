{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ConvertPortal.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface CToken {\n    function underlying() external view returns(address);\n    function transfer(address dst, uint256 amount) external returns (bool);\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function mint(uint mintAmount) external returns (uint);\n    function borrow(uint borrowAmount) external returns (uint);\n    function repayBorrow(uint repayAmount) external returns (uint);\n    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint);\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function exchangeRateCurrent() external returns (uint);\n    function exchangeRateStored() external view returns (uint);\n    function totalSupply() external view returns(uint);\n    function balanceOfUnderlying(address account) external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n}\n\ninterface ITokensTypeStorage {\n  function isRegistred(address _address) external view returns(bool);\n\n  function getType(address _address) external view returns(bytes32);\n\n  function isPermittedAddress(address _address) external view returns(bool);\n\n  function owner() external view returns(address);\n\n  function addNewTokenType(address _token, string calldata _type) external;\n\n  function setTokenTypeAsOwner(address _token, string calldata _type) external;\n}\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ninterface PoolPortalInterface {\n  function buyPool\n  (\n    uint256 _amount,\n    uint _type,\n    IERC20 _poolToken\n  )\n  external\n  payable;\n\n  function sellPool\n  (\n    uint256 _amount,\n    uint _type,\n    IERC20 _poolToken\n  )\n  external\n  payable;\n\n  function getBacorConverterAddressByRelay(address relay)\n  external\n  view\n  returns(address converter);\n\n  function getBancorConnectorsAmountByRelayAmount\n  (\n    uint256 _amount,\n    IERC20 _relay\n  )\n  external view returns(uint256 bancorAmount, uint256 connectorAmount);\n\n  function getBancorConnectorsByRelay(address relay)\n  external\n  view\n  returns(\n    IERC20 BNTConnector,\n    IERC20 ERCConnector\n  );\n\n  function getBancorRatio(address _from, address _to, uint256 _amount)\n  external\n  view\n  returns(uint256);\n\n  function getUniswapConnectorsAmountByPoolAmount(\n    uint256 _amount,\n    address _exchange\n  )\n  external\n  view\n  returns(uint256 ethAmount, uint256 ercAmount);\n\n  function getUniswapTokenAmountByETH(address _token, uint256 _amount)\n  external\n  view\n  returns(uint256);\n\n  function getTokenByUniswapExchange(address _exchange)\n  external\n  view\n  returns(address);\n}\n\n\ninterface ExchangePortalInterface {\n\n  event Trade(address src, uint256 srcAmount, address dest, uint256 destReceived);\n\n  function trade(\n    IERC20 _source,\n    uint256 _sourceAmount,\n    IERC20 _destination,\n    uint256 _type,\n    bytes32[] calldata _additionalArgs,\n    bytes calldata _additionalData\n  )\n    external\n    payable\n    returns (uint256);\n\n  function compoundRedeemByPercent(uint _percent, address _cToken) external returns(uint256);\n\n  function compoundMint(uint256 _amount, address _cToken) external payable returns(uint256);\n\n  function getPercentFromCTokenBalance(uint _percent, address _cToken, address _holder)\n   external\n   view\n   returns(uint256);\n\n  function getValue(address _from, address _to, uint256 _amount) external view returns (uint256);\n\n  function getTotalValue(\n    address[] calldata _fromAddresses,\n    uint256[] calldata _amounts,\n    address _to\n    )\n    external\n    view\n   returns (uint256);\n\n   function getCTokenUnderlying(address _cToken) external view returns(address);\n}\n\n\n/**\n* This contract convert source ERC20 token to destanation token\n* support sources 1INCH, COMPOUND, BANCOR/UNISWAP pools\n*/\n\n\ncontract ConvertPortal {\n  address constant private ETH_TOKEN_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n  bytes32[] private BYTES32_EMPTY_ARRAY = new bytes32[](0);\n  address public CEther;\n  address public sUSD;\n  ExchangePortalInterface public exchangePortal;\n  PoolPortalInterface public poolPortal;\n  ITokensTypeStorage  public tokensTypes;\n\n  /**\n  * @dev contructor\n  *\n  * @param _exchangePortal         address of exchange portal\n  * @param _poolPortal             address of pool portal\n  * @param _tokensTypes            address of the tokens type storage\n  * @param _CEther                 address of Compound ETH wrapper\n  */\n  constructor(\n    address _exchangePortal,\n    address _poolPortal,\n    address _tokensTypes,\n    address _CEther\n    )\n    public\n  {\n    exchangePortal = ExchangePortalInterface(_exchangePortal);\n    poolPortal = PoolPortalInterface(_poolPortal);\n    tokensTypes = ITokensTypeStorage(_tokensTypes);\n    CEther = _CEther;\n  }\n\n  // convert CRYPTOCURRENCY, COMPOUND, BANCOR/UNISWAP pools to _destination asset\n  function convert(\n    address _source,\n    uint256 _sourceAmount,\n    address _destination,\n    address _receiver\n  )\n    external\n    payable\n  {\n    // no need continue convert for not correct input data\n    if(_sourceAmount <= 0 || _source == _destination)\n      return;\n\n    uint256 receivedAmount = 0;\n    // convert assets\n    if(tokensTypes.getType(_source) == bytes32(\"CRYPTOCURRENCY\")){\n      receivedAmount = convertCryptocurency(_source, _sourceAmount, _destination);\n    }\n    else if (tokensTypes.getType(_source) == bytes32(\"BANCOR_ASSET\")){\n      receivedAmount = convertBancorPool(_source, _sourceAmount, _destination);\n    }\n    else if (tokensTypes.getType(_source) == bytes32(\"UNISWAP_POOL\")){\n      receivedAmount = convertUniswapPool(_source, _sourceAmount, _destination);\n    }\n    else if (tokensTypes.getType(_source) == bytes32(\"COMPOUND\")){\n      receivedAmount = convertCompound(_source, _sourceAmount, _destination);\n    }\n    else {\n      // Unknown type\n      revert(\"Unknown token type\");\n    }\n\n    // send assets to _receiver\n    if (_destination == ETH_TOKEN_ADDRESS) {\n      payable(_receiver).transfer(receivedAmount);\n    } else {\n      // transfer tokens received to sender\n      IERC20(_destination).transfer(_receiver, receivedAmount);\n    }\n\n    // After the trade, any _source that exchangePortal holds will be sent back to msg.sender\n    uint256 endAmount = (_source == ETH_TOKEN_ADDRESS)\n    ? address(this).balance\n    : IERC20(_source).balanceOf(address(this));\n\n    // Check if we hold a positive amount of _source\n    if (endAmount > 0) {\n      if (_source == ETH_TOKEN_ADDRESS) {\n        payable(_receiver).transfer(endAmount);\n      } else {\n        IERC20(_source).transfer(_receiver, endAmount);\n      }\n    }\n  }\n\n  // helper for convert Compound asset\n  // _source - should be Compound token\n  function convertCompound(address _source, uint256 _sourceAmount, address _destination)\n    private\n    returns(uint256)\n  {\n    // step 0 transfer compound asset from sender\n    IERC20(_source).transferFrom(msg.sender, address(this), _sourceAmount);\n\n    // step 1 convert cToken to underlying\n    CToken(_source).redeem(_sourceAmount);\n\n    // step 2 get underlying address and received underlying amount\n    address underlyingAddress = (_source == CEther)\n    ? ETH_TOKEN_ADDRESS\n    : CToken(_source).underlying();\n\n    uint256 underlyingAmount = (_source == CEther)\n    ? address(this).balance\n    : IERC20(underlyingAddress).balanceOf(address(this));\n\n    // step 3 convert underlying to destination if _destination != underlyingAddress\n    if(_destination != underlyingAddress){\n      uint256 destAmount = 0;\n      // convert via 1inch\n      // Convert ETH\n      if(underlyingAddress == ETH_TOKEN_ADDRESS){\n        destAmount = exchangePortal.trade.value(underlyingAmount)(\n          IERC20(underlyingAddress),\n          underlyingAmount,\n          IERC20(_destination),\n          2,\n          BYTES32_EMPTY_ARRAY,\n          \"0x\"\n        );\n      }\n      // Convert ERC20\n      else{\n        IERC20(underlyingAddress).approve(address(exchangePortal), underlyingAmount);\n        destAmount = exchangePortal.trade(\n          IERC20(underlyingAddress),\n          underlyingAmount,\n          IERC20(_destination),\n          2,\n          BYTES32_EMPTY_ARRAY,\n          \"0x\"\n        );\n      }\n      return destAmount;\n    }\n    else{\n      return underlyingAmount;\n    }\n\n  }\n\n  // helper for convert Unswap asset\n  // _source - should be Uni pool\n  function convertUniswapPool(address _source, uint256 _sourceAmount, address _destination)\n    private\n    returns(uint256)\n  {\n    // sell pool\n    _transferFromSenderAndApproveTo(IERC20(_source), _sourceAmount, address(poolPortal));\n\n    poolPortal.sellPool(\n      _sourceAmount,\n      1, // type Uniswap\n      IERC20(_source)\n    );\n\n    // convert pool connectors to destanation\n    // get erc20 connector address\n    address ERCConnector = poolPortal.getTokenByUniswapExchange(_source);\n    uint256 ERCAmount = IERC20(ERCConnector).balanceOf(address(this));\n\n    // convert ERC20 connector via 1inch if destination != ERC20 connector\n    if(ERCConnector != _destination){\n      IERC20(ERCConnector).approve(address(exchangePortal), ERCAmount);\n      exchangePortal.trade(\n        IERC20(ERCConnector),\n        ERCAmount,\n        IERC20(_destination),\n        2, // type 1inch\n        BYTES32_EMPTY_ARRAY,\n        \"0x\"\n      );\n    }\n\n    // if destanation != ETH, convert ETH also\n    if(_destination != ETH_TOKEN_ADDRESS){\n      uint256 ETHAmount = address(this).balance;\n      exchangePortal.trade.value(ETHAmount)(\n        IERC20(ETH_TOKEN_ADDRESS),\n        ETHAmount,\n        IERC20(_destination),\n        2, // type 1inch\n        BYTES32_EMPTY_ARRAY,\n        \"0x\"\n      );\n    }\n\n    // return received amount\n    if(_destination == ETH_TOKEN_ADDRESS){\n      return address(this).balance;\n    }else{\n      return IERC20(_destination).balanceOf(address(this));\n    }\n  }\n\n  // helper for convert standrad crypto assets\n  function convertCryptocurency(address _source, uint256 _sourceAmount, address _destination)\n    private\n    returns(uint256)\n  {\n    // Convert crypto via 1inch aggregator\n    uint256 destAmount = 0;\n    if(_source == ETH_TOKEN_ADDRESS){\n      destAmount = exchangePortal.trade.value(_sourceAmount)(\n        IERC20(_source),\n        _sourceAmount,\n        IERC20(_destination),\n        2,\n        BYTES32_EMPTY_ARRAY,\n        \"0x\"\n      );\n    }else{\n      _transferFromSenderAndApproveTo(IERC20(_source), _sourceAmount, address(exchangePortal));\n      destAmount = exchangePortal.trade(\n        IERC20(_source),\n        _sourceAmount,\n        IERC20(_destination),\n        2,\n        BYTES32_EMPTY_ARRAY,\n        \"0x\"\n      );\n    }\n    return destAmount;\n  }\n\n  // helper for convert Bancor pools asset\n  // _source - should be Bancor pool\n  function convertBancorPool(address _source, uint256 _sourceAmount, address _destination)\n    private\n    returns(uint256)\n  {\n    _transferFromSenderAndApproveTo(IERC20(_source), _sourceAmount, address(exchangePortal));\n    // Convert BNT pools just via Bancor DEX\n    uint256 destAmount = exchangePortal.trade(\n      IERC20(_source),\n      _sourceAmount,\n      IERC20(_destination),\n      1,\n      BYTES32_EMPTY_ARRAY,\n      \"0x\"\n    );\n\n    return destAmount;\n  }\n\n  /**\n  * @dev Transfers tokens to this contract and approves them to another address\n  *\n  * @param _source          Token to transfer and approve\n  * @param _sourceAmount    The amount to transfer and approve (in _source token)\n  * @param _to              Address to approve to\n  */\n  function _transferFromSenderAndApproveTo(IERC20 _source, uint256 _sourceAmount, address _to) private {\n    require(_source.transferFrom(msg.sender, address(this), _sourceAmount), \"Can not transfer from\");\n\n    _source.approve(_to, _sourceAmount);\n  }\n\n  // fallback payable function to receive ether from other contract addresses\n  fallback() external payable {}\n}\n"}}}