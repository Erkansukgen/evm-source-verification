{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "MintingMania.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\n//import the ERC20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n//import the ERC721 interface\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    // function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets.\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n// interface ERC721TokenReceiver {\r\n//     /// @notice Handle the receipt of an NFT\r\n//     /// @dev The ERC721 smart contract calls this function on the\r\n//     /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n//     /// of other than the magic value MUST result in the transaction being reverted.\r\n//     /// @notice The contract address is always the message sender.\r\n//     /// @param _operator The address which called `safeTransferFrom` function\r\n//     /// @param _from The address which previously owned the token\r\n//     /// @param _tokenId The NFT identifier which is being transferred\r\n//     /// @param _data Additional data with no specified format\r\n//     /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n//     /// unless throwing\r\n//     function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\r\n//  }\r\n  \r\n\r\n// Mint logic and helper functions\r\ncontract MintMania{\r\n    address owner;\r\n    uint[]  private tokenIdArray;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // onlyOwner modifier for swap\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    // Helper functions\r\n    function getTokenId() public view returns (uint[] memory){\r\n        return tokenIdArray;\r\n    }\r\n    \r\n    // resetTokenId\r\n    function resetTokenId() public onlyOwner{\r\n        delete tokenIdArray;\r\n    }\r\n    \r\n\r\n    // Change owner\r\n    function amendOwner(address _newOwner) external onlyOwner{\r\n        require(_newOwner != address(0));\r\n        owner = _newOwner;\r\n\r\n    }\r\n    \r\n    // Pay bribe amount individually\r\n    function payProtectionMoney(uint256 _bribe) external payable onlyOwner{\r\n        block.coinbase.transfer(_bribe);\r\n    }\r\n    \r\n    //  // Retrieve NFTs internal function to be called by startMintingMania\r\n    // function retrieveJpegs_internal(address _token, address _recipient) internal{\r\n    //         uint256 end_loop = tokenIdArray.length;\r\n            \r\n    //         for (uint i = 0; i < end_loop; i++) {\r\n    //             uint256 tokenId = tokenIdArray[i];\r\n    //             ERC721(_token).safeTransferFrom(address(this), _recipient, tokenId);\r\n\r\n    //         }\r\n            \r\n    //         delete tokenIdArray;\r\n            \r\n    //     }  \r\n    //Declare an Event\r\n    // event JPG(address tok, uint256 le, uint256[] ar);\r\n    // event recJPG(uint256 id);\r\n    // event realrecJPG(uint256[] ar);\r\n\r\n    //Retrieve NFTs \r\n    function retrieveJpegs(address _token, address _recipient) public onlyOwner{\r\n            uint256 end_loop = tokenIdArray.length;\r\n            \r\n            // emit JPG(_token, end_loop, tokenIdArray);\r\n            \r\n            for (uint i = 0; i < end_loop; i++) {\r\n                uint256 tokenId = tokenIdArray[i];\r\n                ERC721(_token).safeTransferFrom(address(this), _recipient, tokenId);\r\n            }\r\n            delete tokenIdArray;\r\n            \r\n        }  \r\n        \r\n    //Main function\r\n    function startMintingMania(address _contract, bytes memory payload, uint256 _value_mint, uint256 _num_loops, bool _transfer_directly, uint256 max_holding, address _recipient, bool _bribing, uint256 _bribe_amount, uint256 _bribe_success_counter) external payable onlyOwner{\r\n        bool _bribing_success_counter = true;\r\n        \r\n        // Minting\r\n        for (uint i = 1; i <= _num_loops; i++) {\r\n            (bool success, bytes memory returnData) = _contract.call{value: _value_mint}(payload);\r\n            \r\n            // Retrieve JPEGs directly after max holding is reached\r\n            if (i % max_holding == 0 && _transfer_directly){\r\n               retrieveJpegs(_contract, _recipient);\r\n            }\r\n            \r\n            // Bribe trigger checck\r\n            if (success == false){\r\n                _bribing_success_counter = i >= _bribe_success_counter;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Send bribe\r\n        if ((_bribing == true) && (_bribing_success_counter == true)){\r\n            block.coinbase.transfer(_bribe_amount);    \r\n        }\r\n        \r\n        // Transfer directly after buy\r\n        if (_transfer_directly){\r\n             retrieveJpegs(_contract, _recipient);\r\n        }\r\n    }\r\n    \r\n        \r\n    //  Retrieve NFTs by Ids - essentially emergency function if internal tokenIdArray gets out of sync\r\n    function retrieveJpegsByIds(address _token, address _recipient, uint256[] memory tokenIds) external payable onlyOwner{\r\n            uint256 end_loop = tokenIds.length;\r\n            \r\n            for (uint i = 0; i < end_loop; i++) {\r\n                uint256 tokenId = tokenIds[i];\r\n                ERC721(_token).safeTransferFrom(address(this), _recipient, tokenId);\r\n            }\r\n            delete tokenIdArray;\r\n        }  \r\n        \r\n    // // NFT Handling\r\n    function onERC721Received(address, address from,uint256 tokenId,bytes calldata) external returns(bytes4){\r\n        tokenIdArray.push(tokenId);\r\n        \r\n        // emit recJPG(tokenId);\r\n        // emit realrecJPG(tokenIdArray);\r\n        return 0x150b7a02;\r\n    }\r\n    \r\n    // Funds Handling\r\n    //  Retrieve ETH funds\r\n    function retrieveETHFunds(address payable _recipient, uint256 _amount, bool _all) external payable onlyOwner{\r\n            uint256 amountSend;\r\n            if (_all == true){\r\n              amountSend = address(this).balance;\r\n            }else{\r\n              amountSend = _amount;\r\n            }\r\n            _recipient.transfer(amountSend);\r\n        }  \r\n        \r\n    //  Retrieve ERC20 funds\r\n    function retrieveERC20Funds(address _token, address _recipient, uint256 _amount, bool _all) external payable onlyOwner{\r\n            uint256 amountSend;\r\n            if (_all == true){\r\n              amountSend= IERC20(_token).balanceOf(address(this));\r\n            }else{\r\n              amountSend = _amount;\r\n            }\r\n            IERC20(_token).transfer(_recipient, amountSend);\r\n        }  \r\n        \r\n    // Receive ETH \r\n    function receiveAmmunition() external payable {\r\n        \r\n    }\r\n    \r\n    // Fallback function\r\n    fallback () external payable{\r\n    \r\n    }\r\n    receive() external payable {\r\n\r\n    }\r\n}\r\n\r\n"
    }
  }
}