{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"contracts/InterPack.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\ninterface ICubes {\n    function mintByPack(address owner) external;\n}\n\n\ncontract InterPack is Ownable {\n    \n    modifier callerIsUser() {\n        require(tx.origin == msg.sender, \"The caller is another contract\");\n        _;\n    }\n\n    modifier onlyCollaborator() {\n        bool isCollaborator = false;\n        for (uint256 i; i < collaborators.length; i++) {\n            if (collaborators[i].addr == msg.sender) {\n                isCollaborator = true;\n\n                break;\n            }\n        }\n\n        require(\n            owner() == _msgSender() || isCollaborator,\n            \"Ownable: caller is not the owner nor a collaborator\"\n        );\n\n        _;\n    }\n\n    modifier mintStarted() {\n        require(\n            (startRegularMintDate != 0 && startRegularMintDate <= block.timestamp),\n            \"You are too early\"\n        );\n\n        _;\n    }\n\n    \n    uint256 private startRegularMintDate = 1632952800; // 29.09.2021 22:00 UTC\n\n    uint256 private claimPrice = 90000000000000000;\n\n    \n    uint256 private totalTokens = 8115;\n    uint256 private totalMintedTokens = 0;\n\n\n    uint128 private basisPoints = 10000;\n    \n    uint16 private maxRegularClaimsPerWallet = 20;\n    \n    mapping(address => uint256) private claimedTokenPerWallet;\n    \n    \n    struct Collaborators {\n        address addr;\n        uint256 cut;\n    }\n    \n    Collaborators[] internal collaborators;\n    \n    address private packContractAddress;\n    address private cubesContractAddress;\n    \n    struct Holder { \n       bool set;\n       uint8 minted;\n    }\n    \n    mapping(address => Holder) private mintpassHolders;\n    uint256 private mintpassHoldersCurrentSize = 0;\n    uint8 private maxFreeSetsPerHolder = 1;\n    \n\n    \n    // ONLY OWNER\n\n    /**\n     * Sets the collaborators of the project with their cuts\n     */\n    function addCollaborators(Collaborators[] memory _collaborators)\n        external\n        onlyOwner\n    {\n        require(collaborators.length == 0, \"Collaborators were already set\");\n\n        uint128 totalCut;\n        for (uint256 i; i < _collaborators.length; i++) {\n            collaborators.push(_collaborators[i]);\n            totalCut += uint128(_collaborators[i].cut);\n        }\n\n        require(totalCut == basisPoints, \"Total cut does not add to 100%\");\n    }\n\n    \n    \n    function setCubesAddr(address _addr) external onlyOwner {\n       cubesContractAddress = _addr;\n    }\n    \n    function setPackAddr(address _addr) external onlyOwner {\n       packContractAddress = _addr;\n    }\n\n    /**\n     * @dev Sets the claim price for each token\n     */\n    function setClaimPrice(uint256 _claimPrice) external onlyOwner {\n        claimPrice = _claimPrice;\n    }\n    \n    function setStartRegularMintDate(uint256 _startMintDate) external onlyOwner {\n        startRegularMintDate = _startMintDate;\n    }\n    \n    function setTotalTokens(uint256 _num) external onlyOwner {\n        require (_num >= totalMintedTokens, \"Cannot be less than already minted\");\n        totalTokens = _num;\n    }\n\n    function setMaxPerWallet(uint16 _num) external onlyOwner {\n        maxRegularClaimsPerWallet = _num;\n    }\n\n    \n    function giftSet(address[] calldata _addresses) external onlyOwner {\n        require((totalMintedTokens + _addresses.length) <= totalTokens, \"No sets left to be minted\");\n\n        for (uint i = 0; i < _addresses.length; i++) {\n            ICubes(cubesContractAddress).mintByPack(_addresses[i]);\n        }\n        \n        \n        totalMintedTokens = totalMintedTokens + _addresses.length;\n    }\n    \n    function addMintpassHolders(address[] calldata _addrs) external onlyOwner {\n        require((mintpassHoldersCurrentSize + _addrs.length) <= 1000, 'Max mintpass holders num exceed');\n        \n        for (uint128 i = 0; i < _addrs.length; i++) {\n            mintpassHolders[_addrs[i]] = Holder(true, 0);\n        }\n        \n        mintpassHoldersCurrentSize = mintpassHoldersCurrentSize + _addrs.length;\n    }\n    \n    function setMaxFreeSetsPerholder(uint8 _num) external onlyOwner {\n        maxFreeSetsPerHolder = _num;\n    }\n    \n    // ONLY collaborators\n    \n    /**\n     * @dev Allows to withdraw the Ether in the contract and split it among the collaborators\n     */\n    function withdraw() external onlyCollaborator {\n        uint256 totalBalance = address(this).balance;\n\n        for (uint256 i; i < collaborators.length; i++) {\n            payable(collaborators[i].addr).transfer(\n                mulScale(totalBalance, collaborators[i].cut, basisPoints)\n            );\n        }\n    }\n\n\n    // END ONLY COLLABORATORS\n\n\n    \n    \n    fallback() external payable {}\n    \n    receive() external payable {}\n    \n    function getAvailableToMint() external view returns (uint256) {\n        return (totalTokens - totalMintedTokens);\n    }\n    \n    function mint(uint8 _numOfPacks) external payable callerIsUser mintStarted {\n        require(msg.value >= (claimPrice * _numOfPacks), \"Not enough Ether to mint a pack\");\n        require((totalMintedTokens + _numOfPacks) <= totalTokens, \"No packs left to be minted\");\n        \n        require(\n            (claimedTokenPerWallet[msg.sender] + _numOfPacks) <= maxRegularClaimsPerWallet,\n            \"You cannot claim more packs.\"\n        );\n\n        for (uint8 j = 0; j < _numOfPacks; j++) {\n            ICubes(cubesContractAddress).mintByPack(msg.sender);\n        }\n        \n        totalMintedTokens = totalMintedTokens + _numOfPacks;\n        claimedTokenPerWallet[msg.sender] = claimedTokenPerWallet[msg.sender] + _numOfPacks;\n    }\n    \n    function mintByPack(address owner) external {\n        require(msg.sender == packContractAddress, \"Unauthorized\");\n        ICubes(cubesContractAddress).mintByPack(owner);\n    }\n    \n    function claimFreeSet() external {\n        \n        require(true == mintpassHolders[msg.sender].set, \"You are not in the mintpass holder list.\");\n        require(maxFreeSetsPerHolder > mintpassHolders[msg.sender].minted, \"You cannot claim more free sets.\");\n        \n        mintpassHolders[msg.sender].minted++;\n        ICubes(cubesContractAddress).mintByPack(msg.sender);\n        totalMintedTokens++;\n    }\n    \n    function getMintpassHoldersCurrentSize() external view returns (uint) {\n        return mintpassHoldersCurrentSize;\n    }\n    \n    function isAddresRegisterdAsMintpassHolder (address _addr) external view returns (bool) {\n        return mintpassHolders[_addr].set;\n    }\n    \n    function getNumOfFreeSetMinted (address _addr) external view returns (uint8) {\n        return mintpassHolders[_addr].minted;\n    }\n    \n    function getNumOfMintsPerAddr(address _addr) external view returns (uint256) {\n        return claimedTokenPerWallet[_addr];\n    }\n    \n    // INTERNAL \n    \n    function mulScale(\n        uint256 x,\n        uint256 y,\n        uint128 scale\n    ) internal pure returns (uint256) {\n        uint256 a = x / scale;\n        uint256 b = x % scale;\n        uint256 c = y / scale;\n        uint256 d = y % scale;\n\n        return a * c * scale + a * d + b * c + (b * d) / scale;\n    }\n}"}}}