{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/farm.sol":{"content":"pragma solidity ^0.6.6;\n\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function decimals() external view returns (uint);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface Uni {\n    function swapExactTokensForTokens(uint, uint, address[] calldata, address, uint) external;\n\n\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n\texternal\n\treturns (uint[] memory amounts);\n\n\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n\texternal\n\tpayable\n\treturns (uint[] memory amounts);\n}\n\ninterface DXDDAO {\n\tfunction buy(address receiver, uint256 etherValue, uint256 _minTokensBought) external payable;\n}\n\ncontract DXDFarming {\n\tusing SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n\taddress constant public DXD = address(0xa1d65E8fB6e87b60FECCBc582F7f97804B725521);\n    address constant public univ2 = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address constant public weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n\t function approveDXD() public {\n\t\tIERC20(DXD).approve(univ2, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    }\n\n\t// profit if uni price > bond price\n\t// accumulation play\n\t// req initial amount of dxd && approve() contract to use DXD token\n\tfunction SellUniBuyBond(uint256 _amount) public {\n\t\tuint dxdAmount = IERC20(DXD).balanceOf(msg.sender);\n\t\tif (dxdAmount >= _amount) {\n\t\t\tIERC20(DXD).safeTransferFrom(msg.sender, address(this), _amount);\n\t\t\taddress[] memory path = new address[](2);\n\t\t\t\tpath[0] = DXD;\n\t\t\t\tpath[1] = weth;\n\t\t\t// high gas may be better to prevent being front run\n\t\t\tUni(univ2).swapExactTokensForETH(_amount, 1, path, address(this), now.add(1800));\n\t\t\tDXDDAO(DXD).buy(msg.sender, address(this).balance, 1);\n\t\t}\n\t}\n\n\t// profit if uni price > bond price\n\t// quick flip play\n\t// require ether\n\tfunction BuyBondSellUni() external payable {\n\t\tDXDDAO(DXD).buy(address(this), address(this).balance, 1);\n\t\tuint dxdAmount = IERC20(DXD).balanceOf(msg.sender);\n\t\tif (dxdAmount > 0) {\n\t\t\taddress[] memory path = new address[](2);\n\t\t\t\tpath[0] = DXD;\n\t\t\t\tpath[1] = weth;\n\t\t\tUni(univ2).swapExactTokensForETH(dxdAmount, 1, path, msg.sender, now.add(1800));\n\t\t}\n\t}\n}"}}}