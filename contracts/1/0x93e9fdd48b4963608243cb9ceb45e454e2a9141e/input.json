{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/9.sol":{"content":"pragma solidity ^0.7.0;\n//SPDX-License-Identifier: UNLICENSED\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address who) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function transfer(address to, uint value) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\ninterface IUNIv2 {\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) \n    external \n    payable \n    returns (uint amountToken, uint amountETH, uint liquidity);\n    \n    function WETH() external pure returns (address);\n\n}\n\ninterface IUnicrypt {\n    event onDeposit(address, uint256, uint256);\n    event onWithdraw(address, uint256);\n    function depositToken(address token, uint256 amount, uint256 unlock_date) external payable; \n    function withdrawToken(address token, uint256 amount) external;\n\n}\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract UT is IERC20, Context {\n    \n    using SafeMath for uint;\n    IUNIv2 uniswap = IUNIv2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniswapV2Factory uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n    IUnicrypt unicrypt = IUnicrypt(0x17e00383A843A9922bCA3B280C0ADE9f8BA48449);\n    string public _symbol;\n    string public _name;\n    uint8 public _decimals;\n    uint _totalSupply;\n    address payable owner;\n    address public pool;\n    uint256 public liquidityUnlock;\n\n    \n    uint256 lockedLiquidityAmount;\n    \n     \n    mapping(address => uint) _balances;\n    mapping(address => mapping(address => uint)) _allowances;\n\n   receive () external payable{\n       \n   }\n    \n\n     modifier onlyOwner() {\n        require(msg.sender == owner, \"You are not the owner\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender; \n        _symbol = \"UT\";\n        _name = \"UnicryptTest\";\n        _decimals = 18;\n        _totalSupply = 400 ether;\n        _balances[address(this)] = _totalSupply;\n        liquidityUnlock = block.timestamp + 2 hours;\n\n        emit Transfer(address(0),address(this), _totalSupply);\n        setUniswapPool();\n    }\n    \n    \n   \n    function lockWithUnicrypt() external onlyOwner {\n        IERC20 liquidityTokens = IERC20(pool);\n        uint256 liquidityBalance = liquidityTokens.balanceOf(address(this));\n        uint256 timeToLuck = block.timestamp + 2 hours;\n        liquidityTokens.approve(address(unicrypt), liquidityBalance);\n\n        unicrypt.depositToken{value: 0} (pool, liquidityBalance, timeToLuck);\n        lockedLiquidityAmount = lockedLiquidityAmount.add(liquidityBalance);\n    }\n    \n    function withdrawFromUnicrypt(uint256 amount) external onlyOwner{\n        unicrypt.withdrawToken(pool, amount);\n    }\n    \n    function setUniswapPool() public {\n        require(pool == address(0), \"the pool already created\");\n        pool = uniswapFactory.createPair(address(this), uniswap.WETH());\n    }\n\n    \n    \n    function addLiquidity() external onlyOwner {\n        uint256 ETH = address(this).balance;\n        this.approve(address(uniswap), balanceOf(address(this)));\n        uniswap.addLiquidityETH\n        { value: ETH }\n        (\n            address(this),\n            balanceOf(address(this)),\n            balanceOf(address(this)),\n            ETH,\n            address(this),\n            block.timestamp + 5 minutes\n       );\n       \n        \n   }\n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address _owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[_owner][spender];\n    }\n\n    \n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    \n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n    \n     \n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n        \n    }\n\n    function _approve(address _owner, address spender, uint256 amount) internal virtual {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[_owner][spender] = amount;\n        emit Approval(_owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    \n    function recoverERC20(address tokenAddress, uint256 tokenAmount) public onlyOwner  {\n        require(block.timestamp >= liquidityUnlock);\n        IERC20(tokenAddress).transfer(owner, tokenAmount);\n    }\n\n}\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n}"}}}