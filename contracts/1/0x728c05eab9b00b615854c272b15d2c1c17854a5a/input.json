{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/uBOMBLiquidityReward.sol": {
      "content": "\npragma solidity ^0.6.7;\n\nlibrary SafeMath {\n  function mul(uint a, uint b) internal pure returns (uint) {\n    if (a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal pure returns (uint) {\n    uint c = a / b;\n    return c;\n  }\n\n  function sub(uint a, uint b) internal pure returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal pure returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function ceil(uint a, uint m) internal pure returns (uint) {\n    uint c = add(a,m);\n    uint d = sub(c,1);\n    return mul(div(d,m),m);\n  }\n}\n\n  \nabstract contract Uniswap2PairContract {\n  \n  function getReserves() external virtual returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n \n \n      \n  }\n  \n    \n  \n\n\nabstract contract ERC20Token {\n  function totalSupply()  public virtual returns (uint);\n  function approve(address spender, uint value)  public virtual returns (bool);\n  function balanceOf(address owner) public virtual returns (uint);\n  function transferFrom (address from, address to, uint value) public virtual returns (bool);\n}\n\n\n\ncontract Ownable {\n    address public owner;\n\n    event TransferOwnership(address _from, address _to);\n\n    constructor() public {\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    function setOwner(address _owner) external onlyOwner {\n        emit TransferOwnership(owner, _owner);\n        owner = _owner;\n    }\n}\n\n\ncontract UniBOMBLiquidReward is Ownable{\n    \n    using SafeMath for uint;\n    \n    uint ONE_MONTH = 60*60*60*24*28;\n    uint MAX_MONTHS = 24;\n    \n    address public LIQUIDITY_TOKEN  = 0xEE89ea23c18410F2b57e7abc6eb24cfcdE4f49B0;\n    address public REWARD_TOKEN  = 0xbBB38bE7c6D954320c0297c06Ab3265a950CDF89;\n\n    uint[3] public rewardLevels = [10000,20000,30000];\n    uint[3] public poolLevels = [100000000000000000000,1000000000000000000000,10000000000000000000000];\n    uint[3] public monthLevels = [3,6,12];\n    \n    uint[4]  public baseRateLookup = [250,200,150,100];\n    \n       //poolLevelsIndex   //monthLevelsIndex    //s0(small)[m0,m1,m2..]  //s2 m2   m3    /3=\n    uint[4][4]  public multiplierLookup = [[105,110,120,130],[100,105,110,120],[100,100,105,110],[100,100,100,100]];\n    \n    \n      mapping(address => mapping(uint => LiquidityRewardData)) public liquidityRewardData; //address to timestamp to data\n    \n    uint public allocatedRewards;\n    uint public totalUniswapLiquidity;\n    uint public unallocatedRewards;\n \n    struct LiquidityRewardData {\n        uint quantity;\n        uint timestamp;\n        uint stakeMonths;\n        uint reward;\n        bool rewardClaimed;\n        bool liquidityClaimed;\n    }\n    \n     \n    \n    fallback()  external payable {\n        revert();\n    }\n    \n    \n    function setOneMonth(uint input ) public onlyOwner{\n       ONE_MONTH = input;\n    }\n    \n    function setRewardLevels(uint[3] memory input ) public onlyOwner{\n       rewardLevels = input;\n    }\n    function setpoolLevels(uint[3] memory input ) public onlyOwner{\n       poolLevels = input;\n    }\n    function setMonthLevels(uint[3] memory input ) public onlyOwner{\n       monthLevels = input;\n    }\n    function setBaseRateLookup(uint[4] memory input ) public onlyOwner{\n       baseRateLookup = input;\n    }\n    function setMultiplierLookup(uint[4][4] memory input ) public onlyOwner{\n       multiplierLookup = input;\n    }\n    function setMaxMonths(uint input ) public onlyOwner{\n       MAX_MONTHS = input;\n    }\n     function getMaxMonths() view public returns(uint){\n       return MAX_MONTHS;\n    }\n    \n    \n    \n    function getAllocatedRewards() view public returns(uint){\n        return allocatedRewards;\n    }\n    \n    function getUnallocatedRewards() view public returns(uint){\n        return unallocatedRewards;\n    }\n    \n    \n      function findOnePercent(uint256 value) public pure returns (uint256)  {\n        uint256 roundValue = value.ceil(100);\n        uint256 onePercent = roundValue.mul(100).div(10000);\n        return onePercent;\n    }\n    \n   \n        //(this)must be whitelisted on ubomb\n     function topupReward (uint amount)  external {\n       require(ERC20Token(REWARD_TOKEN).transferFrom(address(msg.sender), address(this), amount),\"tokenXferFail\");\n       //calc actual deposit amount due to BOMB burn\n       uint tokensToBurn = findOnePercent(amount);\n       uint actual = amount.sub(tokensToBurn);\n       \n       unallocatedRewards += actual;\n     } \n    \n    \n  \n    \n    function calcReward(uint stakeMonths, uint stakeTokens)  public  returns (uint){\n        \n        (uint tokens, uint eth, uint time) = Uniswap2PairContract(LIQUIDITY_TOKEN).getReserves();\n        \n        uint liquidity = stakeTokens;\n\n        uint liquidityTotalSupply = ERC20Token(LIQUIDITY_TOKEN).totalSupply();\n        \n        //uint amountEth = liquidity.mul(eth) / liquidityTotalSupply; // using balances ensures pro-rata distribution\n        uint amountTokens = (liquidity.mul(tokens)).div(liquidityTotalSupply); // using balances ensures pro-rata distribution\n       \n        uint months = stakeMonths;\n        uint baseRate = baseRateLookup[getRewardIndex()];\n        uint multiplier =  multiplierLookup[getpoolLevelsIndex(eth)][getMonthsIndex(months)];\n        \n        uint reward = (amountTokens.mul(months).mul(baseRate).mul(multiplier)).div(1000000);\n        \n        return(reward);\n    }\n    \n   \n    \n    function getRewardIndex() public view returns (uint) {\n        if(unallocatedRewards < rewardLevels[0]){return 3;}\n        else if(unallocatedRewards < rewardLevels[1]){return 2;}\n        else if(unallocatedRewards < rewardLevels[2]){return 1;}\n        else {return 0;}\n    }\n    \n    //baserate\n    function getpoolLevelsIndex(uint eth) public view returns (uint) {\n     \n        if(eth < poolLevels[0] ){return 0;}\n        else if(eth <poolLevels[1]){return 1;}\n        else if(eth <poolLevels[2]){return 2;}\n        else {return 3;}\n    }\n    \n     function getMonthsIndex(uint month) public view returns (uint) {\n        \n        if(month < monthLevels[0]){return 0;}\n        else if(month < monthLevels[1]){return 1;}\n        else if(month < monthLevels[2]){return 2;}\n        else {return 3;}\n        \n    }\n    \n    \n    function lockLiquidity(uint idx, uint stakeMonths, uint stakeTokens) external {\n    \n        //temp hold tokens and ether from sender\n        require(stakeMonths <= MAX_MONTHS,\"tooManyMonths\");\n        require(ERC20Token(LIQUIDITY_TOKEN).transferFrom(address(msg.sender), address(this), stakeTokens),\"tokenXferFail\");\n        \n        require( (liquidityRewardData[msg.sender][idx].quantity == 0),\"previousLiquidityInSlot\");\n       \n        uint reward = calcReward(stakeMonths,stakeTokens);\n        \n        require( unallocatedRewards >= reward, \"notEnoughRewardRemaining\");\n        \n        allocatedRewards += reward;\n        unallocatedRewards -= reward;\n        totalUniswapLiquidity += stakeTokens;\n        \n        liquidityRewardData[msg.sender][idx] = LiquidityRewardData(stakeTokens, block.timestamp, stakeMonths, reward,false,false);\n     \n    }\n    \n    \n    \n    function rewardTask(uint idx, uint renewMonths) public {\n        \n        require(liquidityRewardData[msg.sender][idx].rewardClaimed == false,\"RewardClaimedAlready\");\n        liquidityRewardData[msg.sender][idx].rewardClaimed = true;\n        \n        uint reward = liquidityRewardData[msg.sender][idx].reward;\n        allocatedRewards -= reward;\n            \n        if( liquidityRewardData[msg.sender][idx].timestamp.add( liquidityRewardData[msg.sender][idx].stakeMonths.mul(ONE_MONTH)) <= block.timestamp){\n            \n            if(renewMonths > 0 && liquidityRewardData[msg.sender][idx].liquidityClaimed==false){ //claim and renew\n                \n                uint newReward = calcReward(renewMonths,liquidityRewardData[msg.sender][idx].quantity);\n                require(newReward < unallocatedRewards,\"NotEnoughRewardsRemaining\");\n                allocatedRewards += newReward;\n                unallocatedRewards -= newReward;\n                liquidityRewardData[msg.sender][idx].timestamp = block.timestamp;\n                liquidityRewardData[msg.sender][idx].stakeMonths = renewMonths;\n                liquidityRewardData[msg.sender][idx].reward = newReward;\n                liquidityRewardData[msg.sender][idx].rewardClaimed = false;\n            \n            }\n            ERC20Token(REWARD_TOKEN).approve(address(this),reward);\n            ERC20Token(REWARD_TOKEN).transferFrom(address(this), address(msg.sender), reward);\n        }\n        else{\n            unallocatedRewards += reward;\n            \n        }\n        \n    }\n    \n    \n    \n    \n    function unlockLiquidity(uint idx) external { //get liquidity tokens\n    \n        require(liquidityRewardData[msg.sender][idx].liquidityClaimed == false,\"LiquidityAlreadyClaimed\");\n        \n        if(liquidityRewardData[msg.sender][idx].rewardClaimed == false){\n            rewardTask(idx,0);\n        }\n        totalUniswapLiquidity -= liquidityRewardData[msg.sender][idx].quantity;\n        ERC20Token(LIQUIDITY_TOKEN).approve(address(this),liquidityRewardData[msg.sender][idx].quantity);\n        ERC20Token(LIQUIDITY_TOKEN).transferFrom(address(this),address(msg.sender),liquidityRewardData[msg.sender][idx].quantity);\n        liquidityRewardData[msg.sender][idx].quantity = 0;\n        liquidityRewardData[msg.sender][idx].liquidityClaimed = true;\n        \n    }\n  \n\n}"
    }
  }
}