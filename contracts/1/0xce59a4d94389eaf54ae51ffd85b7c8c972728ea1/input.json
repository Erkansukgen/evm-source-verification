{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/WSwap.sol": {
      "content": "pragma solidity >=0.6.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./comm/SafeMath.sol\";\r\nimport \"./comm/IERC20.sol\";\r\nimport \"./dydx/DydxFlashloanBase.sol\";\r\nimport \"./dydx/IDydx.sol\";\r\nimport \"./curve/ICurveFiCurve.sol\";\r\n\r\ncontract WSwap is ICallee, DydxFlashloanBase {\r\n    using SafeMath for uint256;\r\n\r\n    struct CSDParams {\r\n        uint256 flashloanAmount; // Amount of DAI flashloaned\r\n        uint128 pool1;  \r\n        uint128 pool2;\r\n    }\r\n\r\n    address public addrAdmin;\r\n    address[2] poolAddrArray;\r\n\r\n    event CallEvent(\r\n        uint256 fa,\r\n        uint128 p1,\r\n        uint128 p2\r\n    );\r\n\r\n    constructor() public {\r\n        addrAdmin = msg.sender;\r\n        poolAddrArray[0] = 0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27;  // bUSD\r\n        poolAddrArray[1] = 0x06364f10B501e868329afBc005b3492902d6C763;  // PAX\r\n    }  \r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == addrAdmin);\r\n        _;\r\n    }\r\n\r\n    function callFunction(\r\n        address sender,\r\n        Account.Info memory account,\r\n        bytes memory data\r\n    ) public override {\r\n        CSDParams memory csdp = abi.decode(data, (CSDParams));\r\n        emit CallEvent(csdp.flashloanAmount, csdp.pool1, csdp.pool2);\r\n\r\n        // IERC20 daiToken = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n        // IERC20 usdtToken = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n\r\n        // // dai to usdt\r\n        // ICurveFiCurve curve1 = ICurveFiCurve(poolAddrArray[csdp.pool1]);\r\n        // require(daiToken.approve(address(curve1), csdp.flashloanAmount));\r\n        // curve1.exchange_underlying(\r\n        //     int128(0),\r\n        //     int128(2),\r\n        //     csdp.flashloanAmount,\r\n        //     0\r\n        // );\r\n\r\n        // // usdt to dai\r\n        // uint256 usdtVal = usdtToken.balanceOf(address(this));\r\n        // ICurveFiCurve curve2 = ICurveFiCurve(poolAddrArray[csdp.pool2]);\r\n        // require(usdtToken.approve(address(curve2), usdtVal));\r\n        // curve2.exchange_underlying(int128(2), int128(0), usdtVal, 0);\r\n    }\r\n\r\n    function dai2usdt(uint256 _daiAmount) external onlyAdmin {\r\n        IERC20 daiToken = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n\r\n        ICurveFiCurve curve1 = ICurveFiCurve(poolAddrArray[0]);\r\n        require(daiToken.approve(address(curve1), _daiAmount));\r\n        curve1.exchange_underlying(int128(0), int128(2), _daiAmount, 0);\r\n    }\r\n\r\n    function ustd2dai(uint256 _usdtAmount) external onlyAdmin {\r\n        IERC20 usdtToken = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n\r\n        ICurveFiCurve curve2 = ICurveFiCurve(poolAddrArray[1]);\r\n        require(usdtToken.approve(address(curve2), _usdtAmount));\r\n        curve2.exchange_underlying(int128(2), int128(0), _usdtAmount, 0);\r\n    }\r\n\r\n    function doSwap(uint256 _borrow, uint256 _path) external onlyAdmin {\r\n        address _solo = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n        \r\n        IERC20 daiToken = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n        uint256 marketId = _getMarketIdFromTokenAddress(_solo, 0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n        uint256 repayAmount = _borrow.add(2);\r\n        daiToken.approve(_solo, repayAmount);\r\n\r\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\r\n\r\n        operations[0] = _getWithdrawAction(marketId, _borrow);\r\n        operations[1] = _getCallAction(\r\n            abi.encode(\r\n                CSDParams({\r\n                    flashloanAmount: _borrow,\r\n                    pool1: uint128(_path % 10),\r\n                    pool2: uint128(_path / 10)\r\n                })\r\n            )\r\n        );\r\n        operations[2] = _getDepositAction(marketId, repayAmount);\r\n        Account.Info[] memory accountInfos = new Account.Info[](1);\r\n        accountInfos[0] = _getAccountInfo();\r\n\r\n        ISoloMargin solo = ISoloMargin(_solo);\r\n        solo.operate(accountInfos, operations);\r\n    }\r\n\r\n    function withdraw20(address _addr) external onlyAdmin {\r\n        IERC20 token = IERC20(_addr);\r\n        uint256 val = token.balanceOf(address(this));\r\n        token.transfer(addrAdmin, val);\r\n\r\n        if (address(this).balance > 0) {\r\n            msg.sender.transfer(address(this).balance);\r\n        }\r\n    }\r\n}"
    },
    "browser/comm/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    //function totalSupply() external view returns (uint256);\r\n    //function allowance(address owner, address spender) external view returns (uint256);\r\n    //function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    //event Transfer(address indexed from, address indexed to, uint256 value);\r\n    //event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
    },
    "browser/comm/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"sm:add\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"sm:sub\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"sm:mul\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"sm:div\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    // function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    //     require(b != 0, \"sm:mod\");\r\n    //     return a % b;\r\n    // }\r\n}"
    },
    "browser/curve/ICurveFiCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.7.0;\r\n\r\ninterface ICurveFiCurve {\r\n    // function get_virtual_price() external view returns (uint256 out);\r\n\r\n    // function add_liquidity(uint256[2] calldata amounts, uint256 deadline)\r\n    //     external;\r\n\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view returns (uint256 out);\r\n\r\n    function get_dy_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view returns (uint256 out);\r\n\r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external;\r\n\r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function exchange_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external;\r\n\r\n    function exchange_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    // function remove_liquidity(\r\n    //     uint256 _amount,\r\n    //     uint256 deadline,\r\n    //     uint256[2] calldata min_amounts\r\n    // ) external;\r\n\r\n    // function remove_liquidity_imbalance(\r\n    //     uint256[2] calldata amounts,\r\n    //     uint256 deadline\r\n    // ) external;\r\n\r\n    // function commit_new_parameters(\r\n    //     int128 amplification,\r\n    //     int128 new_fee,\r\n    //     int128 new_admin_fee\r\n    // ) external;\r\n\r\n    // function apply_new_parameters() external;\r\n\r\n    // function revert_new_parameters() external;\r\n\r\n    // function commit_transfer_ownership(address _owner) external;\r\n\r\n    // function apply_transfer_ownership() external;\r\n\r\n    // function revert_transfer_ownership() external;\r\n\r\n    // function withdraw_admin_fees() external;\r\n\r\n    // function coins(int128 arg0) external returns (address out);\r\n\r\n    // function underlying_coins(int128 arg0) external returns (address out);\r\n\r\n    // function balances(int128 arg0) external returns (uint256 out);\r\n\r\n    // function A() external returns (int128 out);\r\n\r\n    // function fee() external returns (int128 out);\r\n\r\n    // function admin_fee() external returns (int128 out);\r\n\r\n    // function owner() external returns (address out);\r\n\r\n    // function admin_actions_deadline() external returns (uint256 out);\r\n\r\n    // function transfer_ownership_deadline() external returns (uint256 out);\r\n\r\n    // function future_A() external returns (int128 out);\r\n\r\n    // function future_fee() external returns (int128 out);\r\n\r\n    // function future_admin_fee() external returns (int128 out);\r\n\r\n    // function future_owner() external returns (address out);\r\n}"
    },
    "browser/dydx/DydxFlashloanBase.sol": {
      "content": "// SPDX-License-Identifier:\r\npragma solidity >=0.6.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../comm/IERC20.sol\";\r\n\r\nimport \"./IDydx.sol\";\r\n\r\ncontract DydxFlashloanBase {\r\n    // -- Internal Helper functions -- //\r\n\r\n    function _getMarketIdFromTokenAddress(address _solo, address token)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (token == 0x6B175474E89094C44Da98b954EedeAC495271d0F) {\r\n            return 3;       // DAI\r\n        }\r\n        else if (token == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) {\r\n            return 2;       // USDC\r\n        }\r\n        else if (token == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\r\n            return 0;       // WETH\r\n        }\r\n        else if (token == 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359) {\r\n            return 1;       // DSToken\r\n        } \r\n        require(false);\r\n\r\n        // ISoloMargin solo = ISoloMargin(_solo);\r\n        // uint256 numMarkets = solo.getNumMarkets();\r\n        // address curToken;\r\n        // for (uint256 i = 0; i < numMarkets; i++) {\r\n        //     curToken = solo.getMarketTokenAddress(i);\r\n        //     if (curToken == token) {\r\n        //         return i;\r\n        //     }\r\n        // }\r\n    }\r\n\r\n    function _getAccountInfo() internal view returns (Account.Info memory) {\r\n        return Account.Info({owner: address(this), number: 1});\r\n    }\r\n\r\n    function _getWithdrawAction(uint256 marketId, uint256 amount)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Withdraw,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: amount\r\n                }),\r\n                primaryMarketId: marketId,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: \"\"\r\n            });\r\n    }\r\n\r\n    function _getCallAction(bytes memory data)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Call,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: 0\r\n                }),\r\n                primaryMarketId: 0,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: data\r\n            });\r\n    }\r\n\r\n    function _getDepositAction(uint256 marketId, uint256 amount)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Deposit,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: true,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: amount\r\n                }),\r\n                primaryMarketId: marketId,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: \"\"\r\n            });\r\n    }\r\n}"
    },
    "browser/dydx/IDydx.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary Account {\r\n    enum Status {Normal, Liquid, Vapor}\r\n    struct Info {\r\n        address owner; // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n    struct Storage {\r\n        mapping(uint256 => Types.Par) balances; // Mapping from marketId to principal\r\n        Status status;\r\n    }\r\n}\r\n\r\nlibrary Actions {\r\n    enum ActionType {\r\n        Deposit, // supply tokens\r\n        Withdraw, // borrow tokens\r\n        Transfer, // transfer balance between accounts\r\n        Buy, // buy an amount of some token (externally)\r\n        Sell, // sell an amount of some token (externally)\r\n        Trade, // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize, // use excess tokens to zero-out a completely negative account\r\n        Call // send arbitrary data to an address\r\n    }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    // struct DepositArgs {\r\n    //     Types.AssetAmount amount;\r\n    //     Account.Info account;\r\n    //     uint256 market;\r\n    //     address from;\r\n    // }\r\n\r\n    // struct WithdrawArgs {\r\n    //     Types.AssetAmount amount;\r\n    //     Account.Info account;\r\n    //     uint256 market;\r\n    //     address to;\r\n    // }\r\n\r\n    // struct CallArgs {\r\n    //     Account.Info account;\r\n    //     address callee;\r\n    //     bytes data;\r\n    // }\r\n}\r\n\r\n// library Decimal {\r\n//     struct D256 {\r\n//         uint256 value;\r\n//     }\r\n// }\r\n\r\nlibrary Types {\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    // struct TotalPar {\r\n    //     uint128 borrow;\r\n    //     uint128 supply;\r\n    // }\r\n\r\n    // struct Wei {\r\n    //     bool sign; // true if positive\r\n    //     uint256 value;\r\n    // }\r\n}\r\n\r\ninterface ISoloMargin {\r\n    function getMarketTokenAddress(uint256 marketId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getNumMarkets() external view returns (uint256);\r\n\r\n    function operate(\r\n        Account.Info[] calldata accounts,\r\n        Actions.ActionArgs[] calldata actions\r\n    ) external;\r\n}\r\n\r\ninterface ICallee {\r\n    // ============ external Functions ============\r\n\r\n    /**\r\n     * Allows users to send this contract arbitrary data.\r\n     *\r\n     * @param  sender       The msg.sender to Solo\r\n     * @param  accountInfo  The account from which the data is being sent\r\n     * @param  data         Arbitrary data given by the sender\r\n     */\r\n    function callFunction(\r\n        address sender,\r\n        Account.Info calldata accountInfo,\r\n        bytes calldata data\r\n    ) external;\r\n}"
    }
  }
}