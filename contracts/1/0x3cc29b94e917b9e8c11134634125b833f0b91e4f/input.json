{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Untitled.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface Minereum {\n  function Payment (  ) payable external;  \n}\n\ncontract MinereumLuckyDraw\n{\n\tMinereum public mne;\n\tRNG public rng;\n\tuint public stakeHoldersfee = 50;\n\tuint public percentWin = 80;\n\tuint public mnefee = 500000000;\n\tuint public ethfee = 10000000000000000;\n\tuint public totalSentToStakeHolders = 0;\n\tuint public totalPaidOut = 0;\n\tuint public ticketsSold = 0;\n\taddress public owner = 0x0000000000000000000000000000000000000000;\t\n\tuint public maxNumber = 1001;\n\tuint public systemNumber = 323;\n\tuint public previousEndPeriod = 1588447830 + 2629743;\n\t\n\taddress[] public winner;\n\tuint[] public winnerTickets;\n\tuint[] public winnerETHAmount;\n\tuint[] public winnerTimestamp;\n\t\n\taddress[] public lost;\n\tuint[] public lostTickets;\n\tuint[] public lostTimestamp;\n\t\n\tevent Numbers(address indexed from, uint[] n, string m);\n\t\n\tconstructor() public\n\t{\n\t\tmne = Minereum(0x7eE48259C4A894065d4a5282f230D00908Fd6D96);\n\t\towner = payable(msg.sender);\n\t\trng = new RNG(1588447830, previousEndPeriod, address(this));\n\t}\n\t\n\treceive() external payable { }\n    \n\t\n    function BuyTickets(address _sender, uint256[] memory _max) public payable returns (uint256)\n    {\n\t\trequire(msg.sender == address(mne));\n\t\t\n\t\tif (block.timestamp > previousEndPeriod)\n\t\t{\n\t\t\t//Some sort of security to prevent miners from hacking block.timestamp. Contract Valid for 1 month. \n\t\t\t//After 1 month a new RNG contract is generated automatically in the first call\n\t\t\trng = new RNG(previousEndPeriod, (previousEndPeriod + 2629743), address(this));\n\t\t}\t\t\n        \n\t\tbool win = false;\n\t\t\n\t\tuint[] memory numbers = new uint[](_max[0]);\n\t\t\n\t\t(numbers, win) = rng.rng(_max[0], systemNumber, maxNumber, _sender);\n\t\t\n\t\tuint valueStakeHolder = msg.value * stakeHoldersfee / 100;\n\t\t\n        if (win)\n\t\t{\n\t\t\taddress payable add = payable(_sender);\n\t\t\tuint contractBalance = address(this).balance;\n\t\t\temit Numbers(msg.sender, numbers, \"You WON!\");\n\t\t\tuint winAmount = contractBalance * percentWin / 100;\n\t\t\tuint totalToPay = winAmount - stakeHoldersfee;\n\t\t\tif (!add.send(totalToPay)) revert('Error While Executing Payment.');\n\t\t\ttotalPaidOut += totalToPay;\n\t\t\twinner.push(_sender);\n\t\t\twinnerTickets.push(_max[0]);\n\t\t\twinnerETHAmount.push(totalToPay);\n\t\t\twinnerTimestamp.push(block.timestamp);\n\t\t}\n        else\n\t\t{\t\n\t\t\tlost.push(_sender);\n\t\t\tlostTickets.push(_max[0]);\n\t\t\tlostTimestamp.push(block.timestamp);\n            emit Numbers(msg.sender, numbers, \"Your numbers don't match the System Number! Try Again.\");\n\t\t}\n\t\tticketsSold += _max[0];\n\t\t\n\t\tuint totalEthfee = ethfee * _max[0];\n\t\tuint totalMneFee = mnefee * _max[0];\n\t\tif (msg.value < totalEthfee) revert('Not enough ETH.');\n\t\tmne.Payment.value(valueStakeHolder)();\n\t\ttotalSentToStakeHolders += valueStakeHolder;\n\t\t\n\t\treturn totalMneFee;\n    }\n\t\n\tfunction transferFundsOut() public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\taddress payable add = payable(msg.sender);\n\t\t\tuint contractBalance = address(this).balance;\n\t\t\tif (!add.send(contractBalance)) revert('Error While Executing Payment.');\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updateFees(uint _stakeHoldersfee, uint _mnefee, uint _ethfee) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tstakeHoldersfee = _stakeHoldersfee;\n\t\t\tmnefee = _mnefee;\n\t\t\tethfee = _ethfee;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updateSystemNumber(uint _systemNumber) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tsystemNumber = _systemNumber;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updateMaxNumber(uint _maxNumber) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tmaxNumber = _maxNumber;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n\t\n\tfunction updateMNEContract(address _mneAddress) public\n\t{\n\t\tif (msg.sender == owner)\n\t\t{\n\t\t\tmne = Minereum(_mneAddress);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trevert();\n\t\t}\n\t}\n}\n\ncontract RNG\n{\n\taddress public owner;\n\tuint public periodStart;\n\tuint public periodEnd;\n\t\n\tconstructor(uint _periodStart, uint _periodEnd, address _owner) public\n\t{\n\t\towner = _owner;\n\t\tperiodStart = _periodStart;\n\t\tperiodEnd = _periodEnd;\n\t}\n\t\n\tfunction rng(uint max, uint systemNumber, uint maxNumber, address _sender) public view returns (uint[] memory, bool)\n\t{\n\t\trequire(msg.sender == owner);\n\t\t\n\t\t//Some sort of security to prevent miners from hacking block.timestamp. Contract Valid for 1 month. \n\t\t//After 1 month a new RNG contract is generated automatically in the first call\n\t\tif (!(block.timestamp >= periodStart && block.timestamp <= periodEnd))\n\t\t\trevert('wrong timestamp');\t\t\n\t\t\n\t\tuint[] memory numbers = new uint[](max);\n        uint i = 0;\n        bool win = false;\n\t\t\n\t\twhile (i < max)\n        {\t\n            //Random number generation\n\t\t\tnumbers[i] = uint256(uint256(keccak256(abi.encodePacked(block.timestamp, _sender, i)))%maxNumber);\n            if (numbers[i] == systemNumber)\n                win = true;\n            i++;\n        }\n\t\t\n\t\treturn (numbers, win);\n\t}\n}"
    }
  }
}