{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "HoldAndArb.sol": {
      "content": "pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface ERC20 {\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n}\n\ninterface IGasToken {\n    function freeFrom(address from, uint256 value) external returns (bool success);\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n}\n\ninterface ITradeAsset {\n    function bridgeCall(address _to, uint _value, bytes calldata _payload) external returns (bool,bytes memory);\n}\n\nlibrary LibBytes {\n\n    using LibBytes for bytes;\n    \n    function readBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        require(\n            b.length >= index + 32,\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n        );\n\n        // Arrays are prefixed by a 256 bit length parameter\n        index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            result := mload(add(b, index))\n        }\n        return result;\n    }\n\n    function readBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes4 result)\n    {\n        require(\n            b.length >= index + 4,\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n        );\n\n        // Arrays are prefixed by a 32 byte length field\n        index += 32;\n\n        // Read the bytes4 from array memory\n        assembly {\n            result := mload(add(b, index))\n            // Solidity does not require us to clean the trailing bytes.\n            // We do it anyway\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n        }\n        return result;\n    }\n\n}\n\ncontract PermissionGroups{\n    \n    address public admin;\n    address public pendingAdmin;\n    \n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"onlyAdmin\");\n        _;\n    }\n    \n    function transferAdmin(address newAdmin) external onlyAdmin {\n        require(newAdmin != address(0),\"newAdmin == address(0)\");\n        pendingAdmin = newAdmin;\n    }\n\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender,\"pendingAdmin != msg.sender\");\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n}\n\ncontract AssetManager is PermissionGroups{\n    \n    receive() external payable{}\n    fallback() external payable{}\n    \n    function withdrawEth(address payable _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        _to.transfer(_value);\n    }\n    \n    function withdrawToken(address _token, address _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        (bool success,bytes memory _data) = _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector,_to,_value));\n        require(success,\"ERC20(_token).transfer failed.\");\n        if(_data.length > 0){\n            require(abi.decode(_data,(bool)),\"ERC20(_token).transfer return data is false.\");\n        }\n    }\n\n}\n\ncontract HoldAndArbTrader is AssetManager{\n    \n    using LibBytes for bytes;\n    \n    string constant public VERSION = \"HoldAndArbTraderBySigner v1.2\";\n    address public assetAddress;\n    address public gasToken;\n    address public gasTokenPayer;\n    mapping(bytes4=>bool) public selectorAllowed;\n    bytes4[] internal selectorGroup;\n    mapping(address=>bool) public callToAllowed;  // set the whitelist when invoke bridgeCall\n    address[] internal callToGroup;\n    address public SIGNER;\n    \n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'Trader: EXPIRED');\n        _;\n    }\n    \n    function setAssetAddress(address newAssetAddress) external onlyAdmin{\n        assetAddress = newAssetAddress;\n    }\n    \n    function setGasToken(address newGasToken) external onlyAdmin{\n        gasToken = newGasToken;\n    }\n    \n    function setGasTokenPayer(address newGasTokenPayer) external onlyAdmin{\n        gasTokenPayer = newGasTokenPayer;\n    }\n       \n    function getSelectorGroup() external view returns (bytes4[] memory) {\n        return selectorGroup;\n    }\n    \n    function addSeletor(bytes4 newSeletor) external onlyAdmin {\n        require(!selectorAllowed[newSeletor],\"duplicated selector\"); // prevent duplicates.\n\n        selectorAllowed[newSeletor] = true;\n        selectorGroup.push(newSeletor);\n    }\n\n    function removeSeletor (bytes4 selector) external onlyAdmin {\n        require(selectorAllowed[selector],\"selector is not in the selectorGroup.\");\n        selectorAllowed[selector] = false;\n\n        for (uint i = 0; i < selectorGroup.length; i++) {\n            if (selectorGroup[i] == selector) {\n                selectorGroup[i] = selectorGroup[selectorGroup.length - 1];\n                selectorGroup.pop();\n                break;\n            }\n        }\n    }\n\n    function addCallTo(address _newCallTo) external onlyAdmin {\n        require(!callToAllowed[_newCallTo],\"duplicated _newCallTo\"); // prevent duplicates.\n       \n        callToAllowed[_newCallTo] = true;\n        callToGroup.push(_newCallTo);\n    }\n\n    function removeCallTo (address _callTo) external onlyAdmin {\n        require(callToAllowed[_callTo],\"_callTo is not in the callToGroup.\");\n        callToAllowed[_callTo] = false;\n\n        for (uint i = 0; i < callToGroup.length; i++) {\n            if (callToGroup[i] == _callTo) {\n                callToGroup[i] = callToGroup[callToGroup.length - 1];\n                callToGroup.pop();\n                break;\n            }\n        }\n    }\n    \n    function getCallToGroup() external view returns(address[] memory) {\n        return callToGroup;\n    }\n    \n    function setSigner(address _signer) external onlyAdmin {\n        SIGNER = _signer;\n    }\n    \n    function swapWithSigner(address _to, bytes calldata _data, bytes calldata signature, uint gasTokenAmount, uint deadline) external ensure(deadline){\n        bytes4 input_selector = _data.readBytes4(0);\n        require(selectorAllowed[input_selector], \"s is not allowed\");\n        require(callToAllowed[_to],\"t is not allowd.\");\n\n        bytes32 dataHash = keccak256(_data);\n        address _signerAddress = ecrecoverAddress(dataHash, signature);\n        require(SIGNER == _signerAddress,\"sign error.\");\n\n        bridgeCall(_to,_data);\n\n        if(gasTokenAmount>0){\n            IGasToken(gasToken).freeFromUpTo(gasTokenPayer,gasTokenAmount);\n        }\n    }\n        \n    function bridgeCall(address _to, bytes memory _payload) internal {\n        try ITradeAsset(assetAddress).bridgeCall(_to,0,_payload) returns (bool success, bytes memory) {\n            require(success,\"bridgeCall failed!\");\n        } catch {\n            revert(\"bridgeCall exception!\");\n        }\n    }\n\n    function ecrecoverAddress(bytes32 data, bytes memory signature) public pure returns (address){\n        (uint8 v, bytes32 r, bytes32 s) = decodeSignatureVRS(signature);\n        \n        return  ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n50\", \"StartMyCheck\", data, \"ToWork\"\n                )), \n            v, r, s);\n    }\n\n    function decodeSignatureVRS(bytes memory signature) internal pure returns(uint8 v, bytes32 r, bytes32 s) {\n        v = uint8(signature[0]);\n        r = signature.readBytes32(1);\n        s = signature.readBytes32(33);\n        return (v, r, s);\n    }\n    \n}\n\n"
    }
  }
}