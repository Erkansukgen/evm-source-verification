{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/proxies/xAAVEProxy.sol":{"content":"pragma solidity 0.6.2;\n\n/**\n * @title Proxy - Generic proxy contract allows to execute all transactions\n */\n\ncontract xAAVEProxy {\n\n    // storage position of the address of the current implementation\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"xaave.implementationPosition\");\n    bytes32 private constant PROPOSED_IMPLEMENTATION_POSITION = keccak256(\"xaave.proposedImplementationPosition\");\n\n    bytes32 private constant PROXY_ADMIN_POSITION = keccak256(\"xaave.proxyAdmin\");\n    bytes32 private constant PROXY_COSIGNER1_POSITION = keccak256(\"xaave.cosigner1\");\n    bytes32 private constant PROXY_COSIGNER2_POSITION = keccak256(\"xaave.cosigner2\");\n\n    bytes32 private constant PROPOSED_NEW_ADMIN  = keccak256(\"xaave.proposedNewAdmin\");\n    bytes32 private constant PROPOSED_NEW_ADMIN_TIMESTAMP  = keccak256(\"xaave.proposedNewAdminTimestamp\");\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == readAddressAtPosition(PROXY_ADMIN_POSITION));\n        _;\n    }\n\n    modifier onlySigner() {\n        address signer1 = readAddressAtPosition(PROXY_COSIGNER1_POSITION);\n        address signer2 = readAddressAtPosition(PROXY_COSIGNER2_POSITION);\n        require(msg.sender == signer1 || msg.sender == signer2);\n        _;\n    }\n\n    /**\n     * @dev Constructor function sets address of master copy contract.\n     * @param implementation the address of the implementation contract that this proxy uses\n     * @param proxyAdmin the address of the admin of this proxy\n     * @param signer1 the first signer of this proxy\n     * @param signer2 the second signer of this proxy\n     */\n    constructor(\n        address implementation,\n        address proxyAdmin,\n        address signer1,\n        address signer2\n    ) public {\n        require(\n            implementation != address(0),\n            \"Invalid implementation address provided\"\n        );\n        require(\n            proxyAdmin != address(0),\n            \"Invalid proxyAdmin address provided\"\n        );\n        require(signer1 != address(0), \"Invalid signer1 address provided\");\n        require(signer2 != address(0), \"Invalid signer2 address provided\");\n        require(signer1 != signer2, \"Signers must have different addresses\");\n        setNewAddressAtPosition(IMPLEMENTATION_POSITION, implementation);\n        setNewAddressAtPosition(PROXY_ADMIN_POSITION, proxyAdmin);\n        setNewAddressAtPosition(PROXY_COSIGNER1_POSITION, signer1);\n        setNewAddressAtPosition(PROXY_COSIGNER2_POSITION, signer2);\n    }\n\n    /**\n     * @dev Proposes a new implementation contract for this proxy if sender is the Admin\n     * @param newImplementation the address of the new implementation\n     */\n    function proposeNewImplementation(address newImplementation) public onlyProxyAdmin {\n        require(newImplementation != address(0), \"new proposed implementation cannot be address(0)\");\n        require(isContract(newImplementation), \"new proposed implementation is not a contract\");\n        require(newImplementation != implementation(), \"new proposed address cannot be the same as the current implementation address\");\n        setNewAddressAtPosition(PROPOSED_IMPLEMENTATION_POSITION, newImplementation);\n    }\n\n    /**\n     * @dev Confirms a previously proposed implementation if the sender is one of the two cosigners\n     * @param confirmedImplementation the address of previously proposed implementation (has to match the previously proposed implementation)\n     */\n    function confirmImplementation(address confirmedImplementation)\n        public\n        onlySigner\n    {\n        address proposedImplementation = readAddressAtPosition(\n            PROPOSED_IMPLEMENTATION_POSITION\n        );\n        require(\n            proposedImplementation != address(0),\n            \"proposed implementation cannot be address(0)\"\n        );\n        require(\n            confirmedImplementation == proposedImplementation,\n            \"proposed implementation doesn't match the confirmed implementation\"\n        );\n        setNewAddressAtPosition(IMPLEMENTATION_POSITION, confirmedImplementation);\n        setNewAddressAtPosition(PROPOSED_IMPLEMENTATION_POSITION, address(0));\n    }\n\n    /**\n     * @dev Proposes a new admin address if the sender is the Admin\n     * @param newAdminAddress address of the new admin role \n     */\n    function proposeAdminTransfer(address newAdminAddress) public onlyProxyAdmin {\n        require(newAdminAddress != address(0), \"new Admin address cannot be address(0)\");\n        setProposedAdmin(newAdminAddress); \n    }\n\n\n    /**\n     * @dev Changes the admin address to the previously proposed admin address if 24 hours has past since it was proposed\n     */\n    function confirmAdminTransfer() public onlyProxyAdmin {\n        address newAdminAddress = proposedNewAdmin();\n        require(newAdminAddress != address(0), \"new Admin address cannot be address(0)\");\n        require(proposedNewAdminTimestamp() + 1 days <= block.timestamp, \"admin change can only be submitted after 1 day\");\n        setProxyAdmin(newAdminAddress);\n        setProposedAdmin(address(0)); \n    }\n\n    /**\n     * @dev Returns whether address is a contract\n     */\n    function isContract(address _addr) private view returns (bool){\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    /**\n     * @dev Returns the address of the implementation contract of this proxy\n     */\n    function implementation() public view returns (address impl) {\n        impl = readAddressAtPosition(IMPLEMENTATION_POSITION);\n    }\n\n    /**\n     * @dev Returns the admin address of this proxy\n     */\n    function proxyAdmin() public view returns (address admin) {\n        admin = readAddressAtPosition(PROXY_ADMIN_POSITION);\n    }\n\n    /**\n     * @dev Returns the new proposed implementation address of this proxy (if there is no proposed implementations, returns address(0x0))\n     */\n    function proposedNewImplementation() public view returns (address impl) {\n        impl = readAddressAtPosition(PROPOSED_IMPLEMENTATION_POSITION);\n    }\n\n    /**\n     * @dev Returns the new proposed admin address of this proxy (if there is no proposed implementations, returns address(0x0))\n     */\n    function proposedNewAdmin() public view returns (address newAdmin) {\n        newAdmin = readAddressAtPosition(PROPOSED_NEW_ADMIN);\n    }\n\n    /**\n     * @dev Returns the timestamp that the proposed admin can be changed/confirmed\n     */\n    function proposedNewAdminTimestamp() public view returns (uint256 timestamp) {\n        timestamp = readIntAtPosition(PROPOSED_NEW_ADMIN_TIMESTAMP);\n    }\n\n    /**\n     * @dev Returns the address of the first cosigner if 'id' == 0, otherwise returns the address of the second cosigner\n     */\n    function proxySigner(uint256 id) public view returns (address signer) {\n        if (id == 0) {\n            signer = readAddressAtPosition(PROXY_COSIGNER1_POSITION);\n        } else {\n            signer = readAddressAtPosition(PROXY_COSIGNER2_POSITION);\n        }\n    }\n\n    /**\n     * @dev Returns the proxy type, specified by EIP-897\n     * @return Always return 2\n     **/\n    function proxyType() public pure returns (uint256) {\n        return 2; // type 2 is for upgradeable proxy as per EIP-897\n    }\n\n\n    function setProposedAdmin(address proposedAdmin) private {\n        setNewAddressAtPosition(PROPOSED_NEW_ADMIN, proposedAdmin);\n        setNewIntAtPosition(PROPOSED_NEW_ADMIN_TIMESTAMP, block.timestamp + 1 days);\n    }\n\n    function setProxyAdmin(address newAdmin) private {\n        setNewAddressAtPosition(PROXY_ADMIN_POSITION, newAdmin);\n    }\n\n    function setNewAddressAtPosition(bytes32 position, address newAddr) private {\n        assembly { sstore(position, newAddr) }\n    }\n\n    function readAddressAtPosition(bytes32 position) private view returns (address result) {\n        assembly { result := sload(position) }\n    }\n\n    function setNewIntAtPosition(bytes32 position, uint256 newInt) private {\n        assembly { sstore(position, newInt) }\n    }\n\n    function readIntAtPosition(bytes32 position) private view returns (uint256 result) {\n        assembly { result := sload(position) }\n    }\n\n    /**\n     * @dev Fallback function forwards all transactions and returns all received return data.\n     */\n    fallback() external payable {\n        address impl = implementation();\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}"}}}