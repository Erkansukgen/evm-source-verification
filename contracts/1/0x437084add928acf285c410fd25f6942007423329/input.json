{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/token.sol":{"content":"pragma solidity ^0.6.6;\n\ncontract Owned {\n    modifier onlyOwner() {\n        require(msg.sender==owner);\n        _;\n    }\n    address payable owner;\n    address payable newOwner;\n    function changeOwner(address payable _newOwner) public onlyOwner {\n        require(_newOwner!=address(0));\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        if (msg.sender==newOwner) {\n            owner = newOwner;\n        }\n    }\n}\n\nabstract contract ERC20 {\n    uint256 public totalSupply;\n    function balanceOf(address _owner) view public virtual returns (uint256 balance);\n    function transfer(address _to, uint256 _value) public virtual returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success);\n    function approve(address _spender, uint256 _value) public virtual returns (bool success);\n    function allowance(address _owner, address _spender) view public virtual returns (uint256 remaining);\n \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n}\n\ncontract Token is Owned,  ERC20 {\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    \n    mapping (address=>uint256) right;\n    mapping (address=>mapping (string=>uint256)) freeze;\n    mapping (address=>uint256) balances;\n    mapping (address=>mapping (address=>uint256)) allowed;\n    \n    function balanceOf(address _owner) view public virtual override returns (uint256 balance) {return balances[_owner];}\n    \n    function transfer(address _to, uint256 _amount) public virtual override returns (bool success) {\n        require (balances[msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\n        if(freeze[msg.sender]['time']<now){\n            balances[msg.sender]-=_amount;\n            balances[_to]+=_amount;\n            emit Transfer(msg.sender,_to,_amount);\n        }\n        else{\n            require (balances[msg.sender]>=(_amount+freeze[msg.sender]['amount']));\n            balances[msg.sender]-=_amount;\n            balances[_to]+=_amount;\n            emit Transfer(msg.sender,_to,_amount);   \n        }\n        \n        return true;\n    }\n  \n    function transferFrom(address _from,address _to,uint256 _amount) public virtual override returns (bool success) {\n        require (balances[_from]>=_amount&&allowed[_from][msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\n        if(freeze[_from]['time']<now){\n            balances[_from]-=_amount;\n            allowed[_from][msg.sender]-=_amount;\n            balances[_to]+=_amount;\n            emit Transfer(_from, _to, _amount);\n        }\n        else{\n            require (balances[_from]>=(_amount+freeze[_from]['amount']));\n            balances[_from]-=_amount;\n            allowed[_from][msg.sender]-=_amount;\n            balances[_to]+=_amount;\n            emit Transfer(_from, _to, _amount);\n        }\n        \n        return true;\n    }\n  \n    function approve(address _spender, uint256 _amount) public virtual override returns (bool success) {\n        allowed[msg.sender][_spender]=_amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) view public virtual override returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n}\nlibrary TransferHelper {\n    function safeTransfer(address token, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n}\ncontract Frozen is Token{\n    \n    function setRight(address _user, uint256 _status) public onlyOwner returns (bool success){\n        right[_user]=_status;\n        return true;\n    }\n    \n    function freezeTarget(address _target, uint256 _day, uint256 _amount) public returns (bool success){\n        require(right[msg.sender]==1, \"You have no authority\");\n        freeze[_target]['time'] = now + _day * 1 days;\n        freeze[_target]['amount'] = _amount;\n        return true;\n    }\n    function defrost(address _target) public onlyOwner returns (bool success){\n        freeze[_target]['time'] = now;\n        return true;\n    }\n    function withdrawToken(address token, uint256 value) public onlyOwner{\n        TransferHelper.safeTransfer(token, owner, value);\n    }\n    \n    function getDefrostTime(address _target) public view returns (uint256){\n        if(freeze[_target]['time'] > now){\n            return freeze[_target]['time'] - now;\n        }\n        else{\n            return 0;\n        }\n    }\n      function getFreezeAmount(address _target) public view returns (uint256){\n        return freeze[_target]['amount'];\n    }\n    function getRight(address _target) public view returns (uint256){\n        return right[_target];\n    }\n    constructor() public{\n        symbol = \"LOCAL\";\n        name = \"Local.com\";\n        decimals = 18;\n        totalSupply = 30000*10**18;\n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    receive () payable external {\n        require(msg.value>0);\n        owner.transfer(msg.value);\n    }\n}"}}}