{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BulldogBackupContract.sol":{"content":"//\"SPDX-License-Identifier: UNLICENSED\"\n\npragma solidity >=0.6.0 <0.9.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract BulldogBackupContract is Ownable {\n  mapping(address => bool) private promisedTransactionExists;\n  mapping(address => TransactionPromise[]) private promisedTransactionsFromTarget;\n  mapping(address => TransactionPromise[]) private promisedTransactionsToSource;\n  uint256 private fee = 100000000000000 wei;\n  \n  struct TransactionPromise {\n      address source;\n      address target;\n      address tokenAddress;\n      uint256 amount;\n  }\n  \n  constructor() Ownable() { }\n  \n  function recordBackup(address tokenAddress, address newBackupAddress, uint256 amount) public payable {\n      require(msg.value == fee);\n      TransactionPromise memory newTransaction = TransactionPromise(msg.sender, newBackupAddress, tokenAddress, amount);\n      if(!promisedTransactionExists[newBackupAddress]){\n          promisedTransactionExists[newBackupAddress] = true;\n          promisedTransactionsToSource[msg.sender].push(newTransaction);\n          promisedTransactionsFromTarget[newBackupAddress].push(newTransaction);\n      } else {\n          TransactionPromise[] memory promises = promisedTransactionsFromTarget[newBackupAddress];\n          for(uint i = 0; i < promises.length; i++){\n              if(promises[i].tokenAddress == tokenAddress && promises[i].source == msg.sender && promises[i].target == newBackupAddress){\n                  promisedTransactionsFromTarget[newBackupAddress][i].amount = amount;\n              }\n          }\n          TransactionPromise[] memory promisesTo = promisedTransactionsToSource[msg.sender];\n          for(uint i = 0; i < promisesTo.length; i++){\n              if(promisesTo[i].tokenAddress == tokenAddress && promisesTo[i].source == msg.sender && promisesTo[i].target == newBackupAddress){\n                  promisedTransactionsToSource[msg.sender][i].amount = amount;\n              }\n          }\n      }\n      \n      \n      //promisedTransactionsToSource[msg.sender].push(newTransaction);\n      //promisedTransactionsFromTarget[newBackupAddress].push(newTransaction);\n      //promisedTransactionsToSource[msg.sender].push(TransactionPromise(msg.sender, newBackupAddress, tokenAddress, amount));\n      //promisedTransactionsFromTarget[newBackupAddress].push(TransactionPromise(msg.sender, newBackupAddress, tokenAddress, amount));\n  }\n  \n  function transferBackup(address tokenAddress, address oldAddress, uint256 amount) public returns(bool) {\n      if(promisedTransactionExists[msg.sender]){\n          TransactionPromise[] memory promises = promisedTransactionsFromTarget[msg.sender];\n          for(uint i = 0; i < promises.length; i++){\n              if(promises[i].tokenAddress == tokenAddress && promises[i].source == oldAddress && promises[i].target == msg.sender){\n                  IERC20(tokenAddress).transferFrom(oldAddress, address(this), amount);\n                  IERC20(tokenAddress).approve(msg.sender, amount);\n                  IERC20(tokenAddress).transfer(msg.sender, amount);\n                  \n                  if(promises[i].amount == amount) {\n                    delete promisedTransactionsFromTarget[msg.sender][i];\n                    promisedTransactionExists[msg.sender] = false;\n                  } else {\n                    promisedTransactionsFromTarget[msg.sender][i].amount -= amount;\n                  }\n                  updateAmount(tokenAddress, oldAddress, msg.sender, promisedTransactionsFromTarget[msg.sender][i].amount);\n                  return true;\n              }\n          }\n      }\n      return false;\n  }\n  \n  function updateAmount(address tokenAddress, address addressFrom, address addressTo, uint256 amount) private {\n    TransactionPromise[] memory promises = promisedTransactionsToSource[addressFrom];\n    for(uint i = 0; i < promises.length; i++){\n      if(promises[i].tokenAddress == tokenAddress && promises[i].source == addressFrom && promises[i].target == addressTo){\n        promisedTransactionsToSource[addressFrom][i].amount = amount;\n      }\n    }\n  }\n  \n  function transferBackupPossible(address tokenAddress, address oldAddress, uint256 amount) public view returns (bool) {\n      if(promisedTransactionExists[msg.sender]){\n          TransactionPromise[] memory promises = promisedTransactionsFromTarget[msg.sender];\n          for(uint i = 0; i < promises.length; i++){\n              if(promises[i].tokenAddress == tokenAddress && promises[i].source == oldAddress && promises[i].target == msg.sender){\n                  return true;\n              }\n          }\n      }\n      return false;\n  }\n  \n  function GetPromisedTransactionsFromTarget(address target) public view returns (TransactionPromise[] memory) {\n      return promisedTransactionsFromTarget[target];\n  }\n  \n  function GetPromisedTransactionsToSource(address source) public view returns (TransactionPromise[] memory) {\n      return promisedTransactionsToSource[source];\n  }\n  \n  function GetPromisedTransactionExists(address source) public view returns (bool) {\n      return promisedTransactionExists[source];\n  }\n  \n  function transfer(address payable _to, uint256 value) public payable onlyOwner {\n    (bool sent, bytes memory data) = _to.call{value: value}(\"\");\n    require(sent, \"Failed to send Ether\");\n  }\n  \n  function updateFee(uint256 newFee) public onlyOwner {\n      fee = newFee;\n  }\n}\n\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}}}