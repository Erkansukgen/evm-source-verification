{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "library/SafeMath.sol": {
      "content": "pragma solidity ^ 0.7.0;\r\nlibrary SafeMath {\r\n  function add(uint x, uint y) internal pure returns (uint z) {\r\n    require((z = x + y) >= x, 'ds-math-add-overflow');\r\n  }\r\n\r\n  function sub(uint x, uint y) internal pure returns (uint z) {\r\n    require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n  }\r\n\r\n  function mul(uint x, uint y) internal pure returns (uint z) {\r\n    if (x == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = x * y;\r\n    require(c / x == y, \"ds-math-mul-overflow\");\r\n    return c;\r\n  }\r\n  function div(uint a, uint b) internal pure returns (uint c) {\r\n    require(b > 0,'ds-math-div-overflow');\r\n    c = a / b;\r\n  }\r\n}"
    },
    "zob_eth.sol": {
      "content": "pragma solidity = 0.7.6;\r\nimport \"./library/SafeMath.sol\";\r\n\r\ninterface IERC20 {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract ZooClub {\r\n  using SafeMath for uint256;\r\n  event ev_join(address indexed addr, address token, uint256 val, uint64 uId, uint64 timestamp);\r\n  event ev_withdraw(address indexed addr,  address token, uint256 val, uint256 fee, uint64 timestamp);\r\n  event ev_transfer_to(address indexed addr,  address token, uint256 val, uint64 timestamp);\r\n  event ev_executor(address indexed addr, uint256 cnt, uint64 optype, uint64 timestamp);\r\n  event ev_fee_addr(address indexed oldaddr, address newaddr, uint64 timestamp);\r\n\r\n  uint64 immutable public deploy_block_num;\r\n  address constant public ADMIN_ADDR = 0xCc219c274177bE6c9cebd78D28368C7f0439966C;\r\n\r\n  address constant private USDT_ADDR=0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n  address constant private SHIB_ADDR=0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;\r\n  address constant private SDOG_ADDR=0x537edD52ebcb9F48ff2f8a28c51FCdB9D6a6E0D4;\r\n  address constant private HOGE_ADDR=0xfAd45E47083e4607302aa43c65fB3106F1cd7607;\r\n  address constant private AKITA_ADDR=0x3301Ee63Fb29F863f2333Bd4466acb46CD8323E6;\r\n  address constant private KISHU_ADDR=0xA2b4C0Af19cC16a6CfAcCe81F192B024d625817D;\r\n  address constant private FLOKI_ADDR=0x43f11c02439e2736800433b4594994Bd43Cd066D;\r\n\r\n  address[7] public Init_Token_Addr = [USDT_ADDR, SDOG_ADDR,SHIB_ADDR, HOGE_ADDR,AKITA_ADDR,KISHU_ADDR,FLOKI_ADDR];\r\n  address public fee_addr = 0xF7f38c2014c57EE654c314C4766951873E8E56cC;\r\n\r\n  address[] public executors;\r\n  uint public executors_cnt = 0;\r\n  \r\n  mapping (address => bool) public isExecutor;\r\n  mapping (address => mapping(address => uint256)) public players;\r\n\r\n  constructor() {\r\n    deploy_block_num = uint64(block.number);\r\n    isExecutor[ADMIN_ADDR] = true;\r\n    executors.push(ADMIN_ADDR);\r\n    executors_cnt=1;\r\n    emit ev_executor(ADMIN_ADDR, executors_cnt, 1, uint64(block.number));\r\n  }\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == ADMIN_ADDR);\r\n    _;\r\n  }\r\n  modifier executorDoesNotExist(address executor) {\r\n    require(!isExecutor[executor]);\r\n    _;\r\n  }\r\n\r\n  modifier executorExists(address executor) {\r\n    require(isExecutor[executor]);\r\n    _;\r\n  }\r\n  modifier notNull(address _address) {\r\n    require(_address !=  address(0));\r\n    _;\r\n  }\r\n\r\n  modifier onlyExecutor(){\r\n    require(isExecutor[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  function safeTransfer(address token, address to, uint256 value) internal {\r\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20(token).transfer.selector, to, value));\r\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'SafeERC20: TRANSFER_FAILED');\r\n  }\r\n\r\n  function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20(token).transferFrom.selector, from, to, value));\r\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'SafeERC20: TRANSFERFROM_FAILED');\r\n  }\r\n\r\n  function addExecutor(address executor) public onlyAdmin executorDoesNotExist(executor) notNull(executor) {\r\n    isExecutor[executor] = true;\r\n    if(executors_cnt >= executors.length){\r\n      executors.push(executor);\r\n    }else{\r\n      executors[executors_cnt] = executor;\r\n    }\r\n    executors_cnt+=1;\r\n    emit ev_executor(executor, executors_cnt, 1, uint64(block.timestamp));\r\n  }\r\n\r\n  function removeExecutor(address executor) public onlyAdmin executorExists(executor) {\r\n    isExecutor[executor] = false;\r\n    for (uint i=0; i<executors_cnt; i++){\r\n       if (executors[i] == executor) {\r\n          executors_cnt -= 1;\r\n          if(i != executors_cnt) {\r\n            executors[i] = executors[executors_cnt];\r\n          }\r\n          emit ev_executor(executor, executors_cnt, 2, uint64(block.timestamp));\r\n          break;\r\n      }\r\n    }\r\n  }\r\n \r\n  function replaceExecutor(address executor, address newExecutor) public onlyAdmin notNull(executor) executorExists(executor) executorDoesNotExist(newExecutor){\r\n    for (uint i=0; i<executors_cnt; i++)\r\n      if (executors[i] == executor) {\r\n        executors[i] = newExecutor;\r\n        isExecutor[executor] = false;\r\n        isExecutor[newExecutor] = true;\r\n        emit ev_executor(executor, executors_cnt-1, 4, uint64(block.timestamp));\r\n        emit ev_executor(newExecutor, executors_cnt, 3, uint64(block.timestamp));\r\n        break;\r\n      }\r\n  }\r\n  function setFeeAddr(address addr) public onlyAdmin notNull(addr) {\r\n    emit ev_fee_addr(fee_addr, addr, uint64(block.timestamp));\r\n    fee_addr = addr;\r\n  }\r\n\r\n  function join(address token, uint256 value, uint64 uId) public {\r\n    int i = get_token_index(token);\r\n    require(i >= 0, \"invalid token\");\r\n    require(value > 0, \"invalid value\");\r\n    safeTransferFrom(token, msg.sender, address(this), value);\r\n    players[msg.sender][token] = players[msg.sender][token].add(value);\r\n    emit ev_join(msg.sender, token, value, uId, uint64(block.timestamp));\r\n  }\r\n\r\n  function withdraw(address addr, address token, uint256 value, uint256 fee) public onlyExecutor notNull(addr) {\r\n    int pos = get_token_index(token);\r\n    require(pos >= 0, \"invalid token\");\r\n    require(value > fee, \"fee is invalid\");\r\n    require(players[addr][token] >= value, \"insufficient funds\");\r\n    players[addr][token] = players[addr][token].sub(value);\r\n    safeTransfer(token, addr, value-fee);\r\n    if(fee > 0) {\r\n      safeTransfer(token, fee_addr, fee);\r\n    }\r\n    emit ev_withdraw(addr, token, value, fee, uint64(block.timestamp));\r\n  }\r\n\r\n  function withdrawbatch(address[] calldata addrs, address[] calldata tokens, uint256[] calldata values, uint256[] calldata fees) public onlyExecutor {\r\n    require(addrs.length == tokens.length && addrs.length == values.length && addrs.length == fees.length, \"addrs,tokens,values,fees length mismatch\");\r\n    address addr;\r\n    address token;\r\n    uint256 value;\r\n    uint256 fee;\r\n    for(uint i = 0; i < addrs.length; i++) {\r\n      addr = addrs[i];\r\n      token = tokens[i];\r\n      value = values[i];\r\n      fee = fees[i];\r\n      int pos = get_token_index(token);\r\n      require(addr!=address(0));\r\n      require(pos >= 0 && value > fee && players[addr][token] >= value);\r\n      players[addr][token] = players[addr][token].sub(value);\r\n      safeTransfer(token, addr, value-fee);\r\n      if(fee > 0) {\r\n        safeTransfer(token, fee_addr, fee);\r\n      }\r\n      emit ev_withdraw(addr, token, value, fee, uint64(block.timestamp));\r\n    }\r\n  }\r\n\r\n  function transferTo(address to, address token, uint256 value) public onlyAdmin {\r\n    int i = get_token_index(token);\r\n    require(i >= 0, \"invalid token\");\r\n    safeTransfer(token, to, value);\r\n    emit ev_transfer_to(to, token, value, uint64(block.timestamp));\r\n  }\r\n\r\n  function get_token_index(address token) public view returns(int) {\r\n    for(uint i = 0; i < Init_Token_Addr.length; i++){\r\n        if(token == Init_Token_Addr[i]) {\r\n             return int(i);\r\n        }\r\n    }\r\n    return -1;\r\n  }\r\n}\r\n"
    }
  }
}