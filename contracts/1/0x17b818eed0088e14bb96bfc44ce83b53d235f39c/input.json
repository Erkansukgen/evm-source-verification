{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/AccredifyMultiSigDocStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev contract module that provides the OpenCerts DocumentStore contract to be used\r\n * to issue and remoke certificates on the blockchain\r\n */\r\ncontract DocumentStore is Ownable {\r\n    string public name;\r\n    string public version = \"2.3.0\";\r\n\r\n    /// A mapping of the document hash to the block number that was issued\r\n    mapping(bytes32 => uint256) public documentIssued;\r\n    /// A mapping of the hash of the claim being revoked to the revocation block number\r\n    mapping(bytes32 => uint256) public documentRevoked;\r\n\r\n    event DocumentIssued(bytes32 indexed document);\r\n    event DocumentRevoked(bytes32 indexed document);\r\n\r\n    constructor(string memory _name) {\r\n        name = _name;\r\n    }\r\n\r\n    function issue(bytes32 document) public onlyOwner onlyNotIssued(document) {\r\n        documentIssued[document] = block.number;\r\n        emit DocumentIssued(document);\r\n    }\r\n\r\n    function bulkIssue(bytes32[] memory documents) public {\r\n        for (uint256 i = 0; i < documents.length; i++) {\r\n            issue(documents[i]);\r\n        }\r\n    }\r\n\r\n    function getIssuedBlock(bytes32 document)\r\n    public\r\n    view\r\n    onlyIssued(document)\r\n    returns (uint256)\r\n    {\r\n        return documentIssued[document];\r\n    }\r\n\r\n    function isIssued(bytes32 document) public view returns (bool) {\r\n        return (documentIssued[document] != 0);\r\n    }\r\n\r\n    function isIssuedBefore(bytes32 document, uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return\r\n        documentIssued[document] != 0 && documentIssued[document] <= blockNumber;\r\n    }\r\n\r\n    function revoke(bytes32 document)\r\n    public\r\n    onlyOwner\r\n    onlyNotRevoked(document)\r\n    {\r\n        documentRevoked[document] = block.number;\r\n        emit DocumentRevoked(document);\r\n    }\r\n\r\n    function bulkRevoke(bytes32[] memory documents) public {\r\n        for (uint256 i = 0; i < documents.length; i++) {\r\n            revoke(documents[i]);\r\n        }\r\n    }\r\n\r\n    function isRevoked(bytes32 document) public view returns (bool) {\r\n        return documentRevoked[document] != 0;\r\n    }\r\n\r\n    function isRevokedBefore(bytes32 document, uint256 blockNumber)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return\r\n        documentRevoked[document] <= blockNumber && documentRevoked[document] != 0;\r\n    }\r\n\r\n    modifier onlyIssued(bytes32 document) {\r\n        require(\r\n            isIssued(document),\r\n            \"Error: Only issued document hashes can be revoked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotIssued(bytes32 document) {\r\n        require(\r\n            !isIssued(document),\r\n            \"Error: Only hashes that have not been issued can be issued\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotRevoked(bytes32 claim) {\r\n        require(!isRevoked(claim), \"Error: Hash has been revoked previously\");\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * AccredifyMultiSigDocStore\r\n * ============\r\n *\r\n * Basic multi-signer wallet designed for use in a co-signing environment where\r\n * 2 signatures are required to issue and revoke certificates.\r\n * Typically used in a 2-of-3 signing configuration. Uses ecrecover to allow\r\n * for 2 signatures in a single transaction.\r\n *\r\n * The first signature is created on the operation hash (see Data Formats) and\r\n * passed to the multiSig functions\r\n * The signer is determined by verifyMultiSig().\r\n *\r\n * The second signature is created by the submitter of the transaction and determined\r\n * by msg.signer.\r\n *\r\n * This wallet only allows for three signers that have to be set upon deployment.\r\n * The signers cannot be changed/removed/added.\r\n *\r\n * This iteration of the wallet restricts the initiation of the different functions to\r\n * specific signers, and removes the expiryTime param, and removes events.\r\n *\r\n * Signer Authorisation\r\n * ====================\r\n * All multisig transactions can only be initiated by the 3rd Signer AKA The Custodian\r\n *\r\n * Data Formats\r\n * ============\r\n *\r\n * The signature is created with ethereumjs-util.ecsign(operationHash).\r\n * Like the eth_sign RPC call, it packs the values as a 65-byte array of [r, s, v].\r\n * Unlike eth_sign, the message is not prefixed.\r\n *\r\n * The operationHash the result of keccak256(prefix, hash).\r\n * For Issue transactions, `prefix` is \"ISSUE\".\r\n * For Bulk Issue transactions, `prefix` is \"BULKISSUE\".\r\n * For Revoke transaction, `prefix` is \"REVOKE\".\r\n * For Bulk Revoke transaction, `prefix` is \"BULKREVOKE\".\r\n * For Transfer transaction, 'prefix' is \"TRANSFER\"\r\n * For Change transaction, 'prefix' is \"CHANGE\"\r\n *\r\n */\r\ncontract AccredifyMultiSigDocStore {\r\n    // Public fields\r\n    address[] public signers; // The addresses that can co-sign transactions on the wallet\r\n    DocumentStore public documentStore; //DocumentStore Contract\r\n\r\n    /**\r\n     * Constructor\r\n     * ============\r\n     *\r\n     * Deploys a new AccredifyMultiSig contract\r\n     * Takes in an array of 3 signers that will be used to approve transactions\r\n     *\r\n     */\r\n    constructor(address[] memory _signers, string memory _name) {\r\n        require(_signers.length == 3, \"3 signers required\");\r\n        signers = _signers;\r\n        documentStore = new DocumentStore(_name);\r\n    }\r\n\r\n    /**\r\n     * Modifier that will execute internal code block only if the sender is the Custodian\r\n     */\r\n    modifier onlyCustodian {\r\n        require(msg.sender == signers[2], \"Wrong initiator\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Fallback function. Is called when a transaction is received without calling a method\r\n     */\r\n    fallback() external {\r\n        revert();\r\n        // Reject any accidental Ether transfer\r\n    }\r\n\r\n    /**\r\n     * Execute a multi-signature issue transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     *\r\n     * @param hash the certificate batch's hash that will be appended to the blockchain\r\n     * @param signature second signer's signature\r\n     */\r\n    function issue(\r\n        bytes32 hash,\r\n        bytes memory signature\r\n    ) public onlyCustodian {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"ISSUE\", hash));\r\n        verify(operationHash, signature, 0);\r\n        documentStore.issue(hash);\r\n    }\r\n\r\n    /**\r\n     * Execute a multi-signature bulk issue transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     *\r\n     * @param hashes an array of certificate batch hashes that will be appended to the blockchain\r\n     * @param signature second signer's signature\r\n     */\r\n    function bulkIssue(\r\n        bytes32[] memory hashes,\r\n        bytes memory signature\r\n    ) public onlyCustodian {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"BULKISSUE\", hashes));\r\n        verify(operationHash, signature, 0);\r\n        documentStore.bulkIssue(hashes);\r\n    }\r\n\r\n    /**\r\n     * Execute a multi-signature revoke transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     *\r\n     * @param hash the certificate's hash that will be revoked on the blockchain\r\n     * @param signature second signer's signature\r\n     */\r\n    function revoke(\r\n        bytes32 hash,\r\n        bytes memory signature\r\n    ) public onlyCustodian {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"REVOKE\", hash));\r\n        verify(operationHash, signature, 0);\r\n        documentStore.revoke(hash);\r\n    }\r\n\r\n    /**\r\n    * Execute a multi-signature bulk revoke transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n    *\r\n    * @param hashes an array of certificate hashes that will be revoked on the blockchain\r\n    * @param signature second signer's signature\r\n    */\r\n    function bulkRevoke(\r\n        bytes32[] memory hashes,\r\n        bytes memory signature\r\n    ) public onlyCustodian {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"BULKREVOKE\", hashes));\r\n        verify(operationHash, signature, 0);\r\n        documentStore.bulkRevoke(hashes);\r\n    }\r\n\r\n    /**\r\n     * Execute a multi-signature transfer transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     * This transaction transfers the ownership of the certificate store to a new owner.\r\n     *\r\n     * @param newOwner the new owner's address\r\n     * @param signature second signer's signature\r\n     */\r\n    function transfer(\r\n        address newOwner,\r\n        bytes memory signature\r\n    ) public onlyCustodian {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"TRANSFER\", newOwner));\r\n        verify(operationHash, signature, 1);\r\n        documentStore.transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * Execute a multi-signature change transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n     * This transaction changes the address of the DocumentStore on this wallet contract.\r\n     *\r\n     * @param newStore the new owner's address\r\n     * @param signature second signer's signature\r\n     */\r\n    function changeStore(\r\n        address newStore,\r\n        bytes memory signature\r\n    ) public onlyCustodian {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"CHANGE\", newStore));\r\n        verify(operationHash, signature, 1);\r\n        documentStore = DocumentStore(newStore);\r\n    }\r\n\r\n    /**\r\n     * Do common multisig verification for both Issue and Revoke transactions\r\n     *\r\n     * @param operationHash keccak256(prefix, hash)\r\n     * @param signature second signer's signature\r\n     * @param signer order in singers array\r\n     * returns address that has created the signature\r\n     */\r\n    function verify(\r\n        bytes32 operationHash,\r\n        bytes memory signature,\r\n        uint8 signer\r\n    ) private view {\r\n        address otherSigner = recoverAddress(operationHash, signature);\r\n        require(otherSigner == signers[signer], \"Wrong signer\");\r\n    }\r\n\r\n    /**\r\n     * Gets signer's address using ecrecover\r\n     * @param operationHash see Data Formats\r\n     * @param signature see Data Formats\r\n     * returns address recovered from the signature\r\n     */\r\n    function recoverAddress(\r\n        bytes32 operationHash,\r\n        bytes memory signature\r\n    ) private pure returns (address) {\r\n        if (signature.length != 65) {\r\n            revert();\r\n        }\r\n        // We need to unpack the signature, which is given as an array of 65 bytes (like eth.sign)\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := and(mload(add(signature, 65)), 255)\r\n        }\r\n        if (v < 27) {\r\n            v += 27;\r\n            // Ethereum versions are 27 or 28 as opposed to 0 or 1 which is submitted by some signing libs\r\n        }\r\n        return ecrecover(operationHash, v, r, s);\r\n    }\r\n}\r\n"
    }
  }
}