{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"GaugeProxy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nlibrary Math {\n    function max(uint a, uint b) internal pure returns (uint) {\n        return a >= b ? a : b;\n    }\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n}\n\ninterface erc20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function decimals() external view returns (uint8);\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n}\n\ninterface ve {\n    function locked__end(address) external view returns (uint);\n    function deposit_for(address, uint) external;\n}\n\ninterface delegate {\n    function get_adjusted_ve_balance(address, address) external view returns (uint);\n}\n\ncontract Gauge {\n    address constant _ibff = 0xb347132eFf18a3f63426f4988ef626d2CbE274F5;\n    address constant _veibff = 0x4D0518C9136025903751209dDDdf6C67067357b1;\n    address constant _delegate = 0x0ea89fb2E5b8FA8F14b741ffe1A4617A32611DfC;\n    address constant _vedist = 0x83893c4A42F8654c2dd4FF7b4a7cd0e33ae8C859;\n    \n    uint constant DURATION = 7 days;\n    uint constant PRECISION = 10 ** 18;\n    uint constant MAXTIME = 4 * 365 * 86400;\n    \n    address public immutable stake;\n    address immutable distribution;\n    \n    uint public rewardRate;\n    uint public periodFinish;\n    uint public lastUpdateTime;\n    uint public rewardPerTokenStored;\n    \n    modifier onlyDistribution() {\n        require(msg.sender == distribution);\n        _;\n    }\n    \n    mapping(address => uint) public userRewardPerTokenPaid;\n    mapping(address => uint) public rewards;\n\n    uint public totalSupply;\n    uint public derivedSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => uint) public derivedBalances;\n    \n    constructor(address _stake) {\n        stake = _stake;\n        distribution = msg.sender;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored + ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * PRECISION / derivedSupply);\n    }\n    \n    function derivedBalance(address account) public view returns (uint) {\n        uint _balance = balanceOf[account];\n        uint _derived = _balance * 40 / 100;\n        uint _adjusted = (totalSupply * delegate(_delegate).get_adjusted_ve_balance(account, address(this)) / erc20(_veibff).totalSupply()) * 60 / 100;\n        return Math.min(_derived + _adjusted, _balance);\n    }\n    \n    function kick(address account) public {\n        uint _derivedBalance = derivedBalances[account];\n        derivedSupply -= _derivedBalance;\n        _derivedBalance = derivedBalance(account);\n        derivedBalances[account] = _derivedBalance;\n        derivedSupply += _derivedBalance;\n    }\n\n    function earned(address account) public view returns (uint) {\n        return (derivedBalances[account] * (rewardPerToken() - userRewardPerTokenPaid[account]) / PRECISION) + rewards[account];\n    }\n\n    function getRewardForDuration() external view returns (uint) {\n        return rewardRate * DURATION;\n    }\n    \n    function deposit() external {\n        _deposit(erc20(stake).balanceOf(msg.sender), msg.sender);\n    }\n    \n    function deposit(uint amount) external {\n        _deposit(amount, msg.sender);\n    }\n    \n    function deposit(uint amount, address account) external {\n        _deposit(amount, account);\n    }\n    \n    function _deposit(uint amount, address account) internal updateReward(account) {\n        totalSupply += amount;\n        balanceOf[account] += amount;\n        _safeTransferFrom(stake, account, address(this), amount);\n    }\n    \n    function withdraw() external {\n        _withdraw(balanceOf[msg.sender]);\n    }\n\n    function withdraw(uint amount) external {\n        _withdraw(amount);\n    }\n    \n    function _withdraw(uint amount) internal updateReward(msg.sender) {\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint _reward = rewards[msg.sender];\n        uint _user_lock = ve(_veibff).locked__end(msg.sender);\n        uint _adj = Math.min(_reward * (_user_lock - block.timestamp) / MAXTIME, _reward);\n        if (_adj > 0) {\n            rewards[msg.sender] = 0;\n            _safeTransfer(_ibff, msg.sender, _adj);\n            ve(_veibff).deposit_for(msg.sender, _adj);\n            _safeTransfer(_ibff, _vedist, _reward - _adj);\n        }\n    }\n\n    function exit() external {\n       _withdraw(balanceOf[msg.sender]);\n        getReward();\n    }\n    \n    function notifyRewardAmount(uint amount) external onlyDistribution updateReward(address(0)) {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = amount / DURATION;\n        } else {\n            uint _remaining = periodFinish - block.timestamp;\n            uint _left = _remaining * rewardRate;\n            rewardRate = (amount + _left) / DURATION;\n        }\n        \n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + DURATION;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n        if (account != address(0)) {\n            kick(account);\n        }\n    }\n    \n    function _safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n    \n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n\ncontract GaugeProxy {\n    address constant _ibff = 0xb347132eFf18a3f63426f4988ef626d2CbE274F5;\n    address constant _delegate = 0x0ea89fb2E5b8FA8F14b741ffe1A4617A32611DfC;\n    address constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;\n    \n    uint public totalWeight;\n    \n    address public gov;\n    address public nextgov;\n    uint public commitgov;\n    uint public constant delay = 1 days;\n    \n    address[] internal _tokens;\n    mapping(address => address) public gauges; // token => gauge\n    mapping(address => uint) public weights; // token => weight\n    mapping(address => mapping(address => uint)) public votes; // msg.sender => votes\n    mapping(address => address[]) public tokenVote;// msg.sender => token\n    mapping(address => uint) public usedWeights;  // msg.sender => total voting weight of user\n    mapping(address => bool) public enabled;\n    \n    function tokens() external view returns (address[] memory) {\n        return _tokens;\n    }\n    \n    constructor() {\n        gov = msg.sender;\n    }\n    \n    modifier g() {\n        require(msg.sender == gov);\n        _;\n    }\n    \n    function setGov(address _gov) external g {\n        nextgov = _gov;\n        commitgov = block.timestamp + delay;\n    }\n    \n    function acceptGov() external {\n        require(msg.sender == nextgov && commitgov < block.timestamp);\n        gov = nextgov;\n    }\n    \n    function reset() external {\n        _reset(msg.sender);\n    }\n    \n    function _reset(address _owner) internal {\n        address[] storage _tokenVote = tokenVote[_owner];\n        uint _tokenVoteCnt = _tokenVote.length;\n\n        for (uint i = 0; i < _tokenVoteCnt; i ++) {\n            address _token = _tokenVote[i];\n            uint _votes = votes[_owner][_token];\n            \n            if (_votes > 0) {\n                totalWeight -= _votes;\n                weights[_token] -= _votes;\n                votes[_owner][_token] = 0;\n            }\n        }\n\n        delete tokenVote[_owner];\n    }\n    \n    function poke(address _owner) public {\n        address[] memory _tokenVote = tokenVote[_owner];\n        uint _tokenCnt = _tokenVote.length;\n        uint[] memory _weights = new uint[](_tokenCnt);\n        \n        uint _prevUsedWeight = usedWeights[_owner];\n        uint _weight = delegate(_delegate).get_adjusted_ve_balance(_owner, ZERO_ADDRESS);\n\n        for (uint i = 0; i < _tokenCnt; i ++) {\n            uint _prevWeight = votes[_owner][_tokenVote[i]];\n            _weights[i] = _prevWeight * _weight / _prevUsedWeight;\n        }\n\n        _vote(_owner, _tokenVote, _weights);\n    }\n    \n    function _vote(address _owner, address[] memory _tokenVote, uint[] memory _weights) internal {\n        // _weights[i] = percentage * 100\n        _reset(_owner);\n        uint _tokenCnt = _tokenVote.length;\n        uint _weight = delegate(_delegate).get_adjusted_ve_balance(_owner, ZERO_ADDRESS);\n        uint _totalVoteWeight = 0;\n        uint _usedWeight = 0;\n\n        for (uint i = 0; i < _tokenCnt; i ++) {\n            _totalVoteWeight += _weights[i];\n        }\n\n        for (uint i = 0; i < _tokenCnt; i ++) {\n            address _token = _tokenVote[i];\n            address _gauge = gauges[_token];\n            uint _tokenWeight = _weights[i] * _weight / _totalVoteWeight;\n\n            if (_gauge != address(0x0)) {\n                _usedWeight += _tokenWeight;\n                totalWeight += _tokenWeight;\n                weights[_token] += _tokenWeight;\n                tokenVote[_owner].push(_token);\n                votes[_owner][_token] = _tokenWeight;\n            }\n        }\n\n        usedWeights[_owner] = _usedWeight;\n    }\n    \n    function vote(address[] calldata _tokenVote, uint[] calldata _weights) external {\n        require(_tokenVote.length == _weights.length);\n        _vote(msg.sender, _tokenVote, _weights);\n    }\n    \n    function addGauge(address _token) external g {\n        require(gauges[_token] == address(0x0), \"exists\");\n        address _gauge = address(new Gauge(_token));\n        gauges[_token] = _gauge;\n        enabled[_token] = true;\n        _tokens.push(_token);\n    }\n    \n    function disable(address _token) external g {\n        enabled[_token] = false;\n    }\n    \n    function enable(address _token) external g {\n        enabled[_token] = true;\n    }\n    \n    function length() external view returns (uint) {\n        return _tokens.length;\n    }\n    \n    function distribute() external {\n        uint _balance = erc20(_ibff).balanceOf(address(this));\n        if (_balance > 0 && totalWeight > 0) {\n            uint _totalWeight = totalWeight;\n            for (uint i = 0; i < _tokens.length; i++) {\n                if (!enabled[_tokens[i]]) {\n                    _totalWeight -= weights[_tokens[i]];\n                }\n            }\n            for (uint x = 0; x < _tokens.length; x++) {\n                if (enabled[_tokens[x]]) {\n                    uint _reward = _balance * weights[_tokens[x]] / _totalWeight;\n                    if (_reward > 0) {\n                        address _gauge = gauges[_tokens[x]];\n                        _safeTransfer(_ibff, _gauge, _reward);\n                        Gauge(_gauge).notifyRewardAmount(_reward);\n                    }\n                }\n            }\n        }\n    }\n    \n    function _safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}"}}}