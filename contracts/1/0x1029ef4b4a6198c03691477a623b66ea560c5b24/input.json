{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Rewards Tracker V2/Context.sol":{"content":"pragma solidity ^0.8.10;\n\n// SPDX-License-Identifier: MIT\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    \n    function _msgValue() internal view virtual returns (uint256) {\n        return msg.value;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"},"Rewards Tracker V2/IRewardsToken.sol":{"content":"pragma solidity ^0.8.10;\n\n// SPDX-License-Identifier: Apache-2.0\n\ninterface IRewardsToken {\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    function isExcludedFromRewards(address wallet) external view returns (bool);\n    \n    function getRewardsSupply() external view returns (uint256);\n}"},"Rewards Tracker V2/Ownable.sol":{"content":"pragma solidity ^0.8.10;\n\n// SPDX-License-Identifier: MIT\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"Rewards Tracker V2/RewardsTracker.sol":{"content":"pragma solidity ^0.8.10;\n\n// SPDX-License-Identifier: Apache-2.0\n\nimport \"./Ownable.sol\";\nimport \"./IRewardsToken.sol\";\nimport \"./SafeMath.sol\";\n\ncontract RewardsTracker is Ownable {\n    using SafeMath for uint256;\n\n    struct TrackingData {\n        IRewardsToken rewardsToken;\n        string trackerName;\n        uint256 allocation;\n        bool enabled;\n    }\n    \n    mapping(uint256 => TrackingData) private trackerData;\n    mapping(address => uint256) private walletNonce;\n    bool public withdrawAllowed = true;\n    uint256 public totalCollected = 0;\n    uint256 public totalWithdrawn = 0;\n\n    address public signer =\n        address(0xF83Ba7773Acc6F87Ea53Ff8B6B9C6a979fef63AD);\n    address payable private _devWalletAddress =\n        payable(0x4cCCC4DDde1D32f728Dca729475A75FE23159E38);\n\n    event TrackerAdded(uint trackerId);\n    event TrackerRemoved(uint trackerId);\n    event AllocationAdded(uint256 value);\n    event DevWalletUpdated(address newDevWallet);\n    event SignerUpdated(address signer);\n    event WithdrawStatusChanged(bool allowed);\n    event Withdrawn(address wallet, uint256 amount);\n\n    function addTracker(uint identifier, address rewardsTokenAddress, string memory name) external onlyOwner {\n        require (!trackerData[identifier].enabled, \"Tracker already registered and enabled\");\n        TrackingData memory data;\n        data.rewardsToken = IRewardsToken(rewardsTokenAddress);\n        data.trackerName = name;\n        data.enabled = true;\n\n        trackerData[identifier] = data;\n        emit TrackerAdded(identifier);\n    }\n\n    function removeTracker(uint identifier) external onlyOwner {\n        require (trackerData[identifier].enabled, \"Tracker not yet registered or already disabled\");\n        trackerData[identifier].enabled = false;\n        \n        if (trackerData[identifier].allocation > 0) {\n            sendEthToWallet(_devWalletAddress, trackerData[identifier].allocation);\n        }\n\n        emit TrackerRemoved(identifier);\n    }\n\n    function getTracker(uint identifier) external view returns (TrackingData memory) {\n        return trackerData[identifier];\n    }\n\n    function getWalletNonce(address wallet) external view returns (uint256) {\n        return walletNonce[wallet];\n    }\n\n    function addAllocation(uint identifier) external payable {\n        require(_msgValue() > 0, \"Allocation can't be 0\");\n        \n        TrackingData storage trackingData = trackerData[identifier];\n        require(trackingData.enabled, \"Tracker isn't enabled\");\n\n        totalCollected = totalCollected.add(_msgValue());\n        trackingData.allocation = trackingData.allocation.add(_msgValue());\n\n        emit AllocationAdded(_msgValue());\n    }\n\n    function withdraw(uint256 identifier, uint256 amount, uint256 nonce, bytes memory sig) external payable {\n        require(withdrawAllowed, \"withdraw is disabled\");\n\n        bytes32 message = keccak256(abi.encodePacked(identifier, amount, nonce, _msgSender()));\n        bool signatureMatch = recoverSigner(message, sig) == signer;\n\n        require(signatureMatch, \"signature mismatch\");\n\n        require(address(this).balance >= amount, \"contract balance is not enough for withdrawal\");\n\n        bool trackerHasBalance = trackerData[identifier].allocation >= amount;\n        require(trackerHasBalance, \"tracker balance is not enough for withdrawal\");\n\n        bool uniqueNonce = (nonce == walletNonce[_msgSender()] + 1);\n        require(uniqueNonce, \"Duplicate nonce\");\n\n        if (signatureMatch && trackerHasBalance && uniqueNonce) {\n            walletNonce[_msgSender()] = walletNonce[_msgSender()] + 1;\n            trackerData[identifier].allocation = trackerData[identifier].allocation.sub(amount);\n            totalWithdrawn = totalWithdrawn.add(_msgValue());\n\n            payable(_msgSender()).transfer(amount);\n\n            emit Withdrawn(_msgSender(), amount);\n        }\n    }\n\n    function setSigner(address newSigner) external onlyOwner {\n        signer = newSigner;\n        emit SignerUpdated(newSigner);\n    }\n    \n    function setDevWallet(address payable newDevWallet) external onlyOwner {\n        _devWalletAddress = newDevWallet;\n        emit DevWalletUpdated(newDevWallet);\n    }\n\n    function setAllowWithdraw(bool allowed) external onlyOwner {\n        withdrawAllowed = allowed;\n        emit WithdrawStatusChanged(allowed);\n    }\n\n    function manualSend() external onlyOwner {\n        uint256 contractEthBalance = address(this).balance;\n        sendEthToWallet(_devWalletAddress, contractEthBalance);\n    }\n\n    function sendEthToWallet(address wallet, uint256 amount) private {\n        require (amount > 0, \"Withdraw must be > 0\");\n        require (address(this).balance >= amount, \"Insufficient balance\");\n\n        payable(wallet).transfer(amount);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = splitSignature(sig);\n        return ecrecover(message, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (uint8, bytes32, bytes32)\n    {\n        require(sig.length == 65);\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n   }\n}"},"Rewards Tracker V2/SafeMath.sol":{"content":"pragma solidity ^0.8.10;\n\n// SPDX-License-Identifier: MIT\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}}