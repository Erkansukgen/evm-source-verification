{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"InstaPowerERC20Resolver.sol":{"content":"pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface TokenInterface {\r\n    function balanceOf(address) external view returns (uint);\r\n}\r\n\r\ncontract Resolver {\r\n    struct TokenBalances {\r\n        uint[] userBalances;\r\n    }\r\n\r\n    function getBalances(address[] memory owners, address[] memory tknAddress) public view returns (TokenBalances[] memory) {\r\n        TokenBalances[] memory tokensBal = new TokenBalances[](tknAddress.length);\r\n        for (uint i = 0; i < tknAddress.length; i++) {\r\n            uint[] memory bals = new uint[](owners.length);\r\n            TokenInterface token = TokenInterface(tknAddress[i]);\r\n            if (tknAddress[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\r\n                for (uint j = 0; j < owners.length; j++) {\r\n                    bals[j] = owners[j].balance;\r\n                }\r\n            } else {\r\n                for (uint j = 0; j < owners.length; j++) {\r\n                    bals[j] = token.balanceOf(owners[j]);\r\n                }\r\n            }\r\n           \r\n            tokensBal[i] = TokenBalances({\r\n                userBalances: bals\r\n            });\r\n        }\r\n        return tokensBal;\r\n    }\r\n}\r\n\r\n\r\ncontract InstaPowerERC20Resolver is Resolver {\r\n    string public constant name = \"ERC20-Power-Resolver-v1\";\r\n}"}}}