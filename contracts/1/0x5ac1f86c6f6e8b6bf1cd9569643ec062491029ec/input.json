{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "localhost/DaoIeo.sol": {
      "content": "pragma solidity ^0.7.3;\npragma experimental ABIEncoderV2;\nimport \"./Ownable.sol\";\nimport './IERC20.sol';\nimport './SafeMath.sol';\nimport \"./SafeERC20.sol\";\n\ninterface IieoCoinContract {\n    function getieoCoinInfoByDao(address coinId) external view returns(address,bool,uint256,uint256,address,bool );\n    function setIeoCoinDao(address coinId,uint256 amount,uint256 uDAONumber) external  returns(bool);\n    function getieoCoinSallInfo(address coinid) external view returns(uint256,uint256);\n    function getCoinType(address coinid) external view returns(bool);\n}\n/*\n *IEODAO提案合约\n*/\ncontract proposalContract is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath  for uint256;\n    IieoCoinContract    public  ieoCoinContract;\n    uint256     public      minUserVotePercent;       \n    uint256     public      percentVote;\n    uint256     public      uVoteWeight;\n\n    uint []     private     magnification = [10,20,40,50,80];\n    uint []     private     magnificationAmount = [10,20,25,40,50];\n    uint256     public      proposalTime;\n    constructor( IieoCoinContract _ieoCoinContract) public {\n        initializeOwner();\n        ieoCoinContract     = _ieoCoinContract;\n        minUserVotePercent  = 10;\n        percentVote         = 20;\n        uVoteWeight         = 1;\n        proposalTime        = 3 days;\n    }\n    struct IEOProposalInfo{\n        uint        uTimestamp;\n        uint256     proposalNO;           \n        address     createAddress;        \n        address     contractAddress;\n        uint        uDaoNumber;\n        uint256     daoCollectAmount;\n        uint256     passVoteNumber;      \n        uint256     unpassVoteNumber;   \n        uint256     daoAmount;\n        uint256     txid;\n        bool        bPass;               \n        bool        bDAOPay;\n        uint256     userVoteNumber;\n    }\n    struct userVoteProposalInfo{\n        uint        uTimestamp;\n        bool        bStatus;\n        uint256     passVoteNumber;          \n        uint256     unpassVoteNumber;        \n    }\n    struct peopleInfo{\n        uint        uTimestamp;\n        uint256     amount;\n        uint256     zoomAmount;                      \n        bool        bPeople;                                \n        uint256     uVoteWeight;                    \n        bool        bVoteEnabled;                   \n        uint        uStakeTime;                      \n        uint        proposalNO;\n    }\n    \n\n    event CreateIeoDAOProposal(address who,uint256 proposalNO,address coinid,uint256 daoCollectAmount,uint256 uDAONumber,uint256 daoAmount,uint256 txid);\n    event Stake(address who,address coinid,uint256 amount,uint uStakeTime);\n    event UnStake(address who,address coinid,uint256 amount,uint256 zoomAmount);\n    event Vote(address who,uint256 proposalNO,uint256 uStatus,uint256 amount,uint256 txid);\n    event SetIeoCoinDao(uint256 prosoalNO,uint256 daoAmount,uint256 uDAONumber);\n    \n    mapping(uint256 => IEOProposalInfo) IEOProposal;\n    mapping(address => mapping(uint256 => userVoteProposalInfo)) public userProposalVoteStatus;    \n    mapping(uint256 => uint256 )               proposalVoteTotal;        \n\n    mapping(address => mapping(address => peopleInfo))  people;\n    mapping(address => uint256) currencyProposal;                        \n    \n    mapping(address=>uint256) coinTotalStake;\n \n    mapping(address =>uint256 [])  proposalNOList;\n    \n    function setieoCoinContract(IieoCoinContract _ieoCoinContract) public onlyOwner returns(bool){\n        require(address(_ieoCoinContract) != address(0));\n        ieoCoinContract = _ieoCoinContract;\n        return true;\n    }\n    function getproposalTime() public view returns(uint){\n        return proposalTime;\n    }\n    function setproposalTime(uint _number) public onlyOwner returns(bool){\n        require(_number >0);\n        proposalTime = _number;\n        return true;\n    }\n    function getcurrencyProposal(address coinid) public view returns(uint256){\n        require(coinid != address(0));\n        return currencyProposal[coinid];\n    }\n    function getpeopleInfo(address who,address coinid) public view returns(peopleInfo memory){\n        require(who != address(0));\n        require(coinid != address(0));\n        return people[who][coinid];\n    }\n    function getproposalVoteTotal(uint256 proposalNO) public view returns(uint256){\n        require(proposalNO > 0);\n        return proposalVoteTotal[proposalNO];\n    }\n \n    function getmagnification(uint index) public view returns(uint){\n        require(index < 5);\n        return magnification[index];\n    }\n    function setmagnification(uint [] memory _magnification ) public onlyOwner returns(bool){\n        for(uint i = 0 ;i< 5;i++){\n            magnification[i] = _magnification[i];\n        }\n        return true;\n    } \n    function getmagnificationAmount(uint index) public view returns(uint){\n        require(index < 5);\n        return magnificationAmount[index];\n    }\n    function setmagnificationAmount(uint [] memory _magnificationAmount ) public onlyOwner returns(bool){\n        for(uint i = 0 ;i< 5;i++){\n            magnificationAmount[i] = _magnificationAmount[i];\n        }\n        return true;\n    }\n    function getTimeMagnification( uint times ) public view returns(uint){\n        uint mag = 10;\n       \n        if( times < 30 days  ){\n            mag = magnification[0];\n        }else if( times >=30 days && times < 90 days ){\n            mag = magnification[1];\n        }else  if( times >= 90 days && times < 180 days ){\n            mag = magnification[2];\n        }else  if( times >= 180 days && times < 360 days ){\n            mag = magnification[3];\n        }else{\n            mag = magnification[4];\n        }\n        return mag;\n    }\n    function getAmountMagnification( uint256 amount ,uint256 decimals ) public view returns(uint){\n        uint mag = 10;\n        uint256 TOKENDECIMALS = 10 ** uint256(decimals);\n        if( amount < 50000 * TOKENDECIMALS  ){\n            mag = magnificationAmount[0];\n        }else if( amount >= 50000 * TOKENDECIMALS && amount <  100000 * TOKENDECIMALS ){\n            mag = magnificationAmount[1];\n        }else  if( amount >= 100000 * TOKENDECIMALS && amount < 500000 * TOKENDECIMALS ){\n            mag = magnificationAmount[2];\n        }else  if( amount >= 500000 * TOKENDECIMALS && amount < 1000000 * TOKENDECIMALS ){\n            mag = magnificationAmount[3];\n        }else{\n            mag = magnificationAmount[4];\n        }\n        return mag;\n    }\n    function getminUserVotePercent() public view returns(uint256){\n        return minUserVotePercent;\n    }\n    function setminUserVotePercent(uint256 _number) public onlyOwner returns(bool){\n        require(_number > 0);\n        minUserVotePercent = _number;\n    }\n    function getpercentVote() public view returns(uint256){\n        return percentVote;\n    } \n    function setpercentVote(uint256 _number) public onlyOwner returns(bool){\n        require(_number>0);\n        percentVote = _number;\n        return true;\n    }\n \n    function getproposalNOListLenth(address coinid) public view returns(uint){\n        return proposalNOList[coinid].length;\n    }\n    function getproposalNOListData(address coinid,uint index) public view returns(uint256){\n        require(index < proposalNOList[coinid].length);\n        return proposalNOList[coinid][index];\n    }\n    function getIEOProposal(uint256 proposalNO) public view returns(IEOProposalInfo memory){\n        require(proposalNO > 0);\n        return IEOProposal[proposalNO];\n    }\n    function getuserProposalVoteStatus(address who ,uint256 prosoalNO) public view returns(userVoteProposalInfo memory){\n        require(who != address(0));\n        require(prosoalNO > 0);\n        return userProposalVoteStatus[who][prosoalNO];\n    }\n    function checkDaoInfo(uint256 proposalNO,address coinid,uint256 daoAmount,uint256 txid) private returns(uint256,uint256){\n        address contractAddress;\n        bool bDAO;\n        uint uDaoNumber;\n        uint256 daoCollectAmount;\n        address  createAddress;\n        bool bExpired;\n        (contractAddress,bDAO,uDaoNumber,daoCollectAmount,createAddress,bExpired) = ieoCoinContract.getieoCoinInfoByDao(coinid);\n        \n        require(bDAO);\n        require(bExpired);\n        require(createAddress == msg.sender );\n        require(daoCollectAmount > 0);\n         \n        IEOProposalInfo memory newIEOProposalInfo = IEOProposalInfo({\n            uTimestamp:             block.timestamp,\n            proposalNO:             proposalNO,\n            createAddress:          createAddress,\n            contractAddress:        contractAddress,\n            uDaoNumber:             uDaoNumber,\n            daoCollectAmount:       daoCollectAmount,\n            passVoteNumber:         0,\n            unpassVoteNumber:       0,\n            daoAmount:              daoAmount,\n            txid:                   txid,\n            bPass:                  false,\n            bDAOPay:                false,\n            userVoteNumber:         0\n\n        });\n        IEOProposal[proposalNO] =  newIEOProposalInfo;\n        \n        return( daoCollectAmount,uDaoNumber);\n\n    }\n    function createIeoDAOProposal(uint256 proposalNO, address coinid,uint256 daoAmount,uint256 txid) public returns(bool){\n        require(coinid != address(0));\n        if( currencyProposal[coinid] == 0 ){\n            currencyProposal[coinid] = proposalNO;\n        }else{\n            require(IEOProposal[currencyProposal[coinid]].uTimestamp + proposalTime <= block.timestamp) ; //过了提案指定时间，才可以发起另外一个提案\n            currencyProposal[coinid] = proposalNO;\n        }\n        uint256 daoCollectAmount;\n        uint uDAONumber;\n        (daoCollectAmount,uDAONumber) = checkDaoInfo(proposalNO,coinid,daoAmount,txid);\n        require( daoAmount <= daoCollectAmount );\n\n        proposalNOList[coinid].push(proposalNO);\n        emit CreateIeoDAOProposal(msg.sender,proposalNO,coinid,daoCollectAmount,uDAONumber, daoAmount,txid);\n        return true;\n    }\n    function checkStatus(uint256 uStatus) private returns(bool){\n        uint ck = 0;\n        if( uStatus == 1 ){\n            ck = ck.add(1);\n        }else if( uStatus == 2 ){\n            ck = ck.add(1);\n        }else{\n            ck = 0;\n        }\n        if( ck >0 ){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    function stake(address coinid,uint256 amount,uint uStakeTime) public returns(bool){\n        require(msg.sender != address(0));\n        require(coinid != address(0));\n        require(amount>0);\n        uint8 decimals = IERC20( coinid ).decimals();      \n        \n        uint old_uStakeTime =  0 ;\n        if( people[msg.sender][coinid].uStakeTime > block.timestamp ){\n            old_uStakeTime = people[msg.sender][coinid].uStakeTime - block.timestamp;\n        }\n        uint256 magTime = getTimeMagnification(uStakeTime.add(old_uStakeTime));    \n        uint256 magNum =  getAmountMagnification(amount.add(people[msg.sender][coinid].amount),decimals);\n       \n        uint256 zoomAmount = amount.mul( magTime.mul(magNum)) ;\n        zoomAmount = zoomAmount.div(100);\n        uint256 voteWeight = uVoteWeight;\n\n        if( people[msg.sender][coinid].proposalNO != currencyProposal[coinid] ){\n            people[msg.sender][coinid].proposalNO = currencyProposal[coinid];\n        }\n        else{\n            if( people[msg.sender][coinid].bPeople ){\n                voteWeight = people[msg.sender][coinid].uVoteWeight;\n            }\n        }\n        peopleInfo  memory newpeopleInfo = peopleInfo({\n            uTimestamp:         block.timestamp,\n            amount:             amount.add(people[msg.sender][coinid].amount),\n            zoomAmount:         zoomAmount.add(people[msg.sender][coinid].zoomAmount),\n            bPeople:            true,\n            uVoteWeight:        voteWeight,\n            bVoteEnabled:       false,\n            uStakeTime:         (uStakeTime.add(block.timestamp)).add(old_uStakeTime),\n            proposalNO:         currencyProposal[coinid]\n        });\n        people[msg.sender][coinid] = newpeopleInfo;\n        \n        people[msg.sender][coinid].bVoteEnabled     = true;\n        people[msg.sender][coinid].uVoteWeight      = voteWeight;\n\n        coinTotalStake[coinid] = amount.add(coinTotalStake[coinid]);\n        IERC20(coinid).safeTransferFrom(msg.sender, address(this), amount); \n\n        emit Stake(msg.sender,coinid,amount,uStakeTime);\n\n        return true;\n    }\n    function unStake(address coinid) public returns(bool){\n        require(msg.sender != address(0));\n        require(people[msg.sender][coinid].bPeople);\n        require(people[msg.sender][coinid].uStakeTime <= block.timestamp);\n        require(coinTotalStake[coinid] >= people[msg.sender][coinid].amount);\n        \n        uint256 amount = people[msg.sender][coinid].amount;\n        uint256 zoomAmount = people[msg.sender][coinid].zoomAmount;\n        people[msg.sender][coinid].amount = 0;\n        people[msg.sender][coinid].zoomAmount = 0;\n        people[msg.sender][coinid].bVoteEnabled = false;\n        people[msg.sender][coinid].uVoteWeight = 0;\n\n        if( coinTotalStake[coinid] >= amount ){\n            coinTotalStake[coinid] = (coinTotalStake[coinid]).sub(amount);\n        }\n        IERC20(coinid).safeTransferFrom(msg.sender, address(this), amount); \n        emit UnStake(msg.sender,coinid,amount,zoomAmount);\n        return true;\n\n    }\n    function vote(uint256 proposalNO,address coinid,uint256 uStatus) public returns(bool){\n        require( proposalNO >0);\n        require( IEOProposal[proposalNO].createAddress != address(0) );\n        require( IEOProposal[proposalNO].uTimestamp + proposalTime >= block.timestamp);  \n        require( checkStatus(uStatus));\n        require( people[msg.sender][coinid].bVoteEnabled);                \n        require( userProposalVoteStatus[msg.sender][proposalNO].bStatus == false );\n        \n        if( people[msg.sender][coinid].proposalNO != currencyProposal[coinid] ){\n            people[msg.sender][coinid].proposalNO = currencyProposal[coinid];\n            people[msg.sender][coinid].uVoteWeight  = uVoteWeight;\n        }\n        require(people[msg.sender][coinid].uVoteWeight > 0 );\n\n        uint256 zoomAmount =people[msg.sender][coinid].zoomAmount;\n\n        userVoteProposalInfo memory newuserVoteProposalInfo = userVoteProposalInfo({\n            uTimestamp:         block.timestamp,\n            bStatus:            true,\n            passVoteNumber:     0,\n            unpassVoteNumber:   0\n        }); \n        userProposalVoteStatus[msg.sender][proposalNO] = newuserVoteProposalInfo;\n       \n        if(uStatus == 2) {\n            IEOProposal[proposalNO].passVoteNumber = zoomAmount.add(IEOProposal[proposalNO].passVoteNumber);\n            userProposalVoteStatus[msg.sender][proposalNO].passVoteNumber = zoomAmount.add(userProposalVoteStatus[msg.sender][proposalNO].passVoteNumber); \n        } \n        else if( uStatus == 1 ){\n            IEOProposal[proposalNO].unpassVoteNumber = zoomAmount.add(IEOProposal[proposalNO].unpassVoteNumber);\n            userProposalVoteStatus[msg.sender][proposalNO].unpassVoteNumber = zoomAmount.add(userProposalVoteStatus[msg.sender][proposalNO].unpassVoteNumber); \n        }\n        IEOProposal[proposalNO].userVoteNumber ++;  \n        proposalVoteTotal[proposalNO] = zoomAmount.add(proposalVoteTotal[proposalNO]);\n        uint256 buyNoice;\n        (buyNoice,) = ieoCoinContract.getieoCoinSallInfo(coinid);\n\n        if( IEOProposal[proposalNO].userVoteNumber >= (buyNoice.mul(minUserVotePercent)).div(100)  ){\n            uint256 voteAmount = (IEOProposal[proposalNO].passVoteNumber).mul(100);\n            if( voteAmount.div( proposalVoteTotal[proposalNO] ) >= percentVote ){\n                IEOProposal[proposalNO].bPass = true;\n            }else{\n                IEOProposal[proposalNO].bPass = false;\n            }\n        }        \n\n        emit Vote(msg.sender,proposalNO,uStatus,zoomAmount,IEOProposal[proposalNO].txid);\n        return true;\n    }\n    function setIeoCoinDao(uint256 proposalNO ) private returns(bool){\n        uint256 uDaoNumber = IEOProposal[proposalNO].uDaoNumber;\n        uint256 daoAmount = IEOProposal[proposalNO].daoAmount;\n        ieoCoinContract.setIeoCoinDao( IEOProposal[proposalNO].contractAddress,daoAmount,uDaoNumber );\n        IEOProposal[proposalNO].bDAOPay = true;\n        emit SetIeoCoinDao(proposalNO,daoAmount,uDaoNumber);\n        return true;\n    }\n    function takeOut(uint256 proposalNO) public returns(bool){\n        require(proposalNO >0);\n        require(msg.sender == IEOProposal[proposalNO].createAddress);\n        require( IEOProposal[proposalNO].uTimestamp + proposalTime <= block.timestamp);   \n        if( IEOProposal[proposalNO].bPass){\n            if(IEOProposal[proposalNO].bDAOPay == false){\n                setIeoCoinDao(proposalNO);\n            }\n        }\n    }\n}"
    },
    "localhost/IERC20.sol": {
      "content": "pragma solidity ^0.7.3;\n\n/**\n * @title Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function totalSupply() external view returns (uint256);\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n}\n"
    },
    "localhost/Ownable.sol": {
      "content": "// SPDX-License-Identifier: No License\n\npragma solidity ^0.7.3;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n * @author crypto-pumpkin@github\n *\n * By initialization, the owner account will be the one that called initializeOwner. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable  {\n    address public _owner;\n\n    event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferCompleted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev COVER: Initializes the contract setting the deployer as the initial owner.\n     */\n    function initializeOwner() public  {\n        require(_owner == address(0));\n        _owner = msg.sender;\n        emit OwnershipTransferCompleted(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferInitiated(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "localhost/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "localhost/SafeMath.sol": {
      "content": "\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.3;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  }
}