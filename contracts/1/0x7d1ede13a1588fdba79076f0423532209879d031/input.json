{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Bridge.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"./handlers/ERC20Handler.sol\";\nimport \"./handlers/ERC721Handler.sol\";\nimport \"./handlers/NativeHandler.sol\";\nimport \"./helpers/HashIndexer.sol\";\nimport \"./helpers/Ownable.sol\";\nimport \"./interfaces/ISigners.sol\";\n\n\ncontract Bridge is NativeHandler, ERC20Handler, ERC721Handler, HashIndexer, Ownable {\n    ISignersRepository public signersRep;\n\n    constructor(address _signersRep){\n        signersRep = ISignersRepository(_signersRep);\n    }\n\n    function checkSignersCopies(address[]memory _signers) private pure returns (bool){\n        if (_signers.length == 1) {\n            return false;\n        }\n\n        for (uint8 i = 0; i < _signers.length - 1; i++) {\n            for (uint8 q = i + 1; q < _signers.length; q++) {\n                if (_signers[i] == _signers[q]) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n    \n    function withdrawERC20(address _token, address _receiver, uint256 _amount) onlyOwner external {\n        _sendERC20(_token,_receiver,_amount);\n    }\n\n    function withdrawERC20(\n        address _token,\n        string memory _txHash,\n        uint256 _amount,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) onlyInexistentHash(_txHash) external  {\n        address[] memory _signers = _deriveERC20Signers(_token, _txHash, _amount, _r, _s, _v);\n\n        require(\n            !checkSignersCopies(_signers),\n            \"Bridge: signatures contain copies\"\n        );\n        require(\n            signersRep.containsSigners(_signers),\n            \"Bridge: bad signatures\"\n        );\n\n        _addHash(_txHash);\n        _sendERC20(_token, msg.sender, _amount);\n    }\n\n    function withdrawNative(\n        string memory _txHash,\n        uint256 _amount,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) onlyInexistentHash(_txHash) external {\n        address[] memory _signers = _deriveNativeSigners(_txHash, _amount, _r, _s, _v);\n\n        require(\n            !checkSignersCopies(_signers),\n            \"Bridge: signatures contain copies\"\n        );\n        require(\n            signersRep.containsSigners(_signers),\n            \"Bridge: bad signatures\"\n        );\n\n        _addHash(_txHash);\n        _sendNative(msg.sender, _amount);\n    }\n\n    function withdrawNative(address _receiver, uint256 _amount) onlyOwner external {\n        _sendNative(_receiver, _amount);\n    }\n\n    function setSignersRep(address _signersRep) external onlyOwner {\n        signersRep = ISignersRepository(_signersRep);\n    }\n\n    function withdrawERC721(\n        address _token,\n        string memory _txHash,\n        uint256 _tokenID,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) onlyInexistentHash(_txHash) external {\n        address[] memory _signers = _deriveERC721Signers(_token, _txHash, _tokenID, _r, _s, _v);\n        require(\n            !checkSignersCopies(_signers),\n            \"Bridge: signatures contain copies\"\n        );\n        require(\n            signersRep.containsSigners(_signers),\n            \"Bridge: bad signatures\"\n        );\n\n        _addHash(_txHash);\n        _sendERC721(_token, msg.sender, _tokenID);\n    }\n\n    function withdrawERC721(address _token, address _receiver, uint256 _amount) onlyOwner external {\n        _sendERC721(_token, _receiver, _amount);\n    }\n}\n"},"contracts/handlers/ERC20Handler.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract ERC20Handler {\n    function _deriveERC20Signers(\n        address _token,\n        string memory _txHash,\n        uint256 _amount,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) internal view returns (address[] memory) {\n        bytes32 _hash = keccak256(abi.encodePacked(block.chainid, _token, msg.sender, _txHash, _amount));\n        address[] memory _signers = new address[](_r.length);\n        for (uint8 i = 0; i < _r.length; i++) {\n            _signers[i] = ecrecover(_hash, _v[i], _r[i], _s[i]);\n        }\n\n        return _signers;\n    }\n\n    function _sendERC20(\n        address _token,\n        address _receiver,\n        uint256 _amount\n    ) internal {\n        require(IERC20(_token).transfer(_receiver, _amount), \"ERC20Handler: token transfer failed\");\n    }\n}\n"},"contracts/handlers/ERC721Handler.sol":{"content":"pragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC721.sol\";\n\nabstract contract ERC721Handler {\n    mapping(string => bool) public hashes;\n\n    function _deriveERC721Signers(\n        address _token,\n        string memory _txHash,\n        uint256 _tokenId,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) internal view returns (address[] memory) {\n        bytes32 _hash = keccak256(abi.encodePacked(block.chainid, _token, msg.sender, _txHash, _tokenId));\n        address[] memory _signers = new address[](_r.length);\n        for (uint8 i = 0; i < _r.length; i++) {\n            _signers[i] = ecrecover(_hash, _v[i], _r[i], _s[i]);\n        }\n\n        return _signers;\n    }\n\n    function _sendERC721(\n        address _token,\n        address _receiver,\n        uint256 _tokenId\n    ) internal {\n        IERC721(_token).transferFrom(address(this), _receiver, _tokenId);\n    }\n}\n\n"},"contracts/handlers/NativeHandler.sol":{"content":"pragma solidity ^0.8.0;\n\n\nabstract contract NativeHandler {\n    event Received(address indexed, uint256);\n\n    function _deriveNativeSigners(\n        string memory _txHash,\n        uint256 _amount,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        uint8[] memory _v\n    ) internal view returns (address[] memory) {\n        bytes32 _hash = keccak256(abi.encodePacked(block.chainid, address(this), msg.sender, _txHash, _amount));\n        address[] memory _signers = new address[](_r.length);\n        for (uint8 i = 0; i < _r.length; i++) {\n            _signers[i] = ecrecover(_hash, _v[i], _r[i], _s[i]);\n        }\n\n        return _signers;\n    }\n\n    receive() payable external {\n        emit Received(msg.sender, msg.value);\n    }\n\n    function _sendNative(\n        address _receiver,\n        uint256 _amount\n    ) internal {\n        payable(_receiver).transfer(_amount);\n    }\n}\n\n"},"contracts/helpers/HashIndexer.sol":{"content":"pragma solidity ^0.8.0;\n\nabstract contract HashIndexer {\n    mapping(string => bool) private hashes;\n\n    event HashAdded(string hash);\n\n    constructor () {}\n\n    modifier onlyInexistentHash(string memory _hash) {\n        require(!hashes[_hash], \"HashIndexer: such hash already exists\");\n        _;\n    }\n\n    function _addHash(string memory _hash) internal {\n        hashes[_hash] = true;\n        emit HashAdded(_hash);\n    }\n\n    function containsHash(string memory _hash) external view returns (bool){\n        return _containsHash(_hash);\n    }\n\n    function _containsHash(string memory _hash) internal view returns (bool){\n        return hashes[_hash];\n    }\n}"},"contracts/helpers/Ownable.sol":{"content":"pragma solidity ^0.8.0;\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n    * @dev Returns the token name.\n    */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"contracts/interfaces/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"},"contracts/interfaces/ISigners.sol":{"content":"pragma solidity ^0.8.0;\n\ninterface ISignersRepository {\n    event SignerAdded(address, address);\n    event SignerRemoved(address, address);\n\n\n    function containsSigner(address) external view virtual returns (bool);\n    function containsSigners(address[] calldata) external view returns (bool);\n    function signersLength() view external returns (uint256);\n    function setupSigner(address) external;\n}\n"}}}