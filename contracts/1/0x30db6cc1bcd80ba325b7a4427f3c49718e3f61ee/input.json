{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Exec.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {\n        IERC20, WETH9,\n        CErc20,CEther,CTokenInterface,IComptroller,\n        IUniswap,\n        ILendingPoolAddressesProvider,ILendingPool,\n        IFlashloanReceiver, ICTokenFlashloan,\n        IUniswapV3,ExactInputSingleParams\n    }  from \"./Interfaces.sol\";\n\nimport { Utils }  from \"./Utils.sol\";\n\n\ncontract  Exec  {\n\n    address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D ;     // UniswapV2Router02\n    address internal constant UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564 ;  // UniswapV3 Swap Router\n    address internal constant SUSHI_ROUTER = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;        // SushiV2Router02\n    address payable internal  WETH_ADDR;\n\n    ILendingPoolAddressesProvider aave_lpa_provider;\n\n    enum Cmd { floan, swap, liquidate, transfer, weth2eth, eth2weth, paytip}\n    enum Flash {simple, start, body, end}        // simple - no flashloan,\n                                                 // start - command invoking flash loan,\n                                                 // body - business logic  flash loan command - > for operate\n                                                 // end - final flash loan command -> to know when to end with business logic and call flashloan\n\n    enum Dex { uniswap,sushi, aave, dydx, compound, creame, uniswap_v3 }\n\n    struct Command {\n        Flash fls;\n        Cmd cmd;\n        Dex dex;\n        address  token1;\n        uint256 amount1;\n        address token2;\n        uint256 amount2;\n        uint24 num;\n        address addr;\n    }\n\n    struct Dex_Addresses {\n        address cethAddress;\n        IComptroller comptroller;\n    }\n\n    mapping(uint8 => Dex_Addresses) dex;\n\n    address payable public owner;\n    event MyLogS(string str);\n\n    modifier onlyOwner() {\n       require(msg.sender == owner,\"Only Owner !\");\n       _;\n    }\n\n    constructor() payable  public {\n       owner = msg.sender;\n       dex[0] = Dex_Addresses(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5,IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B));  // Compound Ether (cETH)\n       dex[1] = Dex_Addresses(0xD06527D5e56A3495252A528C4987003b712860eE,IComptroller(0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258));  // creame Ether(crETH)Creame\n       dex[2] = Dex_Addresses(0xFaCecE87e14B50eafc85C44C01702F5f485CA460,IComptroller(0x3105D328c66d8d55092358cF595d54608178E9B5));  // unFederal ETH (unETH), unFederalReserve \n       dex[3] = Dex_Addresses(0x697b4acAa24430F254224eB794d2a85ba1Fa1FB8,IComptroller(0x4dCf7407AE5C07f8681e1659f626E114A7667339));  // Anchor Ether (anETH), INV Finance  \n    }\n\n    fallback() external {  }\n    receive() external payable { }\n\n\n    function addDex(uint8 id, address _cethAddr,address _comptrollerAddr) public onlyOwner {\n        dex[id] = Dex_Addresses(_cethAddr,IComptroller(_comptrollerAddr));\n    }\n\n    function getDex(uint8 id) public view returns(Dex_Addresses memory){\n        return dex[id];\n    }\n\n    function getBallance() view public returns(uint)  {\n        return(address(this).balance);\n    }\n\n    function getBallanceOf(address _assetAddress) view public returns(uint)  {\n        return(IERC20(_assetAddress).balanceOf(address(this)));\n    }\n\n    function withdraw(address _assetAddress, address payable _recipient) public onlyOwner {\n        uint assetBalance;\n        if (_assetAddress == ETH) {\n            assetBalance = address(this).balance;\n            _recipient.transfer(assetBalance);\n        } else {\n            assetBalance = IERC20(_assetAddress).balanceOf(address(this));\n            IERC20(_assetAddress).transfer(_recipient, assetBalance);\n        }\n    }\n\n    function Eth2Weth(uint _amount) public {\n        require(address(this).balance >= _amount,'INSUFFICIENT_BALANCE_4');\n        WETH9(WETH_ADDR).deposit{value : _amount}();\n    }\n\n    function Weth2Eth(uint _amount) public {\n        require(WETH9(WETH_ADDR).balanceOf(address(this)) >= _amount,'INSUFFICIENT_BALANCE_5');\n        (WETH9(WETH_ADDR)).withdraw(_amount);\n    }\n\n    // AAVE FLASH LOAN\n\n    function getLendingPool() internal view returns (ILendingPool) {\n        return ILendingPool(aave_lpa_provider.getLendingPool());\n    }\n\n    function invokeAave(address _token, uint _amount,  bytes memory _params) internal {\n\n        ILendingPool lendingPool = getLendingPool();\n\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        uint256[] memory modes = new uint256[](1);\n\n        assets[0] = _token;\n        amounts[0] = _amount;\n        modes[0] = 0;\n\n        lendingPool.flashLoan(\n            address(this),  // receiverAddress\n            assets,\n            amounts,\n            modes,\n            address(this),  // onBehalfOf\n            _params,\n            0               //referralCode\n        );\n\n    }\n\n    function executeOperation(\n        address[] calldata _assets,\n        uint256[] calldata _amounts,\n        uint256[] calldata _premiums,\n        address _initiator,\n        bytes calldata _params\n    )\n        external\n        returns (bool)\n    {\n        ILendingPool lendingPool = getLendingPool();\n\n        uint amount=_amounts[0];\n        uint len = bytes(_params).length/320;\n        for (uint i = 0; i < len; i++) {\n             amount = execute(amount,abi.decode(Utils.slice(_params,i*320,320),(Command)));\n        }\n\n        uint amountOwing = _amounts[0] + _premiums[0]; // no safe math\n        require(IERC20(_assets[0]).balanceOf(address(this))>=amountOwing,'INSUFFICIENT_BALANCE_0');\n        require(IERC20(_assets[0]).approve(address(lendingPool), amountOwing),'APPROVE_ERR');\n        return true;\n    }\n\n    // CREAME\n    function doFlashloan(address _cToken, uint256 _amount, bytes memory _params) internal {\n        ICTokenFlashloan(_cToken).flashLoan(address(this), _amount, _params);\n    }\n\n    function executeOperation(address _sender, address _underlying, uint _amount, uint _fee, bytes calldata _params) external {\n\n        address cToken = msg.sender;\n        uint currentBalance = IERC20(_underlying).balanceOf(address(this));\n        require(currentBalance >= _amount, \"INSUFFICIENT_BALANCE_6\");\n\n        uint amount = _amount;\n        uint len = bytes(_params).length/320;\n        for (uint i = 0; i < len; i++) {\n             amount = execute(amount,abi.decode(Utils.slice(_params,i*320,320),(Command)));\n        }\n\n        require(IERC20(_underlying).transfer(cToken, _amount + _fee), \"TRANSFER_FAILED_1\");\n    }\n\n    //UNISWAP & SUSHISWAP\n    function swapTokens(address _router, address _token1, address _token2, uint _amount, uint _amountOutMin ,uint _deadline)\n        internal returns(uint[] memory amounts) {\n\n        IUniswap router = IUniswap(_router);\n        address[] memory path = new address[](2);\n        path[0] = _token1;\n        path[1] = _token2;\n\n        //if (_token1 == WETH_ADDR) {\n        if (_token1 == ETH) {\n            path[0] = WETH_ADDR;\n            require(address(this).balance >= _amount,'INSUFFICIENT_ETH_BALANCE');\n            return router.swapExactETHForTokens{value:_amount}(_amountOutMin,path,address(this),_deadline);\n        }\n\n        IERC20 token = IERC20(_token1);\n        require(token.balanceOf(address(this)) >= _amount,'INSUFFICIENT_BALANCE_1');\n        require(token.approve(address(router),_amount),'APPROVE_ERR');\n\n        //if (_token2 == WETH_ADDR) {\n        if (_token2 == ETH) {\n            path[1] = WETH_ADDR;\n            return router.swapExactTokensForETH(_amount,_amountOutMin,path,address(this),_deadline);\n        }\n\n        return router.swapExactTokensForTokens(_amount,_amountOutMin,path,address(this),_deadline);\n    }\n\n    function swapTokens_v3(address _router, address _token1, address _token2, uint24 _fee, uint _amount, uint _amountOutMin ,uint _deadline)\n            internal returns(uint amountOut) {\n            ExactInputSingleParams memory params;\n\n            IUniswapV3 router = IUniswapV3(_router);\n            params.tokenIn = _token1;\n            params.tokenOut = _token2;\n            params.fee = _fee;\n            params.recipient = address(this);\n            params.amountIn = _amount;\n            params.amountOutMinimum = _amountOutMin;\n            params.deadline = _deadline;\n            params.sqrtPriceLimitX96 = 0;\n\n            IERC20 token = IERC20(_token1);\n            require(token.balanceOf(address(this)) >= _amount,'INSUFFICIENT_BALANCE_1');\n            require(token.approve(address(router),_amount),'APPROVE_ERR');\n\n            return router.exactInputSingle(params);\n        }\n\n\n    // COMPOUND & CREME\n\n    function liquidate(address _borrower, address _cTokenAddress, address _collateralTokenAddress , uint _amount, Dex_Addresses memory _dex)\n        internal  returns(uint) {\n        uint amount;\n        IERC20 underlying;\n        CTokenInterface collateralToken;\n\n        (uint error, uint liquidity, uint shortfall) = _dex.comptroller.getAccountLiquidity(_borrower);\n        require(error == 0, \"COMPTROLLER_ERR\");\n        require(shortfall > 0 && liquidity == 0, \"NO_SHORTFALL\");\n\n        if (_cTokenAddress == _dex.cethAddress) {\n            require(address(this).balance >= _amount,\"INSUFFICIENT_BALANCE_2\");\n            collateralToken = CTokenInterface(_collateralTokenAddress);\n            CEther(payable(_dex.cethAddress)).liquidateBorrow{value:_amount}(_borrower,collateralToken);\n\n        } else {\n            CErc20 cToken = CErc20(_cTokenAddress);\n            underlying = IERC20(cToken.underlying());\n            collateralToken = CTokenInterface(_collateralTokenAddress);\n            require(underlying.balanceOf(address(this)) >= _amount,\"INSUFFICIENT_BALANCE_3\");\n            require(underlying.approve(_cTokenAddress,_amount),\"APPROVE_ERR\");\n            require(cToken.liquidateBorrow(_borrower,_amount,collateralToken)==0,\"LIQUIDATION_ERR\");\n        }\n\n        if (address(_collateralTokenAddress) == _dex.cethAddress) {\n            amount = address(this).balance;\n            CEther(payable(_dex.cethAddress)).redeem(collateralToken.balanceOf(address(this)));\n        } else {\n            underlying = IERC20(CErc20(_collateralTokenAddress).underlying());\n            amount = underlying.balanceOf(address(this));\n            (CErc20(_collateralTokenAddress)).redeem(collateralToken.balanceOf(address(this)));\n        }\n\n        if (address(_collateralTokenAddress) == _dex.cethAddress) {\n            amount = address(this).balance-amount;\n        } else {\n            underlying = IERC20(CErc20(_collateralTokenAddress).underlying());\n            amount = underlying.balanceOf(address(this))-amount;\n        }\n        return amount;\n    }\n\n    function getUnderlying(address _cTokenAddress) internal view returns(address) {\n        CErc20 cToken = CErc20(_cTokenAddress);\n        return cToken.underlying();\n    }\n\n    // BUSINESS LOGIC IMPLEMENTATION { swap, liquidate }\n    function execute(uint _amount, Command memory _command ) internal returns(uint) {\n        uint[] memory amount;\n        uint  amt = _amount;\n\n       // S W A P\n        if (_command.cmd == Cmd.swap) {\n\n            if (_command.amount1 > 0) { amt = _command.amount1;}\n\n            // uniswap\n            if (_command.dex == Dex.uniswap) {\n                amount = swapTokens(UNISWAP_ROUTER,\n                                   _command.token1,\n                                   _command.token2,\n                                   amt,\n                                   _command.amount2,\n                                   block.timestamp + 15);\n                require(amount[1] > 0,\"ERROR IN UNISWAP\");\n                return amount[1];\n            }\n\n            // uniswap_v3\n            if (_command.dex == Dex.uniswap_v3) {\n                   amt = swapTokens_v3(UNISWAP_V3_ROUTER,\n                                      _command.token1,\n                                      _command.token2,\n                                      _command.num,\n                                      amt,\n                                      _command.amount2,\n                                      block.timestamp + 15);\n                   require(amt > 0,\"ERROR IN UNISWAP\");\n                   return amt;\n            }\n\n\n            //sushi\n            if (_command.dex == Dex.sushi) {\n                    amount = swapTokens(SUSHI_ROUTER,\n                                _command.token1,\n                                _command.token2,\n                                amt,\n                                _command.amount2,\n                                block.timestamp + 15);\n                    require(amount[1] > 0,\"ERROR IN SUSHI\");\n                    return amount[1];\n            }\n\n            revert(\"SWAP_NOT_IMPLEMENTED\");\n        }\n\n        // L I Q U I D A T I O N\n        if (_command.cmd == Cmd.liquidate) {\n    \n            Dex_Addresses memory _dex = getDex(uint8(_command.num));\n\n            return  liquidate(_command.addr,\n                              _command.token1,\n                              _command.token2,\n                              _command.amount1,\n                              _dex\n                              );\n        }\n\n        // T R A N S F E R\n        if (_command.cmd == Cmd.transfer) {\n            IERC20 token =  IERC20(_command.token1);\n            require(token.balanceOf(address(this))>_command.amount1,\"INSUFFICIENT_BALANCE\");\n            require(token.transfer(_command.addr,_command.amount1),\"TRANSFER FAILED\");\n        }\n\n        // PAYTIP\n       if (_command.cmd == Cmd.paytip) {\n           uint256 _ethBalance = address(this).balance;\n           require(_ethBalance >= _command.amount1,\"INSUFFICIENT_BALANCE\");\n           block.coinbase.transfer(_command.amount1);\n       }\n\n        // WETH to ETH conversion\n        if (_command.cmd == Cmd.weth2eth) {\n           if (_command.amount1 > 0) { amt = _command.amount1;}\n           Weth2Eth(amt);\n           return amt;\n        }\n\n        // ETH to WETH conversion\n        if (_command.cmd == Cmd.eth2weth) {\n           if (_command.amount1 > 0) { amt = _command.amount1;}\n           Eth2Weth(amt);\n           return amt;\n        }\n\n        // O T H E R  C O M M A N D\n        revert(\"NOT_IMPLEMENTED\");\n    }\n\n    // MAIN FUNCTION\n    function run(Command[] memory _commands ) public onlyOwner {\n        bytes memory params;\n        address token;\n        uint amount;\n        Dex flDex;\n\n        for (uint i = 0; i < _commands.length; i++) {\n\n            // SIMPLE COMMANDS\n            if (_commands[i].fls == Flash.simple) {\n                amount = execute(amount,_commands[i]);\n                continue;\n            }\n\n            // FLASHLOAN FIRST COMMAND\n            if (_commands[i].fls == Flash.start) {\n                    token = address(_commands[i].token1);\n                    amount = _commands[i].amount1;\n                    flDex = _commands[i].dex;\n                    continue;\n            }\n\n            // FLASHLOAN COMMANDS\n            if (_commands[i].fls == Flash.body) {\n                    params = Utils.concat(params,toBytes(_commands[i]));\n                    continue;\n            }\n\n            // FLASHLOAN LAST COMMAND & INVOKE\n            if (_commands[i].fls == Flash.end) {\n                    params = Utils.concat(params,toBytes(_commands[i]));\n\n                    if (flDex == Dex.aave) {\n                        invokeAave(token, amount, params);\n                        continue;\n                    }\n                    if (flDex == Dex.creame) {\n                        doFlashloan(token, amount, params);\n                        continue;\n                    }\n                    revert(\"NOT_IMPLEMENTED\");\n            }\n        }\n    }\n\n\n    function toBytes(Command memory _command) internal pure returns (bytes memory) {\n        return abi.encode(\n                          _command.fls,\n                          _command.cmd,\n                          _command.dex,\n                          _command.token1,\n                          _command.amount1,\n                          _command.token2,\n                          _command.amount2,\n                          _command.num,\n                          _command.addr);\n   }\n\n}\n"
    },
    "ExecMainnet.sol": {
      "content": "pragma solidity ^0.7.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./Exec.sol\";\r\n\r\ncontract ExecMainnet is Exec {\r\n    \r\n    constructor() public {\r\n        \r\n\t\tWETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;      // IERC20 address for Ether\r\n        \r\n\t\taave_lpa_provider  = ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5); \r\n\t\t\r\n    }\r\n}"
    },
    "Interfaces.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.2;\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface WETH9 {\n        receive() external payable ;\n        function balanceOf(address) external view returns (uint);\n        function allowance(address, address) external view returns (uint);\n        function deposit() external payable ;\n        function withdraw(uint wad) external ;\n        function approve(address guy, uint wad) external returns (bool) ;\n        function transfer(address dst, uint wad) external returns (bool) ;\n        function transferFrom(address src, address dst, uint wad) external returns (bool);\n}\n\n// ***************   UNISWAP & SUSHISWAP ***************************\ninterface IUniswap {\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)  external payable returns (uint[] memory amounts);\n    function swapExactTokensForTokens(uint amountIn,uint amountOutMin,address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n}\n\nstruct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n}\n\ninterface IUniswapV3 {\n  function exactInputSingle(ExactInputSingleParams memory params) external returns (uint256 amountOut);\n}\n\n// ***************   COMPOUND ************************************\ninterface IComptroller {\n    function getAccountLiquidity(address account) external returns (uint, uint, uint);\n}\n\ninterface CTokenInterface {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface CEther {\n    function liquidateBorrow(address borrower, CTokenInterface cTokenCollateral) external payable;\n    function redeem(uint redeemTokens) external returns (uint);\n}\n\ninterface CErc20 {\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);\n    function underlying() external view returns(address);\n    function redeem(uint redeemTokens) external returns (uint);\n}\n\n// ***************   AVEE ********************************************\ninterface ILendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n}\n\ninterface ILendingPool {\n      function flashLoan(address receiverAddress,address[] calldata assets,uint256[] calldata amounts,\n                        uint256[] calldata modes,address onBehalfOf,bytes calldata params,uint16 referralCode) external;\n}\n\n// ***************   CREAME FINANCE ********************************************\n\ninterface IFlashloanReceiver {\n    function executeOperation(address sender, address underlying, uint amount, uint fee, bytes calldata params) external;\n}\n\ninterface ICTokenFlashloan {\n    function flashLoan(address receiver, uint amount, bytes calldata params) external;\n}\n"
    },
    "Utils.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\n\npragma solidity ^0.7.6;\npragma experimental ABIEncoderV2;\n\n\nlibrary Utils {\n    \n    function concat(bytes memory _preBytes, bytes memory _postBytes )  internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            \n            tempBytes := mload(0x40)\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n            let mc := add(tempBytes, 0x20)\n            let end := add(mc, length)\n\n            for {\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n            mc := end\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) \n            ))\n        }\n\n        return tempBytes;\n    }\n    \n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                tempBytes := mload(0x40)\n                let lengthmod := and(_length, 31)\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            default {\n                tempBytes := mload(0x40)\n                mstore(tempBytes, 0)\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n    \n}"
    }
  }
}