{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Arb.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\nlibrary SafeMath\n{\n    function add(uint x, uint y) internal pure returns (uint z)\n    {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z)\n    {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z)\n    {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z)\n    {\n        z = x < y ? x : y;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    //    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\nlibrary EcoERC20\n{\n    function balanceOf(address token, address owner) internal view returns (uint)\n    {\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, owner));\n        require(success && data.length >= 32, 'BO');\n        return abi.decode(data, (uint));\n    }\n\n    function safeApprove(address token, address to, uint256 value) internal\n    {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    function transfer(address token, address to, uint value) internal\n    {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TR');\n    }\n\n    function try_transfer(address token, address to, uint value) internal returns (bool)\n    {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n}\n\ninterface IUniswapV2Pair\n{\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\nlibrary EcoUniv2Pair\n{\n    function token0(address pair) internal view returns (address)\n    {\n        (bool success, bytes memory data) = pair.staticcall(abi.encodeWithSelector(IUniswapV2Pair.token0.selector));\n        require(success, 'T0');\n        return abi.decode(data, (address));\n    }\n\n    function token1(address pair) internal view returns (address)\n    {\n        (bool success, bytes memory data) = pair.staticcall(abi.encodeWithSelector(IUniswapV2Pair.token1.selector));\n        require(success, 'T1');\n        return abi.decode(data, (address));\n    }\n\n    function getReserves(address pair) internal view returns (uint112, uint112, uint32)\n    {\n        (bool success, bytes memory data) = pair.staticcall(abi.encodeWithSelector(IUniswapV2Pair.getReserves.selector));\n        require(success, 'RS');\n        return abi.decode(data, (uint112, uint112, uint32));\n    }\n\n    function swap(address pair, uint amount0Out, uint amount1Out, address to) internal\n    {\n        (bool success,) = pair.call(abi.encodeWithSelector(IUniswapV2Pair.swap.selector, amount0Out, amount1Out, to, \"\"));\n\n        if (!success)\n        {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function withdraw(uint) external;\n}\n\nlibrary EcoWETH\n{\n    function deposit(address token, uint targetAmount) internal\n    {\n        (bool success, bytes memory data) = token.call{value : targetAmount}(abi.encodeWithSelector(IWETH.deposit.selector));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'DR');\n    }\n\n    function transfer(address token, address to, uint value) internal\n    {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IWETH.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TR');\n    }\n\n    function try_transfer(address token, address to, uint value) internal returns (bool)\n    {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IWETH.transfer.selector, to, value));\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n\n    function withdraw(address token, uint value) internal\n    {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IWETH.withdraw.selector, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'WR');\n    }\n}\n\n\ninterface PoolInterface {\n    function getBalance(address token) external view returns (uint);\n\n    //    function getDenormalizedWeight(address token) external view returns (uint);\n\n    function swapExactAmountIn(address, uint, address, uint, uint) external returns (uint, uint);\n\n    //    function swapExactAmountOut(address, uint, address, uint, uint) external returns (uint, uint);\n    //\n    //    function calcOutGivenIn(uint tokenBalanceIn, uint tokenWeightIn, uint tokenBalanceOut, uint tokenWeightOut, uint tokenAmountIn, uint swapFee) external pure returns (uint tokenAmountOut);\n    //\n    //    function getSwapFee() external view returns (uint);\n}\n\nlibrary EcoPoolInterface\n{\n    function swapExactAmountIn(address pool, address tokenIn, uint tokenAmountIn, address tokenOut, uint minAmountOut, uint maxPrice) internal returns (uint, uint)\n    {\n        (bool success, bytes memory data) = pool.call(abi.encodeWithSelector(PoolInterface.swapExactAmountIn.selector, tokenIn, tokenAmountIn, tokenOut, minAmountOut, maxPrice));\n\n        if (!success)\n        {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n\n        return abi.decode(data, (uint, uint));\n    }\n}\n\ninterface IContractRegistry {\n    function addressOf(\n        bytes32 contractName\n    ) external returns (address);\n}\n\nlibrary EcoContractRegistry\n{\n    function addressOf(address token, bytes32 contractName) internal returns (address)\n    {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IContractRegistry.addressOf.selector, contractName));\n        require(success, 'AO');\n        return abi.decode(data, (address));\n    }\n}\n\ninterface IBancorNetwork {\n    function conversionPath(\n        IERC20 _sourceToken,\n        IERC20 _targetToken\n    ) external view returns (address[] memory);\n\n    function convertByPath(\n        address[] memory _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _beneficiary,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) external payable returns (uint256);\n}\n\nlibrary EcoBancorNetwork\n{\n    function conversionPath(address bancorNetwork, IERC20 _sourceToken, IERC20 _targetToken) internal view returns (address[] memory)\n    {\n        (bool success, bytes memory data) = bancorNetwork.staticcall(abi.encodeWithSelector(IBancorNetwork.conversionPath.selector, _sourceToken, _targetToken));\n        require(success, 'CP');\n        return abi.decode(data, (address[]));\n    }\n\n    function convertByPath(\n        address bancorNetwork,\n        uint msgValue,\n        address[] memory _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _beneficiary,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) internal returns (uint256)\n    {\n        (bool success, bytes memory data) = bancorNetwork.call{value : msgValue}(abi.encodeWithSelector\n            (IBancorNetwork.convertByPath.selector,\n                _path,\n                _amount,\n                _minReturn,\n                _beneficiary,\n                _affiliateAccount,\n                _affiliateFee\n            )\n        );\n\n        if (!success)\n        {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n\n        return abi.decode(data, (uint256));\n    }\n}\n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n}\n\n\nlibrary EcoSwapRouter\n{\n    //    function exactInputSingle(\n    //        address router,\n    //        ISwapRouter.ExactInputSingleParams calldata params\n    //    ) internal returns (uint256)\n    //    {\n    //        (bool success, bytes memory data) = router.call(abi.encodeWithSelector\n    //            (ISwapRouter.exactInputSingle.selector, params)\n    //        );\n    //\n    //        if (!success)\n    //        {\n    //            assembly {\n    //                let ptr := mload(0x40)\n    //                let size := returndatasize()\n    //                returndatacopy(ptr, 0, size)\n    //                revert(ptr, size)\n    //            }\n    //        }\n    //\n    //        return abi.decode(data, (uint256));\n    //    }\n\n    function exactInputSingle(\n        address router,\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        address recipient,\n        uint256 deadline,\n        uint256 amountIn,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96\n    ) internal returns (uint256)\n    {\n        (bool success, bytes memory data) = router.call(abi.encodeWithSelector\n            (ISwapRouter.exactInputSingle.selector, ISwapRouter.ExactInputSingleParams({\n            tokenIn : tokenIn,\n            tokenOut : tokenOut,\n            fee : fee,\n            //recipient : address(this),\n            recipient : recipient,\n            deadline : deadline,\n            amountIn : amountIn,\n            amountOutMinimum : amountOutMinimum,\n            sqrtPriceLimitX96 : sqrtPriceLimitX96\n            })\n            )\n        );\n\n        if (!success)\n        {\n            assembly {\n                let ptr := mload(0x40)\n                let size := returndatasize()\n                returndatacopy(ptr, 0, size)\n                revert(ptr, size)\n            }\n        }\n\n        return abi.decode(data, (uint256));\n    }\n\n}\n\n\ncontract BalancerUniswapArbitrage {\n    using SafeMath for uint;\n    uint private constant WETH_MIN = 1e15; //l 10^15 0.001WETH\n    uint private constant MINER_BRIBE_DEFAULT = 2e15; //l 2*10^15 0.02WETH\n    uint private constant BRIBE_PERCENT_100 = 1e3;//l 100% 10^3\n    uint private constant DEFL_PERCENT_100 = 1e6;//l 100% 10^6\n    bytes4 private constant ERC20_TRANSFER_SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ISwapRouter private  constant UNIV3_ROUTER = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    //    IContractRegistry contractRegistry = IContractRegistry(0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4);\n    address private constant contractRegistry = 0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4;\n    bytes32 private constant BANCOR_NETWORK_NAME = 0x42616E636F724E6574776F726B00000000000000000000000000000000000000; //l \"BancorNetwork\"\n\n    address public owner;\n    //    mapping(address => bool) public allow_list;\n    //    uint256 public gaspack = 0;\n\n    modifier onlyOwner\n    {\n        require(msg.sender == owner, \"OOW\");\n        _;\n    }\n\n    modifier onlyWorker\n    {\n        //      require(allow_list[msg.sender], \"OWR\");\n        require(is_buy_worker(msg.sender), \"OWR\");\n        _;\n    }\n\n\n    constructor() public\n    {\n        owner = msg.sender;\n        //      allow_list[owner] = true;\n    }\n\n    receive() external payable\n    {\n\n    }\n\n            function is_buy_worker(address addr) private pure returns (bool result)\n            {\n                    assembly\n                    { switch lt(addr, 0x7F35A62D646CF7224E1FA5B9139B6A5743F601D7)\n                    case true { switch lt(addr, 0x4E3B8D047F5946CD817FEE5E8DCF5EC006F78871)\n                case true { switch lt(addr, 0x4C6306A0C56F5B5454CF4D63E94BC8AEB01F8EF5)\n                case true { switch lt(addr, 0x4760FF1872511C627D4D9272898C64B693D46996)\n                case true { switch lt(addr, 0x3D5F42D72CDF3217E960EBB0710EF41DEF9CCED0)\n                case true { result := eq(addr, 0x3D198FBC1B1A2CDDA640F9D49A8CBDB05B2DA447) }\n                default { result := eq(addr, 0x3D5F42D72CDF3217E960EBB0710EF41DEF9CCED0) }}\n                default { result := eq(addr, 0x4760FF1872511C627D4D9272898C64B693D46996) }}\n                default { switch lt(addr, 0x4DC11A8418EB5A73902E4D3F69C375610BD09679)\n                case true { result := eq(addr, 0x4C6306A0C56F5B5454CF4D63E94BC8AEB01F8EF5) }\n                default { result := eq(addr, 0x4DC11A8418EB5A73902E4D3F69C375610BD09679) }}}\n                default { switch lt(addr, 0x551724E554D3C58861A969ABCAEE60BEEA8C732D)\n                case true { switch lt(addr, 0x5066573C3D718502A7BCBC3B82D7F7FDAD082813)\n                case true { switch lt(addr, 0x505D3FB1D8E603444F8A303D0B7FC081D917CACE)\n                case true { result := eq(addr, 0x4E3B8D047F5946CD817FEE5E8DCF5EC006F78871) }\n                default { result := eq(addr, 0x505D3FB1D8E603444F8A303D0B7FC081D917CACE) }}\n                default { result := eq(addr, 0x5066573C3D718502A7BCBC3B82D7F7FDAD082813) }}\n                default { switch lt(addr, 0x67A1196268EC42EA93BE8825BF35711F79F332B2)\n                case true { result := eq(addr, 0x551724E554D3C58861A969ABCAEE60BEEA8C732D) }\n                default { result := eq(addr, 0x67A1196268EC42EA93BE8825BF35711F79F332B2) }}}}\n                default { switch lt(addr, 0xD4F65A64CE6B384D5F92829620FE239A2A6358AE)\n                case true { switch lt(addr, 0xB8961DCBA7ED9B86A7839FB747EA69A522575190)\n                case true { switch lt(addr, 0x94D6E6FE6D03643635B1AF2C37AA2FF3A57C95B4)\n                case true { switch lt(addr, 0x8CAA1F5E10CF89F5AC66F038D0174E4D724590FE)\n                case true { result := eq(addr, 0x7F35A62D646CF7224E1FA5B9139B6A5743F601D7) }\n                default { result := eq(addr, 0x8CAA1F5E10CF89F5AC66F038D0174E4D724590FE) }}\n                default { result := eq(addr, 0x94D6E6FE6D03643635B1AF2C37AA2FF3A57C95B4) }}\n                default { switch lt(addr, 0xBEC0C3AC1ED8A73CA0605864E23E1AA7A7E89BE2)\n                case true { result := eq(addr, 0xB8961DCBA7ED9B86A7839FB747EA69A522575190) }\n                default { result := eq(addr, 0xBEC0C3AC1ED8A73CA0605864E23E1AA7A7E89BE2) }}}\n                default { switch lt(addr, 0xFD608FCF30B772741DA11FC7C3160E703DB749EE)\n                case true { switch lt(addr, 0xEFDA6BC62BB0811525DC17C10FADC6D410A3235E)\n                case true { switch lt(addr, 0xD65C094F322ACD51B60830A5BA2A400DC53AFCA1)\n                case true { result := eq(addr, 0xD4F65A64CE6B384D5F92829620FE239A2A6358AE) }\n                default { result := eq(addr, 0xD65C094F322ACD51B60830A5BA2A400DC53AFCA1) }}\n                default { result := eq(addr, 0xEFDA6BC62BB0811525DC17C10FADC6D410A3235E) }}\n                default { switch lt(addr, 0xFD6196DE3D7F00258A5330B02127BE273F38FFBC)\n                case true { result := eq(addr, 0xFD608FCF30B772741DA11FC7C3160E703DB749EE) }\n                default { result := eq(addr, 0xFD6196DE3D7F00258A5330B02127BE273F38FFBC) }}}}}\n           }\n\n    function set_owner_x666x(address new_owner) public onlyOwner\n    {\n        owner = new_owner;\n        //        allow_list[owner] = true;\n    }\n\n    //    function allow_addresses(address[] memory array) public onlyOwner\n    //    {\n    //        for (uint256 i = 0; i < array.length; i++) allow_list[array[i]] = true;\n    //    }\n\n    //    function cancel_addresses(address[] memory array) public onlyOwner\n    //    {\n    //        for (uint256 i = 0; i < array.length; i++) delete allow_list[array[i]];\n    //    }\n\n    function do_direct_call(uint256 _value, address _target, bytes memory _data) public payable onlyWorker returns (bytes memory response)\n    {\n        (bool success, bytes memory ret) = _target.call{value : _value}(_data);\n        require(success);\n        response = ret;\n    }\n\n    function pickup_eth_76550374(address payable receiver, uint256 value) public onlyOwner\n    {\n        receiver.transfer(value);\n    }\n\n    function pickup_tok_18796546(address receiver, address token, uint256 value) public onlyOwner\n    {\n        _safeTransfer(token, receiver, value);\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20_TRANSFER_SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\n    }\n\n    function charge_addresses(uint256 limit, address[] memory array) public payable onlyOwner\n    {\n        uint256 avail = msg.value;\n\n        for (uint256 i = 0; i < array.length; i++)\n        {\n            if (avail == 0) break;\n\n            address payable worker = payable(array[i]);\n            if (worker.balance < limit)\n            {\n                uint256 need = limit - worker.balance;\n                if (need > avail) need = avail;\n\n                worker.transfer(need);\n\n                avail -= need;\n            }\n        }\n\n        if (avail > 0) msg.sender.transfer(avail);\n    }\n\n    function charge_addresses_weth(uint256 limit, address[] memory array) public payable onlyOwner\n    {\n        uint256 need = 0;\n        for (uint256 i = 0; i < array.length; i++)\n        {\n            if (array[i].balance < limit) need += limit - array[i].balance;\n        }\n\n        uint256 avail = IERC20(WETH).balanceOf(address(this));\n        //        uint256 avail = EcoERC20.balanceOf(WETH, address(this));\n        require(avail >= need, \"low weth balance\");\n\n        IWETH(WETH).withdraw(need);\n\n        for (uint256 i = 0; i < array.length; i++)\n        {\n            address payable worker = payable(array[i]);\n            if (worker.balance < limit) worker.transfer(limit - worker.balance);\n        }\n    }\n\n    //l mix sushi uniswap balancer bancor swap\n    //l path[] - swaps path\n    //l 0 - Sushi/Uniswap, 1 - Balancer, 2 - BANCOR\n    function mixSwapV3_0(uint weiAmount, address[] memory path, uint[] memory swapSequence, uint24[] memory v3Fees) private {\n        uint index = 0;\n        uint v3FeesIndex = 0;\n        uint targetAmount = weiAmount;\n        for (uint i = 0; i < swapSequence.length; i++) {\n            if (swapSequence[i] == 0) {//l uni/sushi\n                address pair = path[index++];\n                //l path[0], index==1\n                address[2] memory tokens = [path[index], path[index + 1]];\n                //l [path[1],path[2]]\n                index += 2;\n                //l index==3\n                //l подряд идущие uni/sushi перекидываем targetAmount на след пару\n                address beneficiary = (i < swapSequence.length - 1) && swapSequence[i + 1] == 0 ? path[index] : address(this);\n                //l i==0, swapSequence[1]==0, path[3]\n                //l если это первый своп или предыдущи не UNI/SUSHI и не BANCOR и не UNISWAP_V3 (они сразу на пару загоняют, если рядом в цепочке)\n                bool needTransferToken0 = i == 0 || (i > 0 && swapSequence[i - 1] != 0 && swapSequence[i - 1] != 2 && swapSequence[i - 1] != 3);\n\n                (uint112 reserve1, uint112 reserve2) = getReserves(IUniswapV2Pair(pair), tokens[0]);\n                targetAmount = swapPair([pair, beneficiary], [reserve1, reserve2], [tokens[0], tokens[1]], targetAmount, needTransferToken0);\n            } else if (swapSequence[i] == 1) {//l Balancer\n                address pair = path[index++];\n                //l path[0], index==1\n                address token0 = path[index++];\n                //l path[1], index==2\n\n                //                  IERC20(token0).approve(address(pair), targetAmount);\n                EcoERC20.safeApprove(token0, pair, targetAmount);\n\n                //                (targetAmount,) = PoolInterface(pair).swapExactAmountIn(\n                //                    address(token0), //l tokenIn\n                //                    targetAmount, //l tokenAmountIn\n                //                    address(path[index++]), //l tokenOut, path[2], index==3\n                //                    uint(1), //l minAmountOut\n                //                    type(uint).max //l maxPrice, set to max -> accept any swap prices\n                //                );\n\n                (targetAmount,) = EcoPoolInterface.swapExactAmountIn(\n                    pair, //l pool\n                    address(token0), //l tokenIn\n                    targetAmount, //l tokenAmountIn\n                    address(path[index++]), //l tokenOut, path[2], index==3\n                    uint(1), //l minAmountOut\n                    type(uint).max //l maxPrice, set to max -> accept any swap prices\n                );\n            } else if (swapSequence[i] == 2) {//l BANCOR\n                //l достаём каждый раз адрес контракта BancorNetwork, т.к. он может меняться\n                //IBancorNetwork bancorNetwork = IBancorNetwork(contractRegistry.addressOf(BANCOR_NETWORK_NAME));\n                address bancorNetwork = EcoContractRegistry.addressOf(contractRegistry, BANCOR_NETWORK_NAME);\n\n                address tokenSource = path[index++];\n                //l path[0], index==1\n                address tokenTarget = path[index++];\n                //l path[1], index==2\n\n                //address[] memory swapPath = bancorNetwork.conversionPath(IERC20(tokenSource), IERC20(tokenTarget));\n                address[] memory swapPath = EcoBancorNetwork.conversionPath(bancorNetwork, IERC20(tokenSource), IERC20(tokenTarget));\n\n                //uint minReturn = bancorNetwork.rateByPath(path,_amount);\n\n                uint msgValue = 0;\n                if (tokenSource == ETH_RESERVE_ADDRESS) {\n                    //                    IWETH(WETH).withdraw(targetAmount);\n                    EcoWETH.withdraw(WETH, targetAmount);\n\n                    msgValue = targetAmount;\n                } else {\n                    //l только если это не первый обмен с ефиром (ефир через msgValue отдаём),\n                    //l мы должны заапрувить (разрешить контракту bancorNetwork-а снять с нас amount токена tokenSource) сумму передаваемого на обмен токена\n                    //                        IERC20(tokenSource).approve(address(bancorNetwork), targetAmount);\n                    EcoERC20.safeApprove(tokenSource, address(bancorNetwork), targetAmount);\n                }\n\n                //l @param _beneficiary account that will receive the conversion result or 0x0 to send the result to the sender account\n                //l если след UNI/SUSHI, то в качестве получателя назначаем пару, иначе address(0), тогда результат вернётся sender-у (контракту)\n                address beneficiary = (i < swapSequence.length - 1) && swapSequence[i + 1] == 0 ? path[index] : address(0);\n\n                //l path[2], index=2\n\n                //targetAmount = bancorNetwork.convertByPath.value(msgValue)(\n                //l convertByPath(address[],uint256,uint256,address,address,uint256)\n                //                targetAmount = bancorNetwork.convertByPath{value : msgValue}(\n                //                    swapPath,\n                //                    targetAmount,\n                //                    uint(1), //l minReturn,\n                //                    beneficiary, //l _beneficiary\n                //                    address(0), //l _affiliateAccount\n                //                    0//l _affiliateFee\n                //                );\n\n\n                targetAmount = EcoBancorNetwork.convertByPath(\n                    bancorNetwork,\n                    msgValue,\n                    swapPath,\n                    targetAmount,\n                    uint(1), //l minReturn,\n                    beneficiary, //l _beneficiary\n                    address(0), //l _affiliateAccount\n                    0//l _affiliateFee\n                );\n\n                //if (tokenTarget == ETH_RESERVE_ADDRESS) IWETH(WETH).deposit.value(targetAmount)();\n                //                if (tokenTarget == ETH_RESERVE_ADDRESS) IWETH(WETH).deposit{value : targetAmount}();\n                if (tokenTarget == ETH_RESERVE_ADDRESS) EcoWETH.deposit(WETH, targetAmount);\n            } else if (swapSequence[i] == 3) {//l UNISWAP_V3\n                address tokenIn = path[index++];\n                address tokenOut = path[index++];\n                address recipient = i < swapSequence.length - 1 && swapSequence[i + 1] == 0 ? path[index] : address(this);\n\n                // IERC20(tokenIn).approve(address(UNIV3_ROUTER), targetAmount);\n                EcoERC20.safeApprove(tokenIn, address(UNIV3_ROUTER), targetAmount);\n\n\n                //                targetAmount = UNIV3_ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams({\n                //                tokenIn : tokenIn,\n                //                tokenOut : tokenOut,\n                //                fee : v3Fees[v3FeesIndex++],\n                //                //recipient : address(this),\n                //                recipient : recipient,\n                //                deadline : block.timestamp + 1 hours,\n                //                amountIn : targetAmount,\n                //                amountOutMinimum : 0,\n                //                sqrtPriceLimitX96 : 0\n                //                })\n                //                );\n\n                //                targetAmount = EcoSwapRouter.exactInputSingle(address(UNIV3_ROUTER), ISwapRouter.ExactInputSingleParams({\n                //                tokenIn : tokenIn,\n                //                tokenOut : tokenOut,\n                //                fee : v3Fees[v3FeesIndex++],\n                //                //recipient : address(this),\n                //                recipient : recipient,\n                //                deadline : block.timestamp + 1 hours,\n                //                amountIn : targetAmount,\n                //                amountOutMinimum : 0,\n                //                sqrtPriceLimitX96 : 0\n                //                })\n                //                );\n\n                targetAmount = EcoSwapRouter.exactInputSingle(address(UNIV3_ROUTER),\n                    tokenIn,\n                    tokenOut,\n                    v3Fees[v3FeesIndex++],\n                    recipient,\n                    block.timestamp + 1 hours,\n                    targetAmount,\n                    0,\n                    0\n                );\n            }\n        }\n    }\n\n    function mixSwapV6(uint weiAmount, uint bribe, uint gasUsed, address[] memory path, uint[] memory swapSequence, uint24[] memory v3Fees) external onlyWorker {\n        mixSwapV6_(weiAmount, bribe, gasUsed, path, swapSequence, v3Fees);\n    }\n\n    function mixSwapV6_(uint weiAmount, uint bribe, uint gasUsed, address[] memory path, uint[] memory swapSequence, uint24[] memory v3Fees) private {\n        //      uint ethBalance = IERC20(WETH).balanceOf(address(this));\n        uint ethBalance = EcoERC20.balanceOf(WETH, address(this));\n\n        if (weiAmount <= ethBalance) {\n            mixSwapV3_0(weiAmount, path, swapSequence, v3Fees);\n\n            //uint wethAfter = IERC20(WETH).balanceOf(address(this));\n            uint wethAfter = EcoERC20.balanceOf(WETH, address(this));\n\n            require(wethAfter > ethBalance, \"NP\");\n\n            uint fee = tx.gasprice * gasUsed;\n\n            require(wethAfter - ethBalance > fee, \"NPF\");\n\n            uint pnl = wethAfter - ethBalance - fee;\n\n            //l перевод награды майнеру\n            uint minerBribe = bribe * pnl / BRIBE_PERCENT_100;\n\n            if (minerBribe > 0) {\n                //              IWETH(WETH).withdraw(minerBribe);\n                EcoWETH.withdraw(WETH, minerBribe);\n                address payable coinbaseAddr = payable(block.coinbase);\n                coinbaseAddr.transfer(minerBribe);\n            }\n        }\n    }\n\n    //l token0->token1\n    function swapPair(address[2] memory pairs, uint112[2] memory reserves, address[2] memory tokens, uint amount, bool isFirstSwap) private returns (uint) {\n        if (isFirstSwap) _safeTransfer(tokens[0], pairs[0], amount);\n\n        uint e0 = calcUniswapSwapTokens(amount, reserves[0], reserves[1]);\n\n        //uint e0_before = IERC20(tokens[1]).balanceOf(pairs[1]);\n        uint e0_before = EcoERC20.balanceOf(tokens[1], pairs[1]);\n\n        //        if (IUniswapV2Pair(pairs[0]).token0() == tokens[0]) IUniswapV2Pair(pairs[0]).swap(0, e0, pairs[1], \"\");\n        //        else IUniswapV2Pair(pairs[0]).swap(e0, 0, pairs[1], \"\");\n\n        if (EcoUniv2Pair.token0(pairs[0]) == tokens[0]) EcoUniv2Pair.swap(pairs[0], 0, e0, pairs[1]);\n        else EcoUniv2Pair.swap(pairs[0], e0, 0, pairs[1]);\n\n        //uint e0_after = IERC20(tokens[1]).balanceOf(pairs[1]);\n        uint e0_after = EcoERC20.balanceOf(tokens[1], pairs[1]);\n        uint amount_res = e0_after - e0_before;\n\n        //return amount_res > 0 ? amount_res - 1 : amount_res;\n        return amount_res;\n    }\n\n    function getReserves(IUniswapV2Pair pair, address token0) private view returns (uint112 r1, uint112 r2) {\n        //        (uint112 reserve1, uint112 reserve2,) = IUniswapV2Pair(pair).getReserves();\n        (uint112 reserve1, uint112 reserve2,) = EcoUniv2Pair.getReserves(address(pair));\n\n        //        if (pair.token0() != token0) (reserve1, reserve2) = (reserve2, reserve1);\n        if (EcoUniv2Pair.token0(address(pair)) != token0) (reserve1, reserve2) = (reserve2, reserve1);\n        return (reserve1, reserve2);\n    }\n\n    //l r1*amount*997/(r0*1000 + amount*997)\n    function calcUniswapSwapTokens(uint amount, uint reserve0, uint reserve1) private pure returns (uint)\n    {\n        uint eth_with_fee = amount.mul(997);\n        uint numerator = eth_with_fee.mul(reserve1);\n        uint denominator = reserve0.mul(1000).add(eth_with_fee);\n        return numerator / denominator;\n    }\n\n    function getBalance(address pool, address token) external view returns (uint blockNumber, uint balance){\n        return (block.number, PoolInterface(pool).getBalance(token));\n    }\n}"
    }
  }
}