{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/StakingRewardsEscrow.sol": {
      "content": "/// StakingRewardsEscrow.sol\n\n// Copyright (C) 2021 Reflexer Labs, INC\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.7;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\nabstract contract TokenLike {\n    function balanceOf(address) virtual public view returns (uint256);\n    function transfer(address, uint256) virtual external returns (bool);\n}\n\ncontract StakingRewardsEscrow is ReentrancyGuard {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"StakingRewardsEscrow/account-not-authorized\");\n        _;\n    }\n\n    // --- Structs ---\n    struct EscrowSlot {\n        uint256 total;\n        uint256 startDate;\n        uint256 duration;\n        uint256 claimedUntil;\n        uint256 amountClaimed;\n    }\n\n    // --- Variables ---\n    // The address allowed to request escrows\n    address   public escrowRequestor;\n    // The time during which a chunk is escrowed\n    uint256   public escrowDuration;\n    // Time in a slot during which rewards to escrow can be added without creating a new escrow slot\n    uint256   public durationToStartEscrow;\n    // Current amount of slots to claim in one shot\n    uint256   public slotsToClaim;\n    // The token to escrow\n    TokenLike public token;\n\n    uint256   public constant MAX_ESCROW_DURATION          = 365 days;\n    uint256   public constant MAX_DURATION_TO_START_ESCROW = 30 days;\n    uint256   public constant MAX_SLOTS_TO_CLAIM           = 25;\n\n    // Oldest slot from which to start claiming unlocked rewards\n    mapping (address => uint256)                        public oldestEscrowSlot;\n    // Next slot to fill for every user\n    mapping (address => uint256)                        public currentEscrowSlot;\n    // All escrows for all accounts\n    mapping (address => mapping(uint256 => EscrowSlot)) public escrows;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 indexed parameter, uint256 data);\n    event ModifyParameters(bytes32 indexed parameter, address data);\n    event EscrowRewards(address indexed who, uint256 amount, uint256 currentEscrowSlot);\n    event ClaimRewards(address indexed who, uint256 amount);\n\n    constructor(\n      address escrowRequestor_,\n      address token_,\n      uint256 escrowDuration_,\n      uint256 durationToStartEscrow_\n    ) public {\n      require(escrowRequestor_ != address(0), \"StakingRewardsEscrow/null-requestor\");\n      require(token_ != address(0), \"StakingRewardsEscrow/null-token\");\n      require(both(escrowDuration_ > 0, escrowDuration_ <= MAX_ESCROW_DURATION), \"StakingRewardsEscrow/invalid-escrow-duration\");\n      require(both(durationToStartEscrow_ > 0, durationToStartEscrow_ < escrowDuration_), \"StakingRewardsEscrow/invalid-duration-start-escrow\");\n      require(escrowDuration_ > durationToStartEscrow_, \"StakingRewardsEscrow/\");\n\n      authorizedAccounts[msg.sender] = 1;\n\n      escrowRequestor        = escrowRequestor_;\n      token                  = TokenLike(token_);\n      escrowDuration         = escrowDuration_;\n      durationToStartEscrow  = durationToStartEscrow_;\n      slotsToClaim           = MAX_SLOTS_TO_CLAIM;\n\n      emit AddAuthorization(msg.sender);\n    }\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Math ---\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"StakingRewardsEscrow/add-overflow\");\n    }\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"StakingRewardsEscrow/sub-underflow\");\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"StakingRewardsEscrow/mul-overflow\");\n    }\n    function minimum(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Modify an uint256 parameter\n    * @param parameter The name of the parameter to modify\n    * @param data New value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"escrowDuration\") {\n          require(both(data > 0, data <= MAX_ESCROW_DURATION), \"StakingRewardsEscrow/invalid-escrow-duration\");\n          require(data > durationToStartEscrow, \"StakingRewardsEscrow/smaller-than-start-escrow-duration\");\n          escrowDuration = data;\n        }\n        else if (parameter == \"durationToStartEscrow\") {\n          require(both(data > 1, data <= MAX_DURATION_TO_START_ESCROW), \"StakingRewardsEscrow/duration-to-start-escrow\");\n          require(data < escrowDuration, \"StakingRewardsEscrow/not-lower-than-escrow-duration\");\n          durationToStartEscrow = data;\n        }\n        else if (parameter == \"slotsToClaim\") {\n          require(both(data >= 1, data <= MAX_SLOTS_TO_CLAIM), \"StakingRewardsEscrow/invalid-slots-to-claim\");\n          slotsToClaim = data;\n        }\n        else revert(\"StakingRewardsEscrow/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /*\n    * @notify Modify an address parameter\n    * @param parameter The name of the parameter to modify\n    * @param data New value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"StakingRewardsEscrow/null-data\");\n\n        if (parameter == \"escrowRequestor\") {\n            escrowRequestor = data;\n        }\n        else revert(\"StakingRewardsEscrow/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notice Put more rewards under escrow for a specific address\n    * @param who The address that will get escrowed tokens\n    * @param amount Amount of tokens to escrow\n    */\n    function escrowRewards(address who, uint256 amount) external nonReentrant {\n        require(escrowRequestor == msg.sender, \"StakingRewardsEscrow/not-requestor\");\n        require(who != address(0), \"StakingRewardsEscrow/null-who\");\n        require(amount > 0, \"StakingRewardsEscrow/null-amount\");\n\n        if (\n          either(currentEscrowSlot[who] == 0,\n          now > addition(escrows[who][currentEscrowSlot[who] - 1].startDate, durationToStartEscrow))\n        ) {\n          escrows[who][currentEscrowSlot[who]] = EscrowSlot(amount, now, escrowDuration, now, 0);\n          currentEscrowSlot[who] = addition(currentEscrowSlot[who], 1);\n        } else {\n          escrows[who][currentEscrowSlot[who] - 1].total = addition(escrows[who][currentEscrowSlot[who] - 1].total, amount);\n        }\n\n        emit EscrowRewards(who, amount, currentEscrowSlot[who] - 1);\n    }\n    /**\n    * @notice Return the total amount of tokens that are being escrowed for a specific account\n    * @param who The address for which we calculate the amount of tokens that are still waiting to be unlocked\n    */\n    function getTokensBeingEscrowed(address who) public view returns (uint256) {\n        if (oldestEscrowSlot[who] >= currentEscrowSlot[who]) return 0;\n\n        EscrowSlot memory escrowReward;\n\n        uint256 totalEscrowed;\n        uint256 endDate;\n\n        for (uint i = oldestEscrowSlot[who]; i <= currentEscrowSlot[who]; i++) {\n            escrowReward = escrows[who][i];\n            endDate      = addition(escrowReward.startDate, escrowReward.duration);\n\n            if (escrowReward.amountClaimed >= escrowReward.total) {\n              continue;\n            }\n\n            if (both(escrowReward.claimedUntil < endDate, now >= endDate)) {\n              continue;\n            }\n\n            totalEscrowed = addition(totalEscrowed, subtract(escrowReward.total, escrowReward.amountClaimed));\n        }\n\n        return totalEscrowed;\n    }\n    /*\n    * @notice Return the total amount of tokens that can be claimed right now for an address\n    * @param who The address to claim on behalf of\n    */\n    function getClaimableTokens(address who) public view returns (uint256) {\n        if (currentEscrowSlot[who] == 0) return 0;\n        if (oldestEscrowSlot[who] >= currentEscrowSlot[who]) return 0;\n\n        uint256 lastSlotToClaim = (subtract(currentEscrowSlot[who], oldestEscrowSlot[who]) > slotsToClaim) ?\n          addition(oldestEscrowSlot[who], subtract(slotsToClaim, 1)) : subtract(currentEscrowSlot[who], 1);\n\n        EscrowSlot memory escrowReward;\n\n        uint256 totalToTransfer;\n        uint256 endDate;\n        uint256 reward;\n\n        for (uint i = oldestEscrowSlot[who]; i <= lastSlotToClaim; i++) {\n            escrowReward = escrows[who][i];\n            endDate      = addition(escrowReward.startDate, escrowReward.duration);\n\n            if (escrowReward.amountClaimed >= escrowReward.total) {\n              continue;\n            }\n\n            if (both(escrowReward.claimedUntil < endDate, now >= endDate)) {\n              totalToTransfer = addition(totalToTransfer, subtract(escrowReward.total, escrowReward.amountClaimed));\n              continue;\n            }\n\n            if (escrowReward.claimedUntil == now) continue;\n\n            reward = subtract(escrowReward.total, escrowReward.amountClaimed) / subtract(endDate, escrowReward.claimedUntil);\n            reward = multiply(reward, subtract(now, escrowReward.claimedUntil));\n            if (addition(escrowReward.amountClaimed, reward) > escrowReward.total) {\n              reward = subtract(escrowReward.total, escrowReward.amountClaimed);\n            }\n\n            totalToTransfer = addition(totalToTransfer, reward);\n        }\n\n        return totalToTransfer;\n    }\n    /*\n    * @notice Claim vested tokens\n    * @param who The address to claim on behalf of\n    */\n    function claimTokens(address who) public nonReentrant {\n        require(currentEscrowSlot[who] > 0, \"StakingRewardsEscrow/invalid-address\");\n        require(oldestEscrowSlot[who] < currentEscrowSlot[who], \"StakingRewardsEscrow/no-slot-to-claim\");\n\n        uint256 lastSlotToClaim = (subtract(currentEscrowSlot[who], oldestEscrowSlot[who]) > slotsToClaim) ?\n          addition(oldestEscrowSlot[who], subtract(slotsToClaim, 1)) : subtract(currentEscrowSlot[who], 1);\n\n        EscrowSlot storage escrowReward;\n\n        uint256 totalToTransfer;\n        uint256 endDate;\n        uint256 reward;\n\n        for (uint i = oldestEscrowSlot[who]; i <= lastSlotToClaim; i++) {\n            escrowReward = escrows[who][i];\n            endDate      = addition(escrowReward.startDate, escrowReward.duration);\n\n            if (escrowReward.amountClaimed >= escrowReward.total) {\n              oldestEscrowSlot[who] = addition(oldestEscrowSlot[who], 1);\n              continue;\n            }\n\n            if (both(escrowReward.claimedUntil < endDate, now >= endDate)) {\n              totalToTransfer            = addition(totalToTransfer, subtract(escrowReward.total, escrowReward.amountClaimed));\n              escrowReward.amountClaimed = escrowReward.total;\n              escrowReward.claimedUntil  = now;\n              oldestEscrowSlot[who]      = addition(oldestEscrowSlot[who], 1);\n              continue;\n            }\n\n            if (escrowReward.claimedUntil == now) continue;\n\n            reward = subtract(escrowReward.total, escrowReward.amountClaimed) / subtract(endDate, escrowReward.claimedUntil);\n            reward = multiply(reward, subtract(now, escrowReward.claimedUntil));\n            if (addition(escrowReward.amountClaimed, reward) > escrowReward.total) {\n              reward = subtract(escrowReward.total, escrowReward.amountClaimed);\n            }\n\n            totalToTransfer            = addition(totalToTransfer, reward);\n            escrowReward.amountClaimed = addition(escrowReward.amountClaimed, reward);\n            escrowReward.claimedUntil  = now;\n        }\n\n        if (totalToTransfer > 0) {\n            require(token.transfer(who, totalToTransfer), \"StakingRewardsEscrow/cannot-transfer-rewards\");\n        }\n\n        emit ClaimRewards(who, totalToTransfer);\n    }\n}"
    }
  }
}