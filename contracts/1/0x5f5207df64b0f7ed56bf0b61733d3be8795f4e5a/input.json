{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Settlement.sol": {
      "content": "pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface ERC20 {\n    function decimals() external view returns (uint);\n    function balanceOf(address _owner) external view returns (uint256);\n}\n\ninterface IWeth is ERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\ninterface IConversionRates {\n    function recordImbalance(ERC20 token,int buyAmount,uint256 rateUpdateBlock,uint256 currentBlock) external;\n    function getRate(ERC20 token, uint256 currentBlockNumber, bool buy, uint256 qty) external view returns(uint256);\n    function getListedTokens() external view returns(ERC20[] memory);\n    function getQuota(ERC20 token, bool isBuy) external view returns (int quota);\n}\n\ninterface ISanityRates {\n    function getSanityRate(ERC20 src, ERC20 dest) external view returns (uint256);\n}\n\ncontract Utils {\n\n    ERC20 internal constant ETH_TOKEN_ADDRESS = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n    uint  constant internal PRECISION = (10**18);\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n    uint  constant internal MAX_DECIMALS = 18;\n    uint  constant internal ETH_DECIMALS = 18;\n    uint  constant internal MAX_BPS  = 100 * 100;\n    mapping(ERC20=>uint) public decimals;\n\n    function setDecimals(ERC20 token) internal {\n        decimals[token] = token.decimals();\n    }\n\n    function getDecimals(ERC20 token) internal view returns(uint) {\n        uint tokenDecimals = decimals[token];\n        // technically, there might be token with decimals 0\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        if(tokenDecimals == 0) return token.decimals();\n\n        return tokenDecimals;\n    }\n\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(srcQty <= MAX_QTY);\n        require(rate <= MAX_RATE);\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n    \n}\n\ncontract PermissionGroups{\n    \n    address public admin;\n    address public pendingAdmin;\n    mapping(address=>bool) public operatorAllowed;\n    address[] internal operatorsGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n    \n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"onlyAdmin\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operatorAllowed[msg.sender],\"onlyOperator\");\n        _;\n    }\n    \n    function transferAdmin(address newAdmin) external onlyAdmin {\n        pendingAdmin = newAdmin;\n    }\n\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender,\"pendingAdmin != msg.sender\");\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    function addOperator(address newOperator) external onlyAdmin {\n        require(!operatorAllowed[newOperator],\"duplicated newOperator\"); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE,\"operatorsGroup.length >= MAX_GROUP_SIZE.\");\n\n        operatorAllowed[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) external onlyAdmin {\n        require(operatorAllowed[operator],\"operator is not in the operatorsGroup.\");\n        operatorAllowed[operator] = false;\n\n        for (uint i = 0; i < operatorsGroup.length; i++) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.pop();\n                break;\n            }\n        }\n    }\n    \n    function getOperators() external view returns(address[] memory) {\n        return operatorsGroup;\n    }\n\n}\n\n\ncontract AssetManager is PermissionGroups{\n    \n    receive() external payable{}\n    fallback() external payable{}\n    \n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'Settlement TransferHelper: ETH_TRANSFER_FAILED');\n    }\n    \n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success,\"ERC20(token).transfer failed.\");\n        if(data.length > 0) {\n            require(abi.decode(data,(bool)),\"ERC20(_token).transfer return data is false.\");\n        }\n    }\n    \n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success,\"ERC20(token).transferFrom failed.\");\n        if(data.length > 0) {\n            require(abi.decode(data,(bool)),\"ERC20(_token).transferFrom return data is false.\");\n        }    \n    }\n    \n    function withdrawEth(address payable _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        safeTransferETH(_to,_value);\n    }\n    \n    function withdrawToken(address token, address to, uint value) external onlyAdmin{\n        require(to != address(0),\"to == address(0)\");\n        safeTransfer(token,to,value);\n    }\n    \n}\n\ncontract RatesCenter is AssetManager, Utils {\n    \n    IConversionRates public myConversionRates;\n    ISanityRates public sanityRatesContract;\n    IWeth constant public wethAddress = IWeth(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    \n    function setMyConversionRates(IConversionRates _myConversionRates) external onlyAdmin {\n        myConversionRates = _myConversionRates;\n    }\n    \n    function setSanityRate(ISanityRates _newSanity) external onlyAdmin {\n        sanityRatesContract = _newSanity;\n    }\n    \n    function batchSetDecimals(ERC20[] memory tokens) public onlyOperator {\n        for (uint i=0; i<tokens.length; i++) {\n            ERC20 token = tokens[i];\n            setDecimals(token);\n        }\n    }\n\n    function getConversionAmount(ERC20 srcToken, ERC20 destToken, uint256 srcAmount, uint256 blockNumber) public view returns (uint destAmount) {\n        if (srcAmount == 0) return 0;\n        // if (srcToken == destToken) return 0;\n        \n        uint rate;\n        if(srcToken == wethAddress) {\n            rate = getRate(destToken,blockNumber,true,srcAmount);\n            if (rate == 0) return 0;\n            if (sanityRatesContract != ISanityRates(0)) {\n                if (rate > sanityRatesContract.getSanityRate(ETH_TOKEN_ADDRESS, destToken)) return 0;\n            }\n            destAmount = calcDstQty(srcAmount,ETH_DECIMALS, getDecimals(destToken), rate);\n        }\n        else if(destToken == wethAddress) {\n            rate = getRate(srcToken,blockNumber,false,srcAmount);\n            if (rate == 0) return 0;\n            if (sanityRatesContract != ISanityRates(0)) {\n                if (rate > sanityRatesContract.getSanityRate(srcToken, ETH_TOKEN_ADDRESS)) return 0;\n            }\n            destAmount = calcDstQty(srcAmount,getDecimals(srcToken), ETH_DECIMALS, rate);\n        }\n        else {\n            uint srcSellRate = getRate(srcToken,blockNumber,false,srcAmount);\n            if (srcSellRate == 0) return 0;\n            if (sanityRatesContract != ISanityRates(0)) {\n                uint256 sellSanityRate = sanityRatesContract.getSanityRate(srcToken, ETH_TOKEN_ADDRESS);\n                if (srcSellRate > sellSanityRate) return 0;\n            }\n            \n            uint srcDecimal = getDecimals(srcToken);\n            uint ethAmount = calcDstQty(srcAmount,srcDecimal, ETH_DECIMALS, srcSellRate);\n            \n            uint destBuyRate = getRate(destToken,blockNumber,true,ethAmount);\n            if (destBuyRate == 0) return 0;\n            if (sanityRatesContract != ISanityRates(0)) {\n                uint256 buySanityRate = sanityRatesContract.getSanityRate(ETH_TOKEN_ADDRESS, destToken);\n                if (destBuyRate > buySanityRate) return 0;\n            }\n\n            uint destDecimal = getDecimals(destToken);\n            destAmount = calcDstQty(ethAmount, ETH_DECIMALS, destDecimal, destBuyRate);\n        }\n        \n    }\n \n    function getRate(ERC20 token, uint blockNumber, bool isBuy, uint srcQty) private view returns (uint){\n        try myConversionRates.getRate(token, blockNumber, isBuy, srcQty) returns(uint256 r) {\n            return r;\n        } catch {\n            return 0;\n        }\n    }\n\n    function getListedTokens() public view returns (ERC20[] memory) {\n        return myConversionRates.getListedTokens();\n    }\n    \n    function getQuota(ERC20 tradeToken, bool isDestToken) public view returns (uint) {\n        int ratesQuota = myConversionRates.getQuota(tradeToken,isDestToken);\n        if(ratesQuota <= 0){\n            return 0;\n        }\n        return uint(ratesQuota); \n    }\n    \n}\n\ncontract Settlement is RatesCenter {\n    \n    string constant public VERSION = \"Settlement v2.0.1\";\n    \n    bool public tradeEnabled = false;\n    address public assetAddress;\n    \n    mapping(address=>bool) public counterpartyAllowed;\n    address[] internal counterpartyGroup;\n    mapping(address=>uint) public platformFeeBpsMap;\n    \n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'Settlement preventReentrant: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n    \n    modifier onlyCounterparty() {\n        require(counterpartyAllowed[msg.sender],\"onlyCounterparty\");\n        _;\n    }\n    \n    function addCounterparty(address newCounterparty, uint platformFeeBps) external onlyOperator {\n        require(!counterpartyAllowed[newCounterparty],\"duplicated counterparty\"); // prevent duplicates.\n        counterpartyAllowed[newCounterparty] = true;\n        counterpartyGroup.push(newCounterparty);\n        \n        _setPlatformFeeBpsMap(newCounterparty,platformFeeBps);\n    }\n\n    function removeCounterparty (address counterparty) external onlyOperator {\n        require(counterpartyAllowed[counterparty],\"counterparty is not in the counterpartyGroup.\");\n        counterpartyAllowed[counterparty] = false;\n\n        for (uint i = 0; i < counterpartyGroup.length; i++) {\n            if (counterpartyGroup[i] == counterparty) {\n                counterpartyGroup[i] = counterpartyGroup[counterpartyGroup.length - 1];\n                counterpartyGroup.pop();\n                break;\n            }\n        }\n        \n        _setPlatformFeeBpsMap(counterparty,0);\n    }\n    \n    function getCounterpartyGroup() external view returns(address[] memory) {\n        return counterpartyGroup;\n    }\n    \n    function setPlatformFeeBpsMap(address[] calldata platformAddressList, uint[] calldata platformFeeBpsList) external onlyOperator {\n        require(platformAddressList.length == platformFeeBpsList.length, \"platformAddressList.length != platformFeeBpsList.length \");\n        for(uint i=0; i<platformAddressList.length; i++) {\n            _setPlatformFeeBpsMap(platformAddressList[i],platformFeeBpsList[i]);\n        }\n    }\n    \n    function _setPlatformFeeBpsMap(address platformAddress, uint platformFeeBps) internal {\n        require(platformFeeBps >= 0 && platformFeeBps < MAX_BPS, \"platformFeeBps should be between 0 and MAX_BPS\");\n        \n        platformFeeBpsMap[platformAddress] = platformFeeBps;\n    }\n    \n    function enableTrade() external onlyAdmin {\n        tradeEnabled = true;\n    }\n    \n    function disableTrade() external onlyOperator {\n        tradeEnabled = false;\n    }\n    \n    function setAssetAddress(address newAssetAddress) external onlyAdmin{\n        assetAddress = newAssetAddress;\n    }\n    \n    function quoteWithFee(ERC20 srcToken, ERC20 destToken, uint256 srcAmount, uint256 blockNumber, uint256 tradeFeeBps) public view returns (uint destAmount) {\n        if(!tradeEnabled) return 0;\n\n        destAmount = getConversionAmount(srcToken, destToken, srcAmount, blockNumber);\n        \n        if (tradeFeeBps > 0) {\n            require(tradeFeeBps < MAX_BPS, \"tradeFeeBps >= MAX_BPS\");\n            destAmount = (destAmount * (MAX_BPS - tradeFeeBps)) / MAX_BPS;\n        }\n        \n        uint balance = destToken.balanceOf(assetAddress);\n        if (balance < destAmount) {\n            return balance;\n        }\n        return destAmount;\n\n    }\n\n    function getDestAmount(ERC20 srcToken, ERC20 destToken, uint256 srcAmount, address platformAddress) public view returns (uint destAmount) {\n        uint tradeFeeBps = platformFeeBpsMap[platformAddress];\n        destAmount = quoteWithFee(srcToken, destToken, srcAmount, block.number, tradeFeeBps);\n    }  \n    \n    function quote(ERC20 srcToken, ERC20 destToken, uint256 srcAmount, uint256 blockNumber) public view returns (uint destAmount) {\n        destAmount = quoteWithFee(srcToken, destToken,  srcAmount, blockNumber, 0);\n    } \n    \n    event TradeExecute(address indexed origin, ERC20 indexed src, uint256 srcAmount, ERC20 indexed destToken, uint256 destAmount, address destAddress);\n    \n    function swapTokenForETHWithTrust(ERC20 srcToken, uint srcAmount, uint destAmountMin, address to) external returns (uint) {\n        uint destAmount = _swapTokens(srcToken, wethAddress, msg.sender, srcAmount, destAmountMin, address(this), msg.sender);\n        wethAddress.withdraw(destAmount);\n        safeTransferETH(to,destAmount);\n        return destAmount;\n    }\n    \n    function swapTokensWithTrust(ERC20 srcToken, ERC20 destToken, uint srcAmount, uint destAmountMin, address to) external returns (uint) {\n        return _swapTokens(srcToken, destToken, msg.sender, srcAmount, destAmountMin, to, msg.sender);\n    }\n    \n    function swapWithTrustAndPlatform(ERC20 srcToken, ERC20 destToken, uint srcAmount, uint destAmountMin, address to, address platformAddress) external returns (uint) {\n        return _swapTokens(srcToken, destToken, msg.sender, srcAmount, destAmountMin, to, platformAddress);\n    }\n    \n    function swapETHForToken(ERC20 destToken, uint destAmountMin, address to) payable external returns (uint) {\n        uint srcAmount = msg.value;\n        wethAddress.deposit{value:srcAmount}();\n        return _swapTokens(wethAddress, destToken,address(this), srcAmount, destAmountMin, to, msg.sender);\n    }\n    \n    function swapTokenForETH(ERC20 srcToken, uint srcAmount, uint destAmountMin, address to) external returns (uint) {\n        require(srcAmount <= srcToken.balanceOf(address(this)) , \"not enough token trasfered in\");\n        uint destAmount = _swapTokens(srcToken, wethAddress, address(this), srcAmount, destAmountMin, address(this), msg.sender);\n        wethAddress.withdraw(destAmount);\n        safeTransferETH(to,destAmount);\n        return destAmount;\n    }\n    \n    function swapTokens(ERC20 srcToken, ERC20 destToken, uint srcAmount, uint destAmountMin, address to) external returns (uint) {\n        require(srcAmount <= srcToken.balanceOf(address(this)) , \"not enough token trasfered in\");\n        return _swapTokens(srcToken, destToken, address(this), srcAmount, destAmountMin, to, msg.sender);\n    }\n    \n    function swapWithPlatform(ERC20 srcToken, ERC20 destToken, uint srcAmount, uint destAmountMin, address to, address platformAddress) external returns (uint) {\n        require(srcAmount <= srcToken.balanceOf(address(this)) , \"not enough token trasfered in\");\n        return _swapTokens(srcToken, destToken, address(this), srcAmount, destAmountMin, to, platformAddress);\n    }\n    \n    function _swapTokens(ERC20 srcToken, ERC20 destToken, address srcAddress, uint srcAmount, uint destAmountMin, address to, address platformAddress) \n        internal lock onlyCounterparty returns (uint) {\n        \n        uint destAmount = getDestAmount(srcToken,destToken,srcAmount,platformAddress);\n        require(destAmount > 0, \"amountOut <= 0\"); \n        require(destAmount >= destAmountMin, \"destAmount is not enough\");\n        \n        if (srcAddress == address(this)) {\n            safeTransfer(address(srcToken),assetAddress,srcAmount);\n        }\n        else {\n            safeTransferFrom(address(srcToken),srcAddress,assetAddress,srcAmount);\n        }\n        safeTransferFrom(address(destToken),assetAddress,to,destAmount);\n        \n        if(srcToken != wethAddress) {\n            myConversionRates.recordImbalance(srcToken, -1*int(srcAmount), 0, 0);\n        }\n        if(destToken != wethAddress) {\n            myConversionRates.recordImbalance(destToken, int(destAmount), 0, 0);\n        }\n        \n        emit TradeExecute(platformAddress, srcToken, srcAmount, destToken, destAmount, to);\n        \n        return destAmount;\n    }\n    \n   \n    \n}\n\n"
    }
  }
}