{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/FinalProductionET.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/**\n *  Program Name: EtherTreasury\n *  Website     : https://www.ethertreasury.com/\n *  Concept     : Ethereum & ERC-20 Toekns Dividend Paying DApp\n *  Category    : Passive Income\n * */\n\npragma solidity >=0.6.0 <0.8.0;\n\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n     /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    \n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ncontract EtherTreasury is Ownable {\n    \n    /**\n     * @dev Structure to hold tokens supplu and dividend per share against collateral.\n     */\n    struct TokenMaster {\n        uint supply;\n        uint dividend;\n    }\n    \n    /**\n     * @dev Structure to hold collateral balalnce of wallet.\n     */\n    struct BalanceLedger {\n        uint tokenBalance;\n        uint referralBalance;\n        int payOut;\n    }\n    \n    /**\n     * @dev mapping to store all active contract addresses and wallet addresses. This will be used to check if contract address and wallet address already part of system.\n     */\n    mapping(address => bool) contractAddressList;\n    mapping(address => bool) walletAddressList;\n    \n    /**\n     * @dev array to store active contract address and wallet addresses.\n     */\n    address[] contractAddressSet;\n    address[] walletAddressSet;\n    \n    uint constant magnitude = 1e18 ;\n    uint constant initialPrice = 100000000000;\n    uint constant incrementPrice = 10000000000;\n    uint constant dividendFee = 10;\n    \n    /**\n     * @dev owner will start program on given time for investment.\n     */\n    bool startDeposit = false;\n    \n    /**\n     * @dev structure mapping created for storing balance and token information.\n     */\n    mapping (address => mapping(address => BalanceLedger)) balanceDetails;\n    mapping(address => TokenMaster) tokenDetails;\n    \n    /**\n     * @dev events to register information about collateral buy, sell, reinvest and token withdraw.\n     */\n    event onPurchase(address walletAddress, address contractAddress, uint incomingTokenAmount, uint collateralMinted, address referredBy);\n    event onSell(address walletAddress, address contractAddress, uint tokenAmountToReceiver, uint collateralBurned);\n    event onReinvest(address walletAddress, address contractAddress, uint reInvestTokenAmount, uint collateralMinted);\n    event onWithdraw(address walletAddress, address contractAddress, uint amountToWithdraw);\n    \n    /**\n     * @dev function to purchase collateral by sending Ethereum.\n     */\n    function buy(address _referredBy) public payable returns(uint256)\n    {\n        require(startDeposit);\n        require(msg.value>0);\n        \n        // if this is first deposit transaction for token then activate token struct storage with default initial parameters.\n        if(contractAddressList[0x0000000000000000000000000000000000000000] == false){\n            contractAddressList[0x0000000000000000000000000000000000000000] = true ;\n            \n            tokenDetails[0x0000000000000000000000000000000000000000].supply = 0;\n            tokenDetails[0x0000000000000000000000000000000000000000].dividend = 0;\n            \n            contractAddressSet.push(0x0000000000000000000000000000000000000000);\n        }\n        \n        // if first investment from user then activate wallet address in system.\n        if(walletAddressList[msg.sender] == false){\n            walletAddressList[msg.sender] = true;\n            walletAddressSet.push(msg.sender);\n        }\n        \n        uint256 collateAmount = purchaseCollate(0x0000000000000000000000000000000000000000, msg.value, _referredBy);\n        return collateAmount;\n    }\n    \n    /**\n     * @dev function to purchase collateral by sending any ERC-20 Tokens except Ethereum.\n     */\n    function buy(address contractAddress, uint256 tokenAmount, address _referredBy) public returns(uint256)\n    {\n        require(startDeposit);\n        \n        // transfer token to system from user wallet\n        require(ERC20(contractAddress).allowance(msg.sender, address(this)) >= tokenAmount);\n        require(ERC20(contractAddress).transferFrom(msg.sender, address(this), tokenAmount));\n        \n        // if this is first deposit transaction for token then activate token struct storage with default initial parameters.\n        if(contractAddressList[contractAddress]==false){\n            contractAddressList[contractAddress]=true ;\n            \n            tokenDetails[contractAddress].supply = 0;\n            tokenDetails[contractAddress].dividend = 0;\n            \n            contractAddressSet.push(contractAddress);\n        }\n        \n        // if first investment from user then activate wallet address in system.\n        if(walletAddressList[msg.sender] == false){\n            walletAddressList[msg.sender] = true;\n            walletAddressSet.push(msg.sender);\n        }\n        \n        uint256 collateAmount = purchaseCollate(contractAddress,tokenAmount, _referredBy);\n        return collateAmount;\n    }\n    \n    /**\n     * @dev function to purchase collateral by sending Ethereum directly to smart contract address.\n     */\n    fallback() payable external\n    {\n        require(startDeposit);\n        require(msg.value > 0);\n        // if this is first deposit transaction for token then activate token struct storage with default initial parameters.\n        if(contractAddressList[0x0000000000000000000000000000000000000000] == false){\n            contractAddressList[0x0000000000000000000000000000000000000000] = true ;\n            \n            tokenDetails[0x0000000000000000000000000000000000000000].supply = 0;\n            tokenDetails[0x0000000000000000000000000000000000000000].dividend = 0;\n            \n            contractAddressSet.push(0x0000000000000000000000000000000000000000);\n        }\n        \n        // if first investment from user then activate wallet address in system.\n        if(walletAddressList[msg.sender] == false){\n            walletAddressList[msg.sender] = true;\n            walletAddressSet.push(msg.sender);\n        }\n        purchaseCollate(0x0000000000000000000000000000000000000000, msg.value, 0x0000000000000000000000000000000000000000);\n    }\n    \n    /**\n     * @dev function to convert all dividend to collateral.\n     */\n    function reinvest(address contractAddress) public\n    {\n        // fetch dividends\n        uint256 _dividends = myDividends(contractAddress, false); // retrieve ref. bonus later in the code\n        \n        // pay out the dividends virtually\n        address _customerAddress = msg.sender;\n        balanceDetails[_customerAddress][contractAddress].payOut +=  (int256) (_dividends * magnitude);\n        \n        // retrieve ref. bonus\n        _dividends += balanceDetails[_customerAddress][contractAddress].referralBalance;\n        \n        balanceDetails[_customerAddress][contractAddress].referralBalance = 0;\n        \n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\n        uint256 _collate = purchaseCollate(contractAddress, _dividends, 0x0000000000000000000000000000000000000000);\n        \n        // fire event\n        emit onReinvest(_customerAddress, contractAddress, _dividends, _collate);\n    }\n    \n    /**\n     * @dev function to sell collateral and withdraw tokens.\n     */\n    function sellAndwithdraw(address contractAddress) public\n    {\n        // get token count for caller & sell them all\n        address _customerAddress = msg.sender;\n        uint256 _tokens = balanceDetails[_customerAddress][contractAddress].tokenBalance;\n        if(_tokens > 0) sell(contractAddress, _tokens);\n    \n        withdraw(contractAddress);\n    }\n\n    /**\n     * @dev function to withdraw tokens, dividend and referralBalance.\n     */\n    function withdraw(address contractAddress) public\n    {\n        // setup data\n        address _customerAddress = msg.sender;\n        uint256 _dividends = myDividends(contractAddress, false); // get ref. bonus later in the code\n        \n        // update dividend tracker\n        balanceDetails[_customerAddress][contractAddress].payOut +=  (int256) (_dividends * magnitude);\n        \n        // add ref. bonus\n        _dividends += balanceDetails[_customerAddress][contractAddress].referralBalance;\n        balanceDetails[_customerAddress][contractAddress].referralBalance = 0;\n        \n        // delivery service\n        if (contractAddress == 0x0000000000000000000000000000000000000000){\n            payable(address(_customerAddress)).transfer(_dividends);\n        }\n        else{\n            ERC20(contractAddress).transfer(_customerAddress,_dividends);\n        }\n        \n        \n        // fire event\n        emit onWithdraw(_customerAddress, contractAddress, _dividends);\n    }\n    \n    /**\n     * @dev function to sell collatral.\n     */\n    function sell(address contractAddress, uint256 _amountOfCollate) public\n    {\n      \n        address _customerAddress = msg.sender;\n       \n        require(_amountOfCollate <= balanceDetails[_customerAddress][contractAddress].tokenBalance);\n        \n        uint256 _collates = _amountOfCollate;\n        uint256 _tokens = collateralToToken_(contractAddress, _collates);\n        uint256 _dividends = SafeMath.div(_tokens, dividendFee);\n        uint256 _taxedToken = SafeMath.sub(_tokens, _dividends);\n        \n        // burn the sold tokens\n        tokenDetails[contractAddress].supply = SafeMath.sub(tokenDetails[contractAddress].supply, _collates);\n        balanceDetails[_customerAddress][contractAddress].tokenBalance = SafeMath.sub(balanceDetails[_customerAddress][contractAddress].tokenBalance, _collates);\n        \n        // update dividends tracker\n        int256 _updatedPayouts = (int256) (tokenDetails[contractAddress].dividend * _collates + (_taxedToken * magnitude));\n        balanceDetails[_customerAddress][contractAddress].payOut -= _updatedPayouts;       \n        \n        // dividing by zero is a bad idea\n        if (tokenDetails[contractAddress].supply > 0) {\n            // update the amount of dividends per token\n            tokenDetails[contractAddress].dividend = SafeMath.add(tokenDetails[contractAddress].dividend, (_dividends * magnitude) / tokenDetails[contractAddress].supply);\n        }\n        \n        // fire event\n        emit onSell(_customerAddress, contractAddress, _taxedToken, _collates);\n    }\n        \n    /**\n     * @dev function to get current purchase price of single collateral.\n     */\n    function buyPrice(address contractAddress) public view returns(uint currentBuyPrice) {\n        if(tokenDetails[contractAddress].supply == 0){\n            return initialPrice + incrementPrice;\n        } else {\n            uint256 _token = collateralToToken_(contractAddress, 1e18);\n            uint256 _dividends = SafeMath.div(_token, dividendFee);\n            uint256 _taxedToken = SafeMath.add(_token, _dividends);\n            return _taxedToken;\n        }\n    }\n    \n    /**\n     * @dev function to get current sell price of single collateral.\n     */\n    function sellPrice(address contractAddress) public view returns(uint) {\n        if(tokenDetails[contractAddress].supply == 0){\n            return initialPrice - incrementPrice;\n        } else {\n            uint256 _token = collateralToToken_(contractAddress, 1e18);\n            uint256 _dividends = SafeMath.div(_token, dividendFee);\n            uint256 _taxedToken = SafeMath.sub(_token, _dividends);\n            return _taxedToken;\n        }\n    }\n\n    \n    /**\n     * @dev function to calculate collateral price based on an amount of incoming token\n     * It's an scientific algorithm;\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n     */\n    function tokentoCollateral_(address contractAddress, uint amount) internal view returns(uint)\n    {\n        uint256 _tokenPriceInitial = initialPrice * 1e18;\n        uint256 tokenSupply_ = tokenDetails[contractAddress].supply;\n        uint tokenPriceIncremental_ = incrementPrice;\n        \n        uint256 _tokensReceived = \n         (\n            (\n                // underflow attempts BTFO\n                SafeMath.sub(\n                    (sqrt\n                        (\n                            (_tokenPriceInitial**2)\n                            +\n                            (2*(tokenPriceIncremental_ * 1e18)*(amount * 1e18))\n                            +\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n                            +\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n                        )\n                    ), _tokenPriceInitial\n                )\n            )/(tokenPriceIncremental_)\n        )-(tokenSupply_)\n        ;\n  \n        return _tokensReceived;\n    }\n    \n    /**\n     * @dev function to calculate token price based on an amount of incoming collateral\n     * It's an scientific algorithm;\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n     */\n    function collateralToToken_(address contractAddress, uint256 _tokens) internal view returns(uint256)\n    {\n\n        uint256 tokens_ = _tokens + 1e18 ;\n        uint256 _tokenSupply = tokenDetails[contractAddress].supply + 1e18;\n        uint256 tokenPriceInitial_ = initialPrice;\n        uint tokenPriceIncremental_ = incrementPrice;\n        \n        uint256 _etherReceived =\n        (\n            // underflow attempts BTFO\n            SafeMath.sub(\n                (\n                    (\n                        (\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\n                        )-tokenPriceIncremental_\n                    )*(tokens_ - 1e18)\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\n            )\n        /1e18);\n        \n        return _etherReceived;\n    }\n    \n    /**\n     * @dev function to calculate amount of collateral received after sending tokens\n     */\n    function calculateCollateReceived(address contractAddress, uint256 _tokenAmount) public view returns(uint256)\n    {\n        uint256 _dividends = SafeMath.div(_tokenAmount, dividendFee);\n        uint256 _taxedToken = SafeMath.sub(_tokenAmount, _dividends);\n        uint256 _amountOfCollatral = tokentoCollateral_(contractAddress, _taxedToken);\n        \n        return _amountOfCollatral;\n    }\n     \n    /**\n     * @dev function to calculate amount of tokens received after sending collateral\n     */\n    function calculateTokenReceived(address contractAddress, uint256 _collateToSell) public view returns(uint256)\n    {\n        require(_collateToSell <= tokenDetails[contractAddress].supply);\n        uint256 _token = collateralToToken_(contractAddress, _collateToSell);\n        uint256 _dividends = SafeMath.div(_token, dividendFee);\n        uint256 _taxedToken = SafeMath.sub(_token, _dividends);\n        return _taxedToken;\n    }  \n    \n    /**\n     * @dev function to process purchase of collateral and update user balance, dividend\n     */\n    function purchaseCollate(address contractAddress, uint256 _incomingToken, address _referredBy) internal returns(uint256)\n    {\n        // data setup\n        address _customerAddress = msg.sender;\n        uint256 _undividedDividends = SafeMath.div(_incomingToken, dividendFee);\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n        uint256 _taxedToken = SafeMath.sub(_incomingToken, _undividedDividends);\n        uint256 _amountOfCollate = tokentoCollateral_(contractAddress,_taxedToken);\n        uint256 _fee = _dividends * magnitude;\n \n      \n        require(_amountOfCollate > 0 && (SafeMath.add(_amountOfCollate,tokenDetails[contractAddress].supply) > tokenDetails[contractAddress].supply));\n        \n        // is the user referred by a karmalink?\n        if(\n            // is this a referred purchase?\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\n            \n            // no cheating!\n            _referredBy != _customerAddress &&\n            \n            walletAddressList[_referredBy] == true\n        ){\n            // wealth redistribution\n            balanceDetails[_referredBy][contractAddress].referralBalance = SafeMath.add(balanceDetails[_referredBy][contractAddress].referralBalance, _referralBonus);\n        } else {\n            // no ref purchase\n            // add the referral bonus back to the global dividends cake\n            _dividends = SafeMath.add(_dividends, _referralBonus);\n            _fee = _dividends * magnitude;\n        }\n        \n        // we can't give people infinite ethereum\n        if(tokenDetails[contractAddress].supply > 0){\n            \n            // add tokens to the pool\n            tokenDetails[contractAddress].supply = SafeMath.add(tokenDetails[contractAddress].supply, _amountOfCollate);\n \n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n            tokenDetails[contractAddress].dividend += (_dividends * magnitude / (tokenDetails[contractAddress].supply));\n            \n            // calculate the amount of tokens the customer receives over his purchase \n            _fee = _fee - (_fee-(_amountOfCollate * (_dividends * magnitude / (tokenDetails[contractAddress].supply))));\n        \n        } else {\n            // add tokens to the pool\n            tokenDetails[contractAddress].supply = _amountOfCollate;\n        }\n        \n        // update circulating supply & the ledger address for the customer\n        balanceDetails[_customerAddress][contractAddress].tokenBalance = SafeMath.add(balanceDetails[_customerAddress][contractAddress].tokenBalance, _amountOfCollate);\n        \n        int256 _updatedPayouts = (int256) ((tokenDetails[contractAddress].dividend * _amountOfCollate) - _fee);\n        balanceDetails[_customerAddress][contractAddress].payOut += _updatedPayouts;\n        \n        // fire event\n        emit onPurchase(_customerAddress, contractAddress, _incomingToken, _amountOfCollate, _referredBy);\n        \n        return _amountOfCollate;\n    }\n    \n    /**\n     * @dev function to get tokens contract hold\n     */\n    function totalTokenBalance(address contractAddress) public view returns(uint)\n    {   \n        if (contractAddress== 0x0000000000000000000000000000000000000000){\n            return address(this).balance;\n        }\n        else{\n            return ERC20(contractAddress).balanceOf(address(this));\n        }\n    }\n    \n    /**\n     * @dev function to retrieve the total token supply.\n     */\n    function totalSupply(address contractAddress) public view returns(uint256)\n    {\n        return tokenDetails[contractAddress].supply;\n    }\n    \n    /**\n     * @dev function to retrieve the tokens owned by the caller.\n     */\n    function myTokens(address contractAddress) public view returns(uint256)\n    {\n        address _customerAddress = msg.sender;\n        return balanceOf(contractAddress, _customerAddress);\n    }\n    \n    /**\n     * @dev function to retrieve the dividends owned by the caller.\n      */ \n    function myDividends(address contractAddress, bool _includeReferralBonus) public view returns(uint256)\n    {\n        address _customerAddress = msg.sender;\n        return _includeReferralBonus ? dividendsOf(contractAddress,_customerAddress) + balanceDetails[_customerAddress][contractAddress].referralBalance : dividendsOf(contractAddress, _customerAddress) ;\n    }\n    \n    /**\n     * @dev function to retrieve the token balance of any single address.\n     */\n    function balanceOf(address contractAddress, address _customerAddress) view public returns(uint256)\n    {\n        return balanceDetails[_customerAddress][contractAddress].tokenBalance;\n    }\n    \n    /**\n     * @dev function to retrieve the dividend balance of any single address.\n     */\n    function dividendsOf(address contractAddress, address _customerAddress) view public returns(uint256)\n    {\n        return (uint256) ((int256)(tokenDetails[contractAddress].dividend * balanceDetails[_customerAddress][contractAddress].tokenBalance) - balanceDetails[_customerAddress][contractAddress].payOut) / magnitude;\n    }\n    \n\n    /**\n     * @dev function to return active tokens list in system\n     */ \n    function tokenList() public view returns (address [] memory){\n        return contractAddressSet;\n    }\n    \n    /**\n     * @dev function to return active wallets list in system\n     */ \n    function walletList() public view returns (address [] memory){\n        return walletAddressSet;\n    }\n    \n\n    /**\n     * @dev function to process swapping of user balance to new token contract address in case project decide to swap ERC-20 token\n     * This function will be used only when project team sent equivalent new contract in system token without asking for old tokens\n     * token swap ratio must be same\n     * this will protect users from price crash due to token sell for swapping. \n     */ \n    function swapTokenContract(address oldContractAddress, address newContractAddress) public onlyOwner returns(bool success)\n    {\n        // validate old contract is already part of system\n        require(contractAddressList[oldContractAddress]=true, \"Old contract tokens must be part of system\");\n        \n        // activate new contractAddress in system\n        if(contractAddressList[newContractAddress]==false)\n        {\n            contractAddressList[newContractAddress]=true ;\n            tokenDetails[newContractAddress].supply = 0;\n            tokenDetails[newContractAddress].dividend = 0;\n            \n            contractAddressSet.push(newContractAddress);\n        }\n        \n        for(uint i = 0; i < walletAddressSet.length; i++)\n        {\n            if (balanceDetails[walletAddressSet[i]][oldContractAddress].tokenBalance > 0 || balanceDetails[walletAddressSet[i]][oldContractAddress].payOut > 0)\n            {\n                // swap user balance from old contract address to new contract address\n                balanceDetails[walletAddressSet[i]][newContractAddress].tokenBalance = balanceDetails[walletAddressSet[i]][oldContractAddress].tokenBalance;\n                balanceDetails[walletAddressSet[i]][newContractAddress].referralBalance = balanceDetails[walletAddressSet[i]][oldContractAddress].referralBalance;\n                balanceDetails[walletAddressSet[i]][newContractAddress].payOut = balanceDetails[walletAddressSet[i]][oldContractAddress].payOut;\n                \n                // set old contract address balance to zero\n                balanceDetails[walletAddressSet[i]][oldContractAddress].tokenBalance=0;\n                balanceDetails[walletAddressSet[i]][oldContractAddress].referralBalance=0;\n                balanceDetails[walletAddressSet[i]][oldContractAddress].payOut=0;\n            }\n        }\n        \n        // swap dividend, current price and supply from old contract to new contract\n        tokenDetails[newContractAddress].supply = tokenDetails[oldContractAddress].supply;\n        tokenDetails[newContractAddress].dividend = tokenDetails[oldContractAddress].dividend;\n        \n        // set old contract divdividend, price to zero\n        tokenDetails[oldContractAddress].supply = 0;\n        tokenDetails[oldContractAddress].dividend = 0;\n        \n        return true;\n    }\n    \n    /**\n     * @dev function to startDeposit\n     */ \n    function startContract() public onlyOwner returns(bool status){\n        startDeposit = true;\n        return true;\n    }\n    \n    function sqrt(uint x) internal pure returns (uint y) {\n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n\n/**\n * @dev interface to process transfer of ERC20 tokens\n */ \ninterface ERC20 {\n    function totalSupply() external view returns (uint supply);\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n    function approve(address _spender, uint _value) external returns (bool success);\n    function balanceOf(address _owner) external view returns (uint balance);\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n\n    event Approval(address indexed _owner, address indexed _spender,    uint _value);\n    event Transfer(address indexed _from, address indexed _to, uint    _value);\n}\n\n/**\n * @dev safemath library to avoid mathematical overflow error\n */ \nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n   \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n   \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}"}}}