{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ClientRecord.sol":{"content":"pragma solidity 0.6.6;\nimport \"./SafeMath.sol\";\nimport \"./IClientRecordShema.sol\";\nimport \"./StorageOwners.sol\";\npragma experimental ABIEncoderV2;\n\ncontract ClientRecord is IClientRecordSchema, StorageOwners {\n\n    uint256 DepositRecordId;\n\n    using SafeMath for uint256;\n    \n    FixedDepositRecord[] fixedDepositRecords;\n    \n    mapping(uint => FixedDepositRecord) DepositRecordMapping;\n    \n    \n    mapping (address => mapping(uint => FixedDepositRecord)) DepositRecordToDepositorMapping; //depositor address to depositor cycle mapping\n    \n     mapping(address=>uint) DepositorToDepositorRecordIndexMapping; //  This tracks the number of records by index created by a depositor\n\n    mapping(address=>mapping(uint=>uint)) DepositorToRecordIndexToRecordIDMapping; //  This maps the depositor to the record index and then to the record ID\n\n    // list of CLient Records\n    ClientRecord[] ClientRecords;\n    //Mapping that enables ease of traversal of the Client Records\n    mapping(address => RecordIndex) public ClientRecordIndexer;\n\n    function doesClientRecordExist(address depositor)\n        external\n        view\n        returns (bool)\n    {\n       return ClientRecordIndexer[depositor].exists;\n        \n    }\n\n    function getRecordIndex(address depositor) external view returns (uint256) {\n        RecordIndex memory recordIndex = ClientRecordIndexer[depositor];\n        require(recordIndex.exists, \"member record not found\");\n        return recordIndex.index;\n    }\n\n    function createClientRecord(\n        address payable _address,\n        uint256 underlyingTotalDeposits,\n        uint256 underlyingTotalWithdrawn,\n        uint256 derivativeBalance,\n        uint256 derivativeTotalDeposits,\n        uint256 derivativeTotalWithdrawn\n    ) external onlyStorageOracle {\n        RecordIndex memory recordIndex = ClientRecordIndexer[_address];\n        require(\n            !recordIndex.exists,\n            \"depositor record already exists\"\n        );\n        ClientRecord memory clientRecord = ClientRecord(\n            true,\n            _address,\n            underlyingTotalDeposits,\n            underlyingTotalWithdrawn,\n            derivativeBalance,\n            derivativeTotalDeposits,\n            derivativeTotalWithdrawn\n        );\n\n        recordIndex = RecordIndex(true, ClientRecords.length);\n        ClientRecords.push(clientRecord);\n        ClientRecordIndexer[_address] = recordIndex;\n    }\n\n    function updateClientRecord(\n        address payable _address,\n        uint256 underlyingTotalDeposits,\n        uint256 underlyingTotalWithdrawn,\n        uint256 derivativeBalance,\n        uint256 derivativeTotalDeposits,\n        uint256 derivativeTotalWithdrawn\n    ) external onlyStorageOracle {\n        RecordIndex memory recordIndex = ClientRecordIndexer[_address];\n        require(recordIndex.exists, \"depositor record not found\");\n        ClientRecord memory clientRecord = ClientRecord(\n            true,\n            _address,\n            underlyingTotalDeposits,\n            underlyingTotalWithdrawn,\n            derivativeBalance,\n            derivativeTotalDeposits,\n            derivativeTotalWithdrawn\n        );\nclientRecord.underlyingTotalDeposits = underlyingTotalDeposits;\nclientRecord.underlyingTotalWithdrawn = underlyingTotalWithdrawn;\nclientRecord.derivativeBalance = derivativeBalance;\nclientRecord.derivativeTotalDeposits = derivativeTotalDeposits;\nclientRecord.derivativeTotalWithdrawn = derivativeTotalWithdrawn;\n    }\n\n    function getLengthOfClientRecords() external returns (uint256) {\n        return ClientRecords.length;\n    }\n\n    function getClientRecordByIndex(uint256 index)\n        external\n        view\n        returns (\n            address payable _address,\n            uint256 underlyingTotalDeposits,\n            uint256 underlyingTotalWithdrawn,\n            uint256 derivativeBalance,\n            uint256 derivativeTotalDeposits,\n            uint256 derivativeTotalWithdrawn\n        )\n    {\n        ClientRecord memory clientRecord = ClientRecords[index];\n        return (\n            clientRecord._address,\n            clientRecord.underlyingTotalDeposits,\n            clientRecord.underlyingTotalWithdrawn,\n            clientRecord.derivativeBalance,\n            clientRecord.derivativeTotalDeposits,\n            clientRecord.derivativeTotalWithdrawn\n        );\n    }\n\n    function getClientRecordByAddress(address depositor)\n        external\n        view\n        returns (\n            address payable _address,\n            uint256 underlyingTotalDeposits,\n            uint256 underlyingTotalWithdrawn,\n            uint256 derivativeBalance,\n            uint256 derivativeTotalDeposits,\n            uint256 derivativeTotalWithdrawn\n        )\n    {\n        RecordIndex memory recordIndex = ClientRecordIndexer[depositor];\n        require(recordIndex.exists, \"depositor record not found\");\n        uint256 index = recordIndex.index;\n\n        ClientRecord memory clientRecord = ClientRecords[index];\n        return (\n            clientRecord._address,\n            clientRecord.underlyingTotalDeposits,\n            clientRecord.underlyingTotalWithdrawn,\n            clientRecord.derivativeBalance,\n            clientRecord.derivativeTotalDeposits,\n            clientRecord.derivativeTotalWithdrawn\n        );\n    }\n\n      function GetRecordIndexFromDepositor(address member) external view returns(uint){\n\n        return DepositorToDepositorRecordIndexMapping[member];\n    }\n    \n     function GetRecordIdFromRecordIndexAndDepositorRecord(uint256 recordIndex, address depositor) external view returns(uint){\n\n      mapping(uint=>uint) storage depositorCreatedRecordIndexToRecordId = DepositorToRecordIndexToRecordIDMapping[depositor];\n\n      return depositorCreatedRecordIndexToRecordId[recordIndex];\n    }\n    \n     function CreateDepositRecordMapping(uint256 amount, uint256 lockPeriodInSeconds,uint256 depositDateInSeconds, address payable depositor, bool hasWithdrawn) external onlyStorageOracle returns(uint)   {\n          \n          DepositRecordId += 1;\n\n         FixedDepositRecord storage _fixedDeposit = DepositRecordMapping[DepositRecordId];\n\n        _fixedDeposit.recordId = DepositRecordId;\n        _fixedDeposit.amount = amount;\n        _fixedDeposit.lockPeriodInSeconds = lockPeriodInSeconds;\n        _fixedDeposit.depositDateInSeconds = depositDateInSeconds;\n        _fixedDeposit.hasWithdrawn = hasWithdrawn;\n        _fixedDeposit.depositorId = depositor;\n        \n        fixedDepositRecords.push(_fixedDeposit);\n\n    return DepositRecordId;\n    }\n\n     function UpdateDepositRecordMapping(uint256 depositRecordId, uint256 amount, uint256 lockPeriodInSeconds,uint256 depositDateInSeconds, address payable depositor, bool hasWithdrawn) external onlyStorageOracle  {\n         \n         \n         FixedDepositRecord storage _fixedDeposit = DepositRecordMapping[depositRecordId];\n\n        _fixedDeposit.recordId = depositRecordId;\n        _fixedDeposit.amount = amount;\n        _fixedDeposit.lockPeriodInSeconds = lockPeriodInSeconds;\n        _fixedDeposit.depositDateInSeconds = depositDateInSeconds;\n        _fixedDeposit.hasWithdrawn = hasWithdrawn;\n        _fixedDeposit.depositorId = depositor;\n        \n        fixedDepositRecords.push(_fixedDeposit);\n\n\n    }\n    \n   function GetRecordId() external view returns (uint){\n        return DepositRecordId;\n    }\n    \n    function GetRecordById(uint depositRecordId) external view returns(uint recordId, address payable depositorId, uint amount, uint depositDateInSeconds, uint lockPeriodInSeconds, bool hasWithdrawn) {\n        \n        FixedDepositRecord memory records = DepositRecordMapping[depositRecordId];\n        \n        return(records.recordId, records.depositorId, records.amount, records.depositDateInSeconds, records.lockPeriodInSeconds, records.hasWithdrawn);\n    }\n    \n    function GetRecords() external view returns (FixedDepositRecord [] memory) {\n        return fixedDepositRecords;\n    }\n    \n     function CreateDepositorToDepositRecordIndexToRecordIDMapping(address payable depositor, uint recordId) external onlyStorageOracle {\n      \n      DepositorToDepositorRecordIndexMapping[depositor] = DepositorToDepositorRecordIndexMapping[depositor].add(1);\n\n      uint DepositorCreatedRecordIndex = DepositorToDepositorRecordIndexMapping[depositor];\n      mapping(uint=>uint) storage depositorCreatedRecordIndexToRecordId = DepositorToRecordIndexToRecordIDMapping[depositor];\n      depositorCreatedRecordIndexToRecordId[DepositorCreatedRecordIndex] = recordId;\n    }\n    \n    function CreateDepositorAddressToDepositRecordMapping (address payable depositor, uint recordId, uint amountDeposited, uint lockPeriodInSeconds, uint depositDateInSeconds, bool hasWithdrawn) external onlyStorageOracle {\n        mapping(uint => FixedDepositRecord) storage depositorAddressMapping = DepositRecordToDepositorMapping[depositor];\n        \n        depositorAddressMapping[recordId].recordId = recordId;\n        depositorAddressMapping[recordId].depositorId = depositor;\n        depositorAddressMapping[recordId].amount = amountDeposited;\n        depositorAddressMapping[recordId].depositDateInSeconds = depositDateInSeconds;\n        depositorAddressMapping[recordId].lockPeriodInSeconds = lockPeriodInSeconds;\n        depositorAddressMapping[recordId].hasWithdrawn = hasWithdrawn;\n        \n    }\n}\n"},"browser/IClientRecordShema.sol":{"content":"pragma solidity 0.6.6;\n\ninterface IClientRecordSchema {\n    struct ClientRecord {\n        bool exists;\n        address payable _address;\n        uint256 underlyingTotalDeposits;\n        uint256 underlyingTotalWithdrawn;\n        uint256 derivativeBalance;\n        uint256 derivativeTotalDeposits;\n        uint256 derivativeTotalWithdrawn;\n    }\n struct FixedDepositRecord{\n        uint256 recordId;\n        address payable depositorId;\n        bool hasWithdrawn;\n        uint256 amount;\n        uint256 depositDateInSeconds;\n        uint256 lockPeriodInSeconds;\n    }\n    struct RecordIndex {\n        bool exists;\n        uint256 index;\n    }\n}\n"},"browser/SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"browser/StorageOwners.sol":{"content":"pragma solidity 0.6.6;\n\ncontract StorageOwners {\n    address owner;\n    mapping(address => bool) private storageOracles;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function changeStorageOracleStatus(address oracle, bool status) external onlyOwner {\n        storageOracles[oracle] = status;\n}\n  function activateStorageOracle(address oracle) external onlyOwner {\n        storageOracles[oracle] = true;\n    }\n\n    function deactivateStorageOracle(address oracle) external onlyOwner {\n        storageOracles[oracle] = false;\n    }\n\n    function reAssignStorageOracle(address newOracle)\n        external\n        onlyStorageOracle\n    {\n        storageOracles[msg.sender] = false;\n        storageOracles[newOracle] = true;\n    }\n\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n\n        // require(newOwner == address(0), \"new owneru\");\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"unauthorized access to contract\");\n        _;\n    }\n\n    modifier onlyStorageOracle() {\n        bool hasAccess = storageOracles[msg.sender];\n        require(hasAccess, \"unauthorized access to contract\");\n        _;\n    }\n}\n"}}}