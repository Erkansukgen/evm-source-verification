{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/BZX2.sol": {
      "content": "pragma solidity >=0.6.6;\nimport \"./SafeMath.sol\";\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns(uint supply);\n\n    function balanceOf(address _owner) external view returns(uint balance);\n\n    function transfer(address _to, uint _value) external returns(bool success);\n\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n\n    function approve(address _spender, uint _value) external returns(bool success);\n\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\n\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\ninterface bzxRead {\n\n    function getLoan(bytes32 loanId) external view returns(bytes32 loanId1, uint96 endTimestamp, address loanToken, address collateralToken, uint256 principal, uint256 collateral, uint256 interestOwedPerDay, uint256 interestDepositRemaining, uint256 startRate, uint256 startMargin, uint256 maintenanceMargin, uint256 currentMargin, uint256 maxLoanTerm, uint256 maxLiquidatable, uint256 maxSeizable);\n}\n\ninterface bzxWrite {\n    function liquidate(bytes32 loanId, address receiver, uint256 closeAmount) payable external;\n    function closeWithSwap(\n        bytes32 loanId,\n        address receiver,\n        uint256 swapAmount, // denominated in collateralToken\n        bool returnTokenIsCollateral, // true: withdraws collateralToken, false: withdraws loanToken\n        bytes memory /*loanDataBytes*/) // for future use\n        external\n        returns (\n            uint256 loanCloseAmount,\n            uint256 withdrawAmount,\n            address withdrawToken\n        );\n}\n\n\ninterface UniswapV2 {\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns(uint256[] memory amounts); \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function WETH() external pure returns (address);\n}\n\n\ninterface FlashLoanInterface {\n    function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes calldata _params) external;\n}\n\n\n\n\ninterface ERC20 {\n\n    function balanceOf(address _owner) external view returns(uint balance);\n\n    function transfer(address _to, uint _value) external returns(bool success);\n\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n\n    function approve(address _spender, uint _value) external returns(bool success);\n\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\n\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n\n\ncontract BZXAAVEFLASHLIQUIDATE2 {\n\n\n\n    address payable owner;\n    address payable aaveRepaymentAddress = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n\n    address uniAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    bzxRead bzx0 = bzxRead(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n\n    address bzx1Address = 0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f;\n    bzxWrite bzx1 = bzxWrite(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n    UniswapV2 usi = UniswapV2(uniAddress);\n    FlashLoanInterface fli = FlashLoanInterface(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n    bytes theBytes;\n    address aaveEthAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    ERC20 wethToken = ERC20(wethAddress);\n    address currentCToken;\n    address currentLToken;\n    address core = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n    uint256 currentMaxLiq;\n    bytes32 currentLoanId;\n    bool wasAvailable = true;\n\n    uint256 outAmount;\n\n    modifier onlyOwner() {\n        if (msg.sender == owner) _;\n    }\n\n\n\n    constructor() public payable {\n        owner = msg.sender;\n\n\n\n    }\n\n\n    fallback() external payable {\n\n    }\n\n\n    function updateBZXs(address newAddress) onlyOwner public {\n        bzxRead bzx0 = bzxRead(newAddress);\n\n        address bzx1Address = newAddress;\n\n        bzxWrite bzx1 = bzxWrite(newAddress);\n    }\n\n    function updateFlashLoanAddress(address newAddress) onlyOwner public {\n        FlashLoanInterface fli = FlashLoanInterface(newAddress);\n    }\n\n\n    function updateAaveEthAddress(address newAddress) onlyOwner public {\n        aaveEthAddress = newAddress;\n    }\n\n\n    function updateAaveRepayment(address payable newAddress) onlyOwner public {\n        aaveRepaymentAddress = newAddress;\n    }\n\n    function updateUniAddress(address newAddress) onlyOwner public {\n        UniswapV2 usi = UniswapV2(newAddress);\n    }\n\n \n\n    \n    function convertTokenToEth(uint256 amount, address addr) internal {\n        uint deadline = block.timestamp + 150; \n        IERC20 dai = IERC20(addr);\n        address[] memory path = new address[](2);\n        path[0] = addr;\n        path[1] = usi.WETH();\n        if (dai.allowance(address(this), address(usi)) == 0){\n            SafeERC20.safeApprove(dai, address(usi), 10000000000000000000000000);\n            //dai.approve(address(usi), 10000000000000000000000000);\n        }\n        usi.swapExactTokensForETH(amount,0, path, address(this), deadline);\n   \n        }\n  \n     \n    function convertEthToToken(uint256 amountOutMin, uint256 inputAmount, address addr) internal {\n        uint deadline = block.timestamp + 150; \n        address[] memory path = new address[](2);\n        path[0] = wethAddress;\n        path[1] = addr;\n        usi.swapExactETHForTokens{value: inputAmount }(amountOutMin, path, address(this), deadline);\n    }\n\n    \n\n    function _execute(bytes32 loanId) onlyOwner public {\n        //getLoan\n        //get amount  and which token you need to pay / flash loan borrow\n        (bytes32 loanId1, uint96 endTimestamp, address loanToken, address collateralToken, uint256 principal, uint256 collateral, , , , , , uint256 currentMargin, uint256 maxLoanTerm, uint256 maxLiquidatable, uint256 maxSeizable) = bzx0.getLoan(loanId);\n        currentCToken = collateralToken;\n        currentLToken = loanToken;\n        currentMaxLiq = maxLiquidatable;\n        currentLoanId = loanId;\n        uint256 out;\n        address tokenAddToUse = loanToken;\n        if (loanToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\n            tokenAddToUse = aaveEthAddress;\n        }\n        if (tokenAddToUse != aaveEthAddress){\n        uint256 availableLiquidityBefore = ERC20(tokenAddToUse).balanceOf(core);\n        if (maxLiquidatable > availableLiquidityBefore){\n            tokenAddToUse = aaveEthAddress;\n            wasAvailable = false;\n        }\n        }\n        performFlash(tokenAddToUse, maxLiquidatable);\n        //flash borrow that amount\n\n        //and then flash function will call bzx liquidate function, swap the returned token from to our repayment  tokenof aave, and pay back avave with fee\n\n\n    }\n\n    function performFlash(address tokenAddToUse, uint maxLiquidatable) internal {\n        fli.flashLoan(address(this), tokenAddToUse, maxLiquidatable, theBytes);\n    }\n\n\n\n    function performUniswap(address sellToken, address buyToken, uint256 amountSent) internal returns(uint256 amounts1) {\n\n\n        IERC20 sellToken1 = IERC20(sellToken);\n        ERC20 buyToken1 = ERC20(currentLToken);\n\n       if (sellToken1.allowance(address(this), uniAddress) <= amountSent) {\n           SafeERC20.safeApprove(sellToken1, uniAddress, 10000000000000000000000000);\n            //sellToken1.approve(uniAddress, 10000000000000000000000000);\n        \n       }\n\n\n\n        require(sellToken1.balanceOf(address(this)) >= amountSent, \"You dont have enough Ctoken to perform this in performUniswap\");\n\n\n        address[] memory addresses = new address[](2);\n\n        addresses[0] = sellToken;\n        addresses[1] = buyToken;\n\n\n        \n        uint256[] memory amounts = performUniswapActual(addresses, amountSent);\n       \n        uint256 resultingTokens = amounts[1];\n        return resultingTokens;\n\n    }\n\n    function performUniswapActual(address[] memory theAddresses, uint amount) internal returns(uint256[] memory amounts1) {\n\n        uint256 deadline = 1000000000000000;\n       \n        uint256[] memory amounts = usi.swapExactTokensForTokens(amount, 0, theAddresses, address(this), deadline);\n        \n\n        return amounts;\n\n    }\n   \n    \n\n    function performTrade(bool isItEther, uint256 amount1) internal {\n\n    \n\n        uint256 startingETHBalance = address(this).balance;\n        IERC20 tokenToReceive = IERC20(currentCToken);\n        uint256 startingCBalance = tokenToReceive.balanceOf(address(this));\n        IERC20 bzLToken = IERC20(currentLToken);\n        uint256 startingLBalance = bzLToken.balanceOf(address(this));\n       \n       if (isItEther == true){\n            bzx1.liquidate{value:(amount1)}(currentLoanId, address(this), currentMaxLiq);\n        }\n        else{   \n            if (bzLToken.allowance(address(this), bzx1Address) <= currentMaxLiq) {\n                SafeERC20.safeApprove(bzLToken, bzx1Address, 10000000000000000000000000);\n                //bzLToken.approve(bzx1Address, (currentMaxLiq * 100));\n            }\n            \n            bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);\n\n        }\n     \n        //now weve made a profit from the liquidation lets convert it back to loaned token\n        \n//handles eth, not sure if this path is ever taken\n        if (address(this).balance > startingETHBalance) {\n            uint256 newETH = address(this).balance - startingETHBalance;\n            convertEthToToken(0, newETH, currentLToken);\n        }\n        else {\n            //handles all other tokens\n            if (address(currentLToken) != 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2){\n                require(startingCBalance<tokenToReceive.balanceOf(address(this)), \"we lost money1\");\n                convertTokenToEth(tokenToReceive.balanceOf(address(this))-startingCBalance, address(tokenToReceive));\n     \n\n                convertEthToToken(0, address(this).balance, currentLToken);\n                require(bzLToken.balanceOf(address(this))> startingLBalance, \"we lost money2\");\n\n            }\n            //handles weth\n            else{\n                \n                require(startingCBalance<tokenToReceive.balanceOf(address(this)), \"we lost money3\");\n                performUniswap(currentCToken, currentLToken, tokenToReceive.balanceOf(address(this))-startingCBalance);\n            }\n         \n        }\n        \n\n    }\n\n\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external {\n        bool isItEther =false;\n       if (_reserve == aaveEthAddress){\n           isItEther = true;\n       }\n       //handles when loaned token is different from what we borrowed\n       if (wasAvailable == false){\n           ERC20 loaned = ERC20(currentLToken);\n           convertEthToToken(0, address(this).balance, currentLToken);\n           performTrade(false, loaned.balanceOf(address(this)));\n           if (currentLToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2){\n\n           \n           }\n            else{\n                ERC20 loaned = ERC20(currentLToken); \n                performUniswap(currentLToken, wethAddress, loaned.balanceOf(address(this)));\n           }\n            wethToken.withdraw((_amount + _fee));\n            aaveRepaymentAddress.call {value: _amount + _fee}(\"\");\n       }\n       else{\n        performTrade(isItEther, _amount);\n        \n        if (_reserve == aaveEthAddress) {\n\n            uint256 repayAmount = (_amount + _fee);\n            wethToken.withdraw((_amount + _fee));\n            aaveRepaymentAddress.call {\n                value: repayAmount\n            }(\"\");\n\n        } else {\n            IERC20 firstToken = IERC20(_reserve);\n            SafeERC20.safeTransfer(firstToken, aaveRepaymentAddress, (_amount + _fee));\n            //firstToken.transfer(aaveRepaymentAddress, (_amount + _fee));\n        }\n       }\n    }\n    function getTokenBal(address token)public view returns (uint256){\n        ERC20 tok = ERC20(token);\n        uint256 ret = tok.balanceOf(address(this));\n        return ret;\n    }\n\n\n\n    function changeOwner(address payable newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n\n   \n\n    // send token 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE if you want to withdraw ether\n    function withdraw(address token) public onlyOwner returns(bool) {\n\n\n\n    //for ether withdrawal from smart contract\n        if (address(token) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            uint256 amount = address(this).balance;\n\n            msg.sender.transfer(amount);\n\n        }\n        //for ether withdrawal from smart contract. Note on dividing by zero: likely will error.\n        else {\n            IERC20 tokenToken = IERC20(token);\n            uint256 newTokenBalance = tokenToken.balanceOf(address(this));\n            SafeERC20.safeTransfer(tokenToken, msg.sender, newTokenBalance);\n            //require(tokenToken.transfer(msg.sender, (newTokenBalance)));\n\n        }\n\n        return true;\n    }\n\n    }"
    },
    "browser/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.6;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  }
}