{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/SmartFundRegistry.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface PermittedConvertsInterface {\n  function permittedAddresses(address _address) external view returns(bool);\n}\ninterface PermittedStablesInterface {\n  function permittedAddresses(address _address) external view returns(bool);\n}\ninterface PermittedPoolsInterface {\n  function permittedAddresses(address _address) external view returns(bool);\n}\ninterface PermittedExchangesInterface {\n  function permittedAddresses(address _address) external view returns(bool);\n}\ninterface SmartFundUSDFactoryInterface {\n  function createSmartFund(\n    address _owner,\n    string  calldata _name,\n    uint256 _successFee,\n    uint256 _platformFee,\n    address _platfromAddress,\n    address _exchangePortalAddress,\n    address _permittedExchanges,\n    address _permittedPools,\n    address _permittedStabels,\n    address _poolPortalAddress,\n    address _stableCoinAddress,\n    address _cEther,\n    address _permittedConvertsAddress\n    )\n  external\n  returns(address);\n}\ninterface SmartFundETHFactoryInterface {\n  function createSmartFund(\n    address _owner,\n    string  calldata _name,\n    uint256 _successFee,\n    uint256 _platformFee,\n    address _platfromAddress,\n    address _exchangePortalAddress,\n    address _permittedExchanges,\n    address _permittedPools,\n    address _poolPortalAddress,\n    address _cEther,\n    address _permittedConvertsAddress\n    )\n  external\n  returns(address);\n}\n\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\n* The SmartFundRegistry is used to manage the creation and permissions of SmartFund contracts\n*/\ncontract SmartFundRegistry is Ownable {\n  address[] public smartFunds;\n\n  // The Smart Contract which stores the addresses of all the authorized Exchange Portals\n  PermittedExchangesInterface public permittedExchanges;\n  // The Smart Contract which stores the addresses of all the authorized Pool Portals\n  PermittedPoolsInterface public permittedPools;\n  // The Smart Contract which stores the addresses of all the authorized stable coins\n  PermittedStablesInterface public permittedStables;\n  // The Smart Contract which stores the addresses of all the authorized Converts portal\n  PermittedConvertsInterface public permittedConverts;\n\n  // Addresses of portals\n  address public poolPortalAddress;\n  address public exchangePortalAddress;\n  address public convertPortalAddress;\n\n  // platForm fee is out of 10,000, e.g 2500 is 25%\n  uint256 public platformFee;\n\n  // Default maximum success fee is 3000/30%\n  uint256 public maximumSuccessFee = 3000;\n\n  // Address of stable coin can be set in constructor and changed via function\n  address public stableCoinAddress;\n\n  // Addresses for Compound platform\n  address public cEther;\n\n  // Factories\n  SmartFundETHFactoryInterface public smartFundETHFactory;\n  SmartFundUSDFactoryInterface public smartFundUSDFactory;\n\n  event SmartFundAdded(address indexed smartFundAddress, address indexed owner);\n\n  /**\n  * @dev contructor\n  *\n  * @param _convertPortalAddress         address of convert portal contract\n  * @param _platformFee                  Initial platform fee\n  * @param _permittedExchangesAddress    Address of the permittedExchanges contract\n  * @param _exchangePortalAddress        Address of the initial ExchangePortal contract\n  * @param _permittedPoolAddress         Address of the permittedPool contract\n  * @param _poolPortalAddress            Address of the initial PoolPortal contract\n  * @param _permittedStables             Address of the permittesStabels contract\n  * @param _stableCoinAddress            Address of the stable coin\n  * @param _smartFundETHFactory          Address of smartFund ETH factory\n  * @param _smartFundUSDFactory          Address of smartFund USD factory\n  * @param _cEther                       Address of Compound ETH wrapper\n  * @param _permittedConvertsAddress     Address of the permittedConverts contract\n  */\n  constructor(\n    address _convertPortalAddress,\n    uint256 _platformFee,\n    address _permittedExchangesAddress,\n    address _exchangePortalAddress,\n    address _permittedPoolAddress,\n    address _poolPortalAddress,\n    address _permittedStables,\n    address _stableCoinAddress,\n    address _smartFundETHFactory,\n    address _smartFundUSDFactory,\n    address _cEther,\n    address _permittedConvertsAddress\n  ) public {\n    convertPortalAddress = _convertPortalAddress;\n    platformFee = _platformFee;\n    exchangePortalAddress = _exchangePortalAddress;\n    permittedExchanges = PermittedExchangesInterface(_permittedExchangesAddress);\n    permittedPools = PermittedPoolsInterface(_permittedPoolAddress);\n    permittedStables = PermittedStablesInterface(_permittedStables);\n    poolPortalAddress = _poolPortalAddress;\n    stableCoinAddress = _stableCoinAddress;\n    smartFundETHFactory = SmartFundETHFactoryInterface(_smartFundETHFactory);\n    smartFundUSDFactory = SmartFundUSDFactoryInterface(_smartFundUSDFactory);\n    cEther = _cEther;\n    permittedConverts = PermittedConvertsInterface(_permittedConvertsAddress);\n  }\n\n  /**\n  * @dev Creates a new SmartFund\n  *\n  * @param _name               The name of the new fund\n  * @param _successFee         The fund managers success fee\n  * @param _isStableBasedFund  true for USD base fund, false for ETH base\n  */\n  function createSmartFund(\n    string memory _name,\n    uint256 _successFee,\n    bool _isStableBasedFund\n  ) public {\n    // Require that the funds success fee be less than the maximum allowed amount\n    require(_successFee <= maximumSuccessFee);\n\n    address owner = msg.sender;\n    address smartFund;\n\n    if(_isStableBasedFund){\n      // Create USD Fund\n      smartFund = smartFundUSDFactory.createSmartFund(\n        owner,\n        _name,\n        _successFee,\n        platformFee,\n        exchangePortalAddress,\n        address(permittedExchanges),\n        address(permittedPools),\n        address(permittedStables),\n        poolPortalAddress,\n        stableCoinAddress,\n        convertPortalAddress,\n        cEther,\n        address(permittedConverts)\n      );\n    }else{\n      // Create ETH Fund\n      smartFund = smartFundETHFactory.createSmartFund(\n        owner,\n        _name,\n        _successFee,\n        platformFee,\n        exchangePortalAddress,\n        address(permittedExchanges),\n        address(permittedPools),\n        poolPortalAddress,\n        convertPortalAddress,\n        cEther,\n        address(permittedConverts)\n      );\n    }\n\n    smartFunds.push(smartFund);\n    emit SmartFundAdded(smartFund, owner);\n  }\n\n  function totalSmartFunds() public view returns (uint256) {\n    return smartFunds.length;\n  }\n\n  function getAllSmartFundAddresses() public view returns(address[] memory) {\n    address[] memory addresses = new address[](smartFunds.length);\n\n    for (uint i; i < smartFunds.length; i++) {\n      addresses[i] = address(smartFunds[i]);\n    }\n\n    return addresses;\n  }\n\n  /**\n  * @dev Sets a new default ExchangePortal address\n  *\n  * @param _newExchangePortalAddress    Address of the new exchange portal to be set\n  */\n  function setExchangePortalAddress(address _newExchangePortalAddress) public onlyOwner {\n    // Require that the new exchange portal is permitted by permittedExchanges\n    require(permittedExchanges.permittedAddresses(_newExchangePortalAddress));\n\n    exchangePortalAddress = _newExchangePortalAddress;\n  }\n\n  /**\n  * @dev Sets a new default Portal Portal address\n  *\n  * @param _poolPortalAddress    Address of the new pool portal to be set\n  */\n  function setPoolPortalAddress (address _poolPortalAddress) external onlyOwner {\n    // Require that the new pool portal is permitted by permittedPools\n    require(permittedPools.permittedAddresses(_poolPortalAddress));\n\n    poolPortalAddress = _poolPortalAddress;\n  }\n\n\n  /**\n  * @dev Sets a new default Convert Portal address\n  *\n  * @param _convertPortalAddress    Address of the new convert portal to be set\n  */\n  function setConvertPortalAddress(address _convertPortalAddress) external onlyOwner {\n    // Require that the new convert portal is permitted by permittedConverts\n    require(permittedConverts.permittedAddresses(_convertPortalAddress));\n\n    convertPortalAddress = _convertPortalAddress;\n  }\n\n  /**\n  * @dev Sets maximum success fee for all newly created SmartFunds\n  *\n  * @param _maximumSuccessFee    New maximum success fee\n  */\n  function setMaximumSuccessFee(uint256 _maximumSuccessFee) external onlyOwner {\n    maximumSuccessFee = _maximumSuccessFee;\n  }\n\n  /**\n  * @dev Sets platform fee for all newly created SmartFunds\n  *\n  * @param _platformFee    New platform fee\n  */\n  function setPlatformFee(uint256 _platformFee) external onlyOwner {\n    platformFee = _platformFee;\n  }\n\n\n  /**\n  * @dev Sets new stableCoinAddress\n  *\n  * @param _stableCoinAddress    New stable address\n  */\n  function setStableCoinAddress(address _stableCoinAddress) external onlyOwner {\n    require(permittedStables.permittedAddresses(_stableCoinAddress));\n    stableCoinAddress = _stableCoinAddress;\n  }\n\n  /**\n  * @dev Allows platform to withdraw tokens received as part of the platform fee\n  *\n  * @param _tokenAddress    Address of the token to be withdrawn\n  */\n  function withdrawTokens(address _tokenAddress) external onlyOwner {\n    IERC20 token = IERC20(_tokenAddress);\n\n    token.transfer(owner(), token.balanceOf(address(this)));\n  }\n\n  /**\n  * @dev Allows platform to withdraw ether received as part of the platform fee\n  */\n  function withdrawEther() external onlyOwner {\n    payable(owner()).transfer(address(this).balance);\n  }\n\n  // Fallback payable function in order to receive ether when fund manager withdraws their cut\n  fallback() external payable {}\n\n}\n"
    }
  }
}