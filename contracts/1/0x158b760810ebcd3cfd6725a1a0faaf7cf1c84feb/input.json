{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/New.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.10 <0.7.0;\n\ncontract ETHPlusX3 {\n    address public creator;\n    uint256 public last_uid;\n    uint256 MAX_LEVEL = 9;\n    uint256 REFERRALS_LIMIT = 2;\n    uint256 LEVEL_EXPIRE_TIME = 90 days;\n    uint256 LEVEL_HIGHER_FOUR_EXPIRE_TIME = 180 days;\n    mapping(uint256 => address) public userAddresses;\n    mapping(uint256 => uint256) directPrice;\n    mapping(uint256 => uint256) levelPrice;\n    mapping(address => User) public users;\n\n    struct User {\n        uint256 id;\n        uint256 referrerID;\n        address[] referrals;\n        mapping(uint256 => uint256) levelExpiresAt;\n    }\n\n    modifier validLevelAmount(uint256 _level) {\n        require(msg.value == levelPrice[_level], \"Invalid level amount sent\");\n        _;\n    }\n\n    modifier userRegistered() {\n        require(users[msg.sender].id != 0, \"User does not exist\");\n        _;\n    }\n\n    modifier validReferrerID(uint256 _referrerID) {\n        require(\n            _referrerID > 0 && _referrerID <= last_uid,\n            \"Invalid referrer ID\"\n        );\n        _;\n    }\n\n    modifier userNotRegistered() {\n        require(users[msg.sender].id == 0, \"User is already registered\");\n        _;\n    }\n\n    modifier validLevel(uint256 _level) {\n        require(_level > 0 && _level <= MAX_LEVEL, \"Invalid level entered\");\n        _;\n    }\n\n    event GetLevelProfitEvent(\n        address indexed user,\n        address indexed referral,\n        uint256 referralID,\n        uint256 amount\n    );\n\n    constructor() public {\n        last_uid++;\n        creator = msg.sender;\n        levelPrice[1] = 0.05 ether;\n        levelPrice[2] = 0.72 ether;\n        levelPrice[3] = 1.96 ether;\n        levelPrice[4] = 4.00 ether;\n        levelPrice[5] = 8.10 ether;\n        levelPrice[6] = 15.00 ether;\n        levelPrice[7] = 20.90 ether;\n        levelPrice[8] = 35.40 ether;\n        levelPrice[9] = 50.70 ether;\n        directPrice[1] = 0.01 ether;\n        directPrice[2] = 0.09 ether;\n        directPrice[3] = 0.49 ether;\n        directPrice[4] = 0.50 ether;\n        directPrice[5] = 1.00 ether;\n        directPrice[6] = 1.87 ether;\n        directPrice[7] = 2.60 ether;\n        directPrice[8] = 4.42 ether;\n        directPrice[9] = 6.30 ether;\n\n        users[creator] = User({\n            id: last_uid,\n            referrerID: 0,\n            referrals: new address[](0)\n        });\n        userAddresses[last_uid] = creator;\n\n        for (uint256 i = 1; i <= MAX_LEVEL; i++) {\n            users[creator].levelExpiresAt[i] = 1 << 37;\n        }\n    }\n\n    function registerUser(uint256 _referrerID)\n        public\n        payable\n        userNotRegistered()\n        validReferrerID(_referrerID)\n        validLevelAmount(1)\n    {\n        uint256 _level = 1;\n\n        if (\n            users[userAddresses[_referrerID]].referrals.length >=\n            REFERRALS_LIMIT\n        ) {\n            _referrerID = users[findReferrer(userAddresses[_referrerID])].id;\n        }\n        last_uid++;\n        users[msg.sender] = User({\n            id: last_uid,\n            referrerID: _referrerID,\n            referrals: new address[](0)\n        });\n        userAddresses[last_uid] = msg.sender;\n        users[msg.sender].levelExpiresAt[_level] =\n            now +\n            getLevelExpireTime(_level);\n        users[userAddresses[_referrerID]].referrals.push(msg.sender);\n\n        transferLevelPayment(_level, msg.sender);\n    }\n\n    function buyLevel(uint256 _level)\n        public\n        payable\n        userRegistered()\n        validLevel(_level)\n        validLevelAmount(_level)\n    {\n        for (uint256 l = _level - 1; l > 0; l--) {\n            require(\n                getUserLevelExpiresAt(msg.sender, l) >= now,\n                \"Buy previous level first\"\n            );\n        }\n\n        if (getUserLevelExpiresAt(msg.sender, _level) == 0) {\n            users[msg.sender].levelExpiresAt[_level] =\n                now +\n                getLevelExpireTime(_level);\n        } else {\n            users[msg.sender].levelExpiresAt[_level] += getLevelExpireTime(\n                _level\n            );\n        }\n\n        transferLevelPayment(_level, msg.sender);\n    }\n\n    function getLevelExpireTime(uint256 _level)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_level < 5) {\n            return LEVEL_EXPIRE_TIME;\n        } else {\n            return LEVEL_HIGHER_FOUR_EXPIRE_TIME;\n        }\n    }\n\n    function findReferrer(address _user) internal view returns (address) {\n        if (users[_user].referrals.length < REFERRALS_LIMIT) {\n            return _user;\n        }\n\n        address[1632] memory referrals;\n        referrals[0] = users[_user].referrals[0];\n        referrals[1] = users[_user].referrals[1];\n\n        address referrer;\n\n        for (uint256 i = 0; i < 16382; i++) {\n            if (users[referrals[i]].referrals.length < REFERRALS_LIMIT) {\n                referrer = referrals[i];\n                break;\n            }\n\n            if (i >= 8191) {\n                continue;\n            }\n\n            referrals[(i + 1) * 2] = users[referrals[i]].referrals[0];\n            referrals[(i + 1) * 2 + 1] = users[referrals[i]].referrals[1];\n        }\n\n        require(referrer != address(0), \"Referrer not found\");\n        return referrer;\n    }\n\n    function transferLevelPayment(uint256 _level, address _user) internal {\n        address referrer = getUserUpline(_user, _level);\n        address sender = msg.sender;\n\n        if (referrer == address(0)) {\n            referrer = creator;\n        }\n\n        uint256 uplines = 3;\n        uint256 eth = msg.value;\n        uint256 ethToReferrer = (eth - (directPrice[_level] * 2)) / uplines;\n\n        for (uint256 i = 1; i <= uplines; i++) {\n            referrer = getUserUpline(_user, i);\n\n            if (\n                referrer != address(0) &&\n                (users[_user].levelExpiresAt[_level] == 0 ||\n                    getUserLevelExpiresAt(referrer, _level) < now)\n            ) {\n                uplines++;\n                continue;\n            }\n\n            if (referrer == address(0)) {\n                referrer = creator;\n            }\n\n            eth = eth - ethToReferrer;\n\n            (bool success, ) = address(uint256(referrer)).call{\n                value: ethToReferrer\n            }(\"\");\n            require(success, \"Transfer failed.\");\n            emit GetLevelProfitEvent(\n                referrer,\n                sender,\n                users[sender].id,\n                ethToReferrer\n            );\n        }\n\n        address directRefer = userAddresses[users[msg.sender].referrerID];\n\n        eth = eth - directPrice[_level];\n        (bool success2, ) = address(uint256(directRefer)).call{\n            value: directPrice[_level]\n        }(\"\");\n        require(success2, \"Transfer failed.\");\n        emit GetLevelProfitEvent(\n            directRefer,\n            sender,\n            users[sender].id,\n            directPrice[_level]\n        );\n\n        (bool success3, ) = address(uint256(creator)).call{value: eth}(\"\");\n        require(success3, \"Transfer failed.\");\n    }\n\n    function getUserUpline(address _user, uint256 height)\n        public\n        view\n        returns (address)\n    {\n        if (height <= 0 || _user == address(0)) {\n            return _user;\n        }\n\n        return\n            this.getUserUpline(\n                userAddresses[users[_user].referrerID],\n                height - 1\n            );\n    }\n\n    function getUserLevelExpiresAt(address _user, uint256 _level)\n        public\n        view\n        returns (uint256)\n    {\n        return users[_user].levelExpiresAt[_level];\n    }\n\n    function getUserReferrals(address _user)\n        public\n        view\n        returns (address[] memory)\n    {\n        return users[_user].referrals;\n    }\n\n    function getUserLevel(address _user) public view returns (uint256) {\n        if (getUserLevelExpiresAt(_user, 1) < now) {\n            return (0);\n        } else if (getUserLevelExpiresAt(_user, 2) < now) {\n            return (1);\n        } else if (getUserLevelExpiresAt(_user, 3) < now) {\n            return (2);\n        } else if (getUserLevelExpiresAt(_user, 4) < now) {\n            return (3);\n        } else if (getUserLevelExpiresAt(_user, 5) < now) {\n            return (4);\n        } else if (getUserLevelExpiresAt(_user, 6) < now) {\n            return (5);\n        } else if (getUserLevelExpiresAt(_user, 7) < now) {\n            return (6);\n        } else if (getUserLevelExpiresAt(_user, 8) < now) {\n            return (7);\n        } else if (getUserLevelExpiresAt(_user, 9) < now) {\n            return (8);\n        } else if (getUserLevelExpiresAt(_user, 10) < now) {\n            return (9);\n        }\n    }\n\n    receive() external payable {\n        revert();\n    }\n}"}}}