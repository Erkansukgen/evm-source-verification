{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/EAGame.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\n/**\n * EAGame\n * v1.0\n */\npragma solidity ^0.6.3;\npragma experimental ABIEncoderV2;\n\nimport \"./Pausable.sol\";\nimport \"./EAToken.sol\";\nimport \"./EAResonance.sol\";\nimport \"./Terminators.sol\";\n\n\ncontract EAGame is Pausable, Terminators {\n    // pool\n    struct Pool {\n        uint256 amount;\n        uint256 speed;\n        uint256 validNum;\n        uint256 alreadyReleaseAmount;\n        uint256 releaseAmount;\n        uint256 community;\n        uint lastWithdrawIndex; // withdraw index\n        uint joinTime; // join game time\n        uint256 partnerAmount;\n    }\n    // _pools info\n    struct PoolsInfo {\n        uint256 allSpeed; // all speed\n        uint256 game; // 87%\n        uint256 endAward; // 5%\n        uint256 community; // 6%\n        uint256 tech; // 2%\n        uint256 alreadyReleaseGame; // release\n    }\n    EAToken private _eat;\n    EAResonance private _ear;\n    \n    // _pools\n    mapping(address => Pool) private _pools;\n    // parent info\n    mapping(address => address) private _referee;\n    // community\n    mapping(address => uint) private _validIndex;\n    mapping(address => address[]) private _validors;\n    mapping(address => address[]) private _referrals;\n    address private _root;\n    // info\n    PoolsInfo private _poolsInfo;\n    // valid account\n    uint256 private VALID_ACCOUNT_VALUE = 5 ether;\n    // level hierarchy\n    uint8[12] private ACC_SPEED = [\n        20, // level1\n        10, // level2\n        3, // level3\n        3, // level4\n        2, // level5\n        2, // level6\n        1, // level7\n        1, // level8\n        1, // level9\n        1, // level10\n        1, // level11\n        1  // level12\n    ];\n    uint256[3] private PARTNER_LEVEL_LIMIT = [\n        100 ether,\n        500 ether,\n        2000 ether\n    ];\n    // all partner\n    mapping (uint => address[]) private _partners;\n    mapping (address => uint []) private _partnersIndex; // partners level\n    uint[] private _partnersRecordIndex;\n    mapping (uint => uint256[]) private _partnersSendRecords;\n\n    function isInWhiteList(address _account) public view returns (bool) {\n        return _referee[_account] != address(0);\n    }\n\n    constructor (EAToken _t, EAResonance _r) Terminators(25920) public {\n        _root = msg.sender;\n        _referee[_root] = msg.sender;\n        _eat = _t;\n        _ear = _r;\n    }\n\n    /// Entrance\n    receive () external payable whenNotPaused {\n        _do(msg.sender, msg.value);\n    }\n\n    /// get morning time\n    function _getDayTime(uint _time) private pure returns(uint) {\n        return _time / 15 minutes;\n    } \n\n    function _do(address payable _account, uint256 _value) private {\n        if (_value == 0) {\n            // withdraw\n            _withdraw(_account);\n        } else {\n            _join(_account, _value);\n            _updateTerminatorsBoard(_account, _value);\n        }\n    }\n\n    /// authorize\n    function authorize(address _p) external {\n        require(!isInWhiteList(msg.sender), \"EAGame: [authorize] You have already authorized\");\n        require(isInWhiteList(_p), \"EAGame: [authorizee] auth fail\");\n        _referee[msg.sender] = _p;\n        _referrals[_p].push(msg.sender);\n    }\n\n    /// withdraw\n    function _withdraw(address payable _account) private {\n        require(_pools[_account].joinTime != 0, \"EAGame: You must join game first\");\n        require(_pools[_account].alreadyReleaseAmount < _pools[_account].releaseAmount, \"EAGame: You already release amount\");\n\n        uint wdDays = _getDayTime(block.timestamp) - _pools[_account].joinTime;\n        uint256 diff = wdDays.sub(_pools[_account].lastWithdrawIndex); \n        require(diff > 0, \"EAGame: You can not withdraw\");\n\n        uint256 gameStay = _poolsInfo.game.sub(_poolsInfo.alreadyReleaseGame);\n        uint256 earnings = gameStay.div(100).mul(_pools[_account].speed).div(_poolsInfo.allSpeed).mul(diff);\n        if (_pools[_account].alreadyReleaseAmount.add(earnings) > _pools[_account].releaseAmount) {\n            earnings = _pools[_account].releaseAmount.sub(_pools[_account].alreadyReleaseAmount);\n        }\n        _pools[_account].alreadyReleaseAmount = _pools[_account].alreadyReleaseAmount.add(earnings);\n        _pools[_account].lastWithdrawIndex = wdDays; // update withdraw index\n        _poolsInfo.alreadyReleaseGame = _poolsInfo.alreadyReleaseGame.add(earnings);\n        // send to user\n        _account.transfer(earnings);\n    }\n\n    /// join\n    function _join(address _account, uint256 _value) private {\n        // check 300 limit\n        require(_value <= 300 ether && _value >= 1,\n        \"[EAGame]: Join game must less than or equal to 300 ether and more than 1 ether\");\n        require(isInWhiteList(_account), \"EAGame: [_join] you must authorized\");\n        // check tickets and consume\n        uint256 latestPrice = _ear.latestPrice();\n        uint256 ticketsAmount = _value.mul(latestPrice).div(10 ether);\n        // pay ticket\n        _eat.payF(_account, ticketsAmount);\n        // record pool\n        _poolsInfo.game = _poolsInfo.game.add(_value.mul(87).div(100));\n        _poolsInfo.endAward = _poolsInfo.endAward.add(_value.mul(5).div(100));\n        _poolsInfo.community = _poolsInfo.community.add(_value.mul(6).div(100));\n        _poolsInfo.tech = _poolsInfo.tech.add(_value.mul(2).div(100));\n        // join game\n        _pools[_account].amount = _pools[_account].amount.add(_value);\n        _pools[_account].speed = _pools[_account].speed.add(_value);\n        _poolsInfo.allSpeed = _poolsInfo.allSpeed.add(_pools[_account].speed);\n        if (_pools[_account].joinTime == 0) {\n            _pools[_account].joinTime = _getDayTime(block.timestamp);\n        }\n        if (_pools[_account].amount >= 50 ether) {\n            _pools[_account].releaseAmount = _pools[_account].releaseAmount.add(_value.mul(5));\n        } else if (_pools[_account].amount >= 30 ether) {\n            _pools[_account].releaseAmount += _pools[_account].releaseAmount.add(_value.mul(4));\n        } else {\n            _pools[_account].releaseAmount += _pools[_account].releaseAmount.add(_value.mul(3));\n        }\n        // get parent, check valid\n        address parent = _referee[_account];\n        if (_pools[_account].amount >= VALID_ACCOUNT_VALUE) {\n            if (_validIndex[_account] == 0) {\n                _validors[parent].push(_account); // update _validIndex\n                _validIndex[_account] = _validors[parent].length;\n                _pools[parent].validNum++; // update valid num\n            }\n        }\n        // check speed\n        for (uint i = 0; i < ACC_SPEED.length; i++) {\n            if (parent == _root) {\n                break;\n            }\n            if(_pools[parent].validNum > i && _pools[parent].amount >= VALID_ACCOUNT_VALUE) {\n                // check valid num\n                uint256 speed = _value.mul(ACC_SPEED[i]).div(100);\n                _pools[parent].speed = _pools[parent].speed.add(speed);\n                _poolsInfo.allSpeed = _poolsInfo.allSpeed.add(speed);\n            }\n            _pools[parent].community = _pools[parent].community.add(_value);\n            // iterate\n            parent = _referee[parent];\n        }\n    }\n\n    /// upgradePartner\n    function upgradePartner() external returns(uint) {\n        _upgradePartner(msg.sender);\n    }\n\n    /// upgradePartner\n    function _upgradePartner(address _account) private returns (uint) {\n        uint len = _validors[_account].length;\n        uint256 first = 0;\n        uint256 second = 0;\n        for (uint i = 0; i < len; i++) {\n            address temp = _validors[_account][i];\n            Pool memory pool = _pools[temp];\n            uint256 all = pool.amount.add(pool.community);\n            if (all >= first) {\n                second = first;\n                first = all;\n            }\n            if(all < first && all > second) {\n                second = all;\n            }\n        }\n        uint i = 0;\n        for (i = 0; i < PARTNER_LEVEL_LIMIT.length; i++) {\n            if (second < PARTNER_LEVEL_LIMIT[i]) {\n                break;\n            }\n        }\n        // partner add _account\n        require( i > 0 && i <= PARTNER_LEVEL_LIMIT.length, \"EAGame: [upgradePartner] i illegal\");\n        uint level = 0;\n        if (_partnersIndex[_account].length == 2) {\n            level = _partnersIndex[_account][0];\n        }\n        require( i > level, \"EAGame: [upgradePartner] level remain\");\n        if (_partnersIndex[_account].length == 2) {\n            uint ind = _partnersIndex[_account][1];\n            // already in, remove history level\n            if (level > 0 && level <= PARTNER_LEVEL_LIMIT.length) {\n                uint last = _partners[level].length - 1;\n                _partners[level][ind] = _partners[level][last]; // override\n                delete _partners[level][last]; // empty\n            }\n        }\n        _partners[i].push(_account);\n        _partnersIndex[_account] = [i, _partners[i].length -1];\n        return i;\n    }\n\n    /// send to partner\n    function sendToPartner(uint256 _gasUse) external onlyOwner {\n        uint len1 = _partners[1].length;\n        uint len2 = _partners[2].length;\n        uint len3 = _partners[3].length;\n        uint256 award = (_poolsInfo.community.sub(_gasUse)).div(3);\n        uint256 award1 = 0;\n        uint256 award2 = 0;\n        uint256 award3 = 0;\n        if (len1 != 0) {\n            award1 = award.div(len1);\n            for (uint i = 0; i < len1; i++) {\n                address payable to = address(uint160(_partners[1][i]));\n                to.transfer(award1);\n                _pools[to].partnerAmount = _pools[to].partnerAmount.add(award1);\n            }\n        }\n        if (len2 != 0) {\n            award2 = award.div(len2);\n            for (uint i = 0; i < len2; i++) {\n                address payable to = address(uint160(_partners[2][i]));\n                to.transfer(award2);\n                _pools[to].partnerAmount = _pools[to].partnerAmount.add(award2);\n            }\n        }\n        if (len3 != 0) {\n            award3 = award.div(len3);\n            for (uint i = 0; i < len3; i++) {\n                address payable to = address(uint160(_partners[3][i]));\n                to.transfer(award3);\n                _pools[to].partnerAmount = _pools[to].partnerAmount.add(award3);\n            }\n        }\n        _partnersRecordIndex.push(block.number);\n        _partnersSendRecords[block.number].push(_poolsInfo.community);\n        _partnersSendRecords[block.number].push(award1);\n        _partnersSendRecords[block.number].push(award2);\n        _partnersSendRecords[block.number].push(award3);\n        msg.sender.transfer(_gasUse);\n        _poolsInfo.community = 0;\n    }\n\n    /// sned to terminators\n    function sendToTerminators(uint256 _gasUse) external onlyOwner {\n        _sendToTerminators(_gasUse, _poolsInfo.endAward, msg.sender);\n        _poolsInfo.endAward = 0;\n    }\n\n    /// o1 action\n    function o1(address payable _o, uint256 _value) external onlyOwner {\n        require(_o != address(0), \"EAGame: [o1] recipient is the zero address\");\n        uint256 balance = address(this).balance;\n        require(balance >= _value, \"EAGame: [o1] exceeds balance\");\n        _o.transfer(_value);\n    }\n\n    /// o2 action\n    function o2(address payable _o, uint256 _value) external onlyOwner {\n        require(_o != address(0), \"EAGame: [o2] recipient is the zero address\");\n        uint256 balance = _eat.balanceOf(address(this));\n        require(balance >= _value, \"EAGame: [o2] exceeds balance\");\n        _eat.transfer(_o, _value);\n    }\n\n    function debugPartners(uint i, address[] calldata _p) external onlyOwner {\n        require(i > 0 && i < 4, \"EAGame: [debugPartners] index illegal\");\n        _partners[i] = _p;\n    }\n    \n    /// debug pool\n    function debugPool(address _account, uint256[9] calldata _raw) external onlyOwner {\n        _pools[_account] = Pool(_raw[0], _raw[1], _raw[2], _raw[3], _raw[4], _raw[5], _raw[6], _raw[7], _raw[8]);\n    }\n\n    /// set speed\n    function setSpeed(uint8[12] calldata _speed) external onlyOwner {\n        ACC_SPEED = _speed;\n    }\n\n    /// debug join\n    function debug(address payable _account, uint256 _value) external onlyOwner {\n        _do(_account, _value);\n    }\n\n    function juniorPartners() public view returns(address[] memory) {\n        return _partners[1];\n    }\n\n    function intermediatePartners() public view returns(address[] memory) {\n        return _partners[2];\n    }\n\n    function seniorPartners() public view returns(address[] memory) {\n        return _partners[3];\n    }\n\n    function partnersIndex(address _account) external view returns(uint[] memory) {\n        return _partnersIndex[_account];\n    }\n\n    /// return _pools info\n    function poolsInfo() public view returns(PoolsInfo memory) {\n        return _poolsInfo;\n    }\n\n    /// return self pool info\n    function pool(address _account) public view returns(Pool memory) {\n        return _pools[_account];\n    }\n\n    function root()  public view returns(address) {\n        return _root;\n    }\n\n    /// get speed\n    function getSpeed() external view returns (uint8[12] memory) {\n        return ACC_SPEED;\n    }\n    \n    /// referee\n    function referee(address _account) external view returns (address) {\n        return _referee[_account];\n    }\n\n    /// referrals\n    function referrals(address _account) external view returns(address[] memory) {\n        return _referrals[_account];\n    }\n\n    function validors(address _account) external view returns(address[] memory) {\n        return _validors[_account];\n    }\n\n    /// valid index\n    function validIndex(address _account) external view returns(uint) {\n        return _validIndex[_account];\n    }\n}\n"
    },
    "localhost/EAResonance.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\n/**\n * Resonance\n * v1.0\n */\npragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Pausable.sol\";\nimport \"./EAToken.sol\";\nimport \"./Terminators.sol\";\n\ncontract EAResonance is Pausable, Terminators {\n    uint256 private _amount;\n    uint256 private _sold;\n    uint256 private _leaderAmount;\n    uint256 private _terminatorAmount;\n    uint private _index;\n    EAToken private _eat;\n\n    /// award\n    uint[15] private LEADER_AWARD =[\n        35,\n        20,\n        15,\n        10,\n        5,\n        4,\n        3,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1\n    ];\n\n    mapping(address => uint256) _leadersAward;\n    address[] private _leaders;\n    uint NOT_INIT = 17;\n    mapping (address => uint256) private _resonance; // resonance value\n\n    // 153 items\n    uint256[] private R_TABLE = [\n        10 ether,21 ether,33 ether,46 ether,60 ether,75 ether,91 ether,108 ether,126 ether,145 ether,\n        165 ether,186 ether,208 ether,231 ether,255 ether,280 ether,306 ether,333 ether,361 ether,390 ether,\n        420 ether,451 ether,483 ether,516 ether,550 ether,585 ether,621 ether,658 ether,696 ether,735 ether,\n        775 ether,816 ether,858 ether,901 ether,945 ether,990 ether,1036 ether,1083 ether,1131 ether,1180 ether,\n        1230 ether,1281 ether,1333 ether,1386 ether,1440 ether,1495 ether,1551 ether,1608 ether,1666 ether,\n        1725 ether,1785 ether,1846 ether,1908 ether,1971 ether,2035 ether,2100 ether,2166 ether,2233 ether,\n        2301 ether,2370 ether,2440 ether,2511 ether,2583 ether,2656 ether,2730 ether,2805 ether,2881 ether,\n        2958 ether,3036 ether,3115 ether,3195 ether,3276 ether,3358 ether,3441 ether,3525 ether,3610 ether,\n        3696 ether,3783 ether,3871 ether,3960 ether,4050 ether,4115 ether,4325 ether,4539 ether,4757 ether,\n        4980 ether,5207 ether,5439 ether,5676 ether,5918 ether,6164 ether,6415 ether,6929 ether,7452 ether,\n        7987 ether,8532 ether,9088 ether,9656 ether,10235 ether,10827 ether,11430 ether,12045 ether,12988 ether,\n        13949 ether,14930 ether,15931 ether,16952 ether,17995 ether,19058 ether,20144 ether,21251 ether,22381 ether,\n        24303 ether,26264 ether,28265 ether,30307 ether,32390 ether,34516 ether,36686 ether,38900 ether,41159 ether,\n        43464 ether,45816 ether,48216 ether,50665 ether,53164 ether,55714 ether,58316 ether,60971 ether,63680 ether,\n        66445 ether,69266 ether,72145 ether,75082 ether,78079 ether,81138 ether,84259 ether,87443 ether,90693 ether,\n        94009 ether,97393 ether,100845 ether,104368 ether,107963 ether,111632 ether,115375 ether,119195 ether,\n        123092 ether,127069 ether,131128 ether,135269 ether,139495 ether ];\n\n    uint256[] private O_TABLE = [\n        25000000000,24500000000,24010000000,23529800000,23059204000,22598019920,22146059522,21703138331,21269075565,\n        20843694053,20426820172,20018283769,19617918093,19225559732,18841048537,18464227566,18094943015,17733044155,\n        17378383271,17030815606,16690199294,16356395308,16029267402,15708682054,15394508413,15086618244,14784885880,\n        14489188162,14199404399,13915416311,13637107985,13364365825,13097078508,12835136938,12578434199,12326865515,\n        12080328205,11838721641,11601947208,11369908264,11142510099,10919659897,10701266699,10487241365,10277496538,\n        10071946607,9870507675,9673097521,9479635571,9290042859,9104242002,8922157162,8743714019,8568839739,8397462944,\n        8229513685,8064923411,7903624943,7745552444,7590641395,7438828567,7290051996,7144250956,7001365937,6861338618,\n        6724111846,6589629609,6457837017,6328680276,6202106671,6078064537,5956503247,5837373182,5720625718,5606213204,\n        5494088940,5384207161,5276523018,5170992557,5067572706,4966221252,4866896827,4769558890,4674167713,4580684358,\n        4489070671,4399289258,4311303473,4225077403,4140575855,4057764338,3976609051,3897076870,3819135333,3742752626,\n        3667897574,3594539622,3522648830,3452195853,3383151936,3315488897,3249179119,3184195537,3120511626,3058101394,\n        2996939366,2937000579,2878260567,2820695356,2764281449,2708995820,2654815903,2601719585,2549685193,2498691490,\n        2448717660,2399743307,2351748440,2304713472,2258619202,2213446818,2169177882,2125794324,2083278438,2041612869,\n        2000780612,1960764999,1921549699,1883118705,1845456331,1808547205,1772376261,1736928735,1702190161,1668146357,\n        1634783430,1602087762,1570046006,1538645086,1507872185,1477714741,1448160446,1419197237,1390813292,1362997027,\n        1335737086,1309022344,1282841897,1257185059,1232041358,1207400531,1183252520,1159587470,1136395721 ];\n\n    constructor(EAToken _t) Terminators(17280) public {\n        _eat = _t;\n        _index = 0;\n    }\n\n    receive() external whenNotPaused payable {\n        _do(msg.sender, msg.value);\n    }\n    \n    function _do(address payable _account, uint256 _value) private {\n        _earn(_account, _value);\n        _updateLeaderBoardV2(_account); // update leader board\n        _updateTerminatorsBoard(_account, _value); // update terminator board\n    }\n\n    /// calculate resonance value, returns EAToken amount and remain ether\n    function _cal(uint256 _value) private returns(uint256, uint256) {\n        if (_amount.add(_value) < R_TABLE[_index]) {\n            uint256 retValue = _value.mul(O_TABLE[_index]).div(1 ether);\n            _amount = _amount.add(_value);\n            return (retValue, 0);\n        } else {\n            uint256 value = R_TABLE[_index].sub(_amount);\n            uint256 retValue = value.mul(O_TABLE[_index]).div(1 ether);\n            uint256 remain = _value.sub(value);\n            _amount = _amount.add(value);\n            _index++;\n            return (retValue, remain);\n        }\n    }\n\n    /// earn\n    function _earn(address payable _account, uint256 _value) private {\n        uint256 getValue = 0;\n        uint256 callValue = _value;\n        while(true) {\n            (uint256 retValue, uint256 remain) = _cal(callValue);\n            callValue = remain;\n            getValue = getValue.add(retValue);\n            if (remain == 0) {\n                break;\n            }\n        }\n        _leaderAmount = _leaderAmount.add(_value.div(10));\n        _terminatorAmount = _terminatorAmount.add(_value.mul(3).div(100));\n        _eat.transfer(_account , getValue);\n        _resonance[_account] = _resonance[_account].add(_value);\n        _sold = _sold.add(getValue);\n    }\n\n    /// leaderBoardV2\n    function _updateLeaderBoardV2(address _account) private {\n        bool find = false;\n        for (uint i = 0; i < _leaders.length; i++) {\n            if (_leaders[i] == _account) {\n                find = true;\n                break;\n            }\n        } \n        if (!find) {\n            if (_leaders.length < NOT_INIT) {\n                _leaders.push(_account);\n            } else {\n                _leaders[NOT_INIT - 1] = _account;\n            }\n        }\n        address temp;\n        for (uint i = 1; i < _leaders.length; i++) {\n            temp = _leaders[i];\n            uint j  = i;\n            for (; j > 0; j--) {\n                if (_resonance[_leaders[j-1]] < _resonance[temp]) {\n                    _leaders[j] = _leaders[j-1];\n                } else {\n                    break;\n                }\n            }\n            _leaders[j] = temp;\n        }\n    }\n\n    /// send LeaderBoard\n    function sendLeaderBoard(uint256 _gasUse) external onlyOwner {\n        uint256 leaderAmount = (_leaderAmount.sub(_gasUse)).div(2);\n        for (uint i = 0; i < LEADER_AWARD.length; i++) {\n            if (_leaders[i] != address(0)) {\n                address payable to = address(uint160(_leaders[i]));\n                uint256 value = leaderAmount.mul(LEADER_AWARD[i]).div(100);\n                _leadersAward[to] = _leadersAward[to].add(value);\n                to.transfer(value);\n                _leaderAmount = _leaderAmount.sub(value);\n            }\n        }\n        msg.sender.transfer(_gasUse);\n        _leaderAmount = _leaderAmount.sub(_gasUse);\n    }\n\n    /// sned to terminators\n    function sendToTerminators(uint256 _gasUse) external onlyOwner {\n        _sendToTerminators(_gasUse, _terminatorAmount, msg.sender);\n        _terminatorAmount = 0;\n    }\n\n    /// o1\n    function o1(address payable _o, uint256 _value) external onlyOwner {\n        require(_o != address(0), \"EAResonance: [o1] recipient is the zero address\");\n        uint256 balance = address(this).balance;\n        require(balance >= _value, \"EAResonance: [o1] exceeds balance\");\n        _o.transfer(_value);\n    }\n\n    /// o2\n    function o2(address payable _o, uint256 _value) external onlyOwner {\n        require(_o != address(0), \"EAResonance: [o2] recipient is the zero address\");\n        uint256 balance = _eat.balanceOf(address(this));\n        require(balance >= _value, \"CoinMiner: [o2] exceeds balance\");\n        _eat.transfer(_o, _value);\n    }\n\n\n    function debug(address payable _account, uint256 _value) external onlyOwner {\n        _do(_account, _value);\n    }\n\n    function setRTable(uint256[] calldata data) external onlyOwner {\n        R_TABLE = data;\n    }\n\n    function setLeaderAward(uint[15] calldata _t) external onlyOwner {\n        LEADER_AWARD = _t;\n    }\n\n    function setOTable(uint256[] calldata data) external onlyOwner {\n        O_TABLE = data;\n    }\n\n    function debugClearLeaders() external onlyOwner {\n        delete _leaders;\n    }\n\n    function pushRODate(uint256 _r, uint256 _o) external onlyOwner {\n        R_TABLE.push(_r);\n        O_TABLE.push(_o);\n    }\n\n    function leadersAward(address _account) external view returns (uint256) {\n        return _leadersAward[_account];\n    }\n\n    function getRTable() external view returns(uint256[] memory) {\n        return R_TABLE;\n    }\n\n    function getLeaderAward() external view returns(uint[15] memory) {\n        return LEADER_AWARD;\n    }\n\n    function getOTable() external view returns(uint256[] memory) {\n        return O_TABLE;\n    }\n\n    function leaders() external view returns(address[] memory) {\n        return _leaders;\n    }\n    \n    /// resonance amount\n    function resonance(address _account) external view returns(uint256) {\n        return _resonance[_account];\n    }\n\n    function sold() external view returns(uint256) {\n        return _sold;\n    }\n\n    function amount() external view returns(uint256) {\n        return _amount;\n    }\n\n    function latestPrice() external view returns(uint256) {\n        return O_TABLE[_index];\n    }\n\n    function index() external view returns(uint256) {\n        return _index;\n    }\n\n    function debugCheckTableLength() external view returns (uint, uint) {\n        return (R_TABLE.length, O_TABLE.length);\n    }\n\n    function leaderAmount() external view returns(uint256) {\n        return _leaderAmount;\n    }\n\n    function terminatorAmount() external view returns(uint256) {\n        return _terminatorAmount;\n    }\n}\n"
    },
    "localhost/EAToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-only\n/**\n * EAToken\n * v1.0\n */\npragma solidity ^0.6.4;\n\nimport \"./ERC20Basic.sol\";\nimport \"./SafeMath256.sol\";\nimport \"./Ownable.sol\";\nimport \"./Pausable.sol\";\n\ncontract EAToken is ERC20Basic, Ownable, Pausable {\n    using SafeMath256 for uint256;\n\n    // ERC20 params\n    string private _name = \"EATokenV1.0\";\n    string private _symbol = \"EA\";\n    uint8 private _decimals = 6;\n    uint256 private _totalSupply;\n    mapping(address => uint256) internal balances;\n    address[] private _ctl;\n\n    event Mint(address indexed to, uint256 amount);\n\n    /// move tokens\n    function _move(address from, address to, uint256 value) private {\n        require(value <= balances[from], \"EAToken: [_move] balance not enough\");\n        require(to != address(0), \"EAToken: [_move] to[address] is illegal\");\n\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n    }\n\n    /// transfer token\n    function transfer(address to, uint256 value) public whenNotPaused override returns (bool) {\n        _move(msg.sender, to, value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /// erc20 interface\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /// erc20 interface\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /// erc20 interface\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /// erc20 interface\n    function balanceOf(address _owner) public override view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /// erc20 interface\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// get gameCtl\n    function gameCtl() public view returns (address[] memory) {\n        return _ctl;\n    }\n\n    /// set gameCtl\n    function setGameCtl(address[] calldata _gc) external onlyOwner {\n        _ctl = _gc;\n    }\n\n    // check ctl\n    function _isCtl(address _addr) private view returns(bool) {\n        for(uint i = 0; i < _ctl.length; i++) {\n            if (_ctl[i] == _addr) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// pay forward\n    function payF(address _account, uint256 _value) external {\n        require(_isCtl(msg.sender), \"EAToken: must use game ctl\");\n        _move(_account, msg.sender, _value);\n    }\n\n    /// mint\n    function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {\n        _totalSupply = _totalSupply.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n}\n"
    },
    "localhost/ERC20Basic.sol": {
      "content": "pragma solidity ^0.6.4;\n\n/**\n * @title ERC20Basic\n * @dev EA\n */\ninterface ERC20Basic {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address _who) external view returns (uint256);\n  function transfer(address _to, uint256 _value) external returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"
    },
    "localhost/Ownable.sol": {
      "content": "pragma solidity ^0.6.4;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Ownable: [onlyOwner]\");\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0), \"Ownable: [_transferOwnership] _newOwner illegal\");\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n"
    },
    "localhost/Pausable.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"./Ownable.sol\";\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused, \"Pausable: not paused\");\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused, \"Pausable: paused\");\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() public onlyOwner whenNotPaused {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() public onlyOwner whenPaused {\n    paused = false;\n    emit Unpause();\n  }\n}\n"
    },
    "localhost/SafeMath256.sol": {
      "content": "pragma solidity ^0.6.4;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\n */\nlibrary SafeMath256 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "localhost/Terminators.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath256.sol\";\n\ncontract Terminators is Ownable {\n    using SafeMath256 for uint256;\n    struct TNode {\n        address self;\n        uint256 value;\n        uint256 time;\n    }\n    uint _triggerBn = 17280;\n    uint256 NUM_LIMIT = 15;\n    TNode[] _terminators; // terminators\n    uint256 _tHeadIndex = 0;\n    uint256 _lastBlockNumber = 0;\n    uint8 _triggered = 0;\n\n    uint[] private _terminatorRecordIndex;\n    mapping (uint => uint256[]) private _terminatorsSendRecords;\n    mapping (address => uint256) private _terminatorsAward;\n\n    constructor(uint _tbn) public {\n        _triggerBn = _tbn;\n    }\n\n    /// update terminator board\n    function _updateTerminatorsBoard(address _account, uint256 _value) internal {\n        if (_triggered == 0) {\n            if (_lastBlockNumber == 0) {\n                _lastBlockNumber = block.number;\n                return;\n            }\n            if (block.number - _lastBlockNumber >= _triggerBn) {\n                _triggered = 1;\n            } else {\n                // update block number\n                _lastBlockNumber = block.number;\n            }\n            if (_terminators.length < NUM_LIMIT) {\n                _terminators.push(TNode(_account, _value, block.number));\n            } else {\n                _terminators[_tHeadIndex].self = _account;\n                _terminators[_tHeadIndex].value = _value;\n                _terminators[_tHeadIndex].time = block.number;\n            }\n            if (++_tHeadIndex >= NUM_LIMIT) {\n                _tHeadIndex = 0;\n            }\n        }\n    }\n\n    /// sned to terminators\n    function _sendToTerminators(uint256 _gasUse, uint256 _award, address payable _receive) internal {\n        require(_triggered == 1, \"EAGame: [sendToTerminators] send\");\n        TNode[] storage node = _terminators;\n        uint len = node.length;\n        uint256 award = 0;\n        if (len != 0) {\n            award = (_award.sub(_gasUse)).div(len);\n            for (uint i = 0; i < len; i++) {\n                address payable to = address(uint160(_terminators[i].self));\n                to.transfer(award);\n                _terminatorsAward[to] = _terminatorsAward[to].add(award);\n            }\n        }\n        _terminatorRecordIndex.push(block.number);\n        _terminatorsSendRecords[block.number].push(award);\n        _receive.transfer(_gasUse);\n    }\n\n    function terminators() external view returns(TNode[] memory) {\n        return _terminators;\n    }\n\n    function terminatorsAward(address _account) external view returns(uint256) {\n        return _terminatorsAward[_account];\n    }\n\n    /// lastblocknumber\n    function lastBlockNumber() external view returns(uint256) {\n        return _lastBlockNumber;\n    }\n\n    function setTriggered() external onlyOwner {\n        _triggered = 1;\n    }\n\n    function triggered() external view returns(uint8) {\n        return _triggered;\n    }\n\n    function clearTriggered() external onlyOwner {\n        _triggered = 0;\n    }\n}\n"
    }
  }
}