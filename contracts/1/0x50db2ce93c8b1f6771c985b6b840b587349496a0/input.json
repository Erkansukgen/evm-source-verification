{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/contracts/StafiBase.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"./interfaces/storage/IStafiStorage.sol\";\n\nabstract contract StafiBase {\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    IStafiStorage stafiStorage = IStafiStorage(0);\n\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.trusted\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered staking pool\n    */\n    modifier onlyRegisteredStakingPool(address _stakingPoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"stakingpool.exists\", _stakingPoolAddress))), \"Invalid staking pool\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(roleHas(\"owner\", msg.sender), \"Account is not the owner\");\n        _;\n    }\n\n\n    /**\n    * @dev Modifier to scope access to admins\n    */\n    modifier onlyAdmin() {\n        require(roleHas(\"admin\", msg.sender), \"Account is not an admin\");\n        _;\n    }\n\n\n    /**\n    * @dev Modifier to scope access to admins\n    */\n    modifier onlySuperUser() {\n        require(roleHas(\"owner\", msg.sender) || roleHas(\"admin\", msg.sender), \"Account is not a super user\");\n        _;\n    }\n\n\n    /**\n    * @dev Reverts if the address doesn't have this role\n    */\n    modifier onlyRole(string memory _role) {\n        require(roleHas(_role, msg.sender), \"Account does not match the specified role\");\n        _;\n    }\n\n\n    /// @dev Set the main Storage address\n    constructor(address _stafiStorageAddress) public {\n        // Update the contract address\n        stafiStorage = IStafiStorage(_stafiStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(keccak256(abi.encodePacked(contractName)) != keccak256(abi.encodePacked(\"\")), \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return stafiStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint256) { return stafiStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return stafiStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return stafiStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return stafiStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int256) { return stafiStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return stafiStorage.getBytes32(_key); }\n    function getAddressS(string memory _key) internal view returns (address) { return stafiStorage.getAddress(keccak256(abi.encodePacked(_key))); }\n    function getUintS(string memory _key) internal view returns (uint256) { return stafiStorage.getUint(keccak256(abi.encodePacked(_key))); }\n    function getStringS(string memory _key) internal view returns (string memory) { return stafiStorage.getString(keccak256(abi.encodePacked(_key))); }\n    function getBytesS(string memory _key) internal view returns (bytes memory) { return stafiStorage.getBytes(keccak256(abi.encodePacked(_key))); }\n    function getBoolS(string memory _key) internal view returns (bool) { return stafiStorage.getBool(keccak256(abi.encodePacked(_key))); }\n    function getIntS(string memory _key) internal view returns (int256) { return stafiStorage.getInt(keccak256(abi.encodePacked(_key))); }\n    function getBytes32S(string memory _key) internal view returns (bytes32) { return stafiStorage.getBytes32(keccak256(abi.encodePacked(_key))); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { stafiStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint256 _value) internal { stafiStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { stafiStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { stafiStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { stafiStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int256 _value) internal { stafiStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { stafiStorage.setBytes32(_key, _value); }\n    function setAddressS(string memory _key, address _value) internal { stafiStorage.setAddress(keccak256(abi.encodePacked(_key)), _value); }\n    function setUintS(string memory _key, uint256 _value) internal { stafiStorage.setUint(keccak256(abi.encodePacked(_key)), _value); }\n    function setStringS(string memory _key, string memory _value) internal { stafiStorage.setString(keccak256(abi.encodePacked(_key)), _value); }\n    function setBytesS(string memory _key, bytes memory _value) internal { stafiStorage.setBytes(keccak256(abi.encodePacked(_key)), _value); }\n    function setBoolS(string memory _key, bool _value) internal { stafiStorage.setBool(keccak256(abi.encodePacked(_key)), _value); }\n    function setIntS(string memory _key, int256 _value) internal { stafiStorage.setInt(keccak256(abi.encodePacked(_key)), _value); }\n    function setBytes32S(string memory _key, bytes32 _value) internal { stafiStorage.setBytes32(keccak256(abi.encodePacked(_key)), _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { stafiStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { stafiStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { stafiStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { stafiStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { stafiStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { stafiStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { stafiStorage.deleteBytes32(_key); }\n    function deleteAddressS(string memory _key) internal { stafiStorage.deleteAddress(keccak256(abi.encodePacked(_key))); }\n    function deleteUintS(string memory _key) internal { stafiStorage.deleteUint(keccak256(abi.encodePacked(_key))); }\n    function deleteStringS(string memory _key) internal { stafiStorage.deleteString(keccak256(abi.encodePacked(_key))); }\n    function deleteBytesS(string memory _key) internal { stafiStorage.deleteBytes(keccak256(abi.encodePacked(_key))); }\n    function deleteBoolS(string memory _key) internal { stafiStorage.deleteBool(keccak256(abi.encodePacked(_key))); }\n    function deleteIntS(string memory _key) internal { stafiStorage.deleteInt(keccak256(abi.encodePacked(_key))); }\n    function deleteBytes32S(string memory _key) internal { stafiStorage.deleteBytes32(keccak256(abi.encodePacked(_key))); }\n\n\n    /**\n    * @dev Check if an address has this role\n    */\n    function roleHas(string memory _role, address _address) internal view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"access.role\", _role, _address)));\n    }\n\n}\n"
    },
    "localhost/contracts/deposit/StafiNodeDeposit.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../StafiBase.sol\";\nimport \"../interfaces/deposit/IStafiNodeDeposit.sol\";\nimport \"../interfaces/deposit/IStafiUserDeposit.sol\";\nimport \"../interfaces/node/IStafiNodeManager.sol\";\nimport \"../interfaces/pool/IStafiStakingPool.sol\";\nimport \"../interfaces/pool/IStafiStakingPoolManager.sol\";\nimport \"../interfaces/settings/IStafiStakingPoolSettings.sol\";\nimport \"../types/DepositType.sol\";\n\n// Handles node deposits and staking pool creation\ncontract StafiNodeDeposit is StafiBase, IStafiNodeDeposit {\n\n    // Events\n    event DepositReceived(address indexed from, uint256 amount, uint256 time);\n\n    // Construct\n    constructor(address _stafiStorageAddress) StafiBase(_stafiStorageAddress) public {\n        version = 1;\n         // Initialize settings on deployment\n        if (!getBoolS(\"settings.node.deposit.init\")) {\n            // Apply settings\n            setDepositEnabled(true);\n            setCurrentNodeDepositAmount(8 ether);\n            // Settings initialized\n            setBoolS(\"settings.node.deposit.init\", true);\n        }\n    }\n\n    // Accept a node deposit and create a new staking pool under the node\n    function deposit() override external payable onlyLatestContract(\"stafiNodeDeposit\", address(this)) {\n        // Check node settings\n        require(getDepositEnabled(), \"Node deposits are currently disabled\");\n        require(msg.value == getCurrentNodeDepositAmount(), \"Invalid node deposit amount\");\n        // Load contracts\n        IStafiUserDeposit stafiUserDeposit = IStafiUserDeposit(getContractAddress(\"stafiUserDeposit\"));\n        IStafiStakingPoolManager stafiStakingPoolManager = IStafiStakingPoolManager(getContractAddress(\"stafiStakingPoolManager\"));\n        IStafiStakingPoolSettings stafiStakingPoolSettings = IStafiStakingPoolSettings(getContractAddress(\"stafiStakingPoolSettings\"));\n        // Get deposit type by node deposit amount\n        DepositType depositType = DepositType.None;\n        if (msg.value == stafiStakingPoolSettings.getFourDepositNodeAmount()) { depositType = DepositType.FOUR; }\n        else if (msg.value == stafiStakingPoolSettings.getEightDepositNodeAmount()) { depositType = DepositType.EIGHT; }\n        else if (msg.value == stafiStakingPoolSettings.getTwelveDepositNodeAmount()) { depositType = DepositType.TWELVE; }\n        else if (msg.value == stafiStakingPoolSettings.getSixteenDepositNodeAmount()) { depositType = DepositType.SIXTEEN; }\n        // Check deposit type\n        require(depositType != DepositType.None, \"Invalid node deposit amount\");\n        // Emit deposit received event\n        emit DepositReceived(msg.sender, msg.value, now);\n        // Register the node\n        IStafiNodeManager stafiNodeManager = IStafiNodeManager(getContractAddress(\"stafiNodeManager\"));\n        stafiNodeManager.registerNode(msg.sender);\n        // Create staking pool\n        address stakingPoolAddress = stafiStakingPoolManager.createStakingPool(msg.sender, depositType);\n        IStafiStakingPool stakingPool = IStafiStakingPool(stakingPoolAddress);\n        // Transfer deposit to staking pool\n        stakingPool.nodeDeposit{value: msg.value}();\n        // Assign deposits if enabled\n        stafiUserDeposit.assignDeposits();\n    }\n\n    // Node deposits currently enabled\n    function getDepositEnabled() public view returns (bool) {\n        return getBoolS(\"settings.node.deposit.enabled\");\n    }\n    function setDepositEnabled(bool _value) public onlySuperUser {\n        setBoolS(\"settings.node.deposit.enabled\", _value);\n    }\n\n    // Node deposits currently amount\n    function getCurrentNodeDepositAmount() public view returns (uint256) {\n        return getUint(\"settings.node.deposit.amount\");\n    }\n    function setCurrentNodeDepositAmount(uint256 _value) public onlySuperUser {\n        IStafiStakingPoolSettings stafiStakingPoolSettings = IStafiStakingPoolSettings(getContractAddress(\"stafiStakingPoolSettings\"));\n        require(_value == stafiStakingPoolSettings.getFourDepositNodeAmount()\n            || _value == stafiStakingPoolSettings.getEightDepositNodeAmount()\n            || _value == stafiStakingPoolSettings.getTwelveDepositNodeAmount()\n            || _value == stafiStakingPoolSettings.getSixteenDepositNodeAmount()\n            , \"Invalid node deposit amount\");\n        setUint(\"settings.node.deposit.amount\", _value);\n    }\n\n}\n"
    },
    "localhost/contracts/interfaces/deposit/IStafiNodeDeposit.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiNodeDeposit {\n    function deposit() external payable;\n}\n"
    },
    "localhost/contracts/interfaces/deposit/IStafiUserDeposit.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiUserDeposit {\n    function getBalance() external view returns (uint256);\n    function getExcessBalance() external view returns (uint256);\n    function deposit() external payable;\n    function recycleDissolvedDeposit() external payable;\n    function recycleWithdrawnDeposit() external payable;\n    function assignDeposits() external;\n    function withdrawExcessBalance(uint256 _amount) external;\n}\n"
    },
    "localhost/contracts/interfaces/node/IStafiNodeManager.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiNodeManager {\n    function getNodeCount() external view returns (uint256);\n    function getNodeAt(uint256 _index) external view returns (address);\n    function getTrustedNodeCount() external view returns (uint256);\n    function getTrustedNodeAt(uint256 _index) external view returns (address);\n    function getNodeExists(address _nodeAddress) external view returns (bool);\n    function getNodeTrusted(address _nodeAddress) external view returns (bool);\n    function registerNode(address _nodeAddress) external;\n    function setNodeTrusted(address _nodeAddress, bool _trusted) external;\n}\n"
    },
    "localhost/contracts/interfaces/pool/IStafiStakingPool.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/DepositType.sol\";\nimport \"../../types/StakingPoolStatus.sol\";\n\ninterface IStafiStakingPool {\n    function getStatus() external view returns (StakingPoolStatus);\n    function getStatusBlock() external view returns (uint256);\n    function getStatusTime() external view returns (uint256);\n    function getDepositType() external view returns (DepositType);\n    function getNodeAddress() external view returns (address);\n    function getNodeFee() external view returns (uint256);\n    function getNodeDepositBalance() external view returns (uint256);\n    function getNodeRefundBalance() external view returns (uint256);\n    function getNodeDepositAssigned() external view returns (bool);\n    function getNodeCommonlyRefunded() external view returns (bool);\n    function getNodeTrustedRefunded() external view returns (bool);\n    function getUserDepositBalance() external view returns (uint256);\n    function getUserDepositAssigned() external view returns (bool);\n    function getUserDepositAssignedTime() external view returns (uint256);\n    function getPlatformDepositBalance() external view returns (uint256);\n    function nodeDeposit() external payable;\n    function userDeposit() external payable;\n    function stake(bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external;\n    function refund() external;\n    function dissolve() external;\n    function close() external;\n}\n"
    },
    "localhost/contracts/interfaces/pool/IStafiStakingPoolManager.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/DepositType.sol\";\n\ninterface IStafiStakingPoolManager {\n    function getStakingPoolCount() external view returns (uint256);\n    function getStakingPoolAt(uint256 _index) external view returns (address);\n    function getNodeStakingPoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingPoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getNodeValidatingStakingPoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeValidatingStakingPoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getStakingPoolByPubkey(bytes calldata _pubkey) external view returns (address);\n    function getStakingPoolExists(address _stakingPoolAddress) external view returns (bool);\n    function getStakingPoolPubkey(address _stakingPoolAddress) external view returns (bytes memory);\n    function getStakingPoolWithdrawalProcessed(address _stakingPoolAddress) external view returns (bool);\n    function createStakingPool(address _nodeAddress, DepositType _depositType) external returns (address);\n    function destroyStakingPool() external;\n    function setStakingPoolPubkey(bytes calldata _pubkey) external;\n    function setStakingPoolWithdrawalProcessed(address _stakingPoolAddress, bool _processed) external;\n}\n"
    },
    "localhost/contracts/interfaces/settings/IStafiStakingPoolSettings.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/DepositType.sol\";\n\ninterface IStafiStakingPoolSettings {\n    function getLaunchBalance() external view returns (uint256);\n    function getDepositNodeAmount(DepositType _depositType) external view returns (uint256);\n    function getFourDepositNodeAmount() external view returns (uint256);\n    function getEightDepositNodeAmount() external view returns (uint256);\n    function getTwelveDepositNodeAmount() external view returns (uint256);\n    function getSixteenDepositNodeAmount() external view returns (uint256);\n    function getDepositUserAmount(DepositType _depositType) external view returns (uint256);\n    function getLaunchTimeout() external view returns (uint256);\n    function getStakingPoolRefundedEnabled(address _stakingPoolAddress) external view returns (bool);\n    function getStakingPoolTrustedRefundedEnabled(address _stakingPoolAddress) external view returns (bool);\n}\n"
    },
    "localhost/contracts/interfaces/storage/IStafiStorage.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiStorage {\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n}\n"
    },
    "localhost/contracts/types/DepositType.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// Represents the type of deposits\nenum DepositType {\n    None,    // Marks an invalid deposit type\n    FOUR,    // Require 4 ETH from the node operator to be matched with 28 ETH from user deposits\n    EIGHT,   // Require 8 ETH from the node operator to be matched with 24 ETH from user deposits\n    TWELVE,  // Require 12 ETH from the node operator to be matched with 20 ETH from user deposits\n    SIXTEEN  // Require 16 ETH from the node operator to be matched with 16 ETH from user deposits\n}\n"
    },
    "localhost/contracts/types/StakingPoolStatus.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// Represents a stakingpool's status within the network\nenum StakingPoolStatus {\n    Initialized,    // The stakingpool has been initialized and is awaiting a deposit of user ETH\n    Prelaunch,      // The stakingpool has enough ETH to begin staking and is awaiting launch by the node\n    Staking,        // The stakingpool is currently staking\n    Withdrawn,   // The stakingpool has been withdrawn from by the node\n    Dissolved       // The stakingpool has been dissolved and its user deposited ETH has been returned to the deposit pool\n}\n"
    }
  }
}