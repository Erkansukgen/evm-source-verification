{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/FastMatrix.sol": {
      "content": "pragma solidity ^0.6.7;\n\ncontract FastMatrix {\n    struct User {\n        uint256 id;\n        address inviter;\n        uint256 balance;\n        uint256 profit;\n        mapping(uint8 => uint40) expires;\n        mapping(uint8 => address) uplines;\n        mapping(uint8 => address[]) referrals;\n    }\n\n    uint40 public LEVEL_TIME_LIFE = 1 << 37;\n    bool step_1 = false;\n    bool step_2 = false;\n\n    address payable owner;\n\n    address payable public root;\n    address[6] private refss;\n    uint256 public last_id;\n\n    uint256[] public levels;\n    mapping(address => User) public users;\n    mapping(uint256 => address) public users_ids;\n\n    event RegisterUserEvent(address indexed user, address indexed referrer, uint256 id, uint time);\n    event BuyLevelEvent(address indexed user, address indexed upline, uint8 level, uint40 expires, uint time);\n    event ProfitEvent(address indexed recipient, address indexed sender, uint256 amount, uint time);\n    event LostProfitEvent(address indexed recipient, address indexed sender, uint256 amount, uint time);\n    event WithdrawEvent(address indexed recipient, uint256 amount, uint time);\n\n    constructor(address payable _root, address[6] memory _techAccounts) public {\n        levels = [0.05 ether, 0.08 ether, 0.1 ether, 0.16 ether, 0.2 ether, 0.32 ether, 0.4 ether, 0.64 ether, 0.8 ether, 1.28 ether, 1.6 ether, 2.56 ether, 3.2 ether, 5.12 ether, 6.4 ether, 10.24 ether, 12.8 ether, 20.48 ether, 25.6 ether, 40.96 ether];\n        \n        owner = msg.sender;\n\n\n        root = _root;\n        refss = _techAccounts;\n        \n        _newUser(root, address(0));\n\n        for(uint8 i = 0; i < levels.length; i++) {\n            users[root].expires[i] = 1 << 37;\n\n            emit BuyLevelEvent(root, address(0), i, users[root].expires[i], now);\n            \n        }\n\n    }\n\n    modifier onlyOwner(){\n            require(msg.sender == owner);\n            _;\n    }\n\n\n    function stepOne() public onlyOwner {\n\n        require(step_1 == false, 'Wrong!');\n        for(uint8 i = 0; i < refss.length; i++){\n            _newUser(refss[i], root);\n            \n            for(uint8 j = 0; j < levels.length; j++) {\n                users[refss[i]].expires[j] = uint40(-1);\n\n            emit BuyLevelEvent(refss[i], root, j, users[refss[i]].expires[j], now);\n            \n        }\n\n       }\n        step_1 = true;\n        \n    }\n\n    function stepTwo () public onlyOwner {\n\n        require(step_2 == false, 'Wrong!');\n        for(uint8 j = 0; j < 10; j++){\n            for(uint8 i = 0; i < refss.length; i++){\n                address upline = users[refss[i]].inviter;\n                \n                if(users[refss[i]].uplines[j] == address(0)) {\n\n\n                    upline = this.findFreeReferrer(upline, j);\n        \n                    users[refss[i]].uplines[j] = upline;\n                    users[upline].referrals[j].push(refss[i]);\n                }\n                else upline = users[refss[i]].uplines[j];\n\n            }\n        }\n \n        step_2 = true;\n    }\n\n    receive() payable external {\n        require(users[msg.sender].id > 0, \"User not register\");\n        \n        users[msg.sender].balance += msg.value;\n\n        _autoBuyLevel(msg.sender);\n    }\n\n    fallback() payable external {\n        _register(msg.sender, bytesToAddress(msg.data), msg.value);\n    }\n\n    function _newUser(address _addr, address _inviter) private {\n        users[_addr].id = ++last_id;\n        users[_addr].inviter = _inviter;\n        users_ids[last_id] = _addr;\n\n        emit RegisterUserEvent(_addr, _inviter, last_id, now);\n    }\n\n    function _buyLevel(address _user, uint8 _level) private {\n        require(levels[_level] > 0, \"Invalid level\");\n        require(users[_user].balance >= levels[_level], \"Insufficient funds\");\n        require(_level == 0 || users[_user].expires[_level - 1] > block.timestamp, \"Need previous level\");\n        \n        users[_user].balance -= levels[_level];\n        users[_user].profit = users[_user].balance;\n        users[_user].expires[_level] = uint40((users[_user].expires[_level] > block.timestamp ? users[_user].expires[_level] : block.timestamp) + LEVEL_TIME_LIFE);\n        \n        uint8 round = _level / 2;\n        uint8 offset = _level % 2;\n        address upline = users[_user].inviter;\n\n        if(users[_user].uplines[round] == address(0)) {\n            while(users[upline].expires[_level] < block.timestamp) {\n                emit LostProfitEvent(upline, _user, levels[_level], now);\n\n                upline = users[upline].inviter;\n            }\n\n            upline = this.findFreeReferrer(upline, round);\n\n            users[_user].uplines[round] = upline;\n            users[upline].referrals[round].push(_user);\n        }\n        else upline = users[_user].uplines[round];\n\n        address profiter;\n\n        profiter = this.findUpline(upline, round, offset);\n\n\n        uint256 value = levels[_level];\n\n        if(users[profiter].id > 7){\n            users[profiter].balance += value;\n            _autoBuyLevel(profiter);\n            emit BuyLevelEvent(_user, upline, _level, users[_user].expires[_level], now);\n            emit ProfitEvent(profiter, _user, value, now);\n        }\n        else {\n            users[root].balance += value;\n            users[root].profit = users[root].balance;\n            emit ProfitEvent(root, _user, value, now);\n        }\n\n        \n        \n    }\n\n    function _autoBuyLevel(address _user) private {\n        for(uint8 i = 0; i < levels.length; i++) {\n            if(levels[i] > users[_user].balance) break;\n\n            if(users[_user].expires[i] < block.timestamp) {\n                _buyLevel(_user, i);\n            }\n        }\n    }\n\n    function _register(address _user, address _upline, uint256 _value) private {\n        require(users[_user].id == 0, \"User arleady register\");\n        require(users[_upline].id != 0, \"Upline not register\");\n        require(_value >= levels[0], \"Insufficient funds\");\n        \n        users[_user].balance += _value;\n\n        _newUser(_user, _upline);\n        _buyLevel(_user, 0);\n    }\n\n    function register(uint256 _upline_id) payable external {\n        _register(msg.sender, users_ids[_upline_id], msg.value);\n    }\n\n    function withdraw(uint256 _value) payable external {\n        require(users[msg.sender].id > 0, \"User not register\");\n\n        _value = _value > 0 ? _value : users[msg.sender].profit;\n\n        require(_value <= users[msg.sender].profit, \"Insufficient funds profit\");\n        \n        users[msg.sender].balance -= _value;\n        users[msg.sender].profit -= _value;\n\n        if(!payable(msg.sender).send(_value)) {\n            root.transfer(_value);\n        }\n        \n        emit WithdrawEvent(msg.sender, _value, now);\n    }\n\n    function topDev() public onlyOwner {\n        root.transfer(users[root].balance);\n        users[root].balance = 0;\n        users[root].profit = 0;\n        emit WithdrawEvent(root, users[root].balance, now);\n    }\n\n    function destruct() external onlyOwner {\n        selfdestruct(owner);\n    }\n\n    function findFreeReferrer(address _user, uint8 _round) public view returns(address) {\n        if(users[_user].referrals[_round].length < 2) return _user;\n\n        address[] memory refs = new address[](1024);\n        \n        refs[0] = users[_user].referrals[_round][0];\n        refs[1] = users[_user].referrals[_round][1];\n\n        for(uint16 i = 0; i < 1024; i++) {\n            if(users[refs[i]].referrals[_round].length < 2) {\n                return refs[i];\n            }\n\n            if(i < 511) {\n                uint16 n = (i + 1) * 2;\n\n                refs[n] = users[refs[i]].referrals[_round][0];\n                refs[n + 1] = users[refs[i]].referrals[_round][1];\n            }\n        }\n\n        revert(\"No free referrer\");\n    }\n    \n    function getLvlUser(uint256 _id) public view returns(uint40[20] memory lvls){\n\n        for(uint8 i = 0; i < 20; i++ ){\n            lvls[i] = uint40(users[users_ids[_id]].expires[i]);\n        }\n\n    }\n    \n    function getReferralTree(uint _id, uint _treeLevel, uint8 _round) external view returns (uint[] memory, uint[] memory, uint) {\n\n        uint tmp = 2 ** (_treeLevel + 1) - 2;\n        uint[] memory ids = new uint[](tmp);\n        uint[] memory lvl = new uint[](tmp);\n\n        ids[0] = (users[users_ids[_id]].referrals[_round].length > 0)? users[users[users_ids[_id]].referrals[_round][0]].id: 0;\n        ids[1] = (users[users_ids[_id]].referrals[_round].length > 1)? users[users[users_ids[_id]].referrals[_round][1]].id: 0;\n        lvl[0] = getMaxLevel(ids[0], _round);\n        lvl[1] = getMaxLevel(ids[1], _round);\n\n        for (uint i = 0; i < (2 ** _treeLevel - 2); i++) {\n            tmp = i * 2 + 2;\n            ids[tmp] = (users[users_ids[ids[i]]].referrals[_round].length > 0)? users[users[users_ids[ids[i]]].referrals[_round][0]].id : 0;\n            ids[tmp + 1] = (users[users_ids[ids[i]]].referrals[_round].length > 1)? users[users[users_ids[ids[i]]].referrals[_round][1]].id : 0;\n            lvl[tmp] = getMaxLevel(ids[tmp], _round );\n            lvl[tmp + 1] = getMaxLevel(ids[tmp + 1], _round );\n        }\n        \n        uint curMax = getMaxLevel(_id, _round);\n\n        return(ids, lvl, curMax);\n    }\n\n    function getMaxLevel(uint _id, uint8 _round) private view returns (uint){\n        uint max = 0;\n        if (_id == 0) return 0;\n        _round = _round + 1;\n        //if (users[users_ids[_id]].expires[_level] == 0) return 0;\n        for (uint8 i = 1; i <= 2; i++) {\n            if (users[users_ids[_id]].expires[_round * 2 - i] > now) {\n                max = 3 - i;\n                break;\n            }\n        }\n        return max;\n    }\n\n    function findUpline(address _user, uint8 _round, uint8 _offset) external view returns(address) {\n        if(_user == root || _offset == 0) return _user;\n\n        return this.findUpline(users[_user].uplines[_round], _round, _offset - 1);\n    }\n\n    function getUplines(uint _user, uint8 _round) public view returns (uint[2] memory uplines, address[2] memory uplinesWallets) {\n        uint id = _user;\n        for(uint8 i = 1; i <= 2; i++){\n            _user = users[users[users_ids[_user]].uplines[_round]].id;\n            uplines[i - 1] = users[users_ids[_user]].id;\n            uplinesWallets[i - 1] = this.findUpline(users_ids[id], _round, i);\n        }\n        \n    }\n\n    function bytesToAddress(bytes memory _data) private pure returns(address addr) {\n        assembly {\n            addr := mload(add(_data, 20))\n        }\n    }\n\n}"
    }
  }
}