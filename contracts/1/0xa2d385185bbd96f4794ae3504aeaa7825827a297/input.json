{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":999999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ValueLiquid-newcore/OracleMultiPair.sol":{"content":"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\n\npragma solidity 0.7.6;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IOracle {\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function updateCumulative() external;\n\n    function update() external;\n\n    function consult(address _token, uint256 _amountIn) external view returns (uint144 _amountOut);\n\n    function consultDollarPrice(address _sideToken, uint256 _amountIn) external view returns (uint256 _dollarPrice);\n\n    function twap(uint256 _amountIn) external view returns (uint144 _amountOut);\n\n    function twapDollarPrice(address _sideToken, uint256 _amountIn) external view returns (uint256 _amountOut);\n}\n\ninterface IValueLiquidFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint256);\n\n    function feeTo() external view returns (address);\n\n    function formula() external view returns (address);\n\n    function protocolFee() external view returns (uint256);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function isPair(address) external view returns (bool);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        uint32 tokenWeightA,\n        uint32 swapFee\n    ) external returns (address pair);\n\n    function getWeightsAndSwapFee(address pair)\n        external\n        view\n        returns (\n            uint32 tokenWeight0,\n            uint32 tokenWeight1,\n            uint32 swapFee\n        );\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setProtocolFee(uint256) external;\n}\n\ninterface IValueLiquidPair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n    function getSwapFee() external view returns (uint32);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(\n        address,\n        address,\n        uint32,\n        uint32\n    ) external;\n}\n\ninterface IEpochController {\n    function epoch() external view returns (uint256);\n\n    function nextEpochPoint() external view returns (uint256);\n\n    function nextEpochLength() external view returns (uint256);\n\n    function nextEpochAllocatedReward(address _pool) external view returns (uint256);\n}\n\ninterface IAggregatorInterface {\n    function latestAnswer() external view returns (int256);\n}\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n\nlibrary Babylonian {\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\n    uint256 private constant Q224 = Q112 << RESOLUTION;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112(self._x / uint224(x));\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z;\n        require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\n        return uq144x112(z);\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // equivalent to encode(numerator).div(denominator)\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // take the reciprocal of a UQ112x112\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n    }\n}\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n\n// fixed window oracle that recomputes the average price for the entire epochPeriod once every epochPeriod\n// note that the price average is only guaranteed to be over at least 1 epochPeriod, but may be over a longer epochPeriod\ncontract OracleMultiPair is Ownable, IOracle {\n    using FixedPoint for *;\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // governance\n    address public operator;\n    address public factory;\n\n    uint256 public oracleReserveMinimum; // $10k\n\n    // epoch\n    address public epochController;\n    uint256 public maxEpochPeriod;\n\n    // 1-hour update\n    uint256 public lastUpdateHour;\n    uint256 public updatePeriod;\n\n    mapping(uint256 => uint256) public epochDollarPrice;\n\n    // chain-link price feed\n    mapping(address => address) public chainLinkOracle;\n\n    // ValueLiquidPair\n    address public mainToken;\n    bool[] public isToken0s;\n    uint256[] public decimalFactors;\n    uint32[] public mainTokenWeights;\n    IValueLiquidPair[] public pairs;\n\n    // Pair price for update in cumulative epochPeriod\n    uint256 public priceCumulative;\n    uint256[] public priceMainCumulativeLast;\n\n    // oracle\n    uint256 public priceCumulativeLast;\n    FixedPoint.uq112x112 public priceAverage;\n\n    uint32 public blockTimestampCumulativeLast;\n    uint32 public blockTimestampLast;\n\n    event Updated(uint256 priceCumulativeLast);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address[] memory _pairs,\n        address _mainToken,\n        address _epochController,\n        uint256 _maxEpochPeriod,\n        uint256 _updatePeriod,\n        uint256 _lastUpdateHour,\n        address _pairFactory,\n        address _defaultOracle,\n        uint256 _oracleReserveMinimum\n    ) {\n        for (uint256 i = 0; i < _pairs.length; i++) {\n            IValueLiquidPair pair = IValueLiquidPair(_pairs[i]);\n            {\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n                require(reserve0 != 0 && reserve1 != 0, \"OracleMultiPair: NO_RESERVES\"); // ensure that there's liquidity in the pair\n            }\n\n            pairs.push(pair);\n            bool isToken0 = pair.token0() == _mainToken;\n            isToken0s.push(isToken0);\n            priceMainCumulativeLast.push(0);\n            {\n                uint256 decimal = IERC20(isToken0 ? pair.token1() : pair.token0()).decimals();\n                decimalFactors.push(10**(uint256(18).sub(decimal)));\n            }\n            (uint32 _tokenWeight0, uint32 _tokenWeight1, ) = IValueLiquidFactory(_pairFactory).getWeightsAndSwapFee(_pairs[i]);\n            mainTokenWeights.push(isToken0 ? _tokenWeight0 : _tokenWeight1);\n        }\n\n        epochController = _epochController;\n        maxEpochPeriod = _maxEpochPeriod;\n        lastUpdateHour = _lastUpdateHour;\n        updatePeriod = _updatePeriod;\n        factory = _pairFactory;\n        mainToken = _mainToken;\n        chainLinkOracle[address(0)] = _defaultOracle;\n        oracleReserveMinimum = _oracleReserveMinimum;\n\n        operator = msg.sender;\n    }\n\n    /* ========== GOVERNANCE ========== */\n\n    function setOperator(address _operator) external onlyOperator {\n        operator = _operator;\n    }\n\n    function setEpochController(address _epochController) external onlyOperator {\n        epochController = _epochController;\n    }\n\n    function setChainLinkOracle(address _token, address _priceFeed) external onlyOperator {\n        chainLinkOracle[_token] = _priceFeed;\n    }\n\n    function setOracleReserveMinimum(uint256 _oracleReserveMinimum) external onlyOperator {\n        oracleReserveMinimum = _oracleReserveMinimum;\n    }\n\n    function setMaxEpochPeriod(uint256 _maxEpochPeriod) external onlyOperator {\n        require(_maxEpochPeriod <= 48 hours, \"_maxEpochPeriod is not valid\");\n        maxEpochPeriod = _maxEpochPeriod;\n    }\n\n    function setLastUpdateHour(uint256 _lastUpdateHour) external onlyOperator {\n        require(_lastUpdateHour % 3600 == 0, \"_lastUpdateHour is not valid\");\n        lastUpdateHour = _lastUpdateHour;\n    }\n\n    function addPair(address _pair) public onlyOperator {\n        IValueLiquidPair pair = IValueLiquidPair(_pair);\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n        require(reserve0 != 0 && reserve1 != 0, \"OracleMultiPair: NO_RESERVES\");\n        // ensure that there's liquidity in the pair\n\n        pairs.push(pair);\n        bool isToken0 = pair.token0() == mainToken;\n        isToken0s.push(isToken0);\n        priceMainCumulativeLast.push(isToken0 ? pair.price0CumulativeLast() : pair.price1CumulativeLast());\n        {\n            uint256 decimal = IERC20(isToken0 ? pair.token1() : pair.token0()).decimals();\n            decimalFactors.push(10**(uint256(18).sub(decimal)));\n        }\n        (uint32 _tokenWeight0, uint32 _tokenWeight1, ) = IValueLiquidFactory(factory).getWeightsAndSwapFee(_pair);\n        mainTokenWeights.push(isToken0 ? _tokenWeight0 : _tokenWeight1);\n    }\n\n    function removePair(address _pair) public onlyOperator {\n        uint256 last = pairs.length - 1;\n\n        for (uint256 i = 0; i < pairs.length; i++) {\n            if (address(pairs[i]) == _pair) {\n                pairs[i] = pairs[last];\n                isToken0s[i] = isToken0s[last];\n                priceMainCumulativeLast[i] = priceMainCumulativeLast[last];\n                decimalFactors[i] = decimalFactors[last];\n                mainTokenWeights[i] = mainTokenWeights[last];\n\n                pairs.pop();\n                isToken0s.pop();\n                mainTokenWeights.pop();\n                priceMainCumulativeLast.pop();\n                decimalFactors.pop();\n\n                break;\n            }\n        }\n    }\n\n    /* =================== Modifier =================== */\n\n    modifier checkEpoch {\n        require(block.timestamp >= nextEpochPoint(), \"OracleMultiPair: not opened yet\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operator == msg.sender, \"OracleMultiPair: caller is not the operator\");\n        _;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function epoch() public view override returns (uint256) {\n        return IEpochController(epochController).epoch();\n    }\n\n    function nextEpochPoint() public view override returns (uint256) {\n        return IEpochController(epochController).nextEpochPoint();\n    }\n\n    function nextEpochLength() external view returns (uint256) {\n        return IEpochController(epochController).nextEpochLength();\n    }\n\n    function nextUpdateHour() public view returns (uint256) {\n        return lastUpdateHour.add(updatePeriod);\n    }\n\n    /* ========== MUTABLE FUNCTIONS ========== */\n    // update reserves and, on the first call per block, price accumulators\n    function updateCumulative() public override {\n        uint256 _updatePeriod = updatePeriod;\n        uint256 _nextUpdateHour = lastUpdateHour.add(_updatePeriod);\n        if (block.timestamp >= _nextUpdateHour) {\n            uint256 totalMainPriceWeight;\n            uint256 totalSidePairBal;\n\n            uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n            if (blockTimestamp != blockTimestampCumulativeLast) {\n                for (uint256 i = 0; i < pairs.length; i++) {\n                    (uint256 priceMainCumulative, , uint256 reserveSideToken) =\n                        currentTokenCumulativePriceAndReserves(pairs[i], isToken0s[i], mainTokenWeights[i], blockTimestamp);\n\n                    uint256 _decimalFactor = decimalFactors[i];\n                    uint256 reserveBal = reserveSideToken.mul(_decimalFactor);\n                    require(reserveBal >= oracleReserveMinimum, \"!min reserve\");\n\n                    totalMainPriceWeight = totalMainPriceWeight.add(\n                        (priceMainCumulative - priceMainCumulativeLast[i]).mul(reserveSideToken.mul(_decimalFactor))\n                    );\n                    totalSidePairBal = totalSidePairBal.add(reserveSideToken);\n                    priceMainCumulativeLast[i] = priceMainCumulative;\n                }\n\n                require(totalSidePairBal <= uint112(-1), \"OracleMultiPair: OVERFLOW\");\n                if (totalSidePairBal != 0) {\n                    priceCumulative += totalMainPriceWeight.div(totalSidePairBal);\n                    blockTimestampCumulativeLast = blockTimestamp;\n                }\n            }\n\n            for (;;) {\n                if (block.timestamp < _nextUpdateHour.add(_updatePeriod)) {\n                    lastUpdateHour = _nextUpdateHour;\n                    break;\n                } else {\n                    _nextUpdateHour = _nextUpdateHour.add(_updatePeriod);\n                }\n            }\n        }\n    }\n\n    /** @dev Updates 1-day EMA price.  */\n    function update() external override checkEpoch {\n        updateCumulative();\n\n        uint32 _blockTimestampCumulativeLast = blockTimestampCumulativeLast; // gas saving\n        uint32 timeElapsed = _blockTimestampCumulativeLast - blockTimestampLast; // overflow is desired\n\n        if (timeElapsed == 0) {\n            // prevent divided by zero\n            return;\n        }\n\n        // overflow is desired, casting never truncates\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n        uint256 _priceCumulative = priceCumulative; //gas saving\n        priceAverage = FixedPoint.uq112x112(uint224((_priceCumulative - priceCumulativeLast) / timeElapsed));\n\n        priceCumulativeLast = _priceCumulative;\n        blockTimestampLast = _blockTimestampCumulativeLast;\n\n        epochDollarPrice[epoch()] = consultDollarPrice(address(0), 1e18);\n        emit Updated(_priceCumulative);\n    }\n\n    // note this will always return 0 before update has been called successfully for the first time.\n    function consult(address _token, uint256 _amountIn) public view override returns (uint144 _amountOut) {\n        require(_token == mainToken, \"OracleMultiPair: INVALID_TOKEN\");\n        require(block.timestamp.sub(blockTimestampLast) <= maxEpochPeriod, \"OracleMultiPair: Price out-of-date\");\n        _amountOut = priceAverage.mul(_amountIn).decode144();\n    }\n\n    function consultDollarPrice(address _sideToken, uint256 _amountIn) public view override returns (uint256) {\n        address _priceFeed = chainLinkOracle[_sideToken];\n        if (_priceFeed == address(0)) {\n            _priceFeed = chainLinkOracle[address(0)];\n        }\n        require(_priceFeed != address(0), \"OracleMultiPair: No price feed\");\n        int256 _price = IAggregatorInterface(_priceFeed).latestAnswer();\n        uint144 _amountOut = consult(mainToken, _amountIn);\n        return uint256(_amountOut).mul(uint256(_price)).div(1e8);\n    }\n\n    function twap(uint256 _amountIn) public view override returns (uint144 _amountOut) {\n        uint32 timeElapsed = blockTimestampCumulativeLast - blockTimestampLast;\n        _amountOut = (timeElapsed == 0)\n            ? priceAverage.mul(_amountIn).decode144()\n            : FixedPoint.uq112x112(uint224((priceCumulative - priceCumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\n    }\n\n    function twapDollarPrice(address _sideToken, uint256 _amountIn) external view override returns (uint256) {\n        address _priceFeed = chainLinkOracle[_sideToken];\n        if (_priceFeed == address(0)) {\n            _priceFeed = chainLinkOracle[address(0)];\n        }\n        require(_priceFeed != address(0), \"OracleMultiPair: No price feed\");\n        int256 _price = IAggregatorInterface(_priceFeed).latestAnswer();\n        uint144 _amountOut = twap(_amountIn);\n        return uint256(_amountOut).mul(uint256(_price)).div(1e8);\n    }\n\n    function governanceRecoverUnsupported(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    ) external onlyOperator {\n        _token.transfer(_to, _amount);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync\n    function currentTokenCumulativePriceAndReserves(\n        IValueLiquidPair pair,\n        bool isToken0,\n        uint32 mainTokenWeight,\n        uint32 blockTimestamp\n    )\n        internal\n        view\n        returns (\n            uint256 _priceCumulative,\n            uint256 reserveMain,\n            uint256 reserveSideToken\n        )\n    {\n        uint32 _blockTimestampLast;\n        if (isToken0) {\n            (reserveMain, reserveSideToken, _blockTimestampLast) = pair.getReserves();\n            _priceCumulative = pair.price0CumulativeLast();\n        } else {\n            (reserveSideToken, reserveMain, _blockTimestampLast) = pair.getReserves();\n            _priceCumulative = pair.price1CumulativeLast();\n        }\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        if (_blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast;\n            // addition overflow is desired\n            // counterfactual\n            uint112 mReserveMain = uint112(reserveMain) * (100 - mainTokenWeight);\n            uint112 mReserveSide = uint112(reserveSideToken) * mainTokenWeight;\n            _priceCumulative += uint256(FixedPoint.fraction(mReserveSide, mReserveMain)._x) * timeElapsed;\n        }\n    }\n}\n"}}}