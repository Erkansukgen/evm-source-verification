{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"MoonCatReference.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.8.1;\r\n\r\ninterface IReverseResolver {\r\n    function claim(address owner) external returns (bytes32);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\n/**\r\n * @title MoonCatsOnChain\r\n * @notice On Chain Reference for Offical MoonCat Projects\r\n * @dev Maintains a mapping of contract addresses to documentation/description strings\r\n */\r\ncontract MoonCatReference {\r\n\r\n    /* Original MoonCat Rescue Contract */\r\n\r\n    address constant public MoonCatRescue = 0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6;\r\n\r\n    /* Documentation */\r\n\r\n    address[] internal ContractAddresses;\r\n\r\n    struct Doc {\r\n        string name;\r\n        string description;\r\n        string details;\r\n    }\r\n\r\n    mapping (address => Doc) internal Docs;\r\n\r\n    /**\r\n     * @dev How many Contracts does this Reference contract have documentation for?\r\n     */\r\n    function totalContracts () public view returns (uint256) {\r\n        return ContractAddresses.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Iterate through the addresses this Reference contract has documentation for.\r\n     */\r\n    function contractAddressByIndex (uint256 index) public view returns (address) {\r\n        require(index < ContractAddresses.length, \"Index Out of Range\");\r\n        return ContractAddresses[index];\r\n    }\r\n\r\n    /**\r\n     * @dev For a specific address, get the details this Reference contract has for it.\r\n     */\r\n    function doc (address _contractAddress) public view returns (string memory name, string memory description, string memory details) {\r\n        Doc storage data = Docs[_contractAddress];\r\n        return (data.name, data.description, data.details);\r\n    }\r\n\r\n    /**\r\n     * @dev Iterate through the addresses this Reference contract has documentation for, returning the details stored for that contract.\r\n     */\r\n    function doc (uint256 index) public view returns (string memory name, string memory description, string memory details, address contractAddress) {\r\n        require(index < ContractAddresses.length, \"Index Out of Range\");\r\n        contractAddress = ContractAddresses[index];\r\n        (name, description, details) = doc(contractAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Get documentation about this contract.\r\n     */\r\n    function doc () public view returns (string memory name, string memory description, string memory details) {\r\n        return doc(address(this));\r\n    }\r\n\r\n    address payable public owner;\r\n\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the stored details about a specific Contract.\r\n     */\r\n    function setDoc (address contractAddress, string memory name, string memory description, string memory details) public onlyOwner {\r\n        require(bytes(name).length > 0, \"Name cannot be blank\");\r\n        Doc storage data = Docs[contractAddress];\r\n        if (bytes(data.name).length == 0) {\r\n            ContractAddresses.push(contractAddress);\r\n        }\r\n        data.name = name;\r\n        data.description = description;\r\n        data.details = details;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the name and description about a specific Contract.\r\n     */\r\n    function setDoc (address contractAddress, string memory name, string memory description) public {\r\n        setDoc(contractAddress, name, description, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Update the details about a specific Contract.\r\n     */\r\n    function updateDetails (address contractAddress, string memory details) public onlyOwner {\r\n        Doc storage data = Docs[contractAddress];\r\n        require(bytes(data.name).length == 0, \"Doc not found\");\r\n        data.details = details;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the details for multiple Contracts at once.\r\n     */\r\n    function batchSetDocs (address[] calldata contractAddresses, Doc[] calldata docs) public onlyOwner {\r\n        for ( uint256 i = 0; i < docs.length; i++) {\r\n            Doc memory data = docs[i];\r\n            setDoc(contractAddresses[i], data.name, data.description, data.details);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allow current `owner` to transfer ownership to another address\r\n     */\r\n    function transferOwnership (address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC20 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC20 (address tokenContract) public onlyOwner {\r\n        IERC20 token = IERC20(tokenContract);\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC721 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC721 (address tokenContract, uint256 tokenId) public onlyOwner {\r\n        IERC721(tokenContract).safeTransferFrom(address(this), owner, tokenId);\r\n    }\r\n\r\n\r\n    constructor () {\r\n        owner = payable(msg.sender);\r\n\r\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\r\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148).claim(msg.sender);\r\n\r\n        setDoc(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6, \"MoonCatRescue\", \"Original 2017 MoonCatRescue user-discoverable blockchain collectible.\", \"\");\r\n    }\r\n}"}}}