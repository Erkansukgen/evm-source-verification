{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "bot.sol": {
      "content": "pragma solidity ^0.8.0;\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\ninterface RouterV2{\r\n    function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ncontract Ownable {\r\n    address public owner = msg.sender;\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n}\r\ncontract Manager is Ownable {\r\n    mapping(address=>bool) manager;\r\n    function setManager(address _target, bool status) public onlyOwner{\r\n        manager[_target]=status;\r\n    }\r\n    function isManager(address _target) public view returns(bool){\r\n        return manager[_target];\r\n    }\r\n    modifier onlyManager() {\r\n        if (manager[msg.sender] != true) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n}\r\ncontract GameSwap is Manager{\r\n    struct Item{\r\n        address token;\r\n        address tokenPair;\r\n        address pairContract;\r\n        address routerContract;\r\n    }\r\n    uint128 public decimals=10**18;\r\n    mapping(address=>bool) tokenSafe;\r\n    \r\n    address public USDT;//BUSD\r\n    uint8 public safeNumber;\r\n    uint256 public maxIn = 1000000*decimals;\r\n    \r\n    function setToken(address _usdt, uint8 _safeNumber, uint256 _maxIn) public onlyOwner{\r\n        USDT=_usdt;\r\n        safeNumber=_safeNumber;\r\n        maxIn=_maxIn;\r\n    }\r\n    function setSafeToken(address token, bool status) public onlyOwner{\r\n        tokenSafe[token]=status;\r\n    }\r\n    function Sum(Item[] memory Input) internal view returns(uint256){\r\n        uint256 count = Input.length;\r\n        uint256 total=0;\r\n        for(uint256 i=0;i<count;i++){\r\n            total+=IERC20(Input[i].token).balanceOf(Input[i].pairContract);\r\n        }\r\n        return total;\r\n    }\r\n    \r\n    function safeApprove(address token, address to, uint value) public onlyOwner {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n    function safeTransfer(address token, address to, uint value) public onlyOwner {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n    function approveToken(address token, address spender, uint256 quantity) public onlyOwner{\r\n        IERC20(token).approve(spender, quantity);\r\n    }\r\n    function safeOut(address token, uint256 quantity) public onlyOwner{\r\n        IERC20(token).transfer(msg.sender, quantity);\r\n    }\r\n    function Swap(Item[] memory Input) public onlyManager{\r\n        uint256 pool=Sum(Input);\r\n        uint256 count = Input.length;\r\n        uint256 myBalance = IERC20(USDT).balanceOf(address(this));\r\n        \r\n        for(uint256 i=0;i<count;i++){\r\n            Item memory Ip = Input[i];\r\n            \r\n            uint256 balance = IERC20(Ip.token).balanceOf(Ip.pairContract);\r\n            uint256 percent = (balance*decimals)/pool;\r\n            \r\n            uint256 tokenIn = (percent*myBalance)/decimals;\r\n            \r\n            address[] memory path = new address[](2);\r\n            path[0] = USDT;\r\n            path[1] = Ip.token;\r\n            uint256[] memory tokenOut = RouterV2(Ip.routerContract).getAmountsOut(tokenIn, path); // tokenout[0] sai\r\n            if(Ip.tokenPair==USDT){\r\n                //safe check \r\n                uint256 safeAmount = IERC20(USDT).balanceOf(Ip.pairContract);\r\n                if(safeAmount>tokenIn*safeNumber){\r\n                    RouterV2(Ip.routerContract).swapTokensForExactTokens(tokenOut[1], maxIn, path, owner, block.timestamp+1000);\r\n                }\r\n            }\r\n            else{\r\n                address otherToken = Ip.tokenPair;\r\n                \r\n               if(tokenSafe[otherToken]==true){\r\n                address[] memory pathOT = new address[](2);\r\n                pathOT[0] = USDT;\r\n                pathOT[1] = otherToken;\r\n                \r\n                uint256[] memory estOT = RouterV2(Ip.routerContract).getAmountsOut(tokenIn, pathOT);\r\n                \r\n                RouterV2(Ip.routerContract).swapTokensForExactTokens(estOT[1], maxIn, pathOT, address(this), block.timestamp+1000);\r\n                \r\n                uint256 balanceOT = IERC20(otherToken).balanceOf(address(this));\r\n                address[] memory pathRouterOT = new address[](2);\r\n                pathRouterOT[0] = otherToken;\r\n                pathRouterOT[1] = Ip.token;\r\n                \r\n                uint256[] memory estTokenOut = RouterV2(Ip.routerContract).getAmountsOut(balanceOT, pathRouterOT);\r\n                //safe check\r\n                uint256 safeAmount = IERC20(otherToken).balanceOf(Ip.pairContract);\r\n                if(safeAmount>balanceOT*safeNumber){\r\n                    RouterV2(Ip.routerContract).swapTokensForExactTokens(estTokenOut[1], maxIn, pathRouterOT, owner, block.timestamp+1000);\r\n                }\r\n               }\r\n            }\r\n        }\r\n    }\r\n}"
    }
  }
}