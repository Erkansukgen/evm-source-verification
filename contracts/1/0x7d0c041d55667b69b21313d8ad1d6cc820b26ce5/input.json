{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "minter.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ninterface Jungle {\n    function mint(uint256 amount) external payable;\n    function price() external view returns(uint256);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n}\n\ncontract Buyer is IERC721Receiver {\n    Jungle private nft;\n    address private owner;\n    \n    constructor() payable {\n        nft = Jungle(0x7E6Bc952d4b4bD814853301bEe48E99891424de0);\n        owner = msg.sender;\n    }\n\n    receive() external payable { }\n\n    function mmmega_mmmint(uint256 count) public payable {\n        uint256 value = nft.price() * 3;\n        for (uint i = 0; i < count; i++) {\n            try nft.mint{value:value}(3) {}\n            catch {\n                break;\n            }\n        }\n    }\n\n    function ggget_jpegs(uint256[] calldata ids) public {\n        require(msg.sender == owner, \"nonono\");\n        for (uint i = 0; i < ids.length; i++) {\n            nft.safeTransferFrom(address(this), owner, ids[i]);\n        }\n    }\n\n    function ggget_eth() public payable {\n        require(msg.sender == owner, \"nonono\");\n        payable(owner).transfer(address(this).balance);\n    }\n    \n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}"
    }
  }
}