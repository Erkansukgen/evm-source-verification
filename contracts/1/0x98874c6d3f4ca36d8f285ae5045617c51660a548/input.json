{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DBTC - v1.0.0.sol":{"content":"/***\n* \n*           _____                    _____                _____                    _____          \n*          /\\    \\                  /\\    \\              /\\    \\                  /\\    \\         \n*         /::\\    \\                /::\\    \\            /::\\    \\                /::\\    \\        \n*        /::::\\    \\              /::::\\    \\           \\:::\\    \\              /::::\\    \\       \n*       /::::::\\    \\            /::::::\\    \\           \\:::\\    \\            /::::::\\    \\      \n*      /:::/\\:::\\    \\          /:::/\\:::\\    \\           \\:::\\    \\          /:::/\\:::\\    \\     \n*     /:::/  \\:::\\    \\        /:::/__\\:::\\    \\           \\:::\\    \\        /:::/  \\:::\\    \\    \n*    /:::/    \\:::\\    \\      /::::\\   \\:::\\    \\          /::::\\    \\      /:::/    \\:::\\    \\   \n*   /:::/    / \\:::\\    \\    /::::::\\   \\:::\\    \\        /::::::\\    \\    /:::/    / \\:::\\    \\  \n*  /:::/    /   \\:::\\ ___\\  /:::/\\:::\\   \\:::\\ ___\\      /:::/\\:::\\    \\  /:::/    /   \\:::\\    \\ \n* /:::/____/     \\:::|    |/:::/__\\:::\\   \\:::|    |    /:::/  \\:::\\____\\/:::/____/     \\:::\\____\\\n* \\:::\\    \\     /:::|____|\\:::\\   \\:::\\  /:::|____|   /:::/    \\::/    /\\:::\\    \\      \\::/    /\n*  \\:::\\    \\   /:::/    /  \\:::\\   \\:::\\/:::/    /   /:::/    / \\/____/  \\:::\\    \\      \\/____/ \n*   \\:::\\    \\ /:::/    /    \\:::\\   \\::::::/    /   /:::/    /            \\:::\\    \\             \n*    \\:::\\    /:::/    /      \\:::\\   \\::::/    /   /:::/    /              \\:::\\    \\            \n*     \\:::\\  /:::/    /        \\:::\\  /:::/    /    \\::/    /                \\:::\\    \\           \n*      \\:::\\/:::/    /          \\:::\\/:::/    /      \\/____/                  \\:::\\    \\          \n*       \\::::::/    /            \\::::::/    /                                 \\:::\\    \\         \n*        \\::::/    /              \\::::/    /                                   \\:::\\____\\        \n*         \\::/____/                \\::/____/                                     \\::/    /        \n*          ~~                       ~~                                            \\/____/         \n*                                                                                                 \n* \n*     \n* https://dbtc.plus v1.0.0\n*/\n\npragma solidity 0.5.17;   \n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\ninterface InterfaceDividend {\n    function withdrawDividendsEverything() external returns(bool);\n}\n\n\ncontract ownerShip\n{\n    address payable public owner;\n    address payable public newOwner;\n\n    event OwnershipTransferredEv(uint256 timeOfEv, address payable indexed previousOwner, address payable indexed newOwner);\n\n    constructor() public \n    {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() \n    {\n        require(msg.sender == owner);\n        _;\n    }\n\n\n    function transferOwnership(address payable _newOwner) public onlyOwner \n    {\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() public \n    {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferredEv(now, owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n\n}\n\ncontract DBTC is ownerShip {\n  \n    using SafeMath for uint256;       \n    string constant public name=\"Decentralized Bitcoin\";\n    string constant public symbol=\"DBTC\";\n    uint256 constant public decimals=18;\n    uint256 public totalSupply = 210000 * ( 10 ** decimals);\n    uint256 public minTotalSupply = 2100 * ( 10 ** decimals);\n    uint256 public constant minSupply = 21 * ( 10 ** decimals);\n    uint256 public  _burnPercent = 500;  // 500 = 5%\n    uint256 public constant _burnPercentAll = 1000;  // 300 = 3%\n    uint256 public constant _invite1Percent = 300;  // 300 = 3%\n    uint256 public constant _invite2Percent = 200;  // 200 =2%\n    address public constant uni = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address public constant AirdropAddress = address(0x91De8F260f05d0aB3C51911d8B43793D82B84d66);\n    address public constant CreateAddress = address(0x4b5d1ebFe85f399B728F655f77142459470549A6);\n    address public TradeAddress;\n    \n    address public dividendContractAdderess;\n\n    struct Miner {\n      address address1;\n      address address2;\n    }\n\n    mapping(address => Miner) public miners;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed approvedBy, address indexed spender, uint256 value);\n    event WhitelistFrom(address _addr, bool _whitelisted);\n    event WhitelistTo(address _addr, bool _whitelisted);\n\n    mapping(address => bool) public whitelistFrom;\n    mapping(address => bool) public whitelistTo;\n  \n    constructor( ) public\n    {\n        balanceOf[CreateAddress] = 170000 * ( 10 ** decimals);\n        balanceOf[AirdropAddress] = 40000 * ( 10 ** decimals);\n        emit Transfer(address(0), CreateAddress, 170000 * ( 10 ** decimals));\n        emit Transfer(address(0), AirdropAddress, 40000 * ( 10 ** decimals));\n    }\n    \n    function () payable external {}\n    \n\n    function _isWhitelisted(address _from, address _to) internal view returns (bool) {\n        return whitelistFrom[_from]||whitelistTo[_to];\n    }\n\n    function setWhitelistedTo(address _addr, bool _whitelisted) external onlyOwner {\n        emit WhitelistTo(_addr, _whitelisted);\n        whitelistTo[_addr] = _whitelisted;\n    }\n\n    function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyOwner {\n        emit WhitelistFrom(_addr, _whitelisted);\n        whitelistFrom[_addr] = _whitelisted;\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_value <= balanceOf[_from], 'Not enough balance');  \n        balanceOf[_from] = balanceOf[_from].sub(_value);    \n        balanceOf[_to] = balanceOf[_to].add(_value);        \n\n        emit Transfer(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n\n        uint256 tokensToBurn = calculatePercentage(_value,_burnPercent);\n        uint256 invite1to = calculatePercentage(_value,_invite1Percent);\n        uint256 invite2to = calculatePercentage(_value,_invite2Percent);\n        uint256 tokensToBurnAll = calculatePercentage(_value,_burnPercentAll);\n\n        if(_isWhitelisted(msg.sender, _to)){\n            _transfer(msg.sender, _to, _value - tokensToBurnAll);\n            _burn(msg.sender, tokensToBurnAll);\n            return true;\n        }\n\n        if(msg.sender == uni && _to == TradeAddress){\n            _transfer(msg.sender, _to, _value);\n            return true;\n        } else if (msg.sender == TradeAddress && _to == uni){\n            _transfer(msg.sender, _to, _value);\n            return true;\n        }\n\n        if(msg.sender == TradeAddress  && _to != uni){\n            if (miners[_to].address1 != address(0) && miners[_to].address2 != address(0)){\n                if (balanceOf[miners[_to].address1] >= minSupply && balanceOf[miners[_to].address2] >= minSupply){\n                    _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                    _transfer(msg.sender, miners[_to].address1,invite1to);\n                    _transfer(msg.sender, miners[_to].address2,invite2to);\n                    _burn(msg.sender, tokensToBurn);\n                    return true;\n                } else if (balanceOf[miners[_to].address1] >= minSupply && balanceOf[miners[_to].address2] < minSupply){\n                    _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                    _transfer(msg.sender, miners[_to].address1,invite1to);\n                    _burn(msg.sender, tokensToBurn + invite2to);\n                    return true;\n                } else if (balanceOf[miners[_to].address1] < minSupply && balanceOf[miners[_to].address2] >= minSupply){\n                    _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                    _transfer(msg.sender, miners[_to].address2,invite2to);\n                    _burn(msg.sender, tokensToBurn + invite1to);\n                    return true;\n                } else {\n                    _transfer(msg.sender, _to, _value - tokensToBurnAll);\n                    _burn(msg.sender, tokensToBurnAll);\n                    return true;\n                }\n            } else if (miners[_to].address1 != address(0)){\n                if (balanceOf[miners[_to].address1] >= minSupply){\n                    _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn );\n                    _transfer(msg.sender, miners[_to].address1,invite1to);\n                    _burn(msg.sender, tokensToBurn + invite2to);\n                    return true;\n                } else {\n                    _transfer(msg.sender, _to, _value - tokensToBurnAll);\n                    _burn(msg.sender, tokensToBurnAll);\n                    return true;\n                }\n            }        \n        }\n\n        if (miners[msg.sender].address1 != address(0) && miners[msg.sender].address2 != address(0) && miners[_to].address1 != address(0)){\n            if (balanceOf[miners[msg.sender].address1] >= minSupply && balanceOf[miners[msg.sender].address2] >= minSupply){\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\n                _transfer(msg.sender, miners[msg.sender].address2,invite2to);\n                _burn(msg.sender, tokensToBurn);\n                return true;\n            } else if (balanceOf[miners[msg.sender].address1] >= minSupply && balanceOf[miners[msg.sender].address2] < minSupply){\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\n                _burn(msg.sender, tokensToBurn + invite2to);\n                return true;\n            } else if (balanceOf[miners[msg.sender].address1] < minSupply && balanceOf[miners[msg.sender].address2] >= minSupply){\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(msg.sender, miners[msg.sender].address2,invite2to);\n                _burn(msg.sender, tokensToBurn + invite1to);\n                return true;\n            } else {\n                _transfer(msg.sender, _to, _value - tokensToBurnAll);\n                _burn(msg.sender, tokensToBurnAll);\n                return true;\n            }\n        } else if (miners[msg.sender].address1 != address(0) && miners[msg.sender].address2 != address(0) && miners[_to].address1 == address(0)){\n            if (balanceOf[miners[msg.sender].address1] >= minSupply && balanceOf[miners[msg.sender].address2] >= minSupply){\n\n                if ( _to != msg.sender || _to!= TradeAddress || _to!= uni){\n                    if(miners[_to].address1 == address(0)){\n                        if(balanceOf[msg.sender] >= minSupply){\n                        miners[_to].address1 = msg.sender;\n                        miners[_to].address2 = miners[msg.sender].address1;\n                        }\n                    }\n                }\n\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\n                _transfer(msg.sender, miners[msg.sender].address2,invite2to);\n                _burn(msg.sender, tokensToBurn);\n                return true;\n            } else if (balanceOf[miners[msg.sender].address1] >= minSupply && balanceOf[miners[msg.sender].address2] < minSupply){\n\n                if ( _to != msg.sender || _to!= TradeAddress || _to!= uni){\n                    if(miners[_to].address1 == address(0)){\n                        if(balanceOf[msg.sender] >= minSupply){\n                        miners[_to].address1 = msg.sender;\n                        }\n                    }\n                }\n\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\n                _burn(msg.sender, tokensToBurn + invite2to);\n                return true;\n            } else if (balanceOf[miners[msg.sender].address1] < minSupply && balanceOf[miners[msg.sender].address2] >= minSupply){\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(msg.sender, miners[msg.sender].address2,invite2to);\n                _burn(msg.sender, tokensToBurn + invite1to );\n                return true;\n            } else {\n                _transfer(msg.sender, _to, _value - tokensToBurnAll);\n                _burn(msg.sender, tokensToBurnAll);\n                return true;\n            }\n        } else if (miners[msg.sender].address1 != address(0) && miners[msg.sender].address2 == address(0) && miners[_to].address1 == address(0)){\n            if (balanceOf[miners[msg.sender].address1] >= minSupply){\n\n                if ( _to != msg.sender || _to!= TradeAddress || _to!= uni){\n                    if(miners[_to].address1 == address(0)){\n                        if(balanceOf[msg.sender] >= minSupply){\n                        miners[_to].address1 = msg.sender;\n                        miners[_to].address2 = miners[msg.sender].address1;\n                        }\n                    }\n                }\n\n                _transfer(msg.sender, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(msg.sender, miners[msg.sender].address1,invite1to);\n                _burn(msg.sender, tokensToBurn + invite2to);\n                return true;\n            } else {\n                _transfer(msg.sender, _to, _value - tokensToBurnAll );\n                _burn(msg.sender, tokensToBurnAll);\n                return true;\n          }\n        } else if (miners[msg.sender].address1 == address(0) && miners[msg.sender].address2 == address(0) && miners[_to].address1 == address(0)){\n\n                if ( _to != msg.sender || _to!= TradeAddress || _to!= uni){\n                    if(miners[_to].address1 == address(0)){\n                        if(balanceOf[msg.sender] >= minSupply){\n                        miners[_to].address1 = msg.sender;\n                        }\n                    }\n                }\n\n                _transfer(msg.sender, _to, _value - tokensToBurnAll);\n                _burn(msg.sender, tokensToBurnAll);\n                return true;\n        }\n\n        if(miners[_to].address1 == address(0)){\n            if(balanceOf[msg.sender] >= minSupply){\n            miners[_to].address1 = msg.sender;\n            }\n        }\n\n        _transfer(msg.sender, _to, _value - tokensToBurnAll);\n        _burn(msg.sender, tokensToBurnAll);\n        return true;\n\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        uint256 tokensToBurn = calculatePercentage(_value,_burnPercent);\n        uint256 invite1to = calculatePercentage(_value,_invite1Percent);\n        uint256 invite2to = calculatePercentage(_value,_invite2Percent);\n        uint256 tokensToBurnAll = calculatePercentage(_value,_burnPercentAll);\n        \n        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n\n        if(_isWhitelisted(_from, _to)){\n            _transfer(_from, _to, _value - tokensToBurnAll);\n            _burn(msg.sender, tokensToBurnAll);\n            return true;\n        }\n\n        if(_from == uni && _to == TradeAddress){\n            _transfer(_from, _to, _value);\n            return true;\n        } else if (_from == TradeAddress && _to == uni){\n            _transfer(_from, _to, _value);\n            return true;\n        } \n\n        if (miners[_from].address1 != address(0) && miners[_from].address2 != address(0)){\n            if (balanceOf[miners[_from].address1] >= minSupply && balanceOf[miners[_from].address2] >= minSupply){\n                _transfer(_from, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(_from, miners[_from].address1,invite1to);\n                _transfer(_from, miners[_from].address2,invite2to);\n                _burn(_from, tokensToBurn);\n                return true;\n            } else if (balanceOf[miners[_from].address1] >= minSupply && balanceOf[miners[_from].address2] < minSupply){\n                _transfer(_from, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(_from, miners[_from].address1,invite1to);\n                _burn(_from, tokensToBurn + invite2to);\n                return true;\n            } else if (balanceOf[miners[_from].address1] < minSupply && balanceOf[miners[_from].address2] >= minSupply){\n                _transfer(_from, _to, _value - invite1to - invite2to - tokensToBurn);\n                _transfer(_from, miners[_from].address2,invite2to);\n                _burn(_from, tokensToBurn + invite1to);\n                return true;\n            } else {\n                _transfer(_from, _to, _value - tokensToBurnAll);\n                _burn(_from, tokensToBurnAll);\n                return true;\n            }\n        } else if (miners[_from].address1 != address(0)){\n            if (balanceOf[miners[_from].address1] >= minSupply){\n                _transfer(_from, _to, _value - invite1to - invite2to - tokensToBurn );\n                _transfer(_from, miners[_from].address1,invite1to);\n                _burn(_from, tokensToBurn + invite2to);\n                return true;\n            } else {\n                _transfer(_from, _to, _value - tokensToBurnAll);\n                _burn(_from, tokensToBurnAll);\n                return true;\n            }\n        }\n        \n        _transfer(_from, _to, _value - tokensToBurnAll);\n        _burn(_from, tokensToBurnAll);\n        return true;\n\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        \n        address user = msg.sender;  //local variable is gas cheaper than reading from storate multiple time\n\n        require(_value <= balanceOf[user], 'Not enough balance');\n        \n        allowance[user][_spender] = _value;\n        emit Approval(user, _spender, _value);\n        return true;\n    }\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    \n        uint256 newAmount = allowance[msg.sender][spender].add(addedValue);\n        approve(spender, newAmount);\n        \n        return true;\n    }\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    \n        uint256 newAmount = allowance[msg.sender][spender].sub(subtractedValue);\n        approve(spender, newAmount);\n        \n        return true;\n    }\n\n    function calculatePercentage(uint256 PercentOf, uint256 percentTo ) internal pure returns (uint256) \n    {\n        uint256 factor = 10000;\n        require(percentTo <= factor);\n        uint256 c = PercentOf.mul(percentTo).div(factor);\n        return c;\n    }\n\n    \n    function setBurningRate(uint burnPercent) onlyOwner public returns(bool success)\n    {\n        _burnPercent = burnPercent;\n        return true;\n    }\n    \n    function updateMinimumTotalSupply(uint minimumTotalSupplyWEI) onlyOwner public returns(bool success)\n    {\n        minTotalSupply = minimumTotalSupplyWEI;\n        return true;\n    }\n    \n    \n    \n    function _burn(address account, uint256 amount) internal returns(bool) {\n        if(totalSupply > minTotalSupply)\n        {\n          totalSupply = totalSupply.sub(amount);\n          balanceOf[account] = balanceOf[account].sub(amount);\n          emit Transfer(account, address(0), amount);\n          return true;\n        }\n    }\n\n    function setTradeAddress(address addr) public onlyOwner {\n        TradeAddress = addr;\n    }\n\n    function manualWithdrawTokens(uint256 tokenAmount) public onlyOwner returns(string memory){\n        _transfer(address(this), owner, tokenAmount);\n        return \"Tokens withdrawn to owner wallet\";\n    }\n\n\n    function manualWithdrawEther(uint256 amount) public onlyOwner returns(string memory){\n        owner.transfer(amount);\n        return \"Ether withdrawn to owner wallet\";\n    }\n\n    function updateDividendContractAddress(address dividendContract) public onlyOwner returns(string memory){\n        dividendContractAdderess = dividendContract;\n        return \"dividend conract address updated successfully\";\n    }\n\n    function airDrop(address[] memory recipients,uint[] memory tokenAmount) public onlyOwner returns (bool) {\n        uint reciversLength  = recipients.length;\n        require(reciversLength <= 150);\n        for(uint i = 0; i < reciversLength; i++)\n        {\n            if (gasleft() < 100000)\n            {\n                break;\n            }\n              _transfer(owner, recipients[i], tokenAmount[i]);\n              miners[recipients[i]].address1 = msg.sender;\n        }\n        return true;\n    }\n}"}}}