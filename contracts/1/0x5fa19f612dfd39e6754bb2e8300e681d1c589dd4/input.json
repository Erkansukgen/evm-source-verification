{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/rewards.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.6.8;\n\n// ERC20 Interface\ninterface ERC20 {\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\nlibrary SafeMath {\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\ncontract PerlinXRewards {\n    using SafeMath for uint256;\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    address public PERL;\n    address public treasury;\n\n    address[] public arrayAdmins;\n    address[] public arrayPerlinPools;\n    address[] public arraySynths;\n    address[] public arrayMembers;\n\n    uint256 public currentEra;\n\n    mapping(address => bool) public isAdmin; // Tracks admin status\n    mapping(address => bool) public poolIsListed; // Tracks current listing status\n    mapping(address => bool) public poolHasMembers; // Tracks current staking status\n    mapping(address => bool) public poolWasListed; // Tracks if pool was ever listed\n    mapping(address => uint256) public mapAsset_Rewards; // Maps rewards for each asset (PERL, BAL, UNI etc)\n    mapping(address => uint256) public poolWeight; // Allows a reward weight to be applied; 100 = 1.0\n    mapping(uint256 => uint256) public mapEra_Total; // Total PERL staked in each era\n    mapping(uint256 => bool) public eraIsOpen; // Era is open of collecting rewards\n    mapping(uint256 => mapping(address => uint256)) public mapEraAsset_Reward; // Reward allocated for era\n    mapping(uint256 => mapping(address => uint256)) public mapEraPool_Balance; // Perls in each pool, per era\n    mapping(uint256 => mapping(address => uint256)) public mapEraPool_Share; // Share of reward for each pool, per era\n    mapping(uint256 => mapping(address => uint256)) public mapEraPool_Claims; // Total LP tokens locked for each pool, per era\n\n    mapping(address => address) public mapPool_Asset; // Uniswap pools provide liquidity to non-PERL asset\n    mapping(address => address) public mapSynth_EMP; // Synthetic Assets have a management contract\n\n    mapping(address => bool) public isMember; // Is Member\n    mapping(address => uint256) public mapMember_poolCount; // Total number of Pools member is in\n    mapping(address => address[]) public mapMember_arrayPools; // Array of pools for member\n    mapping(address => mapping(address => uint256))\n        public mapMemberPool_Balance; // Member's balance in pool\n    mapping(address => mapping(address => bool)) public mapMemberPool_Added; // Member's balance in pool\n    mapping(address => mapping(uint256 => bool))\n        public mapMemberEra_hasRegistered; // Member has registered\n    mapping(address => mapping(uint256 => mapping(address => uint256)))\n        public mapMemberEraPool_Claim; // Value of claim per pool, per era\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        public mapMemberEraAsset_hasClaimed; // Boolean claimed\n\n    // Events\n    event Snapshot(\n        address indexed admin,\n        uint256 indexed era,\n        uint256 rewardForEra,\n        uint256 perlTotal,\n        uint256 validPoolCount,\n        uint256 validMemberCount,\n        uint256 date\n    );\n    event NewPool(\n        address indexed admin,\n        address indexed pool,\n        address indexed asset,\n        uint256 assetWeight\n    );\n    event NewSynth(\n        address indexed pool,\n        address indexed synth,\n        address indexed expiringMultiParty\n    );\n    event MemberLocks(\n        address indexed member,\n        address indexed pool,\n        uint256 amount,\n        uint256 indexed currentEra\n    );\n    event MemberUnlocks(\n        address indexed member,\n        address indexed pool,\n        uint256 balance,\n        uint256 indexed currentEra\n    );\n    event MemberRegisters(\n        address indexed member,\n        address indexed pool,\n        uint256 amount,\n        uint256 indexed currentEra\n    );\n    event MemberClaims(address indexed member, uint256 indexed era, uint256 totalClaim);\n\n    // Only Admin can execute\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender], \"Must be Admin\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    constructor() public {\n        arrayAdmins.push(msg.sender);\n        isAdmin[msg.sender] = true;\n        PERL = 0xeca82185adCE47f39c684352B0439f030f860318;\n        treasury = 0x3F2a2c502E575f2fd4053c76f4E21623143518d8; \n        currentEra = 1;\n        _status = _NOT_ENTERED;\n    }\n\n    //==============================ADMIN================================//\n\n    // Lists a synth and its parent EMP address\n    function listSynth(\n        address pool,\n        address synth,\n        address emp,\n        uint256 weight\n    ) public onlyAdmin {\n        require(emp != address(0), \"Must pass address validation\");\n        if (!poolWasListed[pool]) {\n            arraySynths.push(synth); // Add new synth\n        }\n        listPool(pool, synth, weight); // List like normal pool\n        mapSynth_EMP[synth] = emp; // Maps the EMP contract for look-up\n        emit NewSynth(pool, synth, emp);\n    }\n\n    // Lists a pool and its non-PERL asset (can work for Balance or Uniswap V2)\n    // Use \"100\" to be a normal weight of \"1.0\"\n    function listPool(\n        address pool,\n        address asset,\n        uint256 weight\n    ) public onlyAdmin {\n        require(\n            (asset != PERL) && (asset != address(0)) && (pool != address(0)),\n            \"Must pass address validation\"\n        );\n        require(\n            weight >= 10 && weight <= 1000,\n            \"Must be greater than 0.1, less than 10\"\n        );\n        if (!poolWasListed[pool]) {\n            arrayPerlinPools.push(pool);\n        }\n        poolIsListed[pool] = true; // Tracking listing\n        poolWasListed[pool] = true; // Track if ever was listed\n        poolWeight[pool] = weight; // Note: weight of 120 = 1.2\n        mapPool_Asset[pool] = asset; // Map the pool to its non-perl asset\n        emit NewPool(msg.sender, pool, asset, weight);\n    }\n\n    function delistPool(address pool) public onlyAdmin {\n        poolIsListed[pool] = false;\n    }\n\n    // Quorum Action 1\n    function addAdmin(address newAdmin) public onlyAdmin {\n        require(\n            (isAdmin[newAdmin] == false) && (newAdmin != address(0)),\n            \"Must pass address validation\"\n        );\n        arrayAdmins.push(newAdmin);\n        isAdmin[newAdmin] = true;\n    }\n\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(\n            (isAdmin[newAdmin] == false) && (newAdmin != address(0)),\n            \"Must pass address validation\"\n        );\n        arrayAdmins.push(newAdmin);\n        isAdmin[msg.sender] = false;\n        isAdmin[newAdmin] = true;\n    }\n\n    // Snapshot a new Era, allocating any new rewards found on the address, increment Era\n    // Admin should send reward funds first\n    function snapshot(address rewardAsset) public onlyAdmin {\n        snapshotInEra(rewardAsset, currentEra); // Snapshots PERL balances\n        currentEra = currentEra.add(1); // Increment the eraCount, so users can't register in a previous era.\n    }\n\n    // Snapshot a particular rewwardAsset, but don't increment Era (like Balancer Rewards)\n    // Do this after snapshotPools()\n    function snapshotInEra(address rewardAsset, uint256 era) public onlyAdmin {\n        uint256 start = 0;\n        uint256 end = poolCount();\n        snapshotInEraWithOffset(rewardAsset, era, start, end);\n    }\n\n    // Snapshot with offset (in case runs out of gas)\n    function snapshotWithOffset(\n        address rewardAsset,\n        uint256 start,\n        uint256 end\n    ) public onlyAdmin {\n        snapshotInEraWithOffset(rewardAsset, currentEra, start, end); // Snapshots PERL balances\n        currentEra = currentEra.add(1); // Increment the eraCount, so users can't register in a previous era.\n    }\n\n    // Snapshot a particular rewwardAsset, with offset\n    function snapshotInEraWithOffset(\n        address rewardAsset,\n        uint256 era,\n        uint256 start,\n        uint256 end\n    ) public onlyAdmin {\n        require(rewardAsset != address(0), \"Address must not be 0x0\");\n        require(\n            (era >= currentEra - 1) && (era <= currentEra),\n            \"Must be current or previous era only\"\n        );\n        uint256 amount = ERC20(rewardAsset).balanceOf(address(this)).sub(\n            mapAsset_Rewards[rewardAsset]\n        );\n        require(amount > 0, \"Amount must be non-zero\");\n        mapAsset_Rewards[rewardAsset] = mapAsset_Rewards[rewardAsset].add(\n            amount\n        );\n        mapEraAsset_Reward[era][rewardAsset] = mapEraAsset_Reward[era][rewardAsset]\n            .add(amount);\n        eraIsOpen[era] = true;\n        updateRewards(era, amount, start, end); // Snapshots PERL balances\n    }\n\n    // Note, due to EVM gas limits, poolCount should be less than 100 to do this before running out of gas\n    function updateRewards(\n        uint256 era,\n        uint256 rewardForEra,\n        uint256 start,\n        uint256 end\n    ) internal {\n        // First snapshot balances of each pool\n        uint256 perlTotal;\n        uint256 validPoolCount;\n        uint256 validMemberCount;\n        for (uint256 i = start; i < end; i++) {\n            address pool = arrayPerlinPools[i];\n            if (poolIsListed[pool] && poolHasMembers[pool]) {\n                validPoolCount = validPoolCount.add(1);\n                uint256 weight = poolWeight[pool];\n                uint256 weightedBalance = (\n                    ERC20(PERL).balanceOf(pool).mul(weight)).div(100); // (depth * weight) / 100\n                perlTotal = perlTotal.add(weightedBalance);\n                mapEraPool_Balance[era][pool] = weightedBalance;\n            }\n        }\n        mapEra_Total[era] = perlTotal;\n        // Then snapshot share of the reward for the era\n        for (uint256 i = start; i < end; i++) {\n            address pool = arrayPerlinPools[i];\n            if (poolIsListed[pool] && poolHasMembers[pool]) {\n                validMemberCount = validMemberCount.add(1);\n                uint256 part = mapEraPool_Balance[era][pool];\n                mapEraPool_Share[era][pool] = getShare(\n                    part,\n                    perlTotal,\n                    rewardForEra\n                );\n            }\n        }\n        emit Snapshot(\n            msg.sender,\n            era,\n            rewardForEra,\n            perlTotal,\n            validPoolCount,\n            validMemberCount,\n            now\n        );\n    }\n\n    // Quorum Action\n    // Remove unclaimed rewards and disable era for claiming\n    function removeReward(uint256 era, address rewardAsset) public onlyAdmin {\n      uint256 amount = mapEraAsset_Reward[era][rewardAsset];\n      mapEraAsset_Reward[era][rewardAsset] = 0;\n      mapAsset_Rewards[rewardAsset] = mapAsset_Rewards[rewardAsset].sub(\n          amount\n      );\n      eraIsOpen[era] = false;\n      require(\n            ERC20(rewardAsset).transfer(treasury, amount),\n            \"Must transfer\"\n        );\n    }\n\n    // Quorum Action - Reuses adminApproveEraAsset() logic since unlikely to collide\n    // Use in anger to sweep off assets (such as accidental airdropped tokens)\n    function sweep(address asset, uint256 amount) public onlyAdmin {\n      require(\n            ERC20(asset).transfer(treasury, amount),\n            \"Must transfer\"\n        );\n    }\n\n    //============================== USER - LOCK/UNLOCK ================================//\n    // Member locks some LP tokens\n    function lock(address pool, uint256 amount) public nonReentrant {\n        require(poolIsListed[pool] == true, \"Must be listed\");\n        if (!isMember[msg.sender]) {\n            // Add new member\n            arrayMembers.push(msg.sender);\n            isMember[msg.sender] = true;\n        }\n        if (!poolHasMembers[pool]) {\n            // Records existence of member\n            poolHasMembers[pool] = true;\n        }\n        if (!mapMemberPool_Added[msg.sender][pool]) {\n            // Record all the pools member is in\n            mapMember_poolCount[msg.sender] = mapMember_poolCount[msg.sender]\n                .add(1);\n            mapMember_arrayPools[msg.sender].push(pool);\n            mapMemberPool_Added[msg.sender][pool] = true;\n        }\n        require(\n            ERC20(pool).transferFrom(msg.sender, address(this), amount),\n            \"Must transfer\"\n        ); // Uni/Bal LP tokens return bool\n        mapMemberPool_Balance[msg.sender][pool] = mapMemberPool_Balance[msg.sender][pool]\n            .add(amount); // Record total pool balance for member\n        registerClaim(msg.sender, pool, amount); // Register claim\n        emit MemberLocks(msg.sender, pool, amount, currentEra);\n    }\n\n    // Member unlocks all from a pool\n    function unlock(address pool) public nonReentrant {\n        uint256 balance = mapMemberPool_Balance[msg.sender][pool];\n        require(balance > 0, \"Must have a balance to claim\");\n        mapMemberPool_Balance[msg.sender][pool] = 0; // Zero out balance\n        require(ERC20(pool).transfer(msg.sender, balance), \"Must transfer\"); // Then transfer\n        if (ERC20(pool).balanceOf(address(this)) == 0) {\n            poolHasMembers[pool] = false; // If nobody is staking any more\n        }\n        emit MemberUnlocks(msg.sender, pool, balance, currentEra);\n    }\n\n    //============================== USER - CLAIM================================//\n    // Member registers claim in a single pool\n    function registerClaim(\n        address member,\n        address pool,\n        uint256 amount\n    ) internal {\n        mapMemberEraPool_Claim[member][currentEra][pool] += amount;\n        mapEraPool_Claims[currentEra][pool] = mapEraPool_Claims[currentEra][pool]\n            .add(amount);\n        emit MemberRegisters(member, pool, amount, currentEra);\n    }\n\n    // Member registers claim in all pools\n    function registerAllClaims(address member) public {\n        require(\n            mapMemberEra_hasRegistered[msg.sender][currentEra] == false,\n            \"Must not have registered in this era already\"\n        );\n        for (uint256 i = 0; i < mapMember_poolCount[member]; i++) {\n            address pool = mapMember_arrayPools[member][i];\n            // first deduct any previous claim\n            mapEraPool_Claims[currentEra][pool] = mapEraPool_Claims[currentEra][pool]\n                .sub(mapMemberEraPool_Claim[member][currentEra][pool]);\n            uint256 amount = mapMemberPool_Balance[member][pool]; // then get latest balance\n            mapMemberEraPool_Claim[member][currentEra][pool] = amount; // then update the claim\n            mapEraPool_Claims[currentEra][pool] = mapEraPool_Claims[currentEra][pool]\n                .add(amount); // then add to total\n            emit MemberRegisters(member, pool, amount, currentEra);\n        }\n        mapMemberEra_hasRegistered[msg.sender][currentEra] = true;\n    }\n\n    // Member claims in a era\n    function claim(uint256 era, address rewardAsset)\n        public\n        nonReentrant\n    {\n        require(\n            mapMemberEraAsset_hasClaimed[msg.sender][era][rewardAsset] == false,\n            \"Reward asset must not have been claimed\"\n        );\n        require(eraIsOpen[era], \"Era must be opened\");\n        uint256 totalClaim = checkClaim(msg.sender, era);\n        if (totalClaim > 0) {\n            mapMemberEraAsset_hasClaimed[msg.sender][era][rewardAsset] = true; // Register claim\n            mapEraAsset_Reward[era][rewardAsset] = mapEraAsset_Reward[era][rewardAsset]\n                .sub(totalClaim); // Decrease rewards for that era\n            mapAsset_Rewards[rewardAsset] = mapAsset_Rewards[rewardAsset].sub(\n                totalClaim\n            ); // Decrease rewards in total\n            require(\n                ERC20(rewardAsset).transfer(msg.sender, totalClaim),\n                \"Must transfer\"\n            ); // Then transfer\n        }\n        emit MemberClaims(msg.sender, era, totalClaim);\n        if (mapMemberEra_hasRegistered[msg.sender][currentEra] == false) {\n            registerAllClaims(msg.sender); // Register another claim\n        }\n    }\n\n    // Member checks claims in all pools\n    function checkClaim(address member, uint256 era)\n        public\n        view\n        returns (uint256 totalClaim)\n    {\n        for (uint256 i = 0; i < mapMember_poolCount[member]; i++) {\n            address pool = mapMember_arrayPools[member][i];\n            totalClaim += checkClaimInPool(member, era, pool);\n        }\n        return totalClaim;\n    }\n\n    // Member checks claim in a single pool\n    function checkClaimInPool(\n        address member,\n        uint256 era,\n        address pool\n    ) public view returns (uint256 claimShare) {\n        uint256 poolShare = mapEraPool_Share[era][pool]; // Requires admin snapshotting for era first, else 0\n        uint256 memberClaimInEra = mapMemberEraPool_Claim[member][era][pool]; // Requires member registering claim in the era\n        uint256 totalClaimsInEra = mapEraPool_Claims[era][pool]; // Sum of all claims in a era\n        if (totalClaimsInEra > 0) {\n            // Requires non-zero balance of the pool tokens\n            claimShare = getShare(\n                memberClaimInEra,\n                totalClaimsInEra,\n                poolShare\n            );\n        } else {\n            claimShare = 0;\n        }\n        return claimShare;\n    }\n\n    //==============================UTILS================================//\n    // Get the share of a total\n    function getShare(\n        uint256 part,\n        uint256 total,\n        uint256 amount\n    ) public pure returns (uint256 share) {\n        return (amount.mul(part)).div(total);\n    }\n\n    function adminCount() public view returns (uint256) {\n        return arrayAdmins.length;\n    }\n\n    function poolCount() public view returns (uint256) {\n        return arrayPerlinPools.length;\n    }\n\n    function synthCount() public view returns (uint256) {\n        return arraySynths.length;\n    }\n\n    function memberCount() public view returns (uint256) {\n        return arrayMembers.length;\n    }\n}"
    }
  }
}