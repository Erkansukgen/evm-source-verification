{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/TestSwap7.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ninterface Structs {\n    struct Val {\n        uint256 value;\n    }\n\n    enum ActionType {\n      Deposit,   // supply tokens\n      Withdraw,  // borrow tokens\n      Transfer,  // transfer balance between accounts\n      Buy,       // buy an amount of some token (externally)\n      Sell,      // sell an amount of some token (externally)\n      Trade,     // trade tokens against another account\n      Liquidate, // liquidate an undercollateralized or expiring account\n      Vaporize,  // use excess tokens to zero-out a completely negative account\n      Call       // send arbitrary data to an address\n    }\n\n    enum AssetDenomination {\n        Wei // the amount is denominated in wei\n    }\n\n    enum AssetReference {\n        Delta // the amount is given as a delta from the current value\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    struct Info {\n        address owner;  // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n}\n\nabstract contract DyDxPool is Structs {\n    function getAccountWei(Info memory account, uint256 marketId) public virtual view returns (Wei memory);\n    function operate(Info[] memory, ActionArgs[] memory) public virtual;\n}\n\ncontract DyDxFlashLoan is Structs {\n    DyDxPool pool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n\n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    mapping(address => uint256) public currencies;\n\n    constructor() {\n        currencies[WETH] = 1;\n        currencies[SAI] = 2;\n        currencies[USDC] = 3;\n        currencies[DAI] = 4;\n    }\n\n    modifier onlyPool() {\n        require(\n            msg.sender == address(pool),\n            \"FlashLoan: could be called by DyDx pool only\"\n        );\n        _;\n    }\n\n    function tokenToMarketId(address token) public view returns (uint256) {\n        uint256 marketId = currencies[token];\n        require(marketId != 0, \"FlashLoan: Unsupported token\");\n        return marketId - 1;\n    }\n\n    // the DyDx will call `callFunction(address sender, Info memory accountInfo, bytes memory data) public` after during `operate` call\n    function flashloan(address token, uint256 amount, bytes memory data)\n        internal\n    {\n        IERC20(token).approve(address(pool), amount + 1);\n        Info[] memory infos = new Info[](1);\n        ActionArgs[] memory args = new ActionArgs[](3);\n\n        infos[0] = Info(address(this), 0);\n\n        AssetAmount memory wamt = AssetAmount(\n            false,\n            AssetDenomination.Wei,\n            AssetReference.Delta,\n            amount\n        );\n        ActionArgs memory withdraw;\n        withdraw.actionType = ActionType.Withdraw;\n        withdraw.accountId = 0;\n        withdraw.amount = wamt;\n        withdraw.primaryMarketId = tokenToMarketId(token);\n        withdraw.otherAddress = address(this);\n\n        args[0] = withdraw;\n\n        ActionArgs memory call;\n        call.actionType = ActionType.Call;\n        call.accountId = 0;\n        call.otherAddress = address(this);\n        call.data = data;\n\n        args[1] = call;\n\n        ActionArgs memory deposit;\n        AssetAmount memory damt = AssetAmount(\n            true,\n            AssetDenomination.Wei,\n            AssetReference.Delta,\n            amount + 1\n        );\n        deposit.actionType = ActionType.Deposit;\n        deposit.accountId = 0;\n        deposit.amount = damt;\n        deposit.primaryMarketId = tokenToMarketId(token);\n        deposit.otherAddress = address(this);\n\n        args[2] = deposit;\n\n        pool.operate(infos, args);\n    }\n}\n\n\ncontract GibIhmHart is DyDxFlashLoan {\n    address internal constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D ;\n    address internal constant SUSHISWAP_ROUTER_ADDRESS = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F ;\n    address internal constant DEFISWAP_ROUTER_ADDRESS = 0xCeB90E4C17d626BE0fACd78b79c9c87d7ca181b3 ;\n    address owner;\n    address approver;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function GibIhm(address flashToken, address totoken, uint256 flashAmount, string memory exchangeOne, string memory exchangeTwo) external onlyApprover() {\n        uint256 balanceBefore = IERC20(flashToken).balanceOf(address(this));\n        bytes memory data = abi.encode(flashToken, flashAmount, balanceBefore, totoken, exchangeOne, exchangeTwo);\n        flashloan(flashToken, flashAmount, data); // execution goes to callFunction\n    }\n\n    function callFunction(address, Info calldata, bytes calldata data) external onlyPool {\n        (address flashToken, uint256 flashAmount, uint256 balanceBefore, address totoken, string memory exchangeOne, string memory exchangeTwo) = \n            abi.decode(data, (address, uint256, uint256, address, string, string));\n        uint256 balanceAfter = IERC20(flashToken).balanceOf(address(this));\n        require(balanceAfter - balanceBefore == flashAmount,\"Not enough funds to repay loan!\");\n        \n        uint lastSell = balanceAfter;\n        if(keccak256(abi.encodePacked(exchangeOne)) == keccak256(abi.encodePacked(\"UNISWAP\"))){\n            lastSell = runUniswap(lastSell, flashToken, totoken, UNISWAP_ROUTER_ADDRESS);\n        }\n        else if(keccak256(abi.encodePacked(exchangeOne)) == keccak256(abi.encodePacked(\"SUSHISWAP\"))){\n            lastSell = runUniswap(lastSell, flashToken, totoken, SUSHISWAP_ROUTER_ADDRESS);\n        }\n        else if(keccak256(abi.encodePacked(exchangeOne)) == keccak256(abi.encodePacked(\"DEFISWAP\"))){\n            lastSell = runUniswap(lastSell, flashToken, totoken, DEFISWAP_ROUTER_ADDRESS);\n        }\n        if(keccak256(abi.encodePacked(exchangeTwo)) == keccak256(abi.encodePacked(\"UNISWAP\"))){\n            runUniswap(lastSell, totoken, flashToken, UNISWAP_ROUTER_ADDRESS);\n        }\n        else if(keccak256(abi.encodePacked(exchangeTwo)) == keccak256(abi.encodePacked(\"SUSHISWAP\"))){\n            runUniswap(lastSell, totoken, flashToken, SUSHISWAP_ROUTER_ADDRESS);\n        }\n        else if(keccak256(abi.encodePacked(exchangeTwo)) == keccak256(abi.encodePacked(\"DEFISWAP\"))){\n            runUniswap(lastSell, totoken, flashToken, DEFISWAP_ROUTER_ADDRESS);\n        }\n    }\n\n    function runUniswap(uint amount, address fromtoken, address totoken, address exchange) private returns(uint){\n        IUniswapV2Router02 uniswap = IUniswapV2Router02(exchange);\n        address[] memory path = getPath(fromtoken,totoken);\n        uint[] memory minOuts = uniswap.getAmountsOut(amount, path);\n        uint minOut = 98 * minOuts[1] / 100;\n        IERC20(fromtoken).approve(address(uniswap), amount);\n        uniswap.swapExactTokensForTokens(\n          amount,\n          minOut,\n          path,\n          address(this),\n          block.timestamp\n        );\n        return IERC20(totoken).balanceOf(address(this));\n    }\n    \n    function setApprover(address newApprover) external onlyOwner(){\n        approver = newApprover;\n    }\n    \n    function getPath(address fromtoken, address totoken) private pure returns (address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = address(fromtoken);\n        path[1] = address(totoken);\n        return path;\n    }\n\n    function withdrawETHAndTokens(address tokenAddress) external onlyOwner() {\n        payable(msg.sender).transfer(address(this).balance);\n        IERC20 token = IERC20(tokenAddress);\n        uint256 currentTokenBalance = token.balanceOf(address(this));\n        token.transfer(msg.sender, currentTokenBalance - 100);\n    }\n\n    function changeOwner(address NewOwner) external onlyOwner(){\n        owner = NewOwner;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, 'only owner');\n        _;\n    }\n    \n    modifier onlyApprover() {\n        require(msg.sender == approver, 'only owner');\n        _;\n    }\n}\n"
    }
  }
}