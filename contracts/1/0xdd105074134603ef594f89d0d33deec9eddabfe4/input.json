{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/BikX.sol":{"content":"// SPDX-License-Identifier: BIKDATA\npragma solidity ^0.6.0;\n\ninterface Bik {\n    function transfer(address receiver, uint amount) external returns (bool);\n    function balanceOf(address _address) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract Owner {\n    uint256 numberOfOwners = 0;\n    mapping(address => bool) owners;\n\n    constructor() public {\n        owners[msg.sender] = true;\n        numberOfOwners += 1;\n    }\n    modifier onlyOwner {\n        require(owners[msg.sender], \"Only owners can access this feature\");\n        _;\n    }\n    function revokeOwnership(address owner) onlyOwner public {\n        require(numberOfOwners - 1 > 0, \"You cannot revoke the last owner\");\n        owners[owner] = false;\n        numberOfOwners -= 1;\n    }\n    function grantOwnership(address newOwner) onlyOwner public {\n        owners[newOwner] = true;\n        numberOfOwners += 1;\n    }\n}\n\ncontract BikX is Owner {\n    address bikContract;\n    uint256 amountRaised;\n    bool xClosed;\n\n    uint256 buyPrice;\n    uint256 sellPrice;\n    \n    address contractAddress;\n\n    constructor(address _contract) public {\n        owners[msg.sender] = true;\n        bikContract = _contract;\n        xClosed = false;\n        contractAddress = address(this);\n\n        buyPrice = 480000000000000;\n        sellPrice = 320000000000000;\n    }\n\n    receive () payable external {\n        // Make sure the crowdsale is not closed\n        require(!xClosed);\n        // Set memory data temporarily\n        uint256 amount = msg.value;\n        uint256 valueToSend = getAmountOfTokens(msg.value);\n        require(valueToSend > 0, \"Not enough ether sent to get a BIK\");\n\n        // Make sure we have enough BIKs to send\n        uint256 currentBalance = getCurrentBalance();\n        require(currentBalance > 0 && currentBalance >= valueToSend, \"Not enough funding on the crowdsale\");\n\n        // Transfer BIKs to buyera\n        bool success = Bik(bikContract).transfer(msg.sender, valueToSend);\n        require(success, \"Unable to send amount\");\n\n        // Update the ether amount in contract\n        amountRaised += amount;\n    }\n    function approve(uint256 amount) public returns (bool) {\n        bool approveSuccess = Bik(bikContract).approve(contractAddress, amount);\n        require(approveSuccess, \"Wasn't able to allow the transaction to go through\");\n        return true;\n    }\n    function sell (uint256 amount) payable external returns (bool) {\n        // Make sure the crowdsale is not closed\n        require(!xClosed);\n        \n        // Set memory data temporarily\n        address payable receiver = msg.sender;\n        uint256 valueToSend = getAmountOfEther(amount);\n        \n        // Make sure we have enough ether to send to the seller\n        require(amountRaised >= valueToSend, \"Not enough ether for the amount needed\");\n        \n        // Transfer the BIKs from the seller\n        bool transferSuccess = Bik(bikContract).transferFrom(msg.sender, contractAddress, amount);\n        require(transferSuccess, \"Transaction failure\");\n\n        // Send Ether to the seller\n        receiver.transfer(valueToSend);\n\n        // Update the ether amount left\n        amountRaised -= valueToSend;\n        return true;\n    }\n    \n    /*\n        Interaction with original contract\n    */\n    function getBalanceOf(address _address) public view returns (uint256) {\n        uint256 value = Bik(bikContract).balanceOf(_address);\n        return value;\n    }\n    function getTotalSupply() public view returns (uint256) {\n        uint256 _totalSupply = Bik(bikContract).totalSupply();\n        return _totalSupply;\n    }\n    function getCurrentBalance() public view returns (uint256){\n        return Bik(bikContract).balanceOf(contractAddress);\n    }\n    \n    /*\n        Customer validations\n    */\n    function getAmountOfTokens(uint256 amountEther) public view returns (uint256){\n        return ((amountEther * 1 ether) / buyPrice);\n    }\n    function getAmountOfEther(uint256 amountOfTokens) public view returns (uint256){\n        return (amountOfTokens * sellPrice) / 1 ether;\n    }\n    \n    \n    /*\n        Crowdsale configurations for owner\n    */\n    function setBuyPrice (uint256 _price) onlyOwner public {\n        require(_price > 0, \"Expense cannot be 0 or negative\");\n        buyPrice = _price;\n    }\n    function setSellPrice (uint256 _price) onlyOwner public {\n        require(_price > 0, \"Expense cannot be 0 or negative\");\n        sellPrice = _price;\n    }\n    function setBikContract (address _address) onlyOwner public {\n        require(_address != address(0), \"Address cannot be 0\");\n        require(_address != contractAddress, \"Address cannot be this contract\");\n        bikContract = _address;\n    }\n    function getPrices() onlyOwner public view returns (uint256 buyingPrice, uint256 sellingPrice) {\n        return (\n            buyPrice,\n            sellPrice\n        );\n    }\n\n    /*\n        Admin functions for owner\n    */\n    function closeBikX() onlyOwner public {\n        require(!xClosed, \"Crowdsale already closed\");\n        xClosed = true;\n    }\n    function openBikX() onlyOwner public {\n        require(xClosed, \"Crowdsale is already open\");\n        xClosed = false;\n    }\n    function transferFundsTo(address payable _address) onlyOwner public payable {\n        require(_address != address(0));\n        require(amountRaised > 0);\n        _address.transfer(amountRaised);\n        amountRaised = 0;\n    }\n    function transferTokensTo(address bikContractOwner) onlyOwner public returns (bool){\n        uint256 currentBalance = getCurrentBalance();\n        require(currentBalance > 0, \"Nothing to transfer\");\n        bool transferSuccess = Bik(bikContract).transfer(bikContractOwner, currentBalance);\n        require(transferSuccess, \"Transfer failed\");\n        return true;\n    }\n    function getAmountRaised() onlyOwner public view returns (uint256) {\n        return amountRaised;\n    }\n}"}}}