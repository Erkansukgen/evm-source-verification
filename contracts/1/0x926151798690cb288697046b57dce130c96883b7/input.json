{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Transfer.sol":{"content":"pragma solidity >=0.7.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n  \r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Only for owner\");\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n\r\ncontract TransferExclusive is Ownable {\r\n    IERC20 public _tokenContract;\r\n    address public _tokenAddress;\r\n    address public _ownerAddress;\r\n    \r\n    mapping (address => uint256) claims;\r\n    \r\n    bytes32 _merkleRoot;\r\n    \r\n    struct inputModel {\r\n        address addr;\r\n        uint64 val;\r\n    }\r\n\r\n    constructor (address contractAddress, address ownerAddress) {\r\n        _tokenContract = IERC20(contractAddress);\r\n        _ownerAddress = ownerAddress;\r\n        _tokenAddress = contractAddress;\r\n    }\r\n    \r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n    \r\n    function toAsciiString(address x) internal pure returns (string memory) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint i = 0; i < 20; i++) {\r\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            s[2*i] = char(hi);\r\n            s[2*i+1] = char(lo);            \r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function char(bytes1 b) internal pure returns (bytes1 c) {\r\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\r\n        else return bytes1(uint8(b) + 0x57);\r\n    }\r\n    \r\n    function verify(bytes32 root, bytes32 leaf, bytes32[] memory proof) private pure returns (bool)\r\n    {\r\n        bytes32 computedHash = leaf;\r\n    \r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n          bytes32 proofElement = proof[i];\r\n    \r\n          if (computedHash < proofElement) {\r\n            computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n          } else {\r\n            computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n          }\r\n        }\r\n    \r\n        return computedHash == root;\r\n    }\r\n \r\n    function setMerkleRoot(bytes32 merkleRoot) public onlyOwner  {\r\n        _merkleRoot = merkleRoot;\r\n    }\r\n\r\n    function setPrimaryContract(address contractAddress, address ownerAddress) public onlyOwner returns (uint256){\r\n        _tokenContract = IERC20(contractAddress);\r\n        _ownerAddress = ownerAddress;\r\n        _tokenAddress = contractAddress;\r\n        \r\n        return 1;\r\n    }\r\n    \r\n    function getPrimaryAllowance() public onlyOwner view returns (uint256){\r\n        return _tokenContract.allowance(_ownerAddress, address(this));\r\n    }\r\n    \r\n    function getClaimedValue(address _address) public view returns (uint256){\r\n        return claims[_address];\r\n    }\r\n        \r\n    function transferExclusive(uint256 amount, uint256 max, bytes32[] memory proof) public returns (uint256){\r\n        require(_tokenContract.allowance(_ownerAddress, address(this)) >= amount, \"Allowance too low\");\r\n        \r\n        bytes32 leaf=keccak256(abi.encode(abi.encodePacked(\"0x\",toAsciiString(msg.sender), uint2str(max))));\r\n        \r\n        require(verify(_merkleRoot, leaf, proof), \"Verify failed\");\r\n        \r\n        require(claims[msg.sender]+amount <= max, \"Amount not allowed\");\r\n        \r\n       _internalTransferFrom(_tokenContract, _ownerAddress, msg.sender, amount);\r\n       \r\n       return 1;\r\n    }\r\n    \r\n    function _internalTransferFrom(IERC20 token, address sender, address recipient, uint256 amount) private {\r\n        bool sent = token.transferFrom(sender, recipient, amount*1000000000000000000);\r\n        \r\n        require(sent, \"Token transfer failed\");\r\n        \r\n        claims[recipient]+=amount;\r\n    }\r\n}"}}}