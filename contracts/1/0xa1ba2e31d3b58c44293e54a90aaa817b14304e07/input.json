{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/insidersweeper.sol":{"content":"pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './lib/SafeMath.sol';\r\n\r\n\r\ninterface v2pool{\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n\r\ninterface IWETH {\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\ncontract insidersweeper{\r\n    using SafeMath for uint;\r\n    \r\n    address payable public owner;\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n    \r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n    function approvetoken(address token, address target) external onlyowner {\r\n        IERC20(address(token)).approve(target, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n    }\r\n\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    } \r\n\r\n\r\n\r\n\r\n    function v2swap(address pool, bool first, uint256 amountin) private returns(uint256 amountOut){\r\n        (uint112 r1, uint112 r2, ) = v2pool(pool).getReserves();\r\n        \r\n        if(first){\r\n            amountOut = getAmountOut(amountin, r1, r2);\r\n            v2pool(pool).swap(0, amountOut, address(this), new bytes(0));\r\n        }else{\r\n            amountOut = getAmountOut(amountin, r2, r1);\r\n            v2pool(pool).swap(amountOut, 0, address(this), new bytes(0));\r\n        }\r\n    \r\n    }\r\n\r\n\r\n\r\n    function sweepv2poolskimmem(address pool, address[] calldata tokens, address[] calldata pools, uint256 minamount, bool first, uint256 amount) external{\r\n\r\n        uint256 balance_before;\r\n        uint256 token_balance;\r\n\r\n        \r\n        require(IERC20(tokens[0]).balanceOf(pool) >= minamount, \"shit\");\r\n        \r\n        \r\n        \r\n\r\n        if(first){\r\n            v2pool(pool).swap(0, amount, address(this), new bytes(0));\r\n        }else{\r\n            v2pool(pool).swap(amount, 0, address(this), new bytes(0));\r\n        }\r\n\r\n        \r\n        for(uint i=0; i < pools.length; i++){\r\n            token_balance = IERC20(tokens[i]).balanceOf(address(this));\r\n            balance_before = IERC20(tokens[i]).balanceOf(pools[i]);\r\n            \r\n            _safeTransfer(tokens[i], pools[i], token_balance);\r\n            \r\n            first = tokens[i] < tokens[i+1];\r\n            \r\n            v2swap(pools[i], first, IERC20(tokens[i]).balanceOf(pools[i]) - balance_before);\r\n        }\r\n\r\n        token_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n        \r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(owner, token_balance);\r\n\r\n    }\r\n \r\n\r\n\r\n    function sweepv2poolskim(address pool, address[] calldata tokens, address[] calldata pools, bool first, uint256 amount, uint256 percent) external{\r\n\r\n        uint256 balance_before;\r\n        uint256 token_balance;\r\n\r\n        \r\n\r\n\r\n        if(first){\r\n            v2pool(pool).swap(0, amount, address(this), new bytes(0));\r\n        }else{\r\n            v2pool(pool).swap(amount, 0, address(this), new bytes(0));\r\n        }\r\n\r\n\r\n        \r\n        for(uint i=0; i < pools.length; i++){\r\n            token_balance = IERC20(tokens[i]).balanceOf(address(this));\r\n            balance_before = IERC20(tokens[i]).balanceOf(pools[i]);\r\n            \r\n            _safeTransfer(tokens[i], pools[i], token_balance);\r\n            \r\n            first = tokens[i] < tokens[i+1];\r\n            \r\n            v2swap(pools[i], first, IERC20(tokens[i]).balanceOf(pools[i]) - balance_before);\r\n        }\r\n\r\n        token_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n\r\n        IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(token_balance);\r\n\r\n\r\n        block.coinbase.call{value: token_balance * percent / 100}(new bytes(0));\r\n\r\n        owner.transfer(address(this).balance);\r\n\r\n    }\r\n\r\n\r\n    function get_swap_out(address pool) public view returns(uint256 outamount){\r\n        (uint112 r0, uint112 r1, ) = v2pool(pool).getReserves();\r\n        address t0 = v2pool(pool).token0();\r\n        address t1 = v2pool(pool).token1();\r\n        \r\n        uint256 d1 = IERC20(t0).balanceOf(pool) - r0;\r\n        uint256 d2 = IERC20(t1).balanceOf(pool) - r1;\r\n\r\n        if(d1 > 0){\r\n            outamount = getAmountOut(d1, r0, r1);\r\n        }else{\r\n            outamount = getAmountOut(d2, r1, r0);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n}"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity >=0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"}}}