{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"@openzeppelin/contracts-upgradeable/introspection/IERC1820RegistryUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820RegistryUpgradeable {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"},"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { cs := extcodesize(self) }\n        return cs == 0;\n    }\n}\n"},"contracts/Constants.sol":{"content":"pragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/introspection/IERC1820RegistryUpgradeable.sol\";\n\nlibrary Constants {\n  IERC1820RegistryUpgradeable public constant REGISTRY = IERC1820RegistryUpgradeable(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n  // keccak256(\"ERC777TokensSender\")\n  bytes32 public constant TOKENS_SENDER_INTERFACE_HASH =\n  0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n  // keccak256(\"ERC777TokensRecipient\")\n  bytes32 public constant TOKENS_RECIPIENT_INTERFACE_HASH =\n  0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n  // keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n  bytes32 public constant ACCEPT_MAGIC =\n  0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4;\n\n  bytes4 public constant ERC165_INTERFACE_ID_ERC165 = 0x01ffc9a7;\n  bytes4 public constant ERC165_INTERFACE_ID_ERC721 = 0x80ac58cd;\n}"},"contracts/token/TokenListener.sol":{"content":"pragma solidity ^0.6.4;\n\nimport \"./TokenListenerInterface.sol\";\nimport \"./TokenListenerLibrary.sol\";\nimport \"../Constants.sol\";\n\nabstract contract TokenListener is TokenListenerInterface {\n  function supportsInterface(bytes4 interfaceId) external override view returns (bool) {\n    return (\n      interfaceId == Constants.ERC165_INTERFACE_ID_ERC165 || \n      interfaceId == TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER\n    );\n  }\n}\n"},"contracts/token/TokenListenerInterface.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\";\n\n/// @title An interface that allows a contract to listen to token mint, transfer and burn events.\ninterface TokenListenerInterface is IERC165Upgradeable {\n  /// @notice Called when tokens are minted.\n  /// @param to The address of the receiver of the minted tokens.\n  /// @param amount The amount of tokens being minted\n  /// @param controlledToken The address of the token that is being minted\n  /// @param referrer The address that referred the minting.\n  function beforeTokenMint(address to, uint256 amount, address controlledToken, address referrer) external;\n\n  /// @notice Called when tokens are transferred or burned.\n  /// @param from The address of the sender of the token transfer\n  /// @param to The address of the receiver of the token transfer.  Will be the zero address if burning.\n  /// @param amount The amount of tokens transferred\n  /// @param controlledToken The address of the token that was transferred\n  function beforeTokenTransfer(address from, address to, uint256 amount, address controlledToken) external;\n}\n"},"contracts/token/TokenListenerLibrary.sol":{"content":"pragma solidity ^0.6.12;\n\nlibrary TokenListenerLibrary {\n  /*\n    *     bytes4(keccak256('beforeTokenMint(address,uint256,address,address)')) == 0x4d7f3db0\n    *     bytes4(keccak256('beforeTokenTransfer(address,address,uint256,address)')) == 0xb2210957\n    *\n    *     => 0x4d7f3db0 ^ 0xb2210957 == 0xff5e34e7\n    */\n  bytes4 public constant ERC165_INTERFACE_ID_TOKEN_LISTENER = 0xff5e34e7;\n}"},"contracts/token/UnsafeTokenListenerDelegator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"./TokenListener.sol\";\n\ncontract UnsafeTokenListenerDelegator is TokenListener, Initializable {\n\n  event Initialized(TokenListenerInterface unsafeTokenListener);\n\n  TokenListenerInterface public unsafeTokenListener;\n\n  function initialize (TokenListenerInterface _unsafeTokenListener) external initializer {\n    unsafeTokenListener = _unsafeTokenListener;\n\n    emit Initialized(unsafeTokenListener);\n  }\n\n  /// @notice Called when tokens are minted.\n  /// @param to The address of the receiver of the minted tokens.\n  /// @param amount The amount of tokens being minted\n  /// @param controlledToken The address of the token that is being minted\n  /// @param referrer The address that referred the minting.\n  function beforeTokenMint(address to, uint256 amount, address controlledToken, address referrer) external override {\n    unsafeTokenListener.beforeTokenMint(to, amount, controlledToken, referrer);\n  }\n\n  /// @notice Called when tokens are transferred or burned.\n  /// @param from The address of the sender of the token transfer\n  /// @param to The address of the receiver of the token transfer.  Will be the zero address if burning.\n  /// @param amount The amount of tokens transferred\n  /// @param controlledToken The address of the token that was transferred\n  function beforeTokenTransfer(address from, address to, uint256 amount, address controlledToken) external override {\n    unsafeTokenListener.beforeTokenTransfer(from, to, amount, controlledToken);\n  }\n\n}"}}}