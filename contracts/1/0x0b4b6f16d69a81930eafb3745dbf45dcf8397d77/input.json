{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ethereum/Arbitrageur.sol": {
      "content": "pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\nimport \"./IUniswapV2Route.sol\";\nimport \"./IUniswapV2Factory.sol\";\nimport \"./IUniswapV2Pair.sol\";\nimport \"./IUniswapV1Factory.sol\";\nimport \"./IUniswapV1Exchange.sol\";\nimport \"./IERC20.sol\";\nimport \"./IWBNB.sol\";\n\ncontract Arbitrageur{\n    address private owner;\n    IWBNB private constant WBNB = IWBNB(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    constructor() public{\n        owner = msg.sender;\n    }\n\n    receive() external payable {}\n\n    //only owner can access some functions\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n    }\n\n    struct Exchange{\n        address[] pair;\n        address route;\n        int version;\n    }\n\n    struct Factory{\n        address factory;\n        int version;\n    }\n\n    //make simple, triangular arbitrages\n    function makeArbitrage(Exchange[] memory exchanges, uint amountIn, uint expectedAmountOut) public {\n        require(checkArbitrageStillExists(exchanges, amountIn) > expectedAmountOut, \"X Y Z\");\n\n        uint baseTokenInitialBalance = getBalanceToken(exchanges[0].pair[0]);\n        require(baseTokenInitialBalance >= amountIn, \"Insufficient balance!\");       \n\n        uint amountToSwap = amountIn;//initial amount to swap\n        uint deadline = getDeadline();\n\n        //make all swaps from pairs in exchanges\n        for(uint i = 0; i < exchanges.length; i++){\n            if(exchanges[i].version == 2){\n                //approve first token from each pair\n                IERC20 token = IERC20(exchanges[i].pair[0]);\n                require(\n                    token.approve(exchanges[i].route, amountToSwap),\n                    \"Could not approve token!\"\n                );\n\n                //swap amount\n                uint[] memory amountReceived = IUniswapV2Route(exchanges[i].route).swapExactTokensForTokens(\n                    amountToSwap,\n                    1,\n                    exchanges[i].pair,\n                    address(this),\n                    deadline\n                );\n\n                //amount to swap is updated with amount received from current swap\n                amountToSwap = amountReceived[amountReceived.length-1];\n            }\n            else{\n                IUniswapV1Factory factoryV1 = IUniswapV1Factory(exchanges[i].route);\n                //if first token from pair is wbnb\n                if(isWBNB(exchanges[i].pair[0])){\n                    IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(factoryV1.getExchange(exchanges[i].pair[1]));\n                    WBNB.withdraw(amountToSwap);\n                    uint amountReceived = exchangeV1.ethToTokenSwapInput{value: amountToSwap}(1, deadline);\n\n                    //amount to swap is updated with amount received from current swap\n                    amountToSwap = amountReceived;\n                }\n                else{                    \n                    IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(factoryV1.getExchange(exchanges[i].pair[0]));\n                    IERC20 token = IERC20(exchanges[i].pair[0]);\n                    require(\n                        token.approve(address(exchangeV1), amountToSwap),\n                        \"Could not approve token!\"\n                    );\n\n                    uint amountReceived = exchangeV1.tokenToEthSwapInput(amountToSwap, 1, deadline);\n                    WBNB.deposit{value: amountReceived}();\n\n                    //amount to swap is updated with amount received from current swap\n                    amountToSwap = amountReceived;\n                }                \n            }            \n        }\n        //if base token final balance is less than initial balance, transaction is reverted\n        uint baseTokenFinalBalance = getBalanceToken(exchanges[0].pair[0]);\n        require(baseTokenFinalBalance > baseTokenInitialBalance, \"XYZ\");\n    }\n\n    //check if arbitrage still exists before make arbitrage\n    function checkArbitrageStillExists(Exchange[] memory exchanges, uint amountIn) public view returns (uint) {\n        uint amountToSwap = amountIn;\n\n        for(uint i = 0; i < exchanges.length; i++){\n            if(exchanges[i].version == 2){\n                uint[] memory amountOutMin = IUniswapV2Route(exchanges[i].route).getAmountsOut(\n                    amountToSwap,\n                    exchanges[i].pair);\n\n                amountToSwap = amountOutMin[amountOutMin.length-1];\n            }\n            else{\n                IUniswapV1Factory factoryV1 = IUniswapV1Factory(exchanges[i].route);\n                if(isWBNB(exchanges[i].pair[0])){\n                    IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(factoryV1.getExchange(exchanges[i].pair[1]));\n                    uint amountOutMin = exchangeV1.getEthToTokenInputPrice(amountToSwap);\n                    amountToSwap = amountOutMin;\n                }\n                else{                    \n                    IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(factoryV1.getExchange(exchanges[i].pair[0]));\n                    uint amountOutMin = exchangeV1.getTokenToEthInputPrice(amountToSwap);\n                    amountToSwap = amountOutMin;\n                }                \n            }            \n        }\n        return amountToSwap;\n    }\n\n    //Get all reserves from a pair of tokens\n    function getAllReserves(address tokenA, address tokenB, Factory[] memory factories) public view returns (uint[][] memory){\n    \n        uint[][] memory allReserves = new uint[][](factories.length);\n        \n        for(uint i = 0; i < allReserves.length; i++){\n            if(factories[i].version == 2){\n                try this.getReserves(factories[i].factory, tokenA, tokenB) returns (uint reserveA, uint reserveB) {\n                    uint [] memory reserves = new uint[](3);\n                    reserves[0] = i;\n                    reserves[1] = reserveA;\n                    reserves[2] = reserveB;\n                \n                    allReserves[i] = reserves;\n                } catch (bytes memory) {                \n                }\n            }\n            else{\n                try this.getV1Reserves(factories[i].factory, tokenA, tokenB) returns (uint reserveA, uint reserveB) {\n                    uint [] memory reserves = new uint[](3);\n                    reserves[0] = i;\n                    reserves[1] = reserveA;\n                    reserves[2] = reserveB;\n                \n                    allReserves[i] = reserves;\n                } catch (bytes memory) {                \n                }\n            }\n            \n        }\n        return allReserves;\n    }\n    \n    //Get all reserves from a pack of pairs\n    function getReservesPack(address[][] memory tokens, Factory[] memory factories) public view returns (uint[][][] memory){\n        uint[][][] memory reservesPack = new uint[][][](tokens.length);\n        \n        for(uint i = 0; i < reservesPack.length; i++){\n            address tokenA = tokens[i][0];\n            address tokenB = tokens[i][1];\n            \n            try this.getAllReserves(tokenA, tokenB, factories) returns (uint[][] memory allReserves) {\n                reservesPack[i] = allReserves;\n            } catch (bytes memory) {\n                \n            }\n        }\n        \n        return reservesPack;\n    }    \n\n    //fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    //fetches the reserves for a v1 pair\n    function getV1Reserves(address factory, address tokenA, address tokenB) external view returns (uint reserveA, uint reserveB) {\n\t\trequire(isWBNB(tokenA) || isWBNB(tokenB), 'Pair does not exist');\n        IUniswapV1Factory factoryV1 = IUniswapV1Factory(factory);\n        reserveA = 0;\n        reserveB = 0;\n        if(isWBNB(tokenA)){\n            IUniswapV1Exchange pair = IUniswapV1Exchange(factoryV1.getExchange(tokenB));\n            reserveA = getPairBalanceBNB(address(pair));\n            reserveB = getPairBalanceToken(tokenB, address(pair));\n        }\n        else{\n            IUniswapV1Exchange pair = IUniswapV1Exchange(factoryV1.getExchange(tokenA));\n            reserveA = getPairBalanceToken(tokenA, address(pair));\n            reserveB = getPairBalanceBNB(address(pair));\n        }        \n    }\n\n    //returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    //return v2 pair address\n    function pairFor(address factoryAddress, address tokenA, address tokenB) internal view returns (address pair) {\n        IUniswapV2Factory factory = IUniswapV2Factory(factoryAddress);\n        address pairAddress = factory.getPair(tokenA, tokenB);\n        \n        return pairAddress;\n    }\n    \n    //return tokens balance\n    function getBalanceToken(address tokenAddress) public view returns(uint){\n        IERC20 token = IERC20(tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    //get pair BNB balance used as reserve to v1 exchange\n    function getPairBalanceBNB(address pair) internal view returns(uint){\n        return pair.balance;\n    }\n\n    //get pair token balance used as reserve to v1 exchange\n    function getPairBalanceToken(address tokenAddress, address pair) internal view returns(uint){\n        IERC20 token = IERC20(tokenAddress);\n        return token.balanceOf(pair);\n    }\n    \n    //transfer tokens\n    function withdrawToken(address tokenAddress, uint value) external onlyOwner {\n        IERC20 token = IERC20(tokenAddress);\n        bool success = token.transfer(msg.sender, value);\n        require(success, \"Could not transfer token amount!\");\n    }\n\n    //transfer bnb from wbnb\n    function withdrawWrappedBNB(uint value, address payable to) external onlyOwner{\n        WBNB.withdraw(value);\n        to.transfer(value);\n    }\n\t\n\t//transfer bnb\n\tfunction withdrawBNB(uint value) external onlyOwner{\n        msg.sender.transfer(value);\n    }\n\n    //check if token is wbnb\n    function isWBNB(address token) internal pure returns(bool) {\n        return (token == address(WBNB));\n    }\n\n    //transaction is reverted after deadline\n    function getDeadline() internal view returns (uint) {\n        return block.timestamp + 900;\n    }\n}\n"
    },
    "ethereum/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n}"
    },
    "ethereum/IUniswapV1Exchange.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV1Exchange {\r\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\r\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\r\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\r\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\r\n}"
    },
    "ethereum/IUniswapV1Factory.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV1Factory {\r\n    function getExchange(address) external view returns (address);\r\n}"
    },
    "ethereum/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.6.0 <0.7.0;\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n"
    },
    "ethereum/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.6.0 <0.7.0;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"
    },
    "ethereum/IUniswapV2Route.sol": {
      "content": "pragma solidity 0.6.6;\r\n\r\ninterface IUniswapV2Route{\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}"
    },
    "ethereum/IWBNB.sol": {
      "content": "pragma solidity >=0.5.0;\r\n\r\ninterface IWBNB {\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}"
    }
  }
}