{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/LidoRelayer.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\";\n\n// Based on https://github.com/banteg/lido-keep3r/blob/master/contracts/LidoJob.vy,rewritten in solidity\n\ninterface IKeep3r{\n    function isKeeper(address keeper) external view returns (bool);\n    function worked(address keeper) external;\n}\n\ninterface ILido { \n    function getBufferedEther() external view returns (uint256);\n    function depositBufferedEther(uint256 max_deposits) external returns (uint256);\n}\n\ncontract LidoRelayer {\n    IKeep3r RLR = IKeep3r(0x5b3F693EfD5710106eb2Eac839368364aCB5a70f);\n    ILido Lido = ILido(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    uint256 public constant DEPOSIT_SIZE = 32 * 10 ** 18;\n    uint256 public constant MIN_DEPOSITS = 16;\n    uint256 public constant MAX_DEPOSITS = 60;\n    \n    function workable() external view returns (bool) {\n        return Lido.getBufferedEther() / DEPOSIT_SIZE >= MIN_DEPOSITS;\n    }\n\n    function work() public {\n        require(RLR.isKeeper(msg.sender),\"!relayer\");\n        uint256 deposits = Math.min(Lido.getBufferedEther() / DEPOSIT_SIZE, MAX_DEPOSITS);\n        require (deposits >= MIN_DEPOSITS,\"!workable\");\n        Lido.depositBufferedEther(deposits);\n        RLR.worked(msg.sender);\n    }\n}\n"},"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"}}}