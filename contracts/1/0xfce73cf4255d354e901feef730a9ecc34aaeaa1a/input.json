{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/UniswapV2CalleeDai.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-05-04\n*/\n\n// hevm: flattened sources of src/UniswapV2Callee.sol\npragma solidity >=0.6.12;\n\n////// src/UniswapV2Callee.sol\n// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published\n// by the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity >=0.6.12; */\n\ninterface VatLike_7 {\n    function hope(address) external;\n}\n\ninterface GemJoinLike_2 {\n    function dec() external view returns (uint256);\n    function gem() external view returns (TokenLike_2);\n    function exit(address, uint256) external;\n}\n\ninterface DaiJoinLike_2 {\n    function dai() external view returns (TokenLike_2);\n    function vat() external view returns (VatLike_7);\n    function join(address, uint256) external;\n}\n\ninterface TokenLike_2 {\n    function approve(address, uint256) external;\n    function transfer(address, uint256) external;\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface UniswapV2Router02Like {\n    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external returns (uint[] memory);\n}\n\n// Simple Callee Example to interact with MatchingMarket\n// This Callee contract exists as a standalone contract\ncontract UniswapV2Callee {\n    UniswapV2Router02Like   public uniRouter02;\n    DaiJoinLike_2             public daiJoin;\n    TokenLike_2               public dai;\n\n    uint256                 public constant RAY = 10 ** 27;\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(x, sub(y, 1)) / y;\n    }\n\n    function setUp(address uniRouter02_, address daiJoin_) internal {\n        uniRouter02 = UniswapV2Router02Like(uniRouter02_);\n        daiJoin = DaiJoinLike_2(daiJoin_);\n        dai = daiJoin.dai();\n\n        dai.approve(daiJoin_, uint256(-1));\n    }\n\n    function _fromWad(address gemJoin, uint256 wad) internal view returns (uint256 amt) {\n        amt = wad / 10 ** (sub(18, GemJoinLike_2(gemJoin).dec()));\n    }\n}\n\n// Uniswapv2Router02 route directs swaps from one pool to another\ncontract UniswapV2CalleeDai is UniswapV2Callee {\n    constructor(address uniRouter02_, address daiJoin_) public {\n        setUp(uniRouter02_, daiJoin_);\n    }\n\n    function clipperCall(\n        address sender,         // Clipper Caller and Dai deliveryaddress\n        uint256 daiAmt,         // Dai amount to payback[rad]\n        uint256 gemAmt,         // Gem amount received [wad]\n        bytes calldata data     // Extra data needed (gemJoin)\n    ) external {\n        (\n            address to,           // address to send remaining DAI to\n            address gemJoin,      // gemJoin adapter address\n            uint256 minProfit,    // minimum profit in DAI to make [wad]\n            address[] memory path // Uniswap pool path\n        ) = abi.decode(data, (address, address, uint256, address[]));\n\n        // Convert gem amount to token precision\n        gemAmt = _fromWad(gemJoin, gemAmt);\n\n        // Exit collateral to token version\n        GemJoinLike_2(gemJoin).exit(address(this), gemAmt);\n\n        // Approve uniRouter02 to take gem\n        TokenLike_2 gem = GemJoinLike_2(gemJoin).gem();\n        gem.approve(address(uniRouter02), gemAmt);\n\n        // Calculate amount of DAI to Join (as erc20 WAD value)\n        uint256 daiToJoin = divup(daiAmt, RAY);\n\n        // Do operation and get dai amount bought (checking the profit is achieved)\n        uniRouter02.swapExactTokensForTokens(\n            gemAmt,\n            add(daiToJoin, minProfit),\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        // Although Uniswap will accept all gems, this check is a sanity check, just in case\n        // Transfer any lingering gem to specified address\n        if (gem.balanceOf(address(this)) > 0) {\n            gem.transfer(to, gem.balanceOf(address(this)));\n        }\n\n        // Convert DAI bought to internal vat value of the msg.sender of Clipper.take\n        daiJoin.join(sender, daiToJoin);\n\n        // Transfer remaining DAI to specified address\n        dai.transfer(to, dai.balanceOf(address(this)));\n    }\n}\n\n// Maker-Otc is MatchingMarket, which is the core contract of OasisDex\n/* contract UniswapV2CalleeGem is UniswapV2Callee {\n    constructor(address otc_, address clip_, address daiJoin_) public {\n        setUp(otc_, clip_, daiJoin_);\n    }\n\n    function clipperCall(\n        uint256 daiAmt,         // Dai amount to payback[rad]\n        uint256 gemAmt,         // Gem amount received [wad]\n        bytes calldata data     // Extra data needed (gemJoin)\n    ) external {\n        // Get address to send remaining Gem, gemJoin adapter and minProfit in Gem to make\n        (address to, address gemJoin, uint256 minProfit) = abi.decode(data, (address, address, uint256));\n\n        // Convert gem amount to token precision\n        gemAmt = _fromWad(gemJoin, gemAmt);\n\n        // Exit collateral to token version\n        GemJoinLike(gemJoin).exit(address(this), gemAmt);\n\n        // Approve otc to take gem\n        TokenLike gem = GemJoinLike(gemJoin).gem();\n        gem.approve(address(otc), gemAmt);\n\n        // Calculate amount of DAI to Join (as erc20 WAD value)\n        uint256 daiToJoin = daiAmt / RAY;\n        if (daiToJoin * RAY < daiAmt) {\n            daiToJoin = daiToJoin + 1;\n        }\n\n        // Do operation and get gem amount sold (checking the profit is achieved)\n        uint256 gemSold = otc.buyAllAmount(address(dai), daiToJoin, address(gem), gemAmt - minProfit);\n        // TODO: make sure daiToJoin is actually the amount received from buyAllAmount (due rounding)\n\n        // Convert DAI bought to internal vat value\n        daiJoin.join(address(this), daiToJoin);\n\n        // Transfer remaining gem to specified address\n        gem.transfer(to, gemAmt - gemSold);\n    }\n} */"}}}