{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/rooktest.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-01-08\n*/\n\n// SPDX-License-Identifier: Unlicense\n/** MIT License of code referenced:\n * \n * Copyright (c) 2020 Talo Research Pte. Ltd.\n *\n *Permission is hereby granted, free of charge, to any person obtaining a copy of\n *this software and associated documentation files (the \"Software\"), to deal in\n *the Software without restriction, including without limitation the rights to\n *use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n *the Software, and to permit persons to whom the Software is furnished to do so,\n *subject to the following conditions:\n *\n *The above copyright notice and this permission notice shall be included in all\n *copies or substantial portions of the Software.\n *\n *THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n *FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n *COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n *IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n *CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n \npragma solidity >=0.4.21 <0.7.0;\n\n/// @dev This interfaces defines the functions of the KeeperDAO liquidity pool\n/// that our contract needs to know about. The only function we need is the\n/// borrow function, which allows us to take flash loans from the liquidity\n/// pool.\ninterface LiquidityPool {\n    /// @dev Borrow ETH/ERC20s from the liquidity pool. This function will (1)\n    /// send an amount of tokens to the `msg.sender`, (2) call\n    /// `msg.sender.call(_data)` from the KeeperDAO borrow proxy, and then (3)\n    /// check that the balance of the liquidity pool is greater than it was\n    /// before the borrow.\n    ///\n    /// @param _token The address of the ERC20 to be borrowed. ETH can be\n    /// borrowed by specifying \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\".\n    /// @param _amount The amount of the ERC20 (or ETH) to be borrowed. At least\n    /// more than this amount must be returned to the liquidity pool before the\n    /// end of the transaction, otherwise the transaction will revert.\n    /// @param _data The calldata that encodes the callback to be called on the\n    /// `msg.sender`. This is the mechanism through which the borrower is able\n    /// to implement their custom keeper logic. The callback will be called from\n    /// the KeeperDAO borrow proxy.\n    function borrow(\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n/// @dev This contract implements a simple keeper. It borrows ETH from the\n/// KeeperDAO liquidity pool, and immediately returns all of the borrowed ETH,\n/// plus some amount of \"profit\" from its own balance. Instead of returning\n/// profits from their own balances, keeper contracts will usually engage in\n/// arbitrage or liquidations to earn profits that can be returned.\ncontract HelloKeeperDAO {\n    /// @dev Owner of the contract.\n    address public owner;\n\n    /// @dev Address of the KeeperDAO borrow proxy. This will be the\n    /// `msg.sender` for calls to the `helloCallback` function.\n    address public borrowProxy;\n\n    /// @dev Address of the KeeperDAO liquidity pool. This is will be the\n    /// address to which the `helloCallback` function must return all bororwed\n    /// assets (and all excess profits).\n    address payable public liquidityPool;\n\n    /// @dev This modifier restricts the caller of a function to the owner of\n    /// this contract.\n    modifier onlyOwner {\n        if (msg.sender == owner) {\n            _;\n        }\n    }\n\n    /// @dev This modifier restricts the caller of a function to the KeeperDAO\n    /// borrow proxy.\n    modifier onlyBorrowProxy {\n        if (msg.sender == borrowProxy) {\n            _;\n        }\n    }\n\n    constructor() public {\n        owner = msg.sender;\n        borrowProxy = 0x53463cd0b074E5FDafc55DcE7B1C82ADF1a43B2E;\n        liquidityPool = 0x53463cd0b074E5FDafc55DcE7B1C82ADF1a43B2E;\n    }\n\n    receive() external payable {\n        // Do nothing.\n    }\n\n    /// @dev Set the owner of this contract. This function can only be called by\n    /// the current owner.\n    ///\n    /// @param _newOwner The new owner of this contract.\n    function setOwner(address payable _newOwner) external onlyOwner {\n        owner = _newOwner;\n    }\n\n    /// @dev Set the borrow proxy expected by this contract. This function can\n    /// only be called by the current owner.\n    ///\n    /// @param _newBorrowProxy The new borrow proxy expected by this contract.\n    function setBorrowProxy(address _newBorrowProxy) external onlyOwner {\n        borrowProxy = _newBorrowProxy;\n    }\n\n    /// @dev Set the liquidity pool used by this contract. This function can\n    /// only be called by the current owner.\n    ///\n    /// @param _newLiquidityPool The new liquidity pool used by this contract.\n    /// It must be a payable address, because this contract needs to be able to\n    /// return borrowed assets and profits to the liquidty pool.\n    function setLiquidityPool(address payable _newLiquidityPool)\n        external\n        onlyOwner\n    {\n        liquidityPool = _newLiquidityPool;\n    }\n\n    /// @dev This function is the entry point of this keeper. An off-chain bot\n    /// will call this function whenever it decides that it wants to borrow from\n    /// this KeeperDAO liquidity pool. This function is similar to what you\n    /// would expect in a \"real\" keeper implementation: it accepts paramters\n    /// telling it what / how much to borrow, and which callback on this\n    /// contract should be called once the borrowed funds have been transferred.\n    function hello(address _token, uint256 _amountToBorrow, uint256 _amountOfProfitToReturn)\n        external\n        onlyOwner\n    {\n        require(_amountOfProfitToReturn > 0, \"profit is zero\");\n        require(\n            address(this).balance > _amountOfProfitToReturn,\n            \"balance is too low\"\n        );\n\n        // The liquidity pool is guarded from re-entrance, so we can only call\n        // this function once per transaction.\n        LiquidityPool(liquidityPool).borrow(\n            // Address of the token we want to borrow.\n            address(_token),\n            // The amount of WEI that we will borrow. We have to return at least\n            // more than this amount.\n            _amountToBorrow,\n            // Encode the callback into calldata. This will be used to call a\n            // function on this contract.\n            abi.encodeWithSelector(\n                // Function selector of the callback function.\n                this.helloCallback.selector,\n                // First parameter of the callback.\n                _amountToBorrow,\n                // Second parameter of the callback.\n                _amountOfProfitToReturn\n                // Third paramter, fourth parameter, and so on (our callback\n                // only has two paramters).\n            )\n        );\n    }\n\n    /// @dev This is the callback function that implements our custom keeper\n    /// logic. We do not need to call this function directly; it will be called\n    /// by the KeeperDAO borrow proxy when we call borrow on the KeeperDAO\n    /// liquidity pool. In fact, usually, this function should be restricted so\n    /// that is can only be called by the KeeperDAO borrow proxy.\n    ///\n    /// Just before this callback is called by the KeeperDAO borrow proxy, all\n    /// of the assets that we want to borrow will be transferred to this\n    /// contract. In this callback, we can do whatever we want with these\n    /// assets; we can arbitrage between DEXs, liquidity positions on Compound,\n    /// and so on. The only requirement is that at least more than the borrowed\n    /// assets is returned.\n    ///\n    /// For example, imagine that we wanted borrowed 1 ETH. Before this callback\n    /// is called, the KeeperDAO liquidity pool will have transferred 1 ETH to\n    /// this contract. This callback can then do whatever it wants with that ETH.\n    /// However, before the callback returns, it must return at least more than\n    /// 1 ETH to the KeeperDAO liquidity pool (even if it is only returning\n    /// 1 ETH + 1 WEI).\n    ///\n    /// In our example, we will not implement a complicated keeper strategy. We\n    /// will simply return all of the borrowed ETH, plus a non-zero amount of\n    /// profit. The amount of profit is explicitly specified by the owner of\n    /// this contract when they initiate the borrow. Of course, this strategy\n    /// does not generate profit by interacting with other protocols (like most\n    /// keepers do). Instead, it just uses its own balance to return profits to\n    /// KeeperDAO.\n    function helloCallback(\n        uint256 _amountBorrowed,\n        uint256 _amountOfProfitToReturn\n    ) external onlyBorrowProxy {\n        assert(\n            address(this).balance >= _amountOfProfitToReturn + _amountBorrowed\n        );\n        assert(_amountOfProfitToReturn > 0);\n\n        // Notice that assets are transferred back to the liquidity pool, not to\n        // the borrow proxy.\n        liquidityPool.call.value(_amountBorrowed + _amountOfProfitToReturn)(\"\");\n    }\n    \n    function sendETH(address payable _address) external onlyOwner {\n        uint balance = address(this).balance;\n        _address.transfer(balance);\n    }\n    \n    function sendERC20(address _token, address _address, uint256 _amount) external onlyOwner {\n        IERC20(_token).transfer(_address, _amount);\n    }\n\n}"}}}