{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FlashProtocol.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// File: ../../../../media/shakeib98/xio-flash-protocol/contracts/interfaces/IFlashToken.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IFlashToken {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(address to, uint256 value) external returns (bool);\r\n\r\n    function burn(uint256 value) external returns (bool);\r\n}\r\n\r\n// File: ../../../../media/shakeib98/xio-flash-protocol/contracts/interfaces/IFlashReceiver.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IFlashReceiver {\r\n    function receiveFlash(\r\n        bytes32 id,\r\n        uint256 amountIn,\r\n        uint256 expireAfter,\r\n        uint256 mintedAmount,\r\n        address staker,\r\n        bytes calldata data\r\n    ) external returns (uint256);\r\n}\r\n\r\n// File: ../../../../media/shakeib98/xio-flash-protocol/contracts/interfaces/IFlashProtocol.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IFlashProtocol {\r\n    enum LockedFunctions { SET_MATCH_RATIO, SET_MATCH_RECEIVER }\r\n\r\n    function TIMELOCK() external view returns (uint256);\r\n\r\n    function FLASH_TOKEN() external view returns (address);\r\n\r\n    function matchRatio() external view returns (uint256);\r\n\r\n    function matchReceiver() external view returns (address);\r\n\r\n    function stakes(bytes32 _id)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amountIn,\r\n            uint256 expiry,\r\n            uint256 expireAfter,\r\n            uint256 mintedAmount,\r\n            address staker,\r\n            address receiver\r\n        );\r\n\r\n    function stake(\r\n        uint256 _amountIn,\r\n        uint256 _days,\r\n        address _receiver,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        returns (\r\n            uint256 mintedAmount,\r\n            uint256 matchedAmount,\r\n            bytes32 id\r\n        );\r\n\r\n    function lockFunction(LockedFunctions _lockedFunction) external;\r\n\r\n    function unlockFunction(LockedFunctions _lockedFunction) external;\r\n\r\n    function timelock(LockedFunctions _lockedFunction) external view returns (uint256);\r\n\r\n    function balances(address _staker) external view returns (uint256);\r\n\r\n    function unstake(bytes32 _id) external returns (uint256 withdrawAmount);\r\n\r\n    function unstakeEarly(bytes32 _id) external returns (uint256 withdrawAmount);\r\n\r\n    function getFPY(uint256 _amountIn) external view returns (uint256);\r\n\r\n    function setMatchReceiver(address _newMatchReceiver) external;\r\n\r\n    function setMatchRatio(uint256 _newMatchRatio) external;\r\n\r\n    function getMatchedAmount(uint256 mintedAmount) external view returns (uint256);\r\n\r\n    function getMintAmount(uint256 _amountIn, uint256 _expiry) external view returns (uint256);\r\n\r\n    function getPercentageStaked(uint256 _amountIn) external view returns (uint256 percentage);\r\n\r\n    function getInvFPY(uint256 _amount) external view returns (uint256);\r\n\r\n    function getPercentageUnStaked(uint256 _amount) external view returns (uint256 percentage);\r\n}\r\n\r\n// File: ../../../../media/shakeib98/xio-flash-protocol/contracts/libraries/SafeMath.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n// A library for performing overflow-safe math, courtesy of DappHub: https://github.com/dapphub/ds-math/blob/d0ef6d6a5f/src/math.sol\r\n// Modified to include only the essentials\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"MATH:: ADD_OVERFLOW\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"MATH:: SUB_UNDERFLOW\");\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MATH:: MUL_OVERFLOW\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"MATH:: DIVISION_BY_ZERO\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: ../../../../media/shakeib98/xio-flash-protocol/contracts/libraries/Address.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: ../../../../media/shakeib98/xio-flash-protocol/contracts/FlashProtocol.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FlashProtocol is IFlashProtocol {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    struct Stake {\r\n        uint256 amountIn;\r\n        uint256 expiry;\r\n        uint256 expireAfter;\r\n        uint256 mintedAmount;\r\n        address staker;\r\n        address receiver;\r\n    }\r\n\r\n    uint256 public constant override TIMELOCK = 3 days;\r\n    address public constant override FLASH_TOKEN = 0xB4467E8D621105312a914F1D42f10770C0Ffe3c8;\r\n\r\n    uint256 internal constant PRECISION = 1e18;\r\n    uint256 internal constant MAX_FPY_FOR_1_YEAR = 5e17;\r\n    uint256 internal constant SECONDS_IN_1_YEAR = 365 * 86400;\r\n\r\n    uint256 public override matchRatio;\r\n    address public override matchReceiver;\r\n\r\n    mapping(bytes32 => Stake) public override stakes;\r\n    mapping(LockedFunctions => uint256) public override timelock;\r\n    mapping(address => uint256) public override balances;\r\n\r\n    event Staked(\r\n        bytes32 _id,\r\n        uint256 _amountIn,\r\n        uint256 _expiry,\r\n        uint256 _expireAfter,\r\n        uint256 _mintedAmount,\r\n        address indexed _staker,\r\n        address indexed _receiver\r\n    );\r\n\r\n    event Unstaked(bytes32 _id, uint256 _amountIn, address indexed _staker);\r\n\r\n    modifier onlyMatchReceiver {\r\n        require(msg.sender == matchReceiver, \"FlashProtocol:: NOT_MATCH_RECEIVER\");\r\n        _;\r\n    }\r\n\r\n    modifier notLocked(LockedFunctions _lockedFunction) {\r\n        require(\r\n            timelock[_lockedFunction] != 0 && timelock[_lockedFunction] <= block.timestamp,\r\n            \"FlashProtocol:: FUNCTION_TIMELOCKED\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _initialMatchReceiver) public {\r\n        _setMatchReceiver(_initialMatchReceiver);\r\n    }\r\n\r\n    function lockFunction(LockedFunctions _lockedFunction) external override onlyMatchReceiver {\r\n        timelock[_lockedFunction] = type(uint256).max;\r\n    }\r\n\r\n    function unlockFunction(LockedFunctions _lockedFunction) external override onlyMatchReceiver {\r\n        timelock[_lockedFunction] = block.timestamp + TIMELOCK;\r\n    }\r\n\r\n    function setMatchReceiver(address _newMatchReceiver)\r\n        external\r\n        override\r\n        onlyMatchReceiver\r\n        notLocked(LockedFunctions.SET_MATCH_RECEIVER)\r\n    {\r\n        _setMatchReceiver(_newMatchReceiver);\r\n        timelock[LockedFunctions.SET_MATCH_RECEIVER] = 0;\r\n    }\r\n\r\n    function _setMatchReceiver(address _newMatchReceiver) internal {\r\n        matchReceiver = _newMatchReceiver;\r\n    }\r\n\r\n    function setMatchRatio(uint256 _newMatchRatio)\r\n        external\r\n        override\r\n        onlyMatchReceiver\r\n        notLocked(LockedFunctions.SET_MATCH_RATIO)\r\n    {\r\n        require(_newMatchRatio >= 0 && _newMatchRatio <= 2000, \"FlashProtocol:: INVALID_MATCH_RATIO\");\r\n        matchRatio = _newMatchRatio;\r\n        timelock[LockedFunctions.SET_MATCH_RATIO] = 0;\r\n    }\r\n\r\n    function stake(\r\n        uint256 _amountIn,\r\n        uint256 _expiry,\r\n        address _receiver,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        override\r\n        returns (\r\n            uint256 mintedAmount,\r\n            uint256 matchedAmount,\r\n            bytes32 id\r\n        )\r\n    {\r\n        require(_amountIn > 0, \"FlashProtocol:: INVALID_AMOUNT\");\r\n\r\n        require(_receiver != address(this), \"FlashProtocol:: INVALID_ADDRESS\");\r\n\r\n        address staker = msg.sender;\r\n\r\n        require(_expiry <= calculateMaxStakePeriod(_amountIn), \"FlashProtocol:: MAX_STAKE_PERIOD_EXCEEDS\");\r\n\r\n        uint256 expiration = block.timestamp.add(_expiry);\r\n\r\n        IFlashToken(FLASH_TOKEN).transferFrom(staker, address(this), _amountIn);\r\n\r\n        balances[staker] = balances[staker].add(_amountIn);\r\n\r\n        id = keccak256(abi.encodePacked(_amountIn, _expiry, _receiver, staker, block.timestamp));\r\n\r\n        require(stakes[id].staker == address(0), \"FlashProtocol:: STAKE_EXISTS\");\r\n\r\n        mintedAmount = getMintAmount(_amountIn, _expiry);\r\n        matchedAmount = getMatchedAmount(mintedAmount);\r\n\r\n        IFlashToken(FLASH_TOKEN).mint(_receiver, mintedAmount);\r\n        IFlashToken(FLASH_TOKEN).mint(matchReceiver, matchedAmount);\r\n\r\n        stakes[id] = Stake(_amountIn, _expiry, expiration, mintedAmount, staker, _receiver);\r\n\r\n        if (_receiver.isContract()) {\r\n            IFlashReceiver(_receiver).receiveFlash(id, _amountIn, expiration, mintedAmount, staker, _data);\r\n        }\r\n\r\n        emit Staked(id, _amountIn, _expiry, expiration, mintedAmount, staker, _receiver);\r\n    }\r\n\r\n    function unstake(bytes32 _id) external override returns (uint256 withdrawAmount) {\r\n        Stake memory s = stakes[_id];\r\n        require(block.timestamp >= s.expireAfter, \"FlashProtol:: STAKE_NOT_EXPIRED\");\r\n        balances[s.staker] = balances[s.staker].sub(s.amountIn);\r\n        withdrawAmount = s.amountIn;\r\n        delete stakes[_id];\r\n        IFlashToken(FLASH_TOKEN).transfer(s.staker, withdrawAmount);\r\n        emit Unstaked(_id, s.amountIn, s.staker);\r\n    }\r\n\r\n    function unstakeEarly(bytes32 _id) external override returns (uint256 withdrawAmount) {\r\n        Stake memory s = stakes[_id];\r\n        address staker = msg.sender;\r\n        require(s.staker == staker, \"FlashProtocol:: INVALID_STAKER\");\r\n        uint256 remainingTime = (s.expireAfter.sub(block.timestamp));\r\n        uint256 burnAmount = _calculateBurn(s.amountIn, remainingTime, s.expiry);\r\n        assert(burnAmount <= s.amountIn);\r\n        balances[staker] = balances[staker].sub(s.amountIn);\r\n        withdrawAmount = s.amountIn.sub(burnAmount);\r\n        delete stakes[_id];\r\n        IFlashToken(FLASH_TOKEN).burn(burnAmount);\r\n        IFlashToken(FLASH_TOKEN).transfer(staker, withdrawAmount);\r\n        emit Unstaked(_id, s.amountIn, staker);\r\n    }\r\n\r\n    function getMatchedAmount(uint256 _mintedAmount) public override view returns (uint256) {\r\n        return _mintedAmount.mul(matchRatio).div(10000);\r\n    }\r\n\r\n    function getMintAmount(uint256 _amountIn, uint256 _expiry) public override view returns (uint256) {\r\n        return _amountIn.mul(_expiry).mul(getFPY(_amountIn)).div(PRECISION * SECONDS_IN_1_YEAR);\r\n    }\r\n\r\n    function getFPY(uint256 _amountIn) public override view returns (uint256) {\r\n        return (PRECISION.sub(getPercentageStaked(_amountIn))).div(2);\r\n    }\r\n\r\n    function getPercentageStaked(uint256 _amountIn) public override view returns (uint256 percentage) {\r\n        uint256 locked = IFlashToken(FLASH_TOKEN).balanceOf(address(this)).add(_amountIn);\r\n        percentage = locked.mul(PRECISION).div(IFlashToken(FLASH_TOKEN).totalSupply());\r\n    }\r\n\r\n    function _calculateBurn(\r\n        uint256 _amount,\r\n        uint256 _remainingTime,\r\n        uint256 _totalTime\r\n    ) private view returns (uint256 burnAmount) {\r\n        burnAmount = _amount.mul(_remainingTime).mul(getInvFPY(_amount)).div(_totalTime.mul(PRECISION));\r\n    }\r\n\r\n    function getInvFPY(uint256 _amount) public override view returns (uint256) {\r\n        return PRECISION.sub(getPercentageUnStaked(_amount));\r\n    }\r\n\r\n    function getPercentageUnStaked(uint256 _amount) public override view returns (uint256 percentage) {\r\n        uint256 locked = IFlashToken(FLASH_TOKEN).balanceOf(address(this)).sub(_amount);\r\n        percentage = locked.mul(PRECISION).div(IFlashToken(FLASH_TOKEN).totalSupply());\r\n    }\r\n\r\n    function calculateMaxStakePeriod(uint256 _amountIn) private view returns (uint256) {\r\n        return MAX_FPY_FOR_1_YEAR.mul(SECONDS_IN_1_YEAR).div(getFPY(_amountIn));\r\n    }\r\n}"}}}