{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/FOCProxy.sol":{"content":"pragma solidity 0.8.1;\nimport './FansOnlyCoin.sol';\ncontract Proxy {\n    // Code position in storage is keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\n    constructor(bytes memory constructData, address contractLogic) {\n        // save the code address\n        assembly { // solium-disable-line\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)\n        }\n        (bool success, bytes memory result ) = contractLogic.delegatecall(constructData); // solium-disable-line\n        require(success, \"Construction failed\");\n    }\n\n    fallback() external payable {\n        assembly { // solium-disable-line\n            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(sub(gas(), 10000), contractLogic, 0x0, calldatasize(), 0, 0)\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n            case 0 {\n                revert(0, retSz)\n            }\n            default {\n                return(0, retSz)\n            }\n        }\n    }\n}\n\ncontract Proxiable {\n    // Code position in storage is keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\n\n    function updateCodeAddress(address newAddress) internal {\n        require(\n            bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),\n            \"Not compatible\"\n        );\n        assembly { // solium-disable-line\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, newAddress)\n        }\n    }\n\n    function proxiableUUID() public pure returns (bytes32) {\n        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\n    }\n} \n\n\ncontract MyTokenLogic is FansOnlyCoin, Proxiable {\n\n    function updateCode(address newCode) public {\n        updateCodeAddress(newCode);\n    }\n}"},"contracts/FansOnlyCoin.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2020-06-25\n*/\n\npragma solidity 0.8.1;\n\nlibrary SafeMath\n{\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256)\n    \t{\n\t\tuint256 c = a * b;\n\t\tassert(a == 0 || c / a == b);\n\n\t\treturn c;\n  \t}\n\n  \tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n\t{\n\t\tuint256 c = a / b;\n\n\t\treturn c;\n  \t}\n\n  \tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n\t{\n\t\tassert(b <= a);\n\n\t\treturn a - b;\n  \t}\n\n  \tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n\t{\n\t\tuint256 c = a + b;\n\t\tassert(c >= a);\n\n\t\treturn c;\n  \t}\n}\n\ncontract OwnerHelper\n{\n  \taddress public owner;\n    address public manager;\n\n  \tevent ChangeOwner(address indexed _from, address indexed _to);\n    event ChangeManager(address indexed _from, address indexed _to);\n\n    function setOwner(address to) public {\n        require(owner == address(0), \"Already initalized\");\n        owner = to;\n    }\n  \tmodifier onlyOwner\n\t{\n\t\trequire(msg.sender == owner, \"Only owner is allowed to perform this action\");\n\t\t_;\n  \t}\n  \t\n    modifier onlyManager\n    {\n        require(msg.sender == manager);\n        _;\n    }\n  \t\n  \tfunction transferOwnership(address _to) onlyOwner public\n  \t{\n    \trequire(_to != owner);\n        require(_to != manager);\n    \trequire(_to != address(0x0));\n\n        address from = owner;\n      \towner = _to;\n  \t    \n      \temit ChangeOwner(from, _to);\n  \t}\n\n    function transferManager(address _to) onlyOwner public\n    {\n        require(_to != owner);\n        require(_to != manager);\n        require(_to != address(0x0));\n        \n        address from = manager;\n        manager = _to;\n        \n        emit ChangeManager(from, _to);\n    }\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract FansOnlyCoin is IERC20, OwnerHelper\n{\n    using SafeMath for uint;\n    \n    string public name;\n    uint public decimals;\n    string public symbol;\n    \n    uint  private E9;\n    uint private month;\n    \n    // Total                                  \n    uint public maxTotalSupply;\n    // Sale                                   \n    uint public maxSaleSupply;\n    // Team                                   (25%)\n    uint public vestingScheduleSupply;\n    \n    // Lock\n    uint  public vestingLockDate;\n    \n    uint public totalTokenSupply;\n    uint public tokenIssuedSale;\n        \n    uint public burnTokenSupply;\n    \n    mapping (address => uint) public balances;\n    mapping (address => mapping ( address => uint )) public approvals;\n    \n    bool public tokenLock = true;\n    bool public saleTime = true;\n    uint256 lastRun;\n    uint public endSaleTime = 0;\n\n    event SaleIssue(address indexed _to, uint _tokens);\n    event SaleIssueLock(uint _tokens);\n\n    event Burn(address indexed _from, uint _tokens);\n    \n    event TokenUnlock(address indexed _to, uint _tokens);\n    event EndSale(uint _date);\n    \n    function constructor1() public\n    {\n        setOwner(msg.sender);\n        name        = \"FansOnlyCoin\";\n        decimals    = 9;\n        symbol      = \"FOC\";\n    \n        E9 = 100000000;\n        month = 2592000;\n    \n        maxTotalSupply     = 10**12 * E9;\n        maxSaleSupply      = 10**12 * E9;\n        vestingScheduleSupply      = 25*10**10 * E9;\n        vestingLockDate =  4* month;\n        totalTokenSupply = 10**12 * E9;\n        \n        balances[msg.sender] = vestingScheduleSupply;\n        require(maxTotalSupply==maxSaleSupply,\"\");\n        maxSaleSupply=maxSaleSupply.sub(vestingScheduleSupply);\n\n        tokenIssuedSale     = 0;\n        burnTokenSupply     = 0;\n        lastRun=block.timestamp;\n    }\n\n    function showowner() view public returns (address) \n    {\n        return owner;\n    }\n    function showmsgsender() view public returns (address) \n    {\n        return msg.sender;\n    }\n    \n    function totalSupply() override view public returns (uint) \n    {\n        return totalTokenSupply;\n    }\n    \n    function balanceOf(address _who) override view public returns (uint) \n    {\n        return balances[_who];\n    }\n    \n    function transfer(address _to, uint _value) override public returns (bool) \n    {\n        require(isTransferable() == true);\n        require(balances[msg.sender] >= _value);\n        \n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        \n        emit Transfer(msg.sender, _to, _value);\n        \n        return true;\n    }\n    \n    function approve(address _spender, uint _value) override public returns (bool)\n    {\n        require(isTransferable() == true);\n        require(balances[msg.sender] >= _value);\n        \n        approvals[msg.sender][_spender] = _value;\n        \n        emit Approval(msg.sender, _spender, _value);\n        \n        return true; \n    }\n    \n    function allowance(address _owner, address _spender) override view public returns (uint) \n    {\n        return approvals[_owner][_spender];\n    }\n\n    function transferFrom(address _from, address _to, uint _value) override public returns (bool) \n    {\n        require(isTransferable() == true);\n        require(balances[_from] >= _value);\n        require(approvals[_from][msg.sender] >= _value);\n        \n        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to]  = balances[_to].add(_value);\n        \n        emit Transfer(_from, _to, _value);\n        \n        return true;\n    }\n    \n    function saleIssue(address _to) onlyOwner public\n    {   \n        require(tokenIssuedSale == 0);    \n        uint tokens = vestingScheduleSupply;\n        \n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n\n        balances[_to] = balances[_to].add(tokens);\n        \n        tokenIssuedSale = tokenIssuedSale.add(tokens);\n        \n        emit SaleIssue(_to, tokens);\n    }\n\n    function saleIssueLock() onlyOwner public\n    {\n        require(saleTime == false);\n        require(block.timestamp - lastRun > 2592000, 'It is not time to release vesting');\n        require(maxSaleSupply >= vestingScheduleSupply,\"no tokens to vest\");\n        \n        uint tokens = vestingScheduleSupply;\n        maxSaleSupply=maxSaleSupply.sub(tokens);\n        balances[msg.sender] = balances[msg.sender].add(tokens);\n        \n        lastRun = block.timestamp;\n        \n        emit SaleIssueLock(tokens);\n    }\n\n    function isTransferable() private view returns (bool)\n    {\n        if(tokenLock == false)\n        {\n            return true;\n        }\n        else if(msg.sender == owner)\n        {\n            return true;\n        }\n        \n        return false;\n    }\n    \n    function setTokenUnlock() onlyManager public\n    {\n        require(tokenLock == true);\n        require(saleTime == false);\n        \n        tokenLock = false;\n    }\n    \n    function setTokenLock() onlyManager public\n    {\n        require(tokenLock == false);\n        \n        tokenLock = true;\n    }\n    \n    function endSale() onlyOwner public\n    {\n        require(saleTime == true);\n        \n        saleTime = false;\n        \n        uint nowTime = block.timestamp;\n        endSaleTime = nowTime;\n        \n        emit EndSale(endSaleTime);\n    }\n    \n    function transferAnyERC20Token(address tokenAddress, uint tokens) onlyOwner public returns (bool success)\n    {\n        return IERC20(tokenAddress).transfer(manager, tokens);\n    }\n    \n    function burnToken(uint _value) onlyManager public\n    {\n        uint tokens = _value * E9;\n        \n        require(balances[msg.sender] >= tokens);\n        \n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        \n        burnTokenSupply = burnTokenSupply.add(tokens);\n        totalTokenSupply = totalTokenSupply.sub(tokens);\n        \n        emit Burn(msg.sender, tokens);\n    }\n    \n}"}}}