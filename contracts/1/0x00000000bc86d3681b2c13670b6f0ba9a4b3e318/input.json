{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/BotMultiCallerAssembly.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\ncontract BotMultiCallerAssembly {\n    // TODO: update\n    modifier onlyOwner() {\n        require(msg.sender == 0x030643c61c433c68866012a097884f0058355302);\n        _;\n    }\n\n    // TODO: update\n    // modifier onlyDydx() {\n    //     require(msg.sender == 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE);\n    //     _;\n    // }\n    \n    constructor() payable {}\n\n    receive() external payable {\n    }\n\n    // trade\n    function jIUTh(bytes calldata _data) external onlyOwner payable {\n        trade(_data);\n    }\n\n    function trade(bytes calldata _data) internal {\n        // check balance\n        uint256 balanceBefore;\n        assembly {\n            let balanceBeforePtr := mload(0x40)\n            \n            // check balance\n            mstore(balanceBeforePtr, 0x70a0823100000000000000000000000000000000000000000000000000000000)\n            mstore(add(balanceBeforePtr, 4), address())\n            let success := staticcall(\n                0x2DC6C0,\n                0x000000000000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // TODO: WETH\n                balanceBeforePtr,\n                0x24,\n                balanceBeforePtr,\n                0x20\n            )\n\n            balanceBefore := mload(balanceBeforePtr)\n        }\n\n        // trade\n        uint256 lCoinbase;\n        uint256 multicallIndexStart;\n        assembly {\n            lCoinbase := shr(248, calldataload(add(_data.offset, 9)))\n            multicallIndexStart := add(10, lCoinbase)\n        }\n        multicall(_data[multicallIndexStart:_data.length]);\n\n        // check balance\n        assembly {\n            let balanceAfterPtr := mload(0x40)\n            \n            mstore(balanceAfterPtr, 0x70a0823100000000000000000000000000000000000000000000000000000000)\n            mstore(add(balanceAfterPtr, 4), address())\n            let success := staticcall(\n                0x2DC6C0,\n                0x000000000000000000000000C02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // TODO: WETH\n                balanceAfterPtr,\n                0x24,\n                balanceAfterPtr,\n                0x20\n            )\n\n            // check profit\n            let expectProfit := shr(192, calldataload(_data.offset))\n            let negativeProfit := shr(248, calldataload(add(_data.offset, 8)))\n            if and(negativeProfit, lt(mload(balanceAfterPtr), sub(balanceBefore, expectProfit))) {\n                revert(0,0)\n            }\n            \n            if and(not(negativeProfit), lt(mload(balanceAfterPtr), add(balanceBefore, expectProfit))) {\n                revert(0,0)\n            }\n\n            // miner reward coinbase\n            if not(iszero(lCoinbase)) {\n                success := call(\n                    0x2DC6C0,\n                    coinbase(),\n                    shr(mul(8, sub(32, lCoinbase)), calldataload(add(_data.offset, 10))),\n                    0x00,\n                    0x00,\n                    0x00,\n                    0x20\n                )\n            }\n        }\n    }\n\n    function multicall(bytes calldata _data) internal {\n        assembly {\n            let x := mload(0x40)\n            let index := _data.offset\n            let indexEnd := add(_data.length, _data.offset)\n\n            for { } lt(index, indexEnd) { } {\n                let lcompressedPayload := shr(240, calldataload(add(index, 29)))\n                let countGroup := shr(248, calldataload(add(index, 31)))\n                let lGroup := mul(3, countGroup)\n                let compressedPayloadIndex := add(add(index, 32), lGroup)\n                let payloadIndex := x\n                let lastPos := 0\n                \n                for { let i:= 0 } lt(i, countGroup) { i := add(i, 1) } {\n                    let f := add(add(index, 32), mul(i, 3))\n                    let pos := shr(240, calldataload(f))\n                    let len := shr(248, calldataload(add(f, 2)))\n                    \n                    for { let read := 0 } lt(add(lastPos, read), pos) { read := add(read, 32) } {\n                        mstore(add(x, read), calldataload(add(add(compressedPayloadIndex, lastPos), read)))\n                    }\n                    \n                    x := add(x, sub(pos, lastPos))\n                    \n                    for { let write := 0 } lt(write, len) { write := add(write, 32) } {\n                        mstore(add(x, write), 0x0000000000000000000000000000000000000000000000000000000000000000)\n                    }\n                    \n                    x := add(x, len)\n                    \n                    lastPos := pos\n                }\n                \n                for { let read := 0 } lt(add(lastPos, read), lcompressedPayload) { read := add(read, 32) } {\n                    mstore(add(x, read), calldataload(add(add(compressedPayloadIndex, lastPos), read)))\n                }\n                \n                x := add(x, sub(lcompressedPayload, lastPos))\n                \n                let success := call(\n                    0x2DC6C0,\n                    shr(96, calldataload(add(index, 9))),\n                    shr(184, calldataload(index)),\n                    payloadIndex,\n                    sub(x, payloadIndex),\n                    x,\n                    0x20\n                )\n                if iszero(success) { revert(0,0) }\n\n                index := add(index, add(add(32, lGroup), lcompressedPayload))\n            }\n        }\n    }\n\n    function validatePool(bytes calldata _data) view internal {\n        assembly {\n            let tokenIn := div(calldataload(_data.offset), 0x1000000000000000000000000) // 20 bytes\n            let tokenOut := div(calldataload(add(_data.offset, 20)), 0x1000000000000000000000000) // 20 bytes\n            let fee := div(calldataload(add(_data.offset, 40)), 0x10000000000000000000000000000000000000000000000000000000000) // 3 bytes\n\n            // calculate pool address\n            let x := mload(0x40)\n            switch lt(tokenIn, tokenOut)\n            case 1 {\n                mstore(x, tokenIn)\n                mstore(add(x, 0x20), tokenOut)\n            }\n            default {\n                mstore(x, tokenOut)\n                mstore(add(x, 0x20), tokenIn)\n            }\n            mstore(add(x, 0x40), fee)\n\n            mstore(add(x, 32), keccak256(x, 0x60))\n            mstore(x, 0x0000000000000000000000ff1F98431c8aD98523631AE4a59f267346ea31F984) // TODO: Univ3Factory 0x1F98431c8aD98523631AE4a59f267346ea31F984\n            mstore(add(x, 64), 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54) // UniswapV3: POOL_INIT_CODE_HASH\n        \n            // validate caller is pool\n            if xor(caller(), and(keccak256(add(x, 11), 85), 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff)) {\n                revert(0,0)\n            }\n        }\n    }\n\n    function uniswapV3SwapCallback(\n        int256,\n        int256,\n        bytes calldata _data\n    ) external {\n        validatePool(_data);\n        multicall(_data[43:_data.length]);\n    }\n\n    function uniswapV3FlashCallback(uint256, uint256, bytes calldata _data) external {\n        validatePool(_data);\n        trade(_data[43:_data.length]);\n    }\n\n    function calll(address payable _to, uint256 _value, bytes calldata _data) external onlyOwner payable returns (bytes memory) {\n        require(_to != address(0));\n        (bool _success, bytes memory _result) = _to.call{value: _value}(_data);\n        require(_success);\n        return _result;\n    }\n\n    // flash uni v3\n    function jMMeC(bytes calldata _data) external onlyOwner payable {\n        assembly {\n            let x := mload(0x40)\n            mstore(x, 0x490e6cbc00000000000000000000000000000000000000000000000000000000)\n            mstore(add(x, 4), address())\n            mstore(add(x, 36), 0x0000000000000000000000000000000000000000000000000000000000000000)\n            mstore(add(x, 68), shr(176, calldataload(_data.offset))) // borrow\n            mstore(add(x, 100), 0x0000000000000000000000000000000000000000000000000000000000000080)\n            mstore(add(x, 132), sub(_data.length, 10))\n            calldatacopy(add(x, 164), add(_data.offset, 10), sub(_data.length, 10))\n\n            let success := call(\n                0x2DC6C0,\n                0x00000000000000000000000088e6A0c2dDD26FEEb64F039a2c41296FcB3f5640, // TODO: UniV3 flash that weth is token1\n                0x00,\n                x,\n                add(164, _data.length),\n                x,\n                0x20\n            )\n            if iszero(success) { revert(0,0) }\n        }\n    }\n\n    // function callFunction(address _sender, Account.Info memory, bytes calldata _data) external onlyOwner(_sender) onlyDydx {\n    //     trade(_data);\n    // }\n}"
    }
  }
}