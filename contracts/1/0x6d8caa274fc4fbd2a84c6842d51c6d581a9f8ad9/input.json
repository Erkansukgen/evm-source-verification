{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/exchange.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n// SPDX-License-Identifier: UNLICENSED\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface InterfaceERC20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @dev Unsigned math operations with safety checks that revert on error.\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\ncontract exchange {\n    using SafeMath for uint256;\n    address public manager;\n    address public USDT;\n    address public GWTB;\n    uint256 public USDT_GWTB; // default 0.19\n    bool public USDT_GWTB_IS_OPEN;\n    bool public GWTB_USDT_IS_OPEN;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n\n    struct user{\n        address user;\n        address referrer;\n        uint256 gwtb_total; // usdt -> gwtb 总量\n        uint256 usdt_total; // gwtb -> usdt 总量\n    }\n    user[] public UserData;\n    mapping(address => uint256) public UserIndex;\n\n    event usdt_gwtb_event(address user,uint256 from_usdt,uint256 to_gwtb);\n    event gwtb_usdt_event(address user,uint256 from_gwtb,uint256 to_usdt);\n    \n    constructor(address usdt,address gwtb)public{\n        USDT = usdt;\n        GWTB = gwtb;\n        manager = msg.sender;\n    }\n\n    // USDT - GWTB \n    function usdt_gwtb(address referrer,uint256 value)public{\n        require(value > 0 && USDT_GWTB_IS_OPEN == true);\n        // 转入USDT\n        _safeFromTransfer(USDT,msg.sender,address(this),value);\n        uint256 total = getUSDT_GWTB(value.mul((10 ** 12)));\n        // 将GWTB转到用户地址\n        InterfaceERC20(GWTB).transfer(msg.sender,total);\n        uint256 index = UserIndex[msg.sender];\n        if(index == 0){\n            if(referrer != msg.sender && referrer != address(0)){\n                UserData.push(user({user:msg.sender,referrer:referrer,gwtb_total:total,usdt_total:0}));\n            }else{\n                UserData.push(user({user:msg.sender,referrer:address(0),gwtb_total:total,usdt_total:0}));\n            }\n            UserIndex[msg.sender] = UserData.length;\n        }else if(UserData[UserIndex[msg.sender].sub(1)].referrer == address(0) && referrer != msg.sender){\n            UserData[UserIndex[msg.sender].sub(1)].referrer = referrer;\n        }\n        if(index != 0){\n            UserData[UserIndex[msg.sender].sub(1)].gwtb_total += total;\n        }\n        emit usdt_gwtb_event(msg.sender,value,total);\n    }\n    \n    // GWTB - USDT\n    function gwtb_usdt(address referrer,uint256 value)public{\n        require(value > 0 && GWTB_USDT_IS_OPEN == true);\n        // 转入GWTB\n        _safeFromTransfer(GWTB,msg.sender,address(this),value);\n        uint256 total = getGWTB_USDT(value.div((10 ** 12)));\n        InterfaceERC20(USDT).transfer(msg.sender,total);\n        \n        uint256 index = UserIndex[msg.sender];\n        if(index == 0){\n            if(referrer != msg.sender && referrer != address(0)){\n                UserData.push(user({user:msg.sender,referrer:referrer,gwtb_total:0,usdt_total:total}));\n            }else{\n                UserData.push(user({user:msg.sender,referrer:address(0),gwtb_total:0,usdt_total:total}));\n            }\n            UserIndex[msg.sender] = UserData.length;\n        }else if(UserData[UserIndex[msg.sender].sub(1)].referrer == address(0) && referrer != msg.sender){\n            UserData[UserIndex[msg.sender].sub(1)].referrer = referrer;\n        }\n        if(index != 0){\n            UserData[UserIndex[msg.sender].sub(1)].usdt_total += total;\n        }\n        emit gwtb_usdt_event(msg.sender,value,total);\n    }\n    \n    function getUserData() view public returns(user[] memory){\n        return UserData;\n    }\n    // 5263000\n    // 计算交换金额\n    // 公式：1 / 190 * 1000\n    function getUSDT_GWTB(uint256 value) view public returns(uint256){\n        return value.div(USDT_GWTB).mul(1000);\n    }\n    \n    // 公式：1 * 190 / 1000\n    function getGWTB_USDT(uint256 value) view public returns(uint256){\n        return value.mul(USDT_GWTB).div(1000);\n    }\n    \n    // 设置USDT当前兑换价格\n    function ownerSetUSDT_GWTB(uint256 value)public onlyOwner{\n        require(value > 0);\n        USDT_GWTB = value;\n    }\n    \n    // 开启USDT-GWTB\n    function ownerIsOpenExchange(bool b,uint256 i) public onlyOwner{\n        if (i == 1){\n            USDT_GWTB_IS_OPEN = b;\n        }else if(i == 2){\n            GWTB_USDT_IS_OPEN = b;\n        }\n    }\n    \n    // Owner转移\n    function ownerTransfer(address newOwner) public onlyOwner{\n        require(newOwner != address(0));\n        manager = newOwner;\n    }\n    \n    // 提币\n    function ownerWithdrawal(uint256 value,uint256 i) public onlyOwner{\n        if(i == 1){\n            InterfaceERC20(USDT).transfer(msg.sender,value);\n        }else if(i == 2){\n            InterfaceERC20(GWTB).transfer(msg.sender,value);\n        }\n    }\n    \n    function _safeFromTransfer(address _token,address f, address to, uint value) private {\n        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(SELECTOR, f, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Exchange: TRANSFER_FAILED');\n    }\n    \n    modifier onlyOwner {\n        require(manager == msg.sender);\n        _;\n    }\n}"}}}