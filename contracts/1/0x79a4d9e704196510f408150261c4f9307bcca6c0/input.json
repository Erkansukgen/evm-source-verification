{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/unicPreSale400.sol":{"content":"\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.7.5;\r\n\r\ninterface IERC20Token {\r\n    function balanceOf(address owner) external returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function decimals() external returns (uint256);\r\n}\r\n\r\n\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"ERC20: sending to the zero address\");\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n\r\ncontract TokenSale is Owned{\r\n    IERC20Token public tokenContract;  // the token being sold\r\n    uint256 public price = 400;              // 1eth = 400 tokens\r\n    uint256 public decimals = 18;\r\n    \r\n    uint256 public tokensSold;\r\n    uint256 public ethRaised;\r\n    uint256 public MaxETHAmount;\r\n\r\n    event Sold(address buyer, uint256 amount);\r\n\r\n    constructor(IERC20Token _tokenContract, uint256 _maxEthAmount) {\r\n        owner = msg.sender;\r\n        tokenContract = _tokenContract;\r\n        MaxETHAmount = _maxEthAmount;\r\n    }\r\n    \r\n    fallback() external payable {\r\n        buyTokensWithETH(msg.sender);\r\n    }\r\n\r\n    // Guards against integer overflows\r\n    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 c = a * b;\r\n            assert(c / a == b);\r\n            return c;\r\n        }\r\n    }\r\n    \r\n    function multiply(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    \r\n    function setPrice(uint256 price_) external onlyOwner{\r\n        price = price_;\r\n    }\r\n\r\n\r\n    function buyTokensWithETH(address _receiver) public payable {\r\n        require(ethRaised < MaxETHAmount, \"Presale finished\");\r\n        uint _amount = msg.value; \r\n        require(_receiver != address(0), \"Can't send to 0x00 address\"); \r\n        require(_amount > 0, \"Can't buy with 0 eth\"); \r\n        \r\n        uint tokensToBuy = multiply(_amount, price);\r\n        require(owner.send(_amount), \"Unable to transfer eth to owner\");\r\n        require(tokenContract.transfer(_receiver, tokensToBuy), \"Unable to transfer token to user\"); \r\n        tokensSold += tokensToBuy; \r\n        ethRaised += _amount;\r\n        \r\n        emit Sold(msg.sender, tokensToBuy);\r\n    }\r\n\r\n    \r\n\r\n    function endSale() public {\r\n        require(msg.sender == owner);\r\n\r\n        // Send unsold tokens to the owner.\r\n        require(tokenContract.transfer(owner, tokenContract.balanceOf(address(this))));\r\n\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n}"}}}