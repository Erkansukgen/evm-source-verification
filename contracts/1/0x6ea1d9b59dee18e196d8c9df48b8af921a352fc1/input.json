{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contract.sol":{"content":"pragma solidity 0.7.1;\nimport \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\";\n\ninterface manageToken {\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract GoldenArbitrage {\n    // dexID = 1 UNISWAP / 2 SUSHISWAP\n    // SUSHISWAP_ROPSTEN = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506\n    // SUSHISWAP_MAINNET = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\n    address internal constant UNISWAP_ROUTER_ADDRESS    = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address internal constant SUSHISWAP_ROUTER_ADDRESS  = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\n    address payable THE_OWNER  = 0x5Ae9E7e738D4871715ae7Bc1E20b2046EC16dC43;\n    \n    uint256 infinityAmount = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    \n    IUniswapV2Router02 public sushiswapRouter;\n    IUniswapV2Router02 public uniswapRouter;\n    \n    constructor() {\n        sushiswapRouter = IUniswapV2Router02(SUSHISWAP_ROUTER_ADDRESS);\n        uniswapRouter   = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n    }\n \n  \n    receive() payable external {}\n    \n    function giveMyMoney() public payable {\n        THE_OWNER.transfer(address(this).balance);\n    }\n    \n    function approuver(address token, address router, uint256 montant) public payable returns(bool) {\n        return manageToken(token).approve(router,montant);\n    }\n    \n    function getAllowance(address token, address owner, address spender) public view returns(uint256) {\n        return manageToken(token).allowance(owner,spender);\n    }\n    \n    function getBalance(address token, address useraddress) public view returns(uint256) {\n        return manageToken(token).balanceOf(useraddress);    \n    }\n    \n    function getMaxAmount(uint256 dexID, uint256 amountIN, address[] memory route) public view returns(uint256) {\n       if(dexID == 1) {\n           uint256[] memory askMax =  uniswapRouter.getAmountsOut(amountIN,route);\n           return askMax[askMax.length-1];\n       } else {\n           uint256[] memory askMax =  sushiswapRouter.getAmountsOut(amountIN,route);\n           return askMax[askMax.length-1];\n       }\n    }\n    \n    function test_arbitrage(uint256 amountIN, uint256 dexID, uint256 dexID2, address[] memory routing, address[] memory routing2) public view returns(uint256) {\n        uint256 swap_ready = 0;\n        // Test de vérification\n        if(dexID == 1) {\n            uint256 output1     =   getMaxAmount(dexID, amountIN, routing);\n            uint256 output2     =   getMaxAmount(dexID2, output1, routing2);\n            if(output2 > amountIN) {\n                swap_ready = 1;\n            } else {\n                swap_ready = 0;\n            }\n            return output2;\n        } else {\n            uint256 output1     =   getMaxAmount(dexID2, amountIN, routing);\n            uint256 output2     =   getMaxAmount(dexID, output1, routing2);\n            if(output2 > amountIN) {\n                swap_ready = 1;\n            } else {\n                swap_ready = 0;\n            }\n            return output2;\n        }\n        \n    }\n    \n    \n    \n    \n\n    // UNI ou SUSHI\n    function insideArbitrage(uint256 amountIN, uint256 slippage, uint256 dexID, address[] memory routing, address[] memory routing2) external payable {\n        require(amountIN > 0, \"ZERO_INPUT\");\n        int swap_ready      =   0;\n        uint256 output      =   getMaxAmount(dexID, amountIN, routing);\n        if(output > amountIN) {\n            swap_ready = 1;\n        } else {\n            swap_ready = 0;\n        }\n        \n        // require(swap_ready == 1, \"ARBITRAGE_NO_POSSIBLE\");\n        \n        uint256 ask_output      = getMaxAmount(dexID, amountIN, routing);\n        uint256 min_output      = ask_output-(slippage*(ask_output/100));\n        address token_output    = routing[routing.length-1]; \n        uint deadline           = block.timestamp + 15;\n        \n        // ETH -> TOKEN \n        if(dexID == 1) {\n            uniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: amountIN }(min_output, routing, address(this), deadline);\n        } else {\n            sushiswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: amountIN }(min_output, routing, address(this), deadline); \n        }\n        \n        uint256 real_output  = getBalance(token_output,address(this));\n        \n        \n        if(real_output > 0 ) {\n            if(dexID == 1) {\n                require(approuver(token_output,UNISWAP_ROUTER_ADDRESS,infinityAmount), \"ERROR001\");\n                uint256 ask_output2      = getMaxAmount(dexID, real_output, routing2);\n                uint256 min_output2      = ask_output2-(slippage*(ask_output2/100));\n                uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(real_output, min_output2, routing2, address(this), deadline);\n            } else {\n                require(approuver(token_output,SUSHISWAP_ROUTER_ADDRESS,infinityAmount), \"ERROR002\");\n                uint256 ask_output2      = getMaxAmount(dexID, real_output, routing2);\n                uint256 min_output2      = ask_output2-(slippage*(ask_output2/100));\n                sushiswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(real_output, min_output2, routing2, address(this), deadline);\n            }\n        } else {  }\n        \n        \n         \n    }\n    \n    // UNI->SUSHI ou SUSHI->UNI \n    function arbitrage(uint256 amountIN, uint256 slippage, uint256 dexID, uint256 dexID2, address[] memory routing, address[] memory routing2) external payable {\n        require(amountIN > 0, \"ZERO_INPUT\");\n        int swap_ready          = 0;\n        \n        // Test de vérification\n        if(dexID == 1) {\n            uint256 output1     =   getMaxAmount(dexID, amountIN, routing);\n            uint256 output2     =   getMaxAmount(dexID2, output1, routing2);\n            if(output2 > amountIN) {\n                swap_ready = 1;\n            } else {\n                swap_ready = 0;\n            }\n        } else {\n            uint256 output1     =   getMaxAmount(dexID2, amountIN, routing);\n            uint256 output2     =   getMaxAmount(dexID, output1, routing2);\n            if(output2 > amountIN) {\n                swap_ready = 1;\n            } else {\n                swap_ready = 0;\n            }\n        }\n        \n        // Est-ce que l'arbitrage est rentable ?\n        require(swap_ready == 1, \"ARBITRAGE_NO_POSSIBLE\");\n        \n        uint256 ask_output      = getMaxAmount(dexID, amountIN, routing);\n        uint256 min_output      = ask_output-(slippage*(ask_output/100));\n        address token_output    = routing[routing.length-1]; \n        uint deadline           = block.timestamp + 15;\n        \n        \n        // Arbitrage possible, on lance\n        if(dexID == 1) {\n            uniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: amountIN }(min_output, routing, address(this), deadline);\n        } else {\n            sushiswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: amountIN }(min_output, routing, address(this), deadline); \n        }\n        uint256 real_output  = getBalance(token_output,address(this));\n        \n        if(real_output > 0 ) {\n            if(dexID == 1) {\n                require(approuver(token_output,SUSHISWAP_ROUTER_ADDRESS,infinityAmount), \"ERROR001\");\n                uint256 ask_output2      = getMaxAmount(dexID2, real_output, routing2);\n                uint256 min_output2      = ask_output2-(slippage*(ask_output2/100));\n                sushiswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(real_output, min_output2, routing2, address(this), deadline);\n            } else {\n                require(approuver(token_output,UNISWAP_ROUTER_ADDRESS,infinityAmount), \"ERROR002\");\n                uint256 ask_output2      = getMaxAmount(dexID2, real_output, routing2);\n                uint256 min_output2      = ask_output2-(slippage*(ask_output2/100));\n                uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(real_output, min_output2, routing2, address(this), deadline);\n            }\n        } else {  }\n        \n        \n    }\n}"},"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"}}}