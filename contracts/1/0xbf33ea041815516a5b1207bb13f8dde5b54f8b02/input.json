{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Leaderboard.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\ncontract Leaderboard {\n    \n    mapping(address => mapping (bytes32 => Repartition)) public registery;\n    \n    struct Repartition {\n        uint256 unallocated;\n        mapping (bytes32 => uint256) allocated;\n    }\n    \n    event newAllocation(\n        address _at,\n        bytes32 _leaderHash,\n        bytes32 _fromEntryHash,\n        bytes32 _toEntryHash,\n        uint256 _value\n    );\n    \n    event newLeaderboard(address _from, bytes32 leaderHash, uint256 intialValue);\n    event deletedLeaderboard(address _from, bytes32 leaderHash);\n    \n    // Creation\n    \n    function createLeaderboard(bytes32 _leaderHash, uint256 _intialValue) public {\n        registery[msg.sender][_leaderHash].unallocated = _intialValue;\n        emit newLeaderboard(msg.sender, _leaderHash, _intialValue);\n    }\n    \n    // Allocation\n    \n    function allocateEntryFromUnallocated(\n        bytes32 _leaderHash,\n        bytes32 _toEntryHash,\n        uint256 _value\n    ) public {\n        // Checking repartion\n        require(_value <= registery[msg.sender][_leaderHash].unallocated, \"not enought\");\n        // Changing repartition\n        registery[msg.sender][_leaderHash].unallocated -= _value;\n        registery[msg.sender][_leaderHash].allocated[_toEntryHash] += _value;\n        emit newAllocation(msg.sender, _leaderHash, \"\", _toEntryHash, _value);\n    }\n    \n    function allocateEntryFromEntry(\n        bytes32 _leaderHash,\n        bytes32 _fromEntryHash,\n        bytes32 _toEntryHash,\n        uint256 _value\n    ) public {\n        // Checking repartion\n        require(_value <= registery[msg.sender][_leaderHash].allocated[_fromEntryHash], \"not enought\");\n        // Changing repartition\n        registery[msg.sender][_leaderHash].allocated[_fromEntryHash] -= _value;\n        registery[msg.sender][_leaderHash].allocated[_toEntryHash] += _value;\n        emit newAllocation(msg.sender, _leaderHash, _fromEntryHash, _toEntryHash, _value);\n    }\n    \n    function deallocateEntry(\n        bytes32 _leaderHash,\n        bytes32 _fromEntryHash,\n        uint256 _value\n    ) public {\n        // Checking repartion\n        require(_value <= registery[msg.sender][_leaderHash].allocated[_fromEntryHash], \"not enought\");\n        // Changing repartition\n        registery[msg.sender][_leaderHash].allocated[_fromEntryHash] -= _value;\n        registery[msg.sender][_leaderHash].unallocated += _value;\n        emit newAllocation(msg.sender, _leaderHash, _fromEntryHash, \"\", _value);\n    }\n    \n    // Getters\n    \n    function getUnallocation(address _from, bytes32 leaderHash) public view returns (uint256 _unallocatedAmount){\n        return registery[_from][leaderHash].unallocated;\n    }\n    \n    function getAllocation(address _from, bytes32 leaderHash, bytes32 _entryHash) public view returns (uint256 _allocatedAmount) {\n        return registery[_from][leaderHash].allocated[_entryHash];\n    }\n}\n"}}}