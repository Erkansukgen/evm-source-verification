{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/contracts/Bill/Bill.sol":{"content":"/**\n * SPDX-License-Identifier: LGPL\n *\n * Copyright (c) Invest & Pay International(Singapore) Pte. Ltd., 2020-2022\n *\n */\npragma solidity ^0.6.0;\n\nimport \"../Common/MultiOwnable.sol\";\nimport \"../Common/Owners.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../ERC1155/ERC1155Receiver.sol\";\n\n/// @title Bill\n/// @author Juu17\ncontract Bill is MultiOwnable, ERC1155Receiver {\n    using SafeMath for uint256;\n\n    uint256 public immutable id;\n    uint256 public immutable billAmount;\n    uint256 public issuedAmount;\n    string public drawer;\n    string public draweeBankName;\n    bytes8 public immutable draweeDate;\n    string public accepter;\n    string public accepterBankName;\n    bytes8 public immutable expireDate;\n\n    uint256 public initialIssueTime;\n\n    address public immutable managerAddress;\n\n    constructor(\n        Owners owners,\n        uint256 _id,\n        uint256 _billAmount,\n        string memory _drawer,\n        string memory _draweeBankName,\n        string memory _accepter,\n        string memory _accepterBankName,\n        bytes8 _draweeDate,\n        bytes8 _expireDate\n    ) public MultiOwnable(owners) {\n        id = _id;\n        billAmount = _billAmount;\n        // issuedAmount is set to 0\n        issuedAmount = 0;\n        drawer = _drawer;\n        draweeBankName = _draweeBankName;\n        accepter = _accepter;\n        accepterBankName = _accepterBankName;\n        draweeDate = _draweeDate;\n        expireDate = _expireDate;\n\n        managerAddress = msg.sender;\n    }\n\n    /// @notice Only allowed to the BillManager who created me\n    function addIssueAmount(uint256 _amount) external returns (bool isInitialIssue) {\n        require(msg.sender == managerAddress, \"[CNHC] Manager required\");\n\n        uint256 newIssueAmount = issuedAmount.add(_amount);\n        require(newIssueAmount <= billAmount, \"[CNHC] Bill amount overflow warning\");\n\n        if (issuedAmount == 0) {\n            initialIssueTime = now;\n            isInitialIssue = true;\n        }\n        issuedAmount = newIssueAmount;\n    }\n\n    /// @notice Exposed for callers to judge the status of the bill\n    function isClaimed() external view returns (bool) {\n        return initialIssueTime != 0;\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) external virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) external virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"},"localhost/contracts/Bill/BillCommon.sol":{"content":"/**\n * SPDX-License-Identifier: LGPL\n *\n * Copyright (c) Invest & Pay International(Singapore) Pte. Ltd., 2020-2022\n *\n */\npragma solidity ^0.6.0;\n\nlibrary BillCommon {\n    enum BillState {Invalid, Normal, Discarded}\n\n    bytes constant ISSUE = \"I\";\n    bytes constant ISSUE_INTEREST = \"I|I\";\n    bytes constant DISPATCH = \"D\";\n    bytes constant REDEEM_DESTROY = \"R|D\";\n    bytes constant REDEEM_DISPATCH = \"R|DI\";\n}\n"},"localhost/contracts/BillManager.sol":{"content":"/**\n * SPDX-License-Identifier: LGPL\n *\n * Copyright (c) Invest & Pay International(Singapore) Pte. Ltd., 2020-2022\n *\n */\npragma solidity ^0.6.0;\n\nimport {MultiOwnable} from \"./Common/MultiOwnable.sol\";\nimport \"./Common/Owners.sol\";\nimport \"./Bill/BillCommon.sol\";\nimport \"./Bill/Bill.sol\";\n\n/// @title BillManager\n/// @author Juu17\ncontract BillManager is MultiOwnable {\n    mapping(uint256 => Bill) public bills;\n    mapping(uint256 => BillCommon.BillState) public billStates;\n\n    constructor(Owners _owners) public MultiOwnable(_owners) {}\n\n    event CreateBill(uint256 indexed id, Bill indexed bill);\n    event DiscardBill(uint256 indexed id);\n    event DiscardBills(uint256[] indexed ids);\n\n    modifier onlyExistedId(uint256 _id) {\n        require(address(bills[_id]) != address(0), \"[BM] Bill id not found\");\n        _;\n    }\n    modifier onlyExistedIds(uint256[] memory _ids) {\n        for (uint256 i = 0; i < _ids.length; ++i) {\n            require(address(bills[_ids[i]]) != address(0), \"[BM] Some bill ids not found\");\n        }\n        _;\n    }\n\n    /// @notice Create a new Bill contract object and deploy\n    function createBill(\n        uint256 _id,\n        uint256 _billAmount,\n        string memory _drawer,\n        string memory _draweeBankName,\n        string memory _accepter,\n        string memory _accepterBankName,\n        bytes8 _draweeDate,\n        bytes8 _expireDate\n    ) external onlyOwners returns (Bill) {\n        require(address(bills[_id]) == address(0), \"[BM] Bill id already exist\");\n\n        Bill bill = new Bill(ownersContract, _id, _billAmount, _drawer, _draweeBankName, _accepter, _accepterBankName, _draweeDate, _expireDate);\n        bills[_id] = bill;\n        billStates[_id] = BillCommon.BillState.Normal;\n        emit CreateBill(_id, bill);\n\n        return bill;\n    }\n\n    function tryAddBillIssueAmount(uint256 _id, uint256 _amount) external onlyOwners returns (bool isInitialIssue, address billAddr) {\n        Bill bill = bills[_id];\n        require(address(bill) != address(0), \"[BM] Bill id not found\");\n        isInitialIssue = bill.addIssueAmount(_amount);\n        billAddr = address(bill);\n    }\n\n    /// @notice Discard a single Bill contract, set the status to Discarded\n    function discardBill(uint256 _id) external onlyOwners onlyExistedId(_id) {\n        billStates[_id] = BillCommon.BillState.Discarded;\n        emit DiscardBill(_id);\n    }\n\n    /// @notice Discard a bunch of Bill contracts, set the statuses to Discarded\n    function discardBills(uint256[] calldata _ids) external onlyOwners onlyExistedIds(_ids) {\n        for (uint256 i = 0; i < _ids.length; ++i) {\n            billStates[_ids[i]] = BillCommon.BillState.Discarded;\n        }\n        emit DiscardBills(_ids);\n    }\n\n    function uploadBills(\n        uint256[] calldata _ids,\n        Bill[] calldata _bills,\n        BillCommon.BillState[] calldata _states\n    ) external onlyOwners {\n        require(_ids.length == _bills.length, \"[BM] Parameters (_ids) and (_bills) must be the same length\");\n        require(_bills.length == _states.length, \"[BM] Parameters (_bills) and (_states) must be the same length\");\n\n        for (uint256 i = 0; i < _ids.length; ++i) {\n            uint256 id = _ids[i];\n            bills[id] = _bills[i];\n            billStates[id] = _states[i];\n        }\n    }\n\n    /// @notice Inspect the statues of specified bills\n    function verifyIds(uint256[] calldata _ids, BillCommon.BillState expectedState) external view returns (bool) {\n        require(_ids.length < 30, \"[BM] Parameter (_ids) size too large\");\n        for (uint256 i = 0; i < _ids.length; ++i) {\n            if (billStates[_ids[i]] != expectedState) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"},"localhost/contracts/Common/MultiOwnable.sol":{"content":"/**\n * SPDX-License-Identifier: MIT\n *\n * Copyright (c) 2018 zOS Global Limited.\n * Copyright (c) CENTRE SECZ 2018-2020\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npragma solidity ^0.6.0;\n\nimport \"./Owners.sol\";\n\n/**\n * @notice The Ownable contract has an owner address, and provides basic\n * authorization control functions\n * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-labs/blob/3887ab77b8adafba4a26ace002f3a684c1a3388b/upgradeability_ownership/contracts/ownership/Ownable.sol\n * Modifications:\n * 1. Consolidate OwnableStorage into this contract (7/13/18)\n * 2. Reformat, conform to Solidity 0.6 syntax, and add error messages (5/13/20)\n * 3. Make public functions external (5/27/20)\n */\ncontract MultiOwnable {\n    Owners public ownersContract;\n\n    /**\n     * @dev The constructor sets the original owner of the contract to the sender account.\n     */\n    constructor(Owners _owners) public {\n        ownersContract = _owners;\n    }\n\n    // Deprecated\n    // function setOwnersContract(Owners _owners) external onlyOwners {\n    //     ownersContract = _owners;\n    // }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    // modifier onlyMainOwner() {\n    //     require(\n    //         tx.origin == ownersContract.mainOwner(),\n    //         \"MultiOwnable: caller is not the main owner\");\n    //     _;\n    // }\n\n    /**\n     * @dev Throws if called by any account other than the main owner or other owners.\n     */\n    modifier onlyOwners() {\n        require(tx.origin == ownersContract.mainOwner() || ownersContract.isOwner(tx.origin), \"MultiOwnable: caller is not the owner members\");\n        _;\n    }\n\n    //    modifier onlyOwnersIncludeOrigin() {\n    //        if (tx.origin == msg.sender) {\n    //            require(\n    //                msg.sender == _mainOwner || msg.sender == _contractOwner || owners[msg.sender],\n    //                \"MultiOwnable: caller is not the owner members\"\n    //            );\n    //        } else {\n    //            require(\n    //                tx.origin == _mainOwner || msg.sender == _mainOwner\n    //                || tx.origin == _contractOwner || msg.sender == _contractOwner\n    //                || owners[tx.origin] || owners[msg.sender],\n    //                \"MultiOwnable: caller is not the owner members\"\n    //            );\n    //        }\n    //        _;\n    //    }\n}\n"},"localhost/contracts/Common/Owners.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract Owners {\n    // Owner of the contract\n    address private _mainOwner;\n    mapping(address => bool) private _owners;\n    /**\n     * @dev Event to show ownership has been transferred\n     * @param previousOwner representing the address of the previous owner\n     * @param newOwner representing the address of the new owner\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    event AddNewOwner(address indexed newOwner);\n\n    event RemoveOwner(address indexed owner);\n\n    modifier onlyMainOwner() {\n        require(msg.sender == _mainOwner, \"[OWN] Caller is not the main owner\");\n        _;\n    }\n\n    constructor() public {\n        setMainOwner(msg.sender);\n    }\n\n    /**\n     * @dev Tells the address of the owner\n     * @return the address of the owner\n     */\n    function mainOwner() external view returns (address) {\n        return _mainOwner;\n    }\n\n    function isOwner(address who) external view returns (bool) {\n        return who == _mainOwner || _owners[who];\n    }\n\n    /**\n     * @dev Sets a new owner address\n     */\n    function setMainOwner(address newOwner) private {\n        _mainOwner = newOwner;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferMainOwnership(address newOwner) external onlyMainOwner {\n        require(newOwner != address(0), \"[OWN] New owner is the zero address\");\n        emit OwnershipTransferred(_mainOwner, newOwner);\n        setMainOwner(newOwner);\n    }\n\n    function addOwner(address owner) external onlyMainOwner {\n        require(owner != address(0), \"[OWN] New owner is the zero address\");\n        _owners[owner] = true;\n\n        emit AddNewOwner(owner);\n    }\n\n    function removeOwner(address owner) external onlyMainOwner {\n        require(owner != address(0), \"[OWN] New owner is the zero address\");\n        require(_owners[owner], \"[OWN] Owner is not existed\");\n\n        delete _owners[owner];\n\n        emit RemoveOwner(owner);\n    }\n}\n"},"localhost/contracts/Common/Pausable.sol":{"content":"/**\n * SPDX-License-Identifier: MIT\n *\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\n * Copyright (c) CENTRE SECZ 2018-20200\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npragma solidity ^0.6.0;\n\nimport {MultiOwnable} from \"./MultiOwnable.sol\";\nimport {Owners} from \"./Owners.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is MultiOwnable {\n    /**\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\n     */\n    event Paused(address indexed account, string text);\n\n    /**\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\n     */\n    event Unpaused(address indexed account);\n\n    event PauserChanged(address indexed newAddress);\n\n    address public pauser;\n    bool private _paused;\n    string private _pauseText;\n\n    /**\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n     * to the deployer.\n     */\n    constructor(Owners owner) public MultiOwnable(owner) {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() external view returns (bool) {\n        return _paused;\n    }\n\n    function pauseText() external view returns (string memory) {\n        return _pauseText;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"[CNHC] System paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"[CNHC] System not paused\");\n        _;\n    }\n\n    /**\n     * @dev throws if called by any account other than the pauser\n     */\n    modifier onlyPauser() {\n        require(msg.sender == pauser, \"[CNHC] Caller is not the pauser\");\n        _;\n    }\n\n    /**\n     * @dev Called by a pauser to pause, triggers stopped state.\n     */\n    function pause(string memory text) public onlyPauser whenNotPaused {\n        _paused = true;\n        _pauseText = text;\n        emit Paused(msg.sender, _pauseText);\n    }\n\n    /**\n     * @dev Called by a pauser to unpause, returns to normal state.\n     */\n    function unpause() public onlyPauser whenPaused {\n        _paused = false;\n        _pauseText = \"\";\n        emit Unpaused(msg.sender);\n    }\n\n    /**\n     * @dev update the pauser role\n     */\n    function updatePauser(address _newPauser) external onlyOwners {\n        require(_newPauser != address(0), \"[CNHC] New pauser is the zero address\");\n        pauser = _newPauser;\n        emit PauserChanged(pauser);\n    }\n}\n"},"localhost/contracts/ERC1155/ERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155MetadataURI.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"../GSN/Context.sol\";\nimport \"../introspection/ERC165.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) internal _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substition, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri) public {\n        _setURI(uri);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substituion mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) public view override returns (uint256[] memory) {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(from == _msgSender() || isApprovedForAll(from, _msgSender()), \"ERC1155: caller is not owner nor approved\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(from == _msgSender() || isApprovedForAll(from, _msgSender()), \"ERC1155: transfer caller is not owner nor approved\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substituion mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        // emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        // emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(amount, \"ERC1155: burn amount exceeds balance\");\n\n        // emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(amounts[i], \"ERC1155: burn amount exceeds balance\");\n        }\n\n        // emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) internal pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"},"localhost/contracts/ERC1155/ERC1155Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC1155Receiver.sol\";\nimport \"../introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    constructor() public {\n        _registerInterface(ERC1155Receiver(0).onERC1155Received.selector ^ ERC1155Receiver(0).onERC1155BatchReceived.selector);\n    }\n}\n"},"localhost/contracts/ERC1155/IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transfered from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"},"localhost/contracts/ERC1155/IERC1155MetadataURI.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"},"localhost/contracts/ERC1155/IERC1155Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../introspection/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"localhost/contracts/GSN/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"localhost/contracts/IPIToken.sol":{"content":"/**\n * SPDX-License-Identifier: LGPL\n *\n * Copyright (c) Invest & Pay International(Singapore) Pte. Ltd., 2020-2022\n *\n */\npragma solidity ^0.6.0;\n\nimport \"./ERC1155/ERC1155.sol\";\nimport \"./Bill/BillCommon.sol\";\nimport \"./Common/MultiOwnable.sol\";\nimport \"./math/SafeMath.sol\";\nimport \"./Common/Pausable.sol\";\nimport \"./BillManager.sol\";\n\n/// @title IPIToken\n/// @author Juu17\ncontract IPIToken is ERC1155, MultiOwnable, Pausable {\n    using SafeMath for uint256;\n\n    event Issue(uint256 indexed id, uint256 indexed amount);\n    event IssueInterest(uint256 indexed id, uint256 indexed amount);\n    event Dispatch(uint256 indexed id, address[] indexed addrs, uint256[] amounts);\n    event Redeem(address indexed _to, uint256[] indexed oldIds, uint256[] newIds, uint256[] amounts);\n    event Deprecate(address newAddress);\n\n    string public constant name = \"IPI CNH\";\n    string public constant symbol = \"CNHC\";\n    uint8 public constant decimals = 2;\n    address public upgradedAddress;\n    bool public deprecated;\n\n    BillManager private billManager;\n\n    constructor(BillManager manager, string memory uri) public ERC1155(uri) Pausable(manager.ownersContract()) {\n        billManager = manager;\n    }\n\n    function setBillManager(BillManager _billManager) external onlyOwners {\n        billManager = _billManager;\n    }\n\n    /// Override Section Begin\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override whenNotPaused checkNormalIds(ids) {\n        // TODO if use _burn(), should check if \"to\" is address(0), then jump check\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    /// Override Section End\n\n    /// @notice Issue tokens within specified Bill id\n    function issue(uint256 _id, uint256 amount) external onlyOwners checkNormalIds(_asSingletonArray(_id)) {\n        bool isInitialIssue;\n        address billAddr;\n        (isInitialIssue, billAddr) = billManager.tryAddBillIssueAmount(_id, amount);\n\n        if (isInitialIssue) {\n            _mint(billAddr, _id, amount, BillCommon.ISSUE);\n            emit Issue(_id, amount);\n        } else {\n            _mint(billAddr, _id, amount, BillCommon.ISSUE_INTEREST);\n            emit IssueInterest(_id, amount);\n        }\n    }\n\n    /// @notice Dispatch tokens from one Bill contract to some accounts\n    function dispatch(\n        uint256 _id,\n        address[] calldata accounts,\n        uint256[] calldata amounts\n    ) external onlyOwners checkNormalIds(_asSingletonArray(_id)) {\n        require(accounts.length == amounts.length, \"[CNHC] Parameters (accounts) and (amounts) must be the same length\");\n        address billAddr = address(billManager.bills(_id));\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            __transfer(_id, billAddr, accounts[i], amounts[i], BillCommon.DISPATCH);\n        }\n        emit Dispatch(_id, accounts, amounts);\n    }\n\n    /// @notice Redeem the tokens binded to expired Bills, Recall the old tokens and dispatch new tokens\n    function redeem(\n        address account,\n        uint256[] calldata oldIds,\n        uint256[] calldata newIds,\n        uint256[] calldata newAmounts\n    ) external onlyOwners checkNormalIds(newIds) {\n        // Phrase 1\n        uint256 totalOldBalance;\n        uint256[] memory oldBalanceArray;\n        (totalOldBalance, oldBalanceArray) = _gatherForRedeem(account, oldIds);\n        uint256 totalNewAmount = reduce(newAmounts, addFunc);\n        require(totalOldBalance == totalNewAmount, \"[CNHC] Redeem amount must match\");\n        // Phrase 2\n        for (uint256 i = 0; i < oldIds.length; ++i) {\n            delete _balances[oldIds[i]][account];\n        }\n        // destroy callback\n        address operator = _msgSender();\n        _doSafeBatchTransferAcceptanceCheck(operator, account, address(0), oldIds, oldBalanceArray, BillCommon.REDEEM_DESTROY);\n        // Phrase 3\n        _dispatchForRedeem(account, newIds, newAmounts);\n        emit Redeem(account, oldIds, newIds, newAmounts);\n    }\n\n    /// @notice Private function for redeem\n    function _gatherForRedeem(address account, uint256[] calldata oldIds) private view returns (uint256 totalOldBalance, uint256[] memory oldBalanceArray) {\n        oldBalanceArray = new uint256[](oldIds.length);\n        for (uint256 i = 0; i < oldIds.length; ++i) {\n            uint256 oldVal = _balances[oldIds[i]][account];\n            oldBalanceArray[i] = oldVal;\n            totalOldBalance = totalOldBalance.add(oldVal);\n        }\n    }\n\n    /// @notice Private function for redeem\n    function _dispatchForRedeem(\n        address account,\n        uint256[] memory newIds,\n        uint256[] memory newAmounts\n    ) private {\n        for (uint256 i = 0; i < newIds.length; ++i) {\n            address billAddr = address(billManager.bills(newIds[i]));\n            uint256 amount = newAmounts[i];\n            __transfer(newIds[i], billAddr, account, amount, BillCommon.REDEEM_DISPATCH);\n        }\n    }\n\n    /// @dev Private transfer for single address to single address\n    function __transfer(\n        uint256 id,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        // SafeMath will throw with insuficient funds _from or if _id is not valid (balance will be 0)\n        _balances[id][from] = _balances[id][from].sub(amount, \"[CNHC] Insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        address operator = _msgSender();\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /// @notice Deprecate current contract in favour of a new one\n    function deprecate(address _upgradedAddress) external onlyOwners {\n        deprecated = true;\n        upgradedAddress = _upgradedAddress;\n        emit Deprecate(_upgradedAddress);\n    }\n\n    modifier checkNormalIds(uint256[] memory _ids) {\n        require(billManager.verifyIds(_ids, BillCommon.BillState.Normal), \"[CNHC] Invalid bill id found\");\n        _;\n    }\n\n    function addFunc(uint256 a, uint256 b) private pure returns (uint256) {\n        return a.add(b);\n    }\n\n    function reduce(uint256[] memory a, function(uint256, uint256) pure returns (uint256) f) internal pure returns (uint256) {\n        uint256 r = a[0];\n        for (uint256 i = 1; i < a.length; i++) {\n            r = f(r, a[i]);\n        }\n        return r;\n    }\n}\n"},"localhost/contracts/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor() internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"},"localhost/contracts/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"localhost/contracts/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"localhost/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"}}}