{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/jiesuan.sol": {
      "content": "pragma solidity >=0.4.22 <0.7.0;\r\ncontract BamData {\r\n   struct MiningMachine {\r\n        string name;\r\n        uint price;\r\n        uint backMount;\r\n        uint id;\r\n   }\r\n   struct Record{\r\n     string typeString;\r\n     uint price;\r\n     uint startTime;\r\n     uint canWithdrawal;\r\n     uint haveWithdrawal;\r\n   }\r\n   struct Buyer {\r\n     address buyerAddress;\r\n     mapping(uint => Record) Records;\r\n   }\r\n   address public owner;\r\n   address logicContract;\r\n   mapping(string => MiningMachine) public MiningMachines;\r\n   mapping(address => uint) public dynamicGains;\r\n   mapping(address => Buyer) public Buyers;\r\n   constructor () payable public {\r\n     owner = msg.sender;\r\n     MiningMachines['Mini'] = MiningMachine('迷你矿机',1 ether, 0.00547945 ether,1);\r\n     MiningMachines['Small'] = MiningMachine('小型矿机',10 ether, 0.08219178 ether,2);\r\n     MiningMachines['Medium'] = MiningMachine('中型矿机',50 ether, 0.47945205 ether,3);\r\n     MiningMachines['Large'] = MiningMachine('大型矿机',100 ether, 1.09589041 ether,4);\r\n   }\r\n   modifier isOwner() {\r\n      require(msg.sender == owner, \"Caller is not owner\");\r\n      _;\r\n    }\r\n    modifier isLogicOwner() {\r\n      require(msg.sender == logicContract, \"Caller is not logicContract\");\r\n      _;\r\n    }\r\n   function setOwner (address otherOwner) public isOwner{\r\n     require(otherOwner != address(0), \"Ownable: new owner is the zero address\");\r\n     owner = otherOwner;\r\n   }\r\n   function setLogicOwner (address logicAddress) public isOwner{\r\n     require(logicAddress != address(0), \"Ownable: new owner is the zero address\");\r\n     logicContract = logicAddress;\r\n   }\r\n   function getBalance () public view returns (uint balanceNum) {\r\n      return address(this).balance;\r\n   }\r\n   function getMiningMachine (string memory typeString) public view returns(string memory name, uint price, uint backMount, string memory miningType, uint id) {\r\n      require(bytes(MiningMachines[typeString].name).length > 0, 'No such miner type');\r\n      return (MiningMachines[typeString].name, MiningMachines[typeString].price,MiningMachines[typeString].backMount, typeString, MiningMachines[typeString].id);\r\n   }\r\n   function getMiningName (string memory typeString) public view returns(string memory name) {\r\n      return MiningMachines[typeString].name;\r\n   }\r\n   function getMiningPrice (string memory typeString) public view returns(uint price) {\r\n      return MiningMachines[typeString].price;\r\n   }\r\n   function getMiningBackMount (string memory typeString) public view returns(uint amount) {\r\n      return MiningMachines[typeString].backMount;\r\n   }\r\n   function isHaveBuyer (address buyerAddress) public view returns(bool havBuyer) {\r\n      return Buyers[buyerAddress].buyerAddress != address(0x0);\r\n   }\r\n   function setBuyer (address buyerAddress, string memory typeString, uint time, uint signId) public isLogicOwner{\r\n     Buyers[buyerAddress].buyerAddress = buyerAddress;\r\n     Buyers[buyerAddress].Records[signId].typeString = typeString;\r\n     Buyers[buyerAddress].Records[signId].startTime = time;\r\n     Buyers[buyerAddress].Records[signId].price = MiningMachines[typeString].price;\r\n     Buyers[buyerAddress].Records[signId].haveWithdrawal = 0;\r\n   }\r\n   function setBuyerWithdrawal (address buyerAddress, uint amount, uint signId) public isLogicOwner {\r\n     Buyers[buyerAddress].Records[signId].haveWithdrawal = amount;\r\n   }\r\n   function getBuyerRecord (address buyerAddress, uint signId) public view returns (address buyAdress, string memory recordType, uint endTime, uint price, uint haveWithdrawal) {\r\n      return (buyerAddress,Buyers[buyerAddress].Records[signId].typeString,Buyers[buyerAddress].Records[signId].startTime, Buyers[buyerAddress].Records[signId].price,Buyers[buyerAddress].Records[signId].haveWithdrawal);\r\n   }\r\n   function setRecordHaveWithdrawal (address buyerAddress, uint signId, uint amount) public isLogicOwner {\r\n     require(Buyers[buyerAddress].Records[signId].haveWithdrawal + amount > Buyers[buyerAddress].Records[signId].haveWithdrawal);\r\n     Buyers[buyerAddress].Records[signId].haveWithdrawal += amount;\r\n   }\r\n   function Obtain (uint signId, string memory typeString, address payable toAddress, uint amount) public isLogicOwner {\r\n       (,string memory haveTypeString, uint startTime,,uint haveWithdrawal) = getBuyerRecord(toAddress, signId);\r\n       require(keccak256(abi.encodePacked(typeString)) == keccak256(abi.encodePacked(haveTypeString)), 'Wrong miner type');\r\n      uint havePasstime =(now - startTime)/86400;\r\n      uint backmount;\r\n        if(havePasstime<=365) {\r\n        backmount = getMiningBackMount(typeString) * havePasstime;\r\n      } else {\r\n        backmount = getMiningBackMount(typeString) * 365;  \r\n      }\r\n      require(backmount > haveWithdrawal,'This miner has been received');\r\n      require(backmount -  haveWithdrawal >= amount, 'This miner has been get');\r\n      toAddress.transfer(backmount -  haveWithdrawal);\r\n   }\r\n    function ObtainTotal (uint amount) public isOwner {\r\n      require(address(this).balance>=amount,'Sorry, your credit is running low');\r\n      msg.sender.transfer(amount);\r\n    }\r\n    function SetDynamicGains (address toAddress, uint amount) public isLogicOwner {\r\n      dynamicGains[toAddress] = amount;\r\n    }\r\n    function getDynamicGain (address toAddress) public view returns(uint amount) {\r\n      return dynamicGains[toAddress];\r\n    }\r\n    function obtainDynamicGains (address payable toAddress, uint amount) public isLogicOwner {\r\n      require(dynamicGains[toAddress] >= amount, 'There is no dynamic income at present');\r\n      require(address(this).balance >= amount, 'Not enough eth');\r\n      toAddress.transfer(amount);\r\n    }\r\n   event Received(address, uint);\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n}\r\ncontract BamLogic{\r\n  address public owner;\r\n  BamData bamData;\r\n  address payable importAddress;\r\n  event BuyMachine(address buyAddress, string machineType, uint ethNumber, uint signId, uint id);\r\n  event ObtainEvent(address buyAddress, uint amount, uint signId);\r\n  event DynamicGainsEvent(address buyAddress, uint amount, string dynamType);\r\n  event SetDynamicGainsEvent(address toAddress, uint amount);\r\n  constructor (address payable bamDataAddress, address payable dataAddress) public payable {\r\n    owner = msg.sender;\r\n    bamData = BamData(bamDataAddress);\r\n    importAddress = dataAddress;\r\n  }\r\n   modifier isOwner() {\r\n      require(msg.sender == owner, \"Caller is not owner\");\r\n      _;\r\n    }\r\n    function setImportantAddress (address payable nextAddress) public isOwner {\r\n      require(nextAddress != address(0), \"Ownable: new owner is the zero address\");\r\n      importAddress = nextAddress;\r\n    }\r\n    modifier haveTypeMachine (string memory typeString) {\r\n     require(bytes(bamData.getMiningName(typeString)).length > 0, 'No such miner type');\r\n      _;\r\n    }\r\n    modifier isHaveBuyer (address buyer) {\r\n      require(bamData.isHaveBuyer(buyer) == true,'You don not have a miner yet');\r\n      _;\r\n    }\r\n    function setOwner (address otherOwner) public isOwner{\r\n     require(otherOwner != address(0), \"Ownable: new owner is the zero address\");\r\n     owner = otherOwner;\r\n   }\r\n   function getMiningMachine (string memory typeString) public view returns(string memory name, uint price, uint backMount, string memory miningType, uint id) {\r\n      return bamData.getMiningMachine(typeString);\r\n   }\r\n   function getBalance () public view returns (uint balanceNum) {\r\n      return address(this).balance;\r\n   }\r\n  function buy(string memory typeString, uint timeStamp) public haveTypeMachine(typeString) payable {\r\n     require(msg.value == bamData.getMiningPrice(typeString), 'Not enough eth');\r\n     importAddress.transfer(msg.value);\r\n     uint time = now; \r\n     bamData.setBuyer(msg.sender, typeString, time, getSign(timeStamp));\r\n     (,,,,uint id) = bamData.getMiningMachine(typeString);\r\n     emit BuyMachine(msg.sender, typeString, msg.value, getSign(timeStamp), id);\r\n  }\r\n   function getRecordInfo (address buyerAddress, uint signId) public isHaveBuyer(buyerAddress) view returns(address buyAdress, string memory recordType, uint passTime, uint price, uint haveWithdrawal){\r\n      return bamData.getBuyerRecord(buyerAddress,signId);\r\n   }\r\n   function getCanWithdrawal (uint signId, string memory typeString) public isHaveBuyer(msg.sender) view returns(uint withdrawalAmount, uint passtime) {\r\n    (,, uint startTime,,uint haveWithdrawal) = bamData.getBuyerRecord(msg.sender, signId);\r\n      uint havePasstime = (now - startTime)/86400;\r\n      uint backmount;\r\n      if(havePasstime<=365) {\r\n        backmount = bamData.getMiningBackMount(typeString) * havePasstime;\r\n      } else {\r\n        backmount = bamData.getMiningBackMount(typeString) * 365;  \r\n      }\r\n     return ((backmount -  haveWithdrawal), havePasstime);\r\n      \r\n   }\r\n  function Obtain (uint signId, string memory typeString) public isHaveBuyer(msg.sender) {\r\n    (,string memory haveTypeString, uint startTime,,uint haveWithdrawal) = bamData.getBuyerRecord(msg.sender, signId);\r\n       require(keccak256(abi.encodePacked(typeString)) == keccak256(abi.encodePacked(haveTypeString)), 'Wrong miner type');\r\n      uint havePasstime =(now - startTime)/86400;\r\n      uint backmount;\r\n        if(havePasstime<=365) {\r\n        backmount = bamData.getMiningBackMount(typeString) * havePasstime;\r\n      } else {\r\n        backmount = bamData.getMiningBackMount(typeString) * 365;  \r\n      }\r\n      require(backmount > haveWithdrawal,'This miner has been received');\r\n      bamData.Obtain(signId, typeString, msg.sender, backmount - haveWithdrawal);\r\n      bamData.setRecordHaveWithdrawal(msg.sender, signId, backmount -  haveWithdrawal);\r\n      emit ObtainEvent(msg.sender,backmount -  haveWithdrawal, signId);\r\n     }\r\n  function SetDynamicGains (address toAddress,uint amount) public isOwner {\r\n      bamData.SetDynamicGains(toAddress, bamData.getDynamicGain(toAddress) + amount);\r\n      emit SetDynamicGainsEvent(toAddress, amount);\r\n  }\r\n  function getDynamicGain () public view returns (uint amount) {\r\n     return bamData.getDynamicGain(msg.sender);\r\n  }\r\n  function obtainDynamicGains (uint amount) public {\r\n    bamData.obtainDynamicGains(msg.sender, amount);\r\n    bamData.SetDynamicGains(msg.sender, bamData.getDynamicGain(msg.sender) - amount);\r\n    emit DynamicGainsEvent(msg.sender, amount, 'obtainDynamicGains');\r\n  }\r\n  function getSign (uint time) public view returns (uint256 signNum) {\r\n    uint256 sign = uint256(keccak256(abi.encodePacked(\r\n                    (block.timestamp),\r\n                    (block.difficulty),\r\n                    ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (time)),\r\n                    (block.gaslimit),\r\n                    ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (time)),\r\n                    (block.number)\r\n                ))) % 100000;\r\n    return sign;\r\n  }\r\n  function setBuyer (address buyerAddress, string memory typeString, uint time, uint signId) public isOwner {\r\n    bamData.setBuyer(buyerAddress, typeString, time, signId);\r\n  }\r\n  function setBuyerWithdrawal (address buyerAddress, uint amount, uint signId) public isOwner {\r\n    bamData.setBuyerWithdrawal(buyerAddress, amount, signId);\r\n  }\r\n}"
    }
  }
}