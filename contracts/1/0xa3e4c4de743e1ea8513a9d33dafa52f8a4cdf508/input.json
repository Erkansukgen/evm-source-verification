{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Pancake_Fee.sol": {
      "content": "pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Context {\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        //(bool success, ) = recipient.call{value:amount}(\"\"); // todo : for 0.6.0. need to check\r\n\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function decimals() external view returns(uint digits);\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\ncontract Uniswap_Fee_V2 is Ownable, ReentrancyGuard{\r\n    using SafeERC20 for IERC20;\r\n\tusing SafeMath for uint256;\r\n\r\n    // Main Network\r\n    address public factory  = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);  \r\n    address public rout     = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n    uint256 public percentage_unit = 1000;\r\n    uint256 public upfront_commission = 0; \r\n    uint256 public trail_commission = 0; \r\n    uint256 public pool_fee = 3; // 0.3%\r\n    uint256 public eth_thr = 5;\r\n\r\n    // Main Network\r\n    address[] public stable_list = [\r\n        address(0x6B175474E89094C44Da98b954EedeAC495271d0F),\r\n        address(0xdAC17F958D2ee523a2206206994597C13D831ec7),\r\n        address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48),\r\n        address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599)\r\n    ];\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    constructor() public{\r\n    }\r\n\r\n    function SetConfig(\r\n        address _factory, address _rout,\r\n        uint256 _percentage_unit,\r\n        uint256 _upfront, uint256 _trail,\r\n        uint256 _pool_fee,\r\n        address[] memory new_stable_list\r\n    )  public onlyOwner{\r\n        factory = _factory;\r\n        rout = _rout;\r\n\r\n        percentage_unit = _percentage_unit;\r\n        upfront_commission = _upfront;\r\n        trail_commission = _trail;\r\n        pool_fee = _pool_fee;\r\n\r\n        delete stable_list;\r\n        stable_list = new_stable_list;\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function GetLPPrice(address pair) external view returns(uint256 lp_eth){\r\n        // uint256 total_supply = IUniswapV2Pair(pair).totalSupply();\r\n        address token0 = IUniswapV2Pair(pair).token0();\r\n        address token1 = IUniswapV2Pair(pair).token1();\r\n        (uint256 token0_balance, uint256 token1_balance, )= IUniswapV2Pair(pair).getReserves();\r\n\r\n        //token0_balance = token0_balance.div(total_supply);\r\n        //token1_balance = token1_balance.div(total_supply);\r\n        //token0_balance = token0_balance.div(10**uint256(IERC20(token0).decimals()));\r\n        //token1_balance = token1_balance.div(10**uint256(IERC20(token1).decimals()));\r\n\r\n        uint256 mode = 0;\r\n        uint256 token0_eth = 0;\r\n        uint256 token1_eth = 0;\r\n        if(token0 != IUniswapV2Router02(rout).WETH()){\r\n            address pair0 = IUniswapV2Factory(factory).getPair(token0, IUniswapV2Router02(rout).WETH());\r\n            if(pair0 != address(0)){\r\n                (uint256 pair0_t0_num, uint256 pair0_t1_num,)= IUniswapV2Pair(pair0).getReserves();\r\n                if(IUniswapV2Pair(pair0).token0() == IUniswapV2Router02(rout).WETH()){\r\n                    token0_eth = pair0_t0_num;\r\n                } else{\r\n                    token0_eth = pair0_t1_num;\r\n                }\r\n                if(token0_eth > eth_thr.mul(10**uint256(IERC20(IUniswapV2Router02(rout).WETH()).decimals()))){\r\n                    mode = mode.add(1);\r\n                    token0_eth = getEstimatedETHforToken(10**uint256(IERC20(token0).decimals()),  token0)[1];\r\n                    //token1_eth = token1_eth.div(10**uint256(IERC20(token1).decimals()));\r\n                }\r\n            }\r\n        }\r\n        if(token1 != IUniswapV2Router02(rout).WETH()){\r\n            address pair1 = IUniswapV2Factory(factory).getPair(token1, IUniswapV2Router02(rout).WETH());\r\n            if(pair1 != address(0)){\r\n                (uint256 pair1_t0_num, uint256 pair1_t1_num,)= IUniswapV2Pair(pair1).getReserves();\r\n                if(IUniswapV2Pair(pair1).token0() == IUniswapV2Router02(rout).WETH()){\r\n                    token1_eth = pair1_t0_num;\r\n                } else{\r\n                    token1_eth = pair1_t1_num;\r\n                }\r\n                if(token1_eth > eth_thr.mul(10**uint256(IERC20(IUniswapV2Router02(rout).WETH()).decimals()))){\r\n                    mode = mode.add(2);\r\n                    token1_eth = getEstimatedETHforToken(10**uint256(IERC20(token1).decimals()),  token1)[1];\r\n                }\r\n            }\r\n        }\r\n\r\n        //uint256 weth_decimal = uint256(IERC20(IUniswapV2Router02(rout).WETH()).decimals());\r\n        if(mode == 1){\r\n            lp_eth = token0_balance.mul(token0_eth).div(10**uint256(IERC20(token0).decimals())).mul(2);//.div(10**uint256(18)).mul(2);\r\n        }else if (mode == 2){\r\n            lp_eth = token1_balance.mul(token1_eth).div(10**uint256(IERC20(token1).decimals())).mul(2);//.div(10**uint256(18)).mul(2);\r\n        }else if (mode == 3){\r\n           // lp_eth = HomoraMath.sqrt(token0_balance.mul(token1_balance)).mul(HomoraMath.sqrt(token0_eth.mul(token1_eth))).mul(2).div(10**uint256(18));\r\n            //lp_eth = (token0_balance.mul(token0_eth).div(10**uint256(18))).add(token1_balance.mul(token1_eth).div(10**uint256(18)));//.div(10**uint256(18));\r\n            lp_eth = token0_balance.mul(token0_eth).div(10**uint256(IERC20(token0).decimals()));\r\n            lp_eth = lp_eth.add(token1_balance.mul(token1_eth).div(10**uint256(IERC20(token1).decimals())));\r\n        }else{\r\n            require(false,\"GetLPPrice2: Cannot calculate the lp price\");\r\n        }\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function getEstimatedETHforToken(uint qty ,address crypto) public view returns (uint[] memory amounts) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = crypto;\r\n        path[1] = IUniswapV2Router02(rout).WETH();\r\n        return IUniswapV2Router02(rout).getAmountsOut(qty, path);\r\n    }\r\n    function getEstimatedTokenForETH(uint qty ,address crypto) public view returns (uint[] memory amounts) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = IUniswapV2Router02(rout).WETH();\r\n        path[1] = crypto;\r\n        return IUniswapV2Router02(rout).getAmountsOut(qty, path);\r\n    }\r\n    function USD() external view returns (uint256 usd){\r\n        for (uint256 i = 0; i<stable_list.length; i++){\r\n            usd = usd.add(getEstimatedTokenForETH(1 ether, stable_list[i])[1].div(10**uint256(IERC20(stable_list[i]).decimals())));\r\n        }\r\n        usd = (usd.mul(percentage_unit).div(percentage_unit.sub(pool_fee))).div(stable_list.length);\r\n\t}\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function WETH() external view returns(address){\r\n        return IUniswapV2Router02(rout).WETH();\r\n    }\r\n    function UpfrontCommission(uint256 _amt) external view returns(uint256 res){\r\n        if(upfront_commission > 0){\r\n            res = _amt.mul(percentage_unit.sub(upfront_commission)).div(percentage_unit);\r\n        }else{\r\n            res = _amt;\r\n        }\r\n    }\r\n    function TrailCommission(uint256 _amt) external view returns(uint256 res){\r\n        if(trail_commission > 0){\r\n            res = _amt.mul(percentage_unit.sub(trail_commission)).div(percentage_unit);\r\n        }else{\r\n            res = _amt;\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    function GetPairName(address pair) external view returns(string memory){\r\n        return string(abi.encodePacked(\r\n            IERC20(IUniswapV2Pair(pair).token0()).symbol(),\r\n            \"-\",\r\n            IERC20(IUniswapV2Pair(pair).token1()).symbol())\r\n            );\r\n    }\r\n    function GetTotal(address pair) external view returns(uint256){\r\n        return IUniswapV2Pair(pair).totalSupply();\r\n    }\r\n    function GetReserves(address pair) external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast){\r\n        return IUniswapV2Pair(pair).getReserves();\r\n    }\r\n    \r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////       \r\n    receive() payable external {}\r\n    \r\n    function kill() onlyOwner public {\r\n        selfdestruct(msg.sender); \r\n    }\r\n    function emergencyTokenWithdrawal(address _token) onlyOwner public {\r\n        IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n    function emergencyETHWithdrawal() onlyOwner public{\r\n        payable(msg.sender).transfer(payable(address(this)).balance);\r\n    }\r\n}"
    }
  }
}