{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Chainlink_Oracle_v1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\n/******************************************/\n/*       ChainLink starts here            */\n/******************************************/\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n/******************************************/\n/*       Benchmark starts here            */\n/******************************************/\n\nabstract contract Benchmark \n\n{\n    function rebase(uint256 supplyDelta, bool increaseSupply) external virtual returns (uint256);\n    \n    function transfer(address to, uint256 value) external virtual returns (bool);\n    \n    function balanceOf(address who) external virtual view returns (uint256);\n\n    function totalSupply() external virtual view returns (uint256);\n}\n\n/******************************************/\n/*       BenchmarkSync starts here        */\n/******************************************/\n\nabstract contract BenchmarkSync \n\n{\n    function syncPools() external virtual;\n}\n\n\n/******************************************/\n/*       BenchmarkOracle starts here       */\n/******************************************/\n\ncontract BenchmarkOracle {\n\n    AggregatorV3Interface internal priceFeed;\n    int256 public lastOracleVxx;\n\n    address owner1;\n    address owner2;\n    address owner3;\n    address owner4;\n    address owner5;\n\n    address public standard;\n    uint256 public standardRewards;\n    \n    Benchmark public bm;\n    BenchmarkSync public sync;\n\n    Transaction public pendingRebasement;\n    uint256 internal lastRebasementTime;\n\n    struct Transaction {\n        address initiator;\n        int256 rebaseOne;\n        int256 rebaseTwo;\n        bool executed;\n    }\n\n    modifier isOwner() \n    {\n        require (msg.sender == owner1 || msg.sender == owner2 || msg.sender == owner3 || msg.sender == owner4 || msg.sender == owner5);\n        _;\n    }\n\n    constructor(address _benchmark, address _standard, address _sync)\n    {\n        /**\n        * Network: Ethereum\n        * Aggregator: VXX\n        * Address: 0xC18F2a0C166A091fcD5E2051EFEFD63c4f4A27E9\n        */\n        priceFeed = AggregatorV3Interface(0xC18F2a0C166A091fcD5E2051EFEFD63c4f4A27E9);\n        lastOracleVxx = getOracleVxx();\n\n        owner1 = 0x2c155e07a1Ee62f229c9968B7A903dC69436e3Ec;\n        owner2 = 0xdBd39C1b439ba2588Dab47eED41b8456486F4Ba5;\n        owner3 = 0x90d33D152A422D63e0Dd1c107b7eD3943C06ABA8;\n        owner4 = 0xE12E421D5C4b4D8193bf269BF94DC8dA28798BA9;\n        owner5 = 0xA77364249507F3e55cFb1143e139F931dCC00E9e;\n        standard = _standard;\n        bm = Benchmark(_benchmark);\n        sync = BenchmarkSync(_sync);\n\n        \n        pendingRebasement.executed = true;\n    }\n\n    /**\n     * Returns the latest price\n     */\n    function getOracleVxx() public view returns (int) {\n        (\n            uint80 roundID, \n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        return price;\n    }\n\n    /**\n     * Returns abs value.\n     */\n    function abs(int x) private pure returns (int) {\n    return x >= 0 ? x : -x;\n    }\n    \n    /**\n     * @dev Initiates a rebasement proposal that has to be confirmed by another owner of the contract to be executed. Can't be called while another proposal is pending.\n     * @param _rebaseOne Price divergence.\n     * @param _rebaseTwo VXX difference.\n     */\n    function initiateRebasement(int256 _rebaseOne, int256 _rebaseTwo) public isOwner\n    {\n        require (pendingRebasement.executed == true, \"Pending rebasement.\");\n        require (lastRebasementTime < (block.timestamp - 300), \"Rebasement has already occured within the past 18 hours.\");\n\n        Transaction storage txn = pendingRebasement; \n        txn.initiator = msg.sender;\n        txn.rebaseOne = _rebaseOne;\n        txn.rebaseTwo = _rebaseTwo;\n        txn.executed = false;\n    }\n\n    /**\n     * @dev Confirms and executes a pending rebasement proposal. Prohibits further proposals for 18 hours.\n     * @param _overrule True if Chainlink Oracle should be ignored.\n     */\n    function confirmRebasement(bool _overrule, int256 _currentVxx) public isOwner\n    {\n        require (pendingRebasement.initiator != msg.sender, \"Initiator can't confirm rebasement.\");\n        require (pendingRebasement.executed == false, \"Rebasement already executed.\");\n        int256 oracleRebaseTwo;\n\n        if (_overrule == false) {\n            oracleRebaseTwo = ((getOracleVxx() - lastOracleVxx) * 1e10) / lastOracleVxx;   \n            oracleRebaseTwo = oracleRebaseTwo < 0 ? int(0) : oracleRebaseTwo;\n            require (oracleRebaseTwo == pendingRebasement.rebaseTwo, \"VXX rebases don't match!\");\n            lastOracleVxx = getOracleVxx();\n        } else {\n            oracleRebaseTwo = pendingRebasement.rebaseTwo;\n            require(_currentVxx != 0, \"Current VXX not provided.\");\n            lastOracleVxx = _currentVxx;\n        }  \n\n        pendingRebasement.executed = true;\n        lastRebasementTime = block.timestamp;\n        \n        int256 rebasePercentage = pendingRebasement.rebaseOne + oracleRebaseTwo;\n        bool increaseSupply = rebasePercentage >= 0 ? true : false;\n        uint256 absolutePercentage = uint256(abs(rebasePercentage));\n        uint256 supplyDelta = bm.totalSupply() * absolutePercentage / 1e10;\n\n        bm.rebase(supplyDelta, increaseSupply);\n        bm.transfer(standard, standardRewards);\n\n        sync.syncPools();\n    }\n\n    /**\n     * @dev View Supply Delta and Sign for rebasement verification.\n     */\n    function verifyRebasement(bool _overrule) public view returns (uint256, bool)\n    {\n        int256 oracleRebaseTwo;\n\n        if (_overrule == false) {\n            oracleRebaseTwo = ((getOracleVxx() - lastOracleVxx) * 1e10) / lastOracleVxx;   \n            oracleRebaseTwo = oracleRebaseTwo < 0 ? int(0) : oracleRebaseTwo;\n            require (oracleRebaseTwo == pendingRebasement.rebaseTwo, \"VXX rebases don't match!\");\n        } else {\n            oracleRebaseTwo = pendingRebasement.rebaseTwo;\n        }  \n        \n        int256 rebasePercentage = pendingRebasement.rebaseOne + oracleRebaseTwo;\n        bool increaseSupply = rebasePercentage >= 0 ? true : false;\n        uint256 absolutePercentage = uint256(abs(rebasePercentage));\n        uint256 supplyDelta = bm.totalSupply() * absolutePercentage / 1e10;\n\n        return(supplyDelta, increaseSupply);\n    }\n\n    /**\n     * @dev Denies a pending rebasement proposal and allows the creation of a new proposal.\n     */\n    function denyRebasement() public isOwner\n    {\n        require (pendingRebasement.executed == false, \"Rebasement already executed.\");\n        \n        pendingRebasement.executed = true;\n    }\n\n    /**\n     * @dev Change Standard staking rewards. \n     * @param _standardRewards New amount of rewards.\n     */\n    function setStandardRewards(uint256 _standardRewards) public isOwner {\n        standardRewards = _standardRewards;\n    }\n\n    /**\n     * @dev Remove all MARK deposited on this contract. \n     */\n    function withdrawMark() public {\n        require (msg.sender == 0x2c155e07a1Ee62f229c9968B7A903dC69436e3Ec || msg.sender == 0xdBd39C1b439ba2588Dab47eED41b8456486F4Ba5, \"Only Masterchief can withdraw.\");\n        bm.transfer(msg.sender, bm.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Change the contract for pool synchronization. \n     */\n    function setSyncContract(address _sync) public isOwner {\n        sync = BenchmarkSync(_sync);\n    }\n}\n    "
    }
  }
}