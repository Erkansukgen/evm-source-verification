{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"trb.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8 <0.8.0;\n\ninterface IOracle{\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes memory _queryData) external;\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes memory _queryData) external;\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\n    function getTimeOfLastNewValue() external view returns(uint256);\n}\n\ncontract TRBMiningBox {\n    address private _owner;\n    address TRBAddress;\n    address TRBMiningAddress;\n    uint256 timeDiffPass;\n    \n    constructor(\n        address _trbaddress, \n        address _miningaddress, \n        uint256 _timeDiffPass\n    ) public {\n        _owner = msg.sender;\n        TRBAddress = _trbaddress;\n        TRBMiningAddress = _miningaddress;\n        timeDiffPass = _timeDiffPass;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function timeDiff() public view returns (uint256) {\n        return timeDiffPass;\n    }\n\n    function trbAddress() public view returns (address) {\n        return TRBAddress;\n    }\n\n    function trbMiningAddress() public view returns (address) {\n        return TRBMiningAddress;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _owner = newOwner;\n    }\n\n    function setTimeDiff(uint256 _timeDiffPass) external onlyOwner {\n        timeDiffPass = _timeDiffPass;\n    }\n\n    function setTRBMiningAddress(address _miningaddress) external onlyOwner {\n        TRBMiningAddress = _miningaddress;\n    }\n\n    function setTRBAddress(address _trbaddress) external onlyOwner {\n        TRBAddress = _trbaddress;\n    }\n\n\n    function submitValue(\n        bytes32 _queryId,\n        bytes calldata _value,\n        uint256 _nonce,\n        bytes memory _queryData\n    ) external onlyOwner {\n        uint256 timeOfLastNewValue = IOracle(TRBMiningAddress).getTimeOfLastNewValue();\n        uint256 _timeDiff = block.timestamp - timeOfLastNewValue;\n        if (_nonce == 0){\n            _nonce = IOracle(TRBMiningAddress).getTimestampCountById(_queryId);\n        }\n        \n        if (_timeDiff > timeDiffPass) {\n            IOracle(TRBMiningAddress).submitValue(_queryId, _value, _nonce, _queryData);\n        }\n    }\n\n    function tipQuery(\n        bytes32 _queryId,\n        uint256 _tip,\n        bytes memory _queryData\n    ) external onlyOwner {\n        IOracle(TRBMiningAddress).tipQuery(_queryId, _tip, _queryData);\n    }\n\n    /**\n     * @dev This is the internal function that allows for delegate calls to the Tellor logic\n     * contract address\n     */\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := call(\n                gas(),\n                implementation,\n                0,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    /**\n     * @dev This is the fallback function that allows contracts to call the tellor\n     * contract at the address stored\n     */\n    fallback() external payable {\n        _delegate(TRBAddress);\n    }\n}"}}}