{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NFTStacking.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2021-12-26\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface IERC721{\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);   \r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n}\r\n\r\n\r\ncontract NFTStacking {\r\n    uint256 private tokenRewardInOneHour = 1*10**15; //0.001 lox\r\n\r\n    uint256 private mimumTimeForUnstake = 14*24*60*60; //14 days.\r\n    \r\n    struct NftStakeObj{\r\n        uint256 nftId;\r\n        uint256 stakingStartTime;\r\n        uint256 lastRewardClaimTime;\r\n        bool isStaked;\r\n    }\r\n\r\n    mapping(uint256=>bool) private isNftStakedByUser; //(nftCount=>isStaked)\r\n    mapping(uint256=>NftStakeObj) private nftStakedData;\r\n\r\n    mapping(uint256=>uint256) private totalRewardWithdrawnByNFT;\r\n\r\n    uint256 private totalStakedNFTs;\r\n\r\n    IERC721 private nftContract;\r\n    IERC20 private tokenContract;\r\n\r\n    address private admin;\r\n\r\n    event nftStakedEvent(address indexed owner, uint256 indexed nftId, uint256 time);\r\n    event nftUnStakedEvent(address indexed owner, uint256 indexed nftId, uint256 time);\r\n\r\n\r\n    constructor(address _nftAddress, address _tokenAddress, address _admin){\r\n        nftContract = IERC721(_nftAddress);\r\n        tokenContract = IERC20(_tokenAddress);\r\n        admin = _admin;\r\n    }\r\n\r\n\r\n    // constructor(){\r\n    //     nftContract = IERC721(0x9d83e140330758a8fFD07F8Bd73e86ebcA8a5692);\r\n    //     tokenContract = IERC20(0xd9145CCE52D386f254917e481eB44e9943F39138);\r\n    //     admin = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\r\n    // }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender==admin,\"No permission\");\r\n        _;\r\n    }\r\n\r\n    function stakeNFT(uint256 _nftCount) public {\r\n        require(nftContract.ownerOf(_nftCount) == msg.sender,\"You don't own this NFT\"); //check if user is the owner of nft\r\n        require(!isNftStakedByUser[_nftCount],\"This NFT Is already staked\");//\r\n\r\n        isNftStakedByUser[_nftCount] = true;\r\n        nftStakedData[_nftCount] = NftStakeObj(_nftCount,block.timestamp,block.timestamp,true);\r\n        totalStakedNFTs += 1; \r\n\r\n        emit nftStakedEvent(msg.sender,_nftCount,block.timestamp);\r\n    }\r\n\r\n    function stakeNFTarray(uint256[] memory _allNftsIds) public {\r\n        for(uint256 i=0;i<_allNftsIds.length;i++){\r\n        require(nftContract.ownerOf(_allNftsIds[i]) == msg.sender,\"You don't own this NFT\"); //check if user is the owner of nft\r\n        require(!isNftStakedByUser[_allNftsIds[i]],\"This NFT Is already staked\");//\r\n\r\n        isNftStakedByUser[_allNftsIds[i]] = true;\r\n        nftStakedData[_allNftsIds[i]] = NftStakeObj(_allNftsIds[i],block.timestamp,block.timestamp,true);\r\n        totalStakedNFTs += 1;\r\n        emit nftStakedEvent(msg.sender,_allNftsIds[i],block.timestamp);\r\n        }\r\n        \r\n    }\r\n\r\n    function unStakeNFT(uint256 _nftCount) public {\r\n        require(nftContract.ownerOf(_nftCount) == msg.sender,\"You don't own this NFT\"); //check if user is the owner of nft\r\n        require(isNftStakedByUser[_nftCount],\"Please stake NFT first\");//\r\n        \r\n        isNftStakedByUser[_nftCount] = false;\r\n        nftStakedData[_nftCount].isStaked = false;\r\n        totalStakedNFTs -= 1;\r\n\r\n        emit nftUnStakedEvent(msg.sender,_nftCount,block.timestamp);\r\n\r\n\r\n        _giveUserReward(_nftCount);\r\n\r\n    }\r\n\r\n    function unStakeNFTarray(uint256[] memory _allNftsIds) public {\r\n        for(uint256 i=0;i<_allNftsIds.length;i++){\r\n\r\n        require(nftContract.ownerOf(_allNftsIds[i]) == msg.sender,\"You don't own this NFT\"); //check if user is the owner of nft\r\n        require(isNftStakedByUser[_allNftsIds[i]],\"Please stake NFT first\");//\r\n        \r\n        isNftStakedByUser[_allNftsIds[i]] = false;\r\n        nftStakedData[_allNftsIds[i]].isStaked = false;\r\n        totalStakedNFTs -= 1;\r\n\r\n        emit nftUnStakedEvent(msg.sender,_allNftsIds[i],block.timestamp);\r\n\r\n        _giveUserReward(_allNftsIds[i]);\r\n\r\n        }\r\n    }\r\n\r\n    function claimReward(uint256 _nftCount) public {\r\n        \r\n        require(nftContract.ownerOf(_nftCount) == msg.sender,\"You don't own this NFT\"); //check if user is the owner of nft\r\n        require(isNftStakedByUser[_nftCount],\"Please stake NFT first\");//\r\n\r\n        _giveUserReward(_nftCount);\r\n    }\r\n\r\n    function claimRewardarray(uint256[] memory _allNftsIds) public {\r\n        for(uint256 i=0;i<_allNftsIds.length;i++){\r\n        require(nftContract.ownerOf(_allNftsIds[i]) == msg.sender,\"You don't own this NFT\"); //check if user is the owner of nft\r\n        require(isNftStakedByUser[_allNftsIds[i]],\"Please stake NFT first\");//\r\n\r\n        _giveUserReward(_allNftsIds[i]);\r\n        }\r\n    }\r\n\r\n    function _giveUserReward(uint256 _nftCount) private  {\r\n        require(nftStakedData[_nftCount].lastRewardClaimTime + mimumTimeForUnstake < block.timestamp ,\"You can claim after minimum staking time\");\r\n\r\n        uint256 _stakingstartTime = nftStakedData[_nftCount].lastRewardClaimTime;\r\n        uint256 _stakingIntervalTime = block.timestamp - _stakingstartTime;\r\n        nftStakedData[_nftCount].lastRewardClaimTime = block.timestamp;\r\n\r\n        uint256 _tokenReward = (_stakingIntervalTime/(60*60))*tokenRewardInOneHour;\r\n        totalRewardWithdrawnByNFT[_nftCount] += _tokenReward;\r\n\r\n        require(tokenContract.transfer(msg.sender,_tokenReward),\"Token transfer failed\");\r\n    }\r\n\r\n\r\n\r\n    function withdrawBalance(address _to) public payable onlyAdmin {\r\n        (bool os, ) = payable(_to).call{value: address(this).balance}(\"\");\r\n        require(os);\r\n    }\r\n\r\n    function withdrawBalanceERC20(IERC20 _token, address _to, uint256 _amount) public payable onlyAdmin {\r\n        _token.transfer(_to,_amount);\r\n    }\r\n\r\n    function adminBalance() public view onlyAdmin returns(uint256) {\r\n        return  address(this).balance;\r\n    }\r\n\r\n    function adminBalanceERC20(IERC20 _token) public view onlyAdmin returns(uint256) {\r\n        return  _token.balanceOf(address(this));\r\n    }\r\n\r\n    function changeAdmin(address _newAdmin) public onlyAdmin {\r\n    admin = _newAdmin;\r\n    }\r\n\r\n    function changeTokenRewardInOneHour(uint256 _tokenRewardInOneHour) public onlyAdmin {\r\n    tokenRewardInOneHour = _tokenRewardInOneHour;\r\n    }\r\n\r\n    function changeMimumTimeForUnstake(uint256 _mimumTimeForUnstake) public onlyAdmin {\r\n    mimumTimeForUnstake = _mimumTimeForUnstake;\r\n    }\r\n\r\n    // getFunctions\r\n    function getIsNftStakedByUser(uint256 _nftId) public view returns(bool){\r\n        return isNftStakedByUser[_nftId];\r\n    }\r\n\r\n    function getNftStakedByUser(uint256 _nftId) public view  returns(NftStakeObj memory){\r\n        return nftStakedData[_nftId];\r\n    }\r\n\r\n    function gettotalRewardWithdrawnByNFT(uint256 _nftCount) public view  returns(uint256){\r\n        return totalRewardWithdrawnByNFT[_nftCount];\r\n    }\r\n\r\n    function getTotalStakedNFTs() public view  returns(uint256){\r\n        return totalStakedNFTs;\r\n    }\r\n\r\n    function getTokenRewardInOneHour() public view  returns(uint256){\r\n        return tokenRewardInOneHour;\r\n    }\r\n\r\n    function getMimumTimeForUnstake() public view  returns(uint256){\r\n        return mimumTimeForUnstake;\r\n    }\r\n    \r\n     \r\n}"}}}