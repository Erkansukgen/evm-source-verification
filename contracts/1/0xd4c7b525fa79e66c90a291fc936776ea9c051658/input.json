{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NEOM.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\ncontract CryptoNeom is IERC20 {\n\n    string public constant name = \"Neom defi\";\n    string public constant symbol = \"NEOM\";\n    uint8 public constant decimals = 18;\n    uint8 public  exchangeRate    = 100;   \n    \n\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Burn(address indexed from, uint256 value);\n\n    mapping(address => uint256)  balances;\n\n    mapping(address => mapping (address => uint256)) allowed;\n\n    uint256 totalSupply_ = 1000000000000000000000000 ;\n\n    using SafeMath for uint256;\n\n\n   constructor() public {\n  balances[msg.sender] = totalSupply_;\n         \n    }\n  \n    function totalSupply() public override view returns (uint256) {\n    return totalSupply_;\n    }\n\n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override returns (bool) {\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {\n        require(numTokens <= balances[owner]);\n        require(numTokens <= allowed[owner][msg.sender]);\n\n        balances[owner] = balances[owner].sub(numTokens);\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n        balances[buyer] = balances[buyer].add(numTokens);\n        emit Transfer(owner, buyer, numTokens);\n        return true;\n    }\n    function burn(uint256 _value) public returns (bool success){\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -=_value;\n        return true;\n        emit Burn(msg.sender, _value);\n    }\n}\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      assert(b <= a);\n      return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n    }\n}\ncontract DEX {\n\n    CryptoNeom public token;\n\n    event Bought(uint256 amount);\n    event Sold(uint256 amount);\n\n    constructor() public {\n        \n      token = new CryptoNeom();\n    }\n\n    \n    \nfunction buy() payable public {\n    uint256 amountTobuy = msg.value;\n    uint256 dexBalance = token.balanceOf(address(this));\n    require(amountTobuy > 0, \"You need to send some ether\");\n    require(amountTobuy <= dexBalance, \"Not enough tokens in the reserve\");\n    token.transfer(msg.sender, amountTobuy);\n    emit Bought(amountTobuy);\n}\nfunction sell(uint256 amount) public {\n    require(amount > 0, \"You need to sell at least some tokens\");\n    uint256 allowance = token.allowance(msg.sender, address(this));\n    require(allowance >= amount, \"Check the token allowance\");\n    token.transferFrom(msg.sender, address(this), amount);\n    msg.sender.transfer(amount);\n    emit Sold(amount);\n}\n\n\n\n}\n\n\n"}}}