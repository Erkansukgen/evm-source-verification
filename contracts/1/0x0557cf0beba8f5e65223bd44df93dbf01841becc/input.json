{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "PETH_Patch.sol": {
      "content": "pragma solidity ^0.6.6;\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n// ----------------------------------------------------------------------------\n abstract contract IERC20 {\n    function totalSupply()virtual  public  view returns (uint);\n    function balanceOf(address tokenOwner)virtual public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\n    function transfer(address to, uint tokens) virtual public returns (bool success);\n    function approve(address spender, uint tokens) virtual public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n//\n// Borrowed from MiniMeToken\n// ----------------------------------------------------------------------------\nabstract contract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data)virtual public;\n}\n\nabstract contract PETH{\n        function GetUserInfo(address user)virtual public view returns (bool ,uint256,address,uint256,uint256,uint256,uint256);\n\n    \n}\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\ncontract PETH_Patch is Owned\n{\n    using SafeMath for uint;\n    \n    struct Withdraw_From_This {\n        \n        uint256 amount ;\n    }\n    mapping(address=>Withdraw_From_This) public m_Withdraw_Amount;\n    uint256 public m_Level1_Price=5e17;\n    address public m_PETH_Address;\n    uint256 public m_Numerator=1;\n    uint256 public m_Denominator=1;\n    function Adjust_Rate(uint256 N,uint256 D)public onlyOwner\n    {\n        m_Numerator=N;\n        m_Denominator=D;\n    }\n    \n    function Set_Peth_Address(address peth)public onlyOwner\n    {\n        m_PETH_Address=peth;\n    }\n    function Set_Level1_Price(uint256 price)public  onlyOwner returns(bool)\n    {\n         \n        m_Level1_Price=price;\n        return true;\n    }\n    function Get_User_Spending(address user) public view returns (uint256)\n    {\n       (bool reg ,uint256 quota,address referer,uint256 level ,uint256 losed ,uint256 picked,uint256 profit) = PETH(m_PETH_Address). GetUserInfo(user);\n       uint256 t_price= ((2**(level))-1) * m_Level1_Price;\n       return t_price;\n       \n       \n    }\n    \n    function Get_User_Quota_Used(address user) public view returns (uint256)\n    {\n       (bool reg ,uint256 quota,address referer,uint256 level ,uint256 losed ,uint256 picked,uint256 profit) = PETH(m_PETH_Address). GetUserInfo(user);\n       uint256 t_spending= ((2**(level+1))-1) * m_Level1_Price;\n       uint256 t_max_quota=t_spending*250/100;\n       if(level==6)\n       {\n           t_max_quota=2**254;\n       }\n       uint256 t_quota_used=0;\n       if(t_max_quota>=quota)\n       {\n           t_quota_used=t_max_quota-quota;\n       }\n       else\n       {\n           t_quota_used=0;\n       }\n       \n       \n       return t_quota_used;\n       \n       \n    }\n    \n    function Get_User_Quota_Remaining(address user) public view returns (uint256)\n    {\n        (bool reg ,uint256 quota,address referer,uint256 level ,uint256 losed ,uint256 picked,uint256 profit) = PETH(m_PETH_Address). GetUserInfo(user);\n       uint256 t_spending= ((2**(level))-1) * m_Level1_Price;\n       uint256 t_max_quota=t_spending*250/100;\n      \n       uint256 t_quota_remaining=quota;\n        if(level==6)\n        {\n            uint256 used=0;\n            if(2**254>=quota)\n            {\n                used=2**254-quota;\n            }else{\n                \n            }\n           t_quota_remaining=t_max_quota - used;\n        }\n       t_quota_remaining*=m_Numerator;\n       t_quota_remaining/=m_Denominator;\n       return t_quota_remaining;\n    }\n    \n    function Get_Available_Quota(address user) public view returns (uint256)\n    {\n        \n        uint256 available_amount=Get_User_Quota_Remaining(user);\n        if(m_Withdraw_Amount[user].amount<available_amount)\n        {\n            return available_amount-m_Withdraw_Amount[msg.sender].amount;\n        }\n        return 0;\n    }\n    function GetETH(uint256 quantity) public payable returns(bool)\n    {\n        uint256 t_available_amount=Get_Available_Quota(msg.sender);\n        require(t_available_amount>=quantity,\"OVERDRAW\");\n        m_Withdraw_Amount[msg.sender].amount+=quantity;\n        _safeTransferFrom(m_PETH_Address,msg.sender,(address)(this),quantity);\n        (address((uint160)(msg.sender))).transfer(quantity);\n        \n    }\n    fallback() external payable {}\n    receive() external payable { \n   \n    }\n    \n    function _safeTransfer(address token, address to, uint256 value) private  {\n        _callOptionalReturn(token, abi.encodeWithSelector(IERC20(token).transfer.selector, to, value));\n    }\n\n    function _safeTransferFrom(address token, address from, address to, uint256 value) private  {\n        _callOptionalReturn(token, abi.encodeWithSelector(IERC20(token).transferFrom.selector, from, to, value));\n    }\n    \n    function safeTransfer(address token, address to, uint256 value) public onlyOwner {\n        _callOptionalReturn(token, abi.encodeWithSelector(IERC20(token).transfer.selector, to, value));\n    }\n    function safeTransferFrom(address token, address from, address to, uint256 value) public onlyOwner {\n        _callOptionalReturn(token, abi.encodeWithSelector(IERC20(token).transferFrom.selector, from, to, value));\n    }\n    function Call_Function(address addr,uint256 value ,bytes memory data) public payable onlyOwner {\n      addr.call.value(value)(data);\n    }\n    function _callOptionalReturn(address token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success==true,\"SafeERC20: ERC20 operation did not succeed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n    \n}"
    }
  }
}