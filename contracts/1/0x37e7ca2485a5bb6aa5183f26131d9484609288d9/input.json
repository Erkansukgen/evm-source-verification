{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SecurityTest.sol": {
      "content": "/**\r\nBREAK THE CODE, EARN THE CASH\r\n\r\nMany people in the ETH community act as if they are experts, but do not even review the code of the contracts they use, let alone realize what exploits might be possible.\r\n\r\nWe are a team of enthusiasts looking for more members talented in Solidity. We believe the best way to find good coders is to give people challenges to conquer. This contract is one such challenge.\r\n\r\nIf you manage to capture the ETH stored in the contract, then congratulations! You are free to keep it, but we would like to speak with you. We have lucrative opportunities to discuss. Email us at TeamMoon@protonmail.com with proof of your exploit.\r\n*/\r\n\r\npragma solidity ^0.7.5;\r\n\r\ncontract SecurityTest {\r\n\r\n\tuint minDeposit = 1 ether;\r\n\tuint one = 0.1 ether;\r\n\tuint two = 2 ether;\r\n\tuint waitingPeriod = 60; //one minute\r\n\tbool public approved;\r\n\r\n\tmapping(address=>uint) public deposits;\r\n\tmapping(address=>uint) public depositTimes;\r\n\tmapping(address=>uint) public counts;\r\n\r\n\tAttemptLog log;\r\n\r\n\tconstructor(address payable logger) {\r\n\t\tlog = AttemptLog(logger);\r\n\t}\r\n\r\n\treceive() external payable {\r\n\t\tdeposit();\r\n\t}\r\n\r\n\tfunction deposit() public payable {\r\n\t\tif (msg.value>minDeposit) {\r\n\t\t\tdeposits[msg.sender] += msg.value;\r\n\t\t\tdepositTimes[msg.sender] = block.timestamp;\r\n\t\t\tlog.postEntry(msg.sender, msg.value, \"Deposit\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction withdraw(uint amount) external payable{\r\n\t\tif (approved) {\r\n\t\t\trequire(amount <= deposits[msg.sender]);\r\n\t\t\trequire(block.timestamp >= (depositTimes[msg.sender] + waitingPeriod));\r\n\t\t\tif ((counts[msg.sender] != 0) && (counts[msg.sender] < 4)) {\r\n\t\t\t\t(bool success, bytes memory returnData) = (msg.sender.call{value:amount}(\"\"));\r\n\t\t\t\tif (success) {\r\n\t\t\t\t\tdeposits[msg.sender] -= amount;\r\n\t\t\t\t\tlog.postEntry(msg.sender, amount, \"Success\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else{\r\n\t\t\tgetRekt(amount - msg.value);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction tryMe() external payable {\r\n\t\tif(msg.value == one){\r\n\t\t\tapproved = true;\r\n\t\t\tmsg.sender.call{value:msg.value}(\"\");\r\n\t\t\tapproved = false;\r\n\t\t} else {\r\n\t\t\tgetRekt(0);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getRekt(uint value) internal {\r\n\t\tuint rektAmount = deposits[msg.sender];\r\n\t\tdeposits[msg.sender] = 0;\r\n\t\tlog.postEntry(msg.sender, rektAmount, \"Rekt\");\r\n\t\tcounter(value);\r\n\t}\r\n\r\n\tfunction counter(uint value) internal {\r\n\t\tif (value >= two){\r\n\t\t\tcounts[msg.sender] += 1;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction potSize() public view returns(uint) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\r\n}\r\n\r\ncontract AttemptLog{\r\n\tevent logEntry(address, uint, string);\r\n\tfunction postEntry(address user, uint amount, string memory action) external{\r\n\t\temit logEntry(user, amount, action);\r\n\t}\r\n}"
    }
  }
}