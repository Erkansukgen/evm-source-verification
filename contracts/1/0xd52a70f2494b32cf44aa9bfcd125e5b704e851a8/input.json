{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/JuliaSwap.sol":{"content":"// SPDX-License-Identifier: UNLISCENSED\n\npragma solidity 0.8.4;\n\ncontract SWP {\n    struct NFT_offer {\n        address nft_address;\n        uint256 token_id;\n        address trader;\n    }\n    \n    address constant JULIA = 0x6e845bE4ea601B4Dbe98ED1f52b371dca1Dbb2b6; // MAIN NET\n    address nft_in  = JULIA;\n    address nft_out = JULIA;\n\n    mapping (address => mapping (uint256 => NFT_offer)) swap_offers;\n\n    constructor () {}\n\n    /*\n      One has to approve this contract to use his/her `token_offered` before calling this\n    */\n    function offer_swap(uint256 token_offered, uint256 token_requested) public {\n        uint8   verified = 0;\n        uint256 j = 0;\n        uint256 owned;\n        while (verified < 1) {\n            owned = IERC721Enumerable(nft_in).tokenOfOwnerByIndex(msg.sender, j);\n            if (owned==token_offered) verified++;\n            j++;\n        }\n        require(verified==1);\n        require(IERC721Enumerable(nft_in).getApproved(token_offered)==address(this));\n        swap_offers[nft_in][token_offered] = NFT_offer(nft_out, token_requested, msg.sender);\n    }\n\n    /*\n      One has to approve this contract to use his/her `token_in` before calling this.\n      `token_in` is the token that is required by the offer maker \n      and should be held by the party accepting the offer.\n      `tokwen_out` is the token that is offered by the offer maker \n      and will be given to the party accepting the offer.\n    */\n    function make_swap(uint256 token_in,uint256 token_out) public {\n        NFT_offer memory offer = swap_offers[nft_out][token_out];\n        require(offer.nft_address==nft_in && offer.token_id==token_in);\n        IERC721Enumerable(nft_out).safeTransferFrom(offer.trader, msg.sender, token_out);\n        IERC721Enumerable(nft_in ).safeTransferFrom(msg.sender, offer.trader, token_in);\n    }\n\n    /*\n      Checks if an offer to swap `token_offered` for `token_requested` is available and approved\n      (just to avoid wasting gas in case `make_swap` would fail)\n    */\n    function check_offer(uint256 token_offered, uint256 token_requested) public view returns (bool) {\n        NFT_offer memory offer = swap_offers[nft_out][token_offered];\n        bool approved = IERC721Enumerable(nft_out).getApproved(token_offered)==address(this);\n        return (offer.nft_address==nft_in && offer.token_id==token_requested && approved);\n    }\n\n}\n\ncontract IERC721Enumerable {\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {}\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {}\n    function getApproved(uint256 tokenId) external view returns (address operator) {}\n}"}}}