{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "ArbitrageBot.sol": {
      "content": "pragma solidity ^0.7.0;  \r\n \r\ninterface DexInterface {\r\n    function swapExactTokensForETH( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external  returns (uint[] memory amounts); \r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable  returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);\r\n    function WETH() external pure returns(address);\r\n}  \r\n \r\ninterface IERC20 {\r\n   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n   function approve(address spender, uint256 amount) external returns (bool);\r\n   function transfer(address recipient, uint256 amount) external returns (bool);\r\n   function balanceOf(address account) external view returns (uint256);\r\n} \r\n \r\ncontract ArbitrageBot { \r\n    \r\n    DexInterface public uniswap;\r\n    DexInterface public sushiswap; \r\n    DexInterface public tacoswap; \r\n    address public owner;   \r\n     \r\n    constructor(address _uniswap,address _sushiswap, address _tacoswap, address _owner){\r\n        uniswap = DexInterface(_uniswap); \r\n        sushiswap = DexInterface(_sushiswap);  \r\n        tacoswap = DexInterface(_tacoswap);  \r\n        owner = _owner; \r\n    }   \r\n    \r\n    modifier isOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function.\");\r\n        _;\r\n    }    \r\n    \r\n    fallback() external payable { }  \r\n    receive() external payable {  }  \r\n \r\n\r\n    // Swap ETH for tokens on uniswap\r\n    function swapExactTokensForETHUni( address token, uint amountIn, uint amountOutMin )external isOwner{  \r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = uniswap.WETH();\r\n        IERC20(token).approve(address(uniswap), amountIn);\r\n        uint deadline = block.timestamp + 1200;\r\n        uniswap.swapExactTokensForETH( amountIn, amountOutMin, path, address(this), deadline ); \r\n    }  \r\n    \r\n    \r\n    // Swap ETH for tokens on sushiswap\r\n    function swapExactTokensForETHSUSHI( address token, uint amountIn, uint amountOutMin )external isOwner{  \r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = sushiswap.WETH();\r\n        IERC20(token).approve(address(sushiswap), amountIn);\r\n        uint deadline = block.timestamp + 1200;\r\n        sushiswap.swapExactTokensForETH( amountIn, amountOutMin, path, address(this), deadline ); \r\n    }  \r\n    \r\n\r\n    // Swap ETH for tokens on tacoswap\r\n    function swapExactTokensForETHTaco( address token, uint amountIn, uint amountOutMin )external isOwner{  \r\n        address[] memory path = new address[](2);\r\n        path[0] = token;\r\n        path[1] = tacoswap.WETH();\r\n        IERC20(token).approve(address(tacoswap), amountIn);\r\n        uint deadline = block.timestamp + 1200;\r\n        tacoswap.swapExactTokensForETH( amountIn, amountOutMin, path, address(this), deadline ); \r\n    }  \r\n   \r\n\r\n    // Swap exact ETH for tokens from Uni to Sushi\r\n    function swapExactETHForTokensUniToSushi ( uint amountOutUni, uint amountOutSushi, address tokenIn, address tokenOut, uint _value ) external isOwner {   \r\n        uint uniDeadline = block.timestamp + 1200; \r\n        address[] memory pathUni = new address[](2);\r\n        pathUni[0] = tokenIn;\r\n        pathUni[1] = tokenOut;\r\n        uint[] memory amountBack = uniswap.swapExactETHForTokens{value: _value}( amountOutUni, pathUni, address(this), uniDeadline ); \r\n         \r\n        uint sushiDeadline = block.timestamp + 1200;\r\n        address[] memory pathSushi = new address[](2);\r\n        pathSushi[0] = tokenOut;\r\n        pathSushi[1] = tokenIn;\r\n        IERC20(tokenOut).approve(address(sushiswap), amountBack[1]); \r\n        sushiswap.swapExactTokensForETH( amountBack[1], amountOutSushi, pathSushi, address(this), sushiDeadline); \r\n    }\r\n    \r\n\r\n    // Swap exact ETH for tokens from Sushi to Uni\r\n    function swapExactETHForTokensSushiToUni ( uint amountOutSushi, uint amountOutUni, address tokenIn, address tokenOut, uint _value ) external isOwner {   \r\n        uint sushiDeadline = block.timestamp + 1200; \r\n        address[] memory pathSushi = new address[](2);\r\n        pathSushi[0] = tokenIn;\r\n        pathSushi[1] = tokenOut;\r\n        uint[] memory amountBack = sushiswap.swapExactETHForTokens{value: _value}( amountOutSushi, pathSushi, address(this), sushiDeadline ); \r\n         \r\n        uint uniDeadline = block.timestamp + 1200;\r\n        address[] memory pathUni = new address[](2);\r\n        pathUni[0] = tokenOut;\r\n        pathUni[1] = tokenIn;\r\n        IERC20(tokenOut).approve(address(uniswap), amountBack[1]); \r\n        uniswap.swapExactTokensForETH( amountBack[1], amountOutUni, pathUni, address(this), uniDeadline); \r\n    }\r\n\r\n\r\n    // Swap exact ETH for tokens from Uni to Taco\r\n    function swapExactETHForTokensUniToTaco ( uint amountOutUni, uint amountOutTaco, address tokenIn, address tokenOut, uint _value ) external isOwner {   \r\n        uint uniDeadline = block.timestamp + 1200; \r\n        address[] memory pathUni = new address[](2);\r\n        pathUni[0] = tokenIn;\r\n        pathUni[1] = tokenOut;\r\n        uint[] memory amountBack = uniswap.swapExactETHForTokens{value: _value}( amountOutUni, pathUni, address(this), uniDeadline ); \r\n         \r\n        uint tacoDeadline = block.timestamp + 1200;\r\n        address[] memory pathTaco = new address[](2);\r\n        pathTaco[0] = tokenOut;\r\n        pathTaco[1] = tokenIn;\r\n        IERC20(tokenOut).approve(address(tacoswap), amountBack[1]); \r\n        tacoswap.swapExactTokensForETH( amountBack[1], amountOutTaco, pathTaco, address(this), tacoDeadline); \r\n    } \r\n\r\n\r\n    // Swap exact ETH for tokens from Taco to Uni\r\n    function swapExactETHForTokensTacoToUni ( uint amountOutTaco, uint amountOutUni, address tokenIn, address tokenOut, uint _value ) external isOwner {   \r\n        uint tacoDeadline = block.timestamp + 1200; \r\n        address[] memory pathTaco = new address[](2);\r\n        pathTaco[0] = tokenIn;\r\n        pathTaco[1] = tokenOut;\r\n        uint[] memory amountBack = tacoswap.swapExactETHForTokens{value: _value}( amountOutTaco, pathTaco, address(this), tacoDeadline ); \r\n         \r\n        uint uniDeadline = block.timestamp + 1200;\r\n        address[] memory pathUni = new address[](2);\r\n        pathUni[0] = tokenOut;\r\n        pathUni[1] = tokenIn;\r\n        IERC20(tokenOut).approve(address(uniswap), amountBack[1]); \r\n        uniswap.swapExactTokensForETH( amountBack[1], amountOutUni, pathUni, address(this), uniDeadline); \r\n    }\r\n  \r\n\r\n    // Swap exact ETH for tokens from Sushi to Taco\r\n    function swapExactETHForTokensSushiToTaco ( uint amountOutSushi, uint amountOutTaco, address tokenIn, address tokenOut, uint _value ) external isOwner {   \r\n        uint sushiDeadline = block.timestamp + 1200; \r\n        address[] memory pathSushi = new address[](2);\r\n        pathSushi[0] = tokenIn;\r\n        pathSushi[1] = tokenOut;\r\n        uint[] memory amountBack = sushiswap.swapExactETHForTokens{value: _value}( amountOutSushi, pathSushi, address(this), sushiDeadline ); \r\n         \r\n        uint tacoDeadline = block.timestamp + 1200;\r\n        address[] memory pathTaco = new address[](2);\r\n        pathTaco[0] = tokenOut;\r\n        pathTaco[1] = tokenIn;\r\n        IERC20(tokenOut).approve(address(tacoswap), amountBack[1]); \r\n        tacoswap.swapExactTokensForETH( amountBack[1], amountOutTaco, pathTaco, address(this), tacoDeadline); \r\n    }\r\n\r\n\r\n    // Swap exact ETH for tokens from Taco to Sushi\r\n    function swapExactETHForTokensTacoToSushi ( uint amountOutTaco, uint amountOutSushi, address tokenIn, address tokenOut, uint _value ) external isOwner {   \r\n        uint tacoDeadline = block.timestamp + 1200; \r\n        address[] memory pathTaco = new address[](2);\r\n        pathTaco[0] = tokenIn;\r\n        pathTaco[1] = tokenOut;\r\n        uint[] memory amountBack = tacoswap.swapExactETHForTokens{value: _value}( amountOutTaco, pathTaco, address(this), tacoDeadline ); \r\n         \r\n        uint sushiDeadline = block.timestamp + 1200;\r\n        address[] memory pathSushi = new address[](2);\r\n        pathSushi[0] = tokenOut;\r\n        pathSushi[1] = tokenIn;\r\n        IERC20(tokenOut).approve(address(sushiswap), amountBack[1]); \r\n        sushiswap.swapExactTokensForETH( amountBack[1], amountOutSushi, pathSushi, address(this), sushiDeadline); \r\n    }\r\n\r\n\r\n    // Transfer contract ownership\r\n    function transferOwnership (address _owner) external isOwner{\r\n        owner = _owner;\r\n    }\r\n\r\n\r\n    // Reset DEX contract address\r\n    function resetDEXAddress  (address _uniswap, address _sushiswap, address _tacoswap ) external  isOwner {\r\n        uniswap = DexInterface(_uniswap); \r\n        sushiswap = DexInterface(_sushiswap);  \r\n        tacoswap = DexInterface(_tacoswap);  \r\n    } \r\n    \r\n    \r\n    // Returns contract's ETH balance\r\n    function getETHBalance () external view returns (uint){\r\n        return address(this).balance;\r\n    }  \r\n    \r\n    \r\n    // Returns contract's particular token balance\r\n    function getTokenBalance(address _address) external view returns (uint) {\r\n      return IERC20(_address).balanceOf(address(this));\r\n    }  \r\n     \r\n     \r\n     // Transfer ETH from contract's balance after token swap \r\n    function transferETH (address payable _recipient, uint _amount) external isOwner{\r\n        require(_amount > 0 ); \r\n        _recipient.transfer(_amount);    \r\n    }  \r\n    \r\n     // Withdraw contract's particular token balance\r\n    function transferTokens (address _tokenAddress, address  _recipient, uint _amount) public  isOwner returns (bool){ \r\n        require(_amount > 0 ); \r\n        IERC20(_tokenAddress).transfer(_recipient, _amount);\r\n        return true;\r\n    }  \r\n    \r\n    // Withdraw contract's ETH balance\r\n    function withdrawETHBalance(address payable  recipient) external isOwner{\r\n        recipient.transfer(address(this).balance);\r\n    }     \r\n   \r\n}"
    }
  }
}