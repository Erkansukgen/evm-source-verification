{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/burnHelper.sol": {
      "content": "  \r\n// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\n\r\n//remixd -s E:\\BurnBot --remix-ide https://remix.ethereum.org\r\npragma solidity 0.6.12;\r\n\r\nabstract contract IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() virtual external view returns (string memory);\r\n    function symbol() virtual external view returns (string memory);\r\n    function decimals() virtual external view returns (uint8);\r\n    function totalSupply() virtual external view returns (uint);\r\n    function balanceOf(address owner) virtual external view returns (uint);\r\n    function allowance(address owner, address spender) virtual external view returns (uint);\r\n\r\n    function approve(address spender, uint value) virtual external returns (bool);\r\n    function transfer(address to, uint value) virtual external returns (bool);\r\n    function transferFrom(address from, address to, uint value) virtual external returns (bool);\r\n}\r\n\r\n\r\nabstract contract IBancorVortex\r\n{\r\n    function burn(IERC20[] calldata tokens) virtual external;\r\n}\r\n\r\nabstract contract IBancorNetwork {\r\n    \r\n    // deprecated, backward compatibility\r\n    function convertFor(\r\n        IERC20[] memory _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for\r\n    ) virtual external payable returns (uint256);\r\n}\r\n\r\ncontract BurnBot\r\n{\r\n    address public minter;\r\n    IERC20 bntToken = IERC20(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C);\r\n\r\n    constructor() public\r\n    {\r\n        minter = msg.sender; \r\n        \r\n        // Allow\r\n        uint256 allowance = bntToken.allowance(address(this), minter);\r\n        if (allowance == 0)\r\n        {\r\n            bntToken.approve(minter, 2**256 - 1);\r\n        }\r\n    }\r\n\r\n    // these functions ARE REQUIRED to receive ether\r\n    fallback() external payable {\r\n        // custom function code\r\n    }\r\n\r\n    receive() external payable {\r\n        // custom function code\r\n    }\r\n\r\n    function transferEth(uint256 amount) public returns (uint256)\r\n    {\r\n        require (msg.sender == minter, \"1\");\r\n        msg.sender.transfer(amount);\r\n        return amount;\r\n    }\r\n\r\n    function transferToken(uint256 amount) public returns (uint256)\r\n    {\r\n        require (msg.sender == minter, \"2\");\r\n\r\n        bntToken.transfer(msg.sender, amount);\r\n        return amount;\r\n    }\r\n    \r\n    function swapBntForEthTo(address bancorNetworkAddress, address payable to, uint256 minReturn) public payable  returns (uint256)\r\n    {\r\n        require (msg.sender == minter, \"5\");\r\n        \r\n        uint256 bntBalance = bntToken.balanceOf(address(this));\r\n            \r\n        // Allow\r\n        uint256 allowance = bntToken.allowance(address(this), bancorNetworkAddress);\r\n        if (allowance == 0)\r\n        {\r\n            bntToken.approve(bancorNetworkAddress, 2**256 - 1);\r\n        }\r\n\r\n        IERC20[] memory exchangeBntToEthPath = new IERC20[](3);\r\n        exchangeBntToEthPath[0] = IERC20(0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C);\r\n        exchangeBntToEthPath[1] = IERC20(0xb1CD6e4153B2a390Cf00A6556b0fC1458C4A5533);\r\n        exchangeBntToEthPath[2] = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n        \r\n        // Swap on bancor network\r\n        IBancorNetwork bancorNetwork = IBancorNetwork(bancorNetworkAddress);\r\n        return bancorNetwork.convertFor{value: 0}(exchangeBntToEthPath, bntBalance, minReturn, to);\r\n    }\r\n    \r\n    function burnVortex(address bancorVortexAddress, IERC20[] calldata burnTokens) public \r\n    {\r\n        require (msg.sender == minter, \"4\");\r\n\r\n        // Get bancor vortex\r\n        IBancorVortex bancorVortex = IBancorVortex(bancorVortexAddress);\r\n            \r\n        // Burn it\r\n        bancorVortex.burn(burnTokens);\r\n    }\r\n    \r\n    function burnVortexWithFlashbotBribe(address bancorNetworkAddress, address bancorVortexAddress, IERC20[] calldata burnTokens, uint256 bribePercentage)\r\n                              payable external\r\n    {\r\n        burnVortex(bancorVortexAddress, burnTokens);\r\n\r\n        // Convert BNT to ETH\r\n        uint256 returnAmount = swapBntForEthTo(bancorNetworkAddress, address(0), 1);\r\n\r\n        // Bribe \r\n        uint256 minerBribe = returnAmount * bribePercentage / 100;\r\n        block.coinbase.transfer(minerBribe);\r\n        \r\n        // Return remainder\r\n        msg.sender.transfer(returnAmount - minerBribe);\r\n    }\r\n}"
    }
  }
}