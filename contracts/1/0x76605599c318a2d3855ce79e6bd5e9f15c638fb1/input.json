{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/pownft.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-08-24\n*/\n\npragma solidity =0.8.7;\n\ninterface IPOWNFTPartial{\n    function mine(uint nonce) external payable;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n}\n\ncontract POWNFTMinter {\n    \n    IPOWNFTPartial mainContract = IPOWNFTPartial(0x9Abb7BdDc43FA67c76a62d8C016513827f59bE1b);\n    address private owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n    \n\n    function guarded_mine(\n        uint token_id,\n        uint generation,\n        uint cost,\n        uint minAtomicNumber,\n        uint nonce,\n        uint _ethAmountToCoinbase,\n        bytes32 pre_hash\n    ) external payable {\n        bytes32 hash = keccak256(abi.encodePacked(pre_hash, block.timestamp));\n        uint atomicNumber = calculateAtomicNumber(token_id, hash, generation);\n\n        if (atomicNumber>minAtomicNumber) {\n            mainContract.mine{value: cost}(nonce);\n            mainContract.transferFrom(address(this), msg.sender, token_id);\n            block.coinbase.transfer(_ethAmountToCoinbase);\n        }\n    }\n    \n    function withdraw(address payable to) external {\n        require(msg.sender == owner);\n        to.transfer(address(this).balance);\n    }\n\n    /// @notice Round up to calculate \"ceil\".\n    /// @dev Because the metadata uses Javascript's Math.ceil\n    /// @param a Number to round\n    /// @param m Round up to the nearest 'm'\n    /// @return Rounded up 'a'\n    function ceil(uint a, uint m) internal pure returns (uint ) {\n        return ((a + m - 1) / m) * m;\n    }\n\n    /// @notice Calculate atomic number for a given tokenId and token hash\n    /// @dev The reason it needs both is that atomic number is partially based on tokenId.\n    /// @param _tokenId The tokenId of the Atom\n    /// @param _hash Hash of Atom\n    /// @return Atomic number of the given Atom\n    function calculateAtomicNumber(uint _tokenId, bytes32 _hash, uint generation) private pure returns(uint){\n        if(_tokenId == 1) return 0;\n\n        bytes32 divisor = 0x0000000001000000000000000000000000000000000000000000000000000000;\n        uint salt = uint(_hash)/uint(divisor);\n\n        uint max;\n        if(generation >= 13){\n            max = 118;\n        }else if(generation >= 11){\n            max = 86;\n        }else if(generation >= 9){\n            max = 54;\n        }else if(generation >= 7){\n            max = 36;\n        }else if(generation >= 5){\n            max = 18;\n        }else if(generation >= 3){\n            max = 10;\n        }else if(generation >= 1){\n            max = 2;\n        }\n\n        uint gg;\n        if(generation >= 8){\n            gg = 2;\n        }else{\n            gg = 1;\n        }\n\n\n        uint decimal = 10000000000000000;\n        uint divisor2 = uint(0xFFFFFFFFFF);\n\n\n        uint unrounded = max * decimal * (salt ** gg) / (divisor2 ** gg);\n        uint rounded = ceil(\n            unrounded,\n            decimal\n        );\n        return rounded/decimal;\n    }\n    \n}"}}}