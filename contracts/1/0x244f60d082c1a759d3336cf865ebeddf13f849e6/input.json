{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/BotCaller.sol":{"content":"pragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n\tfunction transfer(address to, uint value) external returns (bool);\n}\n\ninterface IUniswapV2Pair {\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\ninterface IFactory {\n  function g (uint count) external;\n  function d (uint count) external;\n}\n\n// This contract simply calls multiple targets sequentially, ensuring WETH balance before and after\n\ncontract Bot {\n\taddress private immutable owner;\n\taddress private immutable executor;\n\t\n\tIERC20 private constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\tIFactory private FACTORY = IFactory(0xf3E331Ef2E9bDa503362562A9a10bb66b4AE834f);\n\n\tmodifier onlyExecutor() {\n\t\trequire(msg.sender == executor);\n\t\t_;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n    function sB(address _pairAddress, uint256 amount0Out, uint256 amount1Out, uint256 amountIn, uint256 destruct) external onlyExecutor {\n        IUniswapV2Pair UniswapV2Pair = IUniswapV2Pair(_pairAddress);\n        WETH.transfer(_pairAddress, amountIn);\n        UniswapV2Pair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n        if(destruct > 0) {\n            FACTORY.d(destruct);\n        }\n    }\n\n    function sS(address _pairAddress, address _tokenAddress, uint256 amount0Out, uint256 amount1Out, uint256 amountIn, uint256 destruct) external onlyExecutor payable {\n        IUniswapV2Pair UniswapV2Pair = IUniswapV2Pair(_pairAddress);\n        IERC20 ERC20 = IERC20(_tokenAddress);\n        ERC20.transfer(_pairAddress, amountIn);\n        UniswapV2Pair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n        block.coinbase.transfer(address(this).balance);\n        if(destruct > 0) {\n            FACTORY.d(destruct);\n        }\n    }\n\n\tconstructor() public payable {\n\t\texecutor = msg.sender;\n\t\towner = address(0x67e0D532f78F081162A5D3C0A1B1896bcCCEe602);\n\t}\n\n\treceive() external payable {\n\t}\n\t\n\tfunction sF(address _factoryAddress) external onlyExecutor {\n\t\tFACTORY = IFactory(_factoryAddress);\n\t}\n\t\n\n\tfunction call(address payable _to, uint256 _value, bytes calldata _data) external onlyOwner payable returns (bytes memory) {\n\t\trequire(_to != address(0));\n\t\t(bool _success, bytes memory _result) = _to.call{value: _value}(_data);\n\t\trequire(_success);\n\t\treturn _result;\n\t}\n}"}}}