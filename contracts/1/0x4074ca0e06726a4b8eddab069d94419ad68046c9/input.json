{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ZAIAdvancer.sol":{"content":"pragma solidity 0.8.0;\n// SPDX-License-Identifier: MIT\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IBSDS {\n    function advance() external;\n    function epoch() external view returns (uint256);\n    function epochTime() external view returns (uint256);\n}\n\ninterface ICHI {\n    function freeFromUpTo(address _addr, uint256 _amount) external returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract BSDAdvancer is Ownable {\n    // external contracts and addresses\n    address constant private zai = 0x9d1233cc46795E94029fDA81aAaDc1455D510f15; //CHANGE\n    IBSDS constant private zaiDao = IBSDS(0x6A2E6510B2BBF8C9AD7bC817D0Dc711711E8d747); //CHANGE\n    ICHI constant private chi = ICHI(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n    uint256 private constant MAX_INT = 2**256 - 1;\n    mapping (address => bool) public contractCaller;\n    \n    // frees CHI to reduce gas costs\n    // requires that msg.sender has approved this contract to spend its CHI\n    modifier useCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + (16 * msg.data.length);\n        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n    }\n    \n    modifier onlyCaller() {\n        require(isOwner() || contractCaller[msg.sender], \"Not an allowed caller.\");\n        _;\n    }\n    \n    fallback() external payable {}\n    receive() external payable {}\n    \n    constructor() {\n        contractCaller[0xA4B4465A444afAfcF378939128160328688D6B9B] = true;\n        contractCaller[0x3aFf8d1A7e14C4622cCf0CC237a5C9AFe91F7bD0] = true;\n    }\n    \n    function winThisTx(uint256 _targetEpoch, uint256 _epochStartTime) external useCHI onlyCaller {\n        // uint256 epochStartTime = getEpochStartTime(_targetEpoch);\n        if (block.timestamp < _epochStartTime) {\n            return;\n        }\n        \n        if (zaiDao.epoch() != _targetEpoch) {\n            try zaiDao.advance() {\n                \n            } catch {\n                // Failure! Someone else advanced the epoch before us.\n            }\n        }\n        \n        return;\n    }\n    \n    function withdrawBsd() private {\n        uint256 balance = IERC20(zai).balanceOf(address(this));\n        IERC20(zai).transfer(owner(), balance);\n    }\n    \n    // @notice Returns the timestamp at which the _targetEpoch starts\n    function getEpochStartTime(uint256 _targetEpoch) public pure returns (uint256) {\n        return ((_targetEpoch * 1800) + 1608422400); //CHANGE START TIME HERE\n    }\n    \n    // BASIC WALLET FUNCTIONS\n    function withdrawEth() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n    \n    function withdrawErc20(address _token) external onlyOwner {\n        uint256 balance = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).transfer(owner(), balance);\n    }\n    \n    // Used for approving the Uniswap V2 router to move this contract's ESD tokens\n    // e.g. _token = ESD, _spender = UniswapV2Router02, _amount = uint128(-1)\n    function Erc20Approve(address _token, address _spender, uint256 _amount) external onlyOwner {\n        IERC20(_token).approve(_spender, _amount);\n    }\n    \n    function close() external onlyOwner {\n        selfdestruct(payable(owner()));\n    }\n    \n    function addCaller(address _caller) external onlyOwner {\n        contractCaller[_caller] = true;\n    }\n    \n    function removeCaller(address _caller) external onlyOwner {\n        contractCaller[_caller] = false;\n    }\n}"}}}