{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":2000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"bzz_buy.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n//pragma solidity ^0.7.0;\n\n//pragma solidity 0.5.12;\n\n\npragma solidity ^0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface Curve {\n    function mint(\n        uint256 _amount, \n        uint256 _maxCollateralSpend\n    ) external returns (bool);\n\n    function mintTo(\n        uint256 _amount, \n        uint256 _maxCollateralSpend, \n        address _to\n    ) external returns (bool);\n\n    function redeem(uint256 _amount, uint256 _minCollateralReward) external returns (bool success);\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n}\n\ninterface IBFactory {\n    function isBPool(address b) external view returns (bool);\n}\n\n\ninterface IRouter {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\ncontract Owned {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can do this\");\n        _;\n    }\n\n    function kill()\n        public\n        onlyOwner\n    {\n        selfdestruct(msg.sender);\n    }\n}\n\n\ncontract Whitelist is Owned {\n    mapping(address => bool) public whitelist;\n\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender], \"Not whitelisted\");\n        _;\n    }\n\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            success = true; \n        }\n    }\n\n    function addAddressesToWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n}\n\ncontract Arbitrage is Whitelist {\n\n    Curve curve;\n    address public dai;\n    address public bzz;\n    //uint deadline = ;\n    \n    constructor(address _dai, address _bzz) public {\n        addAddressToWhitelist(owner);\n        // addAddressToWhitelist(0xb739890dfc44Dd78D81E03c792330f71B1E3307c);\n        // addAddressToWhitelist(0xf53c21F6c76b16ED5916acef622E71081cf95Ada);\n        // addAddressToWhitelist(0xa7430fde48b555c12f58D696d7d92De0B400f1f7);\n        // addAddressToWhitelist(0xbc268ff42ffA5fecA8a0Ebd21D82D16c31D1883e);\n        // addAddressToWhitelist(0xDf7Caa72fE732C096017b14095387EF1485bCE9E);\n        // addAddressToWhitelist(0xAAa24a5ac1Ed1DbeCeA6DF1CFE78B969703d67E9);\n        // addAddressToWhitelist(0x7f843fa9c015bB77D38962265d697fCA0B2baFd2);\n        // addAddressToWhitelist(0xD5fF161f1713f49255E5f9F0FBFf391A8dEb4522);\n        // addAddressToWhitelist(0x8d93c4C82A40997654D62b4D4E83E688BD165502);\n        curve = Curve(0x4F32Ab778e85C4aD0CEad54f8f82F5Ee74d46904);\n        dai = _dai;\n        bzz = _bzz;\n    }\n\n    \n    function buyBZZ(uint256 _amount, uint256 _maxCollateralSpend) public onlyWhitelisted\n    {\n        TransferHelper.safeApprove(dai, address(curve), _maxCollateralSpend);\n        curve.mint(_amount, _maxCollateralSpend);\n    }\n\n    function sellBZZ(uint256 _amount, uint256 _minCollateralReward) public onlyWhitelisted\n    {\n        TransferHelper.safeApprove(bzz, address(curve), _amount);\n        curve.redeem(_amount, _minCollateralReward);\n    }\n\n    // function arbitrageUniCurve(uint _amount, uint profit, address[] memory path)\n    //     public\n    //     virtual\n    //     returns (uint[] memory amounts)\n    // {\n    //     initialBalanceDai = dai.balanceOf(address(this));\n    //     amounts = uniswapRouterV2.getAmountsIn(_amount, path);\n    //     require(sellReward(_amount) > amounts[0] + profit*10**18, \"!arb\");\n\n    //     TransferHelper.safeApprove(dai, uniswapRouterV2, amounts[0]);\n    //     amounts = uniswapRouterV2.swapTokensForExactTokens(_amount, initialBalanceDai, path, address(this), deadline);\n    //     TransferHelper.safeApprove(bzz, curve, amounts[amounts.length - 1]);\n    //     sellBZZ(amounts[1], amounts[0]);\n    //     require(dai.balanceOf(address(this)) > initialBalanceDai + profit*10**18, \"!arb\");\n    // }\n\n    // function arbitrageCurveUni(uint _amount, uint profit, address[] memory path)\n    //     public\n    //     virtual\n    //     returns (uint[] memory amounts)\n    // {\n    //     initialBalanceDai = dai.balanceOf(address(this));\n    //     initialBalanceBZZ = bzz.balanceOf(address(this));\n\n    //     amounts = uniswapRouterV2.getAmountsOut(_amount, path);\n    //     require(amounts[1] + profit*10**18 > buyPrice(_amount), \"!arb\");\n\n    //     TransferHelper.safeApprove(dai, curve, amounts[0]);\n    //     buyBZZ(_amount, 1);\n    //     boughtBZZ = bzz.balanceOf(address(this)) - initialBalanceBZZ;\n    //     TransferHelper.safeApprove(bzz, uniswapRouterV2, -1);\n    //     amounts = uniswapRouterV2.swapExactTokensForTokens(boughtBZZ, 1, path, owner, deadline);\n    //     require(dai.balanceOf(address(this)) > initialBalanceDai + profit*10**18, \"!arb\");\n    // }\n\n    function withdrawEther() external onlyOwner {\n        payable(address(owner)).transfer(address(this).balance);\n    }\n    \n    function withdrawTokens(address token) public onlyOwner {\n        uint balance = TokenInterface(token).balanceOf(address(this));\n        TransferHelper.safeTransfer(token, owner, balance);\n    }\n\n    fallback () external {}\n\n}"}}}