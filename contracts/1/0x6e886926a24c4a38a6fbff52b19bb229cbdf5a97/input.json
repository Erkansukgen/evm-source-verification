{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ReserveTokenVesting.sol":{"content":"pragma solidity 0.4.24;\r\n\r\ncontract ERC20TokenInterface {\r\n\r\n    function totalSupply () external constant returns (uint);\r\n    function balanceOf (address tokenOwner) external constant returns (uint balance);\r\n    function transfer (address to, uint tokens) external returns (bool success);\r\n    function transferFrom (address from, address to, uint tokens) external returns (bool success);\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n    \r\n    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract ChaliceVesting {\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n    ERC20TokenInterface public chaliceToken;\r\n\r\n    address public withdrawAddress;\r\n\r\n\r\n    struct VestingStage {\r\n        uint256 date;\r\n        uint256 tokensUnlockedPercentage;\r\n    }\r\n\r\n\r\n    VestingStage[10] public stages;\r\n\r\n\r\n    uint256 public vestingStartTimestamp = 1607385600; //12-08-2020 \r\n\r\n    /**\r\n     * Total amount of tokens sent.\r\n     */\r\n    uint256 public initialTokensBalance;\r\n\r\n    /**\r\n     * Amount of tokens already sent.\r\n     */\r\n    uint256 public tokensSent;\r\n\r\n    /**\r\n     * Event raised on each successful withdraw.\r\n     */\r\n    event Withdraw(uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * Could be called only from withdraw address.\r\n     */\r\n    modifier onlyWithdrawAddress () {\r\n        require(msg.sender == withdrawAddress);\r\n        _;\r\n    }\r\n\r\n\r\n    constructor (ERC20TokenInterface token, address withdraw) public {\r\n        chaliceToken = token;\r\n        withdrawAddress = withdraw;\r\n        initVestingStages();\r\n    }\r\n    \r\n\r\n    function () external {\r\n        withdrawTokens();\r\n    }\r\n\r\n\r\n    function getAvailableTokensToWithdraw () public view returns (uint256 tokensToSend) {\r\n        uint256 tokensUnlockedPercentage = getTokensUnlockedPercentage();\r\n        // In the case of stuck tokens we allow the withdrawal of them all after vesting period ends.\r\n        if (tokensUnlockedPercentage >= 100) {\r\n            tokensToSend = chaliceToken.balanceOf(this);\r\n        } else {\r\n            tokensToSend = getTokensAmountAllowedToWithdraw(tokensUnlockedPercentage);\r\n        }\r\n    }\r\n\r\n\r\n    function getStageAttributes (uint8 index) public view returns (uint256 date, uint256 tokensUnlockedPercentage) {\r\n        return (stages[index].date, stages[index].tokensUnlockedPercentage);\r\n    }\r\n\r\n    function initVestingStages () internal {\r\n        \r\n        uint256 month = 30 days;\r\n        stages[0].date = vestingStartTimestamp + month;\r\n\r\n        stages[0].tokensUnlockedPercentage = 10;\r\n        stages[1].tokensUnlockedPercentage = 20;\r\n        stages[2].tokensUnlockedPercentage = 30;\r\n        stages[3].tokensUnlockedPercentage = 40;\r\n        stages[4].tokensUnlockedPercentage = 50;\r\n        stages[5].tokensUnlockedPercentage = 60;\r\n        stages[6].tokensUnlockedPercentage = 70;\r\n        stages[7].tokensUnlockedPercentage = 80;\r\n        stages[8].tokensUnlockedPercentage = 90;\r\n        stages[9].tokensUnlockedPercentage = 100;\r\n\r\n    }\r\n\r\n    /**\r\n     * Main method for withdraw tokens from vesting.\r\n     */\r\n    function withdrawTokens () onlyWithdrawAddress private {\r\n        // Setting initial tokens balance on a first withdraw.\r\n        if (initialTokensBalance == 0) {\r\n            setInitialTokensBalance();\r\n        }\r\n        uint256 tokensToSend = getAvailableTokensToWithdraw();\r\n        sendTokens(tokensToSend);\r\n    }\r\n\r\n    /**\r\n     * Set initial tokens balance when making the first withdrawal.\r\n     */\r\n    function setInitialTokensBalance () private {\r\n        initialTokensBalance = chaliceToken.balanceOf(this);\r\n    }\r\n\r\n    /**\r\n     * Send tokens to withdrawAddress.\r\n     * \r\n     * @param tokensToSend Amount of tokens will be sent.\r\n     */\r\n    function sendTokens (uint256 tokensToSend) private {\r\n        if (tokensToSend > 0) {\r\n            // Updating tokens sent counter\r\n            tokensSent = tokensSent.add(tokensToSend);\r\n            // Sending allowed tokens amount\r\n            chaliceToken.transfer(withdrawAddress, tokensToSend);\r\n            // Raising event\r\n            emit Withdraw(tokensToSend, now);\r\n        }\r\n    }\r\n\r\n\r\n    function getTokensAmountAllowedToWithdraw (uint256 tokensUnlockedPercentage) private view returns (uint256) {\r\n        uint256 totalTokensAllowedToWithdraw = initialTokensBalance.mul(tokensUnlockedPercentage).div(100);\r\n        uint256 unsentTokensAmount = totalTokensAllowedToWithdraw.sub(tokensSent);\r\n        return unsentTokensAmount;\r\n    }\r\n\r\n    /**\r\n     * Get tokens unlocked percentage on current stage.\r\n     * \r\n     * @return Percent of tokens allowed to be sent.\r\n     */\r\n    function getTokensUnlockedPercentage () private view returns (uint256) {\r\n        uint256 allowedPercent;\r\n        \r\n        for (uint8 i = 0; i < stages.length; i++) {\r\n            if (now >= stages[i].date) {\r\n                allowedPercent = stages[i].tokensUnlockedPercentage;\r\n            }\r\n        }\r\n        \r\n        return allowedPercent;\r\n    }\r\n}\r\n\r\ncontract ReserveTokenVesting is ChaliceVesting {\r\n    constructor(ERC20TokenInterface token, address withdraw) ChaliceVesting(token, withdraw) public {}\r\n}"}}}