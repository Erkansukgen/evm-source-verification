{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/OVRLand64.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract liteMinting {\n    \n    address OVRLandContract=0x56B80bBEE68932A8D739315c79BC7b125341098A;\n    address private _owner;\n    \n    event Transfer(address indexed from, address indexed to, uint48 indexed tokenId);\n    \n    mapping(uint48 => address) public tokenOwner;\n        \n        \n    constructor () public {\n        _owner=msg.sender;\n    }\n    \n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function _exists(uint48 tokenId) internal view returns (bool) {\n        return tokenOwner[tokenId] != address(0);\n    }\n    \n    function ownerOf(uint48 tokenId) public view returns (address) {\n        require(tokenOwner[tokenId] != address(0), \"ERC721: owner query for nonexistent token\");\n        return tokenOwner[tokenId];\n    }\n    \n\n    function transfer(address to, uint48 tokenId) public {\n        require(ownerOf(tokenId) == msg.sender, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        tokenOwner[tokenId] = to;\n        emit Transfer(msg.sender, to, tokenId);\n    }   \n    \n    function mint(address to,uint48 tokenId) public onlyOwner {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n        tokenOwner[tokenId]=to;\n        emit Transfer(address(0),to,tokenId);\n    }\n    \n    function uint2hexstr(uint i) internal pure returns (string memory _uintAsString) {\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint length;\n        while (j != 0) {\n            length++;\n            j = j >> 4;\n        }\n        uint mask = 15;\n        bytes memory bstr = new bytes(length);\n        uint k = length - 1;\n        while (i != 0){\n            uint curr = (i & mask);\n           bstr[k--] = curr > 9 ? byte(uint8(55 + curr)) : byte(uint8(48 + curr)); // 55 = 65 - 10\n           i = i >> 4;\n        }\n        return string(bstr);\n    }\n    \n    function claim(uint48 tokenId) public {\n        require(ownerOf(tokenId) == msg.sender, \"Claim of token that is not own\");\n        uint256 tokenId256=0x8C000000000000F+(uint256(tokenId)<<4);\n        (bool successMint, ) = OVRLandContract.call(abi.encodeWithSignature(\"mintLand(address,uint256)\", msg.sender, tokenId256));\n        require(successMint);\n        bytes memory uriB;\n        uriB=abi.encodePacked(\"https://l.ovr.ai/\");\n        uriB=abi.encodePacked(uriB,uint2hexstr(tokenId256));\n        OVRLandContract.call(abi.encodeWithSignature(\"setOVRLandURI(uint256,string)\", tokenId256, string(uriB)));\n        tokenOwner[tokenId]=address(0);\n    }\n    \n\n}"}}}