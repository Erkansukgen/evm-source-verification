{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/NewContract.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-06-04\n*/\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n\n// SPDX-License-Identifier: MIT\n// SPDX-License-Identifier: Something Else\n\npragma solidity ^0.8.0;\n\n\ninterface IERC165 {\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol\n\n\n\npragma solidity ^0.8.0;\n\n\n\ninterface IERC1155 is IERC165 {\n    \n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    \n    event URI(string value, uint256 indexed id);\n\n    \n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function balanceOfEditions(address account, uint256 id) external view returns (uint256[] memory);\n    function balanceOfItems(address account, uint256 id) external view returns (uint256[] memory);\n\n    \n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    \n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n    function safeTransferFromWithEditions(address from, address to, uint256 id, uint256 amount, uint256[] memory edition_ids, uint256[] memory item_ids, bytes calldata data) external;\n    \n    \n}\n\n// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\n\n\n\npragma solidity ^0.8.0;\n\n\ninterface IERC1155Receiver is IERC165 {\n\n   \n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n   \n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n\n// File: @openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\n\n\n\npragma solidity ^0.8.0;\n\n\ninterface IERC1155MetadataURI is IERC1155 {\n    \n    function uri(uint256 id) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n\n\npragma solidity ^0.8.0;\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n\n\n\npragma solidity ^0.8.0;\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    \n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n\n\n\npragma solidity ^0.8.0;\n\n\nabstract contract ERC165 is IERC165 {\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\npragma solidity ^0.8.0;\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI,Ownable {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n    \n    mapping (uint256 => mapping(address => mapping(uint256=>uint256))) private _editionCheck;\n    mapping (uint256 => mapping(address => uint256[])) private _editionBalances;\n    mapping (uint256 => mapping(address => uint256[])) private _editionitemsBalances;\n    \n    \n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n\n    constructor () {\n        \n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155).interfaceId\n            || interfaceId == type(IERC1155MetadataURI).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    \n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    \n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n    function balanceOfEditions(address account, uint256 id) public view virtual override returns (uint256[] memory) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _editionBalances[id][account];\n    }\n    function balanceOfItems(address account, uint256 id) public view virtual override returns (uint256[] memory) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _editionitemsBalances[id][account];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    \n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function safeTransferFromWithEditions(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        uint256[] memory edition_ids,\n        uint256[] memory item_ids,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n        \n        for(uint i = 0; i < edition_ids.length; i++){\n\t      require(_editionCheck[id][to][edition_ids[i]]<1,\"EditionID of TokenID already in adress exists\");\n          _editionCheck[id][to][edition_ids[i]] = 1;\n          \n                if (_editionCheck[id][from][edition_ids[i]]==1) {\n                    _editionCheck[id][from][edition_ids[i]] = 0;\n                        // delete editions from owner\n                        for(uint j = 0; j < _editionBalances[id][from].length; j++){\n                            if (_editionBalances[id][from][j] == edition_ids[i]) {\n                                delete _editionBalances[id][from][j];\n                                delete _editionitemsBalances[id][from][j];\n                            }\n                        }\n                  }  \n          \n          _editionBalances[id][to].push(edition_ids[i]); \n          _editionitemsBalances[id][to].push(item_ids[i]);\n\t\t  \n      }\n        \n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    \n\n    \n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        _balances[id][account] = accountBalance - amount;\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    \n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n// File: contracts/GameItems.sol\n\n// contracts/GameItems.sol\n\npragma solidity ^0.8.0;\n\n// import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract HappyHipposInfinity8 is ERC1155 {\n    \n\tusing Counters for Counters.Counter;\n  \tCounters.Counter private _tokenIds;\n    uint256[] private _lastGeneratedToken;\n    mapping(uint256=>bool) private tokenCheck;\n    mapping(uint256=>string) private tokenHash;\n    mapping(uint256=>string) private tokenName;\n    \n    \n    constructor() {\n        \n    }\n\n\n\n\tfunction TokenMint(address account,uint256 newItemId, uint256 amount, string memory metadata, string memory name)\n\t  public onlyOwner\n\t  returns (uint256){   \n\t      require(!tokenCheck[newItemId],\"TokenID already exists\");\n\t\t_mint(account,newItemId,amount,'');\n\t\ttokenCheck[newItemId] = true;\n\t\ttokenHash[newItemId] = metadata;\n\t\ttokenName[newItemId] = name;\n\t\tdelete _lastGeneratedToken;\n        _lastGeneratedToken.push(newItemId);\n\t\treturn newItemId;\n    }\n    \n    function getTokenName(uint256 newItemId) public view returns(string memory){\n\t\treturn tokenName[newItemId];\n    }\n    function getTokenMetadataHash(uint256 newItemId) public view returns(string memory){\n\t\treturn tokenHash[newItemId];\n    }\n    \n    function TokenBurn(address account,uint256 id, uint256 amount) public onlyOwner returns (bool){   \n\t\t_burn(account,id,amount);\n\t\treturn true;\n    }\n\n    function lastGeneratedToken() public view returns (uint256[] memory){\n        return _lastGeneratedToken;\n    }\n}\n\n\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n\nlibrary SafeMath {\n    \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n       \n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n   \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}"}}}