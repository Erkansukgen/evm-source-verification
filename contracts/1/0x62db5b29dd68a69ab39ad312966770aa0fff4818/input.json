{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 15000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Owner.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Owner\n * @dev Set & change owner\n */\ncontract Owner {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}"
    },
    "contracts/XorEncrypt.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary XorEncrypt {\n    \n    function xorEncrypt (bytes memory data, bytes memory key) internal pure returns (bytes memory result) {\n      // Store data length on stack for later use\n      uint256 length = data.length;\n    \n      assembly {\n        // Set result to free memory pointer\n        result := mload (0x40)\n        // Increase free memory pointer by lenght + 32\n        mstore (0x40, add (add (result, length), 32))\n        // Set result length\n        mstore (result, length)\n      }\n    \n      // Iterate over the data stepping by 32 bytes\n      for (uint i = 0; i < length; i += 32) {\n        // Generate hash of the key and offset\n        bytes32 hash = keccak256 (abi.encodePacked (key, i));\n    \n        bytes32 chunk;\n        assembly {\n          // Read 32-bytes data chunk\n          chunk := mload (add (data, add (i, 32)))\n        }\n        // XOR the chunk with hash\n        chunk ^= hash;\n        assembly {\n          // Write 32-byte encrypted chunk\n          mstore (add (result, add (i, 32)), chunk)\n        }\n      }\n    }\n}"
    },
    "contracts/XorProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./XorEncrypt.sol\";\nimport \"./Owner.sol\";\n\ncontract XorProxy is Owner {\n\n    function encrypt(uint256 rand, bytes memory data) public view returns (bytes memory) {\n        return XorEncrypt.xorEncrypt(data, abi.encodePacked(msg.sender, rand));\n    }\n\n    function delegateEncoded(address to, uint256 rand, bytes memory data) isOwner public payable {\n        return delegate(to, encrypt(rand, data));\n    }\n    \n    function delegate(address to, bytes memory data) isOwner public payable {\n        (bool success, bytes memory result) = to.call{value: msg.value}(data);\n\n        if (!success) {\n            revert(string(result));\n        }\n    }\n}"
    }
  }
}