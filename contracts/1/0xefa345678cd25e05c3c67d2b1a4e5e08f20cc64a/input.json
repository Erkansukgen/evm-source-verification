{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/convex.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2 {\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function factory() external view returns (address);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract ConvexDumper is Ownable {\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    struct ClaimCall {\r\n        address target;\r\n        bytes data;\r\n    }\r\n    \r\n    ClaimCall[] public _claimCalls;\r\n    address[] public _tokens;\r\n    address public _router;\r\n    address public _output;\r\n    address public _factory;\r\n    address public _master;\r\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    \r\n    constructor(address router, address output, address master) {\r\n        _router = router;\r\n        _output = output;\r\n        _master = master;\r\n        _factory = IUniswapV2(_router).factory();\r\n    }\r\n    \r\n    function changeRouter(address router) onlyOwner external {\r\n        _router = router;\r\n        _factory = IUniswapV2(_router).factory();\r\n        \r\n        for(uint256 i=0;i<_tokens.length;i++) {\r\n            IERC20(_tokens[i]).safeApprove(_router, 2**256 - 1);\r\n        }\r\n    }\r\n    \r\n    function changeOutput(address output) onlyOwner external {\r\n        _output = output;\r\n    }\r\n    \r\n    function changeMaster(address master) onlyOwner external {\r\n        _master = master;\r\n    }\r\n    \r\n    function addClaimCall(address target, bytes calldata data) onlyOwner external {\r\n        _claimCalls.push(ClaimCall(target, data));\r\n    }\r\n    \r\n    function removeClaimCall(uint256 index) onlyOwner external {\r\n        delete _tokens[index];\r\n    }\r\n    \r\n    function claim() onlyOwner external {\r\n        _claim();\r\n    }\r\n    \r\n    function addToken(address token) onlyOwner external returns(bool) {\r\n        for(uint256 i=0;i<_tokens.length;i++) {\r\n            if(_tokens[i] == token) {\r\n                return false;\r\n            }\r\n        }\r\n        IERC20(token).safeApprove(_router, 2**256 - 1);\r\n        _tokens.push(token);\r\n        return true;\r\n    }\r\n    \r\n    function removeToken(address token) onlyOwner external returns(bool) {\r\n        for(uint256 i=0;i<_tokens.length;i++) {\r\n            if(_tokens[i] == token) {\r\n                delete _tokens[i];\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function rescue(address token) onlyOwner external {\r\n        if(token == address(0)) {\r\n            owner().call{value: address(this).balance}(\"\");\r\n        } else {\r\n            IERC20(token).safeTransfer(owner(), IERC20(token).balanceOf(address(this)));\r\n        }\r\n    }\r\n    \r\n    function sell(bool antiFR, bool doClaim) onlyOwner external {\r\n        _process(antiFR, doClaim);\r\n    }\r\n    \r\n    function sell() external {\r\n        _process(true, true);\r\n    }\r\n    \r\n    function _process(bool antiFR, bool doClaim) internal {\r\n        if(antiFR) {\r\n            for(uint256 i=0;i<_tokens.length;i++) {\r\n                (,,uint32 blockTimestampLast) = IUniswapV2(pairFor(_tokens[i], WETH)).getReserves();\r\n                require(blockTimestampLast != block.timestamp, 'someone frontrun us!');\r\n            }\r\n        }\r\n        \r\n        if(doClaim) {\r\n            _claim();\r\n        }\r\n        \r\n        for(uint256 i=0;i<_tokens.length;i++) {\r\n            uint256 balance = IERC20(_tokens[i]).balanceOf(_master);\r\n            if(balance == 0) {\r\n                continue;\r\n            }\r\n            _swap(_master, _tokens[i], WETH, address(this), balance);\r\n        }\r\n        \r\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\r\n        if(wethBalance > 0) {\r\n            if(_output != WETH) {\r\n                _swap(address(this), WETH, _output, owner(), wethBalance);\r\n            } else {\r\n                IERC20(WETH).safeTransfer(owner(), wethBalance);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function _swap(address source, address tokenFrom, address tokenTo, address target, uint256 balance) internal {\r\n        address pair = pairFor(tokenFrom, tokenTo);\r\n        IERC20(tokenFrom).transferFrom(source, pair, balance);\r\n\r\n        uint256 amountOut = getAmountOut(balance, tokenFrom, tokenTo);\r\n        (address token0,) = sortTokens(tokenFrom, tokenTo);\r\n        \r\n        if(tokenFrom == token0) {\r\n            IUniswapV2(pair).swap(0, amountOut, target, new bytes(0));\r\n        } else {\r\n            IUniswapV2(pair).swap(amountOut, 0, target, new bytes(0));\r\n        }\r\n    }\r\n    \r\n    function _claim() internal {\r\n        for(uint256 i=0;i<_claimCalls.length;i++) {\r\n            _claimCalls[i].target.call(_claimCalls[i].data);\r\n        }    \r\n    }\r\n    \r\n    //uniswap stuff\r\n    function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = IUniswapV2(_factory).getPair(token0, token1);\r\n    }\r\n    \r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n    \r\n    function getAmountOut(uint amountIn, address from, address to) internal view returns (uint256 amounts) {\r\n        (uint reserveIn, uint reserveOut) = getReserves(from, to);\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amounts = numerator / denominator;\r\n    }\r\n    \r\n    function getReserves(address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2(pairFor(tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n}\r\n"
    }
  }
}