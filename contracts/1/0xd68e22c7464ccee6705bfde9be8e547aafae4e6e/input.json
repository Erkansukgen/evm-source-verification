{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/contracts/TrustTrade.sol": {
      "content": "//pragma solidity >=0.4.21 <0.7.0;\npragma solidity 0.7.0;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return _div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return _sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return _mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n\n    function _mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n//The main block of the contract starts here\ncontract TrustTrade {\n    //###########################GLOBAL VARIABLES##########################\n    uint16 public planId;\n    uint256 public referrerId;\n    // The total number of customers have insvested in our bank\n    uint256 totalCustomers;\n    // The total amount of investment in our bank\n    uint256 totalInvestmentAmount;\n    // The total amount of withdrawal from our bank\n    uint256 totalWithdrawAmount;\n    // The total amount of payments to our referrals\n    uint256 totalReferalPayments;\n    //###########################GLOBAL VARIABLES##########################\n\n\n    //###########################PREDEFINED ADDRESSES##########################\n    address public contractOwner;\n    address public bankOwner;\n    //#####################################################################\n\n    //#############################STRUCTS######################################\n    // struct for storing plan information\n    struct Plan {\n        uint256 period;\n        uint256 interest;\n    }\n\n    // struct for storing investment information\n    struct Invest {\n        uint16 plan_id;\n        uint256 amount;\n        uint256 investTime;\n    }\n\n    // struct for customers information\n    struct Customer {\n        bool isInvested;\n        uint256 lastWidthdrawal;\n        uint256 totalWidtdraw;\n        uint256 investCount;\n        uint256 numReferral;\n        uint256 totalRefPayment;\n        uint256 userReferrerId;\n    }\n    //#########################################################################\n\n    //#############################MAPPINGS#####################################\n    mapping(address => Customer) public customers;\n    mapping(address => Invest) public customers_invests;\n    mapping(uint16 => Plan) public plans;\n    mapping(uint256 => uint256) public PLAN_PRICE;\n    mapping(uint256 => uint256) public REFERRER_PROFIT;\n    mapping(uint256 => address) referral_holder;\n    //############################################################################\n\n    //###################################EVENTS##################################\n    event ReferralPayment(\n        address indexed _referrer,\n        uint256 refProfit,\n        uint256 _refPaymentDate\n    );\n\n    event AdminDeposit(\n        uint256 _value,\n        address _bankOwner,\n        uint256 _depositDate\n    );\n    \n    event NewInvestment(\n        address indexed addr,\n        uint16 plan_id,\n        uint256 _value,\n        uint256 _investDate\n    );\n    \n    event NewCustomerWidthdraw(\n        address indexed addr,\n        uint256 profit,\n        uint256 _customerWithdrawDate\n    );\n    \n    event NewAdminWidtdraw(\n        address indexed AdminAddr,\n        uint256 value,\n        uint256 _ownerWithdrawDate\n    );\n    \n    event CalledForUserInfo(\n        address indexed userAddr,\n        bool isReg,\n        uint256 _askInfoDate\n    );\n    //###########################################################################\n\n    constructor() {\n        contractOwner = msg.sender;\n        bankOwner = 0xdcBC9ae4dBF722148a3553fd85E72a7eb67c928F;\n\n        PLAN_PRICE[0] = 0.5 ether;\n        PLAN_PRICE[1] = 0.2 ether;\n        PLAN_PRICE[2] = 0.15 ether;\n        PLAN_PRICE[3] = 0.1 ether;\n        PLAN_PRICE[4] = 0.08 ether;\n\n        // referrer interest\n        REFERRER_PROFIT[1100] = 10;\n        REFERRER_PROFIT[1101] = 10;\n        REFERRER_PROFIT[1102] = 8;\n        REFERRER_PROFIT[1103] = 6;\n        REFERRER_PROFIT[1104] = 5;\n        \n        plans[1100] = Plan(7, 30);\n        plans[1101] = Plan(7, 25);\n        plans[1102] = Plan(15, 40);\n        plans[1103] = Plan(30, 60);\n        plans[1104] = Plan(30, 50);\n\n        referrerId = 2020;\n        totalCustomers = 0;\n        totalInvestmentAmount = 0;\n        totalWithdrawAmount = 0;\n        totalReferalPayments = 0;\n    }\n\n    ////////////////////MODIFIERS/////////////////////\n\n    fallback() external payable {\n        if (msg.sender == bankOwner) {\n            emit AdminDeposit(msg.value, bankOwner, block.timestamp);\n        } else {\n            address _referrer = bytesToAddress(msg.data);\n            _init(msg.sender, msg.value, _referrer);\n        }\n    }\n\n    function _init (\n        address payable _investor,\n        uint256 _investValue,\n        address _referrer\n    ) private {\n        bool doInvest = true;\n        if (_investValue >= PLAN_PRICE[0]) {\n            planId = 1100;\n        } else if (_investValue == PLAN_PRICE[1]) {\n            planId = 1101;\n        } else if (_investValue == PLAN_PRICE[2]) {\n            planId = 1102;\n        } else if (_investValue == PLAN_PRICE[3]) {\n            planId = 1103;\n        } else if (_investValue == PLAN_PRICE[4]) {\n            planId = 1104;\n        } else {\n            doInvest = false;\n        }\n\n        if (doInvest == true) {\n            invest(_investValue, _investor, planId, _referrer);\n        } else {\n            revert(\"Incorrect value sent!\");\n        }\n    }\n\n\n    function getContBalance() public view returns (uint256) \n    {\n        return \n        (\n        address(this).balance\n        );\n    }\n\n    //very critical function. Consider revising\n    function ownerWidthdraw(uint256 amount) external payable {\n        require(msg.sender == bankOwner);\n        require(\n            amount < this.getContBalance(),\n            \"The amount of dividend to be paid is larger than the contract's balance!\"\n        );\n        //msg.sender.transfer(amount);\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Owner's payment was not successful!\");\n        emit NewAdminWidtdraw(msg.sender, amount, block.timestamp);\n    }\n\n    function calculateDividents(address _userAddr)\n        private\n        view\n        returns (uint256)\n    {\n        \n        uint256 num = SafeMath.mul(\n        plans[customers_invests[_userAddr].plan_id].interest,\n        customers_invests[_userAddr].amount);\n      \n        return SafeMath.div(num, 1000);\n    }\n\n\n    function calculateClaim(\n        address _userAddr\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256, \n            uint256\n        )\n    {\n        //newStart\n        uint256 newStart = SafeMath.div(customers[_userAddr].lastWidthdrawal, SafeMath.mul(24, 3600));\n        //now\n        uint256 current_time = SafeMath.div(block.timestamp, SafeMath.mul(24, 3600));\n\n        // _mod \n        uint256 _mod = SafeMath.mod(SafeMath.sub(current_time, newStart),\n            plans[customers_invests[_userAddr].plan_id].period\n        );\n\n        //_profit    \n        uint256 _profit = SafeMath.div(SafeMath.sub(current_time, newStart), plans[customers_invests[_userAddr].plan_id].period);\n\n        newStart = block.timestamp;\n\n        //res\n        uint256 res = calculateDividents(_userAddr);\n\n        uint256 amount_paid = SafeMath.mul(_profit, res);\n\n        return (amount_paid, newStart, _mod);\n    }\n\n    function _widthDraw(\n        address payable _userAddr\n    ) private {\n        (uint256 _amount, uint256 newStart, uint256 mod) = calculateClaim(_userAddr);\n\n        uint256 contractBalance = this.getContBalance();\n       \n        require(\n            _amount < contractBalance,\n            \"The amount of dividend to be paid is larger than the contract's balance!\"\n        );\n        if (_amount > 0) {\n            (bool success, ) = _userAddr.call{value: _amount}(\"\");\n            require(success == true, \"Customer withdrawal failed!\");\n            customers[_userAddr].totalWidtdraw = SafeMath.add(customers[_userAddr].totalWidtdraw, _amount);\n            customers[_userAddr].lastWidthdrawal = SafeMath.sub(newStart, SafeMath.mul(mod, 86400));\n\n            totalWithdrawAmount = SafeMath.add(totalWithdrawAmount, _amount);\n\n            emit NewCustomerWidthdraw(\n                msg.sender,\n                _amount,\n                block.timestamp\n            );\n        }\n        \n    }\n\n    function widthdraw()\n        external\n        payable\n    {\n        require(\n            customers[msg.sender].isInvested == true,\n            \"You cannot widthdraw because you haven't invested!\"\n        );\n        require(\n            address(this).balance > 0,\n            \"We do not have enough balance for payment at the moment. Please try later!\"\n        );\n        _widthDraw(msg.sender);\n    }\n\n    function _invest(\n        address payable _userAddr,\n        uint16 _pid,\n        uint256 _value,\n        address _referrer\n    ) private returns (bool) {\n        referral_holder[referrerId] = _userAddr;\n        customers[_userAddr].isInvested = true;\n        customers[_userAddr].investCount = SafeMath.add(\n            customers[_userAddr].investCount,\n            1\n        );\n        require(\n            customers[_userAddr].investCount == 1,\n            \"You are not allow to have more than one investment!\"\n        );\n        require(_value > 0, \"Please specify a value of your investment!\");\n        customers_invests[_userAddr] = Invest({\n            plan_id: _pid,\n            amount: _value,\n            investTime: block.timestamp\n        });\n        customers[_userAddr].lastWidthdrawal = block.timestamp;\n\n        totalCustomers = SafeMath.add(totalCustomers, 1);\n        totalInvestmentAmount = SafeMath.add(totalInvestmentAmount, _value);\n\n        require(\n            _referrer != _userAddr,\n            \"The referrer can not be the investor itself.\"\n        );\n        require(\n            _referrer != contractOwner,\n            \"The referrer can not be the contract owner.\"\n        );\n        require(\n            _referrer != bankOwner,\n            \"The referrer can not be the bank owner.\"\n        );\n        _payReferrer(_referrer, _value);\n        customers[_userAddr].userReferrerId = referrerId;\n        referrerId = SafeMath.add(referrerId, 5);\n        return true;\n    }\n\n    function invest(\n        uint256 _value,\n        address payable _userAddr,\n        uint16 _pid,\n        address _referrer\n    ) private {\n        if (_invest(_userAddr, _pid, _value, _referrer)) {\n            emit NewInvestment(_userAddr, _pid, _value, block.timestamp);\n        }\n    }\n\n    function getCustomerInfo(address _userAddr)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n  \n        return (\n            customers[_userAddr].totalWidtdraw,\n            customers[_userAddr].lastWidthdrawal,\n            customers_invests[_userAddr].investTime,\n            customers[_userAddr].numReferral,\n            customers[_userAddr].totalRefPayment,\n            customers[_userAddr].userReferrerId\n        );\n    }\n    \n    function getPlanInfo(address _userAddr) public view returns (uint16, uint256)\n    {\n    \treturn (customers_invests[_userAddr].plan_id, customers_invests[_userAddr].amount);\n    }\n\n    function checkIfReferrerExist(uint32 _referrerCode)\n        public\n        view\n        returns (address)\n    {\n        return referral_holder[_referrerCode];\n    }\n\t\n    \n    function getUserRegistrationStatus(address _userAddr)\n        public\n        view\n        returns (bool)\n    {\n        return customers[_userAddr].isInvested;\n    }\n\n    function statistics() public view returns (uint256, uint256, uint256, uint256)\n    {\n        return (totalCustomers, totalInvestmentAmount, totalWithdrawAmount, totalReferalPayments);\n    }\n\n    function bytesToAddress(bytes memory bys)\n        private\n        pure\n        returns (address addr)\n    {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n\n    function _payReferrer(address _referrer, uint256 _value) private {\n\n        if (customers[_referrer].isInvested) {\n            \n            uint256 refProfit = SafeMath.div(SafeMath.mul(REFERRER_PROFIT[customers_invests[_referrer].plan_id],_value), 100);\n        \n            address payable add3 = address(uint160(_referrer));\n            (bool refSuccess, ) = add3.call{value: refProfit}(\"\");\n            require(refSuccess, \"Referral payment was not successfull!\");\n            //add3.transfer(refProfit);\n            customers[_referrer].numReferral = SafeMath.add(\n                customers[_referrer].numReferral,\n                1\n            );\n\n            customers[_referrer].totalRefPayment = SafeMath.add(\n                customers[_referrer].totalRefPayment,\n                refProfit\n            );\n\n            totalReferalPayments = SafeMath.add(totalReferalPayments, refProfit);\n            emit ReferralPayment(\n                _referrer,\n                //refSuccess,\n                refProfit,\n                block.timestamp\n            );\n        }\n    }\n}\n"
    }
  }
}