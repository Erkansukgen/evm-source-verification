{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/COINS EMPIRE/crowdsale.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n\r\ninterface TokenSaleInterface {\r\n    function decimals() external view  returns(uint8);\r\n    function balanceOf(address _address) external view returns(uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\n\r\ncontract Crowdsale  {\r\n   \r\n    address owner; // Owner of Contract\r\n    TokenSaleInterface TokenContract; \r\n    uint256 public tokenPrice; // Price of eth to token\r\n    uint256 public softCapTokens; // softcap of tokens\r\n    uint256 public hardCapTokens;  // hardcap of tokens\r\n    uint256 public tokenSold; // Total tokens sold\r\n    bool public saleActive;\r\n    mapping(address => uint) balance;\r\n    event Sold(address indexed buyer, uint256 amount);\r\n    \r\n\r\n    constructor(address _addressContract, uint256 _price, uint256 _softcapwei, uint256 _hardcapwei,bool _activeSale) public {\r\n        owner = msg.sender;\r\n        tokenPrice = _price;\r\n        softCapTokens = _softcapwei;\r\n        hardCapTokens = _hardcapwei;\r\n        tokenSold = 0;\r\n        saleActive =_activeSale;\r\n        TokenContract = TokenSaleInterface(_addressContract);\r\n    }\r\n    \r\n    // Only owner modifier, Prevent unauthorized users to access restricted functions\r\n    modifier onlyOwner() {\r\n         require(msg.sender == owner, \"Only Owner can perform this functions\");\r\n        _;\r\n    }\r\n    \r\n   \r\n  \r\n    // Guards against integer overflows\r\n    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        } else {\r\n            uint256 c = a * b;\r\n            // require(c / a == b,\"SafeMath: Multiply overflow\");\r\n            return c;\r\n        }\r\n    }\r\n    \r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n\r\n    // Only owner functions \r\n\r\n    function setPrice(uint256 _newprice) public onlyOwner() {\r\n        require(_newprice > 0,\"Price can not be less then 1\");\r\n        tokenPrice = _newprice;\r\n    }\r\n  \r\n  \r\n    function etherBalance() public view onlyOwner() returns (uint256)  {\r\n        return address(this).balance;\r\n    }\r\n  \r\n    function tokenBalance() public view onlyOwner() returns (uint256)  {\r\n        return TokenContract.balanceOf(address(this));\r\n    }\r\n  \r\n   \r\n     //Activate Sale;\r\n    function activateSale()  public  onlyOwner {\r\n        require(!saleActive,\"Sale is allready Active\");\r\n        saleActive = true;\r\n    }\r\n\r\n    //Deactivates Sale;\r\n    function deactivateSale()  public onlyOwner {\r\n        require(saleActive,\"Sale is allready Deactive\");\r\n        saleActive = false;\r\n    }\r\n    \r\n    function withdrawEther() public onlyOwner() {\r\n        require(tokenSold>=softCapTokens,\"Not allowed to withdraw until softcap reached\");\r\n        require(address(this).balance > 0,\"Can not withdraw 0 balance\");\r\n        payable(owner).transfer(address(this).balance);\r\n   \r\n    }\r\n    \r\n    function transferBalanceToken() public onlyOwner() {\r\n         require(TokenContract.balanceOf(address(this)) > 0,\"You do not have balance\");\r\n         TokenContract.transfer(owner, TokenContract.balanceOf(address(this)));\r\n    }\r\n    \r\n\r\n    // Finally end token sale get ether and balance token back.\r\n    function endTokenSale() public  onlyOwner() {\r\n        // Send ether and balacne token at to benificiary after token sale end\r\n        if (TokenContract.balanceOf(address(this)) > 0){\r\n            TokenContract.transfer(owner, TokenContract.balanceOf(address(this)));\r\n        }    \r\n        \r\n        if (address(this).balance > 0){\r\n             // msg.sender.transfer(address(this).balance);\r\n            payable(owner).transfer(address(this).balance);\r\n        }\r\n\r\n    }\r\n    \r\n\r\n     // Function to receive ether. msg.data must be empty  \r\n     // This function is when someone sends ether directly\r\n    receive() external payable {\r\n        require(saleActive && msg.value > 0,\"Sale is not active or ether can not be zero\"); // Check if ether drop is available\r\n        uint256 sendTokens =  safeMultiply(msg.value ,tokenPrice);\r\n        require(TokenContract.balanceOf(address(this)) > sendTokens, \"Enough tokens are not available\");\r\n        require(safeAdd(tokenSold, sendTokens)  < hardCapTokens, \"HardcapReached\");\r\n        tokenSold = safeAdd(tokenSold,sendTokens);\r\n        TokenContract.transfer(msg.sender, sendTokens);\r\n        emit Sold(msg.sender, sendTokens);\r\n       \r\n    }\r\n    \r\n\r\n}\r\n\r\n"
    }
  }
}