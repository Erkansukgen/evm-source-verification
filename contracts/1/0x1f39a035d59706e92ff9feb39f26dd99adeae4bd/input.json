{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/me_br_3.sol": {
      "content": "pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n\r\n}\r\ninterface IERC20Token {\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n}\r\ninterface Pair {\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\r\n}\r\n\r\nstruct Swap{\r\n    address[] path;\r\n    address pairAddress;\r\n}\r\n\r\ncontract me_br_3\r\n{\r\n    //function signatures\r\n    bytes4 constant getAllowance = 0xdd62ed3e;//keccak256(\"allowance(address,address)\"));\r\n    bytes4 constant approveTokenSpend = 0x095ea7b3; //bytes4(keccak256(\"approve(address,uint256)\"));\r\n    bytes4 constant transferRequest = 0xa9059cbb;  //bytes4(keccak256(\"transfer(address,uint256)\"));\r\n    bytes4 constant getReserves =  0x0902f1ac;//bytes4 sig = bytes4(keccak256(\"getReserves()\"));\r\n    bytes4 constant balanceOf =  0x70a08231;//bytes4 sig = bytes4(keccak256(\"balanceOf(address)\"));\r\n\r\n    address payable Owner;\r\n    IWETH immutable WETH;\r\n    receive() external payable {}\r\n    fallback () external  payable {}\r\n\r\n    constructor() public\r\n    {\r\n        Owner = msg.sender;\r\n        WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    }\r\n\r\n    function ExecuteSwaps(uint tokenInAmount, Swap[] memory swaps,uint minAmountOut) public\r\n    {\r\n        //***note: all function calls are in line rather than using a seperate internal functions to call the external function, which costs more gas\r\n        //defining loop variables here since it costs less gas rather than defining variables outside within the loop\r\n        address pairAddress;\r\n        address token0;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint token0Out;\r\n        uint token1Out;\r\n        address swapToAddress;\r\n        uint startBalance;\r\n       \r\n        assembly\r\n        {\r\n            //get start weth balance\r\n            let x := mload(0x40)   //Find empty storage location using \"free memory pointer\"\r\n            mstore(x,balanceOf) //Place signature at begining of empty storage\r\n            mstore(add(x,0x04),address()) // sender\r\n\r\n            let success:=staticcall(\r\n                0xffff, //hard coded max gas limit\r\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, //contract address\r\n                x,    // inputs are at location x\r\n                0x68, //input size two padded\r\n                x,    //store output over input\r\n                32) //bytes received output\r\n            startBalance:=mload(x)\r\n        }\r\n\r\n        assembly{\r\n            if  eq( eq(caller(), sload(Owner_slot)),0) { revert(0, 0) }\r\n        }\r\n        \r\n\r\n        for (uint i; i < swaps.length; i++)\r\n        {\r\n            tokenIn = swaps[i].path[0];\r\n            tokenOut = swaps[i].path[1];\r\n            pairAddress = swaps[i].pairAddress;\r\n            token0 = tokenIn < tokenOut ? tokenIn  : tokenOut;\r\n            //note that for all swaps other than the last, we are setting the \"TO\" address to the next swap pair to avoid transfer costs\r\n            swapToAddress = (i < swaps.length - 1) ? swaps[i+1].pairAddress : address(this);\r\n\r\n            //we only need to approve and transfer for the the first swap since we are directly sending proceeds to next swap except for the last which is returned to us\r\n            //not that it saves gas to nest the assembly under the if condition when true which is why I am breaking up assembly calls here\r\n            if (i == 0)\r\n            {\r\n                uint allowance;\r\n                assembly\r\n                {\r\n                    \r\n                        //get token allowance\r\n                        let x := mload(0x40)   //Find empty storage location using \"free memory pointer\"\r\n                        mstore(x,getAllowance) //Place signature at begining of empty storage\r\n                        mstore(add(x,0x04),address()) // sender\r\n                        mstore(add(x,0x24),pairAddress) // recipient\r\n\r\n                        let success:=staticcall(\r\n                            0xffff, //hard coded max gas limit\r\n                            tokenIn, //contract address\r\n                            x,    // inputs are at location x\r\n                            0x68, //input size two padded\r\n                            x,    //store output over input\r\n                            32) //bytes received output\r\n                        allowance:=mload(x)\r\n                }\r\n                if (allowance == 0)\r\n                {\r\n                    assembly\r\n                    {\r\n                        \r\n                        let x := mload(0x40)\r\n                        mstore(x,approveTokenSpend)\r\n                        mstore(add(x,0x04),pairAddress)\r\n                        mstore(add(x,0x24),0xffffffffffffffffffffffffffffffff) //largest uint256 possible\r\n                        mstore(0x40,add(x,0x64))\r\n\r\n                        let success:=call(\r\n                            0xffff, //hard coded max gas limit\r\n                            tokenIn, //contract address\r\n                            0,    //wei value to pass in\r\n                            x,    // inputs are at location x\r\n                            0x68, //input size two padded\r\n                            x,    //store output over input\r\n                            0) //bytes received output\r\n\r\n                    }\r\n                }        \r\n                assembly\r\n                {\r\n                    //*********Transfer to pair\r\n                    //Transfer to pair\r\n                    let x := mload(0x40)\r\n                    mstore(x,transferRequest)\r\n                    mstore(add(x,0x04),pairAddress)\r\n                    mstore(add(x,0x24),tokenInAmount)\r\n\r\n                    let success:=call(\r\n                        0xffff, //hard coded max gas limit\r\n                        tokenIn, //contract address\r\n                        0,    //wei value to pass in\r\n                        x,    // inputs are at location x\r\n                        0x68, //input size two padded\r\n                        x,    //store output over input\r\n                        0) //bytes received output\r\n                }\r\n            }\r\n\r\n            assembly\r\n            {\r\n                //Get Reserves & Amount Out\r\n                let x := mload(0x40)   //Find empty storage location using \"free memory pointer\"\r\n                mstore(x,getReserves) //Place signature at begining of empty storage\r\n\r\n                let success:=staticcall(\r\n                    0xffff, //hard coded max gas limit\r\n                    pairAddress, //contract address\r\n                    x,    // inputs are at location x\r\n                    0x68, //input size two padded\r\n                    x,    //store output over input\r\n                    0x40) //bytes received output\r\n\r\n                //Compute Amount Out\r\n                if eq(tokenIn, token0){\r\n                    token0Out:=0\r\n                    token1Out:=\r\n                        div(\r\n                            mul(\r\n                                mul(tokenInAmount, 997)\r\n                                ,mload(add(32, x)) //reserve out\r\n                            )\r\n                            ,\r\n                            add(\r\n                                mul(mload(add(0, x)), 1000) //reserve in\r\n                                ,\r\n                                mul(tokenInAmount, 997)\r\n                            )\r\n                        )\r\n                    tokenInAmount:=token1Out\r\n                }\r\n\r\n                if eq(tokenOut, token0){\r\n                    token0Out:=\r\n                        div(\r\n                            mul(\r\n                                mul(tokenInAmount, 997)\r\n                                ,mload(add(0, x)) //reserve in\r\n                            )\r\n                            ,\r\n                            add(\r\n                                mul(mload(add(32, x)), 1000) //reserve out\r\n                                ,\r\n                                mul(tokenInAmount, 997)\r\n                            )\r\n                        )\r\n                    token1Out:=0\r\n                    tokenInAmount:=token0Out\r\n                }\r\n                \r\n            }\r\n\r\n            //*********Execute swap using Pair interface\r\n            Pair(pairAddress).swap(token0Out,token1Out,swapToAddress, \"\");\r\n            \r\n        }       \r\n        require(tokenInAmount >= minAmountOut, \"Min Not Met\");\r\n        \r\n        assembly\r\n        {\r\n            //get end weth balance and revert if less\r\n            let x := mload(0x40)   //Find empty storage location using \"free memory pointer\"\r\n            mstore(x,balanceOf) //Place signature at begining of empty storage\r\n            mstore(add(x,0x04),address()) // sender\r\n            let success:=staticcall(\r\n                0xffff, //hard coded max gas limit\r\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, //contract address\r\n                x,    // inputs are at location x\r\n                0x68, //input size two padded\r\n                x,    //store output over input\r\n                0) //bytes received output\r\n            if lt(mload(x), startBalance){ revert(0, 0) }\r\n            \r\n        }\r\n        \r\n\r\n    }\r\n   \r\n\r\n    function ReceiveEth() public payable {\r\n    }\r\n    function GetEthBalance() public view returns (uint) {\r\n        require(msg.sender == Owner, \"Invalid caller\");\r\n        return address(this).balance;\r\n    }\r\n    function GetERC20TokenBalance(IERC20Token token) public view returns (uint) {\r\n        require(msg.sender == Owner, \"Invalid caller\");\r\n        return token.balanceOf(address(this));\r\n    }\r\n    function WithdrawERC20Token(IERC20Token token) public {\r\n        require(msg.sender == Owner, \"Invalid caller\");\r\n        token.transfer(Owner, token.balanceOf(address(this)));\r\n    }\r\n    function WithdrawEth(uint256 amount) public {\r\n        require(msg.sender == Owner, \"Invalid caller\");\r\n        Owner.transfer(amount);\r\n    }\r\n    function ConvertWethToEthAndWithdraw(uint256 amount) internal\r\n    {\r\n        WETH.withdraw(amount);\r\n        Owner.transfer(amount);\r\n    }\r\n    function ReceiveEthAndConvertToWeth() public payable\r\n    {\r\n        WETH.deposit{value: msg.value}();\r\n    }\r\n}"
    }
  }
}