{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Ticket.sol":{"content":"// SmartWay Ticket\n// https://dappticket.com\n//\n/// SPDX-License-Identifier: MIT\npragma solidity =0.7.2;\n\ncontract Ticket {\n    uint256 public uid = 1;\n\n    uint8 public constant MAX_LEVEL = 12; // Maximum number of levels\n\n    uint256 public constant LEFT_PRICE = 0.025 ether; // Starting price\n\n    enum Site {X3, X4}\n\n    struct X3 {\n        uint8 status; // 0: nonactivated; 1: open; 2: open and blocked;\n        uint256 reinvestCount;\n        address[] points;\n        address ref;\n    }\n\n    struct X4 {\n        uint8 status; // 0: nonactivated; 1: open; 2: open and blocked;\n        uint256 reinvestCount;\n        address[] firstPoints;\n        address[] leftPoints;\n        address[] rightPoints;\n        address ref;\n    }\n\n    struct User {\n        uint256 id;\n        address referrer;\n        uint256 partnersCount;\n        mapping(uint8 => X3) x3Site;\n        mapping(uint8 => X4) x4Site;\n    }\n\n    enum Relation {\n        Direct, // 0 Match to management account\n        Partner, // 1 Normally matched\n        Slide, // 2\n        Gift // The junior partner surpasses his superior\n    }\n\n    event NewUser(\n        address indexed _user,\n        address indexed _referrer,\n        uint8 level\n    );\n\n    event Transfer(\n        Site indexed _matrix,\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        uint8 _level,\n        bool blocked,\n        uint256 _skip\n    );\n\n    event IndexUser(\n        Site indexed _matrix,\n        address indexed _user,\n        address indexed _referrer,\n        address _partner,\n        uint8 _level,\n        uint256 _skip,\n        Relation _relation,\n        uint8 _buyAgain,\n        uint8 _pointLevel,\n        uint256 _reinvestNumber,\n        bool _active\n    );\n    address public owner;\n    mapping(uint8 => uint256) public levelPrice;\n    mapping(address => User) public users;\n    mapping(uint256 => address) public userIDToAddress;\n\n    constructor(address _ownerAddress) {\n        owner = _ownerAddress;\n        levelPrice[1] = LEFT_PRICE;\n        for (uint8 i = 2; i <= MAX_LEVEL; i++) {\n            levelPrice[i] = levelPrice[i - 1] * 2;\n        }\n        createUser(_ownerAddress, address(0x0), MAX_LEVEL);\n    }\n\n    receive() external payable {\n        if (msg.data.length == 0) {\n            register(msg.sender, owner);\n            return;\n        }\n        register(msg.sender, bytesToAddress(msg.data));\n    }\n\n    function bytesToAddress(bytes memory bys)\n        private\n        pure\n        returns (address addr)\n    {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n\n    function register(address ref) external payable returns (bool) {\n        return register(msg.sender, ref);\n    }\n\n    function register(address userAddress, address ref) private returns (bool) {\n        require(msg.value == LEFT_PRICE * 2, \"Wrong registration cost.\");\n        require(!isUserExists(userAddress), \"User exists.\");\n        require(isUserExists(ref), \"Referrer not exists.\");\n        uint32 size;\n        assembly {\n            size := extcodesize(userAddress)\n        }\n        require(size == 0, \"Cannot be a contract\");\n        createUser(userAddress, ref, 1);\n        // X3\n        x3Transfer(userAddress, ref, 1, LEFT_PRICE);\n        // X4\n        x4Transfer(userAddress, ref, 1, LEFT_PRICE);\n        return true;\n    }\n\n    function createUser(\n        address userAddress,\n        address ref,\n        uint8 level\n    ) private returns (uint256 userID) {\n        require(level <= MAX_LEVEL, \"Level exceeds maximum limit.\");\n        userIDToAddress[uid] = userAddress;\n        User storage user = users[userAddress];\n        user.id = uid;\n        user.referrer = ref;\n        for (uint8 i = 1; i <= level; i++) {\n            user.x3Site[i].status = 1;\n            user.x4Site[i].status = 1;\n        }\n        if (ref != address(0x0)) {\n            users[ref].partnersCount++;\n        }\n        userID = uid;\n        uid++;\n        emit NewUser(userAddress, ref, level);\n    }\n\n    function buyX3Level(uint8 level) public payable {\n        buyNewLevel(Site.X3, level);\n    }\n\n    function buyX4Level(uint8 level) public payable {\n        buyNewLevel(Site.X4, level);\n    }\n\n    function buyNewLevel(Site matrix, uint8 level) private {\n        uint256 amount = levelPrice[level];\n        require(level > 1 && level <= MAX_LEVEL, \"Invalid level.\");\n        require(msg.value == amount, \"Invalid price.\");\n        require(\n            isUserExists(msg.sender),\n            \"User does not exist, please register first.\"\n        );\n        if (matrix == Site.X3) {\n            require(\n                users[msg.sender].x3Site[level].status == 0,\n                \"The current X3 level has been activated.\"\n            );\n            require(\n                users[msg.sender].x3Site[level - 1].status > 0,\n                \"Can not leapfrog upgrade.\"\n            );\n            x3Transfer(msg.sender, users[msg.sender].referrer, level, amount);\n            users[msg.sender].x3Site[level].status = 1;\n            users[msg.sender].x3Site[level - 1].status = 1;\n        } else {\n            require(\n                users[msg.sender].x4Site[level].status == 0,\n                \"The current X4 level has been activated.\"\n            );\n            require(\n                users[msg.sender].x4Site[level - 1].status > 0,\n                \"Can not leapfrog upgrade.\"\n            );\n            x4Transfer(msg.sender, users[msg.sender].referrer, level, amount);\n            users[msg.sender].x4Site[level].status = 1;\n            users[msg.sender].x4Site[level - 1].status = 1;\n        }\n    }\n\n    // x3Transfer\n    function x3Transfer(\n        address userAddress,\n        address ref,\n        uint8 level,\n        uint256 amount\n    ) private {\n        (address receiver, uint256 skip) = updateX3(userAddress, ref, level, 0);\n        transfer(Site.X3, level, userAddress, receiver, skip, amount);\n    }\n\n    function transfer(\n        Site matrix,\n        uint8 level,\n        address from,\n        address receiver,\n        uint256 skip,\n        uint256 amount\n    ) private {\n        if (matrix == Site.X3) {\n            while (true) {\n                X3 memory x3 = users[receiver].x3Site[level];\n                if (x3.status == 2) {\n                    // blocked\n                    emit Transfer(\n                        matrix,\n                        from,\n                        receiver,\n                        amount,\n                        level,\n                        true,\n                        skip\n                    );\n                    receiver = x3.ref;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            while (true) {\n                X4 memory x4 = users[receiver].x4Site[level];\n                if (x4.status == 2) {\n                    // blocked\n                    emit Transfer(\n                        matrix,\n                        from,\n                        receiver,\n                        amount,\n                        level,\n                        true,\n                        skip\n                    );\n                    receiver = x4.ref;\n                } else {\n                    break;\n                }\n            }\n        }\n        emit Transfer(matrix, from, receiver, amount, level, false, skip);\n        address(uint160(receiver)).transfer(amount);\n    }\n\n    // x3 update\n    // @userAddress Register or upgrade user address\n    // @return The address to receive funds\n    function updateX3(\n        address userAddress,\n        address referrer,\n        uint8 level,\n        uint256 skip\n    ) private returns (address, uint256) {\n        address ref = findX3ActiveReferrer(referrer, level);\n        User storage user = users[userAddress];\n        X3 storage x3 = users[ref].x3Site[level];\n        Relation relation = Relation.Direct;\n        if (ref != referrer) {\n            relation = Relation.Gift;\n        }\n        if (user.x3Site[level].ref != ref) {\n            user.x3Site[level].ref = ref;\n        }\n        if (x3.points.length < 2) {\n            x3.points.push(userAddress);\n            emit IndexUser(\n                Site.X3,\n                userAddress,\n                ref,\n                address(0x0),\n                level,\n                skip,\n                relation,\n                0,\n                1,\n                x3.reinvestCount,\n                x3.status == 1\n            );\n            return (ref, skip);\n        }\n        x3.points = new address[](0);\n        x3.reinvestCount++;\n        if (ref == owner) {\n            emit IndexUser(\n                Site.X3,\n                userAddress,\n                ref,\n                address(0x0),\n                level,\n                skip,\n                relation,\n                1,\n                1,\n                x3.reinvestCount - 1,\n                true\n            );\n            return (ref, skip);\n        }\n        if (\n            level < MAX_LEVEL &&\n            users[ref].x3Site[level + 1].status == 0 &&\n            x3.status == 1\n        ) {\n            x3.status = 2;\n            emit IndexUser(\n                Site.X3,\n                userAddress,\n                ref,\n                address(0x0),\n                level,\n                skip,\n                relation,\n                2,\n                1,\n                x3.reinvestCount - 1,\n                false\n            );\n        } else {\n            emit IndexUser(\n                Site.X3,\n                userAddress,\n                ref,\n                address(0x0),\n                level,\n                skip,\n                relation,\n                1,\n                1,\n                x3.reinvestCount - 1,\n                x3.status == 1\n            );\n        }\n        // Buy agin\n        return updateX3(ref, users[ref].referrer, level, skip + 1);\n    }\n\n    function x4Transfer(\n        address userAddress,\n        address ref,\n        uint8 level,\n        uint256 amount\n    ) private {\n        (address receiver, uint256 skip) = updateX4(userAddress, ref, level, 0);\n        transfer(Site.X4, level, userAddress, receiver, skip, amount);\n    }\n\n    // x4 update\n    // @userAddress Register or upgrade user address\n    // @return The address to receive funds\n    function updateX4(\n        address userAddress,\n        address referrer,\n        uint8 level,\n        uint256 skip\n    ) private returns (address, uint256) {\n        address ref = findX4ActiveReferrer(referrer, level);\n        X4 storage x4 = users[ref].x4Site[level];\n        Relation relation = Relation.Direct;\n        if (ref != referrer) {\n            relation = Relation.Gift;\n        }\n        address partner = address(0x0);\n        if (x4.firstPoints.length < 2) {\n            partner = ref;\n            x4.firstPoints.push(userAddress);\n            users[userAddress].x4Site[level].ref = ref;\n            emit IndexUser(\n                Site.X4,\n                userAddress,\n                ref,\n                address(0x0),\n                level,\n                skip,\n                relation,\n                0,\n                1,\n                x4.reinvestCount,\n                x4.status == 1\n            );\n            if (ref == owner) {\n                return (owner, skip);\n            }\n            // isSlide = false\n            return\n                updateX4Second(userAddress, x4.ref, level, ref, relation, skip);\n        } else {\n            // isSlide = true\n            return\n                updateX4Second(\n                    userAddress,\n                    ref,\n                    level,\n                    address(0x0),\n                    relation,\n                    skip\n                );\n        }\n    }\n\n    // Update the second level points\n    function updateX4Second(\n        address userAddress,\n        address ref,\n        uint8 level,\n        address partner,\n        Relation relation,\n        uint256 skip\n    ) private returns (address receiver, uint256) {\n        X4 storage x4 = users[ref].x4Site[level];\n        // Update the first level point\n        bool isSlide = partner == address(0x0);\n        address slideTo;\n        if (isSlide) {\n            if (x4.leftPoints.length <= x4.rightPoints.length) {\n                // left\n                slideTo = x4.firstPoints[0];\n            } else {\n                // right\n                slideTo = x4.firstPoints[1];\n            }\n            X4 storage slideX4 = users[slideTo].x4Site[level];\n            slideX4.firstPoints.push(userAddress);\n            users[userAddress].x4Site[level].ref = slideTo;\n            emit IndexUser(\n                Site.X4,\n                userAddress,\n                slideTo,\n                partner,\n                level,\n                skip,\n                Relation.Slide,\n                0,\n                1,\n                slideX4.reinvestCount,\n                slideX4.status == 1\n            );\n        } else {\n            slideTo = partner;\n        }\n        if (x4.rightPoints.length + x4.leftPoints.length >= 3) {\n            // Determine whether the loop can continue\n            x4.leftPoints = new address[](0);\n            x4.rightPoints = new address[](0);\n            x4.firstPoints = new address[](0);\n            x4.ref = address(0x0);\n            x4.reinvestCount++;\n            if (\n                level < MAX_LEVEL &&\n                users[ref].x4Site[level + 1].status == 0 &&\n                x4.status == 1\n            ) {\n                x4.status = 2;\n                emit IndexUser(\n                    Site.X4,\n                    userAddress,\n                    ref,\n                    slideTo,\n                    level,\n                    skip,\n                    relation,\n                    2,\n                    2,\n                    x4.reinvestCount - 1,\n                    false\n                );\n            } else {\n                emit IndexUser(\n                    Site.X4,\n                    userAddress,\n                    ref,\n                    slideTo,\n                    level,\n                    skip,\n                    relation,\n                    1,\n                    2,\n                    x4.reinvestCount - 1,\n                    x4.status == 1\n                );\n            }\n            if (ref == owner) {\n                return (owner, skip);\n            }\n            // Buy again\n            return updateX4(ref, users[ref].referrer, level, skip + 1);\n        }\n        // Enough points\n        if (slideTo == x4.firstPoints[0]) {\n            x4.leftPoints.push(userAddress);\n        } else {\n            x4.rightPoints.push(userAddress);\n        }\n        if (isSlide) {\n            emit IndexUser(\n                Site.X4,\n                userAddress,\n                ref,\n                slideTo,\n                level,\n                skip,\n                relation,\n                0,\n                2,\n                x4.reinvestCount,\n                x4.status == 1\n            );\n        } else {\n            emit IndexUser(\n                Site.X4,\n                userAddress,\n                ref,\n                slideTo,\n                level,\n                skip,\n                Relation.Partner,\n                0,\n                2,\n                x4.reinvestCount,\n                x4.status == 1\n            );\n        }\n        return (ref, skip);\n    }\n\n    function findX3ActiveReferrer(address addr, uint8 level)\n        public\n        view\n        returns (address)\n    {\n        while (true) {\n            if (users[addr].x3Site[level].status > 0) {\n                return addr;\n            }\n            addr = users[addr].referrer;\n        }\n        return addr;\n    }\n\n    function findX4ActiveReferrer(address addr, uint8 level)\n        public\n        view\n        returns (address)\n    {\n        while (true) {\n            if (users[addr].x4Site[level].status > 0) {\n                return addr;\n            }\n            addr = users[addr].referrer;\n        }\n        return addr;\n    }\n\n    // Get x3 information\n    // @param addr user address\n    // @param level level level\n    function userX3Site(address addr, uint8 level)\n        public\n        view\n        returns (\n            uint8 status,\n            uint256 reinvestCount,\n            address[] memory points,\n            address ref\n        )\n    {\n        X3 memory x3 = users[addr].x3Site[level];\n        status = x3.status;\n        reinvestCount = x3.reinvestCount;\n        points = x3.points;\n        ref = x3.ref;\n    }\n\n    // Get x3 information\n    // @param addr user address\n    // @param level level level\n    function userX4Site(address addr, uint8 level)\n        public\n        view\n        returns (\n            uint8 status,\n            uint256 reinvestCount,\n            address[] memory firstPoints,\n            address[] memory leftPoints,\n            address[] memory rightPoints,\n            address ref\n        )\n    {\n        X4 memory x4 = users[addr].x4Site[level];\n        status = x4.status;\n        reinvestCount = x4.reinvestCount;\n        firstPoints = x4.firstPoints;\n        leftPoints = x4.leftPoints;\n        rightPoints = x4.rightPoints;\n        ref = x4.ref;\n    }\n\n    function isUserExists(address user) public view returns (bool) {\n        return (users[user].id != 0);\n    }\n}\n"}}}