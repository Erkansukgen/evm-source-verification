{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "cbiOracle.sol": {
      "content": "pragma solidity ^0.6.7;\n\nimport \"https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\n\nabstract contract Context {\n    function _msgSender() internal virtual view returns (address payable) {\n        return msg.sender;\n    }\n}\n\ncontract X7Oracle is Context {\n    AggregatorV3Interface internal ethFeed;\n    AggregatorV3Interface internal btcFeed;\n    AggregatorV3Interface internal linkFeed;\n    AggregatorV3Interface internal aaveFeed;\n    AggregatorV3Interface internal renFeed;\n    AggregatorV3Interface internal bandFeed;\n    AggregatorV3Interface internal balFeed;\n\n    BPT private bpt;\n    address private _owner;\n    \n    using SafeMath for uint256;\n\n\n    constructor(address bptAddress) public {\n        ethFeed = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        );\n\n        btcFeed = AggregatorV3Interface(\n            0xdeb288F737066589598e9214E782fa5A8eD689e8\n        );\n\n        linkFeed = AggregatorV3Interface(\n            0xDC530D9457755926550b59e8ECcdaE7624181557\n        );\n\n        aaveFeed = AggregatorV3Interface(\n            0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012\n        );\n\n        renFeed = AggregatorV3Interface(\n            0x3147D7203354Dc06D9fd350c7a2437bcA92387a4\n        );\n\n        bandFeed = AggregatorV3Interface(\n            0x0BDb051e10c9718d1C29efbad442E88D38958274\n        );\n\n        balFeed = AggregatorV3Interface(\n            0xC1438AA3823A6Ba0C159CfA8D98dF5A994bA120b\n        );\n\n        bpt = BPT(bptAddress);\n\n        _owner = _msgSender();\n    }\n\n    /**\n     * @dev This returns the totalValue of our share of the pool, as well as the total supply of \n     * cbix7 tokens to calculate the price per token.\n     * \n     */\n    function getTotalPoolValueInEth() public view returns (uint256 totalValue, uint256 totalSupply) {\n        totalValue = 0;\n        address[] memory tokens = bpt.getFinalTokens();\n        for (uint i = 0; i < tokens.length; i++) {\n            uint256 balance = getOwnedTokenValueInEth(tokens[i]);\n            totalValue = totalValue.add(balance);\n        }\n        \n        totalSupply = bpt.balanceOf(_owner);\n        \n        return (totalValue, totalSupply);\n    }\n\n    /**\n     * @dev This returns the total value the owner owns of a certain token.\n     */\n    function getOwnedTokenValueInEth(address token)\n        private\n        view\n        returns (uint256)\n    {\n        uint256 balance = getOwnedBalance(token);\n        int256 price = getLatestPriceInETH(token);\n        return balance.mul(uint256(price));\n    }\n\n    /**\n     * @dev This returns the owned balance of a certain token.\n     */\n    function getOwnedBalance(address token) private view returns (uint256) {\n        return\n            ((bpt.getBalance(token)).mul(bpt.balanceOf(_owner))).div(bpt.totalSupply());\n    }\n\n    /**\n     * @dev This uses the getTotalPoolValueInEth function and divides them \n     * to get the price of a single token.\n     */\n    function getTokenPriceInEth() public view returns (uint256) {\n        (uint256 totalValue, uint256 totalSupply) = getTotalPoolValueInEth();\n        return totalValue.div(totalSupply);\n    }\n\n    /**\n     * Returns the latest price\n     */\n    function getLatestPriceInETH(address token) public view returns (int256) {\n        if (token == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) {\n            // WETH\n            return 1000000000000000000;\n        } else if (token == 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599) {\n            // WBTC\n            (\n                uint80 roundID,\n                int256 price,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            ) = btcFeed.latestRoundData();\n            return price;\n        } else if (token == 0x514910771AF9Ca656af840dff83E8264EcF986CA) {\n            // LINK\n            (\n                uint80 roundID,\n                int256 price,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            ) = linkFeed.latestRoundData();\n            return price;\n        } else if (token == 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9) {\n            // AAVE\n            (\n                uint80 roundID,\n                int256 price,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            ) = aaveFeed.latestRoundData();\n            return price;\n        } else if (token == 0x408e41876cCCDC0F92210600ef50372656052a38) {\n            // REN\n            (\n                uint80 roundID,\n                int256 price,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            ) = renFeed.latestRoundData();\n            return price;\n        } else if (token == 0xBA11D00c5f74255f56a5E366F4F77f5A186d7f55) {\n            // BAND\n            (\n                uint80 roundID,\n                int256 price,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            ) = bandFeed.latestRoundData();\n            return price;\n        }\n        else if (token == 0xba100000625a3754423978a60c9317c58a424e3D) {\n            // BAL\n            (\n                uint80 roundID,\n                int256 price,\n                uint256 startedAt,\n                uint256 timeStamp,\n                uint80 answeredInRound\n            ) = balFeed.latestRoundData();\n            return price;\n        }\n    }\n\n    /**\n     * Returns the price of eth in usd\n     */\n    function getLatestETHPrice() public view returns (int256) {\n        (\n            uint80 roundID,\n            int256 price,\n            uint256 startedAt,\n            uint256 timeStamp,\n            uint80 answeredInRound\n        ) = ethFeed.latestRoundData();\n        return price;\n    }\n}\n\ncontract DynamicToken {\n    function balanceOf(address whom) external view returns (uint256) {}\n}\n\ncontract BPT is DynamicToken {\n    function getFinalTokens() external view returns (address[] memory tokens) {}\n\n    function getBalance(address token) external view returns (uint256) {}\n\n    function totalSupply() external view returns (uint256) {}\n\n    function exitswapPoolAmountIn(\n        address tokenOut,\n        uint256 poolAmountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 tokenAmountOut) {}\n\n    function joinswapExternAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        uint256 minPoolAmountOut\n    ) external returns (uint256 poolAmountOut) {}\n\n    function getSpotPrice(address tokenIn, address tokenOut)\n        external\n        view\n        returns (uint256 spotPrice)\n    {}\n\n    function swapExactAmountIn(\n        address tokenIn,\n        uint256 tokenAmountIn,\n        address tokenOut,\n        uint256 minAmountOut,\n        uint256 maxPrice\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {}\n}\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    }
  }
}