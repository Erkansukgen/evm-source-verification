{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/ForwarderCollect.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface ERC20Interface {\n  // Send _value amount of tokens to address _to\n  function transfer(address _to, uint256 _value) external returns (bool success);\n  // Get the account balance of another account with address _owner\n  function balanceOf(address _owner) external returns (uint256 balance);\n}\ncontract Forwarder {\n  // Address to which any funds sent to this contract will be forwarded\n  address public parentAddress;\n  event forwarderDeposited(address from, uint value, bytes data);\n\n  event TokensFlushed(\n    address tokenContractAddress, // The contract address of the token\n    uint value // Amount of token sent\n  );\n\n  /**\n   * Create the contract, and set the destination address to that of the creator\n   */\n  constructor() public {\n    parentAddress = msg.sender;\n  }\n\n  /**\n   * Modifier that will execute internal code block only if the sender is a parent of the forwarder contract\n   */\n  modifier onlyParent {\n    if (msg.sender != parentAddress) {\n      revert();\n    }\n    _;\n  }\n\n  /**\n   * Default function; Gets called when Ether is deposited, and forwards it to the destination address\n   */\n  fallback() external payable {\n    (bool success,) = parentAddress.call{value:msg.value}(msg.data);\n    require(success);\n    // Fire off the deposited event if we can forward it  \n    emit forwarderDeposited(msg.sender, msg.value, msg.data);\n  }\n\n\n  function ForwarderDeposited() public payable {\n      emit forwarderDeposited(msg.sender, msg.value, msg.data);\n  }\n}\n\ncontract ForwarderCollect {\n    Forwarder forwarder;\n    address forwarderparent;\n    event ForwarderDeposited(address from, uint value, bytes data);\n    constructor(address payable _address) public {\n        forwarder = Forwarder(_address);\n        forwarderparent = forwarder.parentAddress();\n    }\n    function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize()) }\n      default { return(0, returndatasize()) }\n    }\n  }\n    function depositcall() public payable{\n        (bool success,) = address(forwarder).call{value:address(this).balance}(\"\");\n         require(success);\n        msg.sender.transfer(address(this).balance);\n    }\n    function depositdelegate() public payable{\n       (bool success,) = address(forwarder).delegatecall(abi.encodeWithSignature(\"forwarderDeposited()\"));\n        require(success);\n        msg.sender.transfer(address(this).balance);\n    }\n    function depositdelegateparent() public payable{\n        _delegate(forwarderparent);\n        msg.sender.transfer(msg.value);\n    }\n    fallback() external payable {\n        revert();\n    }\n    receive() external payable {\n       revert();\n    }\n}"
    }
  }
}