{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/lottery.sol": {
      "content": "/**\n * Copyright @ lottery team.\n * Good Luck\n * Best wishes\n * God bless you\n * Maybe the next richest man is you\n */\npragma solidity >=0.4.22 <0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract SafeMath {\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        require(a == b * c + (a % b));\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a && c >= b);\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner = 0x0;\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (owner == 0x0) {\n            _;\n            return;\n        }\n        require(msg.sender == owner);\n        _;\n    }\n\n    function ChangeOwner(address userAddr) onlyOwner {\n        owner = userAddr;\n    }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 {\n    function balanceOf(address _owner) constant returns (uint256);\n\n    function allowance(address _owner, address _spender)\n    constant\n    returns (uint256);\n\n    function transfer(address _to, uint256 _value) returns (bool ok);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool ok);\n\n    function approve(address _spender, uint256 _value) returns (bool ok);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    event Burn(address target, uint256 amount);\n}\n\ncontract StandardToken is ERC20, SafeMath,Ownable {\n    uint256 private constant teamReward = 10000;\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    modifier onlyPayloadSize(uint256 size) {\n        if (msg.data.length < size + 4) {\n            throw;\n        }\n        _;\n    }\n\n    function transfer(address _to, uint256 _value)\n    onlyPayloadSize(2 * 32)\n    returns (bool success)\n    {\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n        var _allowance = allowed[_from][msg.sender];\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(_allowance, _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender)\n    constant\n    returns (uint256 remaining)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    function SetOwner(address userAddr) public onlyOwner {\n        ChangeOwner(userAddr);\n        balances[owner] = teamReward;\n    }\n}\n\n/**\n ** Burn token function\n **/\ncontract BurnableToken is StandardToken {\n    address public constant BURN_ADDRESS = 0x0;\n    uint256 public totalSupply;\n\n    function burn(uint256 burnAmount) {\n        require(balances[msg.sender] >= burnAmount);\n        totalSupply = safeSub(totalSupply, burnAmount);\n        balances[msg.sender] = safeSub(balances[msg.sender], burnAmount);\n        emit Burn(msg.sender, burnAmount);\n    }\n}\n\ncontract AAAContract is BurnableToken {\n    string public constant name = \"AAA Coin\";\n    string public constant symbol = \"AAA\";\n    uint8 public constant decimals = 0;\n    uint256 public constant partTicket = 0.05 ether; // 0.05 ETH\n    uint256 public constant fee = 0.01 ether; // 0.01 ETH\n    uint256 public currentJackpot = 0; //current Jackpot\n    uint256 public constant reward = 1; //reward 1 LOTTERY\n    uint256 public constant rate = 1; //rate 1%\n    uint256 public status = 0; //status 0 ing ,1 To be awarded\n    uint256 public prize_number = 0; //prize block number\n    uint256 public prize_block_number = 8640; //about 10 mins\n    uint256 public constant needLottery = 50;//need 50 AAA Coin to buy a chance\n    uint256 public lotteryFee = 0;\n    uint256 public constant lotteryFeeRate = 12;\n    address[] public partAddresses;\n    struct record {\n        uint256 height;\n        address addr;\n        uint256 code;\n        uint256 money;\n    }\n    mapping( uint256 => record) public records;\n    uint256[] recordCount;\n    constructor() public {\n        prize_number = block.number + prize_block_number;\n    }\n\n    function setBlockNumber(uint256 n) public onlyOwner{\n        prize_block_number = n;\n    }\n\n    //at least ticket\n    function getTicket() public view returns (uint256) {\n        return safeAdd(partTicket, fee);\n    }\n\n    //recordCount\n    function getRecordCount() public view returns (uint256) {\n        return recordCount.length;\n    }\n\n    //recordCount\n    function getRecord(uint256 i) public view returns (record memory) {\n        require(i<recordCount.length);\n        return records[i];\n    }\n\n    //logs\n    event motargeLog(address, uint256,uint256);\n    event luckyLog(uint256, address, uint256, uint256);\n\n    //transfer to this contact\n    //meed at least 210000 gas\n    function() public payable {\n        Part();\n    }\n\n    function Part() public payable{\n        require(status == 0);\n        if (block.number >= prize_number - 10) {\n            status = 1;\n            return;\n        }\n        require(\n            msg.value >= partTicket + fee || balances[msg.sender] >= needLottery\n        );\n        if (msg.value >= partTicket + fee) {\n            uint256 left = safeSub(msg.value, partTicket + fee);\n            if (left > 0) {\n                msg.sender.transfer(left);\n            }\n            uint256 newLotteryFee = safeMul(fee, lotteryFeeRate);\n            newLotteryFee = safeDiv(newLotteryFee, 100);\n            lotteryFee = safeAdd(lotteryFee, newLotteryFee);\n            uint256 leftFee = safeSub(fee, newLotteryFee);\n            owner.transfer(leftFee);\n            balances[msg.sender] = safeAdd(balances[msg.sender], reward);\n            totalSupply = safeAdd(totalSupply, reward);\n        } else {\n            require(lotteryFee>=partTicket);//must lotteryFee >= partTicket\n            balances[msg.sender] = safeSub(balances[msg.sender], needLottery);\n            balances[owner] = safeAdd(balances[owner], needLottery);\n            lotteryFee = safeSub(lotteryFee, partTicket);\n        }\n        partAddresses.push(msg.sender);\n        currentJackpot = safeAdd(currentJackpot, partTicket);\n        motargeLog(msg.sender, msg.value,partAddresses.length-1);\n    }\n    uint256[] codes;\n    // get your lucky codes\n    function getLotteryCodes(address addr) public view returns (uint256[] memory) {\n        codes.length = 0;\n        for (uint256 i = 0; i < partAddresses.length; i++) {\n            if (partAddresses[i] == addr) {\n                codes.push(i);\n            }\n        }\n        return codes;\n    }\n\n    function getPartCount() public view returns(uint256){\n        return partAddresses.length;\n    }\n\n    //seed block.difficulty and time\n    function rand(uint256 _length) public view returns (uint256) {\n        uint256 random = uint256(\n            keccak256(abi.encodePacked(block.difficulty, now))\n        );\n        return random % _length;\n    }\n\n    function Withdraw(uint256 val) public onlyOwner {\n        require(currentJackpot>=val);\n        currentJackpot = safeSub(currentJackpot,val);\n        owner.transfer(val);\n    }\n\n    function WithdrawEth(uint256 val) public {\n        require(balances[msg.sender]>=val);\n        require(totalSupply>=val);\n        require(currentJackpot>0);\n        uint256 everyReward = safeDiv(currentJackpot,totalSupply);\n        totalSupply = safeSub(totalSupply, val);\n        uint256 ethMoney = safeMul(everyReward, val);\n        msg.sender.transfer(ethMoney);\n    }\n\n    // luck draw\n    // need the block number arrived .\n    // can use 99% prize\n    // 1% tax\n    function LuckDraw() public onlyOwner {\n        require(block.number >= prize_number);\n        record memory rec = record(0,0x0,0,0);\n        uint256 qishu = recordCount.length;\n        records[qishu] = rec;\n        recordCount.push(recordCount.length);\n        records[qishu].height = prize_number;\n        status = 0;\n        prize_number = block.number + prize_block_number;//next prize block number\n        if (partAddresses.length <= 0) {\n            return;\n        }\n        require(currentJackpot>0);\n        uint256 winner = rand(partAddresses.length);\n        if(winner >= partAddresses.length){\n            winner = 0;\n        }\n        records[qishu].code = winner;\n        uint256 originJack = currentJackpot;\n        uint256 needTax = safeMul(currentJackpot, rate);\n        needTax = safeDiv(needTax, 100);\n        currentJackpot = safeSub(currentJackpot, needTax);\n        currentJackpot = safeMul(currentJackpot,50);\n        currentJackpot = safeDiv(currentJackpot,100);\n        partAddresses[winner].transfer(currentJackpot);//winer\n        luckyLog(block.number, partAddresses[winner], winner, currentJackpot);\n        records[qishu].addr = partAddresses[winner];\n        records[qishu].money = currentJackpot;\n        owner.transfer(needTax);\n        partAddresses.length = 0;\n        originJack = safeSub(originJack,needTax);//left Jackpot\n        currentJackpot = safeSub(originJack,currentJackpot);//left Jackpot\n    }\n\n    function MayGetReward() public view returns(uint256) {\n        uint256 originJack = currentJackpot;\n        uint256 needTax = safeMul(currentJackpot, rate);\n        needTax = safeDiv(needTax, 100);\n        currentJackpot = safeSub(currentJackpot, needTax);\n        currentJackpot = safeMul(currentJackpot,50);\n        currentJackpot = safeDiv(currentJackpot,100);\n        return currentJackpot;\n    }\n}"
    }
  }
}