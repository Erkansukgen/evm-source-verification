{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/staking.sol":{"content":"pragma solidity ^0.6.6;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"Addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"Subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"Multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"Division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"Modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Staking\n{\n    using SafeMath for uint256;\n\n    struct Staker\n    {\n        uint256 stake;\n        uint256 stakeTime;\n        uint256 reward;\n    }\n    mapping(address => Staker) public stakers;\n\n    IERC20 public _stakingToken;\n    uint256 public _interestPerDay = 1; // 0.1% per day\n    uint256 public _fee = 20; // 0.5%\n\n    event Stake(uint256 amount, uint256 totalStake);\n    event StakeWithdrawal(uint256 amount, uint256 remainingStake);\n    event RewardCollected(uint256 amount, uint256 totalReward);\n    event RewardWithdrawal(uint256 amount, uint256 remainingReward);\n\n    constructor(IERC20 stakingToken) public\n    {\n        require(address(stakingToken) != address(0));\n\n        _stakingToken = stakingToken;\n    }\n\n    function calculateReward(address staker) public view returns (uint256)\n    { return now.sub(stakers[staker].stakeTime).mul(stakers[staker].stake).mul(_interestPerDay).div(86400000); }\n\n    function collectReward(address staker) private returns (uint256)\n    {\n        uint256 reward = calculateReward(staker);\n        stakers[staker].reward = stakers[staker].reward.add(reward);\n        stakers[staker].stakeTime = now;\n\n        emit RewardCollected(reward, stakers[staker].reward);\n        return stakers[staker].reward;\n    }\n\n    function stake(uint256 amount) public\n    {\n        if(stakers[msg.sender].stake > 0)\n        { collectReward(msg.sender); }\n\n        stakers[msg.sender].stakeTime = now;\n        stakers[msg.sender].stake = stakers[msg.sender].stake.add(amount);\n\n        _stakingToken.transferFrom(msg.sender, address(this), amount);\n        emit Stake(amount, stakers[msg.sender].stake);\n    }\n\n    function withdraw() public\n    { withdraw(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }\n\n    function withdraw(uint256 amount) public\n    {\n        require(stakers[msg.sender].stake > 0 || stakers[msg.sender].reward > 0, \"Nothing to withdraw from the contract\");\n\n        uint256 reward = collectReward(msg.sender);\n        uint256 token_balance = _stakingToken.balanceOf(address(this));\n\n        if(amount > stakers[msg.sender].stake)\n        { amount = stakers[msg.sender].stake; }\n\n        if(amount > token_balance)\n        { amount = token_balance; }\n\n        if(amount > 0)\n        {\n            uint256 fee = amount.mul(_fee).div(1000);\n            uint256 withdraw_amount = amount.sub(fee);\n\n            stakers[msg.sender].stake = stakers[msg.sender].stake.sub(amount);\n            token_balance = token_balance.sub(withdraw_amount);\n            _stakingToken.transfer(msg.sender, withdraw_amount);\n            emit StakeWithdrawal(amount, stakers[msg.sender].stake);\n        }\n\n        if(reward > token_balance)\n        { reward = token_balance; }\n\n        if(reward > 0)\n        {\n            stakers[msg.sender].reward = stakers[msg.sender].reward.sub(reward);\n            _stakingToken.transfer(msg.sender, reward);\n            emit RewardWithdrawal(reward, stakers[msg.sender].reward);\n        }\n    }\n\n    function withdrawStake() public\n    { withdrawStake(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }\n\n    function withdrawStake(uint256 amount) public\n    {\n        require(stakers[msg.sender].stake > 0, \"No stake in the contract\");\n\n        collectReward(msg.sender);\n\n        if(amount > stakers[msg.sender].stake)\n        { amount = stakers[msg.sender].stake; }\n\n        uint256 token_balance = _stakingToken.balanceOf(address(this));\n        if(amount > token_balance)\n        { amount = token_balance; }\n\n        if(amount > 0)\n        {\n            uint256 fee = amount.mul(_fee).div(1000);\n            uint256 withdraw_amount = amount.sub(fee);\n\n            stakers[msg.sender].stake = stakers[msg.sender].stake.sub(amount);\n            _stakingToken.transfer(msg.sender, withdraw_amount);\n            emit StakeWithdrawal(amount, stakers[msg.sender].stake);\n        }\n    }\n\n    function withdrawReward() public\n    {\n        uint256 reward = collectReward(msg.sender);\n        require(reward > 0, \"No reward in the contract\");\n\n        uint256 token_balance = _stakingToken.balanceOf(address(this));\n        if(reward > token_balance)\n        { reward = token_balance; }\n\n        if(reward > 0)\n        {\n            stakers[msg.sender].reward = stakers[msg.sender].reward.sub(reward);\n            _stakingToken.transfer(msg.sender, reward);\n            emit RewardWithdrawal(reward, stakers[msg.sender].reward);\n        }\n    }\n}\n"}}}