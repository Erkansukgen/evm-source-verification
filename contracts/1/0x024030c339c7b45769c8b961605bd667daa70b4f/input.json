{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"swapForBot.sol":{"content":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ncontract Swap {\n\n    bool private swaping = false;\n\n    modifier onlyOwner {\n        require (msg.sender == 0xDCDaFD08214a39e9eB54e4bDED5952b2e4f836C7, \"Unauthorized call\");\n        _;\n    }\n\n    receive() external payable  {} // Fallback function pour ajout ether\n\n    function withdrawToken(address tokenAddress, uint amount) external onlyOwner {\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n\n            /************************* token transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), origin()) // address dest\n            mstore(add(ptr,0x24), amount) // token amount\n\n            let result := call(\n                gas(), // gas limit\n                tokenAddress,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n\n    }\n\n    function wethDeposit(uint amountIn) internal {\n        assembly {\n\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n            /************************* WETH deposit ************************/\n\n            // put deposit function signature at memory spot\n            mstore(ptr, 0xd0e30db000000000000000000000000000000000000000000000000000000000) // sig = 0xd0e30db0\n\n            let result := call(\n                gas(), // gas limit\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,  // WETH contract\n                amountIn, // eth deposit\n                ptr, // Inputs are stored at location ptr\n                0x04, // Inputs are 4 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    \n    function wethWithdraw(uint amountOut) internal {        \n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            // put withdraw function signature at memory spot\n            mstore(ptr, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000) // sig = 0x2e1a7d4d\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), amountOut) // amount to withdraw\n\n            let result := call(\n                gas(), // gas limit\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x24, // Inputs are 36 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0,0)\n            }\n        }\n\n        payable(msg.sender).transfer(amountOut);\n    }\n \n    function v2GetTokenAmountOut(address pairAddress, bool zeroForOne, uint amountIn) internal returns (uint amountOut) {\n        uint reserve0;\n        uint reserve1;\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            // put getReserves function signature at memory spot\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000) // sig = 0x0902f1ac\n\n            let result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                4, // Inputs are 4 bytes long\n                ptr,  //Store output over input\n                96) //Outputs are 96 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0, 32)\n            reserve0 := mload(ptr)\n\n            returndatacopy(ptr, 32, 32)\n            reserve1 := mload(ptr)\n\n            // calculating amounts out\n            if eq(zeroForOne, 1) {\n                // token 1 out\n                amountOut := div(mul(mul(reserve1, amountIn), 997), add(mul(1000, reserve0),mul(amountIn, 997)))\n            }\n\n            if eq(zeroForOne, 0) {\n                // token 0 out\n                amountOut := div(mul(mul(reserve0, amountIn), 997), add(mul(1000, reserve1),mul(amountIn, 997)))\n            }\n        }\n    }\n\n    function v2GetTokenAmountIn(address pairAddress, bool zeroForOne, uint maxAmountOut) internal returns (uint amountIn) {\n        uint reserve0;\n        uint reserve1;\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            // put getReserves function signature at memory spot\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000) // sig = 0x0902f1ac\n\n            let result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                4, // Inputs are 4 bytes long\n                ptr,  //Store output over input\n                96) //Outputs are 96 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0, 32)\n            reserve0 := mload(ptr)\n\n            returndatacopy(ptr, 32, 32)\n            reserve1 := mload(ptr)\n\n            // calculating amounts out\n            if eq(zeroForOne, 1) {\n                // token 1 out\n                amountIn := mul(div(1000, 997), div(mul(maxAmountOut, reserve0), sub(reserve1, maxAmountOut)))\n            }\n\n            if eq(zeroForOne, 0) {\n                // token 0 out\n                amountIn := mul(div(1000, 997), div(mul(maxAmountOut, reserve1), sub(reserve0, maxAmountOut)))\n            }\n        }\n    }\n\n    function v2GetETHAmountOut(address pairAddress, bool zeroForOne, address tokenInAddress) internal returns (uint amountOut) {\n        uint reserve0;\n        uint reserve1;\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            /************* Get Balance ************/\n            // put balanceOf function signature at memory spot\n            mstore(ptr, 0x70a0823100000000000000000000000000000000000000000000000000000000) // sig = 0x70a08231\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), pairAddress) // address\n\n            let result := call(\n                gas(), // gas limit\n                tokenInAddress,  // token contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x24, // Inputs are 36 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0,0)\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0x0, 0x20)\n            let pairBalance := mload(ptr)\n\n            /************* Get Reserves ************/\n            // put getReserves function signature at memory spot\n            mstore(ptr, 0x0902f1ac00000000000000000000000000000000000000000000000000000000) // sig = 0x0902f1ac\n\n            result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                4, // Inputs are 4 bytes long\n                ptr,  //Store output over input\n                96) //Outputs are 96 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n            // Storing outputs\n            returndatacopy(ptr, 0, 32)\n            reserve0 := mload(ptr)\n\n            returndatacopy(ptr, 32, 32)\n            reserve1 := mload(ptr)\n\n            /************* Estimate AmountIn ************/\n            let reserve\n            if eq(zeroForOne, 1) {\n                // reserve 0 needed\n                reserve := reserve0\n            }\n\n            if eq(zeroForOne, 0) {\n                // reserve 1 needed\n                reserve := reserve1\n            }  \n\n            let amountIn := sub(pairBalance, reserve)\n\n            // calculating amounts out\n            if eq(zeroForOne, 1) {\n                // token 1 out\n                amountOut := div(mul(mul(reserve1, amountIn), 997), add(mul(1000, reserve0),mul(amountIn, 997)))\n            }\n\n            if eq(zeroForOne, 0) {\n                // token 0 out\n                amountOut := div(mul(mul(reserve0, amountIn), 997), add(mul(1000, reserve1),mul(amountIn, 997)))\n            }\n        }\n    }\n\n    function v2SwapETHtoToken(address pairAddress, bool zeroForOne) external payable onlyOwner {        \n        uint amountIn = msg.value;\n\n        wethDeposit(amountIn);\n\n        uint amountOut = v2GetTokenAmountOut(pairAddress, zeroForOne, amountIn);\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n            \n\n            /************************* WETH transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), pairAddress) // address dest\n            mstore(add(ptr,0x24), amountIn) // WETH amount\n\n            let result := call(\n                gas(), // gas limit\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n\n            /************************* Swap ************************/\n\n            // put swap function signature at memory spot\n            mstore(ptr, 0x022c0d9f00000000000000000000000000000000000000000000000000000000) // sig = 0x022c0d9f\n\n            // append arguments after function signature\n            if eq(zeroForOne, 1) {\n                mstore(add(ptr,0x04), 0) // amount0Out\n                mstore(add(ptr,0x24), amountOut) // amount1Out\n            }\n            if eq(zeroForOne, 0) {\n                mstore(add(ptr,0x04), amountOut) // amount0Out\n                mstore(add(ptr,0x24), 0) // amount1Out\n            }\n            mstore(add(ptr,0x44), address()) // address to \n            mstore(add(ptr,0x64), 0x80) // data \n            mstore(add(ptr,0x84), 0x0) // data \n            \n            result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0xa4, // Inputs are 132 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n    }\n\n    function v2SwapTokenToETH(address pairAddress, bool zeroForOne, uint amountIn, address tokenInAddress) external onlyOwner {   \n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n\n            /************************* token transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), pairAddress) // address dest\n            mstore(add(ptr,0x24), amountIn) // token amount\n\n            let result := call(\n                gas(), // gas limit\n                tokenInAddress,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n\n        uint amountOut = v2GetETHAmountOut(pairAddress, zeroForOne, tokenInAddress);\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n\n            /************************* Swap ************************/\n\n            // put swap function signature at memory spot\n            mstore(ptr, 0x022c0d9f00000000000000000000000000000000000000000000000000000000) // sig = 0x022c0d9f\n\n            // append arguments after function signature\n            if eq(zeroForOne, 1) {\n                mstore(add(ptr,0x04), 0) // amount0Out\n                mstore(add(ptr,0x24), amountOut) // amount1Out\n            }\n            if eq(zeroForOne, 0) {\n                mstore(add(ptr,0x04), amountOut) // amount0Out\n                mstore(add(ptr,0x24), 0) // amount1Out\n            }\n            mstore(add(ptr,0x44), address()) // address to \n            mstore(add(ptr,0x64), 0x80) // data \n            mstore(add(ptr,0x84), 0x0) // data \n            \n            let result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0xa4, // Inputs are 132 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n\n        wethWithdraw((amountOut));\n    }\n\n    function v2SwapETHforExactToken(address pairAddress, bool zeroForOne, uint maxAmountOut) external payable onlyOwner {\n        uint maxAmountIn = v2GetTokenAmountIn(pairAddress, zeroForOne, maxAmountOut);\n\n        uint amountIn;\n        uint amountOut;\n\n        if (maxAmountIn > msg.value) {\n            amountIn = msg.value;\n            amountOut = v2GetTokenAmountOut(pairAddress, zeroForOne, amountIn);\n        }\n        else {\n            amountIn = maxAmountIn;\n            amountOut = maxAmountOut;\n        }\n\n        wethDeposit(amountIn);\n\n        assembly {\n            // move pointer to free memory spot\n            let ptr := mload(0x40)\n            \n\n            /************************* WETH transfer ************************/\n\n            // put transfer function signature at memory spot\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // sig = 0xa9059cbb\n\n            // append arguments after function signature\n            mstore(add(ptr,0x04), pairAddress) // address dest\n            mstore(add(ptr,0x24), amountIn) // WETH amount\n\n            let result := call(\n                gas(), // gas limit\n                0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,  // WETH contract\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0x44, // Inputs are 68 bytes long\n                ptr,  //Store output over input\n                0x20) //Outputs are 32 bytes long\n            \n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n\n\n            /************************* Swap ************************/\n\n            // put swap function signature at memory spot\n            mstore(ptr, 0x022c0d9f00000000000000000000000000000000000000000000000000000000) // sig = 0x022c0d9f\n\n            // append arguments after function signature\n            if eq(zeroForOne, 1) {\n                mstore(add(ptr,0x04), 0) // amount0Out\n                mstore(add(ptr,0x24), amountOut) // amount1Out\n            }\n            if eq(zeroForOne, 0) {\n                mstore(add(ptr,0x04), amountOut) // amount0Out\n                mstore(add(ptr,0x24), 0) // amount1Out\n            }\n            mstore(add(ptr,0x44), address()) // address to \n            mstore(add(ptr,0x64), 0x80) // data \n            mstore(add(ptr,0x84), 0x0) // data \n            \n            result := call(\n                gas(), // gas limit\n                pairAddress,  // transaction sent to\n                0, // not transfer any ether\n                ptr, // Inputs are stored at location ptr\n                0xa4, // Inputs are 132 bytes long\n                ptr,  //Store output over input\n                0x0) //Outputs are 0 bytes long\n\n            if eq(result, 0) {\n                revert(0, returndatasize())\n            }\n            \n        }\n\n        // return ETH non utilisés\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n\n\n}\n"}}}