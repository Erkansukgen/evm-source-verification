{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Bot.sol": {
      "content": "pragma solidity =0.6.6;\r\n\r\ncontract BwareUniswapBot {\r\n    \r\n    address payable private owner;\r\n    \r\n    address constant uniswap_router_v2 = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    address constant uniswap_factory_v2 = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n    \r\n    address private tokenAddress;\r\n    uint256 private etherAmountToSell;\r\n    \r\n    \r\n    constructor () public { owner = msg.sender; }\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"only owner can call this function.\");\r\n        _;\r\n    }\r\n    \r\n    function changeOwner(address payable _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    function getCurrentOwner() public view returns(address) {\r\n        return owner;\r\n    }\r\n    \r\n    function withdrawETH() public onlyOwner returns(bool success) {\r\n        owner.transfer(address(this).balance);\r\n        return true;\r\n    }\r\n    \r\n    function withdrawToken() public onlyOwner returns(bool) {\r\n        if (tokenAddress != address(0)) {\r\n            // get token balance of bot contract\r\n            (, bytes memory bytesBalance) = tokenAddress.call(abi.encodeWithSignature(\"balanceOf(address)\", this));\r\n            uint256 tokenBalance = abi.decode(bytesBalance, (uint256));\r\n            \r\n            // transfer the owned tokens to the owner\r\n            (bool success, ) = tokenAddress.call(abi.encodeWithSignature(\"transfer(address,uint256)\", owner, tokenBalance));\r\n            require(success, \"Could not transfer assets\");\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function getTokenAddress() public view returns(address) {\r\n        return tokenAddress;\r\n    }\r\n    \r\n    function getETHToSell() public view returns(uint256) {\r\n        return etherAmountToSell;\r\n    }\r\n    \r\n    event Address(address toPrint);\r\n    event TokensOut(uint256 tokensAmount);\r\n    event EtherOut(uint256 ethAmount);\r\n    event Reserves(uint256 ethReserve, uint256 tokenReserve);\r\n    \r\n\r\n    function getRealTimeReserves() private returns(uint256, uint256, address) {\r\n        \r\n        (bool get_weth_addr, bytes memory bytesWETHAddr) = uniswap_router_v2.call(abi.encodeWithSignature(\"WETH()\"));\r\n        require(get_weth_addr, \"Could not fetch WETH contract address\");\r\n        address wethAddress = abi.decode(bytesWETHAddr, (address));\r\n        \r\n        // sort the tokens addresses\r\n        (address token0, address token1) = wethAddress < tokenAddress ? (wethAddress, tokenAddress) : (tokenAddress, wethAddress);\r\n        \r\n        (bool get_pair_addr, bytes memory bytesPairAddress) = uniswap_factory_v2.call(abi.encodeWithSignature(\"getPair(address,address)\", token0, token1));\r\n        require(get_pair_addr, \"Could not fetch the pair address\");\r\n        address pairAddress = abi.decode(bytesPairAddress, (address));\r\n        emit Address(pairAddress);\r\n        \r\n        (bool success, bytes memory bytesReserves) = pairAddress.call(abi.encodeWithSignature(\"getReserves()\"));\r\n        (uint256 reserve0, uint256 reserve1, ) = abi.decode(bytesReserves, (uint256,uint256,uint32));\r\n        require(success);\r\n        \r\n        // make sure weth reserve is the first one returned\r\n        (reserve0, reserve1) = wethAddress == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        emit Reserves(reserve0, reserve1);\r\n        \r\n        return (reserve0, reserve1, wethAddress);\r\n    }\r\n    \r\n    function swapBwareETH(address token, uint256 slippage, uint256 gasLeftLimit) external payable onlyOwner returns (uint256) {\r\n        \r\n        tokenAddress = token;\r\n        etherAmountToSell = msg.value;\r\n\r\n        (uint256 reserveETH, uint256 reserveToken, address wethAddress) = getRealTimeReserves();\r\n        require(reserveETH > 0 && reserveToken > 0, \"No Liquidity in the pool\");\r\n        \r\n        uint256 amountInWithFee = etherAmountToSell * 997;\r\n        uint256 numerator = amountInWithFee * reserveToken;\r\n        uint256 denominator = reserveETH * 1000 + amountInWithFee;\r\n        uint256 amountOutMin = numerator / denominator * (100 - slippage) / 100;\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = wethAddress;\r\n        path[1] = tokenAddress;\r\n        \r\n        (bool success, bytes memory bytesBuyResult) = uniswap_router_v2.call{gas: gasleft(), value: etherAmountToSell}(abi.encodeWithSignature(\"swapExactETHForTokens(uint256,address[],address,uint256)\", amountOutMin, path, this, block.timestamp + 300));\r\n        require(success, \"The buying of tokens failed\");\r\n        uint256 realAmountOut = abi.decode(bytesBuyResult, (uint256[]))[1];\r\n        emit TokensOut(realAmountOut);\r\n        \r\n        while (gasleft() > gasLeftLimit) {}\r\n        return realAmountOut;\r\n    }\r\n    \r\n    function approveUniswapRouter() private {\r\n        uint256 MAX_INT = 2**256 - 1;\r\n        (bool approve_status, ) = tokenAddress.call(abi.encodeWithSignature(\"approve(address,uint256)\", uniswap_router_v2, MAX_INT));\r\n        require(approve_status, \"Could not approve router\");\r\n    }\r\n    \r\n    function swapBwareTokens(uint256 slippage, uint256 lossPercent, uint256 gainPercent) external onlyOwner returns (uint256) {\r\n         \r\n        (bool get_token_balance, bytes memory bytesTokenBalance) = tokenAddress.call(abi.encodeWithSignature(\"balanceOf(address)\", this));\r\n        require(get_token_balance, \"Could not get token balance\");\r\n        \r\n        uint256 amountTokenIn = abi.decode(bytesTokenBalance, (uint256));\r\n        require(amountTokenIn > 0, \"Token balance is 0\");\r\n        emit TokensOut(amountTokenIn);\r\n        \r\n        (uint256 reserveETH, uint256 reserveToken, address wethAddress) = getRealTimeReserves();\r\n        uint256 amountInWithFee = amountTokenIn * 997;\r\n        uint256 numerator = amountInWithFee * reserveETH;\r\n        uint256 denominator = reserveToken * 1000 + amountInWithFee;\r\n        uint256 amountOutMin = numerator / denominator * (100 - slippage) / 100;\r\n        \r\n        approveUniswapRouter();\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenAddress; // keep this order\r\n        path[1] = wethAddress;\r\n        \r\n        if (amountOutMin <= (lossPercent * etherAmountToSell / 100) || amountOutMin >= (gainPercent * etherAmountToSell / 100)) {\r\n            (bool success, bytes memory bytesSellResult) = uniswap_router_v2.call{gas: gasleft()}(abi.encodeWithSignature(\"swapExactTokensForETH(uint256,uint256,address[],address,uint256)\", amountTokenIn, amountOutMin, path, owner, block.timestamp + 600));\r\n            require(success, \"The selling of tokens failed\");\r\n            \r\n            uint256 realAmountOut = abi.decode(bytesSellResult, (uint256[]))[1];\r\n            emit TokensOut(realAmountOut);\r\n            return realAmountOut;\r\n        }\r\n        \r\n        return uint256(0);\r\n     }\r\n}"
    }
  }
}