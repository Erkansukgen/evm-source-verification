{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "MoonCatResolver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity 0.8.1;\r\n\r\ninterface IMoonCatAcclimator {\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\ninterface IMoonCatRescue {\r\n    function rescueOrder(uint256 tokenId) external view returns (bytes5);\r\n    function catOwners(bytes5 catId) external view returns (address);\r\n}\r\n\r\ninterface IReverseResolver {\r\n    function claim(address owner) external returns (bytes32);\r\n}\r\n\r\ninterface IRegistry {\r\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function owner(bytes32 node) external view returns (address);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\ninterface IERC721 {\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\n/**\r\n * @title MoonCatResolver\r\n * @notice ENS Resolver for MoonCat subdomains\r\n * @dev Auto-updates to point to the owner of that specific MoonCat\r\n */\r\ncontract MoonCatResolver {\r\n\r\n    /* External Contracts */\r\n    IMoonCatAcclimator MCA = IMoonCatAcclimator(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69);\r\n    IMoonCatRescue MCR = IMoonCatRescue(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6);\r\n\r\n\r\n    /* State */\r\n    mapping(bytes32 => uint256) internal NamehashMapping; // ENS namehash => Rescue ID of MoonCat\r\n    mapping(uint256 => mapping(uint256 => bytes)) internal MultichainMapping; // Rescue ID of MoonCat => Multichain ID => value\r\n    mapping(uint256 => mapping(string => string)) internal TextKeyMapping; // Rescue ID of MoonCat => text record key => value\r\n    mapping(uint256 => bytes) internal ContentsMapping; // Rescue ID of MoonCat => content hash\r\n    mapping(uint256 => address) internal lastAnnouncedAddress; // Rescue ID of MoonCat => address that was last emitted in an AddrChanged Event\r\n\r\n    address payable public owner;\r\n    bytes32 immutable public rootHash;\r\n    string public ENSDomain; // Reference for the ENS domain this contract resolves\r\n    string public avatarBaseURI = \"eip155:1/erc721:0xc3f733ca98e0dad0386979eb96fb1722a1a05e69/\";\r\n    uint64 public defaultTTL = 86400;\r\n\r\n    // For string-matching on a specific text key\r\n    uint256 constant internal avatarKeyLength = 6;\r\n    bytes32 constant internal avatarKeyHash = keccak256(\"avatar\");\r\n\r\n    /* Events */\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    /* Modifiers */\r\n    modifier onlyOwner () {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMoonCatOwner (uint256 rescueOrder) {\r\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == address(MCA), \"Not Acclimated\");\r\n        require(msg.sender == MCA.ownerOf(rescueOrder), \"Not MoonCat's owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Deploy resolver contract.\r\n     */\r\n    constructor(bytes32 _rootHash, string memory _ENSDomain){\r\n        owner = payable(msg.sender);\r\n        rootHash = _rootHash;\r\n        ENSDomain = _ENSDomain;\r\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\r\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148)\r\n            .claim(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow current `owner` to transfer ownership to another address\r\n     */\r\n    function transferOwnership (address payable newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the \"avatar\" value that gets set by default.\r\n     */\r\n    function setAvatarBaseUrl(string calldata url) public onlyOwner {\r\n        avatarBaseURI = url;\r\n    }\r\n\r\n    /**\r\n     * @dev Update the default TTL value.\r\n     */\r\n    function setDefaultTTL(uint64 newTTL) public onlyOwner {\r\n        defaultTTL = newTTL;\r\n    }\r\n\r\n    /**\r\n     * @dev Pass ownership of a subnode of the contract's root hash to the owner.\r\n     */\r\n    function giveControl(bytes32 nodeId) public onlyOwner {\r\n        IRegistry(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e).setSubnodeOwner(rootHash, nodeId, owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC20 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC20(address tokenContract) public onlyOwner {\r\n        IERC20 token = IERC20(tokenContract);\r\n        token.transfer(owner, token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Rescue ERC721 assets sent directly to this contract.\r\n     */\r\n    function withdrawForeignERC721(address tokenContract, uint256 tokenId) public onlyOwner {\r\n        IERC721(tokenContract).safeTransferFrom(address(this), owner, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev ERC165 support for ENS resolver interface\r\n     * https://docs.ens.domains/contract-developer-guide/writing-a-resolver\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == 0x01ffc9a7 // supportsInterface call itself\r\n            || interfaceID == 0x3b3b57de // EIP137: ENS resolver\r\n            || interfaceID == 0xf1cb7e06 // EIP2304: Multichain addresses\r\n            || interfaceID == 0x59d1d43c // EIP634: ENS text records\r\n            || interfaceID == 0xbc1c58d1 // EIP1577: contenthash\r\n        ;\r\n    }\r\n\r\n    /**\r\n     * @dev For a given ENS Node ID, return the Ethereum address it points to.\r\n     * EIP137 core functionality\r\n     */\r\n    function addr(bytes32 nodeID) public view returns (address) {\r\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\r\n        address actualOwner = MCA.ownerOf(rescueOrder);\r\n        if (\r\n            MCR.catOwners(MCR.rescueOrder(rescueOrder)) != address(MCA) ||\r\n            actualOwner != lastAnnouncedAddress[rescueOrder]\r\n        ) {\r\n            return address(0); // Not Acclimated/Announced; return zero (per spec)\r\n        } else {\r\n            return lastAnnouncedAddress[rescueOrder];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev For a given ENS Node ID, return an address on a different blockchain it points to.\r\n     * EIP2304 functionality\r\n     */\r\n    function addr(bytes32 nodeID, uint256 coinType) public view returns (bytes memory) {\r\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\r\n        if (MCR.catOwners(MCR.rescueOrder(rescueOrder)) != address(MCA)) {\r\n            return bytes(''); // Not Acclimated; return zero (per spec)\r\n        }\r\n        if (coinType == 60) {\r\n            // Ethereum address\r\n            return abi.encodePacked(addr(nodeID));\r\n        } else {\r\n            return MultichainMapping[rescueOrder][coinType];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev For a given ENS Node ID, set it to point to an address on a different blockchain.\r\n     * EIP2304 functionality\r\n     */\r\n    function setAddr(bytes32 nodeID, uint256 coinType, bytes calldata newAddr) public {\r\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\r\n        setAddr(rescueOrder, coinType, newAddr);\r\n    }\r\n\r\n    /**\r\n     * @dev For a given MoonCat rescue order, set the subdomains associated with it to point to an address on a different blockchain.\r\n     */\r\n    function setAddr(uint256 rescueOrder, uint256 coinType, bytes calldata newAddr) public onlyMoonCatOwner(rescueOrder) {\r\n        if (coinType == 60) {\r\n            // Ethereum address\r\n            announceMoonCat(rescueOrder);\r\n            return;\r\n        }\r\n        emit AddressChanged(getSubdomainNameHash(uint2str(rescueOrder)), coinType, newAddr);\r\n        emit AddressChanged(getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder))), coinType, newAddr);\r\n        MultichainMapping[rescueOrder][coinType] = newAddr;\r\n    }\r\n\r\n    /**\r\n     * @dev For a given ENS Node ID, return the value associated with a given text key.\r\n     * If the key is \"avatar\", and the matching value is not explicitly set, a url pointing to the MoonCat's image is returned\r\n     * EIP634 functionality\r\n     */\r\n    function text(bytes32 nodeID, string calldata key) public view returns (string memory) {\r\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\r\n\r\n        string memory value = TextKeyMapping[rescueOrder][key];\r\n        if (bytes(value).length > 0) {\r\n            // This value has been set explicitly; return that\r\n            return value;\r\n        }\r\n\r\n        // Check if there's a default value for this key\r\n        bytes memory keyBytes = bytes(key);\r\n        if (keyBytes.length == avatarKeyLength && keccak256(keyBytes) == avatarKeyHash){\r\n            // Avatar default\r\n            return string(abi.encodePacked(avatarBaseURI,  uint2str(rescueOrder)));\r\n        }\r\n\r\n        // No default; just return the empty string\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @dev Update a text record for a specific subdomain.\r\n     * EIP634 functionality\r\n     */\r\n    function setText(bytes32 nodeID, string calldata key, string calldata value) public {\r\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\r\n        setText(rescueOrder, key, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Update a text record for subdomains owned by a specific MoonCat rescue order.\r\n     */\r\n    function setText(uint256 rescueOrder, string calldata key, string calldata value) public onlyMoonCatOwner(rescueOrder) {\r\n        bytes memory keyBytes = bytes(key);\r\n        bytes32 orderHash = getSubdomainNameHash(uint2str(rescueOrder));\r\n        bytes32 hexHash = getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder)));\r\n\r\n        if (bytes(value).length == 0 && keyBytes.length == avatarKeyLength && keccak256(keyBytes) == avatarKeyHash){\r\n            // Avatar default\r\n            string memory avatarRecordValue = string(abi.encodePacked(avatarBaseURI,  uint2str(rescueOrder)));\r\n            emit TextChanged(orderHash, key, avatarRecordValue);\r\n            emit TextChanged(hexHash, key, avatarRecordValue);\r\n        } else {\r\n            emit TextChanged(orderHash, key, value);\r\n            emit TextChanged(hexHash, key, value);\r\n        }\r\n        TextKeyMapping[rescueOrder][key] = value;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the \"content hash\" of a given subdomain.\r\n     * EIP1577 functionality\r\n     */\r\n    function contenthash(bytes32 nodeID) public view returns (bytes memory) {\r\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\r\n        return ContentsMapping[rescueOrder];\r\n    }\r\n\r\n    /**\r\n     * @dev Update the \"content hash\" of a given subdomain.\r\n     * EIP1577 functionality\r\n     */\r\n    function setContenthash(bytes32 nodeID, bytes calldata hash) public {\r\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\r\n        setContenthash(rescueOrder, hash);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the \"content hash\" of a given MoonCat's subdomains.\r\n     */\r\n    function setContenthash(uint256 rescueOrder, bytes calldata hash) public onlyMoonCatOwner(rescueOrder) {\r\n        emit ContenthashChanged(getSubdomainNameHash(uint2str(rescueOrder)), hash);\r\n        emit ContenthashChanged(getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder))), hash);\r\n        ContentsMapping[rescueOrder] = hash;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the TTL for a given MoonCat's subdomains.\r\n     */\r\n    function setTTL(uint rescueOrder, uint64 newTTL) public onlyMoonCatOwner(rescueOrder) {\r\n        IRegistry registry = IRegistry(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\r\n        registry.setTTL(getSubdomainNameHash(uint2str(rescueOrder)), newTTL);\r\n        registry.setTTL(getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder))), newTTL);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow calling multiple functions on this contract in one transaction.\r\n     */\r\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n            require(success);\r\n            results[i] = result;\r\n        }\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * @dev Reverse lookup for ENS Node ID, to determine the MoonCat rescue order of the MoonCat associated with it.\r\n     */\r\n    function getRescueOrderFromNodeId(bytes32 nodeID) public view returns (uint256) {\r\n        uint256 rescueOrder = NamehashMapping[nodeID];\r\n        if (rescueOrder == 0) {\r\n            // Are we actually dealing with MoonCat #0?\r\n            require(\r\n                nodeID == 0x8bde039a2a7841d31e0561fad9d5cfdfd4394902507c72856cf5950eaf9e7d5a // 0.ismymooncat.eth\r\n                || nodeID == 0x1002474938c26fb23080c33c3db026c584b30ec6e7d3edf4717f3e01e627da26, // 0x00d658d50b.ismymooncat.eth\r\n                \"Unknown Node ID\"\r\n            );\r\n        }\r\n        return rescueOrder;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the \"namehash\" of a specific domain, using the ENS standard algorithm.\r\n     * The namehash of 'ismymooncat.eth' is 0x204665c32985055ed5daf374d6166861ba8892a3b0849d798c919fffe38a1a15\r\n     * The namehash of 'foo.ismymooncat.eth' is keccak256(0x204665c32985055ed5daf374d6166861ba8892a3b0849d798c919fffe38a1a15, keccak256('foo'))\r\n     */\r\n    function getSubdomainNameHash(string memory subdomain) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(rootHash, keccak256(abi.encodePacked(subdomain))));\r\n    }\r\n\r\n    /**\r\n     * @dev Cache a single MoonCat's (identified by Rescue Order) subdomain hashes.\r\n     */\r\n    function mapMoonCat(uint256 rescueOrder) public {\r\n        string memory orderSubdomain = uint2str(rescueOrder);\r\n        string memory hexSubdomain = bytes5ToHexString(MCR.rescueOrder(rescueOrder));\r\n\r\n        bytes32 orderHash = getSubdomainNameHash(orderSubdomain);\r\n        bytes32 hexHash = getSubdomainNameHash(hexSubdomain);\r\n\r\n        if (uint256(NamehashMapping[orderHash]) != 0) {\r\n            // Already Mapped\r\n            return;\r\n        }\r\n\r\n        NamehashMapping[orderHash] = rescueOrder;\r\n        NamehashMapping[hexHash] = rescueOrder;\r\n\r\n        if(MCR.catOwners(MCR.rescueOrder(rescueOrder)) != address(MCA)) {\r\n            // MoonCat is not Acclimated\r\n            return;\r\n        }\r\n\r\n        IRegistry registry = IRegistry(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\r\n        registry.setSubnodeRecord(rootHash, keccak256(bytes(orderSubdomain)), address(this), address(this), defaultTTL);\r\n        registry.setSubnodeRecord(rootHash, keccak256(bytes(hexSubdomain)), address(this), address(this), defaultTTL);\r\n\r\n        address moonCatOwner = MCA.ownerOf(rescueOrder);\r\n        lastAnnouncedAddress[rescueOrder] = moonCatOwner;\r\n        emit AddrChanged(orderHash, moonCatOwner);\r\n        emit AddrChanged(hexHash, moonCatOwner);\r\n        emit AddressChanged(orderHash, 60, abi.encodePacked(moonCatOwner));\r\n        emit AddressChanged(hexHash, 60, abi.encodePacked(moonCatOwner));\r\n\r\n        string memory avatarRecordValue = string(abi.encodePacked(avatarBaseURI,  uint2str(rescueOrder)));\r\n        emit TextChanged(orderHash, \"avatar\", avatarRecordValue);\r\n        emit TextChanged(hexHash, \"avatar\", avatarRecordValue);\r\n    }\r\n\r\n    /**\r\n     * @dev Announce a single MoonCat's (identified by Rescue Order) assigned address.\r\n     */\r\n    function announceMoonCat(uint256 rescueOrder) public {\r\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == address(MCA), \"Not Acclimated\");\r\n        address moonCatOwner = MCA.ownerOf(rescueOrder);\r\n\r\n        lastAnnouncedAddress[rescueOrder] = moonCatOwner;\r\n        bytes32 orderHash = getSubdomainNameHash(uint2str(rescueOrder));\r\n        bytes32 hexHash = getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder)));\r\n\r\n        emit AddrChanged(orderHash, moonCatOwner);\r\n        emit AddrChanged(hexHash, moonCatOwner);\r\n        emit AddressChanged(orderHash, 60, abi.encodePacked(moonCatOwner));\r\n        emit AddressChanged(hexHash, 60, abi.encodePacked(moonCatOwner));\r\n    }\r\n\r\n    /**\r\n     * @dev Has an AddrChanged event been emitted for the current owner of a MoonCat (identified by Rescue Order)?\r\n     */\r\n    function needsAnnouncing(uint256 rescueOrder) public view returns (bool) {\r\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == address(MCA), \"Not Acclimated\");\r\n        return lastAnnouncedAddress[rescueOrder] != MCA.ownerOf(rescueOrder);\r\n    }\r\n\r\n    /**\r\n     * @dev Convenience function to iterate through all MoonCats owned by an address to check if they need announcing.\r\n     */\r\n    function needsAnnouncing(address moonCatOwner) public view returns (uint256[] memory) {\r\n        uint256 balance = MCA.balanceOf(moonCatOwner);\r\n        uint256 announceCount = 0;\r\n        uint256[] memory tempRescueOrders = new uint256[](balance);\r\n        for (uint256 i = 0; i < balance; i++) {\r\n            uint256 rescueOrder = MCA.tokenOfOwnerByIndex(moonCatOwner, i);\r\n            if (lastAnnouncedAddress[rescueOrder] != moonCatOwner){\r\n                tempRescueOrders[announceCount] = rescueOrder;\r\n                announceCount++;\r\n            }\r\n        }\r\n        uint256[] memory rescueOrders = new uint256[](announceCount);\r\n        for (uint256 i = 0; i < announceCount; i++){\r\n            rescueOrders[i] = tempRescueOrders[i];\r\n        }\r\n        return rescueOrders;\r\n    }\r\n\r\n    /**\r\n     * @dev Convenience function to iterate through all MoonCats owned by sender to check if they need announcing.\r\n     */\r\n    function needsAnnouncing() public view returns (uint256[] memory) {\r\n        return needsAnnouncing(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Set a manual list of MoonCats (identified by Rescue Order) to announce or cache their subdomain hashes.\r\n     */\r\n    function mapMoonCats(uint256[] memory rescueOrders) public {\r\n        for (uint256 i = 0; i < rescueOrders.length; i++) {\r\n            address lastAnnounced = lastAnnouncedAddress[rescueOrders[i]];\r\n            if (lastAnnounced == address(0)){\r\n                mapMoonCat(rescueOrders[i]);\r\n            } else if (lastAnnounced != MCA.ownerOf(rescueOrders[i])){\r\n                announceMoonCat(rescueOrders[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Convenience function to iterate through all MoonCats owned by an address and announce or cache their subdomain hashes.\r\n     */\r\n    function mapMoonCats(address moonCatOwner) public {\r\n        for (uint256 i = 0; i < MCA.balanceOf(moonCatOwner); i++) {\r\n            uint256 rescueOrder = MCA.tokenOfOwnerByIndex(moonCatOwner, i);\r\n            address lastAnnounced = lastAnnouncedAddress[rescueOrder];\r\n            if (lastAnnounced == address(0)){\r\n                mapMoonCat(rescueOrder);\r\n            } else if (lastAnnounced != moonCatOwner){\r\n                announceMoonCat(rescueOrder);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Convenience function to iterate through all MoonCats owned by the sender and announce or cache their subdomain hashes.\r\n     */\r\n    function mapMoonCats() public {\r\n        mapMoonCats(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Utility function to convert a bytes5 variable into a hexadecimal string.\r\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\r\n     */\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    function bytes5ToHexString(bytes5 x) internal pure returns (string memory) {\r\n        uint256 length = 5;\r\n        uint256 value = uint256(uint40(x));\r\n\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        //require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Utility function to convert a uint256 variable into a decimal string.\r\n     */\r\n    function uint2str(uint value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n}\r\n"
    }
  }
}