{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"TokenERC20.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io\r\n*/\r\n\r\n/***\r\n\r\n   * https://ethcities.com\r\n\r\n* MIT License\r\n* ===========\r\n*\r\n* Copyright (c) 2020 Ethereum Cities\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n\r\n\r\npragma solidity >=0.5.10;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\n\r\n // File: contracts/library/ETCtoken.sol\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n\r\n  function add(uint a, uint b) internal pure returns (uint c) {\r\n    c = a + b;\r\n    require(c >= a);\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint c) {\r\n    require(b <= a);\r\n    c = a - b;\r\n  }\r\n\r\n  function mul(uint a, uint b) internal pure returns (uint c) {\r\n    c = a * b;\r\n    require(a == 0 || c / a == b);\r\n  }\r\n  function div(uint a, uint b) internal pure returns (uint c) {\r\n    require(b > 0);\r\n    c = a / b;\r\n  }\r\n}\r\n /**\r\n * @notice Construct a new ETC token\r\n *\r\n*/\r\n\r\ncontract ERC20Interface {\r\n  function totalSupply() public view returns (uint);\r\n  function balanceOf(address tokenOwner) public view returns (uint balance);\r\n  function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n  function transfer(address to, uint tokens) public returns (bool success);\r\n  function approve(address spender, uint tokens) public returns (bool success);\r\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint tokens);\r\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n  function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;\r\n}\r\n\r\ncontract Owned {\r\n  address public owner;\r\n  address public newOwner;\r\n\r\n  event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    newOwner = _newOwner;\r\n  }\r\n  function acceptOwnership() public {\r\n    require(msg.sender == newOwner);\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n    newOwner = address(0);\r\n  }\r\n}\r\n// File: contracts/library/Governance.sol\r\n\r\ncontract Governance {\r\n\r\n    address public _governance;\r\n\r\n    constructor() public {\r\n        _governance = tx.origin;\r\n    }\r\n\r\n    event GovernanceTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyGovernance {\r\n        require(msg.sender == _governance, \"not governance\");\r\n        _;\r\n    }\r\n\r\n    function setGovernance(address governance)  public  onlyGovernance\r\n    {\r\n        require(governance != address(0), \"new governance the zero address\");\r\n        emit GovernanceTransferred(_governance, governance);\r\n        _governance = governance;\r\n    }\r\n\r\n\r\n}\r\n\r\n/// @title ETC Token Contract\r\n\r\ncontract TokenERC20 is ERC20Interface, Owned{\r\n  using SafeMath for uint;\r\n\r\n  string public symbol;\r\n  string public name;\r\n  uint8 public decimals;\r\n  uint _totalSupply;\r\n\r\n  mapping(address => uint) balances;\r\n  mapping(address => mapping(address => uint)) allowed;\r\n\r\n /**\r\n     * CONSTRUCTOR\r\n     *\r\n     * @dev Initialize the Token\r\n     */\r\n\r\n  constructor() public {\r\n    symbol = \"ETC\";\r\n    name = \"EthCities \";\r\n    decimals = 8;\r\n    _totalSupply = 10**8 * 10**uint(decimals);\r\n    balances[owner] = _totalSupply;\r\n    emit Transfer(address(0), owner, _totalSupply);\r\n  }\r\n\r\n  function totalSupply() public view returns (uint) {\r\n    return _totalSupply.sub(balances[address(0)]);\r\n  }\r\n  function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n      return balances[tokenOwner];\r\n  }\r\n  function transfer(address to, uint tokens) public returns (bool success) {\r\n    balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n    balances[to] = balances[to].add(tokens);\r\n    emit Transfer(msg.sender, to, tokens);\r\n    return true;\r\n  }\r\n  function approve(address spender, uint tokens) public returns (bool success) {\r\n    allowed[msg.sender][spender] = tokens;\r\n    emit Approval(msg.sender, spender, tokens);\r\n    return true;\r\n  }\r\n  function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n    balances[from] = balances[from].sub(tokens);\r\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n    balances[to] = balances[to].add(tokens);\r\n    emit Transfer(from, to, tokens);\r\n    return true;\r\n  }\r\n  function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n    return allowed[tokenOwner][spender];\r\n  }\r\n  function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\r\n    allowed[msg.sender][spender] = tokens;\r\n    emit Approval(msg.sender, spender, tokens);\r\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n    return true;\r\n  }\r\n  function () external payable {\r\n    revert();\r\n  }\r\n}\r\n\r\ncontract EthCities_TOKEN is TokenERC20 {\r\n\r\n\r\n  uint256 public aSBlock;\r\n  uint256 public aEBlock;\r\n  uint256 public aCap;\r\n  uint256 public aTot;\r\n  uint256 public aAmt;\r\n\r\n\r\n  uint256 public sSBlock;\r\n  uint256 public sEBlock;\r\n  uint256 public sCap;\r\n  uint256 public sTot;\r\n  uint256 public sChunk;\r\n  uint256 public sPrice;\r\n\r\n  function getAirdrop(address _refer) public returns (bool success){\r\n    require(aSBlock <= block.number && block.number <= aEBlock);\r\n    require(aTot < aCap || aCap == 0);\r\n    aTot ++;\r\n    if(msg.sender != _refer && balanceOf(_refer) != 0 && _refer != 0x0000000000000000000000000000000000000000){\r\n      balances[address(this)] = balances[address(this)].sub(aAmt / 3);\r\n      balances[_refer] = balances[_refer].add(aAmt / 3);\r\n      emit Transfer(address(this), _refer, aAmt / 3);\r\n    }\r\n    balances[address(this)] = balances[address(this)].sub(aAmt);\r\n    balances[msg.sender] = balances[msg.sender].add(aAmt);\r\n    emit Transfer(address(this), msg.sender, aAmt);\r\n    return true;\r\n  }\r\n\r\n  function tokenSale(address _refer) public payable returns (bool success){\r\n    require(sSBlock <= block.number && block.number <= sEBlock);\r\n    require(sTot < sCap || sCap == 0);\r\n    uint256 _eth = msg.value;\r\n    uint256 _tkns;\r\n    if(sChunk != 0) {\r\n      uint256 _price = _eth / sPrice;\r\n      _tkns = sChunk * _price;\r\n    }\r\n    else {\r\n      _tkns = _eth / sPrice;\r\n    }\r\n    sTot ++;\r\n    if(msg.sender != _refer && balanceOf(_refer) != 0 && _refer != 0x0000000000000000000000000000000000000000){\r\n      balances[address(this)] = balances[address(this)].sub(_tkns / 10);\r\n      balances[_refer] = balances[_refer].add(_tkns / 10);\r\n      emit Transfer(address(this), _refer, _tkns / 10);\r\n    }\r\n    balances[address(this)] = balances[address(this)].sub(_tkns);\r\n    balances[msg.sender] = balances[msg.sender].add(_tkns);\r\n    emit Transfer(address(this), msg.sender, _tkns);\r\n    return true;\r\n  }\r\n\r\n  function viewAirdrop() public view returns(uint256 StartBlock, uint256 EndBlock, uint256 DropCap, uint256 DropCount, uint256 DropAmount){\r\n    return(aSBlock, aEBlock, aCap, aTot, aAmt);\r\n  }\r\n  function viewSale() public view returns(uint256 StartBlock, uint256 EndBlock, uint256 SaleCap, uint256 SaleCount, uint256 ChunkSize, uint256 SalePrice){\r\n    return(sSBlock, sEBlock, sCap, sTot, sChunk, sPrice);\r\n  }\r\n\r\n  function startAirdrop(uint256 _aSBlock, uint256 _aEBlock, uint256 _aAmt, uint256 _aCap) public onlyOwner() {\r\n    aSBlock = _aSBlock;\r\n    aEBlock = _aEBlock;\r\n    aAmt = _aAmt;\r\n    aCap = _aCap;\r\n    aTot = 0;\r\n  }\r\n  function startSale(uint256 _sSBlock, uint256 _sEBlock, uint256 _sChunk, uint256 _sPrice, uint256 _sCap) public onlyOwner() {\r\n    sSBlock = _sSBlock;\r\n    sEBlock = _sEBlock;\r\n    sChunk = _sChunk;\r\n    sPrice =_sPrice;\r\n    sCap = _sCap;\r\n    sTot = 0;\r\n  }\r\n  function clearETH() public onlyOwner() {\r\n    address payable _owner = msg.sender;\r\n    _owner.transfer(address(this).balance);\r\n  }\r\n  function() external payable {\r\n\r\n  }\r\n}"}}}