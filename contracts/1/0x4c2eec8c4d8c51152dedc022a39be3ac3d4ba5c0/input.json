{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FlatFactory.sol":{"content":"// Sources flattened with hardhat v2.5.0 https://hardhat.org\n\n// File @openzeppelin/contracts/proxy/utils/Initializable.sol@v4.2.0\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n\n\n// File contracts/FactoryProxy.sol\n\n/*\n\n          88888888                         88888888\n       8888    888888                   888888    8888\n     888    88  8888888               8888  8888     888\n    888        888888888             888888888888     888\n   888        88888888888           8888888888888      888\n   888      8888888888888           888888888888       888\n    888     888888888888             888888888        888\n     888     888  88888      _=_      8888888  88    888\n       8888    888888      q(-_-)p      888888    8888\n          88888888         '_) (_`         88888888\n             88            /__/  \\            88\n             88          _(<_   / )_          88\n            8888        (__\\_\\_|_/__)        8888\n\n_____ ______   ________  ________   _________  ________  ________          ________ ________  ________ _________  ________  ________      ___    ___ \n|\\   _ \\  _   \\|\\   __  \\|\\   ___  \\|\\___   ___\\\\   __  \\|\\   __  \\        |\\  _____\\\\   __  \\|\\   ____\\\\___   ___\\\\   __  \\|\\   __  \\    |\\  \\  /  /|\n\\ \\  \\\\\\__\\ \\  \\ \\  \\|\\  \\ \\  \\\\ \\  \\|___ \\  \\_\\ \\  \\|\\  \\ \\  \\|\\  \\       \\ \\  \\__/\\ \\  \\|\\  \\ \\  \\___\\|___ \\  \\_\\ \\  \\|\\  \\ \\  \\|\\  \\   \\ \\  \\/  / /\n \\ \\  \\\\|__| \\  \\ \\   __  \\ \\  \\\\ \\  \\   \\ \\  \\ \\ \\   _  _\\ \\   __  \\       \\ \\   __\\\\ \\   __  \\ \\  \\       \\ \\  \\ \\ \\  \\\\\\  \\ \\   _  _\\   \\ \\    / / \n  \\ \\  \\    \\ \\  \\ \\  \\ \\  \\ \\  \\\\ \\  \\   \\ \\  \\ \\ \\  \\\\  \\\\ \\  \\ \\  \\       \\ \\  \\_| \\ \\  \\ \\  \\ \\  \\____   \\ \\  \\ \\ \\  \\\\\\  \\ \\  \\\\  \\|   \\/  /  /  \n   \\ \\__\\    \\ \\__\\ \\__\\ \\__\\ \\__\\\\ \\__\\   \\ \\__\\ \\ \\__\\\\ _\\\\ \\__\\ \\__\\       \\ \\__\\   \\ \\__\\ \\__\\ \\_______\\  \\ \\__\\ \\ \\_______\\ \\__\\\\ _\\ __/  / /    \n    \\|__|     \\|__|\\|__|\\|__|\\|__| \\|__|    \\|__|  \\|__|\\|__|\\|__|\\|__|        \\|__|    \\|__|\\|__|\\|_______|   \\|__|  \\|_______|\\|__|\\|__|\\___/ /     \n                                                                                                                                         \\|___|/      \n*/\n\npragma solidity 0.8.2;\n\ncontract FactoryProxy is Initializable {\n    /*************************** Events ***************************/\n    event Deployed(\n        address addr,\n        string proxyName,\n        string implName,\n        bytes32 salt\n    );\n\n    /*************************** Global Variables ***************************/\n    /* The factory owner */\n    address public factoryOwner;\n\n    /* The array of template creators */\n    address[] public templateCreator;\n\n    /* Types of deployable proxies */\n    struct ProxyTypes {\n        bytes templateByteCode;\n        address[] adminAddress;\n        bool isPublic;\n        bool enabled;\n    }\n\n    /* Types of deployable address */\n    struct ImplementationTypes {\n        address templateAddress;\n        address[] adminAddress;\n        bool isPublic;\n        bool enabled;\n        bool initialised;\n    }\n\n    /* Types of deployable implementation templates */\n    mapping(string => ImplementationTypes) public implTemplateTypes;\n\n    /* Types of deployable proxy templates */\n    mapping(string => ProxyTypes) public proxyTemplateTypes;\n\n    /*************************** Constructor ***************************/\n    constructor(address _factoryOwner) {\n        // Instantiates the owner as a template creator and owner of the contracts\n        factoryOwner = _factoryOwner;\n        templateCreator.push(_factoryOwner);\n    }\n\n    function initialize(address _factoryOwner) external initializer {\n        // Check to make sure this is only run once\n        factoryOwner = _factoryOwner;\n        templateCreator.push(_factoryOwner);\n    }\n\n    /*************************** Constructor ***************************/\n\n    /*************************** Getters ***************************/\n\n    function getFactoryOwner() external view returns (address) {\n        return factoryOwner;\n    }\n\n    function getTemplateCreators() external view returns (address[] memory) {\n        return templateCreator;\n    }\n\n    function getTemplateBytes(string calldata _templateName)\n        external\n        view\n        returns (bytes memory)\n    {\n        return proxyTemplateTypes[_templateName].templateByteCode;\n    }\n\n    function getTemplateAddress(string calldata _templateName)\n        external\n        view\n        returns (address)\n    {\n        return implTemplateTypes[_templateName].templateAddress;\n    }\n\n    /*************************** Getters ***************************/\n\n    /*************************** Setters ***************************/\n\n    /** @dev Adds a new proxy template contract type\n     * @param _templateName Name of the template (informational)\n     * @param _templateByteCode Generated byte code of the deployed contract\n     * @param _isPublic Does the contract have any special admin locks?\n     */\n    function addProxyTemplateType(\n        string calldata _templateName,\n        bytes memory _templateByteCode,\n        bool _isPublic\n    ) external onlyFactoryOwnerOrCreator {\n        if (proxyTemplateTypes[_templateName].templateByteCode.length > 0) {\n            revert(\"This template name has already been taken\");\n        }\n\n        ProxyTypes memory tempTemplate;\n\n        tempTemplate.templateByteCode = _templateByteCode;\n        tempTemplate.adminAddress = new address[](1);\n        tempTemplate.adminAddress[0] = msg.sender;\n        tempTemplate.isPublic = _isPublic;\n        tempTemplate.enabled = true;\n\n        proxyTemplateTypes[_templateName] = (tempTemplate);\n    }\n\n    /** @dev Toggles a proxys status\n     * @param _templateName index of the template in the array\n     */\n    function toggleProxyStatus(string calldata _templateName)\n        external\n        onlyFactoryOwner\n    {\n        proxyTemplateTypes[_templateName].enabled = !proxyTemplateTypes[\n            _templateName\n        ].enabled;\n    }\n\n    /** @dev Adds a new implementation template contract type\n     * @param _templateName Name of the template (informational)\n     * @param _templateAddress Generated byte code of the deployed contract\n     * @param _isPublic Does the contract have any special admin locks?\n     */\n    function addImplTemplateType(\n        string calldata _templateName,\n        address _templateAddress,\n        bool _isPublic\n    ) external onlyFactoryOwnerOrCreator {\n        require(\n            implTemplateTypes[_templateName].initialised != true,\n            \"This template name has already been taken\"\n        );\n\n        implTemplateTypes[_templateName].templateAddress = _templateAddress;\n        implTemplateTypes[_templateName].adminAddress = new address[](1);\n        implTemplateTypes[_templateName].adminAddress[0] = msg.sender;\n        implTemplateTypes[_templateName].isPublic = _isPublic;\n        implTemplateTypes[_templateName].enabled = true;\n        implTemplateTypes[_templateName].initialised = true;\n    }\n\n    /** @dev Toggles an implementation status\n     * @param _templateName index of the template in the mapping\n     */\n    function toggleImplStatus(string calldata _templateName)\n        external\n        onlyFactoryOwner\n    {\n        implTemplateTypes[_templateName].enabled = !implTemplateTypes[\n            _templateName\n        ].enabled;\n    }\n\n    /** @dev Sets a new factory owner\n     * @param _newFactoryOwner New factory owner\n     */\n    function setNewFactoryOwner(address _newFactoryOwner)\n        external\n        onlyFactoryOwner\n    {\n        factoryOwner = _newFactoryOwner;\n    }\n\n    /** @dev Adds a new template creator (someone who is able to deploy new templates)\n     * @param _newTemplateCreator New template creator\n     */\n    function setTemplateCreator(address _newTemplateCreator)\n        external\n        onlyFactoryOwner\n    {\n        for (uint256 i = 0; i < templateCreator.length; i++) {\n            if (_newTemplateCreator == templateCreator[i]) {\n                revert(\"Template creator already exists\");\n            }\n        }\n\n        templateCreator.push(_newTemplateCreator);\n    }\n\n    /** @dev Removes a template creator\n     * @param _newTemplateCreator Address of the to be removed creator\n     */\n    function removeTemplateCreator(address _newTemplateCreator)\n        external\n        onlyFactoryOwner\n    {\n        for (uint256 i = 0; i < templateCreator.length - 1; i++) {\n            if (templateCreator[i] == _newTemplateCreator) {\n                templateCreator[i] = templateCreator[i + 1];\n            }\n        }\n        delete templateCreator[templateCreator.length - 1];\n    }\n\n    /** @dev Adds implementation admin to a specific template\n     * @param _pooName Template address\n     * @param _newAdmin New template owner\n     */\n    function addImplAdmin(string calldata _pooName, address _newAdmin)\n        external\n        onlyFactoryOwner\n    {\n        for (\n            uint256 i = 0;\n            i < implTemplateTypes[_pooName].adminAddress.length;\n            i++\n        ) {\n            if (implTemplateTypes[_pooName].adminAddress[i] == _newAdmin) {\n                revert(\"This admin already exists\");\n            }\n        }\n\n        implTemplateTypes[_pooName].adminAddress.push(_newAdmin);\n    }\n\n    /** @dev Removes a implementation admin\n     * @param _admin Address of the to be removed creator\n     */\n    function removeImplAdmin(string calldata _pooName, address _admin)\n        external\n        onlyFactoryOwner\n    {\n        for (uint256 i = 0; i < templateCreator.length - 1; i++) {\n            if (implTemplateTypes[_pooName].adminAddress[i] == _admin) {\n                implTemplateTypes[_pooName].adminAddress[i] = templateCreator[\n                    i + 1\n                ];\n            }\n        }\n        delete implTemplateTypes[_pooName].adminAddress[\n            implTemplateTypes[_pooName].adminAddress.length - 1\n        ];\n    }\n\n    /** @dev Adds proxy admin to a specific template\n     * @param _pooName Template address\n     * @param _newAdmin New template owner\n     */\n    function addProxyAdmin(string calldata _pooName, address _newAdmin)\n        external\n        onlyFactoryOwner\n    {\n        for (\n            uint256 i = 0;\n            i < proxyTemplateTypes[_pooName].adminAddress.length;\n            i++\n        ) {\n            if (proxyTemplateTypes[_pooName].adminAddress[i] == _newAdmin) {\n                revert(\"This admin already exists\");\n            }\n        }\n\n        proxyTemplateTypes[_pooName].adminAddress.push(_newAdmin);\n    }\n\n    /** @dev Removes a proxy admin\n     * @param _admin Address of the to be removed creator\n     */\n    function removeProxyAdmin(string calldata _pooName, address _admin)\n        external\n        onlyFactoryOwner\n    {\n        for (uint256 i = 0; i < templateCreator.length - 1; i++) {\n            if (proxyTemplateTypes[_pooName].adminAddress[i] == _admin) {\n                proxyTemplateTypes[_pooName].adminAddress[i] = templateCreator[\n                    i + 1\n                ];\n            }\n        }\n        delete proxyTemplateTypes[_pooName].adminAddress[\n            proxyTemplateTypes[_pooName].adminAddress.length - 1\n        ];\n    }\n\n    /** @dev Toggles whether a implementation is public\n     * @param _pooName Implementation name\n     */\n    function toggleImplPublic(string calldata _pooName)\n        external\n        isAdminImpl(_pooName)\n    {\n        implTemplateTypes[_pooName].isPublic = !implTemplateTypes[_pooName]\n            .isPublic;\n    }\n\n    /** @dev Toggles whether a proxy is public\n     * @param _proxyName Proxy name\n     */\n    function toggleProxyPublic(string calldata _proxyName)\n        external\n        isAdminProxy(_proxyName)\n    {\n        proxyTemplateTypes[_proxyName].isPublic = !proxyTemplateTypes[\n            _proxyName\n        ].isPublic;\n    }\n\n    /*************************** Setters ***************************/\n\n    /*************************** Mutators ***************************/\n\n    /** @dev Deploys a new template contract\n     * @param _proxy Name index of the proxy you would like to create\n     * @param _implementation Name index of the template you would like to create\n     * @param _args Arguments for the initializer function\n     */\n    function createTemplate(\n        string calldata _proxy,\n        string calldata _implementation,\n        bytes calldata _args\n    )\n        external\n        isAdminOrPublicImpl(_implementation)\n        isAdminOrPublicProxy(_proxy)\n        returns (address addr)\n    {\n        string memory proxy = _proxy;\n        string memory implementation = _implementation;\n\n        bytes memory _tempMemory = proxyTemplateTypes[proxy].templateByteCode;\n        bytes memory _bytecode = abi.encodePacked(\n            _tempMemory,\n            abi.encode(\n                implTemplateTypes[implementation].templateAddress,\n                address(this),\n                _args\n            )\n        );\n\n        bytes32 _salt = keccak256(\n            abi.encodePacked(block.number, implementation)\n        );\n\n        assembly {\n            addr := create2(\n                0, // wei sent with current call\n                // Actual code starts after skipping the first 32 bytes\n                add(_bytecode, 0x20),\n                mload(_bytecode), // Load the size of code contained in the first 32 bytes\n                _salt // Salt from function arguments\n            )\n\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n\n        emit Deployed(addr, proxy, implementation, _salt);\n\n        return addr;\n    }\n\n    /** @dev Call to one of the template addresses as factory owner\n     * @param _templateAddress Address of the template\n     * @param _data Data of the call\n     */\n    function transact(address _templateAddress, bytes memory _data)\n        external\n        onlyFactoryOwner\n        returns (bool success, bytes memory result)\n    {\n        (success, result) = _templateAddress.call(_data);\n    }\n\n    /*************************** Mutators ***************************/\n\n    /*************************** Modifiers ***************************/\n\n    modifier onlyFactoryOwner() {\n        require(msg.sender == factoryOwner);\n        _;\n    }\n\n    modifier onlyFactoryOwnerOrCreator() {\n        bool success = false;\n\n        for (uint256 i = 0; i < templateCreator.length; i++) {\n            if (\n                templateCreator[i] == msg.sender || factoryOwner == msg.sender\n            ) {\n                success = true;\n            }\n        }\n\n        if (success == true) {\n            _;\n        } else {\n            revert(\"I am neither an admin or creator\");\n        }\n    }\n\n    modifier isAdminOrPublicProxy(string calldata _templateName) {\n        require(\n            proxyTemplateTypes[_templateName].enabled,\n            \"Proxy template not enabled\"\n        );\n\n        if (proxyTemplateTypes[_templateName].isPublic) {\n            _;\n        } else {\n            for (\n                uint256 i = 0;\n                i < proxyTemplateTypes[_templateName].adminAddress.length;\n                i++\n            ) {\n                if (\n                    proxyTemplateTypes[_templateName].adminAddress[i] ==\n                    msg.sender ||\n                    factoryOwner == msg.sender\n                ) {\n                    _;\n                }\n            }\n        }\n    }\n\n    modifier isAdminOrPublicImpl(string calldata _templateName) {\n        require(\n            implTemplateTypes[_templateName].enabled,\n            \"Implementation template not enabled\"\n        );\n\n        if (implTemplateTypes[_templateName].isPublic) {\n            _;\n        } else {\n            for (\n                uint256 i = 0;\n                i < implTemplateTypes[_templateName].adminAddress.length;\n                i++\n            ) {\n                if (\n                    implTemplateTypes[_templateName].adminAddress[i] ==\n                    msg.sender ||\n                    factoryOwner == msg.sender\n                ) {\n                    _;\n                }\n            }\n        }\n    }\n\n    modifier isAdminProxy(string calldata _templateName) {\n        for (\n            uint256 i = 0;\n            i < proxyTemplateTypes[_templateName].adminAddress.length;\n            i++\n        ) {\n            if (\n                proxyTemplateTypes[_templateName].adminAddress[i] ==\n                msg.sender ||\n                factoryOwner == msg.sender\n            ) {\n                _;\n            }\n        }\n    }\n\n    modifier isAdminImpl(string calldata _templateName) {\n        for (\n            uint256 i = 0;\n            i < implTemplateTypes[_templateName].adminAddress.length;\n            i++\n        ) {\n            if (\n                implTemplateTypes[_templateName].adminAddress[i] ==\n                msg.sender ||\n                factoryOwner == msg.sender\n            ) {\n                _;\n            }\n        }\n    }\n\n    /*************************** Modifiers ***************************/\n}\n"}}}