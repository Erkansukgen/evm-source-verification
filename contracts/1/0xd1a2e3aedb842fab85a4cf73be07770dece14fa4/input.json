{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/CouponClipperV2.sol":{"content":"pragma solidity 0.7.4;\n// SPDX-License-Identifier: MIT\n\ninterface IESDS {\n    function redeemCoupons(uint256 _epoch, uint256 _couponAmount) external;\n    function transferCoupons(address _sender, address _recipient, uint256 _epoch, uint256 _amount) external;\n    function totalRedeemable() external view returns (uint256);\n    function epoch() external view returns (uint256);\n    function balanceOfCoupons(address _account, uint256 _epoch) external view returns (uint256);\n    function advance() external;\n}\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface ICHI {\n    function freeFromUpTo(address _addr, uint256 _amount) external returns (uint256);\n}\n\n// @notice Lets anybody trustlessly redeem coupons on anyone else's behalf for a fee (minimum fee is 2%).\n//    Requires that the coupon holder has previously approved this contract via the ESDS `approveCoupons` function.\n// @dev Bots should scan for the `CouponApproval` event emitted by the ESDS `approveCoupons` function to find out which \n//    users have approved this contract to redeem their coupons.\n// @dev This contract's API should be backwards compatible with CouponClipper V1.\ncontract CouponClipperV2 {\n    using SafeMath for uint256;\n\n    IERC20 constant private ESD = IERC20(0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723);\n    IESDS constant private ESDS = IESDS(0x443D2f2755DB5942601fa062Cc248aAA153313D3);\n    ICHI  constant private CHI = ICHI(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n    uint256 constant private HOUSE_RATE = 100; // 100 basis points (1%) -- fee taken by the house\n    \n    address public house = 0x7Fb471734271b732FbEEd4B6073F401983a406e1; // collector of house take\n    \n    event SetOffer(address indexed user, uint256 offer);\n    \n    // frees CHI from msg.sender to reduce gas costs\n    // requires that msg.sender has approved this contract to use their CHI\n    modifier useCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + (16 * msg.data.length);\n        CHI.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n    }\n\n    // The basis points offered by coupon holders to have their coupons redeemed -- default is 200 bps (2%)\n    // E.g., offers[_user] = 500 indicates that _user will pay 500 basis points (5%) to the caller\n    mapping(address => uint256) private offers;\n\n    // @notice Gets the number of basis points the _user is offering the bots\n    // @dev The default value is 100 basis points (2%).\n    //   That is, `offers[_user] = 0` is interpretted as 2%.\n    //   This way users who are comfortable with the default 2% offer don't have to make any additional contract calls.\n    // @param _user The account whose offer we're looking up.\n    // @return The number of basis points the account is offering to have their coupons redeemed\n    function getOffer(address _user) public view returns (uint256) {\n        uint256 offer = offers[_user];\n        return offer < 200 ? 200 : offer;\n    }\n\n    // @notice Allows msg.sender to change the number of basis points they are offering.\n    // @dev _newOffer must be at least 200 (2%) and no more than 10_000 (100%)\n    // @dev A user's offer cannot be *decreased* during the 15 minutes before the epoch advance (frontrun protection)\n    // @param _offer The number of basis points msg.sender wants to offer to have their coupons redeemed.\n    function setOffer(uint256 _newOffer) external {\n        require(_newOffer <= 10_000, \"Offer exceeds 100%.\");\n        require(_newOffer >= 200, \"Minimum offer is 2%.\");\n        uint256 oldOffer = offers[msg.sender];\n        if (_newOffer < oldOffer) {\n            uint256 nextEpoch = ESDS.epoch() + 1;\n            uint256 nextEpochStartTIme = getEpochStartTime(nextEpoch);\n            uint256 timeUntilNextEpoch = nextEpochStartTIme.sub(block.timestamp);\n            require(timeUntilNextEpoch > 15 minutes, \"You cannot reduce your offer within 15 minutes of the next epoch\");\n        }\n        \n        offers[msg.sender] = _newOffer;\n        \n        emit SetOffer(msg.sender, _newOffer);\n    }\n    \n    // @notice Internal logic used to redeem coupons on the coupon holder's bahalf\n    // @param _user Address of the user holding the coupons (and who has approved this contract)\n    // @param _epoch The epoch in which the _user purchased the coupons\n    // @param _couponAmount The number of coupons to redeem (18 decimals)\n    function _redeem(address _user, uint256 _epoch, uint256 _couponAmount) internal {\n        \n        // pull user's coupons into this contract (requires that the user has approved this contract)\n        ESDS.transferCoupons(_user, address(this), _epoch, _couponAmount); // @audit-info : reverts on failure\n        \n        // redeem the coupons for ESD\n        ESDS.redeemCoupons(_epoch, _couponAmount); // @audit-info : reverts on failure\n        \n        // pay the fees\n        uint256 botFeeRate = getOffer(_user).sub(HOUSE_RATE);\n        uint256 botFee = _couponAmount.mul(botFeeRate).div(10_000);\n        uint256 houseFee = _couponAmount.mul(HOUSE_RATE).div(10_000);\n        ESD.transfer(house, houseFee); // @audit-info : reverts on failure\n        ESD.transfer(msg.sender, botFee); // @audit-info : reverts on failure\n        \n        // send the ESD to the user\n        ESD.transfer(_user, _couponAmount.sub(houseFee).sub(botFee)); // @audit-info : reverts on failure\n    }\n    \n    // @notice Allows anyone to redeem coupons for ESD on the coupon-holder's bahalf\n    // @dev Backwards compatible with CouponClipper V1.\n    function redeem(address _user, uint256 _epoch, uint256 _couponAmount) external {\n        _redeem(_user, _epoch, _couponAmount);\n    }\n    \n    // @notice Advances the epoch (if needed) and redeems the max amount of coupons possible\n    //    Also frees CHI tokens to save on gas (requires that msg.sender has CHI tokens in their\n    //    account and has approved this contract to spend their CHI).\n    // @param _user The user whose coupons will attempt to be redeemed\n    // @param _epoch The epoch in which the coupons were created\n    // @param _targetEpoch The epoch that is about to be advanced _to_.\n    //    E.g., if the current epoch is 220 and we are about to advance to to epoch 221, then _targetEpoch\n    //    would be set to 221. The _targetEpoch is the epoch in which the coupon redemption will be attempted.\n    function advanceAndRedeemMax(address _user, uint256 _epoch, uint256 _targetEpoch) external useCHI {\n        // End execution early if tx is mined too early\n        uint256 targetEpochStartTime = getEpochStartTime(_targetEpoch);\n        if (block.timestamp < targetEpochStartTime) { return; }\n        \n        // advance epoch if it has not already been advanced \n        if (ESDS.epoch() != _targetEpoch) { ESDS.advance(); }\n        \n        // get max redeemable amount\n        uint256 totalRedeemable = ESDS.totalRedeemable();\n        uint256 userBalance = ESDS.balanceOfCoupons(_user, _epoch);\n        uint256 maxRedeemableAmount = totalRedeemable < userBalance ? totalRedeemable : userBalance;\n        \n        // attempt to redeem coupons\n        _redeem(_user, _epoch, maxRedeemableAmount);\n    }\n\n    \n    // @notice Returns the timestamp at which the _targetEpoch starts\n    function getEpochStartTime(uint256 _targetEpoch) public pure returns (uint256) {\n        return _targetEpoch.sub(106).mul(28800).add(1602201600);\n    }\n    \n    // @notice Allows house address to change the house address\n    function changeHouseAddress(address _newAddress) external {\n        require(msg.sender == house);\n        house = _newAddress;\n    }\n}\n\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}}