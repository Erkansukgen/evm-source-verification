{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/bridge.sol": {
      "content": "pragma solidity ^0.8.0;\n\n\ninterface IERC721 {\n    function tokenURI(uint256) external view returns (string memory);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function mint(address, string calldata) external returns (uint256);\n\n    function transferFrom(address, address, uint256) external;\n}\n\ncontract BridgeContract {\n    address constant hotwallet = address(0xF2054f0361EFB713047ab7bB748FCF049AbE3A55);\n    address constant contr = address(0xa6829Bb72b66df93D5a1059123b10ff35A7bcbb4);\n\n    mapping(uint256 => bool) public withdrawals;\n\n    // version of the contract to prevent reusing signatures\n    uint256 constant public CONTRACT_VERSION = 3;\n\n    // asset_code that related to this bridge,\n    // this contract operate with only one asset\n    string constant ASSET_CODE = \"ONFT\";\n\n    // indexes for packed signature parameters\n\n    event Deposited(string tokendID, uint256 tokenID, string indexed asset_code);\n    event Minted(string tokendID, string edition, uint256 tokenID, uint8 amount, string indexed asset_code);\n    event Withdrawn(uint256 reqID, uint256 tokenID, string indexed asset_code);\n\n    function checkSignature(\n        uint256 _timestamp,\n        uint256 _requestID,\n        uint256 _tokenID,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _v\n    ) view internal returns (bool) {\n        require(_timestamp >= block.timestamp, \"signature-expired\");\n        bytes32 _hash = keccak256(abi.encodePacked(CONTRACT_VERSION, _timestamp, msg.sender, _requestID, _tokenID));\n        address signer = ecrecover(_hash, _v, _r, _s);\n        require(signer != address(0), \"signature-invalid\");\n\n        return hotwallet == signer;\n    }\n\n    function mint(\n        string memory tokendID,\n        string memory tokenURI\n    ) external {\n        uint256 tokenID = IERC721(contr).mint(hotwallet, tokenURI);\n        emit Minted(tokendID, \"\", tokenID, 1, ASSET_CODE);\n    }\n\n    function batchMint(string memory tokendID, string memory tokenURI, uint8 amount) external {\n        uint256 startID = IERC721(contr).mint(hotwallet, tokenURI);\n\n        for (uint8 i = 1; i < amount; i++) {\n            IERC721(contr).mint(hotwallet, tokenURI);\n        }\n        emit Minted(tokendID, \"\", startID, amount, ASSET_CODE);\n    }\n\n    function mintBySelf(string memory tokendID, string memory tokenURI) external {\n        uint256 tokenID = IERC721(contr).mint(msg.sender, tokenURI);\n        IERC721(contr).transferFrom(msg.sender, hotwallet, tokenID);\n        emit Minted(tokendID, \"\", tokenID, 1, ASSET_CODE);\n    }\n\n    function batchMintBySelf(\n        string memory tokendID,\n        string memory tokenURI,\n        string memory edition,\n        uint8 amount\n    ) external {\n        uint256 startID = IERC721(contr).mint(msg.sender, tokenURI);\n        IERC721(contr).transferFrom(msg.sender, hotwallet, startID);\n\n        for (uint8 i = 1; i < amount; i++) {\n            IERC721(contr).transferFrom(msg.sender, hotwallet, IERC721(contr).mint(msg.sender, tokenURI));\n        }\n\n        emit Minted(tokendID, edition, startID, amount, ASSET_CODE);\n    }\n\n    function deposit(\n        string memory tokendID,\n        uint256 tokenID\n    ) external {\n        IERC721(contr).transferFrom(msg.sender, hotwallet, tokenID);\n        emit Deposited(tokendID, tokenID, ASSET_CODE);\n    }\n\n    function _withdrawFromHotwallet(\n        address receiver,\n        uint256 tokenID,\n        uint256 withdrawID\n    ) internal {\n        IERC721(contr).transferFrom(hotwallet, receiver, tokenID);\n        withdrawals[withdrawID] = true;\n        emit Withdrawn(withdrawID, tokenID, ASSET_CODE);\n    }\n\n    function withdraw(\n        uint256 withdrawID,\n        uint256 timestamp,\n        uint256 tokenID,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _v\n    ) external {\n        require(!withdrawals[withdrawID], \"such-withdraw-already-used\");\n        require(checkSignature(timestamp, withdrawID, tokenID, _r, _s, _v), \"bad-signature\");\n        _withdrawFromHotwallet(msg.sender, tokenID, withdrawID);\n    }\n\n    function lazyWithdraw(\n        uint256 withdrawID,\n        uint256 timestamp,\n        string memory tokenURI,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _v\n    ) external {\n        require(!withdrawals[withdrawID], \"such-withdraw-already-used\");\n        require(checkSignature(timestamp, withdrawID, 0, _r, _s, _v), \"bad-signature\");\n        _withdrawFromHotwallet(msg.sender, IERC721(contr).mint(hotwallet, tokenURI), withdrawID);\n    }\n}\n\n"
    }
  }
}