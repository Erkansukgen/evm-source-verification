{
  "language": "Solidity",
  "settings": {
    "libraries": {
      "Nebula.sol": {
        "QueueLib": "0x37d78b04fa942128c5a6dd12ff8be2a835819090"
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Nebula.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// File: contracts/core/ethereum/Gravity/Gravity.sol\n\npragma solidity <=0.7.0;\n\ncontract Gravity {\n    mapping(uint256=>address[]) public rounds;\n    uint256 public bftValue;\n    uint256 public lastRound;\n\n    constructor(address[] memory consuls, uint256 newBftValue) public {\n        rounds[0] = consuls;\n        bftValue = newBftValue;\n    }\n\n    function getConsuls() external view returns(address[] memory) {\n        return rounds[lastRound];\n    }\n\n    function getConsulsByRoundId(uint256 roundId) external view returns(address[] memory) {\n        return rounds[roundId];\n    }\n\n    function updateConsuls(address[] memory newConsuls, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 roundId) public {\n        uint256 count = 0;\n\n        require(roundId > lastRound, \"round less last round\");\n\n        bytes32 dataHash = hashNewConsuls(newConsuls, roundId);\n\n        address[] memory consuls = rounds[lastRound];\n        for(uint i = 0; i < consuls.length; i++) {\n            count += ecrecover(dataHash, v[i], r[i], s[i]) == consuls[i] ? 1 : 0;\n        }\n        require(count >= bftValue, \"invalid bft count\");\n\n        rounds[roundId] = newConsuls;\n        lastRound = roundId;\n    }\n\n    function hashNewConsuls(address[] memory newConsuls, uint256 roundId) public pure returns(bytes32) {\n        bytes memory data;\n        for(uint i = 0; i < newConsuls.length; i++) {\n            data = abi.encodePacked(data, newConsuls[i]);\n        }\n        \n\n        return keccak256(abi.encodePacked(data, roundId));\n    }\n\n}\n\n// File: contracts/core/ethereum/libs/Queue.sol\n\npragma solidity <=0.7;\n\nlibrary QueueLib {\n    struct Queue {\n        bytes32 first;\n        bytes32 last;\n        mapping(bytes32 => bytes32) nextElement;\n        mapping(bytes32 => bytes32) prevElement;\n    }\n\n    function drop(Queue storage queue, bytes32 rqHash) public {\n        bytes32 prevElement = queue.prevElement[rqHash];\n        bytes32 nextElement = queue.nextElement[rqHash];\n\n        if (prevElement != bytes32(0)) {\n            queue.nextElement[prevElement] = nextElement;\n        } else {\n            queue.first = nextElement;\n        }\n\n        if (nextElement != bytes32(0)) {\n            queue.prevElement[nextElement] = prevElement;\n        } else {\n            queue.last = prevElement;\n        }\n    }\n\n    // function next(Queue storage queue, bytes32 startRqHash) public view returns(bytes32) {\n    //     if (startRqHash == 0x000)\n    //         return queue.first;\n    //     else {\n    //         return queue.nextElement[startRqHash];\n    //     }\n    // }\n\n    function push(Queue storage queue, bytes32 elementHash) public {\n        if (queue.first == 0x000) {\n            queue.first = elementHash;\n            queue.last = elementHash;\n        } else {\n            queue.nextElement[queue.last] = elementHash;\n            queue.prevElement[elementHash] = queue.last;\n            queue.nextElement[elementHash] = bytes32(0);\n            queue.last = elementHash;\n        }\n    }\n}\n\n// File: contracts/core/ethereum/Nebula/NModels.sol\n\npragma solidity <=0.7.0;\n\nlibrary NModels {\n    uint8 constant oracleCountInEpoch = 5;\n\n    enum DataType {\n        Int64,\n        String,\n        Bytes\n    }\n\n    struct Subscription {\n        address owner;\n        address payable contractAddress;\n        uint8 minConfirmations;\n        uint256 reward;\n    }\n\n    struct Pulse {\n        bytes32 dataHash;\n        uint256 height;\n    }\n\n    struct Oracle {\n        address owner;\n        bool isOnline;\n        bytes32 idInQueue;\n    }\n}\n\n// File: contracts/core/ethereum/interfaces/ISubscriberBytes.sol\n\npragma solidity <=0.7.0;\n\ninterface ISubscriberBytes {\n    function attachValue(bytes calldata value) external;\n}\n\n// File: contracts/core/ethereum/interfaces/ISubscriberInt.sol\n\npragma solidity <=0.7.0;\n\ninterface ISubscriberInt {\n    function attachValue(int64 value) external;\n}\n\n// File: contracts/core/ethereum/interfaces/ISubscriberString.sol\n\npragma solidity <=0.7.0;\n\ninterface ISubscriberString {\n    function attachValue(string calldata value) external;\n}\n\n// File: contracts/core/ethereum/Nebula/Nebula.sol\n\npragma solidity <=0.7.0;\n\n\ncontract Nebula {\n    event NewPulse(uint256 pulseId, uint256 height, bytes32 dataHash);\n    event NewSubscriber(bytes32 id);\n\n    mapping(uint256=>bool) public rounds;\n\n    QueueLib.Queue public oracleQueue;\n    QueueLib.Queue public subscriptionsQueue;\n    QueueLib.Queue public pulseQueue;\n\n    address[] public oracles;\n    uint256 public bftValue;\n    address public gravityContract;\n    NModels.DataType public dataType;\n\n    bytes32[] public subscriptionIds;\n    uint256 public lastPulseId;\n    mapping(bytes32 => NModels.Subscription) public subscriptions;\n    mapping(uint256 => NModels.Pulse) public pulses;\n    mapping(uint256 => mapping(bytes32 => bool)) public isPulseSubSent;\n    \n    address contractOwner;\n\n    constructor(NModels.DataType newDataType, address newGravityContract, address[] memory newOracle, uint256 newBftValue) public {\n        dataType = newDataType;\n        oracles = newOracle;\n        bftValue = newBftValue;\n        gravityContract = newGravityContract;\n        \n        contractOwner = msg.sender;\n    }\n    \n    receive() external payable { } \n\n    //----------------------------------public getters--------------------------------------------------------------\n\n    function getOracles() public view returns(address[] memory) {\n        return oracles;\n    }\n\n    function getSubscribersIds() public view returns(bytes32[] memory) {\n        return subscriptionIds;\n    }\n\n    function hashNewOracles(address[] memory newOracles) public pure returns(bytes32) {\n        bytes memory data;\n        for(uint i = 0; i < newOracles.length; i++) {\n            data = abi.encodePacked(data, newOracles[i]);\n        }\n\n        return keccak256(data);\n    }\n\n    //----------------------------------public setters--------------------------------------------------------------\n\n    function sendHashValue(bytes32 dataHash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) public {\n        uint256 count = 0;\n\n        for(uint i = 0; i < oracles.length; i++) {\n            count += ecrecover(dataHash,\n                v[i], r[i], s[i]) == oracles[i] ? 1 : 0;\n        }\n\n        require(count >= bftValue, \"invalid bft count\");\n        \n        uint256 newPulseId = lastPulseId + 1;\n        pulses[newPulseId] = NModels.Pulse(dataHash, block.number);\n\n        emit NewPulse(newPulseId, block.number, dataHash);\n        lastPulseId = newPulseId;\n    }\n\n    function updateOracles(address[] memory newOracles, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 newRound) public {\n        uint256 count = 0;\n        bytes32 dataHash = hashNewOracles(newOracles);\n        address[] memory consuls = Gravity(gravityContract).getConsuls();\n\n        for(uint i = 0; i < consuls.length; i++) {\n            count += ecrecover(dataHash, v[i], r[i], s[i]) == consuls[i] ? 1 : 0;\n        }\n        require(count >= bftValue, \"invalid bft count\");\n\n       oracles = newOracles;\n       rounds[newRound] = true;\n    }\n    \n    function validateDataProvider() internal view returns(bool) {\n        for(uint i = 0; i < oracles.length; i++) {\n            if (oracles[i] == msg.sender) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function sendValueToSubByte(bytes memory value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberBytes(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubInt(int64 value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberInt(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubString(string memory value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberString(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    //----------------------------------internals---------------------------------------------------------------------\n\n    function sendValueToSub(uint256 pulseId, bytes32 subId) internal {\n        require(isPulseSubSent[pulseId][subId] == false, \"sub sent\");\n\n        isPulseSubSent[pulseId][subId] = true;\n    }\n    \n    function subscribe(address payable contractAddress, uint8 minConfirmations, uint256 reward) public {\n        require(validateDataProvider() || contractOwner == msg.sender, \"caller is not one of the oracles or contract deployer\");\n        bytes32 id = keccak256(abi.encodePacked(abi.encodePacked(msg.sig, msg.sender, contractAddress, minConfirmations)));\n        require(subscriptions[id].owner == address(0x00), \"rq exists\");\n        subscriptions[id] = NModels.Subscription(msg.sender, contractAddress, minConfirmations, reward);\n        QueueLib.push(subscriptionsQueue, id);\n        subscriptionIds.push(id);\n        emit NewSubscriber(id);\n    }\n}\n"
    }
  }
}