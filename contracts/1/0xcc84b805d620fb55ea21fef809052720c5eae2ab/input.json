{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/ARIX.sol": {
      "content": "pragma solidity >= 0.6.0;\n\n//For every platform to check token balance of public address\n//allow personal wallet transfer token to other address\n//must be  implement like other tokens do allow user spend it on any C2C platforms.\n\nimport \"./ERC20.sol\";\nimport \"./Context.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Interest.sol\";\n\n//Get information of token like: NAME, SYMBOL, OWNER, DECIMAL PLACES\n\nimport \"./ERC20Detailed.sol\";\n\ncontract ARIX is ERC20, ERC20Detailed, Interest{\n    \n        constructor(\n        uint256   maximumcoin,\n        uint32 secondsforoneyear,\n        uint32 secondsforthreemonths,\n        uint32 secondsforonemonth,\n        uint32 secondsforthreeminute ,\n        uint256 minimumbalanceforfirstyearinterest,\n        uint256 minimumbalanceforsecondyearinterest,\n        uint256 minimumbalanceforthirdyearinterest,\n        string memory name, \n        string memory symbol, \n        uint256 decimals \n        )public ERC20Detailed(name, symbol, decimals) {\n\n            _balances[address(this)] = maximumcoin;\n            _maximumcoin = maximumcoin;\n            _decimals = 10**decimals;\n            _1year = secondsforoneyear;\n            _3month = secondsforthreemonths;\n            _1month = secondsforonemonth;\n            _3min = secondsforthreeminute;\n            _firstyearminbal = minimumbalanceforfirstyearinterest;\n            _secondyearminbal = minimumbalanceforsecondyearinterest;\n            _thirdyearminbal = minimumbalanceforthirdyearinterest;\n   }\n   using SafeMath for uint256;\n   \n    function totalSupply() public view returns (uint256) {\n         \n        uint256 _1yearcoin = (_1year/_3min)*100*_decimals;\n        uint256 _2yearcoin = _1yearcoin.add((_1year/_3min)*50*_decimals);\n        uint256 _3yearcoin = _2yearcoin.add((_1year/_3min)*25*_decimals);\n        uint256 _4yearcoin = _3yearcoin.add(((_1year/_3min)*125*_decimals)/10);\n        uint256 _5yearcoin = _4yearcoin.add(((_1year/_3min)*625*_decimals)/100);\n        \n        uint256 _elapsetime = block.timestamp.sub(deployTime);\n\n        if(_elapsetime <=_1year){      \n            if((_elapsetime/_3min)*100*_decimals < _maximumcoin)\n                return ((_elapsetime/_3min)*100*_decimals);\n            else\n            return(_maximumcoin);\n        \n        \n        }else if(_elapsetime <=(_1year*2)){\n            if(_1yearcoin.add(((_elapsetime.sub(_1year))/_3min)*50*_decimals) < _maximumcoin)\n                return (_1yearcoin.add(((_elapsetime.sub(_1year))/_3min)*50*_decimals));\n            else\n            return(_maximumcoin);\n        \n        \n        }else if(_elapsetime <=(_1year*3)){\n            if(_2yearcoin.add(((_elapsetime.sub(_1year*2))/_3min)*25*_decimals) < _maximumcoin)\n                return (_2yearcoin.add(((_elapsetime.sub(_1year*2))/_3min)*25*_decimals));\n            else\n            return(_maximumcoin);\n        \n        \n        }else if(_elapsetime <=(_1year*4)){\n            if(_3yearcoin.add((((_elapsetime.sub(_1year*3))/_3min)*125*_decimals)/10) < _maximumcoin)\n                return (_3yearcoin.add((((_elapsetime.sub(_1year*3))/_3min)*125*_decimals)/10));\n            else\n            return(_maximumcoin);\n        \n        \n        }else if(_elapsetime <=(_1year*5)){\n            if(_4yearcoin.add((((_elapsetime.sub(_1year*4))/_3min)*625*_decimals)/100) < _maximumcoin)\n                return (_4yearcoin.add((((_elapsetime.sub(_1year*4))/_3min)*625*_decimals)/100));\n            else\n            return(_maximumcoin);\n     \n        \n        }else if(_elapsetime > (_1year*5)){\n            if(_5yearcoin.add((((_elapsetime.sub(_1year*5))/_3min)*3125*_decimals)/1000) < _maximumcoin)\n                return (_5yearcoin.add((((_elapsetime.sub(_1year*5))/_3min)*3125*_decimals)/1000));\n            else\n            return(_maximumcoin);\n        }\n       \n    }\n   \n   \n   function admintransfer(uint256 amount, address recipient) public returns (uint256) {\n           require(msg.sender == admin, \"ERC20: Only admin can transfer from contract\");\n           require(amount <= totalSupply(), \"ERC20: Only less than total released can be tranfered\");\n           require(amount <= totalSupply().sub(_totaltransfered), \"Only less than total suppliable coin\");\n           \n        _transfer(address(this), recipient, amount);\n        _totaltransfered = _totaltransfered.add(amount);\n        return(_balances[recipient]);\n    }\n   \n}    \n\n"
    },
    "browser/Context.sol": {
      "content": "pragma solidity >= 0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    // constructor () internal { }\n    // // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "browser/ERC20.sol": {
      "content": "pragma solidity >= 0.6.0;\n\nimport \"./Context.sol\";\nimport \"./SafeMath.sol\";\n\ncontract ERC20 is Context{\n    using SafeMath for uint256;\n\n    mapping (address => uint256) _balances;\n    \n    mapping (address => uint256) _intactbal;\n    \n    mapping (address => uint256) _depositTime;\n    \n    uint256 _maximumcoin;\n    uint256 _decimals ;\n    \n    uint256  _firstyearminbal ;\n    uint256  _secondyearminbal ;\n    uint256  _thirdyearminbal ;\n\n    uint256  private _currentsupply;\n    \n    uint256 deployTime = block.timestamp;\n\n    uint256  _1year ;\n    uint256  _3month ;\n    uint256 _1month ;\n    uint256  _3min ;\n    \n    address  admin = msg.sender;\n    uint256 _totaltransfered = 0;\n    \n    event OwnershipTransferred(address _oldAdmin, address _newAdmin);\n    event MinimumBalanceforinterestchanged(uint256 _oldminyear1, uint256 _oldminyear2, uint256 _oldminyear3, uint256 _newminyear1, uint256 _newminyear2, uint256 _newminyear3 );\n   \n     /**\n     * @dev See {IERC20-balanceOf}.\n     **/\n\n    function balanceOf(address account) public view returns (uint256) {\n        return (_balances[account]);\n    }\n    \n    function transferOwnership(address _newAdmin) public {\n        require(msg.sender == admin, \"Not an admin\");\n        admin = _newAdmin;\n        emit OwnershipTransferred(msg.sender, admin);\n    }\n    \n    function changeMinimumBalanceforinterest(uint256 y1, uint256 y2, uint256 y3) public {\n        require(msg.sender == admin, \"Not an admin\");\n        _firstyearminbal = y1;\n        _secondyearminbal = y2;\n        _thirdyearminbal = y3;\n        \n        emit MinimumBalanceforinterestchanged(y1, y2, y3, _firstyearminbal, _secondyearminbal, _thirdyearminbal);\n    }\n\n    function viewMinimumBalanceforinterest() public view returns (uint256, uint256, uint256){\n        return (_firstyearminbal,_secondyearminbal,_thirdyearminbal );\n    }\n    \n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer( uint256 amount, address recipient) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n \n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        if(_depositTime[recipient] == 0)\n        _depositTime[recipient] = block.timestamp;\n        emit Transfer (sender, recipient, amount);\n    }\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed frm, address indexed to, uint256 value);\n\n    event InterestTransfer(address indexed to, uint256 value, uint256 transferTime);\n\n}\n\n"
    },
    "browser/ERC20Detailed.sol": {
      "content": "pragma solidity >= 0.6.0;\n\n//import \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed {\n    string private _name;\n    string private _symbol;\n    uint256 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint256 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n}\n\n\n"
    },
    "browser/Interest.sol": {
      "content": "pragma solidity >= 0.6.0;\n\nimport \"./Context.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ERC20.sol\";\n\ncontract Interest is Context, ERC20 {\n    \n    using SafeMath for uint256;\n    \n    //cron this function daily after 3 months of deployment of contract upto 3 years\n    \n     function multiInterestUpdate(address[] memory _contributors)public  returns (bool) { \n         require(msg.sender == admin, \"ERC20: Only admin can transfer from contract\");\n         uint256 _time =block.timestamp.sub(deployTime);\n         require(_time >= _3month.add(_1month), \"ERC20: Only after 4 months of deployment of contract\" );\n    \n            uint8 i = 0;\n            for (i; i < _contributors.length; i++) {\n        \n                address  user = _contributors[i];\n                 uint256 _deposittime =block.timestamp.sub(_depositTime[user]);\n                 \n                 if(_time <= _1year){           //less than 1 year\n                 \n                     if((_balances[ user] >= _firstyearminbal) && (_deposittime > _3month) && (_intactbal[user] == 0))\n                     _intactbal[user] = _intactbal[user].add((_balances[user]*3)/(100));\n                \n                 }\n                 else if(_time <= (_1year*2)){  //less than 2 year\n                        \n                     if(_balances[ user] >= _secondyearminbal && (_deposittime > _1month*2) && (_intactbal[user] == 0))\n                      _intactbal[user] = _intactbal[user].add((_balances[ user]*15)/(1000));\n                 }\n                 else if(_time <= (_1year*3)){  //less than 3 year\n                 \n                     if(_balances[user] >= _thirdyearminbal  && (_deposittime > _1month) && (_intactbal[user] == 0))\n                     _intactbal[user] = _intactbal[user].add((_balances[ user])/(100));\n                 }\n         \n            }\n         \n\n    return (true);\n    }\n    \n    \n    //cron this function monthly after 4 months of deployment of contract upto 3 years\n    \n     function multiInterestCredit( address[] memory _contributors) public returns(uint256) {\n       require(msg.sender == admin, \"ERC20: Only admin can transfer from contract\");\n       uint256 _time =block.timestamp.sub(deployTime);\n         require(_time >= _3month.add(_1month), \"ERC20: Only after 4 months of deployment of contract\" );\n       \n            uint256 monthtotal = 0;\n            \n            uint8 i = 0;\n            for (i; i < _contributors.length; i++) {\n                _transfer(address(this), _contributors[i], _intactbal[_contributors[i]]);\n                 emit InterestTransfer (_contributors[i], _intactbal[_contributors[i]], block.timestamp);\n                _totaltransfered = _totaltransfered.add(_intactbal[_contributors[i]]);\n                _intactbal[_contributors[i]] = 0;\n                monthtotal += _intactbal[_contributors[i]];\n                \n            }\n            \n        return (monthtotal);\n    }\n    \n}"
    },
    "browser/SafeMath.sol": {
      "content": "pragma solidity >= 0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  }
}