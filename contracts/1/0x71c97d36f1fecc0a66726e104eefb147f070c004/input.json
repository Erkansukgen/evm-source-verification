{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Fantasmas.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\npragma solidity ^0.8.0;\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\npragma solidity ^0.8.0;\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\npragma solidity ^0.8.0;\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n\npragma solidity ^0.8.0;\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n// File: @openzeppelin/contracts/utils/Context.sol\npragma solidity ^0.8.0;\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\npragma solidity ^0.8.0;\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        _beforeTokenTransfer(from, to, tokenId);\n        _approve(address(0), tokenId);\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n    }\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n// File: @openzeppelin/contracts/utils/cryptography/ECDSA.sol\npragma solidity ^0.8.0;\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\npragma solidity ^0.8.0;\ninterface IERC721Enumerable is IERC721 {\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\npragma solidity ^0.8.0;\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n    uint256[] private _allTokens;\n    mapping(uint256 => uint256) private _allTokensIndex;\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId;\n        _allTokensIndex[lastTokenId] = tokenIndex;\n\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n// File: @openzeppelin/contracts/utils/Strings.sol\npragma solidity ^0.8.0;\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n// File: @openzeppelin/contracts/utils/Address.sol\npragma solidity ^0.8.0;\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n\npragma solidity ^0.8.0;\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\npragma solidity ^0.8.0;\nabstract contract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor() {\n        _setOwner(_msgSender());\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File: contracts/Fantasmas.sol\n\npragma solidity ^0.8.4;\n\ncontract Fantasmas is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n    using ECDSA for bytes32;\n    uint256 public FANTASMAS_GIFT = 100;\n    uint256 public FANTASMAS_PRESALE = 500;\n    uint256 public FANTASMAS_PUBLIC = 1421;\n    uint256 public FANTASMAS_MAX = FANTASMAS_GIFT + FANTASMAS_PRESALE + FANTASMAS_PUBLIC;\n    uint256 public FANTASMAS_PRICE = .008 ether;\n    uint256 public FANTASMAS_PRESALE_PRICE = .008 ether;\n    uint256 public constant FANTASMAS_PER_MINT = 13;\n    mapping(address => bool) public presalerList;\n    mapping(address => uint256) public presalerListPurchases;\n    string private _tokenBaseURI = \"https://mint.fantasmas.io/api/\";\n    uint256 public giftedAmount;\n    uint256 public publicAmountMinted;\n    uint256 public privateAmountMinted;\n    uint256 public presalePurchaseLimit = 13;\n    bool public presaleLive;\n    bool public saleLive;\n    constructor() ERC721(\"Fantasmas\", \"FTMS\") payable { }\n    function addToPresaleList(address[] calldata entries) external onlyOwner {\n        for(uint256 i = 0; i < entries.length; i++) {\n            address entry = entries[i];\n            require(entry != address(0), \"NULL_ADDRESS\");\n            require(!presalerList[entry], \"DUPLICATE_ENTRY\");\n            presalerList[entry] = true;\n        }\n    }\n    function removeFromPresaleList(address[] calldata entries) external onlyOwner {\n        for(uint256 i = 0; i < entries.length; i++) {\n            address entry = entries[i];\n            require(entry != address(0), \"NULL_ADDRESS\");\n            presalerList[entry] = false;\n        }\n    }\n    function togglePresaleStatus() external onlyOwner {\n        presaleLive = !presaleLive;\n    }\n    function toggleSaleStatus() external onlyOwner {\n        saleLive = !saleLive;\n    }\n    function buy(uint256 tokenQuantity) external payable {\n        require(saleLive, \"SALE_CLOSED\");\n        require(!presaleLive, \"ONLY_PRESALE\");\n        require(totalSupply() < FANTASMAS_MAX, \"Out of stock.\");\n        require(publicAmountMinted + tokenQuantity <= FANTASMAS_PUBLIC, \"EXCEED_PUBLIC\");\n        require(tokenQuantity <= FANTASMAS_PER_MINT, \"EXCEED_FANTASMAS_PER_MINT\");\n        require(FANTASMAS_PRICE * tokenQuantity <= msg.value, \"Insufficient ETH.\");\n        for(uint i = 0; i < tokenQuantity; i++) {\n            publicAmountMinted++;\n            _safeMint(msg.sender, totalSupply());\n        }\n    }\n    function presaleBuy(uint256 tokenQuantity) external payable {\n        require(!saleLive && presaleLive, \"The presale has finished.\");\n        require(presalerList[msg.sender], \"You are not qualified for the presale.\");\n        require(totalSupply() < FANTASMAS_MAX, \"Out of stock.\");\n        require(privateAmountMinted + tokenQuantity <= FANTASMAS_PRESALE, \"EXCEED_PRIVATE\");\n        require(presalerListPurchases[msg.sender] + tokenQuantity <= presalePurchaseLimit, \"You have reached your maximum purchase amount.\");\n        require(FANTASMAS_PRESALE_PRICE * tokenQuantity <= msg.value, \"Insufficient ETH.\");\n        for (uint256 i = 0; i < tokenQuantity; i++) {\n            privateAmountMinted++;\n            presalerListPurchases[msg.sender]++;\n            _safeMint(msg.sender, totalSupply());\n        }\n    }\n    function gift(address[] calldata receivers) external onlyOwner {\n        require(totalSupply() + receivers.length <= FANTASMAS_MAX, \"MAX_MINT\");\n        require(giftedAmount + receivers.length <= FANTASMAS_GIFT, \"GIFTS_EMPTY\");\n        for (uint256 i = 0; i < receivers.length; i++) {\n            giftedAmount++;\n            _safeMint(receivers[i], totalSupply());\n        }\n    }\n    function withdrawTeam() external onlyOwner {\n        uint balance = address(this).balance;\n        payable(0x09174D9Ac92eAD808469ea0D239a3876ad8dFaF1).transfer((balance*25)/100); // Melt\n        payable(0x5927Db621E1DD69aBCEF792A53F12Dc701C05961).transfer((balance*25)/100); // Odds\n        payable(0xCBE25cB7F012E79cA4C252526CDdd8Bbc9f7349d).transfer((balance*25)/100); // Lobster\n        payable(0x9f71C75Ff0361a37c30337dA70e819DcDFb0b750).transfer((balance*25)/100); // Community\n    }\n    function isPresaler(address addr) external view returns (bool) {\n        return presalerList[addr];\n    }\n    function presalePurchasedCount(address addr) external view returns (uint256) {\n        return presalerListPurchases[addr];\n    }\n    function setBaseURI(string calldata URI) external onlyOwner {\n        _tokenBaseURI = URI;\n    }\n    function setPresaleAmount(uint256 number) external onlyOwner {\n        FANTASMAS_PRESALE = number;\n        FANTASMAS_MAX = FANTASMAS_GIFT + FANTASMAS_PRESALE + FANTASMAS_PUBLIC;\n    }\n    function setPublicAmount(uint256 number) external onlyOwner {\n        FANTASMAS_PUBLIC = number;\n        FANTASMAS_MAX = FANTASMAS_GIFT + FANTASMAS_PRESALE + FANTASMAS_PUBLIC;\n    }\n    function setGiftAmount(uint256 number) external onlyOwner {\n        FANTASMAS_GIFT = number;\n        FANTASMAS_MAX = FANTASMAS_GIFT + FANTASMAS_PRESALE + FANTASMAS_PUBLIC;\n    }\n    function setPrice(uint256 number) external onlyOwner {\n        FANTASMAS_PRICE = number;\n    }\n    function setPresalePrice(uint256 number) external onlyOwner {\n        FANTASMAS_PRESALE_PRICE = number;\n    }\n    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {\n        require(_exists(tokenId), \"Cannot query non-existent token\");\n        return string(abi.encodePacked(_tokenBaseURI, tokenId.toString()));\n    }\n}"}}}