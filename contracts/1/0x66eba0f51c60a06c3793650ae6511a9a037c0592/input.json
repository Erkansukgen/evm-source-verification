{"language":"Solidity","settings":{"evmVersion":"petersburg","libraries":{"ERC20Bonus.sol":{"SafeMath":"0x7d81a828ed4b441da83d78d6c252a5a12f60a562"}},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ERC20Bonus.sol":{"content":"pragma solidity >=0.4.21 <0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, \"add\");\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a, \"sub\");\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"mul\");\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0, \"div\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract ERC20TokenBankInterface{\r\n  //function balance() public view returns(uint);\r\n // function token() public view returns(address, string memory);\r\n  function issue(address _to, uint _amount) public returns (bool success);\r\n}\r\ninterface IERC20 {\r\n    function totalSupplyAt(uint _blockNumber) external view returns (uint);\r\n    function balanceOfAt(address _owner, uint _blockNumber) external view returns (uint);\r\n}\r\n\r\ncontract ERC20Bonus{\r\n  using SafeMath for uint;\r\n\r\n  ERC20TokenBankInterface public bank;\r\n  address public share_address;\r\n  uint public snapshot_block;\r\n  uint public start_block;\r\n  uint public end_block;\r\n  uint public bonus_total;\r\n  uint public claimed_bonus; \r\n\r\n  mapping (address => bool) public is_claimed;\r\n\r\n  event ClaimedBonus(address account, uint shareAmount, uint amount);\r\n\r\n  constructor(address _bank, address _share_address, uint _snapshot_block, uint _start_block, uint _end_block, uint _bonus_total) public {\r\n    require(_bank != address(0x0), \"invalid address\");\r\n    require(_share_address != address(0x0), \"not ERC20\");\r\n    bank = ERC20TokenBankInterface(_bank);\r\n    share_address = _share_address;\r\n    snapshot_block = _snapshot_block;\r\n    start_block = _start_block;\r\n    end_block = _end_block;\r\n    bonus_total = _bonus_total;\r\n  }\r\n\r\n  function claimBonus() public returns(bool){\r\n    require(block.number >= start_block, \"bonus not begin\");\r\n    require(block.number <= end_block, \"bonus end\");\r\n    require(!is_claimed[msg.sender], \"has claimed\");\r\n    uint share_amount = IERC20(share_address).balanceOfAt(msg.sender, snapshot_block);\r\n    require(share_amount > 0, \"no share\");\r\n    uint share_total = IERC20(share_address).totalSupplyAt(snapshot_block);\r\n\r\n    uint bonus_amount = share_amount.safeMul(bonus_total).safeDiv(share_total);\r\n\r\n    is_claimed[msg.sender] = true;\r\n    claimed_bonus += bonus_amount;\r\n    bank.issue(msg.sender, bonus_amount);\r\n    emit ClaimedBonus(msg.sender, share_amount, bonus_amount);\r\n    return true;\r\n  }\r\n\r\n  \r\n}\r\n\r\ncontract ERC20BonusFactory{\r\n  event CreateERC20Bonus(address addr);\r\n\r\n  function newBonus(address _bank, address _share_address, uint _snapshot_block, uint _start_block, uint _end_block, uint _bonus_total)\r\n  public returns (ERC20Bonus){\r\n    ERC20Bonus addr = new ERC20Bonus(_bank, _share_address, _snapshot_block, _start_block, _end_block, _bonus_total);\r\n    emit CreateERC20Bonus(address(addr));\r\n    return addr;\r\n  }\r\n}"}}}