{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LockNLoadETH2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  /* getRoundData and latestRoundData should both raise \"No data present\" */\n  /* if they do not have data to report, instead of returning unset values */\n  /* which could be misinterpreted as actual reported values. */\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n/* Token Contract call and send Functions */\ninterface Token {\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function approveAndCall(address spender, uint tokens, bytes memory data) external returns (bool success);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a / b;\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n    uint256 c = add(a,m);\n    uint256 d = sub(c,1);\n    return mul(div(d,m),m);\n  }\n}\n\ncontract Ownable {\n        address public owner;\n        event onOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        constructor() {\n            owner = payable(msg.sender);\n        }\n\n        modifier onlyOwner {\n            require(msg.sender == owner);\n            _;\n        }\n\n        function transferOwnership(address _newOwner) onlyOwner public {\n            require(_newOwner != address(0));\n            emit onOwnershipTransferred(owner, _newOwner);\n            owner = _newOwner;\n        }\n}\n\ncontract LockNLoad is Ownable{\n    using SafeMath for uint256;\n    \n    /* Deposit Variables */\n    struct Items {\n        address tokenAddress;\n        address withdrawalAddress;\n        uint256 tokenAmount;\n        uint256 unlockTime;\n        bool withdrawn;\n    }\n    \n    uint256 public depositId;\n    uint256[] public allDepositIds;\n    mapping (address => uint256[]) public depositsByWithdrawalAddress;\n    mapping (uint256 => Items) public lockedToken;\n    mapping (address => mapping(address => uint256)) public walletTokenBalance;\n    mapping(address => bool) public premiumMember;\n    bool public premium = true;\n    int private feerate = 1;\n    uint256 systemFeeCollected;\n    \n    event LogWithdrawal(address SentToAddress, uint256 AmountTransferred);\n    AggregatorV3Interface internal priceFeed;\n    \n    constructor()  {\n        priceFeed = AggregatorV3Interface(0x773616E4d11A78F511299002da57A0a94577F1f4);\n    }\n    \n    /* Calculate 1$ Price from Blockchain */\n    function getLatestPrice() public view returns (uint256) {\n        (\n            , \n            int price,\n            ,\n            ,\n        ) = priceFeed.latestRoundData();\n        return uint256(price);\n    }\n    \n    /* Calculate the original Fee */\n    function getSystemFees() public view returns (uint256) {\n        (\n            , \n            int price,\n            ,\n            ,\n        ) = priceFeed.latestRoundData();\n        return uint256(price*feerate);\n    }\n\n    /* Calculate Price for Multiple Locks */\n    function getSystemFeesBatch(uint256 _totalBatch) public view returns (uint256) {\n      return(getSystemFees()*_totalBatch);\n    }\n    \n    /* Lock the Tokens */\n    function lockTokens(address _tokenAddress, address _withdrawalAddress, uint256 _amount, uint256 _unlockTime) public payable returns (uint256 _id) {\n        require(_amount > 0);\n        require(_unlockTime < 10000000000);\n        uint256 fee = getSystemFees();\n        \n        if(premium){\n            if(!premiumMember[_withdrawalAddress]){\n                require(msg.value>=fee,\"System Fee Required\");\n                payable(owner).transfer(msg.value);\n                systemFeeCollected = systemFeeCollected + msg.value;\n            }\n        }\n        \n        /* update balance in address */\n        walletTokenBalance[_tokenAddress][_withdrawalAddress] = walletTokenBalance[_tokenAddress][_withdrawalAddress].add(_amount);\n        \n        _id = ++depositId;\n        lockedToken[_id].tokenAddress = _tokenAddress;\n        lockedToken[_id].withdrawalAddress = _withdrawalAddress;\n        lockedToken[_id].tokenAmount = _amount;\n        lockedToken[_id].unlockTime = _unlockTime;\n        lockedToken[_id].withdrawn = false;\n        \n        allDepositIds.push(_id);\n        depositsByWithdrawalAddress[_withdrawalAddress].push(_id);\n        \n        /* transfer tokens into contract */\n        require(Token(_tokenAddress).transferFrom(msg.sender, address(this), _amount));\n    }\n    \n    /* Create Multiple Locks */\n    function createMultipleLocks(address _tokenAddress, address _withdrawalAddress, uint256[] memory _amounts, uint256[] memory _unlockTimes) public payable returns (uint256 _id) {\n        require(_amounts.length > 0);\n        require(_amounts.length == _unlockTimes.length);\n        \n        uint256 fee = getSystemFees() * _amounts.length;\n        \n        if(premium){\n            if(!premiumMember[_withdrawalAddress]){\n                require(msg.value>=fee,\"System Fee Required\");\n                payable(owner).transfer(msg.value);\n                systemFeeCollected = systemFeeCollected + msg.value;\n            }\n        }\n        \n        uint256 i;\n        for(i=0; i<_amounts.length; i++){\n            require(_amounts[i] > 0);\n            require(_unlockTimes[i] < 10000000000);\n            \n            /* update balance in address */\n            walletTokenBalance[_tokenAddress][_withdrawalAddress] = walletTokenBalance[_tokenAddress][_withdrawalAddress].add(_amounts[i]);\n            \n            _id = ++depositId;\n            lockedToken[_id].tokenAddress = _tokenAddress;\n            lockedToken[_id].withdrawalAddress = _withdrawalAddress;\n            lockedToken[_id].tokenAmount = _amounts[i];\n            lockedToken[_id].unlockTime = _unlockTimes[i];\n            lockedToken[_id].withdrawn = false;\n            \n            allDepositIds.push(_id);\n            depositsByWithdrawalAddress[_withdrawalAddress].push(_id);\n            \n            /* transfer tokens into contract */\n            require(Token(_tokenAddress).transferFrom(msg.sender, address(this), _amounts[i]));\n        }\n    }\n    \n    /* Extend the Lock Duration */\n    function extendLockDuration(uint256 _id, uint256 _unlockTime) public {\n        require(_unlockTime < 10000000000);\n        require(_unlockTime > lockedToken[_id].unlockTime);\n        require(!lockedToken[_id].withdrawn);\n        require(msg.sender == lockedToken[_id].withdrawalAddress);\n        \n        /* set new unlock time */\n        lockedToken[_id].unlockTime = _unlockTime;\n    }\n    \n    /* Transfer the Locked Tokens */\n    function transferLocks(uint256 _id, address _receiverAddress) public {\n        require(!lockedToken[_id].withdrawn);\n        require(msg.sender == lockedToken[_id].withdrawalAddress);\n        \n        /* decrease sender's token balance */\n        walletTokenBalance[lockedToken[_id].tokenAddress][msg.sender] = walletTokenBalance[lockedToken[_id].tokenAddress][msg.sender].sub(lockedToken[_id].tokenAmount);\n        \n        /* increase receiver's token balance */\n        walletTokenBalance[lockedToken[_id].tokenAddress][_receiverAddress] = walletTokenBalance[lockedToken[_id].tokenAddress][_receiverAddress].add(lockedToken[_id].tokenAmount);\n        \n        /* remove this id from sender address */\n        uint256 j;\n        uint256 arrLength = depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress].length;\n        for (j=0; j<arrLength; j++) {\n            if (depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress][j] == _id) {\n                depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress][j] = depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress][arrLength - 1];\n                depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress].pop();\n                break;\n            }\n        }\n        \n        /* Assign this id to receiver address */\n        lockedToken[_id].withdrawalAddress = _receiverAddress;\n        depositsByWithdrawalAddress[_receiverAddress].push(_id);\n    }\n    \n    /* Withdraw Tokens */\n    function withdrawTokens(uint256 _id) public {\n        require(block.timestamp >= lockedToken[_id].unlockTime);\n        require(msg.sender == lockedToken[_id].withdrawalAddress);\n        require(!lockedToken[_id].withdrawn);\n        \n        \n        lockedToken[_id].withdrawn = true;\n        \n        /* update balance in address */\n        walletTokenBalance[lockedToken[_id].tokenAddress][msg.sender] = walletTokenBalance[lockedToken[_id].tokenAddress][msg.sender].sub(lockedToken[_id].tokenAmount);\n        \n        /* remove this id from this address */\n        uint256 j;\n        uint256 arrLength = depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress].length;\n        for (j=0; j<arrLength; j++) {\n            if (depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress][j] == _id) {\n                depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress][j] = depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress][arrLength - 1];\n                depositsByWithdrawalAddress[lockedToken[_id].withdrawalAddress].pop();\n                break;\n            }\n        }\n        \n        /* transfer tokens to wallet address */\n        require(Token(lockedToken[_id].tokenAddress).transfer(msg.sender, lockedToken[_id].tokenAmount));\n        emit LogWithdrawal(msg.sender, lockedToken[_id].tokenAmount);\n    }\n\n    /* Get Total Token Balance in Contract */\n    function getTotalTokenBalance(address _tokenAddress) view public returns (uint256)\n    {\n       return Token(_tokenAddress).balanceOf(address(this));\n    }\n    \n    /* Get Total Token Balance by Address */\n    function getTokenBalanceByAddress(address _tokenAddress, address _walletAddress) view public returns (uint256)\n    {\n       return walletTokenBalance[_tokenAddress][_walletAddress];\n    }\n    \n    /* Get All Deposit IDs */\n    function getAllDepositIds() view public returns (uint256[] memory)\n    {\n        return allDepositIds;\n    }\n    \n    /* Get Deposit Details */\n    function getDepositDetails(uint256 _id) view public returns (address _tokenAddress, address _withdrawalAddress, uint256 _tokenAmount, uint256 _unlockTime, bool _withdrawn)\n    {\n        return(lockedToken[_id].tokenAddress,lockedToken[_id].withdrawalAddress,lockedToken[_id].tokenAmount,\n        lockedToken[_id].unlockTime,lockedToken[_id].withdrawn);\n    }\n    \n    /* Get Deposit Details by Withdrawal Address */\n    function getDepositsByWithdrawalAddress(address _withdrawalAddress) view public returns (uint256[] memory)\n    {\n        return depositsByWithdrawalAddress[_withdrawalAddress];\n    }\n    \n    /* Turn Premium Feature ON or OFF */\n    function turnPremiumFeature() public onlyOwner returns (bool success)  {\n        if (premium) {\n            premium = false;\n        } else {\n            premium = true;\n        }\n        return true;\n        \n    }\n\n    /* View BNB Balance */\n    function bnbBalance() public view returns (uint256){\n        return address(this).balance;\n    }\n    \n    /* Update fee Rate with respect to $ */\n    function updateFeeRate(int _feerate) public onlyOwner returns (bool success){\n        feerate = _feerate;\n        return true;\n    }\n    \n    /* Only Recieve Token for Lock */\n    receive() payable external {\n        payable(owner).transfer(msg.value);\n    }\n    \n}\n"}}}