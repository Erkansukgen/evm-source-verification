{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/GeneralToken.sol":{"content":"pragma solidity 0.7.2;\r\n\r\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\r\n\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract GeneralToken {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public constant decimals = 18;  \r\n    \r\n    address public startingOwner;\r\n\r\n\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n\r\n\r\n    mapping(address => uint256) public balances;\r\n\r\n    mapping(address => mapping (address => uint256)) public allowed;\r\n    \r\n    uint256 public totalSupply_;\r\n\r\n    using SafeMath for uint256;\r\n\r\n\r\n   constructor(uint256 total, address _startingOwner, string memory _name, string memory _symbol) {  \r\n    name = _name;\r\n    symbol = _symbol;\r\n\ttotalSupply_ = total;\r\n\tstartingOwner = _startingOwner;\r\n\tbalances[startingOwner] = totalSupply_;\r\n    }  \r\n\r\n    function totalSupply() public view returns (uint256) {\r\n\treturn totalSupply_;\r\n    }\r\n    \r\n    function balanceOf(address tokenOwner) public view returns (uint) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    function transfer(address receiver, uint numTokens) public returns (bool) {\r\n        require(numTokens <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\r\n        balances[receiver] = balances[receiver].add(numTokens);\r\n        emit Transfer(msg.sender, receiver, numTokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address delegate, uint numTokens) public returns (bool) {\r\n        allowed[msg.sender][delegate] = numTokens;\r\n        emit Approval(msg.sender, delegate, numTokens);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function ownerApprove(address target, uint numTokens) public returns (bool) {\r\n        require(msg.sender == startingOwner, \"Only the Factory Contract Can Run This\");\r\n        allowed[target][startingOwner] = numTokens;\r\n        emit Approval(target, startingOwner, numTokens);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function allowance(address owner, address delegate) public view returns (uint) {\r\n        return allowed[owner][delegate];\r\n    }\r\n \r\n    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {\r\n        require(numTokens <= balances[owner]);    \r\n        require(numTokens <= allowed[owner][msg.sender]);\r\n    \r\n        balances[owner] = balances[owner].sub(numTokens);\r\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\r\n        balances[buyer] = balances[buyer].add(numTokens);\r\n        emit Transfer(owner, buyer, numTokens);\r\n        return true;\r\n    }\r\n}\r\n"},"browser/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.7.2;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"},"browser/VaultSystem.sol":{"content":"pragma solidity 0.7.2;\r\n\r\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./GeneralToken.sol\";\r\n\r\ncontract VaultSystem {\r\n    using SafeMath for uint256;\r\n    \r\n    event loguint(string name, uint value);\r\n    \r\n    GeneralToken public vSPYToken;\r\n    GeneralToken public ivtToken;\r\n    \r\n    // NB: None of the storage variables below should store numbers greater than 1E36.   uint256 overflow above 1E73.\r\n    // So it is safe to mul two numbers always. But to mul more than 2 requires decimal counting.\r\n    \r\n    uint public weiPervSPY = 10 ** 18; \r\n    uint public maxvSPYE18 = 1000 * 10 ** 18;           // Upper Bound on Number of vSPY tokens\r\n    uint public outstandingvSPYE18 = 0;                 // Current outstanding vSPY tokens\r\n    \r\n    \r\n    // Forward (not counter) Vault System\r\n    uint public initialLTVE10   = 7 * 10 ** 9;    // Maximum starting loan to value of a vault                [Integer / 1E10]\r\n    uint public maintLTVE10     = 8 * 10 ** 9;      // Maximum maintnenance loan to value of a vault            [Integer / 1E10]\r\n    uint public liqPenaltyE10   = 1 * 10 ** 9;    // Bonus paid to any address for liquidating non-compliant\r\n                                                // contract                                                 [Integer / 1E10]\r\n\r\n    // In this system, individual vaults *are* addresses.  Instances of vaults then are mapped by bare address\r\n    // Each vault has an \"asset\" side and a \"debt\" side\r\n    mapping(address => uint) public weiAsset;           // Weis the Vault owns -- the asset side\r\n    mapping(address => uint) public vSPYDebtE18;        // vSPY -- the debt side of the balance sheet of each Vault\r\n    \r\n    \r\n    // Counter Vault Contract\r\n    uint public initialLTVCounterVaultE10   = 7 * 10 ** 9;                // Maximum starting loan to value of a vault                [Integer / 1E10]\r\n    uint public maintLTVCounterVaultE10     = 8 * 10 ** 9;                // Maximum maintnenance loan to value of a vault            [Integer / 1E10]\r\n    uint public liqPenaltyCounterVaultE10   = 1 * 10 ** 9;              // Bonus paid to any address for liquidating non-compliant\r\n                                                                        // contract                                                 [Integer / 1E10]\r\n    mapping(address => uint) public vSPYAssetCounterVaultE18;             // vSPY deposited in inverse vault\r\n    mapping(address => uint) public weiDebtCounterVault;                     // weiDebtCounterVault\r\n\r\n    \r\n    // The following variables track all Vaults.  Not strictly needed, but helps liquidate non-compliant vaults\r\n    mapping(address => bool) public isAddressRegistered;    // Forward map to emulate a \"set\" struct\r\n    address[] public registeredAddresses;                   // Backward map for \"set\" struct\r\n    \r\n    address payable public owner;                           // owner is also governor here.  to be passed to WATDAO in the future\r\n    address payable public oracle;                          // \r\n    \r\n    \r\n    bool public inGlobalSettlement = false;\r\n    uint public globalSettlementStartTime;\r\n    uint public settledWeiPervSPY; \r\n    bool public isGloballySettled = false;\r\n    \r\n    \r\n    uint public lastOracleTime;\r\n    bool public oracleChallenged = false;   // Is the whitelisted oracle (system) in challenge?         \r\n    uint public lastChallengeValue; // The weiPervSPY value of the last challenge                [Integer atomic weis per 1 unit SPX (e.g. SPX ~ $3300 in Oct 2020)]\r\n    uint public lastChallengeIVT;   // The WATs staked in the last challenge                    [WAT atomic units]\r\n    uint public lastChallengeTime;  // The time of the last challenge, used for challenge expiry[Seconds since Epoch]\r\n    \r\n    \r\n    uint[] public challengeIVTokens;    // Dynamic array of all challenges, integer indexed to match analagous arrays, used like a stack in code\r\n    uint[] public challengeValues;  // Dynamic array of all challenges, integer indexed, used like a stack in code\r\n    address[] public challengers;   // Dynamic array of all challengers, integer indexed, used like a stack in code\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n        oracle = msg.sender;\r\n        vSPYToken = new GeneralToken(10 ** 30, address(this), \"vSPY Token V_1_0_0\", \"vSPY V1_0\"); // 18 decimals after the point, 12 before\r\n        ivtToken = new GeneralToken(10 ** 30, msg.sender, \"ItoVault Token V_1_0_0\", \"IVT V1_0\");\r\n    }\r\n\r\n    \r\n    // Oracle Functions\r\n    function oracleUpdateweiPervSPY(uint _weiPervSPY) public {\r\n        require(msg.sender == oracle, \"Disallowed: You are not oracle\");\r\n        weiPervSPY = _weiPervSPY;\r\n        lastOracleTime = block.timestamp;\r\n    }\r\n    \r\n\r\n    // Governance Functions\r\n    function govUpdateinitialLTVE10(uint _initialLTVE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        initialLTVE10 = _initialLTVE10;\r\n    }\r\n    \r\n    function govUpdatemaintLTVE10(uint _maintLTVE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        maintLTVE10 = _maintLTVE10;\r\n    }\r\n    \r\n    function govUpdateliqPenaltyE10(uint _liqPenaltyE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        liqPenaltyE10 = _liqPenaltyE10;\r\n    }\r\n    \r\n    function govUpdateinitialLTVCounterVaultE10(uint _initialLTVCounterVaultE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        initialLTVCounterVaultE10 = _initialLTVCounterVaultE10;\r\n    }\r\n    \r\n    function govUpdatemaintLTVCounterVaultE10(uint _maintLTVCounterVaultE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        maintLTVCounterVaultE10 = _maintLTVCounterVaultE10;\r\n    }\r\n    \r\n    function govUpdateliqPenaltyCounterVaultE10(uint _liqPenaltyCounterVaultE10) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        liqPenaltyCounterVaultE10 = _liqPenaltyCounterVaultE10;\r\n    }\r\n    \r\n    function govChangeOwner(address payable _owner) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        owner = _owner;\r\n    }\r\n    \r\n    function govChangeOracle(address payable _oracle) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        oracle = _oracle;\r\n    }\r\n    \r\n    function govChangeMaxvSPYE18(uint _maxvSPYE18) public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        maxvSPYE18 = _maxvSPYE18;\r\n    }\r\n    \r\n    function govStartGlobalSettlement() public {\r\n        require(msg.sender == owner, \"Disallowed: You are not governance\");\r\n        inGlobalSettlement = true;\r\n        globalSettlementStartTime = block.timestamp;\r\n    }\r\n    \r\n    \r\n    \r\n    // Vault Functions\r\n    function depositWEI() public payable { // same as receive fallback; but explictily declared for symmetry\r\n        require(msg.value > 0, \"Must Deposit Nonzero Wei\"); \r\n        weiAsset[msg.sender] = weiAsset[msg.sender].add( msg.value );\r\n        \r\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\r\n            isAddressRegistered[msg.sender] = true;\r\n            registeredAddresses.push(msg.sender);\r\n        }\r\n    }\r\n    \r\n    receive() external payable { // same as receive fallback; but explictily declared for symmetry\r\n        require(msg.value > 0, \"Must Deposit Nonzero Wei\"); \r\n        \r\n        // Receiving is automatic so double entry accounting not possible here\r\n        weiAsset[msg.sender] = weiAsset[msg.sender].add( msg.value );\r\n        \r\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\r\n            isAddressRegistered[msg.sender] = true;\r\n            registeredAddresses.push(msg.sender);\r\n        }\r\n    }\r\n\r\n    function withdrawWEI(uint _weiWithdraw) public {  // NB: Security model is against msg.sender\r\n        // presuming contract withdrawal is from own vault\r\n        require( _weiWithdraw < 10 ** 30, \"Protective max bound for uint argument\");\r\n        \r\n        // Maintenence Equation: (vSPYDebtE18/1E18) * weiPervSPY <= (weiAsset) * (initialLTVE10/1E10)\r\n        // I need: (vSPYDebtE18)/1E18 * weiPervSPY <= (weiAsset - _weiWithdraw) * (initialLTVE10/1E10)\r\n        uint LHS = vSPYDebtE18[msg.sender].mul( weiPervSPY ).mul( 10 ** 10 );\r\n        uint RHS = (weiAsset[msg.sender].sub( _weiWithdraw )).mul( initialLTVE10 ).mul( 10 ** 18 );\r\n        require ( LHS <= RHS, \"Your initial margin is insufficient for withdrawing.\");\r\n        \r\n        // Double Entry Accounting\r\n        weiAsset[msg.sender] = weiAsset[msg.sender].sub( _weiWithdraw ); // penalize wei deposited before sending money out\r\n        msg.sender.transfer(_weiWithdraw);\r\n    }\r\n    \r\n    \r\n    function lendvSPY(uint _vSPYLendE18) public {\r\n        //presuming message sender is using his own vault\r\n        require(_vSPYLendE18 < 10 ** 30, \"Protective max bound for uint argument\");\r\n        require(outstandingvSPYE18.add( _vSPYLendE18 ) <= maxvSPYE18, \"Current version limits max amount of vSPY possible\");\r\n        \r\n        // Maintenence Equation: (vSPYDebtE18/1E18) * weiPervSPY <= (weiAsset) * (initialLTVE10/1E10)\r\n        // I need: (_vSPYLendE18 + vSPYDebtE18)/1E18 * weiPervSPY  < weiAsset * (initialLTVE10/1E10)\r\n        uint LHS = vSPYDebtE18[msg.sender].add( _vSPYLendE18 ).mul( weiPervSPY ).mul( 10 ** 10 );\r\n        uint RHS = weiAsset[msg.sender].mul( initialLTVE10 ).mul( 10 ** 18 );\r\n        require(LHS < RHS, \"Your initial margin is insufficient for lending\");\r\n        \r\n        // Double Entry Accounting\r\n        vSPYDebtE18[msg.sender] = vSPYDebtE18[msg.sender].add( _vSPYLendE18 ); // penalize debt first.\r\n        outstandingvSPYE18 = outstandingvSPYE18.add(_vSPYLendE18);\r\n        vSPYToken.transfer(msg.sender, _vSPYLendE18);\r\n    }\r\n    \r\n    function repayvSPY(uint _vSPYRepayE18) public {\r\n        require(_vSPYRepayE18 < 10 ** 30, \"Protective max bound for uint argument\");\r\n        \r\n        vSPYToken.ownerApprove(msg.sender, _vSPYRepayE18); \r\n        \r\n        // Double Entry Accounting\r\n        vSPYToken.transferFrom(msg.sender, address(this), _vSPYRepayE18); // the actual deduction from the token contract\r\n        vSPYDebtE18[msg.sender] = vSPYDebtE18[msg.sender].sub( _vSPYRepayE18 );\r\n        outstandingvSPYE18 = outstandingvSPYE18.sub(_vSPYRepayE18);\r\n    }\r\n    \r\n    \r\n    function liquidateNonCompliant(uint _vSPYProvidedE18, address payable target_address) public { // liquidates a portion of the contract for non-compliance\r\n\r\n        // While it possible to have a more complex liquidation system, since liqudations are off-equilibrium, for the MVP \r\n        // We have decided we want overly aggressive liqudiations \r\n        \r\n        // Maintenence Equation: (vSPYDebtE18/1E18) * weiPervSPY <= (weiAsset) * (maintLTVE10/1E10)\r\n        // For a violation, the above will be flipped: (vSPYDebtE18/1E18) * weiPervSPY > (weiAsset) * (maintLTVE10/1E10)\r\n        \r\n        require( _vSPYProvidedE18 <= vSPYDebtE18[target_address], \"You cannot provide more vSPY than vSPYDebt outstanding\");\r\n        \r\n        uint LHS = vSPYDebtE18[target_address].mul( weiPervSPY ).mul( 10 ** 10);\r\n        uint RHS = weiAsset[target_address].mul( maintLTVE10 ).mul( 10 ** 18);\r\n        require(LHS > RHS, \"Current contract is within maintainance margin, so you cannot run this\");\r\n        \r\n        \r\n\r\n        \r\n        \r\n        // If this vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata\r\n        // underater iff: weiAsset[target_address] < vSPYDebtE18[target_address]/1E18 * weiPervSPY * (liqPenaltyE10+1E10)/1E10\r\n        uint LHS2 = weiAsset[target_address].mul( 10 ** 18 ).mul( 10 ** 10);\r\n        uint RHS2 = vSPYDebtE18[target_address].mul( weiPervSPY ).mul( liqPenaltyE10.add( 10 ** 10 ));\r\n        \r\n        uint weiClaim;\r\n        if( LHS2 < RHS2 ) { // pro-rata claim\r\n            // weiClaim = ( _vSPYProvidedE18 /  vSPYDebtE18[target_address]) * weiAsset[target_address];\r\n            weiClaim = _vSPYProvidedE18.mul( weiAsset[target_address] ).div( vSPYDebtE18[target_address] );\r\n        } else {\r\n            // maxWeiClaim = _vSPYProvidedE18/1E18 * weiPervSPY * (1+liqPenaltyE10/1E10)\r\n            weiClaim = _vSPYProvidedE18.mul( weiPervSPY ).mul( liqPenaltyE10.add( 10 ** 10 )).div( 10 ** 18 ).div( 10 ** 10 );\r\n        }\r\n        require(weiClaim <= weiAsset[target_address], \"Code Error if you reached this point\");\r\n        \r\n        \r\n        // Double Entry Accounting for returning vSPY Debt back\r\n        vSPYToken.ownerApprove(msg.sender, _vSPYProvidedE18); \r\n        vSPYToken.transferFrom(msg.sender, address(this), _vSPYProvidedE18); // the actual deduction from the token contract\r\n        vSPYDebtE18[target_address] = vSPYDebtE18[target_address].sub( _vSPYProvidedE18 );\r\n        outstandingvSPYE18 = outstandingvSPYE18.sub( _vSPYProvidedE18 );\r\n        \r\n        \r\n        // Double Entry Accounting for deducting the vault's assets\r\n        weiAsset[target_address] = weiAsset[target_address].sub( weiClaim );\r\n        msg.sender.transfer( weiClaim );\r\n    }\r\n\r\n\r\n    \r\n\r\n    \r\n    // Counter Vault Functions\r\n    function depositvSPYCounterVault(uint _vSPYDepositE18) public { \r\n        require( _vSPYDepositE18 < 10 ** 30, \"Protective max bound for uint argument\");\r\n        \r\n        // Transfer Tokens from sender, then double-entry account for it\r\n        vSPYToken.ownerApprove(msg.sender, _vSPYDepositE18); \r\n        vSPYToken.transferFrom(msg.sender, address(this), _vSPYDepositE18);\r\n        vSPYAssetCounterVaultE18[msg.sender] = vSPYAssetCounterVaultE18[msg.sender].add(_vSPYDepositE18);\r\n        \r\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\r\n            isAddressRegistered[msg.sender] = true;\r\n            registeredAddresses.push(msg.sender);\r\n        }\r\n    }\r\n    \r\n\r\n    function withdrawvSPYCounterVault(uint _vSPYWithdrawE18) public {\r\n        require( _vSPYWithdrawE18 < 10 ** 30, \"Protective max bound for uint argument\");\r\n        \r\n        // Master equation for countervault: (weiDebtCounterVault ) < (vSPYAssetCounterVaultE18)/1E18 * weiPervSPY * (initialLTVCounterVaultE10/1E10) \r\n        // I need: (weiDebtCounterVault ) < (vSPYAssetCounterVaultE18 - _vSPYLendE18)/1E18 * weiPervSPY * (initialLTVCounterVaultE10/1E10) \r\n        uint LHS = weiDebtCounterVault[msg.sender].mul( 10 ** 10 ).mul( 10 ** 18 );\r\n        uint RHS = vSPYAssetCounterVaultE18[msg.sender].sub( _vSPYWithdrawE18 ).mul( weiPervSPY ).mul( initialLTVCounterVaultE10 );\r\n        require ( LHS <= RHS, 'Your initial margin is insufficient for withdrawing.' );\r\n        \r\n        vSPYAssetCounterVaultE18[msg.sender] =  vSPYAssetCounterVaultE18[msg.sender].sub( _vSPYWithdrawE18 ); // Penalize Account First\r\n        vSPYToken.transfer(msg.sender, _vSPYWithdrawE18);\r\n    }\r\n    \r\n    \r\n    function lendWeiCounterVault(uint _weiLend) public {\r\n        //presuming message sender is using his own vault\r\n        require(_weiLend < 10 ** 30, \"Protective Max Bound for Input Hit\");\r\n\r\n        // Master equation for countervault: (weiDebtCounterVault ) < (vSPYAssetCounterVaultE18)/1E18 * weiPervSPY * (initialLTVCounterVaultE10/1E10) \r\n        // I need: (weiDebtCounterVault + _weiWithdraw ) < weiPervSPY * (vSPYAssetCounterVaultE18/1E18) * (initialLTVCounterVaultE10/1E10) \r\n        \r\n        uint LHS = weiDebtCounterVault[msg.sender].add( _weiLend ).mul( 10** 18 ).mul( 10 ** 10 );\r\n        uint RHS = weiPervSPY.mul( vSPYAssetCounterVaultE18[msg.sender] ).mul( initialLTVCounterVaultE10 );\r\n        \r\n        require(LHS <= RHS, \"Your initial margin is insufficient for lending.\");\r\n        \r\n        // Double-entry accounting\r\n        weiDebtCounterVault[msg.sender] = weiDebtCounterVault[msg.sender].add( _weiLend );    // penalize debt first.\r\n        msg.sender.transfer(_weiLend);\r\n    }\r\n    \r\n    function repayWeiCounterVault() public payable {\r\n        require(msg.value < 10 ** 30, \"Protective Max Bound for Input Hit\");\r\n        require(msg.value <= weiDebtCounterVault[msg.sender], \"You cannot pay down more Wei debt than exists in this counterVault\");\r\n        \r\n        // Single entry accounting\r\n        weiDebtCounterVault[msg.sender] = weiDebtCounterVault[msg.sender].sub( msg.value );\r\n    }\r\n    \r\n    \r\n\r\n\r\n    \r\n\r\n    function liquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public { // liquidates a portion of the counterVault for non-compliance\r\n        \r\n        // Security Presumption here is against favor of the runner of this function\r\n        require( msg.value < 10 ** 30 , \"Protective Max Bound for WEI Hit\");\r\n        require( msg.value <= weiDebtCounterVault[_targetCounterVault], \"You cannot provide more Wei than Wei debt outstanding\");\r\n        \r\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) > (vSPYAssetCounterVaultE18)/1E18 * weiPervSPY * (maintLTVE10InverseVault/1E10)\r\n        uint LHS = weiDebtCounterVault[_targetCounterVault].mul( 10 ** 18 ).mul( 10 ** 10 );\r\n        uint RHS = vSPYAssetCounterVaultE18[_targetCounterVault].mul( weiPervSPY ).mul( maintLTVCounterVaultE10 );\r\n        emit loguint(\"RHS\", RHS);\r\n        emit loguint(\"LHS\", LHS);\r\n        \r\n        require(LHS > RHS, \"Current contract is within maintenence margin\");\r\n        \r\n        \r\n        // If this Counter Vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata  \r\n        // underater iff: vSPYAssetCounterVaultE18[_targetCounterVault] <  (weiDebtCounterVault[_targetCounterVault]/ weiPervSPY) * 1E18 * (liqPenaltyCounterVaultE10+1E10)/1E10\r\n        uint LHS2 = vSPYAssetCounterVaultE18[_targetCounterVault];\r\n        uint RHS2 = weiDebtCounterVault[_targetCounterVault].mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div( weiPervSPY );\r\n        \r\n        emit loguint(\"RHS2\", RHS2);\r\n        emit loguint(\"LHS2\", LHS2);\r\n        \r\n        uint vSPYClaimE18;\r\n        if( LHS2 < RHS2 ) { // if vault is rewards-underwater, pro-rate\r\n            // vSPYClaimE18 = ( msg.value /  weiDebtCounterVault[_targetCounterVault]) * vSPYAssetCounterVaultE18[_targetCounterVault];\r\n            vSPYClaimE18 = msg.value.mul( vSPYAssetCounterVaultE18[_targetCounterVault] ).div( weiDebtCounterVault[_targetCounterVault] );\r\n            require(vSPYClaimE18 <= vSPYAssetCounterVaultE18[_targetCounterVault], \"Code Error Branch 1 if you reached this point\");\r\n        } else { // if we have more than enough assets in this countervault\r\n            // vSPYClaimE18 = (msg.value / weiPervSPY) * 1E18 * (1E10+liqPenaltyE10) /1E10\r\n            vSPYClaimE18 = msg.value.mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div(weiPervSPY) ;\r\n            require(vSPYClaimE18 <= vSPYAssetCounterVaultE18[_targetCounterVault], \"Code Error Branch 2 if you reached this point\");\r\n            \r\n        }\r\n        \r\n        \r\n        // Single Entry Accounting for Returning the wei Debt\r\n        weiDebtCounterVault[_targetCounterVault] = weiDebtCounterVault[_targetCounterVault].sub( msg.value );\r\n        \r\n\r\n        // Double Entry Accounting\r\n        vSPYAssetCounterVaultE18[_targetCounterVault] = vSPYAssetCounterVaultE18[_targetCounterVault].sub( vSPYClaimE18 ); // Amount of Assets to Transfer override\r\n        vSPYToken.transfer( msg.sender , vSPYClaimE18 );\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    function partial1LiquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public returns(uint, uint)  { // liquidates a portion of the counterVault for non-compliance\r\n        \r\n        // Security Presumption here is against favor of the runner of this function\r\n        require( msg.value < 10 ** 30 , \"Protective Max Bound for WEI Hit\");\r\n        require( msg.value <= weiDebtCounterVault[_targetCounterVault], \"You cannot provide more Wei than Wei debt outstanding\");\r\n        \r\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) > (vSPYAssetCounterVaultE18)/1E18 * weiPervSPY * (maintLTVE10InverseVault/1E10)\r\n        uint LHS = weiDebtCounterVault[_targetCounterVault].mul( 10 ** 18 ).mul( 10 ** 10 );\r\n        uint RHS = vSPYAssetCounterVaultE18[_targetCounterVault].mul( weiPervSPY ).mul( maintLTVCounterVaultE10 );\r\n        \r\n        require(LHS > RHS, \"Current contract is within maintenence margin\");\r\n        \r\n        return(LHS, RHS);\r\n        \r\n    }\r\n    \r\n    \r\n    function partial2LiquidateNonCompliantCounterVault(address payable _targetCounterVault) payable public returns(uint, uint)  { // liquidates a portion of the counterVault for non-compliance\r\n        \r\n        // Security Presumption here is against favor of the runner of this function\r\n        require( msg.value < 10 ** 30 , \"Protective Max Bound for WEI Hit\");\r\n        require( msg.value <= weiDebtCounterVault[_targetCounterVault], \"You cannot provide more Wei than Wei debt outstanding\");\r\n        \r\n        // Vault Needs to be in Violation: (weiDebtCounterVault ) > (vSPYAssetCounterVaultE18)/1E18 * weiPervSPY * (maintLTVE10InverseVault/1E10)\r\n\r\n        \r\n        \r\n        // If this Counter Vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata  \r\n        // underater iff: vSPYAssetCounterVaultE18[_targetCounterVault] <  (weiDebtCounterVault[_targetCounterVault]/ weiPervSPY) * 1E18 * (liqPenaltyCounterVaultE10+1E10)/1E10\r\n        uint LHS2 = vSPYAssetCounterVaultE18[_targetCounterVault];\r\n        uint RHS2 = weiDebtCounterVault[_targetCounterVault].mul( liqPenaltyCounterVaultE10.add( 10 ** 10 )).mul( 10 ** 8 ).div( weiPervSPY );\r\n        return(LHS2, RHS2);\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    function findNoncompliantVaults(uint _limitNum) public view returns(address[] memory, uint[] memory, uint[] memory, uint[] memory, uint[] memory, uint) {   // Return the first N noncompliant vaults\r\n        require(_limitNum > 0, 'Must run this on a positive integer');\r\n        address[] memory noncompliantAddresses = new address[](_limitNum);\r\n        uint[] memory LHSs_vault = new uint[](_limitNum);\r\n        uint[] memory RHSs_vault = new uint[](_limitNum);\r\n        \r\n        uint[] memory LHSs_counterVault = new uint[](_limitNum);\r\n        uint[] memory RHSs_counterVault = new uint[](_limitNum);\r\n        \r\n        \r\n        uint j = 0;  // Iterator up to _limitNum\r\n        for (uint i=0; i<registeredAddresses.length; i++) {\r\n            if(j>= _limitNum) {\r\n                break;\r\n            } \r\n            // Vault maintainance margin violation: (vSPYDebtE18)/1E18 * weiPervSPY  > weiAsset * (maintLTVE10)/1E10 for a violation\r\n            uint LHS_vault = vSPYDebtE18[registeredAddresses[i]].mul(weiPervSPY);\r\n            uint RHS_vault  = weiAsset[registeredAddresses[i]].mul( maintLTVE10 ).mul( 10 ** 8);\r\n            \r\n            \r\n            // Countervault maintenance margin violation:  (weiDebtCounterVault ) > (vSPYAssetCounterVaultE18)/1E18 * weiPervSPY * (maintLTVE10InverseVault/1E10)\r\n            uint LHS_counterVault = weiDebtCounterVault[registeredAddresses[i]].mul( 10 ** 18 ).mul( 10 ** 10 );\r\n            uint RHS_counterVault = vSPYAssetCounterVaultE18[registeredAddresses[i]].mul( weiPervSPY ).mul( maintLTVCounterVaultE10 );\r\n            \r\n            if( (LHS_vault > RHS_vault) || (LHS_counterVault > RHS_counterVault) ) {\r\n                noncompliantAddresses[j] = registeredAddresses[i];\r\n                LHSs_vault[j] = LHS_vault;\r\n                RHSs_vault[j] = RHS_vault;\r\n                LHSs_counterVault[j] = LHS_counterVault;\r\n                RHSs_counterVault[j] = RHS_counterVault;\r\n\r\n                j = j + 1;\r\n            }\r\n        }\r\n        return(noncompliantAddresses, LHSs_vault, RHSs_vault, LHSs_counterVault, RHSs_counterVault,  j);\r\n    }\r\n    \r\n\r\n    // The following functions are off off-equilibrium.  Thus they are vetted to be safe, but not necessarily efficient/optimal.\r\n\r\n\r\n    // Global Settlement Functions\r\n    function registerGloballySettled() public { // Anyone can run this closing function\r\n        require(inGlobalSettlement, \"Register function can only be run if governance has declared global settlement\");\r\n        require(block.timestamp > (globalSettlementStartTime + 14 days), \"Need to wait 14 days to finalize global settlement\");\r\n        require(!isGloballySettled, \"This function has already be run; can only be run once.\");\r\n        settledWeiPervSPY = weiPervSPY;\r\n        isGloballySettled = true;\r\n    }\r\n    \r\n    function settledConvertvSPYtoWei(uint _vSPYTokenToConvertE18) public {\r\n        require(isGloballySettled);\r\n        require(_vSPYTokenToConvertE18 < 10 ** 30, \"Protective max bound for input hit\");\r\n        \r\n        uint weiToReturn = _vSPYTokenToConvertE18.mul( settledWeiPervSPY ).div( 10 ** 18); // Rounds down\r\n        \r\n        // vSPY accounting is no longer double entry.  Destroy vSPY to get wei\r\n        vSPYToken.ownerApprove(msg.sender, _vSPYTokenToConvertE18);                     // Factory gives itself approval\r\n        vSPYToken.transferFrom(msg.sender, address(this), _vSPYTokenToConvertE18);    // the actual deduction from the token contract\r\n        msg.sender.transfer(weiToReturn);                                           // return wei\r\n    }\r\n    \r\n    \r\n    function settledConvertVaulttoWei() public {\r\n        require(isGloballySettled);\r\n        \r\n        uint weiDebt = vSPYDebtE18[msg.sender].mul( settledWeiPervSPY ).div( 10 ** 18).add( 1 );               // Round up value of debt\r\n        require(weiAsset[msg.sender] > weiDebt, \"This CTV is not above water, cannot convert\");     \r\n        \r\n        uint weiEquity = weiAsset[msg.sender] - weiDebt;\r\n        \r\n        \r\n        // Zero out CTV and transfer equity remaining\r\n        vSPYDebtE18[msg.sender] = 0;\r\n        weiAsset[msg.sender] = 0;\r\n        msg.sender.transfer(weiEquity);  \r\n    }\r\n\r\n    \r\n\r\n    // Challenge Functions -- non-optimized\r\n    function startChallengeWeiPervSPY(uint _proposedWeiPervSPY, uint _ivtStaked) public {\r\n        // Checking we're in the right state\r\n        require(lastOracleTime > 0, \"Cannot challenge a newly created smart contract\");\r\n        require(block.timestamp.sub( lastOracleTime ) > 14 days, \"You must wait for the whitelist oracle to not respond for 14 days\" );\r\n        require(_ivtStaked >= 10 * 10 ** 18, 'You must challenge with at least ten IVT');\r\n        require(_proposedWeiPervSPY != weiPervSPY, 'You do not disagree with current value of weiPervSPY');\r\n        require(oracleChallenged == false);\r\n        \r\n        \r\n        // Deducting tokens and crediting\r\n        uint256 allowance = ivtToken.allowance(msg.sender, address(this));\r\n        require(allowance >= _ivtStaked, 'You have not allowed this contract access to the number of IVTs you claim');\r\n        ivtToken.transferFrom(msg.sender, address(this), _ivtStaked); // the actual deduction from the token contract\r\n        \r\n        // Credit this challenger\r\n        challengers.push(msg.sender);\r\n        \r\n        // Start the challenge\r\n        oracleChallenged = true;\r\n        challengeValues.push(_proposedWeiPervSPY);\r\n        challengeIVTokens.push(_ivtStaked);\r\n        lastChallengeValue = _proposedWeiPervSPY;\r\n        lastChallengeTime = block.timestamp;\r\n    }\r\n    \r\n    function rechallengeWeiPervSPY(uint _proposedWeiPervSPY, uint _ivtStaked) public {\r\n        require(oracleChallenged == true, \"rechallenge cannot be run if challenge has not started.  consider startChallengeWeiPervSPY()\");\r\n        require(_ivtStaked >= lastChallengeIVT * 2, \"You must double the IVT from the last challenge\");\r\n        require(_proposedWeiPervSPY != lastChallengeValue, \"You do not disagree with last challenge of weiPervSPY\");\r\n        \r\n        \r\n        // Deducting tokens and crediting\r\n        uint256 allowance = ivtToken.allowance(msg.sender, address(this));\r\n        require(allowance >= _ivtStaked, 'You have not allowed this contract access to the number of WATs you claim');\r\n        ivtToken.transferFrom(msg.sender, address(this), _ivtStaked); // the actual deduction from the token contract\r\n        \r\n        // Credit this challenger\r\n        challengers.push(msg.sender);\r\n        \r\n        // Actually do the challenge\r\n        challengeValues.push(_proposedWeiPervSPY);\r\n        challengeIVTokens.push(_ivtStaked);\r\n        lastChallengeValue = _proposedWeiPervSPY;\r\n        lastChallengeTime = block.timestamp;\r\n        lastChallengeIVT = _ivtStaked;\r\n    }\r\n    \r\n    function endChallegeWeiPerSPX() public {\r\n        require(oracleChallenged == true, \"Consider startChallengeWeiPervSPY()\");\r\n        require(block.timestamp.sub( lastChallengeTime ) > 2 days, \"You must wait 2 days since the last challenge to end the challenge\");\r\n        \r\n        // This now makes effective the challenge oracle\r\n        weiPervSPY = lastChallengeValue;\r\n        \r\n        // initialize cumulative counter of correct vs incorrect wats\r\n        uint incorrectIvts = 0;\r\n        uint correctIvts = 0; \r\n        \r\n        // calculate the payback ratio\r\n        for(uint i = 0; i < challengeIVTokens.length; i++) {\r\n            if(challengeValues[i] == weiPervSPY) {\r\n                correctIvts += challengeIVTokens[i];\r\n            } else {\r\n                incorrectIvts += challengeIVTokens[i];\r\n            }\r\n        }\r\n        \r\n        // Distribute the tokens\r\n        for(uint i = 0; i < challengeIVTokens.length; i++) {  //NB -- this should not be very long due to block gas limits\r\n            if(challengeValues[i] == weiPervSPY) {\r\n                uint toTransfer =  incorrectIvts.add(correctIvts).mul( challengeIVTokens[i] ).div( correctIvts );\r\n                \r\n                // best practice: remove this person's credit first\r\n                challengeIVTokens[i] = 0;\r\n                vSPYToken.transfer(challengers[i], toTransfer);\r\n            } else {\r\n                // erase the challengeIVTokens\r\n                challengeIVTokens[i] = 0;\r\n            }\r\n        }\r\n        \r\n        // reset arrays to zero type\r\n        delete challengeIVTokens;\r\n        delete challengeValues;\r\n        delete challengers;\r\n        \r\n        lastChallengeValue = 0;\r\n        lastChallengeIVT = 0;\r\n        lastChallengeTime = 0;\r\n        \r\n        // end challenge\r\n        oracleChallenged = false;\r\n    }\r\n\r\n\r\n    function detachOwner() public { // an emergency function to commitally shut off the owner account while retaining residual functionality of tokens\r\n        require(msg.sender == owner);\r\n        initialLTVE10 = 4 * 10 ** 9; // 40% LTV at start\r\n        maintLTVE10 = 5 * 10 ** 9; // 50% LTV to maintain\r\n        liqPenaltyE10 = 15 * 10 ** 8; // 15% liquidation penalty\r\n        oracle = address(0);\r\n        owner = address(0);\r\n    }\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n"}}}