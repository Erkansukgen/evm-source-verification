{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"LiquidityRouter.sol":{"content":"// SPDX-License-Identifier: Unlicensed\npragma solidity >=0.6.8 <=0.6.13;\n\n\n\ninterface IRouter {\n    function factory() external pure returns(address);\n    function WBASE() external pure returns(address);\n\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns(uint256 amountA, uint256 amountB, uint256 liquidity);\n    function addLiquidityBase(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) external payable returns(uint256 amountToken, uint256 amountBase, uint256 liquidity);\n    function removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns(uint256 amountA, uint256 amountB);\n    function removeLiquidityBase(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) external returns(uint256 amountToken, uint256 amountBase);\n    function removeLiquidityWithPermit( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 amountA, uint256 amountB);\n    function removeLiquidityBaseWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns(uint256 amountToken, uint256 amountBase);\n    function removeLiquidityBaseSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) external returns(uint256 amountBase);\n    function removeLiquidityBaseWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns(uint256 amountBase);\n}\n\ninterface IFactory {\n    function getPair(address tokenA, address tokenB) external view returns(address pair);\n    function createPair(address tokenA, address tokenB) external returns(address pair);\n}\n\ninterface IPair {\n    function balanceOf(address owner) external view returns(uint256);\n\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\n\n    function getReserves() external view returns(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    function mint(address to) external returns(uint256 liquidity);\n    function burn(address to) external returns(uint256 amount0, uint256 amount1);\n}\n\ninterface IWBASE {\n    function deposit() external payable;\n    function transfer(address to, uint256 value) external returns(bool);\n    function withdraw(uint256) external;\n}\n\nlibrary SwapLibrary {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns(address token0, address token1) {\n        require(tokenA != tokenB, 'SwapLibrary: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'SwapLibrary: ZERO_ADDRESS');\n    }\n\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns(address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'f51ca69eb1a82502fdd641b3105488d5e37d94e5277e55f63a9051e664d85c52' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns(uint256 reserveA, uint256 reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1,) = IPair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns(uint256 amountB) {\n        require(amountA > 0, 'SwapLibrary: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'SwapLibrary: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n}\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferBase(address to, uint256 value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: BASE_TRANSFER_FAILED');\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x + y) >= x, 'Router SafeMath: ds-math-add-overflow');\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x - y) <= x, 'Router SafeMath: ds-math-sub-underflow');\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, 'Router SafeMath: ds-math-mul-overflow');\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require((z = x / y) > 0, 'Router SafeMath: ds-math-div-overflow');\n    }\n    function div0(uint256 x, uint256 y) internal pure returns(uint256 z) {\n        require(y > 0);\n        z = x / y;\n        if (z < 0) {\n            z = 0;\n        }\n        return z;\n    }\n}\n\ncontract JMSwapLiquidityRouter is IRouter {\n    using SafeMath for uint256;\n\n    address public immutable override factory;\n    address public immutable override WBASE;\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WBASE) public {\n        factory = _factory;\n        WBASE = _WBASE;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WBASE); // only accept (BSC, ETH) via fallback from the (WBSC, WETH) contract\n    }\n\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin) internal virtual returns(uint256 amountA, uint256 amountB) {\n        // create the pair if it doesn't exist yet\n        if (IFactory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IFactory(factory).createPair(tokenA, tokenB);\n        }\n        (uint256 reserveA, uint256 reserveB) = SwapLibrary.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal = SwapLibrary.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = SwapLibrary.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external virtual override ensure(deadline) returns(uint256 amountA, uint256 amountB, uint256 liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, address(this), amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, address(this), amountB);\n        TransferHelper.safeTransfer(tokenA, pair, IPair(tokenA).balanceOf(address(this)));\n        TransferHelper.safeTransfer(tokenB, pair, IPair(tokenB).balanceOf(address(this)));\n        liquidity = IPair(pair).mint(to);\n    }\n    function addLiquidityBase(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) external virtual override payable ensure(deadline) returns(uint256 amountToken, uint256 amountBase, uint256 liquidity) {\n        (amountToken, amountBase) = _addLiquidity(token, WBASE, amountTokenDesired, msg.value, amountTokenMin, amountBaseMin);\n        address pair = SwapLibrary.pairFor(factory, token, WBASE);\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amountToken);\n        TransferHelper.safeTransfer(token, pair, IPair(token).balanceOf(address(this)));\n        IWBASE(WBASE).deposit{value: amountBase}();\n        assert(IWBASE(WBASE).transfer(pair, amountBase));\n        liquidity = IPair(pair).mint(to);\n        // refund dust (trx, bsc, eth) if any\n        if (msg.value > amountBase) TransferHelper.safeTransferBase(msg.sender, msg.value - amountBase);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) public virtual override ensure(deadline) returns(uint256 amountA, uint256 amountB) {\n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB);\n        IPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IPair(pair).burn(address(this));\n        TransferHelper.safeTransfer(tokenA, to, IPair(tokenA).balanceOf(address(this)));\n        TransferHelper.safeTransfer(tokenB, to, IPair(tokenB).balanceOf(address(this)));\n        (address token0,) = SwapLibrary.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\n    }\n\n    function removeLiquidityBase(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) public virtual override ensure(deadline) returns(uint256 amountToken, uint256 amountBase) {\n        address pair = SwapLibrary.pairFor(factory, token, WBASE);\n        IPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = IPair(pair).burn(address(this));\n        (address token0,) = SwapLibrary.sortTokens(token, WBASE);\n        (amountToken, amountBase) = token == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountToken >= amountTokenMin, 'Router: INSUFFICIENT_TOKEN_AMOUNT');\n        require(amountBase >= amountBaseMin, 'Router: INSUFFICIENT_BASE_AMOUNT');\n        TransferHelper.safeTransfer(token, to, IPair(token).balanceOf(address(this)));\n        IWBASE(WBASE).withdraw(amountBase);\n        TransferHelper.safeTransferBase(to, amountBase);\n    }\n\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external virtual override returns(uint256 amountA, uint256 amountB) {\n        address pair = SwapLibrary.pairFor(factory, tokenA, tokenB);\n        uint256 value = approveMax ? uint256(-1) : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n\n    function removeLiquidityBaseWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external virtual override returns(uint256 amountToken, uint256 amountBase) {\n        address pair = SwapLibrary.pairFor(factory, token, WBASE);\n        uint256 value = approveMax ? uint256(-1) : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountBase) = removeLiquidityBase(token, liquidity, amountTokenMin, amountBaseMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityBaseSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline) public virtual override ensure(deadline) returns(uint256 amountBase) {\n        (, amountBase) = removeLiquidity(token, WBASE, liquidity, amountTokenMin, amountBaseMin, address(this), deadline);\n        TransferHelper.safeTransfer(token, to, IPair(token).balanceOf(address(this)));\n        IWBASE(WBASE).withdraw(amountBase);\n        TransferHelper.safeTransferBase(to, amountBase);\n    }\n\n    function removeLiquidityBaseWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountBaseMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external virtual override returns(uint256 amountBase) {\n        address pair = SwapLibrary.pairFor(factory, token, WBASE);\n        uint256 value = approveMax ? uint256(-1) : liquidity;\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountBase = removeLiquidityBaseSupportingFeeOnTransferTokens(token, liquidity, amountTokenMin, amountBaseMin, to, deadline);\n    }\n}"}}}