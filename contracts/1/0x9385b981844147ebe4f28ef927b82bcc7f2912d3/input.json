{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/RGB.sol":{"content":"pragma solidity ^ 0.7;\r\ncontract Prism{\r\n\taddress address0 = address(0);\r\n\t\r\n\tmapping(address => PyramidProxy) public proxy;\r\n\r\n\tPyramidContract public pyramidContract;\r\n\tERC20 public resolveToken;\r\n\taddress public pyramidAddress;\r\n\taddress public resolveAddress;\r\n\tColorToken public colorBonds;\r\n\tColorToken public colorResolve;\r\n\r\n\tuint bondsIN = 0;\r\n\tuint bondsOUT = 0;\r\n\t\r\n\r\n\tconstructor(address _pyramidAddress) public{\r\n\t\tpyramidAddress = _pyramidAddress;\r\n\t\tpyramidContract = PyramidContract( pyramidAddress );\r\n\t\tresolveToken = pyramidContract.resolveToken();\r\n\t\tresolveAddress = address( resolveToken );\r\n\t\tcolorBonds = new ColorToken( pyramidAddress, \"Color3D Bonds\", \"RGB\" );\r\n\t\tcolorResolve = new ColorToken( resolveAddress, \"Color\", \"`rgb\" );\r\n\t}\r\n\t\r\n\tfunction totalColorBonds() public view returns (uint){\r\n\t\treturn bondsIN - bondsOUT;\r\n\t}\r\n\r\n\r\n\tevent Buy( address indexed addr, uint256 spent, uint256 bonds, uint red, uint green, uint blue);\r\n\tfunction buy(address addr, uint _red, uint _green, uint _blue, address gatewayAddress) payable public returns(uint bondsCreated){\r\n\t\tif(_red>1e18) _red = 1e18;\r\n\t\tif(_green>1e18) _green = 1e18;\r\n\t\tif(_blue>1e18) _blue = 1e18;\r\n\r\n\t\tuint eth4Bonds = msg.value;\r\n\t\t\r\n\t\tuint createdBonds = ensureProxy(addr).buy{value: eth4Bonds }(gatewayAddress);\r\n\t\tbondsIN += createdBonds;\r\n\r\n\t\tcolorBonds.addColor(addr, createdBonds, _red, _green, _blue);\r\n\r\n\t\temit Buy( addr, eth4Bonds, createdBonds, _red, _green, _blue );\r\n\t\t\r\n\t\treturn createdBonds;\r\n  \t}\r\n\r\n  \tevent Sell( address indexed addr,uint cashout, uint256 bondsSold, uint256 resolves, uint initialInput, uint mintedColorWeight);\r\n  \tfunction sell(uint amountToSell) public returns(uint eth, uint resolvesMinted, uint initialInput, uint mintedColorWeight){\r\n  \t\taddress sender = msg.sender;\r\n  \t\tuint bondsBefore = colorBonds.balanceOf(sender);\r\n  \t\tuint[] memory RGB = new uint[](3);\r\n  \t\t(RGB[0], RGB[1], RGB[2]) = colorBonds.RGB_Ratio(sender);\r\n  \t\t(uint numEthers, uint mintedResolves, uint initialInput_ETH, uint destroyedColoredBonds) = proxy[sender].sell(amountToSell);\r\n  \t\tbondsOUT += destroyedColoredBonds;\r\n  \t\tmintedColorWeight = mintedResolves * destroyedColoredBonds / amountToSell;\r\n  \t\tcolorResolve.addColor(sender, mintedColorWeight, RGB[0], RGB[1], RGB[2] );\r\n\r\n\t\temit Sell(sender, numEthers, amountToSell, mintedResolves, initialInput_ETH, mintedColorWeight);\r\n\t\tcolorBonds.thinColor(sender, bondsBefore - amountToSell, bondsBefore );\r\n\t\t\r\n  \t\treturn (numEthers, mintedResolves, initialInput_ETH, mintedColorWeight);\r\n  \t}\r\n\r\n  \tevent Withdraw( address indexed addr, uint256 earnings, uint256 dissolved );\r\n  \tfunction withdraw(uint amount) public returns(uint dissolvedResolves){\r\n  \t\taddress payable sender = msg.sender;\r\n  \t\tuint totalResolves = resolveToken.balanceOf( pyramidAddress );\r\n  \t\tdissolvedResolves = proxy[sender].withdraw(amount);\r\n  \t\tcolorResolve.colorShift(pyramidAddress, address(0), dissolvedResolves, true, totalResolves);\r\n  \t\tuint earned = amount;\r\n\r\n  \t\temit Withdraw( sender, amount, dissolvedResolves);\r\n  \t\treturn dissolvedResolves;\r\n  \t}\r\n\r\n\tevent Reinvest( address indexed addr, uint256 coreEarningsReinvested, uint256 bondsCreated, uint256 dissolved );\r\n  \tfunction reinvest( uint amount ) public returns(uint,uint){\r\n  \t\taddress sender = msg.sender;\r\n\r\n  \t\tuint createdBonds;\r\n  \t\tuint dissolvedResolves;\r\n\r\n\t\t\r\n\r\n\t\tif(amount>0){\r\n\t\t\tuint totalResolves = resolveToken.balanceOf( pyramidAddress );\r\n\t\t\t(createdBonds, dissolvedResolves) = proxy[sender].reinvest( amount );\r\n  \t\t\tcolorResolve.colorShift(pyramidAddress, address(0), dissolvedResolves,true, totalResolves);\r\n\t\t\tbondsIN += createdBonds;\r\n\t\t}else{\r\n\t\t\trevert();\t\r\n\t\t}\r\n\r\n\t\temit Reinvest( sender, amount, createdBonds, dissolvedResolves);\r\n\t\treturn (createdBonds, dissolvedResolves);\r\n  \t}\r\n\r\n  \tevent Stake( address indexed addr, uint256 amountStaked );\r\n  \tfunction stake(uint amountToStake) public{\r\n  \t\taddress sender = msg.sender;\r\n\t\tcolorResolve.colorShift( sender, pyramidAddress, amountToStake,false,0);\r\n\t\tproxy[sender].stake( amountToStake );\r\n\t\t//pushMinecart(sender);\r\n  \t\temit Stake(sender, amountToStake);\r\n  \t}\r\n\r\n  \tevent Unstake( address indexed addr, uint256 pulledResolves, uint256 forfeiture );\r\n  \tfunction unstake(uint amountToUnstake) public returns (uint _forfeiture){\r\n  \t\taddress sender = msg.sender;\r\n\t\tcolorResolve.colorShift( pyramidAddress, sender, amountToUnstake,false,0);\r\n\t\tuint forfeiture = proxy[sender].unstake( amountToUnstake );\r\n  \t\temit Unstake( sender, amountToUnstake, forfeiture);\r\n  \t\treturn forfeiture;\r\n  \t}\r\n\r\n\tfunction setVotingForCR(address candidate) public{\r\n\t\tproxy[msg.sender].setVotingForCR(candidate);\r\n\t}\r\n\tfunction setVotingForGR(uint MR_votingFor) public{\r\n\t\tproxy[msg.sender].setVotingForGR(MR_votingFor);\r\n\t}\r\n\r\n\tfunction auth(address addr) public view returns(bool){\r\n\t\treturn (addr == address(colorResolve) || addr == address(colorBonds) );\r\n\t}\r\n\r\n  \tfunction ensureProxy(address addr) internal returns (PyramidProxy){\r\n\t\tif( address( proxy[addr] ) == address0 ){\r\n\t\t\tPyramidProxy prox = new PyramidProxy( addr );\r\n\t\t\tproxy[addr] = prox;\r\n\t\t}\r\n\t\treturn proxy[addr];\r\n\t}\r\n\r\n  \tfunction external_ensureProxy(address addr) external returns (PyramidProxy){\r\n\t\trequire( auth(msg.sender) );\r\n\t\treturn ensureProxy(addr);\r\n\t}\r\n\r\n\tfunction isContract(address _addr) internal view returns (bool is_contract) {\r\n\t\tuint length = 0;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\tif(length>0) {\r\n\t\t\treturn true;\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract PyramidProxy{\r\n\tPrism public prism;\r\n\taddress public THIS = address(this);\r\n\taddress payable public owner;\r\n\tuint public coloredBonds;\r\n\r\n\tconstructor( address _owner ) public{\r\n\t\tprism = Prism(msg.sender);\r\n\t\towner = address( uint160( _owner ) );\r\n\t}\r\n\r\n\tmodifier authOnly{\r\n\t\trequire(msg.sender == address(prism) || prism.auth(msg.sender) );\r\n\t\t_;\r\n    }\r\n\r\n\tfunction buy(address gatewayAddress) payable external authOnly() returns(uint){\r\n\t\tuint createdBonds = prism.pyramidContract().fund{value: msg.value }(gatewayAddress);\r\n\t\tcoloredBonds += createdBonds;\r\n\t\treturn createdBonds;\r\n\t}\r\n\r\n\tfunction sell(uint amount) external authOnly() returns (uint returnedETH,uint resolveMinted,uint initialETH, uint destroyedColoredBonds){\r\n\t\tdestroyedColoredBonds = amount * coloredBonds / prism.colorBonds().balanceOf(owner);\r\n\t\tcoloredBonds -= destroyedColoredBonds;\r\n\t\t(uint ETH, uint resolves, uint initialInput_ETH) = prism.pyramidContract().sellBonds(amount);\r\n\t\treturn ( ETH , resolves, initialInput_ETH, destroyedColoredBonds );\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint _value) external authOnly(){\r\n\t\tPyramidProxy toProxy = prism.proxy(_to);\r\n\t\t\r\n\t\tif ( msg.sender == address( prism.colorBonds() ) ){\r\n\t\t\tcoloredBonds -= _value;\r\n\t\t\ttoProxy.addColoredBonds( _value );\r\n\t\t}\r\n\r\n\t\tERC20( ColorToken(msg.sender).asset() ).transfer( address( toProxy ), _value );\r\n\t}\r\n\r\n\tfunction addColoredBonds(uint amount) external{\r\n\t\tif( PyramidProxy(msg.sender).prism() == prism ){\r\n\t\t\tcoloredBonds += amount;\r\n\t\t}else{\r\n\t\t\trevert();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction withdraw(uint amount) external authOnly() returns(uint dissolvedResolves){\r\n\t\treturn prism.pyramidContract().withdraw( amount );\r\n\t}\r\n\r\n\tfunction reinvest(uint amount) external authOnly() returns(uint,uint){\r\n\t\treturn prism.pyramidContract().reinvestEarnings( amount );\r\n\t}\r\n\r\n\tfunction stake(uint amount) external authOnly(){\r\n\t\tprism.resolveToken().transfer( prism.pyramidAddress(), amount );\r\n\t}\r\n\r\n\tfunction unstake(uint amount) external authOnly() returns(uint){\r\n\t\treturn prism.pyramidContract().pullResolves( amount );\r\n\t}\r\n\r\n\tfunction unwrapTokens(uint amountToUnwrap) external authOnly(){\r\n\t\tERC20( ColorToken(msg.sender).asset() ).transfer( owner, amountToUnwrap );\r\n\t}\r\n\tfunction setVotingForCR(address candidate) external authOnly(){\r\n\t\tResolveToken( prism.resolveAddress() ).setVotingForCR(candidate);\r\n\t}\r\n\tfunction setVotingForGR(uint MR_votingFor) external authOnly(){\r\n\t\tResolveToken( prism.resolveAddress() ).setVotingForGR(MR_votingFor);\r\n\t}\r\n\r\n\tfallback () payable external {\r\n\t\tuint ETH = msg.value;\r\n\t\t//uint fee = prism.colorFee( ETH );\r\n\t\t//prism.fundPipeline{value: fee }( owner );\r\n\t\t(bool success, ) = owner.call{value: ETH }(\"\");\r\n\t\trequire(success, \"Transfer failed.\");\r\n\t}\r\n}\r\n\r\nabstract contract ERC20{\r\n\tfunction balanceOf(address _owner) public view virtual returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public virtual returns (bool);\r\n    function totalSupply() public view virtual returns (uint256);\r\n}\r\n\r\nabstract contract ResolveToken{\r\n\tfunction setVotingForCR(address candidate) public virtual;\r\n\tfunction setVotingForGR(uint MR_votingFor) public virtual;\r\n}\r\n\r\ncontract ColorToken is ERC20{\r\n\taddress public asset;\r\n\r\n\tmapping(address => uint256) public C;\r\n\tmapping(address => uint256) public red;\r\n\tmapping(address => uint256) public green;\r\n\tmapping(address => uint256) public blue;\r\n\r\n\tuint public totalWeight;\r\n\r\n\tmapping(address => mapping(address => uint)) approvals;\r\n\r\n\tPrism prism;\r\n\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint8 constant public decimals = 18;\r\n\r\n\tconstructor(address _asset, string memory _name, string memory _symbol) public{\r\n\t\tprism = Prism(msg.sender);\r\n\t\tasset = _asset;\r\n\r\n\t\tname = _name;\r\n\t\tsymbol = _symbol;\r\n\t}\r\n\r\n\tmodifier authOnly{\r\n\t\trequire(msg.sender == address(prism) || prism.auth(msg.sender) );\r\n\t\t_;\r\n    }\r\n\t\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 amount,\r\n\t\tbytes data\r\n\t);\r\n\r\n\tfunction totalSupply() public view override returns (uint256) {\r\n        return ERC20( asset ).totalSupply();\r\n    }\r\n\r\n\tevent UnwrapTokens( address indexed addr, uint256 amountUnwrapped);\r\n\tfunction unwrapTokens(uint _value) public {\r\n  \t\taddress sender = msg.sender;\r\n  \t\tuint total = balanceOf(sender);\r\n  \t\tthis.thinColor(sender, total - _value, total);\r\n\t\tprism.proxy(sender).unwrapTokens( _value );\r\n\t\temit UnwrapTokens( sender, _value );\r\n\t}\r\n\r\n\tfunction addColor(address addr, uint color, uint _red, uint _green, uint _blue) public authOnly(){\r\n\t\tred[addr] += _red * color;\r\n\t\tgreen[addr] += _green * color;\r\n\t\tblue[addr] += _blue * color;\r\n\t\tC[addr] += color;\r\n\t}\r\n\r\n\tfunction thinColor(address addr, uint newWeight, uint oldWeight) public authOnly(){\r\n  \t\t(red[addr], green[addr], blue[addr], C[addr]) = RGB_scale( addr, newWeight, oldWeight);\r\n  \t}\r\n\r\n  \tfunction RGB_Ratio() public view returns(uint,uint,uint){\r\n  \t\treturn RGB_Ratio(msg.sender);\r\n  \t}\r\n  \tfunction RGB_Ratio(address addr) public view returns(uint,uint,uint){\r\n  \t\tuint coloredWeight = C[addr];\r\n  \t\tif (coloredWeight==0){\r\n  \t\t\treturn (0,0,0);\r\n  \t\t}\r\n  \t\treturn ( red[addr]/coloredWeight, green[addr]/coloredWeight, blue[addr]/coloredWeight);\r\n  \t}\r\n  \tfunction RGB_scale(address addr, uint numerator, uint denominator) internal view returns(uint,uint,uint,uint){\r\n\t\treturn (red[addr] * numerator / denominator, green[addr] * numerator / denominator, blue[addr] * numerator / denominator, C[addr] * numerator / denominator );\r\n\t}\r\n\r\n\tfunction balanceOf(address addr) public view override returns(uint){\r\n\t\taddress a = address( prism.proxy(addr) );\r\n\t\tif ( a != address(0) )\r\n\t\t\treturn ERC20( asset ).balanceOf( a );\r\n\t\telse\r\n\t\t\treturn 0;\r\n\t}\r\n\r\n\t// Function that is called when a user or another contract wants to transfer funds.\r\n\tfunction transfer(address _to, uint _value, bytes memory _data) public returns (bool) {\r\n\t\tif( Common.isContract(_to) ){\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Standard function transfer similar to ERC20 transfer with no _data.\r\n\t// Added due to backwards compatibility reasons .\r\n\tfunction transfer(address _to, uint _value) public override returns (bool) {\r\n\t\t//standard function transfer similar to ERC20 transfer with no _data\r\n\t\t//added due to backwards compatibility reasons\r\n\t\tbytes memory empty;\r\n\t\tif(Common.isContract(_to)){\r\n\t\t\treturn transferToContract(_to, _value, empty);\r\n\t\t}else{\r\n\t\t\treturn transferToAddress(_to, _value, empty);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//function that is called when transaction target is an address\r\n\tfunction transferToAddress(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//function that is called when transaction target is a contract\r\n\tfunction transferToContract(address _to, uint _value, bytes memory _data) private returns (bool) {\r\n\t\tmoveTokens(msg.sender, _to, _value);\r\n\t\tERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction moveTokens(address _from, address _to, uint _amount) internal virtual{\r\n\t\tprism.external_ensureProxy(_to);\r\n\t\tthis.colorShift(_from, _to, _amount,false,0);\r\n\t\tprism.proxy(_from).transfer(_to, _amount);\r\n\t}\r\n\r\n\tfunction colorShift(address _from, address _to, uint amountOfTokensShifting, bool isGivenTotal, uint givenTotal) public authOnly() virtual returns(uint colorWeightShifted){\r\n\t\tuint totalTokens;\r\n\t\tif( isGivenTotal ){\r\n\t\t\ttotalTokens = givenTotal;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif( _from == prism.pyramidAddress() && asset == prism.resolveAddress() ){\r\n\t\t\t\ttotalTokens = ERC20(asset).balanceOf(_from);\r\n\t\t\t\t//if you do a \"hard transfer\" of colorBonds to the pyramid. it's going to send those bonds to the Pyramid's Proxy.\r\n\t\t\t\t//but not really because the core pyramid contract rejects other tokens.\r\n\t\t\t}else{\r\n\t\t\t\ttotalTokens = ERC20(asset).balanceOf( address( prism.proxy(_from) ) );\r\n\t\t\t}\t\r\n\t\t}\r\n\r\n\t\t(uint red_ratio, uint green_ratio, uint blue_ratio, uint colorWeight) = RGB_scale( _from, amountOfTokensShifting, totalTokens );\r\n\t\tred[_from] -= red_ratio;\r\n\t\tgreen[_from] -= green_ratio;\r\n\t\tblue[_from] -= blue_ratio;\r\n\t\tC[_from] -= colorWeight;\r\n\t\tred[_to] += red_ratio;\r\n\t\tgreen[_to] += green_ratio;\r\n\t\tblue[_to] += blue_ratio;\r\n\t\tC[_to] += colorWeight;\r\n\t\treturn colorWeight;\r\n\t}\r\n\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return approvals[src][guy];\r\n    }\r\n  \t\r\n    function transferFrom(address src, address dst, uint amount) public returns (bool){\r\n    \taddress sender = msg.sender;\r\n        require(approvals[src][sender] >=  amount);\r\n        if (src != sender) {\r\n            approvals[src][sender] -=  amount;\r\n        }\r\n\t\tmoveTokens(src,dst,amount);\r\n\r\n        return true;\r\n    }\r\n    event Approval(address indexed src, address indexed guy, uint amount);\r\n    function approve(address guy, uint amount) public returns (bool) {\r\n    \taddress sender = msg.sender;\r\n        approvals[sender][guy] = amount;\r\n\r\n        emit Approval( sender, guy, amount );\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nabstract contract PyramidContract{\r\n\tfunction sellBonds(uint amount) public virtual returns(uint returned_eth, uint returned_resolves, uint initialInput_ETH);\r\n\tfunction resolveToken() public virtual returns(ERC20);\r\n\tfunction pullResolves(uint amount) public virtual returns(uint);\r\n\tfunction reinvestEarnings(uint amountFromEarnings) public virtual returns(uint,uint);\r\n\tfunction withdraw(uint amount) public virtual returns(uint);\r\n\tfunction fund(address gatewayAddress) payable public virtual returns(uint);\r\n\tfunction resolveEarnings(address _owner) public view virtual returns (uint256 amount);\r\n}\r\n\r\nlibrary Common {\r\n\t//assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n\tfunction isContract(address _addr) public view returns (bool is_contract) {\r\n\t\tuint length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\tif(length>0) {\r\n\t\t\treturn true;\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nabstract contract ERC223ReceivingContract{\r\n    function tokenFallback(address _from, uint _value, bytes calldata _data) external virtual;\r\n}"}}}