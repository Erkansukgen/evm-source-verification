{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "pool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\n\n// NOTICE: Contract begins line 345\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol) {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ninterface IOwnable {\n  function owner() external view returns (address);\n\n  function renounceManagement() external;\n  \n  function pushManagement( address newOwner_ ) external;\n  \n  function pullManagement() external;\n}\n\nabstract contract Ownable is IOwnable {\n\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipPushed( address(0), _owner );\n    }\n\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyOwner() {\n        emit OwnershipPushed( _owner, address(0) );\n        _owner = address(0);\n    }\n\n    function pushManagement( address newOwner_ ) public virtual override onlyOwner() {\n        require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipPushed( _owner, newOwner_ );\n        _newOwner = newOwner_;\n    }\n    \n    function pullManagement() public virtual override {\n        require( msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled( _owner, _newOwner );\n        _owner = _newOwner;\n    }\n}\n\n/**\n * Range Pool is a RangeSwap ERC20 token that facilitates trades between stablecoins. We execute \"optimistic swaps\" --\n * essentially, the pool assumes all tokens to be worth the same amount at all times, and executes as such.\n * The caveat is that tokens must remain within a range, determined by Allocation Points (AP). For example,\n * token A with (lowAP = 1e8) and (highAP = 5e8) must make up 10%-50% of the pool at all times.\n * RangeSwap allows for cheaper execution and higher capital efficiency than existing, priced swap protocols.\n */\ncontract RangePool is ERC20, Ownable {\n\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n\n    /* ========== EVENTS ========== */\n\n    event Swap( address, uint, address );\n    event Add( address, uint );\n    event Remove( address, uint );\n\n    event TokenAdded( address, uint, uint );\n    event BoundsChanged( address, uint, uint );\n    event Accepting( address, bool );\n    event FeeChanged( uint );\n\n\n    /* ========== STRUCTS ========== */\n\n    struct PoolToken {\n        uint lowAP; // 9 decimals\n        uint highAP; // 9 decimals\n        bool accepting; // can send in (swap or add)\n        bool pushed; // pushed to tokens list\n    }\n\n\n    /* ========== STATE VARIABLES ========== */\n\n    mapping( address => PoolToken ) public tokenInfo;\n    address[] public tokens;\n    uint public totalTokens;\n\n    uint public fee; // 9 decimals\n    \n    constructor() ERC20( 'Range Pool Token', 'RPT' ) {\n        _mint( msg.sender, 1e18 );\n        totalTokens = 1e18;\n    }\n\n    /* ========== SWAP ========== */\n\n    // swap amount from firstToken to secondToken\n    function swap( address firstToken, uint amount, address secondToken ) external {\n        require( amount <= maxCanSwap( firstToken, secondToken ), \"Exceeds limit\" );\n\n        emit Swap( firstToken, amount, secondToken );\n\n        uint feeToTake = amount.mul(fee).div(1e9);\n        totalTokens = totalTokens.add( feeToTake );\n\n        IERC20( firstToken ).safeTransferFrom( msg.sender, address(this), amount ); \n        IERC20( secondToken ).safeTransfer( msg.sender, amount.sub( feeToTake ) ); // take fee on amount\n    }\n\n    /* ========== ADD LIQUIDITY ========== */\n\n    // add token to pool as liquidity. returns number of pool tokens minted.\n    function add( address token, uint amount ) external returns ( uint amount_ ) {\n        amount_ = value( amount ); // do this before changing totalTokens or totalSupply\n\n        totalTokens = totalTokens.add( amount ); // add amount to total first\n\n        require( amount <= maxCanAdd( token ), \"Exceeds limit\" );\n\n        IERC20( token ).safeTransferFrom( msg.sender, address(this), amount );\n        emit Add( token, amount );\n\n        _mint( msg.sender, amount_ );\n    }\n\n    // add liquidity evenly across all tokens. returns number of pool tokens minted.\n    function addAll( uint amount ) external returns ( uint amount_ ) {\n        uint sum;\n        for ( uint i = 0; i < tokens.length; i++ ) {\n            IERC20 token = IERC20( tokens[i] );\n            uint send = amount.mul( token.balanceOf( address(this) ) ).div( totalTokens );\n            if (send > 0) {\n                token.safeTransferFrom( msg.sender, address(this), send );\n                emit Add( tokens[i], send );\n                sum = sum.add(send);\n            }\n        }\n        amount_ = value( sum );\n\n        totalTokens = totalTokens.add( sum ); // add amount second (to not skew pool)\n        _mint( msg.sender, amount_ );\n    }\n\n    /* ========== REMOVE LIQUIDITY ========== */\n\n    // remove token from liquidity, burning pool token\n    // pass in amount token to remove, returns amount_ pool tokens burned\n    function remove( address token, uint amount ) external returns (uint amount_) {\n        amount_ = value( amount ); // token balance => pool token balance\n        amount = amount.sub( amount.mul( fee ).div( 1e9 ) ); // take fee\n\n        require( amount <= maxCanRemove( token ), \"Exceeds limit\" );\n        emit Remove( token, amount );\n\n        _burn( msg.sender, amount_ ); // burn pool token\n        totalTokens = totalTokens.sub( amount ); // remove amount from pool less fees\n\n        IERC20( token ).safeTransfer( msg.sender, amount ); // send token removed\n    }\n\n    // remove liquidity evenly across all tokens \n    // pass in amount tokens to remove, returns amount_ pool tokens burned\n    function removeAll( uint amount ) public returns (uint amount_) {\n        uint sum;\n        for ( uint i = 0; i < tokens.length; i++ ) {\n            IERC20 token = IERC20( tokens[i] );\n            uint send = amount.mul( token.balanceOf( address(this) ) ).div( totalTokens );\n\n            if ( send > 0 ) {\n                uint minusFee = send.sub( send.mul( fee ).div( 1e9 ) );\n                token.safeTransfer( msg.sender, minusFee );\n                emit Remove( tokens[i], minusFee ); // take fee\n                sum = sum.add(send);\n            }\n        }\n\n        amount_ = value( sum );\n        _burn( msg.sender, amount_ );\n        totalTokens = totalTokens.sub( sum.sub( sum.mul( fee ).div( 1e9 ) ) ); // remove amount from pool less fees\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    // number of tokens 1 pool token can be redeemed for\n    function redemptionValue() public view returns (uint value_) {\n        value_ = totalTokens.mul(1e18).div( totalSupply() );\n    } \n\n    // token value => pool token value\n    function value( uint amount ) public view returns ( uint ) {\n        return amount.mul( 1e18 ).div( redemptionValue() );\n    }\n\n    // maximum number of token that can be added to pool\n    function maxCanAdd( address token ) public view returns ( uint ) {\n        require( tokenInfo[token].accepting, \"Not accepting token\" );\n        uint maximum = totalTokens.mul( tokenInfo[ token ].highAP ).div( 1e9 );\n        uint balance = IERC20( token ).balanceOf( address(this) );\n        return maximum.sub( balance );\n    }\n\n    // maximum number of token that can be removed from pool\n    function maxCanRemove( address token ) public view returns ( uint ) {\n        uint minimum = totalTokens.mul( tokenInfo[ token ].lowAP ).div( 1e9 );\n        uint balance = IERC20( token ).balanceOf( address(this) );\n        return balance.sub( minimum );\n    }\n\n    // maximum size of trade from first token to second token\n    function maxCanSwap( address firstToken, address secondToken ) public view returns ( uint ) {\n        uint canAdd = maxCanAdd( firstToken);\n        uint canRemove = maxCanRemove( secondToken );\n\n        if ( canAdd > canRemove ) {\n            return canRemove;\n        } else {\n            return canAdd;\n        }\n    }\n\n    // amount of secondToken returned by swap\n    function amountOut( address firstToken, uint amount, address secondToken ) external view returns ( uint ) {\n        if ( amount <= maxCanSwap( firstToken, secondToken ) ) {\n            return amount.sub( amount.mul( fee ).div( 1e9 ) );\n        } else {\n            return 0;\n        }\n    }\n\n    /* ========== SETTINGS ========== */\n\n    // set fee taken on trades\n    function setFee( uint newFee ) external onlyOwner() {\n        fee = newFee;\n        emit FeeChanged( fee );\n    }\n\n    // add new token to pool. allocation points are 9 decimals.\n    // must call toggleAccept to activate token\n    function addToken( address token, uint lowAP, uint highAP ) external onlyOwner() {\n        require( !tokenInfo[ token ].pushed );\n\n        tokenInfo[ token ] = PoolToken({\n            lowAP: lowAP,\n            highAP: highAP,\n            accepting: false,\n            pushed: true\n        });\n\n        tokens.push( token );\n        emit TokenAdded( token, lowAP, highAP );\n    }\n\n    // change bounds of tokens in pool\n    function changeBound( address token, uint newLow, uint newHigh ) external onlyOwner() {\n        tokenInfo[ token ].highAP = newHigh;\n        tokenInfo[ token ].lowAP = newLow;\n\n        emit BoundsChanged( token, newLow, newHigh );\n    }\n\n    // toggle whether to accept incoming token\n    // setting token to false will not allow swaps as incoming token or adds\n    function toggleAccept( address token ) external onlyOwner() {\n        tokenInfo[ token ].accepting = !tokenInfo[ token ].accepting;\n        emit Accepting( token, tokenInfo[ token ].accepting );\n    }\n}"
    }
  }
}