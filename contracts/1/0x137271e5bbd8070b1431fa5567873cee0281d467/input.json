{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/interfaces/v3pool.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity ^0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"
    },
    "contracts/visor.sol": {
      "content": "pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './interfaces/v3pool.sol';\r\nimport './lib/SafeMath.sol';\r\n\r\n\r\ninterface IWETH {\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\n\r\n\r\ninterface v3quoter{\r\n  function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountOut);\r\n}\r\n\r\n\r\ninterface v2pool{\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n\r\ninterface visorpool{\r\n    function deposit(\r\n        uint256 deposit0,\r\n        uint256 deposit1,\r\n        address to\r\n    ) external returns (uint256 shares);\r\n\r\n\r\n    function withdraw(\r\n        uint256 shares,\r\n        address to,\r\n        address from\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n}\r\n\r\n\r\ncontract visor {\r\n    using SafeMath for uint;\r\n    \r\n    address payable public owner;\r\n    \r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n    function withdrawtokenall(address tokenaddr) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\r\n    }\r\n    \r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n\r\n\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata _data\r\n    ) external {\r\n        // require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\r\n        (address tokenIn, address tokenOut) = abi.decode(_data, (address, address));\r\n\r\n\r\n\r\n        (bool isExactInput, uint256 amountToPay) =\r\n            amount0Delta > 0\r\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\r\n                : (tokenOut < tokenIn, uint256(amount1Delta));\r\n        \r\n        _safeTransfer(tokenIn, msg.sender, amountToPay);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\r\n    \r\n        uint256 shareamount;\r\n\r\n        (bool flag, uint256 purchase_amount, address v3pooladdr, address token, address targetpool, bool istoken0, uint256 depositamount)  \r\n            = abi.decode(_data, (bool, uint256, address, address, address, bool, uint256));\r\n        \r\n\r\n\r\n        bytes memory data = abi.encode(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), token);\r\n\r\n        // swap weth to target token\r\n        if(flag){\r\n            v3pool(v3pooladdr).swap(address(this), false, int256(purchase_amount),  1461446703485210103287273052203988822378723970342 - 1, data);\r\n        }else{\r\n            v3pool(v3pooladdr).swap(address(this), true, int256(purchase_amount), 4295128739 + 1, data);\r\n        }\r\n        \r\n        IERC20(token).approve(targetpool, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        // deposit some token to pool\r\n        if(istoken0){\r\n            shareamount = visorpool(targetpool).deposit(depositamount ,0 , address(this));\r\n        }else{\r\n            shareamount = visorpool(targetpool).deposit( 0, depositamount, address(this));\r\n        }\r\n\r\n\r\n        // swap token back to eth on v3\r\n        data = abi.encode(token, address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\r\n        if(flag){\r\n            v3pool(v3pooladdr).swap(address(this), true, int256(IERC20(token).balanceOf(address(this))), 4295128739 + 1, data);\r\n\r\n        }else{\r\n            v3pool(v3pooladdr).swap(address(this), false, int256(IERC20(token).balanceOf(address(this))),  1461446703485210103287273052203988822378723970342 - 1, data);\r\n        }      \r\n        \r\n\r\n        // with draw the shares\r\n       visorpool(targetpool).withdraw(shareamount, address(this), address(this));\r\n\r\n        // withdraw target token,swap that back to weth again\r\n\r\n        data = abi.encode(token, address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\r\n        if(flag){\r\n            v3pool(v3pooladdr).swap(address(this), true, int256(IERC20(token).balanceOf(address(this))), 4295128739 + 1, data);\r\n\r\n        }else{\r\n            v3pool(v3pooladdr).swap(address(this), false, int256(IERC20(token).balanceOf(address(this))),  1461446703485210103287273052203988822378723970342 - 1, data);\r\n        } \r\n\r\n        // transfer back weth\r\n        // IERC20(address(0x956F47F50A910163D8BF957Cf5846D573E7f87CA)).transfer(msg.sender, amountout);\r\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), msg.sender, ((purchase_amount * 3) / 997) + 1 + purchase_amount));\r\n    \r\n    }\r\n\r\n\r\n\r\n    // flag, token < weth\r\n    function visorarb(address v3pool, bool flag, uint256 wethout, address targettoken, address targetpool, bool istoken0, uint256 depositamount) public payable{\r\n        bytes memory data = abi.encode(flag, wethout, v3pool, targettoken, targetpool, istoken0, depositamount);\r\n\r\n        v2pool(address(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc)).swap(0, wethout, address(this), data);\r\n\r\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(owner, \r\n            IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this)));\r\n        /*\r\n        if(flag){\r\n            v2pool(address(v2pool)).swap(0, wethout, address(this), data);\r\n        }else{\r\n            v2pool(address(v2pool)).swap(wethout, 0, address(this), data);\r\n        }\r\n        */\r\n        \r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}"
    }
  }
}