{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/NinjaKITTI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        \n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Pausable is Context {\n\n    event Paused(address account);\n\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    constructor() {\n        _paused = false;\n    }\n\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \n            if (returndata.length > 0) {\n                \n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\ninterface IERC721Receiver {\n   \n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC165 {\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\ninterface IERC721 is IERC165 {\n    \n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Enumerable is IERC721 {\n    \n    function totalSupply() external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\ninterface IERC721Metadata is IERC721 {\n    \n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    string private _name;\n\n    string private _symbol;\n\n    mapping(uint256 => address) private _owners;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(uint256 => address) private _tokenApprovals;\n\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        \n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n   \n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    \n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    \n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    uint256[] private _allTokens;\n\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n \n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; \n            _ownedTokensIndex[lastTokenId] = tokenIndex; \n        }\n\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        \n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; \n        _allTokensIndex[lastTokenId] = tokenIndex; \n\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n\n\ncontract NinjaKITTI is ERC721Enumerable, Ownable {\n    using Strings for uint256;\n\n    uint256 public constant MAX_KITTI = 10000;\n    uint256 public constant PRESALE_PRICE = 0.05 ether;\n    uint256 public constant PRICE = 0.07 ether;\n    uint256 public constant FREEPASS_MAX_MINT = 1;\n    uint256 public constant PRESALE_MAX_MINT = 3;\n    uint256 public constant MAX_PER_MINT = 6;\n    uint256 public constant MAX_KITTI_MINT = 12;\n    uint256 public constant RESERVED_KITTI = 500;\n    address public constant founderAddress = 0x820270a17869f10C6f637765fDd8bD0B41E7bad6;\n    address public constant admin1Address = 0xeff9932b80bb0009b85144fFEB881788C1e41FFE;\n    address public constant admin2Address = 0x501D29b7d66B7ca7C7EF2AfD1CcE5e52E40663A6;\n\n    uint256 public reservedClaimed;\n\n    uint256 public numKITTIMinted;\n\n    string public baseTokenURI;\n\n    bool public publicSaleStarted;\n    bool public presaleStarted;\n\n    mapping(address => bool) public _presaleEligible;\n    mapping(address => bool) public _freepassEligible;\n    mapping(address => uint256) public _totalClaimed;\n\n    event BaseURIChanged(string baseURI);\n    event PresaleMint(address minter, uint256 amountOfKITTI);\n    event PublicSaleMint(address minter, uint256 amountOfKITTI);\n\n    modifier whenPresaleStarted() {\n        require(presaleStarted, \"Presale has not started\");\n        _;\n    }\n\n    modifier whenPublicSaleStarted() {\n        require(publicSaleStarted, \"Public sale has not started\");\n        _;\n    }\n\n    constructor(string memory baseURI) ERC721(\"NinjaKITTI\", \"KITTI\") {\n        baseTokenURI = baseURI;\n    }\n\n    function claimReserved(address recipient, uint256 amount) external onlyOwner {\n        require(reservedClaimed != RESERVED_KITTI, \"Already have claimed all reserved KITTI\");\n        require(reservedClaimed + amount <= RESERVED_KITTI, \"Minting would exceed max reserved KITTI\");\n        require(recipient != address(0), \"Cannot add null address\");\n        require(totalSupply() < MAX_KITTI, \"All tokens have been minted\");\n        require(totalSupply() + amount <= MAX_KITTI, \"Minting would exceed max supply\");\n\n        uint256 _nextTokenId = numKITTIMinted + 1;\n\n        for (uint256 i = 0; i < amount; i++) {\n            _safeMint(recipient, _nextTokenId + i);\n        }\n        numKITTIMinted += amount;\n        reservedClaimed += amount;\n    }\n\n    function addToPresale(address[] calldata addresses) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            require(addresses[i] != address(0), \"Cannot add null address\");\n\n            _presaleEligible[addresses[i]] = true;\n\n            _totalClaimed[addresses[i]] > 0 ? _totalClaimed[addresses[i]] : 0;\n        }\n    }\n\n    function checkPresaleEligiblity(address addr) external view returns (bool) {\n        return _presaleEligible[addr];\n    }\n\n    function addToFreePass(address[] calldata addresses) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; i++) {\n            require(addresses[i] != address(0), \"Cannot add null address\");\n\n            _freepassEligible[addresses[i]] = true;\n\n            _totalClaimed[addresses[i]] > 0 ? _totalClaimed[addresses[i]] : 0;\n        }\n    }\n\n    function checkFreePassEligiblity(address addr) external view returns (bool) {\n        return _freepassEligible[addr];\n    }\n\n    function amountClaimedBy(address owner) external view returns (uint256) {\n        require(owner != address(0), \"Cannot add null address\");\n\n        return _totalClaimed[owner];\n    }\n\n    function mintPresale(uint256 amountOfKITTI) external payable whenPresaleStarted {\n        require(_presaleEligible[msg.sender], \"You are not eligible for the presale\");\n        require(totalSupply() < MAX_KITTI, \"All tokens have been minted\");\n        require(amountOfKITTI <= PRESALE_MAX_MINT, \"Cannot purchase this many tokens during presale\");\n        require(totalSupply() + amountOfKITTI <= MAX_KITTI, \"Minting would exceed max supply\");\n        require(_totalClaimed[msg.sender] + amountOfKITTI <= PRESALE_MAX_MINT, \"Purchase exceeds max allowed\");\n        require(amountOfKITTI > 0, \"Must mint at least one KITTI\");\n        require(PRESALE_PRICE * amountOfKITTI == msg.value, \"ETH amount is incorrect\");\n\n        for (uint256 i = 0; i < amountOfKITTI; i++) {\n            uint256 tokenId = numKITTIMinted + 1;\n\n            numKITTIMinted += 1;\n            _totalClaimed[msg.sender] += 1;\n            _safeMint(msg.sender, tokenId);\n        }\n\n        emit PresaleMint(msg.sender, amountOfKITTI);\n    }\n\n    function mintFreePass(uint256 amountOfKITTI) external payable whenPresaleStarted {\n        require(_freepassEligible[msg.sender], \"You do not have a FREE PASS\");\n        require(totalSupply() < MAX_KITTI, \"All tokens have been minted\");\n        require(amountOfKITTI <= FREEPASS_MAX_MINT, \"Cannot purchase this many tokens during presale\");\n        require(totalSupply() + amountOfKITTI <= MAX_KITTI, \"Minting would exceed max supply\");\n        require(_totalClaimed[msg.sender] + amountOfKITTI <= FREEPASS_MAX_MINT, \"Purchase exceeds max allowed\");\n        require(amountOfKITTI > 0, \"Must mint at least one KITTI\");\n\n        for (uint256 i = 0; i < amountOfKITTI; i++) {\n            uint256 tokenId = numKITTIMinted + 1;\n\n            numKITTIMinted += 1;\n            _totalClaimed[msg.sender] += 1;\n            _safeMint(msg.sender, tokenId);\n        }\n\n        emit PresaleMint(msg.sender, amountOfKITTI);\n    }\n\n    function mint(uint256 amountOfKITTI) external payable whenPublicSaleStarted {\n        require(totalSupply() < MAX_KITTI, \"All tokens have been minted\");\n        require(amountOfKITTI <= MAX_PER_MINT, \"Cannot purchase this many tokens in a transaction\");\n        require(totalSupply() + amountOfKITTI <= MAX_KITTI, \"Minting would exceed max supply\");\n        require(_totalClaimed[msg.sender] + amountOfKITTI <= MAX_KITTI_MINT, \"Purchase exceeds max allowed per address\");\n        require(amountOfKITTI > 0, \"Must mint at least one KITTI\");\n        require(PRICE * amountOfKITTI == msg.value, \"ETH amount is incorrect\");\n\n        for (uint256 i = 0; i < amountOfKITTI; i++) {\n            uint256 tokenId = numKITTIMinted + 1;\n\n            numKITTIMinted += 1;\n            _totalClaimed[msg.sender] += 1;\n            _safeMint(msg.sender, tokenId);\n        }\n\n        emit PublicSaleMint(msg.sender, amountOfKITTI);\n    }\n\n    function togglePresaleStarted() external onlyOwner {\n        presaleStarted = !presaleStarted;\n    }\n\n    function togglePublicSaleStarted() external onlyOwner {\n        publicSaleStarted = !publicSaleStarted;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        baseTokenURI = baseURI;\n        emit BaseURIChanged(baseURI);\n    }\n\n    function withdrawAll() public onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"Insufficent balance\");\n        _widthdraw(admin1Address, ((balance * 5) / 100));\n        _widthdraw(admin2Address, ((balance * 5) / 100));\n        _widthdraw(founderAddress, address(this).balance);\n    }\n\n    function _widthdraw(address _address, uint256 _amount) private {\n        (bool success, ) = _address.call{ value: _amount }(\"\");\n        require(success, \"Failed to widthdraw Ether\");\n    }\n}"
    }
  }
}