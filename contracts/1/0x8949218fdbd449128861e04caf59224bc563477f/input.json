{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "OnebitRouter.sol": {
      "content": "pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface ERC20 {\n    function decimals() external view returns (uint);\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n}\n\ninterface IWeth is ERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\ninterface ISettlement {\n    function getDestAmount(address srcToken, address destToken, uint256 srcAmount, address platformAddress) external view returns (uint destAmount);\n    function swapWithTrustAndPlatform(address srcToken, address destToken, uint srcAmount, uint destAmountMin, address to, address platformAddress) external returns (uint destAmount);\n}\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n}\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'OB TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'OB TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'OB TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'OB TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\ncontract PermissionGroups{\n    \n    address public admin;\n    address public pendingAdmin;\n    \n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"onlyAdmin\");\n        _;\n    }\n\n    function transferAdmin(address newAdmin) external onlyAdmin {\n        pendingAdmin = newAdmin;\n    }\n\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender,\"pendingAdmin != msg.sender\");\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n}\n\n\ncontract AssetManager is PermissionGroups{\n    \n    receive() external payable{}\n    fallback() external payable{}\n    \n    function withdrawEth(address payable _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        TransferHelper.safeTransferETH(_to,_value);\n    }\n    \n    function withdrawToken(address token, address to, uint value) external onlyAdmin{\n        require(to != address(0),\"to == address(0)\");\n        TransferHelper.safeTransfer(token,to,value);\n    }\n    \n    function approveIfBelow(address token, address spender, uint256 amount) internal {\n        uint tokenAllowance = ERC20(token).allowance(address(this), spender);\n        if (tokenAllowance < amount) {\n            if (tokenAllowance != 0) {\n                TransferHelper.safeApprove(token, spender, 0);\n            }\n            TransferHelper.safeApprove(token, spender, uint256(-1));\n        }\n    }\n    \n}\n\n\ncontract Config is AssetManager {\n\n    string constant public VERSION = \"OB Router v1.0.2\";\n    address constant public wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant public usdtAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address constant public uniswapFactory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    address public settlement;\n    \n    mapping(address=>bool) public isTokenEnabled; // the same token as ConversionRate\n    address[] internal listedTokens;\n    \n    mapping(address=>bool) public counterpartyAllowed;\n    address[] internal counterpartyGroup;\n    \n    modifier onlyCounterparty() {\n        require(counterpartyAllowed[msg.sender],\"OB Router onlyCounterparty\");\n        _;\n    }\n    \n    function addCounterparty(address newCounterparty) external onlyAdmin {\n        require(!counterpartyAllowed[newCounterparty],\"duplicated counterparty\"); // prevent duplicates.\n        counterpartyAllowed[newCounterparty] = true;\n        counterpartyGroup.push(newCounterparty);\n    }\n\n    function removeCounterparty (address counterparty) external onlyAdmin {\n        require(counterpartyAllowed[counterparty],\"counterparty is not in the counterpartyGroup.\");\n        counterpartyAllowed[counterparty] = false;\n\n        for (uint i = 0; i < counterpartyGroup.length; i++) {\n            if (counterpartyGroup[i] == counterparty) {\n                counterpartyGroup[i] = counterpartyGroup[counterpartyGroup.length - 1];\n                counterpartyGroup.pop();\n                break;\n            }\n        }\n    }\n    \n    function getCounterpartyGroup() external view returns(address[] memory) {\n        return counterpartyGroup;\n    }\n    \n    function addTokens(address[] calldata _addingTokens) external onlyAdmin {\n        for(uint i=0; i<_addingTokens.length; i++) {\n            addToken(_addingTokens[i]);\n        }\n    }\n\n    function addToken(address token) private {\n        require(!isTokenEnabled[token],\"duplicated token\");\n        isTokenEnabled[token] = true;\n        listedTokens.push(token);\n    }\n    \n    function removeTokens(address[] calldata _removingTokens) external onlyAdmin {\n        for(uint i=0; i<_removingTokens.length; i++) {\n            removeToken(_removingTokens[i]);\n        }\n    }\n    \n    function removeToken(address token) private {\n        require(isTokenEnabled[token],\"token is not in the list.\");\n        isTokenEnabled[token] = false;\n\n        for (uint i = 0; i < listedTokens.length; i++) {\n            if (listedTokens[i] == token) {\n                listedTokens[i] = listedTokens[listedTokens.length - 1];\n                listedTokens.pop();\n                break;\n            }\n        }\n    }\n    \n    function getListedTokens() public view returns(address[] memory) {\n        return listedTokens;\n    }\n    \n    function setSettlement(address _settlement) external onlyAdmin {\n        settlement = _settlement;\n    }\n    \n    function doApprove(address token, uint value) external onlyAdmin {\n        TransferHelper.safeApprove(token, settlement, value);\n    }\n    \n    \n    \n}\n\ncontract SwapUtil is Config {\n    \n    using SafeMath for uint;\n    \n    function trasferToken(address token, address from, address to, uint mount) internal {\n        if (from != address(this)) {\n            TransferHelper.safeTransferFrom(token, from, to, mount);\n        }\n        else if (to != address(this)) {\n            TransferHelper.safeTransfer(token,to,mount);\n        }\n    }\n    \n    function getExternalAmountOut(address srcToken, address destToken, uint srcAmount) public view returns (uint) {\n        address uni_pair = IUniswapV2Factory(uniswapFactory).getPair(srcToken,destToken);\n        if(uni_pair == address(0)) {\n            return 0;\n        }\n        return getUniPairAmountOut(uni_pair, srcToken, destToken, srcAmount);\n    }\n\n    function getUniPairAmountOut(address uni_pair, address tokenA, address tokenB, uint amountIn) internal view returns (uint) {   \n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(uni_pair).getReserves();\n        (uint reserveIn, uint reserveOut) = tokenA < tokenB ? (reserve0, reserve1) : (reserve1, reserve0);\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function _uniswap(address uni_pair, address srcToken, address destToken, uint srcAmount, address to) internal returns (uint) {\n        uint amountOut = getUniPairAmountOut(uni_pair, srcToken, destToken, srcAmount);\n        (uint amount0Out, uint amount1Out) = srcToken < destToken ? (uint(0), amountOut) : (amountOut, uint(0));\n        IUniswapV2Pair(uni_pair).swap(amount0Out, amount1Out, to, new bytes(0));\n        return amountOut;\n    }\n    \n    function isObqToken(address token) public view returns (bool) {\n        if (token == wethAddress || token == usdtAddress) {\n            return true;\n        }\n        else {\n            return isTokenEnabled[token];\n        }\n    }\n\n    function obqSwap(address srcToken, address destToken, address srcAddress, uint srcAmount, uint destAmountMin, address to) internal returns (uint) {\n        if (srcAddress != address(this)) {\n            TransferHelper.safeTransferFrom(srcToken, srcAddress, address(this), srcAmount);\n        }\n        approveIfBelow(srcToken, settlement, srcAmount);\n        return ISettlement(settlement).swapWithTrustAndPlatform(srcToken, destToken, srcAmount, destAmountMin, to, msg.sender);\n    }\n    \n}\n\ncontract OnebitRouter is SwapUtil {\n    \n    function beginWithObqSwap(address srcToken, address bridgeToken, address destToken, address srcAddress, uint256 srcAmount, address to) internal returns (uint) {\n        address uni_pair = IUniswapV2Factory(uniswapFactory).getPair(bridgeToken,destToken);\n        if(uni_pair == address(0)) {\n            revert(\"no uni pair\");\n        }\n\n        uint middle_amount = obqSwap(srcToken, bridgeToken, srcAddress, srcAmount, 1, uni_pair); \n        return _uniswap(uni_pair, bridgeToken, destToken, middle_amount, to);\n    }\n    \n    function endWithObqSwap(address srcToken, address bridgeToken, address destToken, address srcAddress, uint256 srcAmount, address to) internal returns (uint) {\n        address uni_pair = IUniswapV2Factory(uniswapFactory).getPair(srcToken,bridgeToken);\n        if(uni_pair == address(0)) {\n            revert(\"no uni pair\");\n        }\n\n        trasferToken(srcToken,srcAddress,uni_pair,srcAmount);\n        uint middle_amount = _uniswap(uni_pair,srcToken,bridgeToken,srcAmount,address(this));\n        //uint middle_amount = ERC20(bridgeToken).balanceOf(address(this));\n        return obqSwap(bridgeToken, destToken, address(this), middle_amount, 1, to); \n    }\n    \n    function swapTokenForETHWithTrust(address srcToken, uint srcAmount, uint destAmountMin, address to) external returns (uint) {\n        uint destAmount = _swapTokens(srcToken, wethAddress, msg.sender, srcAmount, destAmountMin, address(this));\n        IWeth(wethAddress).withdraw(destAmount);\n        TransferHelper.safeTransferETH(to,destAmount);\n        return destAmount;\n    }\n    \n    function swapTokensWithTrust(address srcToken, address destToken, uint256 srcAmount, uint destAmountMin, address to) external returns (uint destAmount) {\n        return _swapTokens(srcToken,destToken,msg.sender,srcAmount,destAmountMin,to);\n    }\n    \n    function swapETHForToken(address destToken, uint destAmountMin, address to) payable external returns (uint) {\n        uint srcAmount = msg.value;\n        IWeth(wethAddress).deposit{value:srcAmount}();\n        return _swapTokens(wethAddress, destToken,address(this), srcAmount, destAmountMin, to);\n    }\n    \n    function swapTokenForETH(address srcToken, uint srcAmount, uint destAmountMin, address to) external returns (uint) {\n        require(srcAmount <= ERC20(srcToken).balanceOf(address(this)) , \"not enough token trasfered in\");\n        uint destAmount = _swapTokens(srcToken, wethAddress, address(this), srcAmount, destAmountMin, address(this));\n        IWeth(wethAddress).withdraw(destAmount);\n        TransferHelper.safeTransferETH(to,destAmount);\n        return destAmount;\n    }\n    \n    function swapTokens(address srcToken, address destToken, uint srcAmount, uint destAmountMin, address to) external returns (uint) {\n        require(srcAmount <= ERC20(srcToken).balanceOf(address(this)) , \"not enough token trasfered in\");\n        return _swapTokens(srcToken,destToken,address(this),srcAmount,destAmountMin,to);\n    }\n    \n    function _swapTokens(address srcToken, address destToken, address srcAddress, uint256 srcAmount, uint destAmountMin, address to)\n        internal onlyCounterparty returns (uint destAmount) {\n            \n        uint destBalanceBefore = ERC20(destToken).balanceOf(to);\n            \n        if(isObqToken(srcToken)) {\n            if(isObqToken(destToken)) {   \n                destAmount = obqSwap(srcToken, destToken, srcAddress, srcAmount, 1, to); \n            }\n            else {\n                address bridgeToken = srcToken != wethAddress ? wethAddress:usdtAddress;\n                beginWithObqSwap(srcToken, bridgeToken, destToken, srcAddress, srcAmount, to);\n            }\n\n        }\n        else {\n            if(isObqToken(destToken)) {\n                address bridgeToken = destToken != wethAddress ? wethAddress:usdtAddress;\n                endWithObqSwap(srcToken, bridgeToken, destToken, srcAddress, srcAmount, to);  \n            }\n            else {\n                revert(\"not supported\");\n            }\n        }\n        \n        uint destBalanceAfter = ERC20(destToken).balanceOf(to);\n        destAmount = destBalanceAfter.sub(destBalanceBefore);\n\n        require(destAmount > 0, \"amountOut <= 0\"); \n        require(destAmount >= destAmountMin, \"OB router : destAmount is not enough\");\n    }\n\n    function quote(address srcToken, address destToken, uint256 srcAmount, uint256 blockNumber) public view returns (uint) {\n        return getDestAmount(srcToken, destToken,  srcAmount, address(this));\n    } \n    \n    function getDestAmount(address srcToken, address destToken, uint256 srcAmount, address platformAddress) public view returns (uint destAmount) {        \n        if(isObqToken(srcToken)) {\n            if(isObqToken(destToken)) {\n                // srcToken -> destToken : Settlement\n                return ISettlement(settlement).getDestAmount(srcToken,destToken,srcAmount,platformAddress);\n            }\n            else {\n                // srcToken -> bridgeToken : settlement\n                // bridgeToken -> destToken: external swap\n                address bridgeToken = srcToken != wethAddress ? wethAddress:usdtAddress;\n                uint middle_amount = ISettlement(settlement).getDestAmount(srcToken,bridgeToken,srcAmount,platformAddress);\n                if (middle_amount == 0) {\n                    return 0;\n                }\n                return getExternalAmountOut(bridgeToken, destToken, middle_amount);\n            }\n        }\n        else {\n            if(isObqToken(destToken)) {\n                // srcToken -> weth : external swap\n                // weth -> destToken: settlement\n                address bridgeToken = destToken != wethAddress ? wethAddress:usdtAddress;\n                uint middle_amount = getExternalAmountOut(srcToken, bridgeToken, srcAmount);\n                if (middle_amount == 0) {\n                    return 0;\n                }\n                return ISettlement(settlement).getDestAmount(bridgeToken,destToken,middle_amount,platformAddress);\n            }\n            else {\n                return 0;\n            }\n        }  \n    }\n    \n}\n"
    }
  }
}