{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/CL.sol": {
      "content": "// SPDX-License-Identifier: Propertiary\n\npragma solidity >=0.8.0 <0.9.0;\n\ninterface IERC20\n{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IUniswapV2Router01\n{\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01\n{\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IERC721 /* is ERC165 */ {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\ncontract CoinsLootCore \n{\n    struct LootsTokenStackData\n    {\n        uint256     _mTsStackedAt;\n        uint256     _mIntAmount;\n    }\n    \n    \n    struct LootsTokenUnstackData\n    {\n        uint256     _mIntAmount;\n        uint256     _mTsAvailableAfter;\n    }\n    \n    struct LootsProfitData\n    {\n        int256      _m256Amount;\n        uint256     _mUI256GameLock;\n    }\n    \n    event                                                       LootTokenStakeEvent(address indexed _eAddrBy, uint256 _eUI256At, uint256 _eUI256Value);\n    event                                                       LootTokenUnfreezeEvent(address indexed _eAddrBy, uint256 _eUI256Value);\n    event                                                       LootTokenUnstakeEvent(address indexed _eAddrBy, uint256 _eUI256Value);\n    event                                                       LootCheckRedemptionEvent(address indexed _eAddrBy, uint256 _eUI256Nonce);\n    event                                                       NewHashHeadEvent(uint256 indexed _eUI256Height, bytes32 _eB32Hash);\n    event                                                       LootProfitEvent(uint256 indexed _eUI256Index, int256 _eUI256Value, uint256 _eUI256Lock);\n   \n    address private                                             _gAddrOwner;\n    address private                                             _gAddrAuthority;\n    address private                                             _gAddrContractUniswapRouter;\n    address private                                             _gAddrContractStackableToken;\n    address[] private                                           _gAddrMSAuthority;\n    mapping(uint256 => bool) private                            _gMapRedemeedNonce;\n    mapping(uint256 => bytes32) private                         _gMapHashHeads;\n    \n    bool private                                                _gBoolIsActive;\n    \n    mapping(address => LootsTokenUnstackData) private           _gUnstackData;\n    mapping(address => LootsTokenStackData[]) private           _gStackData;\n    \n    mapping(uint256 => LootsProfitData) private                 _gMappingProfit;\n    \n    uint256 constant private                                    PRIZE_TYPE_ETH = 1;\n    uint256 constant private                                    PRIZE_TYPE_TOKEN = 2;\n    uint256 constant private                                    PRIZE_TYPE_EXT_20TOKEN = 3;\n    uint256 constant private                                    PRIZE_TYPE_721TOKEN = 4;\n    \n    constructor() \n    {\n        _gAddrOwner =                           msg.sender;\n        _gAddrAuthority =                       msg.sender;\n        \n        _gAddrContractStackableToken =          0xd919fD88d44F6500cd33B534D27E367a950ef5A3;\n        _gAddrContractUniswapRouter =           0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n        \n        _gBoolIsActive =                        true;\n        \n        _gAddrMSAuthority.push(0x058F2cCc1C27D09402e453C53287a2C9a2a67636);\n        _gAddrMSAuthority.push(0xd919fD88d44F6500cd33B534D27E367a950ef5A3);\n        _gAddrMSAuthority.push(0x1A75280Fe687a3063eD7DA98A275c337c53D3da9);\n    }\n    \n    function replaceRouter(address _pAddrNew) public\n    {\n        require(msg.sender == _gAddrOwner);\n        _gAddrContractUniswapRouter = _pAddrNew;\n    }\n    \n    function replaceMsAuthority(address _pAddrNew) public\n    {\n        for(uint i = 0; i < _gAddrMSAuthority.length;i++)\n        {\n            if(_gAddrMSAuthority[i] == msg.sender)\n            {\n                _gAddrMSAuthority[i] = _pAddrNew;\n                return;\n            }\n        }\n        \n        revert();\n    }\n    \n    function transferOwnership(\n        address _pAddrNewOwner,  uint256 _pUI256Ts,\n        bytes32 _pB32R1, bytes32 _pB32S1, uint8 _pUI8V1,\n        bytes32 _pB32R2, bytes32 _pB32S2, uint8 _pUI8V2,\n        bytes32 _pB32R3, bytes32 _pB32S3, uint8 _pUI8V3\n    ) public\n    {\n        require(_pUI256Ts + 5 minutes > block.timestamp && block.timestamp - 5 minutes < _pUI256Ts);\n        \n        require(ecrecover(keccak256(abi.encodePacked(_pAddrNewOwner, _pUI256Ts)), _pUI8V1, _pB32R1, _pB32S1) == _gAddrMSAuthority[0]);\n        require(ecrecover(keccak256(abi.encodePacked(_pAddrNewOwner, _pUI256Ts)), _pUI8V2, _pB32R2, _pB32S2) == _gAddrMSAuthority[1]);\n        require(ecrecover(keccak256(abi.encodePacked(_pAddrNewOwner, _pUI256Ts)), _pUI8V3, _pB32R3, _pB32S3) == _gAddrMSAuthority[2]);\n        \n        _gAddrOwner = _pAddrNewOwner;\n    }\n    \n    function kill() public\n    {\n        require(msg.sender == _gAddrOwner);\n        selfdestruct(payable(msg.sender));\n    }\n        \n    function setActive(\n        bool _pBoolStatus, uint256 _pUI256Ts,\n        bytes32 _pB32R1, bytes32 _pB32S1, uint8 _pUI8V1,\n        bytes32 _pB32R2, bytes32 _pB32S2, uint8 _pUI8V2,\n        bytes32 _pB32R3, bytes32 _pB32S3, uint8 _pUI8V3\n    ) public\n    {\n        require(_pUI256Ts + 5 minutes > block.timestamp && block.timestamp - 5 minutes < _pUI256Ts);\n        require(ecrecover(keccak256(abi.encodePacked(_pBoolStatus, _pUI256Ts)), _pUI8V1, _pB32R1, _pB32S1) == _gAddrMSAuthority[0]);\n        require(ecrecover(keccak256(abi.encodePacked(_pBoolStatus, _pUI256Ts)), _pUI8V2, _pB32R2, _pB32S2) == _gAddrMSAuthority[1]);\n        require(ecrecover(keccak256(abi.encodePacked(_pBoolStatus, _pUI256Ts)), _pUI8V3, _pB32R3, _pB32S3) == _gAddrMSAuthority[2]);\n        \n        _gBoolIsActive = _pBoolStatus;\n    }\n    \n    function stake(uint256 _pIntAmount) public \n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        require(_pIntAmount > 1000 * 10 ** 18);\n        require(_gUnstackData[msg.sender]._mIntAmount == 0);\n        require(_gUnstackData[msg.sender]._mTsAvailableAfter == 0);\n\n        IERC20 lIERC20Token = IERC20(_gAddrContractStackableToken);\n        \n        require(lIERC20Token.transferFrom(msg.sender, address(this), _pIntAmount) == true);\n        \n        LootsTokenStackData memory data;\n        data._mTsStackedAt = block.timestamp;\n        data._mIntAmount = _pIntAmount;\n        _gStackData[msg.sender].push(data);\n        \n        emit LootTokenStakeEvent(msg.sender, block.timestamp, _pIntAmount);\n    }\n     \n    function requestUnstake() public\n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        require(_gUnstackData[msg.sender]._mIntAmount == 0);\n        require(_gUnstackData[msg.sender]._mTsAvailableAfter == 0);\n        \n        uint256 lUI256ToUnstack = 0;\n        \n        for(uint i = 0; i < _gStackData[msg.sender].length;i++)\n        {\n            lUI256ToUnstack += _gStackData[msg.sender][i]._mIntAmount;\n        }\n        \n        require(lUI256ToUnstack > 0);\n        \n        delete _gStackData[msg.sender];\n        \n        _gUnstackData[msg.sender]._mIntAmount = lUI256ToUnstack;\n        _gUnstackData[msg.sender]._mTsAvailableAfter = block.timestamp + 5 days;\n        \n        emit LootTokenUnfreezeEvent(msg.sender, lUI256ToUnstack);\n    }\n    \n    function unstake() public \n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        require(_gUnstackData[msg.sender]._mIntAmount != 0);\n        require(_gUnstackData[msg.sender]._mTsAvailableAfter <= block.timestamp);\n        \n        IERC20 token = IERC20(_gAddrContractStackableToken);\n        token.transfer(msg.sender, _gUnstackData[msg.sender]._mIntAmount);\n        \n        emit LootTokenUnstakeEvent(msg.sender, _gUnstackData[msg.sender]._mIntAmount);\n        \n        delete _gUnstackData[msg.sender]._mIntAmount;\n        delete _gUnstackData[msg.sender]._mTsAvailableAfter;\n    }\n\n    function setNewAuthority( \n        address _pAddrNewAuthority, uint256 _pUI256Ts,\n        bytes32 _pB32R1, bytes32 _pB32S1, uint8 _pUI8V1,\n        bytes32 _pB32R2, bytes32 _pB32S2, uint8 _pUI8V2,\n        bytes32 _pB32R3, bytes32 _pB32S3, uint8 _pUI8V3) public \n    {\n        require(_pUI256Ts + 5 minutes > block.timestamp && block.timestamp - 5 minutes < _pUI256Ts);\n        require(ecrecover(keccak256(abi.encodePacked(_pAddrNewAuthority, _pUI256Ts)), _pUI8V1, _pB32R1, _pB32S1) == _gAddrMSAuthority[0]);\n        require(ecrecover(keccak256(abi.encodePacked(_pAddrNewAuthority, _pUI256Ts)), _pUI8V2, _pB32R2, _pB32S2) == _gAddrMSAuthority[1]);\n        require(ecrecover(keccak256(abi.encodePacked(_pAddrNewAuthority, _pUI256Ts)), _pUI8V3, _pB32R3, _pB32S3) == _gAddrMSAuthority[2]);\n        \n        _gAddrAuthority = _pAddrNewAuthority;\n    }\n    \n    function verifyAuthoritySignature(bytes32 _pB32Hash, bytes32 _pB32R, bytes32 _pB32S, uint8 _pUI8V) private view returns (bool _rBoolResult)\n    {\n        return ecrecover(_pB32Hash, _pUI8V, _pB32R, _pB32S) == _gAddrAuthority;\n    }\n\n    function claimEthCheck(uint256 _pUI256PrizeAmount, uint256 _pUI256Nonce, bytes32 _pB32R, bytes32 _pB32S, uint8 _pUI8V) public\n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        require(_gMapRedemeedNonce[_pUI256Nonce] == false);\n        require(_pUI256PrizeAmount != 0);\n\n        bytes32 lB32Hash = keccak256(abi.encodePacked(PRIZE_TYPE_ETH, msg.sender, _pUI256PrizeAmount, _pUI256Nonce));\n        require(verifyAuthoritySignature(lB32Hash, _pB32R, _pB32S, _pUI8V) == true);\n        \n        _gMapRedemeedNonce[_pUI256Nonce] = true;\n        \n        payable((msg.sender)).transfer(_pUI256PrizeAmount);\n        \n        emit LootCheckRedemptionEvent(msg.sender, _pUI256Nonce);\n    }\n    \n    function claimErc20TokenCheck(address _pAddrToken, uint256 _pUI256Amount, uint256 _pUI256Nonce, bytes32 _pB32R, bytes32 _pB32S, uint8 _pUI8V) public\n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        IERC20 lIERC20Token = IERC20(_pAddrToken);\n\n        require(_gMapRedemeedNonce[_pUI256Nonce] == false);\n        require(lIERC20Token.balanceOf(address(this)) > _pUI256Amount);\n        require(_pUI256Amount != 0);\n\n        bytes32 lB32Hash = keccak256(abi.encodePacked(PRIZE_TYPE_TOKEN, msg.sender, _pAddrToken, _pUI256Amount, _pUI256Nonce));\n        require(verifyAuthoritySignature(lB32Hash, _pB32R, _pB32S, _pUI8V) == true);\n        \n        _gMapRedemeedNonce[_pUI256Nonce] = true;\n        \n        lIERC20Token.transfer(msg.sender, _pUI256Amount);\n        \n        emit LootCheckRedemptionEvent(msg.sender, _pUI256Nonce);\n    }\n    \n    function claimExtErc20TokenCheck(address _pAddrToken, uint256 _pUI256Amount, address _pAddrFrom, uint256 _pUI256Nonce, bytes32 _pB32R, bytes32 _pB32S, uint8 _pUI8V) public\n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        IERC20 lIERC20FromToken = IERC20(_pAddrFrom);\n       \n        require(_pUI256Amount != 0);\n        bytes32 lB32Hash = keccak256(abi.encodePacked(PRIZE_TYPE_EXT_20TOKEN, msg.sender, _pAddrToken, _pUI256Amount, _pAddrFrom, _pUI256Nonce));\n        require(verifyAuthoritySignature(lB32Hash, _pB32R, _pB32S, _pUI8V) == true);\n        require(_gMapRedemeedNonce[_pUI256Nonce] == false);\n        \n        _gMapRedemeedNonce[_pUI256Nonce] = true;\n        \n        IUniswapV2Router02 lIUniswapRouter = IUniswapV2Router02(_gAddrContractUniswapRouter);\n            \n        address[] memory lArrData = new address[](2);\n            \n        lArrData[0] = _pAddrFrom;\n        lArrData[1] = _pAddrToken;\n            \n        lIERC20FromToken.approve(_gAddrContractUniswapRouter, _pUI256Amount);\n        lIUniswapRouter.swapExactTokensForTokens(_pUI256Amount, 1, lArrData, msg.sender, block.timestamp + 2 hours);\n        \n        emit LootCheckRedemptionEvent(msg.sender, _pUI256Nonce);\n    }\n    \n    function claimErc721TokenCheck(address _pAddrToken, uint256 _pUI256ID, uint256 _pUI256Nonce, bytes32 _pB32R, bytes32 _pB32S, uint8 _pUI8V) public\n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        IERC721 lIERCToken = IERC721(_pAddrToken);\n       \n        bytes32 lB32Hash = keccak256(abi.encodePacked(PRIZE_TYPE_721TOKEN, msg.sender, _pAddrToken, _pUI256ID, _pUI256Nonce));\n        require(verifyAuthoritySignature(lB32Hash, _pB32R, _pB32S, _pUI8V) == true);\n        require(_gMapRedemeedNonce[_pUI256Nonce] == false);\n        require(lIERCToken.ownerOf(_pUI256ID) == address(this));\n        \n        _gMapRedemeedNonce[_pUI256Nonce] = true;\n         \n        lIERCToken.transferFrom(address(this), msg.sender, _pUI256ID);\n        \n        emit LootCheckRedemptionEvent(msg.sender, _pUI256Nonce);\n    }\n    \n    function setHashHead(uint256 _pUI256Height, bytes32 _pB32Hash) public \n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        require(msg.sender == _gAddrOwner);\n        require(_gMapHashHeads[_pUI256Height] == 0);\n        \n        _gMapHashHeads[_pUI256Height] = _pB32Hash;\n        \n        emit NewHashHeadEvent(_pUI256Height, _pB32Hash);\n    }\n    \n    function setProfit(uint256 _pUI256Index, int256 _pI256Value, uint256 _pUI256Lock) public\n    {\n        require(_gBoolIsActive || msg.sender == _gAddrMSAuthority[0] || msg.sender == _gAddrMSAuthority[1] || msg.sender == _gAddrMSAuthority[2]);\n        require(msg.sender == _gAddrOwner);\n        require(_gMappingProfit[_pUI256Index]._m256Amount == 0);\n        \n        LootsProfitData memory lSData;\n        lSData._m256Amount = _pI256Value;\n        lSData._mUI256GameLock = _pUI256Lock;\n        \n        _gMappingProfit[_pUI256Index] = lSData;\n        \n        emit LootProfitEvent(_pUI256Index, _pI256Value, _pUI256Lock);\n    }\n    \n    function getUserStakeCount(address _pAddrTarget) public view returns (uint256 _rUI256Count) \n    {\n        return _gStackData[_pAddrTarget].length;\n    }\n    \n    function getAllUserStakeAmount(address _pAddrTarget) public view returns (uint256 _rUI256Count)\n    {\n        uint lUILocal = 0;\n        \n        for(uint256 i = 0; i < _gStackData[_pAddrTarget].length;i++)\n        {\n            lUILocal += _gStackData[_pAddrTarget][i]._mIntAmount;\n        }\n        \n        return lUILocal;\n    }\n    \n    function getUserStakeInfoAmount(address _pAddrTarget, uint256 _pUI256Slot) public view returns (uint256 _rUI256Count)\n    {\n        return _gStackData[_pAddrTarget][_pUI256Slot]._mIntAmount;\n    }\n    \n    function getUserStakeInfoTime(address _pAddrTarget, uint256 _pUI256Slot) public view returns (uint256 _rUI256Timestamp)\n    {\n        return _gStackData[_pAddrTarget][_pUI256Slot]._mTsStackedAt;\n    }\n    \n    function getUserUnstakeAmount(address _pAddrTarget) public view returns (uint _rUI256Count)\n    {\n        return _gUnstackData[_pAddrTarget]._mIntAmount;\n    }\n    \n    function getUserUnstakeTime(address _pAddrTarget) public view returns (uint _rUI256Timestamp)\n    {\n        return _gUnstackData[_pAddrTarget]._mTsAvailableAfter;\n    }\n    \n    function getHashHead(uint256 _pUI256Height) public view returns (bytes32 _rB32Hash)\n    {\n        return _gMapHashHeads[_pUI256Height];\n    }\n    \n    function isNonceRedemeed(uint256 _pUI256Index) public view returns (bool _rBResult)\n    {\n        return _gMapRedemeedNonce[_pUI256Index];\n    }\n    \n    function getProfitCountByIndex(uint256 _pUI256Index) public view returns (int256 _rI256Profit)\n    {\n        return _gMappingProfit[_pUI256Index]._m256Amount;\n    }\n    \n    function getProfitLockByIndex(uint256 _pUI256Index) public view returns (uint256 _rUI256Lock)\n    {\n        return _gMappingProfit[_pUI256Index]._mUI256GameLock;\n    }\n    \n    fallback() external payable {  }\n    \n    receive() external payable {  }\n}"
    }
  }
}