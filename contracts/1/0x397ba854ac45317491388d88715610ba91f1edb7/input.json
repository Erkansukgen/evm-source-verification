{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/2_Owner.sol": {
      "content": "pragma solidity ^0.7.0;    \npragma experimental ABIEncoderV2;\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"\");\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}    \n\n\nabstract contract IFlashLoanParamsGetter {\n\tfunction getFlashLoanParams(bytes memory _data) public view virtual returns (address[] memory tokens, uint256[] memory amount, uint256[] memory modes);\n}    \n\n\n\nabstract contract ILendingPoolAddressesProvider {\n    function getLendingPool() public view virtual returns (address);\n\n    function setLendingPoolImpl(address _pool) public virtual;\n\n    function getLendingPoolCore() public view virtual returns (address payable);\n\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public virtual;\n\n    function getLendingPoolConfigurator() public view virtual returns (address);\n\n    function setLendingPoolConfiguratorImpl(address _configurator) public virtual;\n\n    function getLendingPoolDataProvider() public view virtual returns (address);\n\n    function setLendingPoolDataProviderImpl(address _provider) public virtual;\n\n    function getLendingPoolParametersProvider() public view virtual returns (address);\n\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public virtual;\n\n    function getTokenDistributor() public view virtual returns (address);\n\n    function setTokenDistributor(address _tokenDistributor) public virtual;\n\n    function getFeeProvider() public view virtual returns (address);\n\n    function setFeeProviderImpl(address _feeProvider) public virtual;\n\n    function getLendingPoolLiquidationManager() public view virtual returns (address);\n\n    function setLendingPoolLiquidationManager(address _manager) public virtual;\n\n    function getLendingPoolManager() public view virtual returns (address);\n\n    function setLendingPoolManager(address _lendingPoolManager) public virtual;\n\n    function getPriceOracle() public view virtual returns (address);\n\n    function setPriceOracle(address _priceOracle) public virtual;\n\n    function getLendingRateOracle() public view virtual returns (address);\n\n    function setLendingRateOracle(address _lendingRateOracle) public virtual;\n}\n\nlibrary EthAddressLib {\n    function ethAddress() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    }\n}    \n\n\nabstract contract ILendingPool {\n    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\n\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\n\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\n\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual payable;\n\tfunction swapBorrowRateMode(address _reserve) external virtual;\n    function getReserves() external virtual view returns(address[] memory);\n\n    /// @param _reserve underlying token address\n    function getReserveData(address _reserve)\n        external virtual\n        view\n        returns (\n            uint256 totalLiquidity,               // reserve total liquidity\n            uint256 availableLiquidity,           // reserve available liquidity for borrowing\n            uint256 totalBorrowsStable,           // total amount of outstanding borrows at Stable rate\n            uint256 totalBorrowsVariable,         // total amount of outstanding borrows at Variable rate\n            uint256 liquidityRate,                // current deposit APY of the reserve for depositors, in Ray units.\n            uint256 variableBorrowRate,           // current variable rate APY of the reserve pool, in Ray units.\n            uint256 stableBorrowRate,             // current stable rate APY of the reserve pool, in Ray units.\n            uint256 averageStableBorrowRate,      // current average stable borrow rate\n            uint256 utilizationRate,              // expressed as total borrows/total liquidity.\n            uint256 liquidityIndex,               // cumulative liquidity index\n            uint256 variableBorrowIndex,          // cumulative variable borrow index\n            address aTokenAddress,                // aTokens contract address for the specific _reserve\n            uint40 lastUpdateTimestamp            // timestamp of the last update of reserve data\n        );\n\n    /// @param _user users address\n    function getUserAccountData(address _user)\n        external virtual\n        view\n        returns (\n            uint256 totalLiquidityETH,            // user aggregated deposits across all the reserves. In Wei\n            uint256 totalCollateralETH,           // user aggregated collateral across all the reserves. In Wei\n            uint256 totalBorrowsETH,              // user aggregated outstanding borrows across all the reserves. In Wei\n            uint256 totalFeesETH,                 // user aggregated current outstanding fees in ETH. In Wei\n            uint256 availableBorrowsETH,          // user available amount to borrow in ETH\n            uint256 currentLiquidationThreshold,  // user current average liquidation threshold across all the collaterals deposited\n            uint256 ltv,                          // user average Loan-to-Value between all the collaterals\n            uint256 healthFactor                  // user current Health Factor\n    );    \n\n    /// @param _reserve underlying token address\n    /// @param _user users address\n    function getUserReserveData(address _reserve, address _user)\n        external virtual\n        view\n        returns (\n            uint256 currentATokenBalance,         // user current reserve aToken balance\n            uint256 currentBorrowBalance,         // user current reserve outstanding borrow balance\n            uint256 principalBorrowBalance,       // user balance of borrowed asset\n            uint256 borrowRateMode,               // user borrow rate mode either Stable or Variable\n            uint256 borrowRate,                   // user current borrow rate APY\n            uint256 liquidityRate,                // user current earn rate on _reserve\n            uint256 originationFee,               // user outstanding loan origination fee\n            uint256 variableBorrowIndex,          // user variable cumulative index\n            uint256 lastUpdateTimestamp,          // Timestamp of the last data update\n            bool usageAsCollateralEnabled         // Whether the user's current reserve is enabled as a collateral\n    );\n\n    function getReserveConfigurationData(address _reserve)\n        external virtual\n        view\n        returns (\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            address rateStrategyAddress,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive\n    );\n\n    // ------------------ LendingPoolCoreData ------------------------\n    function getReserveATokenAddress(address _reserve) public virtual view returns (address);\n    function getReserveConfiguration(address _reserve)\n        external virtual\n        view\n        returns (uint256, uint256, uint256, bool);\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n        public virtual\n        view\n        returns (uint256);\n\n    function getReserveCurrentLiquidityRate(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveCurrentVariableBorrowRate(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveCurrentStableBorrowRate(address _reserve) \n        public virtual\n        view\n        returns (uint256);\n    function getReserveTotalLiquidity(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveAvailableLiquidity(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveTotalBorrowsVariable(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n\n    // ---------------- LendingPoolDataProvider ---------------------\n    function calculateUserGlobalData(address _user)\n        public virtual\n        view\n        returns (\n            uint256 totalLiquidityBalanceETH,\n            uint256 totalCollateralBalanceETH,\n            uint256 totalBorrowBalanceETH,\n            uint256 totalFeesETH,\n            uint256 currentLtv,\n            uint256 currentLiquidationThreshold,\n            uint256 healthFactor,\n            bool healthFactorBelowThreshold\n        );\n}    \n\n\n\n\n\n\n\n/// @title Getter contract for positions from Aave protocol\ncontract AaveV1FullPositionView is DSMath, IFlashLoanParamsGetter {\n\n    address public constant AAVE_V1_LENDING_POOL_ADDRESSES = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n\n    struct UserBorrows {\n        address[] borrowAddr;\n        uint256[] borrowAmounts;\n        uint256[] borrowRateModes;\n    }\n\n    function getUserBorrows(address _user, address[] memory _borrTokens) public view returns (UserBorrows memory borrowsData) {\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_V1_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        borrowsData = UserBorrows({\n            borrowAddr: new address[](_borrTokens.length),\n            borrowAmounts: new uint[](_borrTokens.length),\n            borrowRateModes: new uint[](_borrTokens.length)\n        });\n\n        uint64 borrowPos = 0;\n\n        for (uint64 i = 0; i < _borrTokens.length; i++) {\n            address reserve = _borrTokens[i];\n\n            (,uint256 borrowBalance,,uint256 borrowRateMode,,,,,,) = ILendingPool(lendingPoolAddress).getUserReserveData(reserve, _user);\n\n            // Sum up debt in Eth\n            if (borrowBalance > 0) {\n                borrowsData.borrowAddr[borrowPos] = reserve;\n                borrowsData.borrowAmounts[borrowPos] = borrowBalance;\n                borrowsData.borrowRateModes[borrowPos] = borrowRateMode;\n                borrowPos++;\n            }\n        }\n\n        return borrowsData;\n    }\n\n\n    function getFlashLoanParams(bytes memory _data) public view override returns (address[] memory tokens, uint256[] memory amount, uint256[] memory modes) {\n        (address account, address[] memory borrTokens) = abi.decode(_data, (address,address[]));\n\n        UserBorrows memory borrowsData = getUserBorrows(account, borrTokens);\n\n        return (borrowsData.borrowAddr, borrowsData.borrowAmounts, borrowsData.borrowRateModes);\n    }\n}"
    }
  }
}