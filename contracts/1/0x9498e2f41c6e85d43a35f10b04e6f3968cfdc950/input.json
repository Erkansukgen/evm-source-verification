{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Unixo.sol":{"content":"/*! unixo.sol | (c) 2020 Develop by BelovITLab LLC (smartcontract.ru), author @stupidlovejoy | License: MIT */\n//\n// ██╗░░░██╗███╗░░██╗██╗██╗░░██╗░█████╗░░░░██╗░█████╗░\n// ██║░░░██║████╗░██║██║╚██╗██╔╝██╔══██╗░░░██║██╔══██╗\n// ██║░░░██║██╔██╗██║██║░╚███╔╝░██║░░██║░░░██║██║░░██║\n// ██║░░░██║██║╚████║██║░██╔██╗░██║░░██║░░░██║██║░░██║\n// ╚██████╔╝██║░╚███║██║██╔╝╚██╗╚█████╔╝██╗██║╚█████╔╝\n// ░╚═════╝░╚═╝░░╚══╝╚═╝╚═╝░░╚═╝░╚════╝░╚═╝╚═╝░╚════╝░\n//\n// Official Website : https://unixo.io/\n// \n// Telegram Official Chat : https://t.me/unixo_chat\n\npragma solidity 0.6.6;\n\ncontract Unixo {\n    struct User {\n        uint256 id;\n        uint256 upline_id;\n        address upline;\n        uint256 balance;\n        uint256 profit;\n        uint8 level;\n        uint40 expires;\n        address[] referrals;\n    }\n\n    uint24 public LEVEL_TIME_LIFE = 30 days;\n\n    address payable public root;\n    uint256 public last_id;\n\n    uint256[] public levels;\n    mapping(address => User) public users;\n    mapping(uint256 => address) public users_ids;\n\n    event Register(address indexed addr, address indexed upline, uint256 id);\n    event UpLevel(address indexed addr, uint8 level, uint40 expires);\n    event Profit(address indexed addr, address indexed referral, uint256 value);\n    event Lost(address indexed addr, address indexed referral, uint256 value);\n\n    constructor() public {\n        levels.push(0.1 ether);\n        levels.push(0.3 ether);\n        levels.push(0.9 ether);\n        levels.push(1.8 ether);\n        levels.push(3.6 ether);\n        levels.push(7.2 ether);\n        levels.push(14.4 ether);\n        levels.push(28.8 ether);\n        levels.push(57.6 ether);\n        levels.push(115.2 ether);\n\n        root = 0xb47b7EE03096D1DD8F69ef60bd8FebfF71Ec1364;\n\n        _newUser(root, address(0));\n    }\n    \n    receive() payable external {\n        _register(msg.sender, address(0), msg.value);\n    }\n\n    fallback() payable external {\n        _register(msg.sender, bytesToAddress(msg.data), msg.value);\n    }\n\n    function _send(address _to, uint256 _value) private {\n        require(_to != address(0), \"Zero address\");\n\n        if(!payable(_to).send(_value - 0.01 ether)) {\n            root.transfer(_value);\n        }\n        else root.transfer(0.01 ether);\n    }\n\n    function _newUser(address _addr, address _upline) private {\n        users[_addr].id = ++last_id;\n        users_ids[last_id] = _addr;\n\n        if(users[_upline].id > 0) {\n            users[_addr].upline_id = users[_upline].id;\n            users[_addr].upline = _upline;\n            users[_upline].referrals.push(_addr);\n        }\n\n        emit Register(_addr, _upline, last_id);\n    }\n\n    function _upLevel(address _user, uint8 _level) private {\n        users[_user].level = _level;\n        users[_user].expires = uint40(block.timestamp + LEVEL_TIME_LIFE);\n\n        emit UpLevel(_user, _level, users[_user].expires);\n    }\n\n    function _register(address _user, address _upline, uint256 _value) private {\n        require(_value == levels[users[_user].level], \"Bad value\");\n        require(_user != root, \"Is root\");\n\n        if(users[_user].id == 0) {\n            require(users[_upline].id > 0, \"Bad upline\");\n\n            _newUser(_user, this.findFreeReferrer(_upline));\n        }\n        else require(users[_user].expires < block.timestamp - 3 days, \"Not expires\");\n        \n        _upLevel(_user, users[_user].level);\n        _uplinePay(users[_user].upline, _value);\n    }\n    \n    function _uplinePay(address _user, uint256 _value) private {\n        if(_user == address(0)) {\n            return root.transfer(_value);\n        }\n\n        if(users[_user].expires < block.timestamp && _user != root) {\n            emit Lost(_user, tx.origin, _value);\n\n            return _uplinePay(users[_user].upline, _value);\n        }\n\n        uint256 cap = levels[users[_user].level] * 3;\n\n        if(users[_user].level < levels.length - 1) {\n            uint256 next_price = levels[users[_user].level + 1];\n            uint256 max_profit = cap - next_price;\n\n            if(users[_user].profit < max_profit) {\n                uint256 max_value = max_profit - users[_user].profit;\n                uint256 profit = _value;\n\n                if(max_value < profit) {\n                    profit = max_value;\n                }\n                \n                users[_user].profit += profit;\n                _value -= profit;\n\n                _send(_user, profit);\n                \n                emit Profit(_user, tx.origin, profit);\n            }\n\n            if(_value > 0) {\n                uint256 b = users[_user].balance + _value;\n\n                if(b >= next_price) {\n                    users[_user].balance = 0;\n                    users[_user].profit = 0;\n\n                    if(b > next_price) {\n                        uint256 p = b - next_price;\n                        b -= p;\n\n                        users[_user].profit += p;\n\n                        _send(_user, p);\n                        \n                        emit Profit(_user, tx.origin, p);\n                    }\n\n                    _upLevel(_user, users[_user].level + 1);\n                    _uplinePay(users[_user].upline, b);\n                }\n                else users[_user].balance += _value;\n            }\n        }\n        else {\n            if(users[_user].profit < cap) {\n                users[_user].profit += _value;\n\n                _send(_user, _value);\n\n                emit Profit(_user, tx.origin, _value);\n            }\n            else _uplinePay(users[_user].upline, _value);\n        }\n    }\n\n    function register(uint256 _upline_id) payable external {\n        _register(msg.sender, users_ids[_upline_id], msg.value);\n    }\n\n    function destruct() external {\n        require(msg.sender == root, \"Access denied\");\n\n        selfdestruct(root);\n    }\n\n    function findFreeReferrer(address _user) external view returns(address) {\n        if(users[_user].referrals.length < 3) return _user;\n\n        address[] memory refs = new address[](1023);\n        \n        refs[0] = users[_user].referrals[0];\n        refs[1] = users[_user].referrals[1];\n        refs[2] = users[_user].referrals[2];\n\n        for(uint16 i = 0; i < 1023; i++) {\n            if(users[refs[i]].referrals.length < 3) {\n                return refs[i];\n            }\n\n            if(i < 340) {\n                uint16 n = (i + 1) * 3;\n\n                refs[n] = users[refs[i]].referrals[0];\n                refs[n + 1] = users[refs[i]].referrals[1];\n                refs[n + 2] = users[refs[i]].referrals[2];\n            }\n        }\n\n        revert(\"No free referrer\");\n    }\n\n    function bytesToAddress(bytes memory _data) private pure returns(address addr) {\n        assembly {\n            addr := mload(add(_data, 20))\n        }\n    }\n}"}}}