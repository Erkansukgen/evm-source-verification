{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Faucet.sol":{"content":"/**\r\n *Submitted for verification at Etherscan.io on 2021-08-22\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// Faucet contract\r\n// Para no tener que dar uno a uno los tokens, tenemos este contrato de \"faucet\"\r\n//\r\n// ¿Qué es un Faucet? es una forma muy común de distribuir nuevos Tokens.\r\n//\r\n// Consiste en un contrato (que _suele_ tener una página web asociada)\r\n// que distribuye los tokens a quien los solicita.\r\n// Así el que crea el token no tiene que pagar por distribuir los tokens,\r\n// y sólo los interesados 'pagan' a los mineros de la red por el coste de la transacción.\r\n\r\npragma solidity >=0.7.0;\r\n\r\n\r\ninterface iERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n \r\ncontract Faucet {\r\n\r\n   // Vamos a hacer un Faucet_muy_ sencillo:\r\n   //   - No podemos saber de qué país es cada dirección así que:\r\n   //   - Cada dirección de Ethereum debe poder participar en el Airdrop.\r\n   //   - A cada dirección que lo solicite le transferimos 1000 unidades del tocken.\r\n   //   - Sólo se puede participar en el airdrop una sola vez. \r\n   //   - Si hay algún problema, la transacción _falla_\r\n   \r\n   // Primero necesitamos la dirección del contrato del Token\r\n   \r\n   address public immutable token;\r\n   address public _root;\r\n\r\n   // También necesitamos una lista de direcciones.\r\n   // Un \"mapping\" direccion -> a un 0 o 1 bastaría...\r\n   // .. pero ese tipo de dato no existe en este lenguaje)\r\n   // .. así que hay que construirlo a mano.\r\n\r\n   // este es un bitmap (hay formas más eficientes de hacerlo, pero esta nos sirve)   \r\n   mapping (address => uint256) public claimed;\r\n   uint256 public immutable claimAmount;\r\n\r\n   event Claimed(address _by, address _to, uint256 _value);\r\n   \r\n   // Cantidad solicitada por cada dirección\r\n   function ClaimedAmount(address index) public view returns (uint256) {\r\n       return claimed[index];\r\n   }\r\n      \r\n   function _setClaimed(address index) private {\r\n       require(claimed[index] == 0);\r\n       claimed[index] += claimAmount;  // No puede desbordar\r\n   }\r\n   \r\n   // Esta funcion es la que permite reclamar los tokens.\r\n   // No hace falta ser el dueño de la dirección para solicitarlo.\r\n   // De todos modos... ¿quién puede querer enviar tokens a otro?\r\n   // Hmm.. ¿puede haber alguna implicación legal de eso?\r\n   \r\n   function Claim(address index) public returns (uint256) {\r\n      // hmm... ¿dejamos que lo haga un smart contract?\r\n      require(msg.sender == tx.origin, \"Only humans\");\r\n\r\n      require(ClaimedAmount(index) == 0 && index != address(0));\r\n\r\n      _setClaimed(index);\r\n      // Hacemos la transferencia y revertimos operacion si da algún error\r\n      require(iERC20(token).transfer(index, claimAmount), \"Airdrop: error transferencia\");\r\n      emit Claimed(msg.sender, index, claimAmount);\r\n      return claimAmount;\r\n   }\r\n\r\n   // Cuando acabe el tiempo del airdrop se pueden recuperar\r\n   // a menos que haya alguna logica en el token que no lo permita...\r\n\r\n   // Se permite que Recovertokens lo llame un contrato por motivos fiscales.\r\n   // Si se llama a Recovertokens desde una direccion \"normal\" de Ethereum\r\n   // hacienda nos puede obligar a tributar por tener los tokens durante unos segundos.\r\n\r\n   function Recovertokens() public returns (bool) {\r\n      require(tx.origin == _root || msg.sender == _root , \"tx.origin is not root\");\r\n      uint256 allbalance = iERC20(token).balanceOf(address(this));\r\n      return iERC20(token).transfer(_root, allbalance);\r\n   }\r\n\r\n   // SetRoot permite cambiar el superusuario del contrato\r\n   // es decir, la dirección a la que se permite reclamar\r\n   // todos los tokens. Se puede llamar desde un contrato!\r\n\r\n   event NewRootEvent(address);\r\n\r\n   function SetRoot(address newroot) public {\r\n      require(msg.sender == _root); // sender \r\n      address oldroot = _root;\r\n      emit NewRootEvent(newroot);\r\n      _root = newroot;\r\n   } \r\n   \r\n   // Necesitamos construir el contrato (instanciar)\r\n   // Constructor\r\n\r\n   constructor(address tokenaddr, uint256 claim_by_addr) {\r\n       token = tokenaddr;\r\n       claimAmount = claim_by_addr;\r\n       _root = tx.origin;  // La persona (humana?) que crea el contrato.\r\n   }\r\n\r\n}"}}}