{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/staking.sol": {
      "content": "pragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\";\r\nimport \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\";\r\n\r\ninterface IERC20 {\r\nfunction totalSupply() external view returns (uint256);\r\nfunction balanceOf(address account) external view returns (uint256);\r\nfunction transfer(address recipient, uint256 amnt) external returns (bool);\r\nfunction allowance(address owner, address spender) external view returns (uint256);\r\nfunction approve(address spender, uint256 amount) external returns (bool);\r\nfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract Hedge is Ownable {\r\n\r\naddress[] private usrs;\r\naddress[] private allTkn;\r\nuint256 public voteOpen;\r\naddress public oldToken;\r\naddress private constant taxFeeAddress = 0xE6D34C72C128834C3298ACF0601e2Ac0D57E9737; // change to address you want tax to be sent to\r\naddress private constant nativeOrkaAddress = 0xfd7fe1B4d589cC80FB16852A38418F83145A573E; // change to native orka address\r\naddress private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // change to weth mainnet address\r\naddress private constant uniAddr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\nuint256 public wETHInvested;\r\nuint256 public wETHProfits;\r\nuint256 public minFund = 50000000000000000; // change to min fund\r\nuint256 public totVote;\r\nuint256 public returnVote;\r\nuint256 public returnLPVote;\r\nuint256 public investedTimestamp;\r\nuint256 public voteTime = 1603791000; // change to vote time\r\nuint256 private feePercent = 5; //// change fee percent\r\n\r\nIUniswapV2Router02 private uni;\r\n\r\nstruct Investor {\r\nuint256 stake;\r\naddress addr;\r\naddress voted;\r\nuint256 stakePer;\r\nuint8 votedReturn;\r\nuint8 invested;\r\n}\r\n    \r\nmapping(address => Investor) public usr;\r\nmapping(address => uint256) public tAddr;\r\n\r\nIERC20 private fundTkn;\r\n\r\nconstructor(IERC20 stakingToken) public {\r\nfundTkn = stakingToken;\r\nuni = IUniswapV2Router02(uniAddr);\r\n}\r\n\r\nfunction fund(uint256 amnt) external {\r\nif(usr[msg.sender].addr == address(0)) {\r\nusr[msg.sender].addr = msg.sender;\r\nusrs.push(msg.sender);\r\n}\r\n// take tax fee\r\nuint256 feeAmount = amnt*feePercent/100;\r\nuint256 finalAmount = amnt-feeAmount;\r\nusr[msg.sender].stake = usr[msg.sender].stake+finalAmount;\r\nfundTkn.transferFrom(msg.sender, address(this), amnt);\r\nfundTkn.transfer(taxFeeAddress, feeAmount);\r\n}\r\n\r\nfunction withdraw() public { withdraw(0); }\r\n\r\nfunction withdraw(uint256 amnt) public {\r\nrequire(usr[msg.sender].voted == address(0), \"Remove vote to withdraw\");\r\nuint256 fundBal = fundTkn.balanceOf(address(this));\r\nrequire(fundBal > 0, \"ERR\");\r\nif(amnt == 0) { amnt = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; }\r\nif(amnt > usr[msg.sender].stake) { amnt = usr[msg.sender].stake; }\r\nif(amnt > fundBal) { amnt = fundBal; }\r\n// take tax fee\r\nuint256 feeAmount = amnt*feePercent/100;\r\nuint256 finalAmount = amnt-feeAmount;\r\nrequire(usr[msg.sender].stake >= finalAmount, \"Your balance is too low\");\r\nusr[msg.sender].stake = usr[msg.sender].stake-amnt;\r\nfundTkn.transfer(msg.sender, finalAmount);\r\nfundTkn.transfer(taxFeeAddress, feeAmount);\r\n}\r\n\r\n// add vote\r\nfunction vote(address tkn) external {\r\nrequire(usr[msg.sender].stake >= minFund || usr[msg.sender].invested > 0, \"Your balance is too low\");\r\nrequire(tkn != nativeOrkaAddress, \"Cannot vote for this token\");\r\n\r\nuint256 checkVotes;\r\nif(voteOpen == 1) {\r\nrequire(tkn != oldToken, \"Already invested in this token\");\r\nrequire(usr[msg.sender].invested == 1, \"You can only vote to return the vote\");\r\n// if its users first time voting calculate check votes\r\nif(usr[msg.sender].voted == address(0)) {\r\ncheckVotes = totVote+1;\r\n}\r\n// reset users return vote if previously voted return\r\nif(usr[msg.sender].votedReturn > 0) {\r\nusr[msg.sender].votedReturn = 0;\r\nreturnLPVote-=1;\r\n}\r\n}\r\n\r\n// if vote is closed\r\nif(voteOpen == 1 && checkVotes > returnVote/2) {\r\n    \r\n// swap token here\r\nuint256 oldTokenBal = IERC20(oldToken).balanceOf(address(this));\r\n\r\naddress[] memory path;\r\npath = new address[](2);\r\nif(oldToken != WETH) {\r\nif(tkn != WETH) {\r\npath = new address[](3);\r\npath[2] = tkn;\r\n}\r\npath[0] = oldToken;\r\npath[1] = WETH;\r\n} else {\r\npath[0] = WETH;\r\npath[1] = tkn;\r\n}\r\n\r\nIERC20(oldToken).approve(uniAddr, 2000000000000000000000000000);\r\nuni.swapExactTokensForTokens(oldTokenBal, 0, path, address(this), now+600);\r\n\r\n// set round data\r\noldToken = tkn;\r\nreturnVote = checkVotes;\r\nresetData(3);\r\n\r\n} else {\r\n\r\n// if vote is open just add vote as normal\r\n// add token to list if first vote\r\nif(tAddr[tkn] == 0) {\r\nallTkn.push(tkn);\r\n}\r\n\r\n// if user already voted\r\nif(usr[msg.sender].voted != address(0)) {\r\n// remove users old vote from token\r\ntAddr[usr[msg.sender].voted]-=1;\r\n} else {\r\n// if user has not voted then add 1 vote to total vote\r\ntotVote+=1;\r\n}\r\n\r\n// set users token voted for\r\nusr[msg.sender].voted = tkn;\r\ntAddr[tkn]+=1;\r\n}\r\n}\r\n\r\n// vote to return to lp\r\nfunction returnLP() external {\r\nrequire(voteOpen == 1, \"Vote is still open\");\r\nrequire(usr[msg.sender].votedReturn == 0, \"Already voted on return\");\r\nrequire(usr[msg.sender].stake >= minFund || usr[msg.sender].invested == 1, \"Your balance is too low\");\r\n\r\n// if user already voted\r\nif(usr[msg.sender].voted != address(0)) {\r\n// remove users old vote from token\r\nusr[msg.sender].voted = address(0);\r\ntAddr[usr[msg.sender].voted]-=1;\r\ntotVote-=1;\r\n}\r\n\r\nuint256 checkVotes = returnLPVote+1;\r\nusr[msg.sender].votedReturn = 1;\r\n\r\n// if return lp vote is hegher than previous return vote\r\nif(checkVotes > returnVote/2) {\r\n\r\nuint256 allOrcaLP = IERC20(fundTkn).balanceOf(address(this));\r\n\r\n// return liquidity here\r\nuint256 oldTknBal = IERC20(oldToken).balanceOf(address(this));\r\nIERC20(oldToken).approve(uniAddr, oldTknBal);\r\naddress[] memory path;\r\npath = new address[](2);\r\nif(oldToken != WETH) {\r\npath[0] = oldToken;\r\npath[1] = WETH;\r\nuni.swapExactTokensForTokens(oldTknBal, 0, path, address(this), now+600);\r\n}\r\n\r\nuint256 newWETHBal = IERC20(WETH).balanceOf(address(this));\r\nuint256 wethProfit;\r\nif(newWETHBal > wETHInvested) {\r\nwethProfit = newWETHBal-wETHInvested;\r\n// add profits to all time profits\r\nwETHProfits = wETHProfits+wethProfit;\r\nif(wethProfit >= 100000000000000000) {\r\n    \r\n// take tax if profit\r\nuint256 feeAmount = wethProfit*feePercent/100;\r\nfundTkn.transfer(taxFeeAddress, feeAmount);\r\nwethProfit = wethProfit-feeAmount;\r\n\r\npath[0] = WETH;\r\npath[1] = nativeOrkaAddress;\r\nuni.swapExactTokensForTokens(wethProfit/2, 0, path, address(this), now+600);\r\n}\r\n}\r\n\r\n// return liquidity\r\nIERC20(nativeOrkaAddress).approve(uniAddr, 2000000000000000000000000000);\r\nuni.addLiquidity(nativeOrkaAddress, WETH, IERC20(nativeOrkaAddress).balanceOf(address(this)), IERC20(WETH).balanceOf(address(this)), 0, 0, address(this), now+600);\r\n\r\n// buy ORCA with left over WETH\r\nuint256 newETH = IERC20(WETH).balanceOf(address(this));\r\nif(newETH >= 100000000000000000) {\r\npath = new address[](2);\r\npath[0] = WETH;\r\npath[1] = nativeOrkaAddress;\r\nuni.swapExactTokensForTokens(newETH/2, 0, path, address(this), now+600);\r\nuni.addLiquidity(nativeOrkaAddress, WETH, IERC20(nativeOrkaAddress).balanceOf(address(this)), IERC20(WETH).balanceOf(address(this)), 0, 0, address(this), now+600);\r\n}\r\n\r\nuint256 realOrca = IERC20(fundTkn).balanceOf(address(this))-allOrcaLP;\r\nuint256 i;\r\nfor(i = 0; i < usrs.length; i++){\r\nif(usr[usrs[i]].invested == 1) {\r\nusr[usrs[i]].stake = usr[usrs[i]].stakePer/10**18*realOrca/100+usr[usrs[i]].stake;\r\nusr[usrs[i]].stakePer = 0;\r\nusr[usrs[i]].invested = 0;\r\n}\r\n}\r\n\r\n// set round data\r\nvoteOpen = 0;\r\nreturnVote = 0;\r\nvoteTime = now+86400; // change to 86400\r\nwETHInvested = 0;\r\nresetData(0);\r\n\r\n} else {\r\n// if return lp vote is lower than previous return vote just add 1 to total return vote\r\nreturnLPVote+=1;\r\n}\r\n}\r\n    \r\n// remove vote\r\nfunction removeVote() external {\r\nrequire(usr[msg.sender].voted != address(0), \"You have not voted\");\r\n// remove users vote from token\r\ntAddr[usr[msg.sender].voted]-=1;\r\n// remove 1 form total votes\r\ntotVote-=1;\r\nusr[msg.sender].voted = address(0);\r\n}\r\n\r\n// close vote\r\nfunction closeVote() external {\r\nrequire(now >= voteTime, \"Vote is not closed yet\");\r\n\r\n// find highest voted token\r\nuint256 highestVoted; \r\naddress highestVotedName; \r\nuint256 i;\r\nfor(i = 0; i < allTkn.length; i++){\r\nif(tAddr[allTkn[i]] > highestVoted) {\r\nhighestVoted = tAddr[allTkn[i]];\r\nhighestVotedName = allTkn[i];\r\n} \r\n}\r\n\r\n// if found token with votes\r\nif(highestVoted > 0) {\r\n    \r\n// remove liquidity and invest into highest voted token here using highestVotedName\r\nuint256 orcaLP = IERC20(fundTkn).balanceOf(address(this));\r\n// approve tokens\r\nIERC20(fundTkn).approve(uniAddr, 20000000000000000000000);\r\nIERC20(WETH).approve(uniAddr, 10000000000000000000000000);\r\nuni.removeLiquidity(nativeOrkaAddress, WETH, orcaLP, 0, 0, address(this), now+600);\r\n\r\n// if wETH was NOT voted otherwise just keep wETH from liquidate\r\nif(highestVotedName != WETH) {\r\nuint256 wethLiq = IERC20(WETH).balanceOf(address(this));\r\nwETHInvested = wethLiq;\r\naddress[] memory path = new address[](2);\r\npath[0] = WETH;\r\npath[1] = highestVotedName;\r\nuni.swapExactTokensForTokens(wethLiq, 0, path, address(this), now+600);\r\n}\r\n\r\n// set invested users percentages\r\nfor(i = 0; i < usrs.length; i++){\r\nusr[usrs[i]].stakePer = 100*usr[usrs[i]].stake*10**18/orcaLP;\r\nusr[usrs[i]].stake = 0;\r\n}\r\n\r\n// close vote\r\nvoteOpen = 1;\r\nreturnVote = totVote;\r\noldToken = highestVotedName;\r\ninvestedTimestamp = now;\r\nresetData(1);\r\n\r\n} else {\r\n// if no tokens where voted\r\nvoteTime = now+86400;\r\n}\r\n}\r\n\r\n// reset contract data\r\nfunction resetData(uint256 resetType) private {\r\ntotVote = 0;\r\nreturnLPVote = 0;\r\n\r\nuint256 i;\r\n// set each user voted address to 0x00000\r\nfor(i = 0; i < usrs.length; i++){\r\nusr[usrs[i]].voted = address(0);\r\nusr[usrs[i]].votedReturn = 0;\r\n// set investors to invested\r\nif(resetType == 0) {\r\nusr[usrs[i]].invested = 0;\r\n} else {\r\nusr[usrs[i]].invested = 1;\r\n} \r\n}\r\n// set all token votes to 0\r\nfor(i = 0; i < allTkn.length; i++){\r\ntAddr[allTkn[i]] = 0;\r\n}\r\n\r\ndelete allTkn;\r\n}\r\n\r\n// get all tokens voted\r\nfunction getStrings() external view returns (address [] memory) {\r\nreturn allTkn;\r\n}\r\n\r\n// changes min fund amount and min eth amount\r\nfunction fundMin(uint256 amnt) external onlyOwner {\r\nminFund = amnt;\r\n}\r\n\r\n}\r\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    }
  }
}