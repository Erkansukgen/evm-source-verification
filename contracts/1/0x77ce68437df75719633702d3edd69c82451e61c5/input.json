{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/MFI_LP_AUTO_Instance.sol":{"content":"pragma solidity ^0.6.0;\n\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n// ----------------------------------------------------------------------------\n abstract   contract  ERC20Interface {\n    function  totalSupply()virtual public  view returns (uint);\n    function balanceOf(address tokenOwner) virtual public  view returns (uint balance);\n    function allowance(address tokenOwner, address spender)virtual public  view returns (uint remaining);\n    function transfer(address to, uint tokens)virtual public  returns (bool success);\n    function approve(address spender, uint tokens) virtual public  returns (bool success);\n    function transferFrom(address from, address to, uint tokens)virtual public   returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\nabstract contract PETH {\n     function GetUserInfo(address user) virtual public view returns (bool ,uint256,address,uint256,uint256,uint256,uint256);\n}\n// ----------------------------------------------------------------------------\n// Contract function to receive approval and execute function in one call\n//\n// Borrowed from MiniMeToken\n// ----------------------------------------------------------------------------\nabstract  contract  ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public ;\n}\n\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\ncontract MFI_Stacking is  Owned {\n\n    event EVENT_STACK(address indexed user, uint tokens);\n    event EVENT_RECEIVE(address indexed user, uint tokens);\n    event EVENT_UNSTACK(address indexed user, uint tokens);\n\n    struct  User{\n        bool Registered;\n        address User_Address;\n        address Referer_Address;\n        uint Stacking_Amount;\n        uint Contribution_Amount;\n        uint Accelerator_Stacking_Amount;\n        uint Token_Amount;\n        uint Stacking_Block_Number_Start;\n        uint Stacking_Operation_Block_Stamp;\n        uint256 m_LastUpdatedSumOfWeightedStackingReciprocale128;\n    }\n\n    using SafeMath for uint;\n    //addr for user updater\n    address public m_Updater_Address;\n    //addr for user relationship\n    address public m_Referer_Info_Address;\n    // addr for stacking token\n    address public m_Stacking_Address;\n    // addr for target token \n    address public m_Token_Address;\n    // addr for token which accelerates stacking\n    address public m_Liquid_Proof_Address;\n    //game's block span\n    uint public m_Stacking_Block_Number_Start;\n    uint public m_Stacking_Block_Number_Stop;\n    \n    // total amount of stacking\n    uint256 public m_Total_Stacking; \n    // total user number\n    uint256 public m_User_Count;\n    // total amount of acceleractor token\n    uint256 public m_Accelerator_Total_Stacking; \n\n    uint256 public m_2TimesThreshold=1.5e18;\n    uint256 public m_1TimesThreshold=20.0e18;\n\n    uint256 public m_WeightOfBlock;\n    uint256 public m_BlockNumOfLastUpdate=0;\n    uint256 public m_SumOfWeightedStackingReciprocale128=0;\n    uint256 public m_FIX_POINT=( 1*2**128);\n\n    uint256 public LP_Binding_Rate_Numerator=16265 ;\n    uint256 public LP_Binding_Rate_Denominator=10000;\n    // indicate whether game is paused true=pause false=play\n    bool m_Game_Pause;\n    //if user unstacking within a span of blocks take 10% receiving token for fee;  \n    uint256 m_Punishment_Span;\n    \n    \n    modifier onlyPayloadSize(uint size) {\n        require(!(msg.data.length < size + 4));\n        _;\n    }\n    modifier NotGamePause()\n    {\n        require(m_Game_Pause!=true);\n        _;\n    }\n    modifier OnlyRegistered()\n    {\n        require(m_User_Map[msg.sender].Registered==true);\n        _;\n    }\n    mapping(address => User) public  m_User_Map;\n    constructor() public {\n        m_Total_Stacking=1*10**18;\n        m_Accelerator_Total_Stacking=1;\n        m_Game_Pause=false;\n        m_User_Count=1;\n        m_Punishment_Span=40320;\n        m_BlockNumOfLastUpdate=block.number;\n        m_Stacking_Block_Number_Start=block.number;\n        m_Stacking_Block_Number_Stop=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        \n        m_WeightOfBlock=0.06185185185e18;\n        \n        m_Referer_Info_Address=0xD2A98CE01478E46E3376f90a4Fb5Db3c40212D43;\n        m_Stacking_Address=0xD2A98CE01478E46E3376f90a4Fb5Db3c40212D43;\n        m_Liquid_Proof_Address=0xe7f15F697eE71DF9E208CCf15Ff95e7aD41a067A;\n        m_Token_Address=0xEaDC218Ac4cB7895a5A56e6484646b48f841C45a;\n    }\n\n    function Set_Token_Address( address stacking,address lp,address token) public onlyOwner{\n        m_Stacking_Address=stacking;\n        m_Token_Address=token;\n        m_Liquid_Proof_Address=lp;\n       \n    }\n    function Set_Referer_Info_Address( address addr) public onlyOwner{\n        \n        m_Referer_Info_Address=addr;\n       \n    }\n\n    function Set_Updater_Address( address addr) public onlyOwner{\n        \n        m_Updater_Address=addr;\n       \n    }\n    function Set_Reward_Rate_Threshold( uint256 t2 ,uint256 t3) public onlyOwner{\n       m_2TimesThreshold=t2;\n       m_1TimesThreshold=t3;\n    }\n    function Set_Punishment_Span( uint span) public onlyOwner{\n        m_Punishment_Span=span;\n       \n    }\n    function Pause( ) public onlyOwner{\n       m_Game_Pause=true;\n       m_Stacking_Block_Number_Stop=block.number;\n    }\n    function Resume( ) public onlyOwner{\n       m_Game_Pause=false;\n       m_Stacking_Block_Number_Stop=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    }\n\n\n    function Start_At(uint block_number) public onlyOwner{\n            if(block_number==0)\n            {\n                uint number = block.number;\n                m_Stacking_Block_Number_Start=number;\n            }else\n            {\n                m_Stacking_Block_Number_Start=block_number;\n            }\n    }\n    function Stop_At(uint block_number) public onlyOwner{\n            if(block_number==0)\n            {\n                uint number = block.number;\n                 m_Stacking_Block_Number_Stop=number;\n            }else\n            {\n                 m_Stacking_Block_Number_Stop=block_number;\n            }\n    }\n    function Get_User_Info(address user ) public view returns(bool ,address, address, uint ,uint,uint)\n    {\n        return\n        (\n        m_User_Map[user]. Registered,\n        m_User_Map[user]. User_Address,\n        m_User_Map[user]. Referer_Address,\n        m_User_Map[user]. Stacking_Amount,\n        m_User_Map[user]. Contribution_Amount,\n        m_User_Map[user]. Stacking_Operation_Block_Stamp\n        );\n    }\n    function Get_Game_Info() public view returns(uint256,uint256,uint256 )\n    {\n        return(\n            m_Total_Stacking,m_User_Count,m_Punishment_Span\n        );\n    }\n    function Do_Registering() public  NotGamePause returns(bool){\n        // initialize user data\n        Update_Global_Data();\n        address Referer=GetRefererAddress(msg.sender);\n        uint256 UserLevel=GetUserGrade(msg.sender);\n        require( Referer != address(0),\"REFERER ERROR\");\n        require( m_User_Map[msg.sender].Registered==false,\"USER EXIST\");\n        require( UserLevel>=1,\"USER GRADE ERROR\");\n        m_User_Map[msg.sender].Registered=true;\n        m_User_Map[msg.sender].User_Address=msg.sender;\n        m_User_Map[msg.sender].Referer_Address=GetRefererAddress(msg.sender); \n        m_User_Map[msg.sender].Stacking_Block_Number_Start= block.number;\n        m_User_Map[msg.sender].m_LastUpdatedSumOfWeightedStackingReciprocale128=m_SumOfWeightedStackingReciprocale128;\n        //m_User_Count=m_User_Count+1;\n        return true;\n    }\n    function GetRefererAddress(address user )private returns(address)\n    {\n          (bool Register,uint256 PETH_Quota,address Referer,uint256 UserLevel,uint256 Losed,uint256 PickedUp,uint256 ExactProfit)= PETH( m_Referer_Info_Address).GetUserInfo(user);\n        return (Referer);\n    }\n    function GetUserGrade(address user )private returns(uint256)\n    {\n          (bool Register,uint256 PETH_Quota,address Referer,uint256 UserLevel,uint256 Losed,uint256 PickedUp,uint256 ExactProfit)= PETH( m_Referer_Info_Address).GetUserInfo(user);\n        return (UserLevel);\n    }\n    function Do_Stacking(uint stacking_amount) public OnlyRegistered  NotGamePause returns(bool){\n           \n            //transfer from user to contract\n            bool res=false;\n            res=ERC20Interface(m_Stacking_Address).transferFrom(msg.sender, address(this),stacking_amount);\n            if(res ==false)\n            {\n                //if failed revert transaction;\n                 revert();\n            }\n            uint256 lp_stacking_amount =stacking_amount/LP_Binding_Rate_Denominator;\n            lp_stacking_amount=lp_stacking_amount * LP_Binding_Rate_Numerator;\n\n            res=ERC20Interface(m_Liquid_Proof_Address).transferFrom(msg.sender, address(this),lp_stacking_amount);\n            if(res ==false)\n            {\n                //if failed revert transaction;\n                 revert();\n            }\n\n             uint256 old_stacking_amount=m_User_Map[msg.sender].Stacking_Amount;\n\n            // update token value in pass;\n            Update_Global_Data();\n            Update_User(msg.sender,false);\n             m_User_Map[msg.sender].Stacking_Operation_Block_Stamp=block.number;\n            // update user and contract data\n            m_Total_Stacking=m_Total_Stacking.add(stacking_amount);\n            m_User_Map[msg.sender].Stacking_Amount= m_User_Map[msg.sender].Stacking_Amount+stacking_amount;        \n\n            //------------------------------------------------------------\n            // add contribute\n            //------------------------------------------------------------\n            address referer_address=GetRefererAddress(msg.sender); \n            Update_User(referer_address,false);\n            m_User_Map[referer_address].Contribution_Amount=m_User_Map[referer_address].Contribution_Amount.add(stacking_amount/5);\n\n            //------------------------------------------------------------\n            //  add contribute\n            //------------------------------------------------------------\n            referer_address=GetRefererAddress(referer_address); \n            Update_User(referer_address,false);\n            m_User_Map[referer_address].Contribution_Amount=m_User_Map[referer_address].Contribution_Amount.add(stacking_amount/10);\n\n            //adjust user count\n            if(old_stacking_amount<15e16 && m_User_Map[msg.sender].Stacking_Amount>=15e16  )\n            {\n                m_User_Count=m_User_Count+1;\n            }\n\n            emit EVENT_STACK(msg.sender,stacking_amount);\n            return true;\n    }\n    function Do_Receiving() public  OnlyRegistered  NotGamePause returns(bool) {\n\n\n              //TODO: UPDATE\n              Update_Global_Data();\n            Update_User(msg.sender,false);\n            bool res=false;\n            \n            \n            \n            if( (block.number - m_User_Map[msg.sender].Stacking_Operation_Block_Stamp )< m_Punishment_Span)\n            {\n                res=ERC20Interface(m_Token_Address).transfer(msg.sender,m_User_Map[msg.sender].Token_Amount*9/10);\n                ERC20Interface(m_Token_Address).transfer(address(0),m_User_Map[msg.sender].Token_Amount*1/10);\n                if(res ==false)\n                {\n                     revert();\n                }\n            }else{\n\n                res=ERC20Interface(m_Token_Address).transfer(msg.sender,m_User_Map[msg.sender].Token_Amount);\n               \n                if(res ==false)\n                {\n                     revert();\n                }\n            }\n\n            //send token to user            \n            \n            \n            \n\n             emit EVENT_RECEIVE(msg.sender,m_User_Map[msg.sender].Token_Amount);\n            \n            // update user  data\n            m_User_Map[msg.sender].Token_Amount=0;\n         \n\n\n            return true;\n    }\n    //function \n    function Do_Unstacking(uint stacking_amount) public  OnlyRegistered   returns(bool)  {\n            //check balance\n            require( m_User_Map[msg.sender].Stacking_Amount>=stacking_amount);\n            \n            Update_Global_Data();\n            Update_User(msg.sender,false);\n            uint256 old_stacking_amount=m_User_Map[msg.sender].Stacking_Amount;\n\n\n            bool res=false;\n            res=ERC20Interface(m_Stacking_Address).transfer(msg.sender,stacking_amount);\n            if(res ==false)\n            {\n                 revert();\n            }\n\n            uint256 lp_stacking_amount =stacking_amount/LP_Binding_Rate_Denominator;\n            lp_stacking_amount=lp_stacking_amount * LP_Binding_Rate_Numerator;\n\n            res=ERC20Interface(m_Liquid_Proof_Address).transfer(msg.sender,lp_stacking_amount);\n            if(res ==false)\n            {\n                //if failed revert transaction;\n                 revert();\n            }\n\n            m_User_Map[msg.sender].Stacking_Amount= m_User_Map[msg.sender].Stacking_Amount.sub(stacking_amount);\n            m_Total_Stacking=m_Total_Stacking.sub(stacking_amount);\n\n            //------------------------------------------------------------\n            // delete contribute\n            //------------------------------------------------------------\n            address referer_address=GetRefererAddress(msg.sender);\n            Update_User(referer_address,false);\n            m_User_Map[referer_address].Contribution_Amount= m_User_Map[referer_address].Contribution_Amount.sub(stacking_amount/5);\n\n            //------------------------------------------------------------\n            //  delete contribute\n            //------------------------------------------------------------\n            referer_address=GetRefererAddress(referer_address); \n            Update_User(referer_address,false);\n            m_User_Map[referer_address].Contribution_Amount= m_User_Map[referer_address].Contribution_Amount.sub(stacking_amount/10);\n            \n            //adjust user count\n            if(old_stacking_amount>=15e16 && m_User_Map[msg.sender].Stacking_Amount<15e16 )\n            {\n                m_User_Count=m_User_Count-1;\n            }\n\n\n            emit EVENT_UNSTACK(msg.sender,stacking_amount);\n            return true;\n    }\n   function Do_Game_Update() public    returns(bool){\n        require(msg.sender==m_Updater_Address,\"DISQUALIFIED\");\n        Update_Global_Data();\n         //Update_User(user,false);\n        return true;\n    }\n    function Do_Update_User(address user) public    returns(bool){\n        require(msg.sender==m_Updater_Address,\"DISQUALIFIED\");\n        //Update_Global_Data();\n        require(m_User_Map[user].Registered==true);\n        Update_User(user,false);\n        return true;\n    }\n    function Update_Global_Data() private\n    {\n         uint block_num_clamp=block.number;\n        if(block_num_clamp>m_Stacking_Block_Number_Stop)\n        {\n            block_num_clamp=m_Stacking_Block_Number_Stop;\n        }\n        if(block_num_clamp<m_Stacking_Block_Number_Start)\n        {\n            block_num_clamp=m_Stacking_Block_Number_Start;\n        }\n\n        uint256 block_span=block_num_clamp-m_BlockNumOfLastUpdate;\n        if(block_span==0)\n        {\n            \n        }else{\n            uint256 delta=  m_FIX_POINT;\n            uint256 t_total_stacking=m_Total_Stacking;\n            delta=delta/t_total_stacking;\n            delta=delta*block_span*m_WeightOfBlock;\n            m_SumOfWeightedStackingReciprocale128=m_SumOfWeightedStackingReciprocale128+delta;\n        }\n        m_BlockNumOfLastUpdate=block_num_clamp;\n    }\n    function Do_Update() public  OnlyRegistered  NotGamePause returns(bool){\n        Update_Global_Data();\n        Update_User(msg.sender,false);\n        return true;\n    }\n    function Update_User(address user,bool punishment) private\n    {   \n        if(m_User_Map[user].Registered==false)\n        {\n            return;\n        }\n        uint256 block_num_clamp=block.number;\n        if(block_num_clamp>m_Stacking_Block_Number_Stop)\n        {\n            block_num_clamp=m_Stacking_Block_Number_Stop;\n        }\n            m_User_Map[user].User_Address=user;\n            //// check user's block number which should be lower than  current number and greater than 0;\n            if(m_User_Map[user].Stacking_Block_Number_Start<=m_Stacking_Block_Number_Start)\n            {\n                m_User_Map[user].Stacking_Block_Number_Start= block_num_clamp;\n            }\n            if(m_User_Map[user].Stacking_Block_Number_Start> block_num_clamp)\n            {\n                m_User_Map[user].Stacking_Block_Number_Start= block_num_clamp;\n            }\n            if(m_User_Map[user].Stacking_Block_Number_Start>= m_Stacking_Block_Number_Stop )\n            {\n                m_User_Map[user].Stacking_Block_Number_Start=m_Stacking_Block_Number_Stop;\n            }\n////Get how many blocks between last operation and current block///\n        \n        //uint block_span=block_num_clamp - m_User_Map[user].Stacking_Block_Number_Start;\n        \n////BASE///////////////////////////////////////////////////////////////\n        uint fixed_point=(2**12);\n        uint quantity=m_SumOfWeightedStackingReciprocale128.sub( m_User_Map[user].m_LastUpdatedSumOfWeightedStackingReciprocale128);\n        quantity=quantity/fixed_point;\n        quantity=( m_User_Map[user].Stacking_Amount+m_User_Map[user].Contribution_Amount)*quantity;\n        quantity =quantity/( m_FIX_POINT);\n        quantity =quantity*fixed_point;\n        //////////////////////////////////////\n\n        quantity =quantity*10;\n        quantity =quantity/13;\n        /////////////////////////////////////\n       uint prize_rate= GetAccelerationRate(user);\n       quantity=quantity*prize_rate;\n       quantity=quantity/3;\n ////Punishment/////////////////////////////////////////////////////////////////////////       \n        if(punishment)\n        {\n            uint256 burn_quantity=quantity/10;\n            //TODO：burn \n             bool res=false;\n            //\n            res=ERC20Interface(m_Token_Address).transfer(address(0),burn_quantity);\n            quantity=TakeFee10(quantity);\n        }    \n        \n////Update Token Data////////////////////////////////////////////////////////////\n        m_User_Map[user].Token_Amount= m_User_Map[user].Token_Amount.add(quantity);\n        \n\n ////Update Block Number////////////////////////////////////////////////////////////       \n        m_User_Map[user].Stacking_Block_Number_Start= block_num_clamp;\n     ////Update LastUpdatedSumOfWeightedStackingReciprocale128////////////////////////////////////////////////////////////       \n        m_User_Map[user].m_LastUpdatedSumOfWeightedStackingReciprocale128= m_SumOfWeightedStackingReciprocale128;\n    \n    \n    }\n    function GetAccelerationRate(address user) private  view returns (uint )  \n    {\n       //uint t_s=m_Total_Stacking;\n       //uint a_s=t_s/m_User_Count;\n       //uint a_s_range_left=a_s*1160/1000;\n       //uint a_s_range_right=a_s*2000/1000;\n       if(m_User_Map[user].Stacking_Amount<m_2TimesThreshold)\n       {\n           return 2;\n       }\n       if(m_User_Map[user].Stacking_Amount>m_1TimesThreshold)\n       {\n           return 1;\n       }\n        return 3;\n    }\n\n\n    function Take_Token(address token_address,uint token_amount) public onlyOwner{\n           ERC20Interface(token_address).transfer(msg.sender,token_amount);\n    }\n    \n    function TakeFee10(uint token_amount) private pure returns (uint) {\n            uint res=token_amount;\n            res=res*9;\n            res=res/10;\n            return res;\n    }\n    function ViewReceiving(address user) public view  returns (uint) {\n       ////Get how many blocks between last operation and current block///\n        uint block_num_clamp=block.number;\n        if(block_num_clamp>m_Stacking_Block_Number_Stop)\n        {\n            block_num_clamp=m_Stacking_Block_Number_Stop;\n        }\n        if(block_num_clamp<m_Stacking_Block_Number_Start)\n        {\n            block_num_clamp=m_Stacking_Block_Number_Start;\n        }\n\n        uint256 block_span=block_num_clamp-m_BlockNumOfLastUpdate;\n        uint256 t_SumOfWeightedStackingReciprocale128=m_SumOfWeightedStackingReciprocale128;\n        if(block_span==0)\n        {\n            //m_TotalStackingOfLastUpdate=stacking_amount+m_TotalStackingOfLastUpdate;\n        }else{\n            uint256 delta=  m_FIX_POINT;\n            uint256 t_total_stacking=m_Total_Stacking;\n            delta=delta/t_total_stacking;\n            delta=delta*block_span*m_WeightOfBlock;\n            t_SumOfWeightedStackingReciprocale128=m_SumOfWeightedStackingReciprocale128+delta;\n        }\n////BASE///////////////////////////////////////////////////////////////\n       uint fixed_point=(2**12);\n        uint quantity=t_SumOfWeightedStackingReciprocale128.sub( m_User_Map[user].m_LastUpdatedSumOfWeightedStackingReciprocale128);\n        quantity=quantity/fixed_point;\n        quantity=( m_User_Map[user].Stacking_Amount+m_User_Map[user].Contribution_Amount)*quantity;\n        quantity =quantity/( m_FIX_POINT);\n        quantity =quantity*fixed_point;\n        //////////////////////////////////////\n\n        quantity =quantity*10;\n        quantity =quantity/13;\n        /////////////////////////////////////\n       uint prize_rate= GetAccelerationRate(user);\n       quantity=quantity*prize_rate;\n       quantity=quantity/3;\n\n        \n\n /////////////////////////////////////////////////////////////////////////////   \n\n\n        uint res=quantity+m_User_Map[user].Token_Amount;\n        return res;\n    }\n\n\n\n    function Set_Block_Weight(uint256 block_weight)public onlyOwner\n    {\n        m_WeightOfBlock=block_weight;\n    }\n\n}\n"}}}