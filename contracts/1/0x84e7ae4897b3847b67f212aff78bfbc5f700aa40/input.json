{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/VirtualBitcoin.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./VirtualBitcoinInterface.sol\";\n\ncontract VirtualBitcoin is VirtualBitcoinInterface {\n\n    string  constant public NAME = \"Virtual Bitcoin\";\n    string  constant public SYMBOL = \"VBTC\";\n    uint256 constant public COIN = 10 ** uint256(DECIMALS);\n    uint8   constant public DECIMALS = 8;\n    uint32  constant public SUBSIDY_HALVING_INTERVAL = 210000 * 20;\n    uint256 constant public MAX_COIN = 21000000 * COIN;\n    uint256 constant public PIZZA_POWER_PRICE = 10000 * COIN;\n    uint256 constant public PRECISION = 1e4;\n\n    uint256 immutable public genesisEthBlock;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private balances;\n    mapping(address => mapping(address => uint256)) private allowed;\n\n    struct Pizza {\n        address owner;\n        uint256 power;\n        uint256 accSubsidy;\n    }\n    Pizza[] public pizzas;\n\n    uint256 public accSubsidyBlock;\n    uint256 public accSubsidy;\n    uint256 public totalPower;\n\n    constructor() {\n        genesisEthBlock = block.number;\n\n        accSubsidy = 0;\n        accSubsidyBlock = block.number;\n\n        pizzas.push(Pizza({\n            owner: msg.sender,\n            power: 1,\n            accSubsidy: 0\n        }));\n\n        totalPower = 1;\n    }\n\n    function name() external pure override returns (string memory) { return NAME; }\n    function symbol() external pure override returns (string memory) { return SYMBOL; }\n    function decimals() external pure override returns (uint8) { return DECIMALS; }\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n\n    function balanceOf(address user) external view override returns (uint256 balance) {\n        return balances[user];\n    }\n\n    function transfer(address to, uint256 amount) public override returns (bool success) {\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool success) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address user, address spender) external view override returns (uint256 remaining) {\n        return allowed[user][spender];\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external override returns (bool success) {\n        uint256 _allowance = allowed[from][msg.sender];\n        if (_allowance != type(uint256).max) {\n            allowed[from][msg.sender] = _allowance - amount;\n        }\n        balances[from] -= amount;\n        balances[to] += amount;\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function mint(address to, uint256 amount) internal {\n        balances[to] += amount;\n        _totalSupply += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    function collect(address to, uint256 amount) internal {\n        balances[address(this)] -= amount;\n        balances[to] += amount;\n        emit Transfer(address(this), to, amount);\n    }\n\n    function pizzaPrice(uint256 power) external pure override returns (uint256) {\n        return power * PIZZA_POWER_PRICE;\n    }\n\n    function pizzaCount() external view override returns (uint256) {\n        return pizzas.length;\n    }\n\n    function subsidyAt(uint256 blockNumber) public view override returns (uint256 amount) {\n        uint256 era = (blockNumber - genesisEthBlock) / SUBSIDY_HALVING_INTERVAL;\n        amount = 25 * COIN / 10 / (2 ** era);\n    }\n\n    function calculateAccSubsidy() internal view returns (uint256) {\n        uint256 _accSubsidyBlock = accSubsidyBlock;\n        uint256 subsidy = 0;\n        uint256 era1 = (_accSubsidyBlock - genesisEthBlock) / SUBSIDY_HALVING_INTERVAL;\n        uint256 era2 = (block.number - genesisEthBlock) / SUBSIDY_HALVING_INTERVAL;\n\n        if (era1 == era2) {\n            subsidy = (block.number - _accSubsidyBlock) * subsidyAt(block.number);\n        } else {\n            uint256 boundary = (era1 + 1) * SUBSIDY_HALVING_INTERVAL + genesisEthBlock;\n            subsidy = (boundary - _accSubsidyBlock) * subsidyAt(_accSubsidyBlock);\n            uint256 span = era2 - era1;\n            for (uint256 i = 1; i < span; i += 1) {\n                boundary = (era1 + 1 + i) * SUBSIDY_HALVING_INTERVAL + genesisEthBlock;\n                subsidy += SUBSIDY_HALVING_INTERVAL * subsidyAt(_accSubsidyBlock + SUBSIDY_HALVING_INTERVAL * i);\n            }\n            subsidy += (block.number - boundary) * subsidyAt(block.number);\n        }\n\n        return accSubsidy + subsidy * PRECISION / totalPower;\n    }\n\n    function makePizza(uint256 power) internal returns (uint256) {\n        require(power > 0);\n\n        uint256 pizzaId = pizzas.length;\n        uint256 _accSubsidy = update();\n\n        pizzas.push(Pizza({\n            owner: msg.sender,\n            power: power,\n            accSubsidy: _accSubsidy * power / PRECISION\n        }));\n\n        totalPower += power;\n        return pizzaId;\n    }\n\n    function buyPizza(uint256 power) external override returns (uint256) {\n        transfer(address(this), power * PIZZA_POWER_PRICE);\n        uint256 pizzaId = makePizza(power);\n        emit BuyPizza(msg.sender, pizzaId, power);\n        return pizzaId;\n    }\n\n    function changePizza(uint256 pizzaId, uint256 power) external override {\n        Pizza storage pizza = pizzas[pizzaId];\n        require(pizzaId != 0);\n        require(pizza.owner == msg.sender);\n\n        uint256 currentPower = pizza.power;\n        require(currentPower != power);\n\n        uint256 _accSubsidy = update();\n        uint256 subsidy = _accSubsidy * currentPower / PRECISION - pizza.accSubsidy;\n        if (subsidy > 0) {\n            mint(msg.sender, subsidy);\n        }\n        emit Mine(msg.sender, pizzaId, subsidy);\n\n        if (currentPower < power) { // upgrade\n            uint256 diff = power - currentPower;\n            transfer(address(this), diff * PIZZA_POWER_PRICE);\n            totalPower += diff;\n        } else { // downgrade\n            uint256 diff = currentPower - power;\n            collect(msg.sender, diff * PIZZA_POWER_PRICE);\n            totalPower -= diff;\n        }\n\n        pizza.accSubsidy = _accSubsidy * power / PRECISION;\n        pizza.power = power;\n\n        emit ChangePizza(msg.sender, pizzaId, power);\n    }\n\n    function sellPizza(uint256 pizzaId) external override {\n        Pizza storage pizza = pizzas[pizzaId];\n        require(pizzaId != 0);\n        require(pizza.owner == msg.sender);\n\n        uint256 power = pizza.power;\n        mine(pizzaId);\n        pizza.owner = address(0);\n        totalPower -= power;\n\n        collect(msg.sender, power * PIZZA_POWER_PRICE);\n        emit SellPizza(msg.sender, pizzaId);\n    }\n\n    function powerOf(uint256 pizzaId) external view override returns (uint256) {\n        return pizzas[pizzaId].power;\n    }\n\n    function subsidyOf(uint256 pizzaId) external view override returns (uint256) {\n        Pizza memory pizza = pizzas[pizzaId];\n        if (pizza.owner == address(0)) {\n            return 0;\n        }\n        return calculateAccSubsidy() * pizza.power / PRECISION - pizza.accSubsidy;\n    }\n\n    function mine(uint256 pizzaId) public override returns (uint256) {\n        Pizza storage pizza = pizzas[pizzaId];\n        require(pizza.owner == msg.sender);\n        uint256 power = pizza.power;\n\n        uint256 _accSubsidy = update();\n        uint256 subsidy = _accSubsidy * power / PRECISION - pizza.accSubsidy;\n        if (subsidy > 0) {\n            mint(msg.sender, subsidy);\n        }\n\n        pizza.accSubsidy = _accSubsidy * power / PRECISION;\n        emit Mine(msg.sender, pizzaId, subsidy);\n        return subsidy;\n    }\n\n    function update() internal returns (uint256 _accSubsidy) {\n        if (accSubsidyBlock != block.number) {\n            _accSubsidy = calculateAccSubsidy();\n            accSubsidy = _accSubsidy;\n            accSubsidyBlock = block.number;\n        } else {\n            _accSubsidy = accSubsidy;\n        }\n    }\n}"},"contracts/VirtualBitcoinInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface VirtualBitcoinInterface {\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event BuyPizza(address indexed owner, uint256 indexed pizzaId, uint256 power);\n    event ChangePizza(address indexed owner, uint256 indexed pizzaId, uint256 power);\n    event SellPizza(address indexed owner, uint256 indexed pizzaId);\n    event Mine(address indexed owner, uint256 indexed pizzaId, uint256 subsidy);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function transfer(address to, uint256 amount) external returns (bool success);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool success);\n    function approve(address spender, uint256 amount) external returns (bool success);\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    function pizzaPrice(uint256 power) external view returns (uint256);\n    function pizzaCount() external view returns (uint256);\n    function subsidyAt(uint256 blockNumber) external view returns (uint256);\n    function buyPizza(uint256 power) external returns (uint256);\n    function sellPizza(uint256 pizzaId) external;\n    function changePizza(uint256 pizzaId, uint256 power) external;\n    function powerOf(uint256 pizzaId) external view returns (uint256);\n    function subsidyOf(uint256 pizzaId) external view returns (uint256);\n    function mine(uint256 pizzaId) external returns (uint256);\n}"}}}