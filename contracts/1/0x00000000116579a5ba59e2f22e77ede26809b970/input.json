{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/flash_tri.sol": {
      "content": "pragma solidity <0.8.6;\r\ninterface IUniswapV3Pool {\r\n    function swap(address recipient,bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96,bytes calldata data) external returns (int256 amount0, int256 amount1);\r\n    function token0() external view returns(address);\r\n    function token1() external view returns(address);\r\n    function fee() external view returns(uint24);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ncontract Flash{\r\n    address private owner = 0x488156ed63555e06fc8a168b3b3618CFb79Cf61D;\r\n    IWETH private constant TOKEN_WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n    function buyAndFree22457070633(uint256 _amount) external{\r\n        require(msg.sender == 0xf95E0918A6E1b285E54F28bF42482BAfC2F292a1||msg.sender == 0x488156ed63555e06fc8a168b3b3618CFb79Cf61D,\"fs\");\r\n\r\n        assembly{\r\n            let cAddr := address()\r\n\r\n            //数据处理\r\n            let startTag := and(_amount,0xf)\r\n            let startAddr := div(_amount,0x10)\r\n\r\n            //块检查\r\n            if lt(div(startAddr,0x10000000000000000000000000000000000000000),number()) {revert(0x0, 0x0) }\r\n\r\n            let ptr := mload(0x40)\r\n            let funcPtr := add(ptr,0x1c)\r\n            switch startTag\r\n            case 0{//V3启动\r\n                //函数\r\n                mstore(ptr,0x128acb08)\r\n\r\n                //_recipient\r\n                let swapData := calldataload(0x24)\r\n                let zeroforone := and(swapData,0xf)\r\n                let V3Start := and(swapData,0xf0)\r\n                let amount := calldataload(0x44)\r\n\r\n                switch V3Start\r\n                case 0{\r\n                    //addr\r\n                    let addr := and(div(swapData,0x100),0xffffffffffffffffffffffffffffffffffffffff)\r\n                    mstore(add(ptr,0x20),addr)\r\n                }\r\n                default{\r\n                    //addr\r\n                    mstore(add(ptr,0x20),cAddr)\r\n                }\r\n               \r\n                //zero for one\r\n                mstore(add(ptr,0x40),zeroforone)\r\n\r\n                //startamount\r\n                mstore(add(ptr,0x60),amount)\r\n                \r\n                //tick\r\n                switch zeroforone\r\n                case 0{\r\n                    mstore(add(ptr,0x80),1461446703485210103287273052203988822378723970341)\r\n                }\r\n                default{\r\n                    mstore(add(ptr,0x80),4295128740)\r\n                }\r\n\r\n                //call 信息\r\n                mstore(add(ptr,0xa0),0xa0)\r\n                mstore(add(ptr,0xc0),0x20)\r\n                mstore(add(ptr,0xe0),swapData)\r\n                                           \r\n                startAddr := and(startAddr, 0xffffffffffffffffffffffffffffffffffffffff)                           \r\n                let result := call(gas(),startAddr,0,funcPtr,0xe4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n            }\r\n            case 1{\r\n                //转钱给V2\r\n                let nextAddr := calldataload(0x24)\r\n                let amount := div(nextAddr,0x10000000000000000000000000000000000000000)\r\n                nextAddr := and(nextAddr,0xffffffffffffffffffffffffffffffffffffffff)\r\n                \r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),startAddr)\r\n                mstore(add(ptr,0x40),amount)\r\n                let result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0, funcPtr, 0x44, ptr, 0x0)\r\n\r\n                //第一次交换\r\n                let amountData := calldataload(0x44)\r\n                mstore(ptr,0x022c0d9f)\r\n                amount := and(amountData,0xffffffffffffffffffffffffffffffff)\r\n                let amount0 := div(mul(amount,eq(and(amount,0xf),0x0)),0x10)\r\n                let amount1 := div(mul(amount,eq(and(amount,0xf),0x1)),0x10)\r\n                mstore(add(ptr,0x20),amount0)\r\n                mstore(add(ptr,0x40),amount1)\r\n                mstore(add(ptr,0x60),nextAddr)\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(),startAddr, 0,funcPtr,0xa4, ptr, 0x0) \r\n\r\n                //第二次交换\r\n                amount := div(amountData,0x100000000000000000000000000000000)\r\n                amount0 := div(mul(amount,eq(and(amount,0xf),0x0)),0x10)\r\n                amount1 := div(mul(amount,eq(and(amount,0xf),0x1)),0x10)\r\n                mstore(add(ptr,0x20),amount0)\r\n                mstore(add(ptr,0x40),amount1)\r\n                mstore(add(ptr,0x60),cAddr)\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(),nextAddr, 0,funcPtr,0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}  \r\n            }  \r\n            case 2{ //纯V2 多角套利\r\n                //启动数据获取\r\n                let amount := calldataload(0x24)\r\n                let amountETH := div(amount,0x100000000000000000000000000000000)\r\n                amount := and(amount,0xffffffffffffffffffffffffffffffff)\r\n                startAddr := and(startAddr, 0xffffffffffffffffffffffffffffffffffffffff)   \r\n\r\n                //转钱给V2\r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),startAddr)\r\n                mstore(add(ptr,0x40),amountETH)\r\n                let result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0, funcPtr, 0x44, ptr, 0x0)\r\n\r\n                //第一次交换\r\n                mstore(ptr,0x022c0d9f)\r\n                let nextAddr := and(calldataload(0x44),0xffffffffffffffffffffffffffffffffffffffff)\r\n                mstore(add(ptr,0x20),div(mul(amount,eq(and(amount,0xf),0x0)),0x10))\r\n                mstore(add(ptr,0x40),div(mul(amount,eq(and(amount,0xf),0x1)),0x10))\r\n                mstore(add(ptr,0x60),nextAddr)\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(),startAddr, 0,funcPtr,0xa4, ptr, 0x0)\r\n\r\n                let dataSize := calldatasize()\r\n                \r\n                for { let i := 0x44 } lt(i, dataSize) { i := add(i, 0x20) } {\r\n                    startAddr := nextAddr\r\n                    amount := div(calldataload(i),0x10000000000000000000000000000000000000000)\r\n\r\n                    switch eq(i,sub(dataSize,0x20))\r\n                    case 0{\r\n                        nextAddr := and(calldataload(add(i,0x20)),0xffffffffffffffffffffffffffffffffffffffff)\r\n                    }\r\n                    default{\r\n                        nextAddr := cAddr\r\n                    }\r\n\r\n                    mstore(add(ptr,0x20),div(mul(amount,eq(and(amount,0xf),0x0)),0x10))\r\n                    mstore(add(ptr,0x40),div(mul(amount,eq(and(amount,0xf),0x1)),0x10))\r\n                    mstore(add(ptr,0x60),nextAddr)\r\n                    mstore(add(ptr,0x80),0x80)\r\n                    mstore(add(ptr,0xa0),0x0)\r\n                    result := call(gas(),startAddr, 0,funcPtr,0xa4, ptr, 0x0)                    \r\n                }\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n            }\r\n            default{//V3启动 多角套利\r\n                let amount := calldataload(0x24)\r\n                let addr := calldataload(0x44)\r\n                let zeroforone := and(amount,0xf)\r\n                amount := div(amount,0x10)\r\n\r\n                //函数\r\n                mstore(ptr,0x128acb08)\r\n                \r\n                switch addr\r\n                case 0{\r\n                    mstore(add(ptr,0x20),cAddr)\r\n                }\r\n                default{\r\n                    mstore(add(ptr,0x20),addr)\r\n                }\r\n\r\n                //zero for one\r\n                mstore(add(ptr,0x40),zeroforone)\r\n\r\n                //startamount\r\n                mstore(add(ptr,0x60),amount)\r\n                \r\n                //tick\r\n                switch zeroforone\r\n                case 0{\r\n                    mstore(add(ptr,0x80),1461446703485210103287273052203988822378723970341)\r\n                }\r\n                default{\r\n                    mstore(add(ptr,0x80),4295128740)\r\n                }\r\n\r\n                //call 信息\r\n                let nextcallSize := sub(calldatasize(),0x64)\r\n                mstore(add(ptr,0xa0),0xa0)\r\n                mstore(add(ptr,0xc0),nextcallSize)\r\n                calldatacopy(add(ptr,0xe0), 0x64, nextcallSize)\r\n\r\n                startAddr := and(startAddr, 0xffffffffffffffffffffffffffffffffffffffff)  \r\n                let result := call(gas(),startAddr,0,funcPtr,add(0xc4,nextcallSize), ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n                                           \r\n            }\r\n        }\r\n    }\r\n\r\n    function uniswapV3SwapCallback(int256 amount0Delta,int256 amount1Delta,bytes calldata data) external{\r\n        IUniswapV3Pool pool = IUniswapV3Pool(msg.sender);\r\n        address token0 = pool.token0();\r\n        address token1 = pool.token1();\r\n        uint24 fee = pool.fee();\r\n        bytes32 V3_POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\r\n        //安全检查\r\n        address poolAddr = address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hex'ff',\r\n                        0x1F98431c8aD98523631AE4a59f267346ea31F984,\r\n                        keccak256(abi.encode(token0, token1, fee)),\r\n                        V3_POOL_INIT_CODE_HASH\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        require(poolAddr == msg.sender,\"faddr\");\r\n\r\n        (uint256 amountIn,uint256 amountOut) = amount0Delta<0 ?(uint256(amount1Delta),uint256(-amount0Delta)):(uint256(amount0Delta),uint256(-amount1Delta));\r\n\r\n        assembly{\r\n            //数据准备\r\n            let addr := calldataload(0x84)\r\n            let zeroforone := and(addr,0xf)\r\n            let tag := and(addr,0xf0)\r\n            addr := div(addr,0x100)\r\n            let profit := div(addr,0x10000000000000000000000000000000000000000)\r\n            let amountTag := and(profit,0xf)\r\n            profit := div(profit,0x10)\r\n            \r\n            let ptr := mload(0x40)\r\n            let funcPtr := add(ptr,0x1c)\r\n            addr := and(addr,0xffffffffffffffffffffffffffffffffffffffff)\r\n            switch tag\r\n            case 0x0{ //V3start \r\n                let amountETH := add(amountIn,profit)\r\n\r\n                //从V2获得WETH\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),mul(amountETH,eq(amountTag,0x0)))\r\n                mstore(add(ptr,0x40),mul(amountETH,eq(amountTag,0x1)))\r\n                mstore(add(ptr,0x60),address())\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                let result := call(gas(), addr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n\r\n                //还款\r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x40),amountIn)\r\n                result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0,funcPtr  , 0x44, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n            }\r\n            case 0x10{ //V2start\r\n                //检查\r\n                let amountETH := sub(amountOut,profit)\r\n\r\n                //转钱给V2\r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),addr)\r\n                mstore(add(ptr,0x40),amountETH)\r\n                let result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0, funcPtr, 0x44, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n\r\n                //还款\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),mul(amountIn,eq(amountTag,0x0)))\r\n                mstore(add(ptr,0x40),mul(amountIn,eq(amountTag,0x1)))\r\n                mstore(add(ptr,0x60),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(), addr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n            }\r\n            \r\n            //只还钱 data = 0\r\n            case 0x20{       \r\n                if lt(profit,amountIn){ revert(ptr, 0x0)}\r\n\r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x40),amountIn)\r\n                let result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0,funcPtr , 0x44, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n                // WETH.transfer(poolAddr, amount0Delta);\r\n            }\r\n\r\n            //倒序V3套利  纯v3 call   \r\n            case 0x30{\r\n                //profit检查\r\n                if lt(amountOut,profit){ revert(ptr, 0x0)}\r\n\r\n                //V3 给 V3 还钱\r\n                mstore(ptr,0x128acb08)\r\n                mstore(add(ptr,0x20),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n\r\n                mstore(add(ptr,0x40),zeroforone)\r\n\r\n                mstore(add(ptr,0x60),add(not(amountIn),1))\r\n\r\n                switch zeroforone\r\n                case 0{\r\n                    mstore(add(ptr,0x80),1461446703485210103287273052203988822378723970341)\r\n                }\r\n                default{\r\n                    mstore(add(ptr,0x80),4295128740)\r\n                }\r\n\r\n                let nextcallSize := sub(calldatasize(),0xa4)\r\n                mstore(add(ptr,0xa0),0xa0)\r\n                mstore(add(ptr,0xc0),nextcallSize)\r\n                calldatacopy(add(ptr,0xe0), 0xa4, nextcallSize)\r\n                \r\n                let result := call(gas(),addr,0,funcPtr,add(0xc4,nextcallSize), ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n\r\n            }\r\n\r\n\r\n            //倒序V3套利 V2终点\r\n            case 0x40{\r\n                \r\n                let nextAddr := calldataload(0xa4)\r\n                nextAddr := and(nextAddr,0xffffffffffffffffffffffffffffffffffffffff)\r\n\r\n                //找V2 拿eth\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),mul(profit,eq(amountTag,0x0)))\r\n                mstore(add(ptr,0x40),mul(profit,eq(amountTag,0x1)))\r\n                mstore(add(ptr,0x60),address())\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                let result := call(gas(), addr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n\r\n                //中间V3的钱用第一个V3给\r\n                mstore(ptr,0x128acb08)\r\n                mstore(add(ptr,0x20),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n\r\n                mstore(add(ptr,0x40),zeroforone)\r\n\r\n                mstore(add(ptr,0x60),add(not(amountIn),1))\r\n\r\n                switch zeroforone\r\n                case 0{\r\n                    mstore(add(ptr,0x80),1461446703485210103287273052203988822378723970341)\r\n                }\r\n                default{\r\n                    mstore(add(ptr,0x80),4295128740)\r\n                }\r\n\r\n                let nextcallSize := sub(calldatasize(),0xc4)\r\n                mstore(add(ptr,0xa0),0xa0)\r\n                mstore(add(ptr,0xc0),nextcallSize)\r\n                calldatacopy(add(ptr,0xe0), 0xc4, nextcallSize)\r\n                \r\n                addr := calldataload(0xa4)\r\n                result := call(gas(),nextAddr,0,funcPtr,add(0xc4,nextcallSize), ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n            }\r\n\r\n            //倒序V3套利 V2中介\r\n            case 0x50{                    \r\n                let nextAddr := calldataload(0xa4)\r\n                nextAddr := and(nextAddr,0xffffffffffffffffffffffffffffffffffffffff)\r\n\r\n                //用第一个V3来给V2钱\r\n                mstore(ptr,0x128acb08)\r\n                mstore(add(ptr,0x20),nextAddr)\r\n\r\n                mstore(add(ptr,0x40),zeroforone)\r\n\r\n                mstore(add(ptr,0x60),sub(amountOut,profit))\r\n\r\n                switch zeroforone\r\n                case 0{\r\n                    mstore(add(ptr,0x80),1461446703485210103287273052203988822378723970341)\r\n                }\r\n                default{\r\n                    mstore(add(ptr,0x80),4295128740)\r\n                }\r\n\r\n                let nextcallSize := sub(calldatasize(),0xc4)\r\n                mstore(add(ptr,0xa0),0xa0)\r\n                mstore(add(ptr,0xc0),nextcallSize)\r\n                calldatacopy(add(ptr,0xe0), 0xc4, nextcallSize)\r\n                \r\n                let result := call(gas(),addr,0,funcPtr,add(0xc4,nextcallSize), ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n\r\n                //用中间V2 给最后一个V3还钱\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),mul(amountIn,eq(amountTag,0x0)))\r\n                mstore(add(ptr,0x40),mul(amountIn,eq(amountTag,0x1)))\r\n                mstore(add(ptr,0x60),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(), nextAddr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n            }\r\n\r\n            //倒序V3套利 V2起点\r\n            case 0x60{\r\n                //转钱给V2\r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),addr)\r\n                mstore(add(ptr,0x40),profit)\r\n                let result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0, funcPtr, 0x44, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)} \r\n\r\n                //还款\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),mul(amountIn,eq(amountTag,0x0)))\r\n                mstore(add(ptr,0x40),mul(amountIn,eq(amountTag,0x1)))\r\n                mstore(add(ptr,0x60),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(), addr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}     \r\n            }\r\n\r\n            //双V2套利 V3起点\r\n            case 0x70{\r\n                //获得token直接给第二个V2\r\n                let nextAddr := calldataload(0xa4)\r\n\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),div(calldataload(0xc4),0x100000000000000000000000000000000))\r\n                mstore(add(ptr,0x40),and(calldataload(0xc4),0xffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x60),nextAddr)\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                let result := call(gas(), addr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n\r\n                //获得WETH直接给自己\r\n                mstore(add(ptr,0x20),mul(add(amountIn,profit),eq(amountTag,0x0)))\r\n                mstore(add(ptr,0x40),mul(add(amountIn,profit),eq(amountTag,0x1)))\r\n                mstore(add(ptr,0x60),address())\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(), nextAddr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n\r\n                //还钱\r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x40),amountIn)\r\n                result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0, funcPtr, 0x44, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n            }\r\n\r\n            //双V2套利 V3中介\r\n            case 0x80{\r\n                //获得WETH直接给自己\r\n                let nextAddr := calldataload(0xa4)\r\n\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),div(calldataload(0xc4),0x100000000000000000000000000000000))\r\n                mstore(add(ptr,0x40),and(calldataload(0xc4),0xffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x60),address())\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                let result := call(gas(), addr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n\r\n                //给第一个V2 WETH\r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),nextAddr)\r\n                mstore(add(ptr,0x40),profit)\r\n                result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0, funcPtr, 0x44, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n\r\n\r\n                //第一个V2还钱\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),mul(amountIn,eq(amountTag,0x0)))\r\n                mstore(add(ptr,0x40),mul(amountIn,eq(amountTag,0x1)))\r\n                mstore(add(ptr,0x60),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(), nextAddr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n            }\r\n\r\n            //双V2套利 V3结束\r\n            default{\r\n                let nextAddr := calldataload(0xa4)\r\n\r\n                //给第一个V2\r\n                mstore(ptr,0xa9059cbb)\r\n                mstore(add(ptr,0x20),addr)\r\n                mstore(add(ptr,0x40),sub(amountOut,profit))\r\n                let result := call(gas(), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0, funcPtr, 0x44, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n\r\n                //获得token直接给V2\r\n                mstore(ptr,0x022c0d9f)\r\n                mstore(add(ptr,0x20),div(calldataload(0xc4),0x100000000000000000000000000000000))\r\n                mstore(add(ptr,0x40),and(calldataload(0xc4),0xffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x60),nextAddr)\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(), addr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n\r\n\r\n                //第二个V2还钱\r\n                mstore(add(ptr,0x20),mul(amountIn,eq(amountTag,0x0)))\r\n                mstore(add(ptr,0x40),mul(amountIn,eq(amountTag,0x1)))\r\n                mstore(add(ptr,0x60),and(poolAddr,0xffffffffffffffffffffffffffffffffffffffff))\r\n                mstore(add(ptr,0x80),0x80)\r\n                mstore(add(ptr,0xa0),0x0)\r\n                result := call(gas(), nextAddr, 0, funcPtr, 0xa4, ptr, 0x0)\r\n                if eq(result,0) { revert(ptr, 0x0)}\r\n            } \r\n\r\n\r\n        }\r\n    }\r\n\r\n    function withDrawToken(uint _num,address _token) external {\r\n        require(msg.sender == owner,\"nope\");\r\n        IERC20(_token).transfer(owner,_num);\r\n    }\r\n\r\n    function withDrawETH(uint _num) external {\r\n        require(msg.sender == owner,\"nope\");\r\n        msg.sender.transfer(_num);\r\n    }\r\n\r\n    function withDrawWETH(uint _num) external {\r\n        require(msg.sender == owner,\"nope\");\r\n        TOKEN_WETH.withdraw(_num);\r\n        msg.sender.transfer(_num);\r\n    }\r\n\r\n    fallback() external payable {}\r\n}\r\n"
    }
  }
}