{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":3},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"MassDepositFlat.sol":{"content":"// Sources flattened with hardhat v2.6.8 https://hardhat.org\r\n\r\n// File contracts/interfaces/IBentoBoxMinimal.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Minimal BentoBox vault interface.\r\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\r\ninterface IBentoBoxMinimal {\r\n    /// @notice Balance per ERC-20 token per account in shares.\r\n    function balanceOf(address, address) external view returns (uint256);\r\n\r\n    /// @dev Helper function to represent an `amount` of `token` in shares.\r\n    /// @param token The ERC-20 token.\r\n    /// @param amount The `token` amount.\r\n    /// @param roundUp If the result `share` should be rounded up.\r\n    /// @return share The token amount represented in shares.\r\n    function toShare(\r\n        address token,\r\n        uint256 amount,\r\n        bool roundUp\r\n    ) external view returns (uint256 share);\r\n\r\n    /// @dev Helper function to represent shares back into the `token` amount.\r\n    /// @param token The ERC-20 token.\r\n    /// @param share The amount of shares.\r\n    /// @param roundUp If the result should be rounded up.\r\n    /// @return amount The share amount back into native representation.\r\n    function toAmount(\r\n        address token,\r\n        uint256 share,\r\n        bool roundUp\r\n    ) external view returns (uint256 amount);\r\n\r\n    /// @notice Registers this contract so that users can approve it for BentoBox.\r\n    function registerProtocol() external;\r\n\r\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\r\n    /// @param token_ The ERC-20 token to deposit.\r\n    /// @param from which account to pull the tokens.\r\n    /// @param to which account to push the tokens.\r\n    /// @param amount Token amount in native representation to deposit.\r\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\r\n    /// @return amountOut The amount deposited.\r\n    /// @return shareOut The deposited amount represented in shares.\r\n    function deposit(\r\n        address token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    /// @notice Withdraws an amount of `token` from a user account.\r\n    /// @param token_ The ERC-20 token to withdraw.\r\n    /// @param from which user to pull the tokens.\r\n    /// @param to which user to push the tokens.\r\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\r\n    /// @param share Like above, but `share` takes precedence over `amount`.\r\n    function withdraw(\r\n        address token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    /// @notice Transfer shares from a user account to another one.\r\n    /// @param token The ERC-20 token to transfer.\r\n    /// @param from which user to pull the tokens.\r\n    /// @param to which user to push the tokens.\r\n    /// @param share The amount of `token` in shares.\r\n    function transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 share\r\n    ) external;\r\n\r\n    function setMasterContractApproval(\r\n        address user,\r\n        address masterContract,\r\n        bool approved,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /// @notice EIP 2612\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\n\r\n// File contracts/libraries/SafeERC20.sol\r\n\r\npragma solidity >=0.6.12;\r\n\r\nlibrary SafeERC20 {\r\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(\r\n            abi.encodeWithSelector(0x95d89b41)\r\n        );\r\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n    }\r\n\r\n    function safeName(IERC20 token) internal view returns (string memory) {\r\n        (bool success, bytes memory data) = address(token).staticcall(\r\n            abi.encodeWithSelector(0x06fdde03)\r\n        );\r\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n    }\r\n\r\n    function safeDecimals(IERC20 token) public view returns (uint8) {\r\n        (bool success, bytes memory data) = address(token).staticcall(\r\n            abi.encodeWithSelector(0x313ce567)\r\n        );\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, amount)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"SafeERC20: Transfer failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"SafeERC20: TransferFrom failed\"\r\n        );\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapV2Router01.sol\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapV2Router02.sol\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/MassDeposit.sol\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\n\r\ncontract MassDeposit {\r\n    using SafeERC20 for IERC20;\r\n    IBentoBoxMinimal internal immutable bentoBox;\r\n\r\n    IUniswapV2Router02 immutable routerSushi;\r\n    IUniswapV2Router02 immutable routerUni;\r\n\r\n    IERC20 immutable wETH;\r\n\r\n    event TokensWithNoLiquidity(address[] tokens);\r\n\r\n    constructor(\r\n        IBentoBoxMinimal _bentoBox,\r\n        IUniswapV2Router02 _routerSushi,\r\n        IUniswapV2Router02 _routerUni,\r\n        IERC20 _wETH\r\n    ) {\r\n        routerSushi = _routerSushi;\r\n        routerUni = _routerUni;\r\n        bentoBox = _bentoBox;\r\n        wETH = _wETH;\r\n        _wETH.approve(address(_routerSushi), type(uint256).max);\r\n        _wETH.approve(address(_routerUni), type(uint256).max);\r\n    }\r\n\r\n    function go(IERC20[] calldata tokens) external payable {\r\n        wETH.deposit{value: msg.value}();\r\n\r\n        uint256 tokensIndex = 0;\r\n        address[] memory tokensWithNoLiquidty = new address[](150);\r\n        for (uint256 i; i < tokens.length; i++) {\r\n            uint256 amountOut = _swapEthForTokens(address(tokens[i]));\r\n            if (amountOut == 0) {\r\n                tokensWithNoLiquidty[tokensIndex] = address(tokens[i]);\r\n                tokensIndex++;\r\n                continue;\r\n            }\r\n            bentoBox.deposit(\r\n                address(tokens[i]),\r\n                address(bentoBox),\r\n                0x000000000000000000000000000000000000dEaD,\r\n                amountOut,\r\n                0\r\n            );\r\n        }\r\n\r\n        emit TokensWithNoLiquidity(tokensWithNoLiquidty);\r\n\r\n        wETH.withdraw(wETH.balanceOf(address(this)));\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function swapSushi(address[] memory path, uint256 amountIn) internal {\r\n        routerSushi.swapExactTokensForTokens(\r\n            amountIn,\r\n            1000,\r\n            path,\r\n            address(bentoBox),\r\n            block.timestamp + 1000000\r\n        );\r\n    }\r\n\r\n    function swapUni(address[] memory path, uint256 amountIn) internal {\r\n        routerUni.swapExactTokensForTokens(\r\n            amountIn,\r\n            1000,\r\n            path,\r\n            address(bentoBox),\r\n            block.timestamp + 1000000\r\n        );\r\n    }\r\n\r\n    function _swapEthForTokens(address token)\r\n        internal\r\n        returns (uint256 amountOut)\r\n    {\r\n        address[] memory path1 = new address[](2);\r\n        path1[0] = address(wETH);\r\n        path1[1] = token;\r\n\r\n        // ETH -> USDC -> Token\r\n        address[] memory path2 = new address[](3);\r\n        path2[0] = address(wETH);\r\n        path2[1] = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n        path2[2] = token;        \r\n\r\n        try routerSushi.getAmountsIn(1000, path1) returns (uint256[] memory amounts1) {\r\n            if (amounts1[0] > 0 && amounts1[0] <= 10**15) {\r\n                swapSushi(path1, amounts1[0]);\r\n                return amounts1[1];\r\n            }\r\n        } catch {}\r\n\r\n        try routerSushi.getAmountsIn(1000, path2) returns (uint256[] memory amounts2) {\r\n            if (amounts2[0] > 0 && amounts2[0] <= 10**15) {\r\n                swapSushi(path2, amounts2[0]);\r\n                return amounts2[2];\r\n            }\r\n        } catch {}       \r\n\r\n        try routerUni.getAmountsIn(1000, path1) returns (uint256[] memory amounts3) {\r\n            if (amounts3[0] > 0 && amounts3[0] <= 10**15) {\r\n                swapUni(path1, amounts3[0]);\r\n                return amounts3[1];\r\n            }\r\n        } catch {}\r\n\r\n        try routerUni.getAmountsIn(1000, path2) returns (uint256[] memory amounts4) {\r\n            if (amounts4[0] > 0 && amounts4[0] <= 10**15) {\r\n                swapUni(path2, amounts4[0]);\r\n                return amounts4[2];\r\n            }\r\n        } catch {}        \r\n    }\r\n\r\n    receive() external payable {}\r\n}"}}}