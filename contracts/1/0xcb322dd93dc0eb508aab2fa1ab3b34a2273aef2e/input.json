{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Auction.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract SimpleAuction {\n    //Parameters of the SimpleAuction\n    uint256 private auctionEndTime;\n\n    // Current state of the auctionEndTime\n    address private highestBidder;\n    uint256 private highestBid;\n\n    IERC20 private token;\n    uint256 private lowestBidAmount;\n    uint256 private buyNowPrice;\n\n    bool ended = false;\n\n    constructor(\n        uint256 _biddingTime,\n        address _token,\n        uint256 _lowestBidAmount,\n        uint256 _buyNowPrice\n    ) {\n        token = IERC20(_token);\n        lowestBidAmount = _lowestBidAmount * 10**18;\n        buyNowPrice = _buyNowPrice * 10**18;\n        auctionEndTime = block.timestamp + _biddingTime;\n    }\n\n    function getAddress() external view returns (address) {\n        return address(this);\n    }\n\n    function getBuyNowPrice() external view returns (uint256) {\n        return buyNowPrice;\n    }\n\n    function getLowestPossibleBid() external view returns (uint256) {\n        return lowestBidAmount;\n    }\n\n    function getHighestBidder() external view returns (address) {\n        return highestBidder;\n    }\n\n    function getHighestBid() external view returns (uint256) {\n        return highestBid;\n    }\n\n    function bid(uint256 amountSmall, address sender) external {\n        uint256 amount = amountSmall * 10**18;\n        if (block.timestamp > auctionEndTime) {\n            revert(\"Auction already ended\");\n        }\n        if (amount > token.balanceOf(sender)) {\n            revert(\"Low Balance\");\n        }\n        if (amount < lowestBidAmount) {\n            revert(\"Bid amount too low\");\n        }\n        if (amount <= highestBid) {\n            revert(\"Amount is less than highestBid\");\n        }\n        require(token.transferFrom(sender, msg.sender, amount));\n\n        highestBidder = sender;\n        highestBid = amount;\n    }\n\n    function endAuction() external {\n        ended = true;\n    }\n\n    function auctionEnd() external returns (bool) {\n        if (block.timestamp < auctionEndTime) {\n            //revert(\"The auction has not ended yet\");\n            return false;\n        }\n        if (ended) {\n            //revert(\"The function actionEnded has already been called\");\n            return true;\n        }\n        ended = true;\n        return ended;\n        //token.transfer(msg.sender,highestBid);\n    }\n}\n"
    },
    "contracts/GoatMarketContract.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SimpleAuction} from \"./Auction.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract GoatMarketContract {\n    struct AuctionItem {\n        uint256 id;\n        address tokenAddress;\n        uint256 tokenId;\n        address seller;\n        uint256 askingPrice;\n        bool isSold;\n        bool active;\n    }\n    struct AuctionItemBid {\n        uint256 id;\n        address tokenAddress;\n        uint256 tokenId;\n        address seller;\n        uint256 buyNow;\n        bool isBidSold;\n        bool active;\n    }\n\n    address tracker_0x_address = 0x37611b28aCa5673744161Dc337128cfdD2657F69; // goat token\n\n    AuctionItem[] public itemsForSale;\n    AuctionItemBid[] public itemsForBid;\n    SimpleAuction[] public auctions;\n\n    mapping(address => mapping(uint256 => bool)) activeItems;\n\n    event itemAdded(\n        uint256 id,\n        uint256 tokenId,\n        address tokenAddress,\n        uint256 askingPrice,\n        bool active\n    );\n    event itemAddedBid(\n        uint256 newItemId,\n        uint256 tokenId,\n        address tokenAddress,\n        uint256 biddingTime,\n        address auction,\n        uint256 buyNow,\n        uint256 minBid,\n        bool active\n    );\n    event itemSold(uint256 id, address buyer, uint256 askingPrice, bool bid);\n    event priceChanged(uint256 id, uint256 newPrice);\n    event itemInActive(uint256 id, bool bid);\n    event bidded(\n        uint256 id,\n        uint256 amount,\n        address bidder,\n        address seller,\n        address tokenAddress,\n        uint256 tokenId\n    );\n    event withdrawn(uint256 id, address bidder, uint256 amount);\n\n    modifier OnlyItemOwner(address tokenAddress, uint256 tokenId) {\n        IERC721 tokenContract = IERC721(tokenAddress);\n        require(tokenContract.ownerOf(tokenId) == msg.sender);\n        _;\n    }\n\n    modifier HasTransferApproval(address tokenAddress, uint256 tokenId) {\n        IERC721 tokenContract = IERC721(tokenAddress);\n        require(tokenContract.getApproved(tokenId) == address(this));\n        _;\n    }\n\n    modifier ItemExists(uint256 id) {\n        require(\n            id < itemsForSale.length && itemsForSale[id].id == id,\n            \"Could not find item\"\n        );\n        _;\n    }\n    modifier ItemExistsBid(uint256 id) {\n        require(\n            id < itemsForBid.length && itemsForBid[id].id == id,\n            \"Could not find item\"\n        );\n        _;\n    }\n\n    modifier IsForSale(uint256 id) {\n        require(itemsForSale[id].isSold == false, \"Item is already sold!\");\n        _;\n    }\n    modifier IsForSaleBid(uint256 id) {\n        require(itemsForBid[id].isBidSold == false, \"Item is already sold!\");\n        _;\n    }\n\n    function changeItemPrice(uint256 id, uint256 askingPrice)\n        external\n        OnlyItemOwner(itemsForSale[id].tokenAddress, itemsForSale[id].tokenId)\n    {\n        require(\n            activeItems[itemsForSale[id].tokenAddress][\n                itemsForSale[id].tokenId\n            ] == true,\n            \"Item is not up for sale!\"\n        );\n        itemsForSale[id].askingPrice = askingPrice;\n        emit priceChanged(id, askingPrice);\n    }\n\n    function removeItemFP(uint256 id)\n        external\n        OnlyItemOwner(itemsForSale[id].tokenAddress, itemsForSale[id].tokenId)\n    {\n        require(\n            activeItems[itemsForSale[id].tokenAddress][\n                itemsForSale[id].tokenId\n            ] == true,\n            \"Item is not up for sale!\"\n        );\n        activeItemsActivator(\n            itemsForSale[id].tokenAddress,\n            itemsForSale[id].tokenId,\n            false\n        );\n\n        itemsForSale[id].active = false;\n        emit itemInActive(id, false);\n    }\n\n    function addItemToMarket(\n        uint256 tokenId,\n        address tokenAddress,\n        uint256 askingPrice\n    )\n        external\n        OnlyItemOwner(tokenAddress, tokenId)\n        HasTransferApproval(tokenAddress, tokenId)\n        returns (uint256)\n    {\n        require(\n            activeItems[tokenAddress][tokenId] == false,\n            \"Item is already up for sale!\"\n        );\n        uint256 newItemId = itemsForSale.length;\n        itemsForSale.push(\n            AuctionItem(\n                newItemId,\n                tokenAddress,\n                tokenId,\n                msg.sender,\n                askingPrice,\n                false,\n                true\n            )\n        );\n        activeItemsActivator(tokenAddress, tokenId, true);\n\n        assert(itemsForSale[newItemId].id == newItemId);\n        emit itemAdded(newItemId, tokenId, tokenAddress, askingPrice, true);\n        return newItemId;\n    }\n\n    function addItemToMarketBid(\n        uint256 tokenId,\n        address tokenAddress,\n        uint256 biddingTime,\n        uint256 minBid,\n        uint256 buyNow\n    )\n        external\n        OnlyItemOwner(tokenAddress, tokenId)\n        HasTransferApproval(tokenAddress, tokenId)\n        returns (uint256)\n    {\n        require(\n            activeItems[tokenAddress][tokenId] == false,\n            \"Item is already up for sale!\"\n        );\n        uint256 newItemId = itemsForBid.length;\n        activeItemsActivator(tokenAddress, tokenId, true);\n\n        itemsForBid.push(\n            AuctionItemBid(\n                newItemId,\n                tokenAddress,\n                tokenId,\n                msg.sender,\n                buyNow,\n                false,\n                true\n            )\n        );\n        SimpleAuction simpleAuction = new SimpleAuction(\n            biddingTime,\n            tracker_0x_address,\n            minBid,\n            buyNow\n        );\n        auctions.push(simpleAuction);\n\n        assert(itemsForBid[newItemId].id == newItemId);\n\n        emit itemAddedBid(\n            newItemId,\n            tokenId,\n            tokenAddress,\n            biddingTime,\n            simpleAuction.getAddress(),\n            (simpleAuction.getBuyNowPrice() / 10**18),\n            (simpleAuction.getLowestPossibleBid() / 10**18),\n            true\n        );\n        return newItemId;\n    }\n\n    function buyOrBid(\n        uint256 id,\n        address admin,\n        uint256 serviceFeePercentage,\n        uint256 value\n    )\n        external\n        ItemExistsBid(id)\n        IsForSaleBid(id)\n        HasTransferApproval(\n            itemsForBid[id].tokenAddress,\n            itemsForBid[id].tokenId\n        )\n    {\n        require(itemsForBid[id].active, \"Item is no longer on sale\");\n        require(!itemsForBid[id].isBidSold, \"Item is sold\");\n        require(msg.sender != itemsForBid[id].seller);\n        if ((value * 10**18) >= auctions[id].getBuyNowPrice()) {\n            _bid(id, value, msg.sender);\n            itemsForBid[id].isBidSold = true;\n            itemsForBid[id].active = false;\n            activeItemsActivator(\n                itemsForBid[id].tokenAddress,\n                itemsForBid[id].tokenId,\n                false\n            );\n            purchase(id, admin, serviceFeePercentage, value, msg.sender, true);\n        } else {\n            _bid(id, value, msg.sender);\n        }\n    }\n\n    function _bid(\n        uint256 id,\n        uint256 value,\n        address sender\n    ) private {\n        returnPreviousBid(id);\n        auctions[id].bid(value, sender);\n        emit bidded(\n            id,\n            value,\n            sender,\n            itemsForBid[id].seller,\n            itemsForBid[id].tokenAddress,\n            itemsForBid[id].tokenId\n        );\n    }\n\n    function returnPreviousBid(uint256 id) private {\n        if (auctions[id].getHighestBid() > 0) {\n            IERC20(tracker_0x_address).transfer(\n                auctions[id].getHighestBidder(),\n                auctions[id].getHighestBid()\n            );\n            emit withdrawn(\n                id,\n                auctions[id].getHighestBidder(),\n                auctions[id].getHighestBid()\n            );\n        }\n    }\n\n    function buyItem(\n        uint256 id,\n        address admin,\n        uint256 serviceFeePercentage,\n        uint256 value\n    )\n        external\n        ItemExists(id)\n        IsForSale(id)\n        HasTransferApproval(\n            itemsForSale[id].tokenAddress,\n            itemsForSale[id].tokenId\n        )\n    {\n        require(itemsForSale[id].active, \"Item is no longer on sale\");\n        require(!itemsForSale[id].isSold, \"Item is sold\");\n        require(value >= itemsForSale[id].askingPrice, \"Not enough funds sent\");\n        require(msg.sender != itemsForSale[id].seller);\n\n        itemsForSale[id].isSold = true;\n        itemsForSale[id].active = false;\n        activeItemsActivator(\n            itemsForSale[id].tokenAddress,\n            itemsForSale[id].tokenId,\n            false\n        );\n\n        purchase(id, admin, serviceFeePercentage, value, msg.sender, false);\n    }\n\n    function run(\n        uint256 id,\n        AuctionItemBid memory itemForBid,\n        SimpleAuction auction,\n        address admin,\n        uint256 serviceFeePercentage\n    ) private {\n        itemForBid.isBidSold = true;\n        itemForBid.active = false;\n        activeItemsActivator(\n            itemForBid.tokenAddress,\n            itemForBid.tokenId,\n            false\n        );\n\n        purchase(\n            id,\n            admin,\n            serviceFeePercentage,\n            auction.getHighestBid() / 10**18,\n            auction.getHighestBidder(),\n            true\n        );\n    }\n\n    function purchase(\n        uint256 id,\n        address admin,\n        uint256 serviceFeePercentage,\n        uint256 value,\n        address buyer,\n        bool bid\n    ) private {\n        uint256 serviceFee = ((value * 10**18) * serviceFeePercentage) / 100;\n        uint256 pay = (value * 10**18) - serviceFee;\n\n        if (bid) {\n            IERC721(itemsForBid[id].tokenAddress).safeTransferFrom(\n                itemsForBid[id].seller,\n                buyer,\n                itemsForBid[id].tokenId\n            );\n            IERC20(tracker_0x_address).transfer(itemsForBid[id].seller, pay);\n            IERC20(tracker_0x_address).transfer(admin, serviceFee);\n        } else {\n            IERC721(itemsForSale[id].tokenAddress).safeTransferFrom(\n                itemsForSale[id].seller,\n                buyer,\n                itemsForSale[id].tokenId\n            );\n            IERC20(tracker_0x_address).transferFrom(\n                buyer,\n                itemsForSale[id].seller,\n                pay\n            );\n            IERC20(tracker_0x_address).transferFrom(buyer, admin, serviceFee);\n        }\n        emit itemSold(id, buyer, value, bid);\n    }\n\n    function endBid(\n        uint256 id,\n        address admin,\n        uint256 serviceFeePercentage,\n        bool accept\n    )\n        external\n        ItemExistsBid(id)\n        IsForSaleBid(id)\n        HasTransferApproval(\n            itemsForBid[id].tokenAddress,\n            itemsForBid[id].tokenId\n        )\n        returns (bool)\n    {\n        require(itemsForBid[id].active, \"Item is no longer on sale\");\n        require(!itemsForBid[id].isBidSold, \"Item is sold\");\n        AuctionItemBid memory itemForBid = itemsForBid[id];\n        SimpleAuction auction = auctions[id];\n        if (!auction.auctionEnd()) {\n            require(msg.sender == itemForBid.seller, \"you are not the seller\");\n            if (accept) {\n                require(\n                    auction.getHighestBid() >= auction.getLowestPossibleBid(),\n                    \"No reasonable bid yet\"\n                );\n                run(id, itemForBid, auction, admin, serviceFeePercentage);\n                return true;\n            } else {\n                returnPreviousBid(id);\n                auction.endAuction();\n                activeItemsActivator(\n                    itemForBid.tokenAddress,\n                    itemForBid.tokenId,\n                    false\n                );\n                itemForBid.active = false;\n                emit itemInActive(id, true);\n                return false;\n            }\n        } else {\n            if (auction.getHighestBid() >= auction.getLowestPossibleBid()) {\n                run(id, itemForBid, auction, admin, serviceFeePercentage);\n                return true;\n            } else {\n                activeItemsActivator(\n                    itemForBid.tokenAddress,\n                    itemForBid.tokenId,\n                    false\n                );\n                itemForBid.active = false;\n                emit itemInActive(id, true);\n                return false;\n            }\n        }\n    }\n\n    function activeItemsActivator(\n        address tokenAddress,\n        uint256 tokenId,\n        bool value\n    ) private {\n        activeItems[tokenAddress][tokenId] = value;\n    }\n}\n"
    }
  }
}