{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/dtnet.sol": {
      "content": "pragma solidity >=0.4.22 <0.7.0;\r\n\r\ncontract dtnet {\r\n    uint public tp_id; // trading pair current id\r\n    uint public test_num; // for testing\r\n    address payable public operator; //current operator address for commission\r\n    address payable public comm_addr; //where commission is to be paid \r\n    \r\n    struct trading_pair {\r\n        address payable buyer;\r\n        address payable seller;\r\n        uint tpid;\r\n        uint balance;\r\n        uint return_seller;\r\n        uint return_buyer;\r\n        string instrument_name;\r\n        uint opening_price;\r\n        uint opening_price_ts;\r\n        uint closing_price;\r\n        uint closing_price_ts;\r\n        uint leverage;\r\n        uint status; //1-buyer only, 2-seller only, 3-seller and buyer, ready to open price, 4 price opened, 5 closing initiated, 6 closed, 7 recalled\r\n        address closing_initiator;\r\n    }\r\n    \r\n    mapping (uint => trading_pair) public tp;\r\n\r\n    struct trading_pair2 {\r\n        uint buyer_paidin; \r\n        uint seller_paidin;\r\n        uint tpid2;\r\n    }\r\n    \r\n    mapping (uint => trading_pair2) public tp2;\r\n    \r\n    constructor() public {\r\n        operator = msg.sender;\r\n        comm_addr = msg.sender;\r\n    }\r\n    \r\n    function test(uint to_add) public payable returns(string memory Result) {\r\n        test_num=test_num+to_add;\r\n        return(\"test added\");\r\n    }\r\n\r\n    function changeComm(address payable newComm) public {\r\n        require((msg.sender==operator) || msg.sender==comm_addr, \"Only Operator or Commission Address can call this function\");\r\n        comm_addr = newComm;\r\n    }\r\n\r\n    function changeOp(address payable newOp) public {\r\n        require(msg.sender==operator, \"Only Operator can call this function\");\r\n        operator = newOp;\r\n    }\r\n    \r\n    function recall(uint TPID) public{\r\n        require((msg.sender==tp[TPID].buyer && tp[TPID].status==1) || (msg.sender==tp[TPID].seller && tp[TPID].status==2) || msg.sender==operator, \"Only Buyer, Seller or Operator can call this function\");\r\n        require(tp[TPID].status==1 || tp[TPID].status==2, \"Not accepting recall requests\");\r\n        //returning money to buyer\r\n        if(tp[TPID].status==1){\r\n            tp[TPID].buyer.transfer(tp[TPID].balance);\r\n        }\r\n        if(tp[TPID].status==2){\r\n            tp[TPID].seller.transfer(tp[TPID].balance);\r\n        }\r\n        tp[TPID].balance=0;\r\n        tp[TPID].status=7;\r\n        tp[TPID].closing_initiator=msg.sender;\r\n    }\r\n    \r\n    function initiateClosing(uint TPID) public{\r\n        require(msg.sender==tp[TPID].buyer || msg.sender==tp[TPID].seller || msg.sender==operator, \"Only Buyer, Seller or Operator can call this function\");\r\n        require(tp[TPID].status==4, \"Not accepting closure requests\");\r\n        tp[TPID].closing_initiator=msg.sender;\r\n        tp[TPID].status=5;\r\n    }\r\n    \r\n    function setClosePrice(uint TPID, uint closing_price, uint closing_ts, uint to_buyer_wei, uint to_seller_wei) public {\r\n        require(msg.sender == operator, \"Only contract operator can call this function\");\r\n        //require(tp[TPID].status == 5, \"Not waiting for Set Closing Price\");\r\n        require(tp[TPID].balance >= to_buyer_wei + to_seller_wei, \"Requested payouts larger than contract balance\");\r\n        tp[TPID].closing_price_ts = closing_ts;\r\n        tp[TPID].closing_price=closing_price;\r\n\r\n        \r\n        tp[TPID].return_buyer=to_buyer_wei;\r\n        tp[TPID].return_seller=to_seller_wei;\r\n        \r\n        //payouts\r\n        tp[TPID].buyer.transfer(to_buyer_wei);\r\n        tp[TPID].seller.transfer(to_seller_wei);\r\n        comm_addr.transfer(tp[TPID].balance-to_buyer_wei-to_seller_wei);\r\n        tp[TPID].balance=0;\r\n\r\n        //status closed\r\n        tp[TPID].status=6;\r\n    }    \r\n    \r\n    function setOpenPrice(uint TPID, uint opening_price, uint opening_ts) public {\r\n        require(msg.sender == operator, \"Only contract operator can call this function\");\r\n        require(tp[TPID].status == 3, \"Not waiting for Set Opening Price\");\r\n        tp[TPID].opening_price_ts = opening_ts;\r\n        tp[TPID].opening_price=opening_price;\r\n        tp[TPID].status=4;\r\n    }\r\n\r\n    function init(uint command, string memory instrument, uint lever) public payable returns (string memory Result) {\r\n        // called to initialize new trading pair\r\n        // command 1 = buy, 2 = sell\r\n        require(msg.value>=100000000000000000, \"Amount must be 0.1 ETH or more\");\r\n        require(command == 1 || command == 2, \"Unknown command\");\r\n        \r\n        tp_id = tp_id + 1;\r\n        \r\n        tp[tp_id].instrument_name=instrument;\r\n        tp[tp_id].leverage=lever;\r\n        tp[tp_id].tpid=tp_id;\r\n        tp2[tp_id].tpid2=tp_id;\r\n        \r\n        //new buy\r\n        if(command == 1){\r\n            tp[tp_id].buyer = msg.sender;\r\n            tp[tp_id].balance = msg.value;\r\n            tp2[tp_id].buyer_paidin = msg.value;\r\n            tp[tp_id].status = 1;\r\n            //tp_buyer_paid_amount[tp_id] = msg.value;\r\n            //tp_instrument_name[tp_id] = instrument;\r\n            //tp_status[tp_id] = 1;\r\n            return(\"Funds recevied / buy now looking for a sell\");\r\n        }\r\n        \r\n        //new sell    \r\n        if(command == 2){\r\n            tp[tp_id].seller = msg.sender;\r\n            tp[tp_id].balance = msg.value;\r\n            tp2[tp_id].seller_paidin = msg.value;\r\n            tp[tp_id].status = 2;\r\n            //tp_buyer_paid_amount[tp_id] = msg.value;\r\n            //tp_instrument_name[tp_id] = instrument;\r\n            //tp_status[tp_id] = 1;\r\n            return(\"Funds recevied / sell now looking for a buy\");\r\n        }        \r\n        \r\n        }\r\n        \r\n    function join(uint TPID) public payable returns (string memory Result){\r\n        require(tp[TPID].status == 1 || tp[TPID].status ==2, \"Transaction not looking for a peer\");\r\n        require(msg.value >= tp[TPID].balance, \"Not enough ETH, send more\");\r\n        \r\n        if(tp[TPID].status==1){ \r\n            tp[TPID].balance += msg.value;\r\n            tp2[TPID].seller_paidin = msg.value;\r\n            tp[TPID].seller = msg.sender;\r\n            tp[TPID].status = 3;\r\n        }\r\n        \r\n        if(tp[TPID].status==2){ \r\n            tp[TPID].balance += msg.value;\r\n            tp2[TPID].buyer_paidin = msg.value;\r\n            tp[TPID].buyer = msg.sender;\r\n            tp[TPID].status = 3;\r\n        }\r\n        \r\n        return(\"Trading Pair opened\");\r\n    }\r\n\r\n    fallback() external payable { }\r\n    receive() external payable { }\r\n}"
    }
  }
}