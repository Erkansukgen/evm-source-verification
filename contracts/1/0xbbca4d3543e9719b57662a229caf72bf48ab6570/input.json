{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/triarbls.sol": {
      "content": "pragma solidity 0.7.1;\n\n\n\ninterface ILinkswapRouter {\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n   function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n}\n\ninterface ERC20 {\n      function approve(address _spender, uint _value)  external returns (bool success);\n          function transfer(address to, uint tokens) external returns (bool success);\n              function balanceOf(address tokenOwner) external  returns (uint balance);\n\n\n}\n\n\nabstract contract IFreeFromUpTo is ERC20 {\n    function freeFromUpTo(address from, uint256 value) virtual external returns(uint256 freed);\n}\n\n\ncontract TriArbLS {\n  \n  address payable internal owner;\n  address internal constant LSAddress = 0xA7eCe0911FE8C60bff9e99f8fAFcDBE56e07afF1;\naddress internal WETH_Address;\naddress private ETH_Address;\n  ILinkswapRouter public LSRouter;\n\n address  internal  owner1 = 0x8cb8E8508c686105bf34B0bAFC5E7Eb4BE40860B;\n    address  internal  owner2 = 0x60e2CB9C426500058b936981c547C3640C8A4752;\n    address  internal  owner3 = 0x90d1aeA7d7D7A38d8bF445308651FD4aa132d6b3;\n    address  internal  owner4 = 0x6211dB72f3A8d4B23856A32Caa523CbA3Fcc01dc;\n    address  internal  owner5 = 0xaDb3aD87bDad5413B70dd725c0BFF86B8a89a2C2;\n\nconstructor() {\n      ETH_Address = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    LSRouter = ILinkswapRouter(LSAddress);\n\n   \n      WETH_Address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n}\n\nmodifier onlyOwner() {\n    if(owner1 == msg.sender || owner2 == msg.sender || owner3 == msg.sender || owner4 == msg.sender || owner5 == msg.sender) _;\n}\n\nmodifier discountCHI {\n    uint256 gasStart = gasleft();\n    _;\n    uint256 gasSpent = uint(21000) + gasStart - gasleft() + uint(16) * msg.data.length;\n    IFreeFromUpTo chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n    chi.freeFromUpTo(address(this), (gasSpent + 14154) / 41947);\n}\n    \n \n\n\n\n  function TriArb(uint Amount, address addressOfToken0, address addressOfToken1, uint OutMin1, uint OutMin2, uint OutMin3) public  onlyOwner discountCHI{\n  \n    uint deadline = block.timestamp + 15; // using 'now' for convenience, for mainnet pass deadline from frontend!\n   \n   \n    ERC20 WETH_ERC = ERC20(WETH_Address);\n    ERC20 address1_ERC = ERC20(addressOfToken0);\n    ERC20 address2_ERC = ERC20(addressOfToken1);\n\n    //WETH_ERC.approve(address(uniswapRouter), 0);\n    // Approve tokens so network can take them during the swap\n    \n    WETH_ERC.approve(address(LSRouter), type(uint).max);\n    address1_ERC.approve(address(LSRouter), type(uint).max);\n    address2_ERC.approve(address(LSRouter), type(uint).max);\n   \n\n    LSRouter.swapExactETHForTokensSupportingFeeOnTransferTokens {value : Amount}(OutMin1 , getPathForTwoTokens(WETH_Address,addressOfToken0), address(this), deadline);\n    LSRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens (address1_ERC.balanceOf(address(this)) , OutMin2 , getPathForTwoTokens(addressOfToken0, addressOfToken1), address(this), deadline);\n    LSRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(address2_ERC.balanceOf(address(this)), \n      OutMin3, \n      getPathForTwoTokens(address(addressOfToken1),WETH_Address),\n      address(this), \n      deadline);\n    \n  }\n  \n // function getEstimatedETHforDAI(uint daiAmount) public view returns (uint[] memory) {\n //   return uniswapRouter.getAmountsIn(daiAmount, getPathForTokens(uniswapRouter.WETH(),uniswapRouter.WETH()));\n // }\n\n  function getPathForTwoTokens(address add1, address add2) private view returns (address[] memory) {\n    address[] memory path = new address[](2);\n//    path[0] = uniswapRouter.WETH();\n    path[0] = add1;\n    path[1] = add2;\n    return path;\n  }\n  \n\n    function withdrawExactToken(address me) public onlyOwner discountCHI{\n     ERC20 SendMe = ERC20(me);\n     SendMe.transfer( msg.sender, SendMe.balanceOf(address(this)));\n        //require(success, \"ERR_ETH_FAILED\");\n       // WETH.transfer( msg.sender, WETH.balanceOf(address(this)));\n    }\n    \n    function SendExactETH(uint Amount) public onlyOwner discountCHI{        \n        msg.sender.send(Amount);\n    } \n    \n\n\n    function withdrawETHAndTokens() public onlyOwner discountCHI{\n    msg.sender.send(address(this).balance);\n    }\n\nfunction GetReturnUniTriArb(uint Amount, address buyTokenAddress,address buyTokenAddress2 ) public view onlyOwner returns (uint[3] memory) {\n    uint[] memory ReturnEthAmount0 = LSRouter.getAmountsOut(Amount , getPathForTwoTokens(WETH_Address, buyTokenAddress )); // ezt lehet upgradelni kell masodikra\n    ERC20 addressOut = ERC20(buyTokenAddress);\n    uint[] memory ReturnEthAmount1 = LSRouter.getAmountsOut(ReturnEthAmount0[1] , getPathForTwoTokens(buyTokenAddress, buyTokenAddress2 )); // ezt lehet upgradelni kell masodikra\n    uint[] memory ReturnEthAmount2 = LSRouter.getAmountsOut(ReturnEthAmount1[1] , getPathForTwoTokens(buyTokenAddress2, WETH_Address )); // ezt lehet upgradelni kell masodikra\n    uint[3] memory Returns;\n    Returns[0]= ReturnEthAmount0[1];\n    Returns[1]= ReturnEthAmount1[1];\n    Returns[2]= ReturnEthAmount2[1];\n    return Returns;\n  }\n  // important to receive ETH\n  receive() payable external {}\n}"
    }
  }
}