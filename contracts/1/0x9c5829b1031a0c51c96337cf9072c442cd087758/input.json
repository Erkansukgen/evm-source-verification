{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/FlashMoneyPrinter.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.6.6 <0.8.0;\r\n\r\n\r\nimport './interfaces/IUniswapV2Router.sol';\r\nimport './interfaces/IUniswapV2Pair.sol';\r\nimport './interfaces/IUniswapV2Factory.sol';\r\nimport './interfaces/IERC20.sol';\r\n\r\n// e00: out of block\r\n// e01: no profit\r\n// e10: Requested pair is not available\r\n// e11: token0 / token1 does not exist\r\n// e12: src/target router empty\r\n// e13: pancakeCall not enough tokens for buyback\r\n// e14: pancakeCall msg.sender transfer failed\r\n// e15: pancakeCall owner transfer failed\r\n\r\ncontract MoneyPrinter {\r\n    \r\n  address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function arb(\r\n        uint256 _amountIn,\r\n        address _sourceRouter,\r\n        address _targetRouter,\r\n        address _sourceFactory,\r\n        address[] calldata _pathIn,\r\n        address[] calldata _pathOut\r\n    ) external {\r\n       \r\n        // recheck for stopping and gas usage\r\n       (int256 profit, uint256 _amountOut) = check(_amountIn,_pathIn,_pathOut, _sourceRouter, _targetRouter);\r\n        require(profit > 0, 'e01');\r\n\r\n        address pairAddress = IUniswapV2Factory(_sourceFactory).getPair(_pathIn[0], _pathOut[0]); // is it cheaper to compute this locally?\r\n        require(pairAddress != address(0), 'e10');\r\n\r\n        IUniswapV2Pair(pairAddress).swap(\r\n             _pathOut[0] == IUniswapV2Pair(pairAddress).token0() ? _amountOut : 0,\r\n             _pathOut[0] == IUniswapV2Pair(pairAddress).token1() ? _amountOut : 0,\r\n            address(this),\r\n            abi.encode(_sourceRouter, _targetRouter)\r\n        );\r\n    }\r\n\r\n    function check(\r\n        uint256 _amountIn, // example: BNB => 10 * 1e18\r\n        address[] calldata _pathIn,\r\n        address[] calldata _pathOut,\r\n        address _sourceRouter,\r\n        address _targetRouter\r\n    ) public view returns(int256, uint256) {\r\n\r\n        uint256 amountOut = IUniswapV2Router(_sourceRouter).getAmountsOut(_amountIn, _pathIn)[1];\r\n        uint256 amountRepay = IUniswapV2Router(_targetRouter).getAmountsOut(amountOut, _pathOut)[1];\r\n        \r\n        return (\r\n            int256(amountRepay - _amountIn), // our profit or loss; example output: BNB amount\r\n            amountOut // the amount we get from our input \"_amountTokenPay\"; example: BUSD amount\r\n        );\r\n    }\r\n\r\n    function execute(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) internal {\r\n        // obtain an amount of token that you exchanged\r\n        uint256 amountOut = _amount0 == 0 ? _amount1 : _amount0;\r\n        //address sender = _sender;\r\n        IUniswapV2Pair iUniswapV2Pair = IUniswapV2Pair(msg.sender);\r\n        address token0 = iUniswapV2Pair.token0();\r\n        address token1 = iUniswapV2Pair.token1();\r\n\r\n\r\n        // require(token0 != address(0) && token1 != address(0), 'e16');\r\n\r\n        // if _amount0 is zero sell token1 for token0\r\n        // else sell token0 for token1 as a result\r\n        address[] memory path1 = new address[](2);\r\n        address[] memory path = new address[](2);\r\n        path[0] = path1[1] = _amount0 == 0 ? token1 : token0; // c&p\r\n        path[1] = path1[0] = _amount0 == 0 ? token0 : token1; // c&p\r\n\r\n        (address sourceRouter, address targetRouter) = abi.decode(_data, (address, address));\r\n        //require(sourceRouter != address(0) && targetRouter != address(0), 'e12');\r\n\r\n        // IERC20 token that we will sell for otherTokens\r\n        \r\n        //ANALYZE THIS 20k-40k gas approval\r\n        IERC20(_amount0 == 0 ? token1 : token0).approve(targetRouter, amountOut);\r\n\r\n        // calculate the amount of token how much input token should be reimbursed\r\n        uint256 amountRequired = IUniswapV2Router(sourceRouter).getAmountsIn(amountOut, path1)[0];\r\n\r\n        // swap token and obtain equivalent otherToken amountRequired as a result\r\n        uint256 amountReceived = IUniswapV2Router(targetRouter).swapExactTokensForTokens(\r\n            amountOut,\r\n            0, // we already now what we need at least for payback; get less is a fail; slippage can be done via - ((amountRequired * 19) / 981) + 1,\r\n            path,\r\n            address(this), // its a foreign call; from router but we need contract address also equal to \"_sender\"\r\n            block.timestamp + 60\r\n        )[1];\r\n        \r\n        // fail if we didn't get enough tokens\r\n        require(amountReceived > amountRequired, 'e13');\r\n    \r\n        IERC20 otherToken = IERC20(_amount0 == 0 ? token0 : token1);\r\n        // transfer failing already have error message\r\n        otherToken.transfer(msg.sender, amountRequired); // send back borrow\r\n        otherToken.transfer(owner, amountReceived - amountRequired); // our win\r\n    }\r\n        // pancake, pancakeV2, apeswap, kebab\r\n\r\n    // pancake, pancakeV2, apeswap, kebab\r\n    function pancakeCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n\r\n    function waultSwapCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n\r\n    function uniswapV2Call(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n\r\n    // mdex\r\n    function swapV2Call(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n\r\n    // pantherswap\r\n    function pantherCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n\r\n    // jetswap\r\n    function jetswapCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n\r\n    // cafeswap\r\n    function cafeCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n\r\n    // @TODO: pending release\r\n    function BiswapCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n\r\n    // @TODO: pending release\r\n    function wardenCall(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data) external {\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n    \r\n}     \r\n    //test gas useage\r\n    //receive() external payable {}\r\n    \r\n"},"contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"},"contracts/interfaces/IUniswapV2Factory.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n"},"contracts/interfaces/IUniswapV2Pair.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n"},"contracts/interfaces/IUniswapV2Router.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router {\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n}\n"}}}