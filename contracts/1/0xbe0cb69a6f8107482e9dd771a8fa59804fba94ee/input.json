{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"distro.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\ncontract DistroContract {\n    using SafeMath for uint256;\n\n    address payable wallet1 = 0x4A1a435a550A05f940D1114af167b06308f2cE8E;\n    address payable wallet2 = 0x653Cf82b7344e38eE7A2c73ce3A5CBA671944417;\n    address payable wallet3 = 0x9fcA7e51Af009fC928976355e1C32BFc48E408bc;\n    address payable wallet4 = 0xdD54346268ee90D06B2EBCbFE778476D00Bf6846;\n    address payable wallet5 = 0x9502289Eaa0282b11a1730f34d19a11f2e59eD97;\n    address payable wallet6 = 0x2FF02621648Cd1dA959F9C15111F3bC1fe33b9f0;\n\n    receive() external payable {\n        if (msg.sender == wallet6 || msg.sender == wallet5  || msg.sender == wallet4  || msg.sender == wallet3  || msg.sender == wallet2) {\n            if (msg.value == 0) {\n                require(address(this).balance > 100, \"Insufficient contract balance to distribute.\");\n                uint256 total = address(this).balance;\n                uint256 amount1 = total.mul(40).div(100);\n                wallet1.transfer(amount1);\n                uint256 amount2 = total.mul(12).div(100);\n                wallet2.transfer(amount2);\n                wallet3.transfer(amount2);\n                wallet4.transfer(amount2);\n                wallet5.transfer(amount2);\n                wallet6.transfer(total.sub(amount1).sub(amount2.mul(4)));\n            }\n        }\n    }\n\n\n}"}}}