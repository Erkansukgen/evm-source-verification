{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/UniswapFlashQuery.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n\ninterface Quoter {\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n\ninterface IUniswapV3Pool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    function liquidity() external view returns (uint128);\n\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function fee() external view returns (uint24);\n\n    function tickSpacing() external view returns (int24);\n}\n\nabstract contract UniswapV2Factory {\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    function allPairsLength() external view virtual returns (uint256);\n}\n\nabstract contract UniswapV3Factory {\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view virtual returns (address);\n}\n\n// In order to quickly load up data from Uniswap-like market, this contract allows easy iteration with a single eth_call\ncontract FlashBotsUniswapQuery {\n    function getReservesByPairs(IUniswapV2Pair[] calldata _pairs)\n        external\n        view\n        returns (uint256[3][] memory)\n    {\n        uint256[3][] memory result = new uint256[3][](_pairs.length);\n        for (uint256 i = 0; i < _pairs.length; i++) {\n            (result[i][0], result[i][1], result[i][2]) = _pairs[i]\n                .getReserves();\n        }\n        return result;\n    }\n\n    function getPriceLiquidityFeeByPools(IUniswapV3Pool[] calldata _pools)\n        external\n        view\n        returns (uint256[5][] memory)\n    {\n        uint256[5][] memory result = new uint256[5][](_pools.length);\n        for (uint256 i = 0; i < _pools.length; i++) {\n            (result[i][0], , , , , , ) = _pools[i].slot0();\n            result[i][1] = _pools[i].liquidity();\n            result[i][2] = _pools[i].fee();\n            IERC20 token0 = IERC20(_pools[i].token0());\n            IERC20 token1 = IERC20(_pools[i].token1());\n            result[i][3] = token0.balanceOf(address(_pools[i]));\n            result[i][4] = token1.balanceOf(address(_pools[i]));\n        }\n        return result;\n    }\n\n    function getPairsByIndexRange(\n        UniswapV2Factory _uniswapFactory,\n        uint256 _start,\n        uint256 _stop\n    ) external view returns (address[3][] memory) {\n        uint256 _allPairsLength = _uniswapFactory.allPairsLength();\n        if (_stop > _allPairsLength) {\n            _stop = _allPairsLength;\n        }\n        require(_stop >= _start, \"start cannot be higher than stop\");\n        uint256 _qty = _stop - _start;\n        address[3][] memory result = new address[3][](_qty);\n        for (uint256 i = 0; i < _qty; i++) {\n            IUniswapV2Pair _uniswapPair = IUniswapV2Pair(\n                _uniswapFactory.allPairs(_start + i)\n            );\n            result[i][0] = _uniswapPair.token0();\n            result[i][1] = _uniswapPair.token1();\n            result[i][2] = address(_uniswapPair);\n        }\n        return result;\n    }\n\n    function getPoolsByTokens(\n        UniswapV3Factory _uniswapFactory,\n        address[] memory _token0,\n        address[] memory _token1,\n        uint24[] memory _feeList\n    ) external view returns (address[3][] memory) {\n        require(\n            _token0.length == _token1.length,\n            \"token 0 and 1 length not equal\"\n        );\n        uint256 count = 0;\n        address[3][] memory result = new address[3][](_token0.length * 3);\n        for (uint256 i = 0; i < _token0.length; i++) {\n            for (uint256 j = 0; j < _feeList.length; j++) {\n                address poolAddress = _uniswapFactory.getPool(\n                    _token0[i],\n                    _token1[i],\n                    _feeList[j]\n                );\n                if (poolAddress != address(0)) {\n                    result[count][0] = IUniswapV3Pool(poolAddress).token0();\n                    result[count][1] = IUniswapV3Pool(poolAddress).token1();\n                    result[count][2] = poolAddress;\n                    count++;\n                }\n            }\n        }\n        address[3][] memory finalResult = new address[3][](count);\n        for (uint256 k = 0; k < count; k++) {\n            finalResult[k][0] = result[k][0];\n            finalResult[k][1] = result[k][1];\n            finalResult[k][2] = result[k][2];\n        }\n        return result;\n    }\n\n    function V3getTokensOut(\n        Quoter _quoter,\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 _inAmount,\n        uint160 _sqrtPriceLimitX96\n    ) external payable returns (uint256) {\n        try\n            _quoter.quoteExactInputSingle(\n                _tokenIn,\n                _tokenOut,\n                _fee,\n                _inAmount,\n                _sqrtPriceLimitX96\n            )\n        returns (uint256 v) {\n            return v;\n        } catch (bytes memory) {\n            return 0;\n        }\n    }\n\n    function V3getMultipleTokensOut(\n        Quoter[] memory _quoters,\n        address[] memory _tokenIn,\n        address[] memory _tokenOut,\n        uint24[] memory _fee,\n        uint256[] memory _inAmount,\n        uint256[] memory _ratio,\n        uint160[] memory _sqrtPriceLimitX96\n    ) external payable returns (uint256[][] memory) {\n        require(\n            _tokenIn.length == _tokenOut.length,\n            \"token 0 and 1 length not equal\"\n        );\n        require(\n            _tokenIn.length == _fee.length,\n            \"token and fee length not equal\"\n        );\n        uint256[][] memory result = new uint256[][](_tokenIn.length);\n        for (uint256 i = 0; i < _tokenIn.length; i++) {\n            uint256[] memory temp = new uint256[](_inAmount.length);\n            for (uint256 j = 0; j < _inAmount.length; j++) {\n                uint256 _amount = _inAmount[j]*_ratio[i];\n                try\n                    _quoters[i].quoteExactInputSingle(\n                        _tokenIn[i],\n                        _tokenOut[i],\n                        _fee[i],\n                        _amount,\n                        _sqrtPriceLimitX96[i]\n                    )\n                returns (uint256 v) {\n                    temp[j] = v;\n                } catch (bytes memory) {\n                    temp[j] = 0;\n                }\n            }\n            result[i] = temp;\n        }\n        return result;\n    }\n\n    function V3getTokensIn(\n        Quoter _quoter,\n        address _tokenIn,\n        address _tokenOut,\n        uint24 _fee,\n        uint256 _outAmount,\n        uint160 _sqrtPriceLimitX96\n    ) external payable returns (uint256) {\n        try\n            _quoter.quoteExactOutputSingle(\n                _tokenIn,\n                _tokenOut,\n                _fee,\n                _outAmount,\n                _sqrtPriceLimitX96\n            )\n        returns (uint256 v) {\n            return v;\n        } catch (bytes memory) {\n            return uint256(-1);\n        }\n    }\n\n    function V3getMultipleTokensIn(\n        Quoter[] memory _quoters,\n        address[] memory _tokenIn,\n        address[] memory _tokenOut,\n        uint24[] memory _fee,\n        uint256[] memory _outAmount,\n        uint256[] memory _ratio,\n        uint160[] memory _sqrtPriceLimitX96\n    ) external payable returns (uint256[][] memory) {\n        require(\n            _tokenIn.length == _tokenOut.length,\n            \"token 0 and 1 length not equal\"\n        );\n        require(\n            _tokenIn.length == _fee.length,\n            \"token and fee length not equal\"\n        );\n        uint256[][] memory result = new uint256[][](_tokenIn.length);\n        for (uint256 i = 0; i < _tokenIn.length; i++) {\n            uint256[] memory temp = new uint256[](_outAmount.length);\n            for (uint256 j = 0; j < _outAmount.length; j++) {\n                uint256 _amount = _outAmount[j]*_ratio[i];\n                try\n                    _quoters[i].quoteExactOutputSingle(\n                        _tokenIn[i],\n                        _tokenOut[i],\n                        _fee[i],\n                        _amount,\n                        _sqrtPriceLimitX96[i]\n                    )\n                returns (uint256 v) {\n                    temp[j] = v;\n                } catch (bytes memory) {\n                    temp[j] = uint256(-1);\n                }\n            }\n            result[i] = temp;\n        }\n        return result;\n    }\n}"}}}