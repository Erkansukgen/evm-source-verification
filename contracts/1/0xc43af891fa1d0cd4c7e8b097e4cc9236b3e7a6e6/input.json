{"language":"Solidity","settings":{"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}},"sources":{"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"contracts/BridgePool.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport './interfaces/IBridgePool.sol';\n\ncontract BridgePool is IBridgePool {\n\n    address public owner;\n\n    /*\n      operator modes:\n        1 - contract:creator\n        2 - contract:withdrawer\n        4 - withdrawer\n        8 - taker\n    */\n    mapping(address => uint8) public operator;\n    mapping(bytes32 => bool) public withdrawn;\n\n    bool private entered = false;\n    modifier nonReentrant() {\n        require(!entered, 'reentrant call');\n        entered = true;\n        _;\n        entered = false;\n    }\n\n    constructor () {\n        owner = tx.origin;\n    }\n\n    function setOwner(address newOwner) external {\n        require(msg.sender == owner, 'forbidden');\n        owner = newOwner;\n    }\n\n    function setOperatorMode(address account, uint8 mode) external {\n        require(msg.sender == owner, 'forbidden');\n        operator[account] = mode;\n    }\n\n    function deposit(IERC20 token, uint amount, uint8 to, bool bonus, bytes calldata recipient) override external payable nonReentrant() {\n        // allowed only direct call or 'contract:creator' or 'contract:withdrawer'\n        require(tx.origin == msg.sender || (operator[msg.sender] & (1 | 2) > 0), 'call from unauthorized contract');\n        require(address(token) != address(0) && amount > 0 && recipient.length > 0, 'invalid input');\n\n        if (address(token) == address(1)) {\n            require(amount == msg.value, 'value must equal amount');\n        } else {\n            safeTransferFrom(token, msg.sender, address(this), amount);\n        }\n\n        emit Deposited(msg.sender, address(token), to, amount, bonus, recipient);\n    }\n\n    function withdraw(Withdraw[] calldata ws) override external nonReentrant() {\n        // allowed only 'withdrawer' or 'withdrawer' through 'contract:withdrawer'\n        require(operator[msg.sender] == 4 || (operator[tx.origin] == 4 && operator[msg.sender] == 2), 'forbidden');\n\n        for (uint i = 0; i < ws.length; i++) {\n            Withdraw memory w = ws[i];\n\n            require(!withdrawn[w.id], 'already withdrawn');\n            withdrawn[w.id] = true;\n\n            if (address(w.token) == address(1)) {\n                require(address(this).balance >= w.amount + w.bonus, 'too low token balance');\n                (bool success, ) = w.recipient.call{value: w.amount}('');\n                require(success, 'native transfer error');\n            } else {\n                require(\n                    w.token.balanceOf(address(this)) >= w.amount && address(this).balance >= w.bonus,\n                    'too low token balance'\n                );\n                safeTransfer(w.token, w.recipient, w.amount);\n            }\n\n            if (w.bonus > 0) {\n                // may fail on contracts\n                w.recipient.call{value: w.bonus}('');\n            }\n\n            if (address(w.token) != address(1) && w.feeAmounts.length > 0) {\n                for (uint j = 0; j < w.feeAmounts.length; j++) {\n                    require(w.token.balanceOf(address(this)) >= w.feeAmounts[i], 'too low token balance');\n                    safeTransfer(w.token, w.feeTargets[i], w.feeAmounts[i]);\n                }\n            }\n\n            emit Withdrawn(w.id, address(w.token), w.recipient, w.amount);\n        }\n    }\n\n    function take(IERC20 token, uint amount, address payable to) external override nonReentrant() {\n        // allowed only 'taker'\n        require(operator[msg.sender] == 8, 'forbidden');\n        if (address(token) == address(1)) {\n            to.transfer(amount);\n        } else {\n            safeTransfer(token, to, amount);\n        }\n    }\n\n    receive() external payable {}\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(token.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'transfer failed');\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'transfer failed');\n    }\n}\n"},"contracts/interfaces/IBridgePool.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBridgePool {\n    struct Withdraw {\n        bytes32 id;\n        IERC20 token;\n        uint amount;\n        uint bonus;\n        address payable recipient;\n        uint[] feeAmounts;\n        address[] feeTargets;\n    }\n\n    event Deposited(address indexed sender, address indexed token, uint8 indexed to, uint amount, bool bonus, bytes recipient);\n    event Withdrawn(bytes32 indexed id, address indexed token, address indexed recipient, uint amount);\n\n    function operator(address account) external view returns (uint8 mode);\n    function deposit(IERC20 token, uint amount, uint8 to, bool bonus, bytes calldata recipient) external payable;\n    function withdraw(Withdraw[] memory ws) external;\n    function take(IERC20 token, uint amount, address payable to) external;\n}\n"}}}