{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/DaiLendingAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.8.0;\n\nimport './IDaiToken.sol';\nimport './IYDaiToken.sol';\nimport './OwnableService.sol';\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/*\n    @brief: This contract implements the core functions that interact with YEarn Finance with DAI currency\n*/\ncontract DaiLendingAdapter is OwnableService{\n    using SafeMath for uint256;\n\n    IDaiToken dai = IDaiToken(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n\n    IYDaiToken yDai = IYDaiToken(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01);\n\n    mapping(address => uint256) userDaiDeposits;\n\n    constructor(address payable serviceContract)public OwnableService(serviceContract)\n    {\n    }\n\n    function GetPricePerFullShare() public view returns (uint256) {\n        return yDai.getPricePerFullShare();\n    }\n\n    function GetYDaiBalance(address account) public view returns (uint256) {\n        return yDai.balanceOf(account);\n    }\n\n    function GetDaiBalance(address account) public view returns (uint256) {\n        return dai.balanceOf(account);\n    }\n\n    /*\n        account: this is the owner of the Dai token\n    */\n    function save(uint256 amount, address account)\n        public\n        onlyOwnerAndServiceContract\n    {\n        //  Give allowance that a spender can spend on behalf of the owner. NOTE: This approve function has to be called from outside this smart contract because if you call\n        //  it from the smart contract, it will use the smart contract address as msg.sender which is not what we want,\n        //  we want the address with the DAI token to be the one that will be msg.sender. Hence the line below will not work and needs to be called\n        //  from Javascript or C# environment\n        //   dai.approve(address(this),amount); (Not work)\n\n        //  See example with Node.js below\n        //  await daiContract.methods.approve(\"recipient(in our case, this smart contract address)\",1000000).send({from: \"wallet address with DAI\"});\n\n        //  Transfer DAI from the account address to this smart contract address\n        dai.transferFrom(account, address(this), amount);\n\n        //  This gives the yDAI contract approval to invest our DAI\n        _save(amount, account);\n    }\n\n    //  This function returns your DAI balance + interest. NOTE: There is no function in Yearn finance that gives you the direct balance of DAI\n    //  So you have to get it in two steps\n\n    function GetGrossRevenue(address account) public view returns (uint256) {\n        //  Get the price per full share\n        uint256 price = yDai.getPricePerFullShare();\n\n        //  Get the balance of yDai in this users address\n        uint256 balanceShares = yDai.balanceOf(account);\n\n        return balanceShares.mul(price);\n    }\n\n    function GetNetRevenue(address account) public view returns (uint256) {\n        //  Get the price per full share\n        uint256 price = yDai.getPricePerFullShare();\n\n        //  Get the balance of yDai in this users address\n        uint256 balanceShares = yDai.balanceOf(account);\n\n        uint256 grossBalance = balanceShares.mul(price); //   value in 10 ^ 36\n\n        uint256 userDaiDepositBalance = userDaiDeposits[account].mul(1e18); // multiply dai deposit by 1 * 10 ^ 18 to get value in 10 ^36\n\n        return grossBalance.sub(userDaiDepositBalance);\n    }\n\n    function Withdraw(uint256 amount, address owner)\n        public\n        onlyOwnerAndServiceContract\n    {\n        //  To withdraw our DAI amount, the amount argument is in DAI but the withdraw function of the yDAI expects amount in yDAI token\n        //  So we need to find our balance in yDAI\n\n        uint256 balanceShares = yDai.balanceOf(owner);\n\n        //  transfer yDai From owner to this contract address\n        yDai.transferFrom(owner, address(this), balanceShares);\n\n        //  We now call the withdraw function to withdraw the total DAI we have. This withdrawal is sent to this smart contract\n        yDai.withdraw(balanceShares);\n\n        //  Now all the DAI we have are in the smart contract wallet, we can now transfer the specified amount to a recipient of our choice\n        dai.transfer(owner, amount);\n\n        //   remove withdrawn dai of this owner from userDaiDeposits mapping\n        if (userDaiDeposits[owner] >= amount) {\n            userDaiDeposits[owner] = userDaiDeposits[owner].sub(amount);\n        } else {\n            userDaiDeposits[owner] = 0;\n        }\n\n        //  If we have some DAI left after transferring a specified amount to a recipient, we can re-invest it in yearn finance\n        uint256 balanceDai = dai.balanceOf(address(this));\n\n        if (balanceDai > 0) {\n            //  This gives the yDAI contract approval to invest our DAI\n            _save(balanceDai, owner);\n        }\n    }\n\n    function WithdrawByShares(\n        uint256 amount,\n        address owner,\n        uint256 sharesAmount\n    ) public\n    onlyOwnerAndServiceContract\n    {\n        //  To withdraw our DAI amount, the amount argument is in DAI but the withdraw function of the yDAI expects amount in yDAI token\n\n        uint256 balanceShares = sharesAmount;\n\n        //  transfer yDai From owner to this contract address\n        yDai.transferFrom(owner, address(this), balanceShares);\n\n        //  We now call the withdraw function to withdraw the total DAI we have. This withdrawal is sent to this smart contract\n        yDai.withdraw(balanceShares);\n\n        //  Now all the DAI we have are in the smart contract wallet, we can now transfer the specified amount to a recipient of our choice\n        dai.transfer(owner, amount);\n\n        //   remove withdrawn dai of this owner from userDaiDeposits mapping\n        if (userDaiDeposits[owner] >= amount) {\n            userDaiDeposits[owner] = userDaiDeposits[owner].sub(amount);\n        } else {\n            userDaiDeposits[owner] = 0;\n        }\n\n        //  If we have some DAI left after transferring a specified amount to a recipient, we can re-invest it in yearn finance\n        uint256 balanceDai = dai.balanceOf(address(this));\n\n        if (balanceDai > 0) {\n            //  This gives the yDAI contract approval to invest our DAI\n            _save(balanceDai, owner);\n        }\n    }\n\n    /*\n        this function withdraws all the dai to this contract based on the sharesAmount passed\n    */\n    function WithdrawBySharesOnly(address owner, uint256 sharesAmount)\n        public\n        onlyOwnerAndServiceContract\n    {\n        uint256 balanceShares = sharesAmount;\n\n        //  transfer yDai From owner to this contract address\n        yDai.transferFrom(owner, address(this), balanceShares);\n\n        //  We now call the withdraw function to withdraw the total DAI we have. This withdrawal is sent to this smart contract\n        yDai.withdraw(balanceShares);\n\n        uint256 contractDaiBalance = dai.balanceOf(address(this));\n\n        //  Now all the DAI we have are in the smart contract wallet, we can now transfer the total amount to the recipient\n        dai.transfer(owner, contractDaiBalance);\n\n        //   remove withdrawn dai of this owner from userDaiDeposits mapping\n        if (userDaiDeposits[owner] >= contractDaiBalance) {\n            userDaiDeposits[owner] = userDaiDeposits[owner].sub(\n                contractDaiBalance\n            );\n        } else {\n            userDaiDeposits[owner] = 0;\n        }\n\n        //  We do not have any dai left in this contract so nothing to re-invest\n\n        // //  If we have some DAI left after transferring a specified amount to a recipient, we can re-invest it in yearn finance\n        // uint balanceDai = dai.balanceOf(address(this));\n\n        // if(balanceDai > 0){\n        //     //  This gives the yDAI contract approval to invest our DAI\n        //     _save(balanceDai,owner);\n        // }\n    }\n\n    //  This function is an internal function that enabled DAI contract where user has money to approve the yDai contract address to invest the user's DAI\n    //  and to send the yDai shares to the user's address\n    function _save(uint256 amount, address account) internal {\n        //  Approve the yDAI contract address to spend amount of DAI\n        dai.approve(address(yDai), amount);\n\n        //  Now our yDAI contract has deposited our DAI and it is earning interest and this gives us yDAI token in this Wallet contract\n        //  and we will use the yDAI token to redeem our DAI\n        yDai.deposit(amount);\n\n        //  call balanceOf and get the total balance of yDai in this contract\n        uint256 shares = yDai.balanceOf(address(this));\n\n        //  transfer the yDai shares to the user's address\n        yDai.transfer(account, shares);\n\n        //  add deposited dai to userDaiDeposits mapping\n        userDaiDeposits[account] = userDaiDeposits[account].add(amount);\n    }\n}\n"
    },
    "browser/IDaiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './IERC20.sol';\n\n/*\n    This contract returns the address of the Dai Stable Coin Smart Contract\n*/\ninterface IDaiToken is IERC20{\n     \n    function getDaiContractAddress() external view returns(address);      \n}\n\n"
    },
    "browser/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "browser/IYDaiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './IERC20.sol';\n\n/*\n    This interface returns the address of the YDai Token contract\n    Learn more about YTokens here: https://docs.yearn.finance/faq#ytokens\n    IYDaiV3: https://github.com/iearn-finance/itoken/blob/master/contracts/YDAIv3.sol\n*/\n\n\n\ninterface IYDaiToken is IERC20{\n \n      function recommend() external view returns (uint256);\n\n      function supplyDydx(uint256 amount) external returns(uint);\n    \n      function balance() external view returns (uint256);\n      function deposit(uint amount) external;\n      function withdraw(uint256 shares) external;\n      function getAave() external view returns (address);\n      function getAaveCore() external view returns (address);\n    \n      function approveToken() external;\n    \n      function balanceDydx() external view returns (uint256);\n      function balanceCompound() external view returns (uint256);\n      function balanceCompoundInToken() external view returns (uint256);\n      function balanceFulcrumInToken() external view returns (uint256);\n      function balanceFulcrum() external view returns (uint256);\n      function balanceAave() external view returns (uint256);\n    \n      function rebalance() external;\n    \n      function supplyAave(uint amount) external;\n      function supplyFulcrum(uint amount) external;\n      function supplyCompound(uint amount) external;\n    \n      // Invest ETH\n      function invest(uint256 _amount) external;\n    \n      // Invest self eth from external profits\n      function investSelf() external;\n    \n      function calcPoolValueInToken() external view returns (uint256);\n    \n      function getPricePerFullShare() external view returns (uint256);\n    \n      // Redeem any invested tokens from the pool\n      function redeem(uint256 _shares) external;\n    \n}"
    },
    "browser/OwnableService.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.8.0;\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\ncontract OwnableService {\n    address payable public owner;\n    address payable public serviceContract;\n\n    constructor(address payable _serviceContract) internal {\n        owner = msg.sender;\n        serviceContract = _serviceContract;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized access to contract\");\n        _;\n    }\n\n    modifier onlyOwnerAndServiceContract() {\n        require(\n            msg.sender == owner || msg.sender == serviceContract,\n            \"Unauthorized access to contract\"\n        );\n        _;\n    }\n\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n\n    function transferContractOwnership(address payable newServiceContract)\n        public\n        onlyOwnerAndServiceContract\n    {\n        if (newServiceContract != address(0)) {\n            serviceContract = newServiceContract;\n        }\n    }\n}\n"
    }
  }
}