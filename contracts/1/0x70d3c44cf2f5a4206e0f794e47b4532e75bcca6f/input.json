{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "RedeemableKeep3r.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\ninterface erc20 {\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function balanceOf(address) external view returns (uint);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n}\r\n\r\ninterface cl {\r\n    function latestAnswer() external view returns (int);\r\n}\r\n\r\ncontract RedeemableKeep3r {\r\n    string public constant name = \"Redeemable Keep3r v2\";\r\n    string public constant symbol = \"rKP3Rv2\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    address public gov;\r\n    address public nextGov;\r\n    uint public delayGov;\r\n\r\n    uint public fee = 90;\r\n    uint public nextFee;\r\n    uint public delayFee;\r\n\r\n    address public treasury;\r\n    address public nextTreasury;\r\n    uint public delayTreasury;\r\n\r\n    address constant KP3R = address(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\r\n    address constant ibEUR = address(0x96E61422b6A9bA0e068B6c5ADd4fFaBC6a4aae27);\r\n\r\n    cl constant _kp3reth = cl(0xe7015CCb7E5F788B8c1010FC22343473EaaC3741);\r\n    cl constant _eurusd = cl(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\r\n    cl constant _ethusd = cl(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n    function kp3reth() public view returns (uint) {\r\n        return uint(_kp3reth.latestAnswer());\r\n    }\r\n\r\n    function kp3rusd() public view returns (uint) {\r\n        return uint(_kp3reth.latestAnswer() * _ethusd.latestAnswer() / 1e18);\r\n    }\r\n\r\n    function kp3reur() public view returns (uint) {\r\n        return kp3rusd() * 1e18 / uint(_eurusd.latestAnswer());\r\n    }\r\n\r\n    uint32 constant DELAY = 1 days;\r\n    uint32 constant BASE = 100;\r\n\r\n    event Redeem(address indexed from, address indexed owner, uint amount, uint strike);\r\n\r\n    constructor(address _treasury) {\r\n        gov = msg.sender;\r\n        treasury = _treasury;\r\n    }\r\n\r\n    modifier g() {\r\n        require(msg.sender == gov);\r\n        _;\r\n    }\r\n\r\n    function setGov(address _gov) external g {\r\n        nextGov = _gov;\r\n        delayGov = block.timestamp + DELAY;\r\n    }\r\n\r\n    function acceptGov() external {\r\n        require(msg.sender == nextGov && delayGov < block.timestamp);\r\n        gov = nextGov;\r\n    }\r\n\r\n    function setFee(uint _fee) external g {\r\n        nextFee = _fee;\r\n        delayFee = block.timestamp + DELAY;\r\n    }\r\n\r\n    function commitFee() external g {\r\n        require(delayFee < block.timestamp);\r\n        fee = nextFee;\r\n    }\r\n\r\n    function setTreasury(address _treasury) external g {\r\n        nextTreasury = _treasury;\r\n        delayTreasury = block.timestamp + DELAY;\r\n    }\r\n\r\n    function commitTreasury() external g {\r\n        require(delayTreasury < block.timestamp);\r\n        treasury = nextTreasury;\r\n    }\r\n\r\n    /// @notice Total number of tokens in circulation\r\n    uint public totalSupply = 0;\r\n\r\n    mapping(address => mapping (address => uint)) public allowance;\r\n    mapping(address => uint) public balanceOf;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n    event Approval(address indexed owner, address indexed spender, uint amount);\r\n\r\n    function calc(uint amount) public view returns (uint) {\r\n        return kp3reur() * amount / 1e18 * fee / BASE;\r\n    }\r\n\r\n    function deposit(uint amount) external returns (bool) {\r\n        _safeTransferFrom(KP3R, msg.sender, address(this), amount);\r\n        _mint(msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    function claim(uint amount) external returns (bool) {\r\n        _burn(msg.sender, amount);\r\n        uint _strike = calc(amount);\r\n        _safeTransferFrom(ibEUR, msg.sender, treasury, _strike);\r\n        _safeTransfer(KP3R, msg.sender, amount);\r\n        emit Redeem(msg.sender, msg.sender, amount, _strike);\r\n        return true;\r\n    }\r\n\r\n    function _mint(address to, uint amount) internal {\r\n        // mint the amount\r\n        totalSupply += amount;\r\n        // transfer the amount to the recipient\r\n        balanceOf[to] += amount;\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint amount) internal {\r\n        // burn the amount\r\n        totalSupply -= amount;\r\n        // transfer the amount from the recipient\r\n        balanceOf[from] -= amount;\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function approve(address spender, uint amount) external returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint amount) external returns (bool) {\r\n        _transferTokens(msg.sender, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\r\n        address spender = msg.sender;\r\n        uint spenderAllowance = allowance[src][spender];\r\n\r\n        if (spender != src && spenderAllowance != type(uint).max) {\r\n            uint newAllowance = spenderAllowance - amount;\r\n            allowance[src][spender] = newAllowance;\r\n\r\n            emit Approval(src, spender, newAllowance);\r\n        }\r\n\r\n        _transferTokens(src, dst, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transferTokens(address src, address dst, uint amount) internal {\r\n        balanceOf[src] -= amount;\r\n        balanceOf[dst] += amount;\r\n\r\n        emit Transfer(src, dst, amount);\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n\r\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(erc20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n}"
    }
  }
}