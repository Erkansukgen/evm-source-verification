{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/DSA_test/comp.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface TokenInterface {\n    function allowance(address, address) external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n    function approve(address, uint) external;\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ninterface ComptrollerInterface {\n    function claimComp(address holder) external;\n    function claimComp(address holder, address[] calldata) external;\n    function claimComp(address[] calldata holders, address[] calldata cTokens, bool borrowers, bool suppliers) external;\n}\n\ninterface COMPInterface {\n    function delegate(address delegatee) external;\n    function delegates(address) external view returns(address);\n}\n\ninterface InstaMapping {\n    function cTokenMapping(address) external view returns (address);\n}\n\ninterface MemoryInterface {\n    function getUint(uint _id) external returns (uint _num);\n    function setUint(uint _id, uint _val) external;\n}\n\ninterface EventInterface {\n    function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external;\n}\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n}\n\n\ncontract Helpers is DSMath {\n    /**\n     * @dev Return ethereum address\n     */\n    function getAddressETH() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\n    }\n\n    /**\n     * @dev Return Memory Variable Address\n     */\n    function getMemoryAddr() internal pure returns (address) {\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\n    }\n\n    /**\n     * @dev Return InstaEvent Address.\n     */\n    function getEventAddr() internal pure returns (address) {\n        return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\n    }\n\n    /**\n     * @dev Get Uint value from InstaMemory Contract.\n    */\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\n    }\n\n    /**\n     * @dev Set Uint value in InstaMemory Contract.\n    */\n    function setUint(uint setId, uint val) internal {\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\n    }\n\n    /**\n     * @dev Connector Details\n    */\n    function connectorID() public pure returns(uint _type, uint _id) {\n        (_type, _id) = (1, 24);\n    }\n}\n\n\ncontract COMPHelpers is Helpers {\n    /**\n     * @dev Return Compound Comptroller Address\n     */\n    function getComptrollerAddress() internal pure returns (address) {\n        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n    }\n\n    /**\n     * @dev Return COMP Token Address.\n     */\n    function getCompTokenAddress() internal pure returns (address) {\n        return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n    }\n\n    /**\n     * @dev Return InstaDApp Mapping Addresses\n     */\n    function getMappingAddr() internal pure returns (address) {\n        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\n    }\n}\n\n\ncontract BasicResolver is COMPHelpers {\n    event LogClaimedComp(uint256 compAmt, uint256 setId);\n    event LogDelegate(address delegatee);\n\n    /**\n     * @dev Claim Accrued COMP Token.\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\n    */\n    function ClaimComp(address user, uint setId) external payable {\n        TokenInterface compToken = TokenInterface(getCompTokenAddress());\n        uint intialBal = compToken.balanceOf(user);\n        ComptrollerInterface(getComptrollerAddress()).claimComp(user);\n        uint finalBal = compToken.balanceOf(user);\n        uint amt = sub(finalBal, intialBal);\n\n        setUint(setId, amt);\n\n        emit LogClaimedComp(amt, setId);\n        // bytes32 _eventCode = keccak256(\"LogClaimedComp(uint256,uint256)\");\n        // bytes memory _eventParam = abi.encode(amt, setId);\n        // (uint _type, uint _id) = connectorID();\n        // EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\n    }\n\n    /**\n     * @dev Claim Accrued COMP Token.\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\n    */\n    function ClaimCompTwo(address user, address[] calldata tokens, uint setId) external payable {\n        uint _len = tokens.length;\n        address[] memory ctokens = new address[](_len);\n        for (uint i = 0; i < _len; i++) {\n            ctokens[i] = InstaMapping(getMappingAddr()).cTokenMapping(tokens[i]);\n        }\n\n        TokenInterface compToken = TokenInterface(getCompTokenAddress());\n        uint intialBal = compToken.balanceOf(user);\n        ComptrollerInterface(getComptrollerAddress()).claimComp(user, ctokens);\n        uint finalBal = compToken.balanceOf(user);\n        uint amt = sub(finalBal, intialBal);\n\n        setUint(setId, amt);\n\n        emit LogClaimedComp(amt, setId);\n        // bytes32 _eventCode = keccak256(\"LogClaimedComp(uint256,uint256)\");\n        // bytes memory _eventParam = abi.encode(amt, setId);\n        // (uint _type, uint _id) = connectorID();\n        // EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\n    }\n\n    /**\n     * @dev Claim Accrued COMP Token.\n     * @param setId Set ctoken amount at this ID in `InstaMemory` Contract.\n    */\n    function ClaimCompThree(address user, address[] calldata supplyTokens, address[] calldata borrowTokens, uint setId) external payable {\n        (\n            address[] memory ctokens,\n            bool isBorrow,\n            bool isSupply\n        ) = mergeCtokenArr(supplyTokens, borrowTokens);\n\n        address[] memory holders = new address[](1);\n        holders[0] = user;\n\n        TokenInterface compToken = TokenInterface(getCompTokenAddress());\n        uint intialBal = compToken.balanceOf(user);\n        ComptrollerInterface(getComptrollerAddress()).claimComp(holders, ctokens, isBorrow, isSupply);\n        uint finalBal = compToken.balanceOf(user);\n        uint amt = sub(finalBal, intialBal);\n\n        setUint(setId, amt);\n\n        emit LogClaimedComp(amt, setId);\n        // bytes32 _eventCode = keccak256(\"LogClaimedComp(uint256,uint256)\");\n        // bytes memory _eventParam = abi.encode(amt, setId);\n        // (uint _type, uint _id) = connectorID();\n        // EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\n    }\n\n    function mergeCtokenArr(address[] memory supplyTokens, address[] memory borrowTokens) internal view\n    returns (\n        address[] memory ctokens,\n        bool isBorrow,\n        bool isSupply\n    )\n    {\n         uint _supplyLen = supplyTokens.length;\n        uint _borrowLen = borrowTokens.length;\n        uint _totalLen = add(_supplyLen, _borrowLen);\n        ctokens = new address[](_totalLen);\n        isBorrow;\n        isSupply;\n        if(_supplyLen > 0) {\n            for (uint i = 0; i < _supplyLen; i++) {\n                ctokens[i] = InstaMapping(getMappingAddr()).cTokenMapping(supplyTokens[i]);\n            }\n            isSupply = true;\n        }\n\n        if(_borrowLen > 0) {\n            for (uint i = 0; i < _borrowLen; i++) {\n                ctokens[_supplyLen + i] = InstaMapping(getMappingAddr()).cTokenMapping(borrowTokens[i]);\n            }\n            isBorrow = true;\n        }\n    }\n\n    /**\n     * @dev Delegate votes.\n     * @param delegatee The address to delegate votes to.\n    */\n    function delegate(address user, address delegatee) external payable {\n        COMPInterface compToken = COMPInterface(getCompTokenAddress());\n        require(compToken.delegates(user) != delegatee, \"Already delegated to same delegatee.\");\n\n        compToken.delegate(delegatee);\n\n        emit LogDelegate(delegatee);\n        // bytes32 _eventCode = keccak256(\"LogDelegate(address)\");\n        // bytes memory _eventParam = abi.encode(delegatee);\n        // (uint _type, uint _id) = connectorID();\n        // EventInterface(getEventAddr()).emitEvent(_type, _id, _eventCode, _eventParam);\n    }\n}\n\n\ncontract ConnectCOMP is BasicResolver {\n    string public name = \"COMP-v1\";\n}"
    }
  }
}