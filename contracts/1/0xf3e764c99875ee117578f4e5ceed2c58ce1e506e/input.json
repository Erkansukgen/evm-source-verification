{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/IToken.sol":{"content":"pragma solidity ^0.6.4;\n\ncontract SafeMath {\n  function safeAdd(uint256 _a, uint256 _b) internal returns (uint256) {\n    uint256 c = _a + _b;\n    assert(c >= _a);\n    return c;\n  }\n  function safeSub(uint256 _a, uint256 _b) internal returns (uint256) {\n    assert(_a >= _b);\n    return _a - _b;\n  }\n  function safeMul(uint256 _a, uint256 _b) internal returns (uint256) {\n    uint256 c = _a * _b;\n    assert(_a == 0 || c / _a == _b);\n    return c;\n  }\n}\n\ncontract TokenERC20 is SafeMath{\n  string public name;\n  string public symbol;\n  uint8 public decimals = 18;\n  uint256 public totalSupply;\n  address public owner;\n\n  mapping (address => uint256) public balanceOf;\n  mapping (address => mapping (address => uint256)) public allowance;\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n  event Burn(address indexed _from, uint256 _value);\n\n  modifier validAddress(address _address){\n    require(_address != address(0));\n    _;\n  }\n\n  constructor (uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\n    totalSupply = initialSupply * 10 ** uint256(decimals);\n    balanceOf[msg.sender] = totalSupply;\n    name = tokenName;\n    symbol = tokenSymbol;\n    owner = msg.sender;\n  }\n\n\n  function _transfer(address _from, address _to, uint256 _value) internal  {\n\n    require(balanceOf[_from] >= _value);\n    require(balanceOf[_to] + _value > balanceOf[_to]);\n    balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);\n    balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);\n    emit Transfer(_from, _to, _value);\n\n  }\n  function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool) {\n    _transfer(msg.sender, _to, _value);\n    return true;\n  }\n  function transferFrom(address _from, address _to, uint256 _value) public\n    validAddress(_from)\n    validAddress(_to)\n    returns (bool success) {\n    allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);\n    _transfer(_from, _to, _value);\n    return true;\n  }\n  function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool success) {\n    require(_value == 0 || allowance[msg.sender][_spender] == 0);\n    allowance[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n  function burn(uint256 _value) public returns (bool success) {\n    require(_value >= 0);\n    balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);\n    totalSupply = SafeMath.safeSub(totalSupply, _value);\n    emit Burn(msg.sender, _value);\n    return true;\n  }\n\n}\n"}}}