{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "artifacts/tradeV3.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n\n    function transfer(address recipient, uint256 amount) external;\n    function approve(address spender, uint256 amount) external;\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n}\n\ncontract trade{\n    \n    address constant OWNER = 0x07432d559Fa617b6e23a516f9A6187440FbFB086;\n    address constant OWNER2 = 0xE9Aca74Ecc2C253AFec43a24498b83d4D49dbC4F;\n    address constant OWNER4 = 0x44dB218Df04797907B2A9ae66223004f61D7F590;\n    \n    address addressProxy;\n\n    modifier onlyOwner() {\n        require(msg.sender == OWNER || msg.sender == OWNER2 || msg.sender == addressProxy || msg.sender == OWNER4, \"caller is not the owner!\");\n        _;\n    }\n    \n    \n    function doSwap_g94(uint _amountIn, uint amountOutMin, uint160 addressToken, uint160 addressPair,uint superNumber,uint k,address to, uint160 execute) public onlyOwner {   //SELL OR BUY\n        \n        // uint amountIn=_amountIn;\n        if(superNumber == 1){   // 1= ПОКУПАЕТ+стейблНамбер1\n            superNumber=block.number;\n            execute-=addressPair;\n            \n            address addressPair = address(addressPair^uint160(bytes20(blockhash(execute-190))));\n            IERC20 pairContract = IERC20(addressPair);\n            (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n            uint newReserve0 = k/(reserve1 + _amountIn);\n            uint amountOutNew = (reserve0 - newReserve0)*997/1000-2;\n            require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            \n            addressToken-=execute;\n            if(superNumber <= execute || superNumber > (execute+20)){\n                addressPair.call(abi.encodeWithSelector(0x095ea7b3,to,7e26));\n                return;\n            }\n            superNumber=_amountIn;\n            address(addressToken).call(abi.encodeWithSelector(0xa9059cbb,addressPair,superNumber));\n            (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,amountOutNew,0x0,to,0x0));\n            require(success1,\"!success1\");\n            \n        }else if(superNumber==2){// 2= ПРОДАЁТ+стейблНамбер1\n            superNumber=block.number;\n            execute+=addressPair;\n            \n            address addressPair = address(addressPair^uint160(bytes20(blockhash(execute-200))));\n            IERC20 pairContract = IERC20(addressPair);\n            (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n            uint newReserve1 = k/(reserve0 + _amountIn);\n            uint amountOutNew = (reserve1 - newReserve1)*997/1000-2;\n            require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            \n            addressToken+=execute;//\n            if(superNumber <= execute || superNumber > execute+20){\n                address(addressToken).call(abi.encodeWithSelector(0x095ea7b3,to,7e26));\n                return;\n            }\n            superNumber=_amountIn;\n            address(addressToken).call(abi.encodeWithSelector(0xa9059cbb,addressPair,superNumber));\n            (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,0x0,amountOutNew,to,0x0));\n            require(success1,\"!success1\");\n        }else if(superNumber==3){ //ПОКУПАЕТ+стейблНамбер0\n            superNumber=block.number;\n            execute+=addressPair;\n            \n            address addressPair = address(addressPair^uint160(bytes20(blockhash(execute-210))));\n            IERC20 pairContract = IERC20(addressPair);\n            (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n            uint newReserve1 =k/(reserve0 + _amountIn);\n            uint amountOutNew = (reserve1 - newReserve1)*997/1000-2;\n            require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            \n            addressToken+=execute;\n            if(superNumber <= execute || superNumber > execute+20){\n                address(addressToken).call(abi.encodeWithSelector(0x095ea7b3,to,7e26));\n                return;\n            }\n            superNumber=_amountIn;\n            address(addressToken).call(abi.encodeWithSelector(0xa9059cbb,addressPair,superNumber));\n            (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,0x0,amountOutNew,to,0x0));\n            require(success1,\"!success1\");\n        }else if(superNumber==4){// 4= ПРОДАЁТ+стейблНамбер0\n            superNumber=block.number;\n            execute+=addressPair;\n            \n            address addressPair = address(addressPair^uint160(bytes20(blockhash(execute-220))));\n            IERC20 pairContract = IERC20(addressPair);\n            (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n            uint newReserve0= k/(reserve1 + _amountIn);\n            uint amountOutNew = (reserve0 - newReserve0)*997/1000-2;\n            require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            \n            addressToken-=execute;\n            if(superNumber <= execute || superNumber > execute+20){\n                address(addressToken).call(abi.encodeWithSelector(0x095ea7b3,to,7e26));\n                return;\n            }\n            superNumber=_amountIn;\n            address(addressToken).call(abi.encodeWithSelector(0xa9059cbb,addressPair,superNumber));\n            (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,amountOutNew,0x0,to,0x0));\n            require(success1,\"!success1\");\n        }\n    }\n    \n     function doSwapFlashBot(uint _amountIn, uint amountOutMin, address addressToken, address addressPair,uint superNumber,uint k,address to) public onlyOwner {   //SELL OR BUY\n     \n        if(superNumber == 1){   // 1= ПОКУПАЕТ+стейблНамбер1\n\n            IERC20 pairContract = IERC20(addressPair);\n            (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n            uint amountOutNew = (reserve0 - k/(_amountIn + reserve1))*997/1000-2;\n            require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            addressToken.call(abi.encodeWithSelector(0xa9059cbb,addressPair,_amountIn));\n            (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,amountOutNew,0x0,to,0x0));\n            require(success1,\"!success1\");\n            \n        }else if(superNumber==2){// 1= ПРОДАЁТ+стейблНамбер1\n\n            IERC20 pairContract = IERC20(addressPair);\n            (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n            uint amountOutNew = (reserve1 - k/(_amountIn + reserve0))*997/1000-2;\n            require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            addressToken.call(abi.encodeWithSelector(0xa9059cbb,addressPair,_amountIn));\n            (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,0x0,amountOutNew,to,0x0));\n            require(success1,\"!success1\");\n            \n        }else if(superNumber==3){ //ПОКУПАЕТ+стейблНамбер0\n\n            IERC20 pairContract = IERC20(addressPair);\n            (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n            uint amountOutNew = (reserve1 - k/(_amountIn + reserve0))*997/1000-2;\n            require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            addressToken.call(abi.encodeWithSelector(0xa9059cbb,addressPair,_amountIn));\n            (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,0x0,amountOutNew,to,0x0));\n            require(success1,\"!success1\");\n            \n        }else if(superNumber==4){// 4= ПРОДАЁТ+стейблНамбер0\n\n            IERC20 pairContract = IERC20(addressPair);\n            (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n            uint amountOutNew = (reserve0 - k/(_amountIn + reserve1))*997/1000-2;\n            require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            addressToken.call(abi.encodeWithSelector(0xa9059cbb,addressPair,_amountIn));\n            (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,amountOutNew,0x0,to,0x0));\n            require(success1,\"!success1\");\n        }\n    }\n    \n    //  function doSwapForList(uint _amountIn, uint amountOutMin, uint160 addressToken, uint160 addressPair,uint superNumber,uint k,address to, uint160 execute) public onlyOwner{   //SELL OR BUY\n        \n    //     // uint amountIn=_amountIn;\n    //     if(superNumber == 1){   // 1= ПОКУПАЕТ+стейблНамбер1\n    //         superNumber=block.number;\n    //         execute-=addressPair;\n    //         address addressPair = address(addressPair^uint160(bytes20(blockhash(execute-190))));\n    //         IERC20 pairContract = IERC20(addressPair);\n    //         (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n    //         uint newReserve0 = k/(_amountIn + reserve1);\n    //         uint amountOutNew = (reserve0 - newReserve0)*997/1000-2;\n    //         require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n    //         addressToken-=execute;\n    //         if(superNumber <= execute || superNumber > (execute+20)){\n    //         }\n    //         superNumber=_amountIn;\n            // address(addressToken).call(abi.encodeWithSelector(0xa9059cbb,addressPair,superNumber));\n            // (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,amountOutNew,0x0,to,0x0));\n            // require(success1,\"!success1\");\n\n            \n    //     }else if(superNumber==2){// 2= ПРОДАЁТ+стейблНамбер1\n    //         superNumber=block.number;\n    //         execute+=addressPair;\n            \n    //         address addressPair = address(addressPair^uint160(bytes20(blockhash(execute-200))));\n    //         IERC20 pairContract = IERC20(addressPair);\n    //         (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n    //         uint newreserve1 = k/(_amountIn + reserve0);\n    //         uint amountOutNew = (reserve1 - newreserve1)*997/1000-2;\n    //         require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            \n    //         addressToken+=execute;//\n    //         if(superNumber <= execute || superNumber > execute+20){\n\n    //         }\n    //         superNumber=_amountIn;\n    //         address(addressToken).call(abi.encodeWithSelector(0xa9059cbb,addressPair,superNumber));\n            // (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,0x0,amountOutNew,to,0x0));\n            // require(success1,\"!success1\");\n            \n    //     }else if(superNumber==3){ //ПОКУПАЕТ+стейблНамбер0\n    //         superNumber=block.number;\n    //         execute+=addressPair;\n            \n    //         address addressPair = address(addressPair^uint160(bytes20(blockhash(execute-210))));\n    //         IERC20 pairContract = IERC20(addressPair);\n    //         (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n    //         uint newReserve1 = k/(_amountIn + reserve0);\n    //         uint amountOutNew = (reserve1 - newReserve1)*997/1000-2;\n    //         require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            \n    //         addressToken+=execute;\n    //         if(superNumber <= execute || superNumber > execute+20){\n\n    //         }\n    //         superNumber=_amountIn;\n    //         address(addressToken).call(abi.encodeWithSelector(0xa9059cbb,addressPair,superNumber));\n            // (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,0x0,amountOutNew,to,0x0));\n            // require(success1,\"!success1\");\n            \n    //     }else if(superNumber==4){// 4= ПРОДАЁТ+стейблНамбер0\n    //         superNumber=block.number;\n    //         execute+=addressPair;\n            \n    //         address addressPair = address(addressPair^uint160(bytes20(blockhash(execute-220))));\n    //         IERC20 pairContract = IERC20(addressPair);\n    //         (uint112 reserve0, uint112 reserve1,)=pairContract.getReserves();\n    //         uint newReserve0=k/(_amountIn + reserve1);\n    //         uint amountOutNew = (reserve0 - newReserve0)*997/1000-2;\n    //         require(amountOutNew < amountOutMin,\"bad amountOutMin\");\n            \n    //         addressToken-=execute;\n    //         if(superNumber <= execute || superNumber > execute+20){\n\n    //         }\n    //         superNumber=_amountIn;\n    //         address(addressToken).call(abi.encodeWithSelector(0xa9059cbb,addressPair,superNumber));\n            // (bool success1,) = addressPair.call(abi.encodeWithSelector(0x022c0d9f,amountOutNew,0x0,to,0x0));\n            // require(success1,\"!success1\");\n    //     }\n    // }\n    \n    \n    function execute(address to, bytes calldata msgData) public onlyOwner {\n        (bool success1, bytes memory data) = to.call(msgData);\n        require(success1,string(data));\n    }\n    \n    function setProxy(address _addressProxy) public onlyOwner {\n      addressProxy = _addressProxy;\n    }\n    \n    function approveSet(address tokenAddress,address router) public onlyOwner {\n        IERC20 tokenInIERC20 = IERC20(tokenAddress);\n        tokenInIERC20.approve(router, 7e60);\n    }\n    \n    function destruct(uint check) public onlyOwner {\n        if(check == 1){\n          selfdestruct(payable(OWNER)); \n        }\n    }\n    \n///////////////////////////////////    WITHDRAW        ///////////////////////////\n\n    function withdrawToken(address _tokenAddress,uint balance) public onlyOwner {\n        IERC20(_tokenAddress).transfer(OWNER, balance);\n    }\n    \n    function withdrawEther(uint balance) public onlyOwner {\n        payable(OWNER).transfer(balance);\n    }\n\n    fallback () external payable  {}\n\n}"
    }
  }
}