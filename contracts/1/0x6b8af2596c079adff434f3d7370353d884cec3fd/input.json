{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "SquirrelStash.sol": {
      "content": "pragma solidity ^0.4.25;\r\n\r\n/**\r\n * \r\n * \"Stash\" (v0.2 beta)\r\n * A simple tool for a personal smart contract wallet to help protect your assets.\r\n * \r\n * For more info checkout: https://squirrel.finance\r\n * \r\n */\r\n\r\ncontract SquirrelStash {\r\n\r\n    mapping(address => uint256) public adminAddresses; // Can withdraw to whitelisted addresses only\r\n    address[] public admins;\r\n    \r\n    address[] public whitelist;\r\n    mapping(address => Whitelisted) public whitelistedAddress;\r\n    mapping(address => bytes32) private addressPasswords; // Hashed\r\n    mapping(uint256 => bytes32) private pendingPasswords;\r\n    \r\n    mapping(address => mapping(address => uint256)) private addressLimits;\r\n    mapping(address => mapping(address => LimitUpdate)) private pendingLimitUpdate;\r\n    \r\n    mapping(address => mapping(address => uint256)) private limitEpochEnds;\r\n    mapping(address => mapping(address => uint256)) private limitEpochSpent;\r\n    \r\n    uint8 constant public ACTION_EDIT_PASSWORD = 1;\r\n    uint8 constant public ACTION_EDIT_ADMIN = 2;\r\n    uint8 constant public ACTION_WITHDRAW_TOKEN = 3;\r\n    uint8 constant public ACTION_WITHDRAW_ETH = 4;\r\n    uint8 constant public ACTION_ADD_RECIPIENT = 5;\r\n    uint8 constant public ACTION_EDIT_DELAY = 6;\r\n    uint8 constant public ACTION_EDIT_LIMIT = 7;\r\n    uint8 constant public ACTION_ADD_PLUGIN = 8;\r\n    \r\n    uint8 constant public STATE_PENDING = 0;\r\n    uint8 constant public STATE_COMPLETED = 1;\r\n    uint8 constant public STATE_CANCELLED = 2;\r\n    \r\n    History[] public history;\r\n    uint256 public DELAY_TIMER = 3 days;\r\n    uint128 constant public STASH_VERSION = 2;\r\n    \r\n    struct Whitelisted {\r\n        uint128 index;\r\n        bool ethApproved;\r\n        bool tokenApproved;\r\n    }\r\n    \r\n    struct LimitUpdate {\r\n        uint128 etaTimestamp;\r\n        uint128 limit;\r\n    }\r\n    \r\n    struct History {\r\n        address recipient;\r\n        address token;\r\n        uint8 action;\r\n        uint8 state;\r\n        uint128 amount;\r\n        uint48 epoch;\r\n        uint48 eta;\r\n        bool ethApproved;\r\n        bool tokenApproved;\r\n    }\r\n\r\n    modifier adminOnly() {\r\n        require(adminAddresses[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    constructor(address squirrel) public {\r\n        admins.push(squirrel);\r\n        adminAddresses[squirrel] = 1;\r\n    }\r\n    \r\n    function() external payable { /** Accepts eth **/ }\r\n    \r\n    \r\n    function whitelistAddress(address candidate, bool tokenApproved, bool ethApproved) external adminOnly {\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        history.push(History(candidate, msg.sender, ACTION_ADD_RECIPIENT, STATE_PENDING, 0, uint48(now), eta, tokenApproved, ethApproved));\r\n    }\r\n\r\n\r\n    function triggerWhiteListApproval(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_ADD_RECIPIENT);\r\n        require(pending.state == STATE_PENDING);\r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            if (pending.eta > 0 && pending.eta < now) {\r\n                updateCandidate(pending);\r\n                pending.state = STATE_COMPLETED;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function updateCandidate(History action) internal {\r\n        address candidate = action.recipient;\r\n        uint128 index = whitelistedAddress[candidate].index;\r\n        bool approving = (action.ethApproved || action.tokenApproved);\r\n        if (index == 0 && approving) {\r\n            whitelist.push(candidate); // Add new recipient\r\n            whitelistedAddress[candidate] = Whitelisted(uint128(whitelist.length), action.ethApproved, action.tokenApproved);\r\n        } else if (index > 0) {\r\n            if (approving) {\r\n                Whitelisted memory data = whitelistedAddress[candidate];\r\n                data.ethApproved = action.ethApproved;\r\n                data.tokenApproved = action.tokenApproved;\r\n                whitelistedAddress[candidate] = data;\r\n            } else { // Removing from whitelist\r\n                uint256 numWhitelisted = whitelist.length;\r\n                delete whitelistedAddress[candidate];\r\n                if (numWhitelisted > 1) {\r\n                    whitelist[index - 1] = whitelist[numWhitelisted - 1];\r\n                }\r\n                delete whitelist[numWhitelisted - 1];\r\n                whitelist.length--;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function editPassword(address candidate, bytes32 hash) external adminOnly {\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        pendingPasswords[history.length] = hash;\r\n        history.push(History(candidate, msg.sender, ACTION_EDIT_PASSWORD, STATE_PENDING, 0, uint48(now), eta, hash != 0, false));\r\n    }\r\n    \r\n    function triggerPasswordUpdate(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_EDIT_PASSWORD);\r\n        require(pending.state == STATE_PENDING);\r\n        \r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            require(pending.eta > 0 && pending.eta < now);\r\n            bytes32 newPassword = pendingPasswords[index];\r\n            if (newPassword == keccak256(\"\")) {\r\n                delete addressPasswords[pending.recipient];\r\n            } else {\r\n                addressPasswords[pending.recipient] = newPassword;\r\n            }\r\n            delete pendingPasswords[index];\r\n            pending.state = STATE_COMPLETED;\r\n        }\r\n    }\r\n    \r\n\r\n    function editAdmin(address candidate, bool isAdmin) external adminOnly {\r\n        require(candidate != msg.sender); // Don't edit yourself\r\n        \r\n        if (isAdmin && adminAddresses[candidate] == 0) {\r\n            admins.push(candidate); // Add new admin\r\n            adminAddresses[candidate] = admins.length;\r\n            history.push(History(candidate, msg.sender, ACTION_EDIT_ADMIN, STATE_COMPLETED, 0, uint48(now), 0, isAdmin, false));\r\n        } else if (!isAdmin && adminAddresses[candidate] > 0) {\r\n            uint48 eta = uint48(now + DELAY_TIMER); // Removing admin\r\n            history.push(History(candidate, msg.sender, ACTION_EDIT_ADMIN, STATE_PENDING, 0, uint48(now), eta, false, false));\r\n        }\r\n    }\r\n    \r\n    function triggerAdminRemoval(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_EDIT_ADMIN);\r\n        require(pending.state == STATE_PENDING);\r\n        \r\n         if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            require(pending.recipient != msg.sender); // Don't remove yourself\r\n            require(pending.eta > 0 && pending.eta < now);\r\n            uint256 numAdmins = admins.length;\r\n            uint256 adminIndex = adminAddresses[pending.recipient] - 1;\r\n            delete adminAddresses[pending.recipient]; // Remove old admin\r\n            if (numAdmins > 1) {\r\n                admins[adminIndex] = admins[numAdmins - 1];\r\n            }\r\n            delete admins[numAdmins - 1];\r\n            admins.length--;\r\n            pending.state = STATE_COMPLETED;\r\n        }\r\n    }\r\n    \r\n    \r\n    function editWithdrawLimit(address candidate, address token, uint128 limit) external adminOnly {\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        pendingLimitUpdate[candidate][token] = LimitUpdate(eta, limit);\r\n        history.push(History(candidate, token, ACTION_EDIT_LIMIT, STATE_PENDING, limit, uint48(now), eta, false, false));\r\n    }\r\n    \r\n    function triggerLimitUpdate(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_EDIT_LIMIT);\r\n        require(pending.state == STATE_PENDING);\r\n        \r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            require(pending.eta > 0 && pending.eta < now);\r\n            if (pending.amount > 0) {\r\n                addressLimits[pending.recipient][pending.token] = pending.amount;\r\n            } else {\r\n                delete addressLimits[pending.recipient][pending.token];\r\n            }\r\n            pending.state = STATE_COMPLETED;\r\n        }\r\n    }\r\n    \r\n    \r\n    function editDelay(uint128 newDelay) external adminOnly {\r\n        require(newDelay >= 24 hours && newDelay <= 30 days);\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        history.push(History(0, msg.sender, ACTION_EDIT_DELAY, STATE_PENDING, newDelay, uint48(now), eta, false, false));\r\n    }\r\n    \r\n    function triggerDelayUpdate(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_EDIT_DELAY);\r\n        require(pending.state == STATE_PENDING);\r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            require(pending.eta > 0 && pending.eta < now);\r\n            DELAY_TIMER = pending.amount;\r\n            pending.state = STATE_COMPLETED;\r\n        }\r\n    }\r\n\r\n\r\n    function withdrawToken(address recipient, address token, uint256 amount) external adminOnly {\r\n        withdrawTokenInternal(recipient, token, amount);\r\n    }\r\n    \r\n    function withdrawToken(address recipient, address token, uint256 amount, string password) external {\r\n        validatePassword(recipient, password);\r\n        withdrawTokenInternal(recipient, token, amount);\r\n    }\r\n    \r\n    function withdrawTokenInternal(address recipient, address token, uint256 amount) internal {\r\n        require(whitelistedAddress[recipient].tokenApproved);\r\n        validateLimits(recipient, token, amount);\r\n        history.push(History(recipient, token, ACTION_WITHDRAW_TOKEN, STATE_COMPLETED, uint128(amount), uint48(now), 0, false, false));\r\n        ERC20(token).transfer(recipient, amount);\r\n    }\r\n    \r\n    function withdrawEth(address recipient, uint256 amount) external adminOnly {\r\n        withdrawEthInternal(recipient, amount);\r\n    }\r\n    \r\n    function withdrawEth(address recipient, uint256 amount, string password) external {\r\n        validatePassword(recipient, password);\r\n        withdrawEthInternal(recipient, amount);\r\n    }\r\n    \r\n    function withdrawEthInternal(address recipient, uint256 amount) internal {\r\n        require(whitelistedAddress[recipient].ethApproved);\r\n        validateLimits(recipient, 0, amount);\r\n        history.push(History(recipient, 0, ACTION_WITHDRAW_ETH, STATE_COMPLETED, uint128(amount), uint48(now), 0, false, false));\r\n        recipient.transfer(amount);\r\n    }\r\n    \r\n    \r\n    function validatePassword(address recipient, string password) view internal {\r\n        bytes32 key = addressPasswords[recipient];\r\n        require(key != 0);\r\n        require(keccak256(password) == key);\r\n    }\r\n    \r\n    function validateLimits(address recipient, address token, uint256 amount) internal {\r\n        require(uint256(amount) == uint128(amount));\r\n        uint256 limit = addressLimits[recipient][token];\r\n        if (limit > 0) {\r\n            if (limitEpochEnds[recipient][token] < now) {\r\n                require(amount <= limit);\r\n                limitEpochEnds[recipient][token] = now + 24 hours; // Daily withdrawal limit\r\n                limitEpochSpent[recipient][token] = amount;\r\n            } else {\r\n                uint256 totalToday = amount + limitEpochSpent[recipient][token];\r\n                require(totalToday <= limit);\r\n                limitEpochSpent[recipient][token] = totalToday;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function hashed(address recipient) external view returns (bool) {\r\n        return addressPasswords[recipient] != 0;\r\n    }\r\n    \r\n    function adminsLength() public view returns (uint256) {\r\n        return admins.length;\r\n    }\r\n    \r\n    function whitelistLength() public view returns (uint256) {\r\n        return whitelist.length;\r\n    }\r\n    \r\n    function historyLength() public view returns (uint256) {\r\n        return history.length;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * v0.2 DeFi Plugin stuff\r\n     */\r\n    \r\n    mapping(address => bool) public whiteListedPlugins;\r\n    PluginList constant plugins = PluginList(0x2459D608A7B7Eb695C78D4a40137bDeaD85D91c2);\r\n    \r\n    function whitelistPlugin(address candidateFactory) external adminOnly {\r\n        require(plugins.isValid(candidateFactory));\r\n        PluginFactory factory = PluginFactory(candidateFactory);\r\n        address plugin = factory.createPlugin();\r\n        uint48 eta = uint48(now + DELAY_TIMER);\r\n        history.push(History(plugin, msg.sender, ACTION_ADD_PLUGIN, STATE_PENDING, 0, uint48(now), eta, false, false));\r\n    }\r\n    \r\n    function triggerPluginApproval(uint256 index, bool cancel) external adminOnly {\r\n        History storage pending = history[index];\r\n        require(pending.action == ACTION_ADD_PLUGIN);\r\n        require(pending.state == STATE_PENDING);\r\n        if (cancel) {\r\n            pending.state = STATE_CANCELLED;\r\n        } else {\r\n            if (pending.eta > 0 && pending.eta < now) {\r\n                whiteListedPlugins[pending.recipient] = true;\r\n                pending.state = STATE_COMPLETED;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function pluginEth(uint256 amount) external {\r\n        require(whiteListedPlugins[msg.sender]);\r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    function pluginToken(address token, uint256 amount) external {\r\n        require(whiteListedPlugins[msg.sender]);\r\n        require(ERC20(token).transfer(msg.sender, amount));\r\n    }\r\n    \r\n    \r\n    \r\n}\r\n\r\n\r\ncontract PluginList {\r\n    function isValid(address candidate) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\ncontract PluginFactory {\r\n    function createPlugin() external returns(address);\r\n}\r\n\r\ncontract ERC20 {\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    \r\n    string public symbol;\r\n    uint8 public decimals;\r\n}"
    }
  }
}