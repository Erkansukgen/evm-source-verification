{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"EthBridge.sol":{"content":"pragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\n\n \ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    \n}\n\ncontract EthBnbBridge {\n    address public phnxAddress;\n    address public signer;\n\n    uint256 public nonce;\n    mapping(bytes32 => bool) public sigRepeated;\n\n    //keccak(\"ETH_BRIDGE_HASH_ONE\")\n    bytes32 public constant HASH_ONE = 0x63c7f5cdb1d38bbec4fca06b08adbb3c338e225bf61b79696076f193b0a70f07;\n    //keccak(\"ETH_BRIDGE_HASH_TWO\")\n    bytes32 public constant HASH_TWO = 0xc17d317ce8d3846b73214929c7cc4a2a2679e1c043b10e5612748890112fb726;\n    //keccak(\"ETH_BRIDGE_HASH_THREE\")\n    bytes32 public constant HASH_THREE = 0x521953684645f878093bce1437e3c6d4d19a8a16cb0cb7379b2da2e14f5bb7cb;\n\n    event TokenDeposited(address user, uint256 amount, uint256 nonce);\n    event TokenWithdrawn(address user, uint256 amount, uint256 nonce);\n\n    constructor(address _phnxAddress, address _signer) {\n        require(_phnxAddress!=address(0) && _signer!=address(0),\"EthBnbBridge: Signer and Token cannot be zero Address\");\n        phnxAddress = _phnxAddress;\n        signer = _signer;\n    }\n\n    function changeSigner(address _signer) external{\n        require(signer==msg.sender,\"Changing Signer Forbidden\");\n        signer = _signer;\n    }\n\n    function depositToken(uint256 amount) external {\n        require(amount!=0,\"EthBnbBridge: Amount Cannot be Zero\");\n        address sender = msg.sender;\n        IERC20(phnxAddress).transferFrom(sender, address(this), amount);\n        emit TokenDeposited(sender, amount, nonce++);\n    }\n\n    function withdrawToken(\n        address sender,\n        uint256 amount,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(sender == msg.sender, \"Invalid sender\");\n        require(amount!=0,\"EthBnbBridge: Amount Cannot be Zero\");\n        bytes32 encodeData = keccak256(abi.encode(amount, sender, nonce));\n        require(!sigRepeated[encodeData], \"Alredy claimed\");\n        sigRepeated[encodeData] = true;\n        _validateSignedData(encodeData, v, r, s);\n        IERC20(phnxAddress).transfer(sender, amount);\n        emit TokenWithdrawn(sender, amount, nonce);\n    }\n\n    function getDomainSeparator() internal view returns (bytes32) {\n        return keccak256(abi.encode(HASH_ONE, HASH_TWO, HASH_THREE, \"0x01\", address(this)));\n    }\n\n    function _validateSignedData(\n        bytes32 encodeData,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view {\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeparator(), encodeData));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"Invlid Signature\");\n    }\n\n    function withdrawTokens() external {\n        require(msg.sender == signer);\n        IERC20(phnxAddress).transfer(signer,IERC20(phnxAddress).balanceOf(address(this)));\n    }\n}\n"}}}