{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ss.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  function mul(uint a, uint b) internal pure returns (uint c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal pure returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  function sub(uint a, uint b) internal pure returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal pure returns (uint c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function burn(uint256 amount) external;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\npragma solidity >=0.6.0 <0.8.0;\n\ncontract Staking {\n\n  using SafeMath for uint;\n\n  IERC20 public stakingToken;                       //staking Token\n  uint public rewardAmount;                         //Amount that is paid for staking 1 second\n  uint public oneUnit;                              //Amount that is calculated as unit\n  uint public stakeFee;                             //fee in 0.01%\n  uint public unstakeFee;                           //fee in 0.01%\n  uint internal amountForRewards;                   //Amount deposited for rewards\n  uint internal amountClaimed;                      //Amount claimed for rewards\n  uint internal amountFees;                         //Amount of fees collected\n  uint internal amountBurned;                       //Amount of fees burned\n  mapping (address => uint) internal stakedAmounts;\n  mapping (address => uint) internal lastClaims;\n  mapping (address => uint) internal claimableAmounts;\n  mapping (address => uint) internal claimedAmounts;\n  mapping (address => uint) internal admins;\n\n  event Stake(\n    address indexed owner,\n    uint amount,\n    uint fee\n  );\n\n  event Unstake(\n    address indexed owner,\n    uint amount,\n    uint fee\n  );\n\n  event Claimed(\n    address indexed owner,\n    uint amount\n  );\n\n  event Compound(\n    address indexed owner,\n    uint amount,\n    uint fee\n  );\n\n  constructor(\n    address __stakingToken,\n    uint __rewardAmount,\n    uint __oneUnit,\n    uint __stakeFee,\n    uint __unstakeFee\n  ) {\n    require(Address.isContract(__stakingToken), \"Error: Address should be a contract\");\n    stakingToken = IERC20(__stakingToken);\n\n    rewardAmount = __rewardAmount;\n    oneUnit = __oneUnit;\n    stakeFee = __stakeFee;\n    unstakeFee = __unstakeFee;\n    amountForRewards = 0;\n    amountClaimed = 0;\n    amountFees = 0;\n    amountBurned = 0;\n\n    admins[msg.sender] = block.timestamp;\n  }\n\n  function isAdmin(address __address) view public returns(bool) {\n    if (admins[__address] > 0) {\n        return (true);\n    }\n    return (false);\n  }\n\n  function addAdmin(address __address) external onlyAdmin {\n    require(__address != address(0), \"Error: new admin is the zero address\");\n    admins[__address] = block.timestamp;\n  }\n\n  function fund(uint __amount) external onlyAdmin {\n    require(__amount > 0, \"You are trying to fund with 0 assets\");\n\n    stakingToken.transferFrom(msg.sender, address(this), __amount);\n    amountForRewards = amountForRewards.add(__amount);\n  }\n\n  function burn() external onlyAdmin {\n      require(amountFees.sub(amountBurned) > 0, \"Error: you are trying to burn all tokens\");\n      stakingToken.burn(amountFees.sub(amountBurned));\n      amountBurned = amountFees;\n  }\n\n  function balance() view public returns(uint, uint, int, uint, uint) {\n    return (amountForRewards, amountClaimed, int(amountForRewards - amountClaimed), amountFees, amountBurned);\n  }\n\n  function deleteAdmin(address __address) external onlyAdmin {\n    admins[__address] = 0;\n  }\n\n  modifier onlyAdmin() {\n    require(admins[msg.sender] > 0, \"Error: caller is not the admin\");\n    _;\n  }\n\n  function isStaker(address __address) view public returns(bool, uint, uint, uint, uint) {\n    if (stakedAmounts[__address] == 0) {\n      return (false, 0, 0, 0, 0);\n    }\n    uint __claimableAmount = claimableAmounts[__address].add(stakedAmounts[__address].div(oneUnit).mul(block.timestamp.sub(lastClaims[__address])).mul(rewardAmount));\n    return (true, stakedAmounts[__address], lastClaims[__address], __claimableAmount, claimedAmounts[__address]);\n  }\n\n  function update(address __address, uint __stakedAmount, uint __lastClaim, uint __claimableAmount, uint __claimedAmount) private {\n    if (stakedAmounts[__address] != __stakedAmount) {\n      stakedAmounts[__address] = __stakedAmount;\n    }\n    if (lastClaims[__address] != __lastClaim) {\n      lastClaims[__address] = __lastClaim;\n    }\n    if (claimableAmounts[__address] != __claimableAmount) {\n      claimableAmounts[__address] = __claimableAmount;\n    }\n    if (__claimedAmount > 0 && claimedAmounts[__address] != __claimedAmount) {\n      claimedAmounts[__address] = __claimedAmount;\n    }\n  }\n\n  function claim() external {\n    (bool __isStaker, uint __stakedAmount, , uint __claimableAmount, uint __claimedAmount) = isStaker(msg.sender);\n    require(__isStaker == true, \"Error: you are not staking\");\n\n    update(msg.sender, __stakedAmount, block.timestamp, 0, __claimedAmount.add(__claimableAmount));\n    amountClaimed = amountClaimed.add(__claimableAmount);\n\n    stakingToken.transfer(msg.sender, __claimableAmount);\n    emit Claimed(msg.sender, __claimableAmount);\n  }\n\n  function compound() external {\n    (bool __isStaker, uint __stakedAmount, , uint __claimableAmount, uint __claimedAmount) = isStaker(msg.sender);\n    require(__isStaker == true, \"Error: you are not staking\");\n\n    uint __fee = __claimableAmount.mul(stakeFee).div(10000);\n    uint __stakeAmount = __claimableAmount.sub(__fee);\n\n    update(msg.sender, __stakedAmount.add(__stakeAmount), block.timestamp, 0, __claimedAmount.add(__claimableAmount));\n\n    amountClaimed = amountClaimed.add(__claimableAmount);\n    amountFees = amountFees.add(__fee);\n\n    emit Compound(msg.sender, __stakeAmount, __fee);\n  }\n\n  function stake(uint __amount) external {\n    require(__amount > 0, \"Error: you are trying to stake 0 tokens\");\n    stakingToken.transferFrom(msg.sender, address(this), __amount);\n\n    (bool __isStaker, uint __stakedAmount, , uint __claimableAmount, ) = isStaker(msg.sender);\n    uint __fee = __amount.mul(stakeFee).div(10000);\n    uint __stakeAmount = __amount.sub(__fee);\n\n    if (__isStaker) {\n      update(msg.sender, __stakedAmount.add(__stakeAmount), block.timestamp, __claimableAmount, 0);\n    } else {\n      update(msg.sender, __stakeAmount, block.timestamp, 0, 0);\n    }\n\n    amountFees = amountFees.add(__fee);\n    emit Stake(msg.sender, __stakeAmount, __fee);\n  }\n\n  function unstake() external {\n    (bool __isStaker, uint __stakedAmount, , uint __claimableAmount, uint __claimedAmount) = isStaker(msg.sender);\n    require(__isStaker == true, \"Error: you are not staking\");\n\n    uint __fee = __stakedAmount.mul(unstakeFee).div(10000);\n    uint __unstakeAmount = __stakedAmount.sub(__fee).add(__claimableAmount);\n\n    update(msg.sender, 0, block.timestamp, 0, __claimedAmount.add(__claimableAmount));\n\n    amountClaimed = amountClaimed.sub(__claimableAmount);\n    amountFees = amountFees.add(__fee);\n\n    stakingToken.transfer(msg.sender, __unstakeAmount);\n    emit Unstake(msg.sender, __unstakeAmount, __fee);\n  }\n\n  function transferStake(address __to, uint __amount) external {\n    (bool __isStaker, uint __stakedAmount, , uint __claimableAmount, ) = isStaker(msg.sender);\n    require(__isStaker == true, \"Error: you are not staking\");\n    require(__to != address(0), \"Error: new owner is the zero address\");\n    require(__stakedAmount > __amount, \"Error: you are trying to transfer more then you have\");\n    if (__amount == 0) {\n        __amount = __stakedAmount;\n    }\n\n    update(msg.sender, __stakedAmount.add(__amount), block.timestamp, __claimableAmount, 0);\n\n    (__isStaker, __stakedAmount, , __claimableAmount, ) = isStaker(__to);\n    update(__to, __stakedAmount.add(__amount), block.timestamp, __claimableAmount, 0);\n  }\n\n}\n"}}}