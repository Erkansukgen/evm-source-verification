{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NFT-Cashier/Cashier.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\nimport './libraries/SafeMath.sol';\r\nimport './libraries/TransferHelper.sol';\r\nimport './interfaces/ICharacterNFT.sol';\r\n\r\ncontract Cashier {\r\n  using SafeMath for uint;\r\n\r\n  struct PurchaseResult {\r\n    address player;\r\n    uint[]  token_ids;\r\n  }\r\n\r\n  // core\r\n  address public owner;\r\n  address public company;\r\n  address public nft;\r\n\r\n  // cashier profile\r\n  uint    public max_of_open;\r\n  uint    public max_purchase_per_address;\r\n  uint    public remaining_character;\r\n  uint    public total_character;\r\n  uint    public price_per_nft;\r\n  uint    public seed;\r\n\r\n  // action control\r\n  bool    public paused_purchase;\r\n\r\n  // (request id => result info) purchase history\r\n  mapping(bytes32 => PurchaseResult) purchase_result;\r\n  \r\n  // allow to manage character\r\n  mapping(address => bool) public access_permission;\r\n\r\n  // track address purchased amount\r\n  mapping(address => uint) public total_purchased;\r\n  \r\n  modifier hasAccessPermission() {\r\n    require(access_permission[msg.sender], \"no access permission\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"not owner\");\r\n    _;\r\n  }\r\n  \r\n  modifier checkValidPurchase(uint num_of_open) {\r\n    require(!paused_purchase, \"purchase paused\");\r\n    require(num_of_open > 0, \"empty open\");\r\n    require(num_of_open <= max_of_open, \"invalid number of open\");\r\n    require(remaining_character >= num_of_open, \"character out of supply\");\r\n    _;\r\n  }\r\n\r\n  event AddCharacter(uint amount);\r\n  event ReduceCharacter(uint amount);\r\n  event TransferOwner(address new_owner);\r\n  event UpdateMaxOfOpen(uint max_of_open);\r\n  event UpdatePricePerNft(uint price_per_nft);\r\n  event UpdateTotalCharacter(uint amount, uint current_total);\r\n  event UpdateCompany(address company);\r\n  event UpdateNFT(address nft);\r\n  event UpdateAccessPermission(address _address, bool status);\r\n  event UpdatePausePurchase(bool status);\r\n  event UpdatePaymentToken(address payment_token);\r\n  event UpdateMaxPurchasePerAddress(uint max_purchase_per_address);\r\n\r\n  event Purchase(\r\n      address buyer,\r\n      bytes32 request_id,\r\n      uint[] token_ids,\r\n      uint num_of_open,\r\n      uint price_per_nft,\r\n      uint total_payment\r\n  );\r\n\r\n  constructor(\r\n    address _company,\r\n    address _nft\r\n  ) public {\r\n    company       = _company;\r\n    nft           = _nft;\r\n    owner         = msg.sender;\r\n    max_of_open   = 10;\r\n\r\n    // max purchase per address\r\n    max_purchase_per_address = 10;\r\n    \r\n    // initial price : 0.08 ETH per nft\r\n    price_per_nft = 80000000000000000;\r\n\r\n    // allow permissions\r\n    access_permission[msg.sender] = true;\r\n    access_permission[address(this)] = true;\r\n\r\n    // initial supply\r\n    addCharacter(20);\r\n  }\r\n  \r\n  /*\r\n  * user purchase nft\r\n  * @param num_of_open - unit is ETHER\r\n  */\r\n  function purchase(uint num_of_open) public payable checkValidPurchase(num_of_open) {\r\n    uint total_payment = price_per_nft * num_of_open;\r\n    uint purchase_num  = total_purchased[msg.sender].add(num_of_open);\r\n\r\n    require(msg.value == total_payment, \"invalid payment\");\r\n    require(purchase_num <= max_purchase_per_address, \"purchase limit reached\");\r\n\r\n    TransferHelper.safeTransferETH(company, msg.value);\r\n    \r\n    // open the chest(s)\r\n    _purchase(num_of_open, total_payment);\r\n\r\n    total_purchased[msg.sender] = total_purchased[msg.sender].add(num_of_open);\r\n  }\r\n\r\n  /*\r\n  * retrieve the supply information\r\n  */\r\n  function getSupplyInfo() public view returns(uint total, uint remain, uint price_nft, uint max_purchase) {\r\n    total        = total_character;\r\n    remain       = remaining_character;\r\n    price_nft    = price_per_nft;\r\n    max_purchase = max_purchase_per_address;\r\n  }\r\n\r\n  /*\r\n  * retrieve purchase record by request ID\r\n  */\r\n  function getPurchaseRecord(bytes32 request_id) public view returns (\r\n      address player,\r\n      uint[] memory token_list\r\n  ) {\r\n    player         = purchase_result[request_id].player;\r\n    token_list     = purchase_result[request_id].token_ids;\r\n  }\r\n\r\n  /*\r\n  * add character availability\r\n  * @param amount - amount to be add (unit is ETHER)\r\n  */\r\n  function addCharacter(uint amount) public hasAccessPermission {\r\n    remaining_character = remaining_character.add(amount);\r\n    total_character     = total_character.add(amount);\r\n    emit AddCharacter(amount);\r\n  }\r\n\r\n  /*\r\n  * reduce character availability\r\n  * @param amount - amount to be add (unit is ETHER)\r\n  */\r\n  function reduceCharacter(uint amount) public hasAccessPermission {\r\n    remaining_character = remaining_character.sub(amount);\r\n    total_character     = total_character.sub(amount);\r\n    emit ReduceCharacter(amount);\r\n  }\r\n\r\n  /*\r\n  * transfer ownership\r\n  */\r\n  function transferOwner(address new_owner) public onlyOwner {\r\n    owner = new_owner;\r\n    emit TransferOwner(owner);\r\n  }\r\n  \r\n  /*\r\n  * current network ID\r\n  */\r\n  function getChainID() public view returns (uint256) {\r\n    uint256 id;\r\n    assembly {\r\n        id := chainid()\r\n    }\r\n    return id;\r\n  }\r\n  \r\n  /*\r\n  * update the maximum open chest number\r\n  */\r\n  function updateMaxOfOpen(uint amount) public onlyOwner {\r\n    max_of_open = amount;\r\n    emit UpdateMaxOfOpen(max_of_open);\r\n  }\r\n\r\n  /*\r\n  * update the maximum purchase per address\r\n  */\r\n  function updateMaxPurchasePerAddress(uint amount) public onlyOwner {\r\n    max_purchase_per_address = amount;\r\n    emit UpdateMaxPurchasePerAddress(max_purchase_per_address);\r\n  }\r\n\r\n  /*\r\n  * update the price per chest\r\n  */\r\n  function updatePricePerChest(uint _price_per_nft) public onlyOwner {\r\n    price_per_nft = _price_per_nft;\r\n    emit UpdatePricePerNft(_price_per_nft);\r\n  }\r\n\r\n  /*\r\n  * update the total character amount\r\n  */\r\n  function updateTotalCharacter(uint _amount) public onlyOwner {\r\n    total_character = _amount;\r\n    emit UpdateTotalCharacter(_amount, total_character);\r\n  }\r\n  \r\n  /*\r\n  * update the pause purchase status\r\n  */\r\n  function updatePausePurchase(bool status) public onlyOwner {\r\n    paused_purchase = status;\r\n    emit UpdatePausePurchase(paused_purchase);\r\n  }\r\n  \r\n  /*\r\n  * update company address for payment receive\r\n  */\r\n  function updateCompany(address _company) public onlyOwner {\r\n    company = _company;\r\n    emit UpdateCompany(company);\r\n  }\r\n  \r\n  /*\r\n  * update company address for payment receive\r\n  */\r\n  function updateNFT(address _nft) public onlyOwner {\r\n    nft = _nft;\r\n    emit UpdateNFT(nft);\r\n  }\r\n  \r\n  /*\r\n  * update access permission\r\n  */\r\n  function updateAccessPermission(address _address, bool status) public onlyOwner {\r\n    access_permission[_address] = status;\r\n    emit UpdateAccessPermission(_address, status);\r\n  }\r\n\r\n  /*\r\n  * emergency transfer ether to owner\r\n  */\r\n  function emergencyTransferEther(uint amount) public onlyOwner {\r\n    TransferHelper.safeTransferETH(owner, amount);\r\n  }\r\n\r\n  /*\r\n  * emergency transfer any token to owner\r\n  */\r\n  function emergencyTransferToken(address token, uint amount) public onlyOwner {\r\n    TransferHelper.safeTransfer(token, owner, amount);\r\n  }\r\n  \r\n  function _purchase(uint num_of_open, uint total_payment) internal {\r\n    bytes32 request_id   = bytes32(keccak256(abi.encode(msg.sender, block.number, seed, \"REQ\")));\r\n    uint[] memory tokens = new uint[](num_of_open);\r\n    \r\n    purchase_result[request_id].player = msg.sender;\r\n    for (uint i = 0; i < num_of_open; i++) {\r\n      tokens[i] = _mintingNFT(request_id);\r\n    }\r\n    \r\n    remaining_character = remaining_character.sub(num_of_open);\r\n\r\n    emit Purchase(msg.sender, request_id, tokens, num_of_open, price_per_nft, total_payment);\r\n  }\r\n  \r\n  function _mintingNFT(bytes32 request_id) internal returns (uint) {\r\n    uint randomness = uint(keccak256(abi.encode(msg.sender, block.number, seed, \"RNG\")));\r\n    uint token_id   = ICharacterNFT(nft).mint(msg.sender);\r\n    \r\n    seed = randomness;\r\n    purchase_result[request_id].token_ids.push(token_id);\r\n\r\n    return token_id;\r\n  }\r\n}\r\n"},"NFT-Cashier/interfaces/ICharacterNFT.sol":{"content":"pragma solidity >=0.6.12;\n\ninterface ICharacterNFT {\n    function mint(address to) external returns (uint);\n}"},"NFT-Cashier/libraries/SafeMath.sol":{"content":"pragma solidity ^0.6.12;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, 'SafeMath:INVALID_ADD');\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a, 'SafeMath:OVERFLOW_SUB');\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b, uint decimal) internal pure returns (uint) {\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"SafeMath: multiple overflow\");\r\n        uint c1 = c0 + (dc / 2);\r\n        require(c1 >= c0, \"SafeMath: multiple overflow\");\r\n        uint c2 = c1 / dc;\r\n        return c2;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, uint decimal) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * dc;\r\n        require(a == 0 || c0 / a == dc, \"SafeMath: division internal\");\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"SafeMath: division internal\");\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n}\r\n"},"NFT-Cashier/libraries/TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity >=0.6.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeApprove: approve failed'\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeTransfer: transfer failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::transferFrom: transferFrom failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n}\r\n"}}}