{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/Aladdin.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Owner {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(msg.sender);\n    }\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier OnlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual OnlyOwner {\n        _setOwner(address(0));\n    }\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual OnlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract Aladdin is IERC20,Owner{\n    using SafeMath for uint256;\n\n    uint256 private _totalSupply;\n    string  private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    //fee,dived by 10000\n    uint16 private _stakeFee=10;\n    uint16 private _taxFee=300;\n    uint16 private _burnFee=200;\n    uint16 private _previousTaxFee=_taxFee;\n    uint16 private _previousLiquidFee=_burnFee;\n    \n\n    mapping(address=>uint256) private _balances;\n    \n    mapping(address=>uint256) private _stakes;\n    \n    mapping(address=>bool) private _exludeBalances;\n    \n    mapping(address=>mapping(address=>uint256)) private _allowances;\n    //weight\n    uint256 private _liquidWeight;\n    uint256 private _liquidLastChangeTime;\n    uint256 private _totalLiquid;\n    uint256 private _totalStake;\n    //Weight for users\n    mapping(address=>uint256) _userWeight;\n    //The timestamp of last changed for user's.\n    mapping(address=>uint256) _lastChangeTime;\n    \n    \n    uint256 _totalStakeWeight;\n    \n    //Weight for users' stake.\n    mapping(address=>uint256) _userStakeWeight;\n    \n    //The timestamp of last changed for user's stake.\n    mapping(address=>uint256) _stakeLastChangeTime;\n    \n    uint256 private _totalStakeLastChangeTime;\n    \n    address private _tempStakeAddress;\n    \n    uint256 _weightDays = 30 days;\n    bool _mutex = false;\n    modifier Mutex{\n        require(_mutex==false);\n        _mutex=true;\n        _;\n        _mutex=false;\n    }\n    constructor () payable{\n        _name=\"APPLE TOKEN\";\n        _symbol=\"APL\";\n        _decimals=8;\n        _totalSupply=100000000000*10**_decimals;\n        _balances[msg.sender]=_totalSupply;\n        _exludeBalances[msg.sender]=true;\n        _exludeBalances[address(this)]=true;\n        _totalLiquid=0;\n        \n        _liquidLastChangeTime = block.timestamp;\n        _totalStakeLastChangeTime = block.timestamp;\n        \n        _tempStakeAddress = address(uint160(block.timestamp));\n    }\n    function name() public view returns(string memory){\n        return _name;\n    }\n    function symbol() public view returns(string memory){\n        return _symbol;\n    }\n    function decimals() public view returns(uint8){\n        return _decimals;\n    }\n    function totalSupply() public view override returns(uint256){\n        return _totalSupply;\n    }\n    function totalLiquid() public view returns(uint256){\n        return _totalLiquid;\n    }\n    \n    \n    function getWeight(address account) public returns(uint256,uint256){\n        updateWeight(account);\n        return (_userWeight[account],_liquidWeight);\n    }\n    \n    function balanceOf(address account)public view override returns(uint256){\n        if(_exludeBalances[account])\n            return _balances[account];\n        (uint256 u,uint256 t) = getUserWeight(account);\n        uint256 result=0;\n        if(t==0){\n            result = _balances[account];\n        }else{\n            result = _balances[account].add(_balances[address(this)].mul(u).div(t));\n        }\n        return result;\n    }\n    //Transfer\n    function transfer(address recipient, uint256 amount) public override returns (bool){\n        require(recipient!=address(0)&&msg.sender!=address(0)&&amount>0,\"ERC20:an error occured\");\n        //indicates if fee should be deducted from transfer\n        bool takeFee = true;\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_exludeBalances[msg.sender] || _exludeBalances[recipient]){\n            takeFee = false;\n        }\n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(msg.sender,recipient,amount,takeFee);\n        takeFee=true;\n        return true;\n    }\n    //Transfer all of the tokens to the recipient.\n    function transferAll(address recipient) public returns(bool){\n        uint256 amount = balanceOf(msg.sender);\n        bool result = transfer(recipient,amount);\n        return result;\n    }\n    \n    function removeAllFee() private {\n        if(_taxFee == 0 && _burnFee== 0) return;\n        _previousTaxFee = _taxFee;\n        _previousLiquidFee = _burnFee;\n        _taxFee = 0;\n        _burnFee= 0;\n    }\n    \n    function restoreAllFee() private {\n        _taxFee = _previousTaxFee;\n        _burnFee= _previousLiquidFee;\n    }\n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n        if(!takeFee)\n            removeAllFee();\n        \n        if (_exludeBalances[sender] && !_exludeBalances[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_exludeBalances[sender] && _exludeBalances[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_exludeBalances[sender] && !_exludeBalances[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_exludeBalances[sender] && _exludeBalances[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n        if(!takeFee)\n            restoreAllFee();\n    }\n    function _transferBothExcluded(address sender,address recipient,uint256 amount) private{\n        require(_balances[sender]>=amount,\"ERC20:\");\n        _balances[sender]=_balances[sender].sub(amount);\n        _balances[recipient]=_balances[recipient].add(amount);\n    }\n    function _transferFromExcluded(address sender,address recipient,uint256 amount) private{\n        //Update recipient's state\n        updateWeight(recipient);\n        require(_balances[sender]>=amount,\"ERC20:\");\n        \n        _balances[sender]=_balances[sender].sub(amount);\n        _balances[recipient]=_balances[recipient].add(amount);\n        _totalLiquid=_totalLiquid.add(amount);\n    }\n    function _transferToExcluded(address sender,address recipient,uint256 amount) private{\n        //Update sender's state.\n        updateWeight(sender);\n        \n        uint256 uBalance;\n        if(_liquidWeight==0){\n            uBalance=_balances[sender];\n        }else{\n            uBalance=_balances[sender].add(_balances[address(this)].mul(_userWeight[sender]).div(_liquidWeight));\n        }\n        require(uBalance>=amount,\"ERC20:\");\n        \n        uint256 uAmout =_balances[sender].mul(amount).div(uBalance);\n        uint256 pAmout = amount.sub(uAmout);\n        uint256 subWeight = _userWeight[sender].mul(amount).div(uBalance);\n        //Transfer from user's balance.\n        _balances[sender]=_balances[sender].sub(uAmout);\n        _userWeight[sender]=_userWeight[sender].sub(subWeight);\n        //Transfer from the part of the pool.\n        _balances[address(this)]=_balances[address(this)].sub(pAmout);\n        _liquidWeight=_liquidWeight.sub(subWeight);\n       \n        //Transfer to.\n        _balances[recipient]=_balances[recipient].add(amount);\n        //Recalculate the liquid.\n        _totalLiquid=_totalLiquid.sub(uAmout);\n        \n    }\n    function _transferStandard(address sender,address recipient,uint256 amount) private{\n        //Update state for sender and recipient.\n        updateWeight(sender);\n        updateWeight(recipient);\n        //Get user's balance.\n        uint256 uBalance=_balances[sender]+_balances[address(this)].mul(_userWeight[sender]).div(_liquidWeight);\n        require(uBalance>=amount,\"ERC20:\");\n\n        uint256 uAmout =_balances[sender].mul(amount).div(uBalance);\n        uint256 pAmout = amount.sub(uAmout);\n        uint256 subWeight = _userWeight[sender].mul(amount).div(uBalance);\n        //Transfer from sender's balance.\n        _balances[sender]=_balances[sender].sub(uAmout);\n        //Recalculate user's weight.\n        _userWeight[sender]=_userWeight[sender].sub(subWeight);\n        //Transfer the part of the pool.\n        _balances[address(this)]=_balances[address(this)].sub(pAmout);\n        //Recalculate the weight of the whole liquid.\n        _liquidWeight=_liquidWeight.sub(subWeight);\n       \n        uint256 tax = amount.mul(_taxFee)/10000;\n        uint256 burn = amount.mul(_burnFee)/10000;\n        //Burn from the total supply.\n        _totalSupply=_totalSupply.sub(burn);\n        _balances[address(this)]=_balances[address(this)].add(tax);\n        //Tranfer to the recipient.\n        _balances[recipient]=_balances[recipient].add(amount).sub(tax).sub(burn);\n        \n        //Recalculate the liquid.\n        _totalLiquid=_totalLiquid.add(pAmout).sub(tax).sub(burn);\n    }\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256){\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external override returns (bool){\n        _approve(msg.sender,spender,amount);\n        return true;\n    }\n    \n    function increaseAllowance(address spender,uint256 addedValue) public returns(bool){\n        _approve(msg.sender,spender,_allowances[msg.sender][spender]+addedValue);\n        return true;\n    }\n    function decreaseAllowance(address spender,uint256 subtractedValue) public returns(bool){\n        uint256 currentAllowance=_allowances[msg.sender][spender];\n        require(currentAllowance>=subtractedValue,\"ERC20:decreased allowance below zero\");\n        unchecked{\n            _approve(msg.sender,spender,currentAllowance.sub(subtractedValue));\n        }\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool){\n        uint256 currentAllowance=_allowances[sender][msg.sender];\n        require(currentAllowance>=amount,\"ERC20:transfer amount exceeds allowance\");\n        //indicates if fee should be deducted from transfer\n        bool takeFee = true;\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_exludeBalances[msg.sender] || _exludeBalances[recipient]){\n            takeFee = false;\n        }\n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(sender,recipient,amount,takeFee);\n        unchecked{\n            _approve(sender,msg.sender,currentAllowance.sub(amount));\n        }\n        return true;\n    }\n    \n    function _approve(address owner,address spender,uint256 amount) internal{\n        require(owner!=address(0)&&spender!=address(0),\"ERC20:approve from zero address\");\n        \n        (uint256 u,uint256 t)=getUserWeight(owner);\n        uint256 senderBalance;\n        if(_liquidWeight==0){\n            senderBalance=_balances[owner];\n        }else{\n            senderBalance=_balances[owner].add(_balances[address(this)].mul(u).div(t));\n        }\n        require(senderBalance>=amount,\"ALADDIN:do not have enough amount to approve\");\n        _allowances[owner][spender]=amount;\n        emit Approval(owner,spender,amount);\n    }\n    \n    //Stake all of the tokens.\n    function stakeAll()public returns(bool){\n        uint256 rest = balanceOf(msg.sender);\n        return increaseStake(rest);\n    }\n    \n    //Increase the amount of stake.\n    function increaseStake(uint256 amount) public returns (bool){\n        if(_exludeBalances[msg.sender])return false;\n        require(amount>0,\"ALADDIN:stake amount must > 0\");\n        updateStakeWeight(msg.sender);\n        \n        _transferToExcluded(msg.sender,_tempStakeAddress,amount);\n        _balances[_tempStakeAddress]=0;\n        \n        uint256 tax = amount.mul(_taxFee).div(10000);\n        uint256 burn = amount.mul(_burnFee).div(10000);\n        uint256 i=amount.sub(tax).sub(burn);\n        //Burn from the total supply.\n        _totalSupply-=burn;\n        _stakes[msg.sender]=_stakes[msg.sender].add(i);\n        _totalStake=_totalStake.add(i);\n        //Add the tax fee to the pool.\n        _balances[address(this)]=_balances[address(this)].add(tax);\n        \n        return true;\n    }\n    \n    //Cancel stake.Return the weight of stake for user and the whole stake.\n    function cancelStake()public returns(uint256,uint256){\n        updateStakeWeight(msg.sender);\n        \n        uint256 maxUserWeight = _stakes[msg.sender].mul(1 days).mul(10000).div(_stakeFee);\n        uint256 currentUserWeight = _userStakeWeight[msg.sender];\n        uint256 totalStakeWeight=_totalStakeWeight;\n        \n        uint256 fee;\n        //The time less than time can stake.\n        if(currentUserWeight<=maxUserWeight){\n            fee = currentUserWeight.mul(_stakeFee).div(_stakes[msg.sender]).div(1 days).div(10000);\n            uint256 unStake = _balances[msg.sender].sub(fee);\n           \n           transferFromTempStake(msg.sender,unStake);\n            \n        }else{\n            //All stake was burnd.\n            fee = _stakes[msg.sender];\n            //Correct the weight of the total stake.\n            totalStakeWeight=_totalStakeWeight.sub(currentUserWeight).add(maxUserWeight);\n            currentUserWeight = maxUserWeight;\n        }\n        _totalStake = _totalStake.sub(_stakes[msg.sender]);\n        //Recalculate the weight of the total stake.\n        _totalStakeWeight=_totalStakeWeight.sub(currentUserWeight);\n        \n        _userStakeWeight[msg.sender]=0;\n        _stakes[msg.sender]=0;\n        \n        //Half burnd,another half tranfer to the pool.\n        uint256 half=fee.div(2);\n        uint256 other = fee.sub(half);\n        \n        _balances[address(this)]=_balances[address(this)].add(half);\n        _totalSupply=_totalSupply.sub(other);\n        return (currentUserWeight,totalStakeWeight);\n    }\n    \n    function transferFromTempStake(address sender,uint256 amout)private Mutex{\n            _balances[_tempStakeAddress]=amout;\n            _transferFromExcluded(_tempStakeAddress,sender,amout);\n    }\n    //Get amout of user's stake.\n    function getStake() public view returns(uint256){\n        return _stakes[msg.sender];\n    }\n    //Get weight of user's stake.Return the weight of the user and the whole stake.\n    function getStakeWeight()public returns(uint256,uint256){\n        updateStakeWeight(msg.sender);\n        return (_userStakeWeight[msg.sender],_totalStakeWeight);\n    }\n    //Update stake state for user and the whole state.\n    function updateStakeWeight(address ad) private {\n        uint256 weight = block.timestamp.sub(_stakeLastChangeTime[ad]).mul(_stakes[ad]);\n        _userStakeWeight[ad] = _userStakeWeight[ad].add(weight);\n        _stakeLastChangeTime[ad]=block.timestamp;\n        _totalStakeWeight = _totalStakeWeight.add(block.timestamp.sub(_totalStakeLastChangeTime).mul(_totalStake));\n        _totalStakeLastChangeTime = block.timestamp;\n    }\n\n    //Get the weight of user and total liquid.\n    function getUserWeight(address ad) private view returns(uint256,uint256){\n        uint256 u = 0;\n        uint256 t = 0; \n        t = _liquidWeight.add(block.timestamp.sub(_liquidLastChangeTime).mul(_totalLiquid));\n        if(_lastChangeTime[ad]==0){\n            u=0;\n        }else{\n            u=block.timestamp.sub(_lastChangeTime[ad]).mul(_balances[ad]);\n        }\n        uint256 maxU = _balances[ad].mul(_weightDays);\n        if(u>maxU){\n            t = t.sub(u).add(maxU);\n            u = maxU;\n        }\n        u=_userWeight[ad].add(u);\n        return (u,t);\n    }\n    //Update weight for user and total liquid,and set the last changed time for them.\n    function updateWeight(address ad)private{\n        uint256 u = 0;\n        uint256 t = 0; \n        t = _liquidWeight.add(block.timestamp.sub(_liquidLastChangeTime).mul(_totalLiquid));\n        if(_lastChangeTime[ad]==0){\n            u=0;\n        }else{\n            u=block.timestamp.sub(_lastChangeTime[ad]).mul(_balances[ad]);\n        }\n        uint256 maxU = _balances[ad].mul(_weightDays);\n        //Recorrect the total liquid weight.\n        if(u>maxU){\n            t = t.sub(u).add(maxU);\n            u = maxU;\n        }\n        _liquidWeight = t;\n        _liquidLastChangeTime = block.timestamp;\n        _userWeight[ad]=_userWeight[ad].add(u);\n        _lastChangeTime[ad]=block.timestamp;\n    }\n\n    function recieve() public  payable{}\n    //functions for admin\n    \n    function changeTaxFee(uint16 newTaxFee) public OnlyOwner{\n        _taxFee = newTaxFee;\n    }\n    function changeBurnFee(uint16 newBurnFee) public OnlyOwner{\n        _burnFee = newBurnFee;\n    }\n    function changeStakeFee(uint16 newStakeFee)public OnlyOwner{\n        _stakeFee = newStakeFee;\n    }\n    function changeWeightDays(uint256 newWeightDays)public OnlyOwner{\n        _weightDays= newWeightDays;\n    }\n    function changeExcludeState(address account,bool state)public OnlyOwner{\n        _exludeBalances[account]=state;\n    }\n    \n}"
    }
  }
}