{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/com.sol": {
      "content": "pragma solidity ^0.6.7;\n\ninterface ERC20 {\n  function approve(address spender, uint256 amount) external;\n  function transfer(address recipient, uint256 amount) external;\n  function balanceOf(address account) external view returns (uint256);\n}\n\ninterface Comptroller {\n  function closeFactorMantissa() external view returns(uint256);\n  function getAccountLiquidity(address account) external view returns(uint256, uint256, uint256);\n  function oracle() external view returns(address);\n}\n\ninterface CToken {\n  function borrowBalanceCurrent(address account) external returns(uint);\n  function balanceOfUnderlying(address account) external returns(uint);\n  function liquidateBorrow(address borrower, uint _amount, address _supplyAsset) external returns(uint);\n}\n\ninterface CEther {\n  function liquidateBorrow(address borrower, address supplyAsset) external payable;\n}\n\ninterface CompOracle {\n  function getUnderlyingPrice(address cToken) external view returns(uint256);\n}\n\ninterface OneInch {\n  function swap(ERC20 fromToken, ERC20 toToken, uint256 amount, uint256 minReturn, uint256[] calldata distribution, uint256 disableFlags) external payable;\n  function getExpectedReturn(ERC20 fromToken, ERC20 toToken, uint256 amount, uint256 parts, uint256 disableFlags) external view returns(uint256 returnAmount, uint256[] memory distribution);\n}\n\ninterface GST2 {\n  function freeUpTo(uint256 value) external returns (uint256 freed);\n}\n\ninterface AaveProvider {\n  function getLendingPool() external view returns (address);\n  function getLendingPoolCore() external view returns (address payable);\n}\n\ninterface AaveLendingPool {\n  function flashLoan(address receiver, address reserve, uint256 amount, bytes calldata params) external;\n}\n\n// Error codes:\n// ERR-1 - Price does not match\n// ERR-2 - Account not for liquidation\n\ncontract Liquidator {\n\n  address constant COMPTROLLER_ADDRESS = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n  address constant GST2_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n  address constant ONE_INCH_CONTRACT = 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\n  address constant AAVE_PROVIDER = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n\n  address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  address constant CETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n  address constant CDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n  address constant CBAT = 0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E;\n  address constant CREP = 0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1;\n  address constant CSAI = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\n  address constant CZRX = 0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407;\n  address constant CUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\n  address constant CUSDT = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9;\n  address constant CWBTC = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;\n\n  address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n  address constant BAT = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\n  address constant REP = 0x1985365e9f78359a9B6AD760e32412f4a445E862;\n  address constant SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n  address constant ZRX = 0xE41d2489571d322189246DaFA5ebDe1F4699F498;\n  address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n  address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n  address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n\n  event LogInt(uint256 key, uint val);\n  event LogAddr(uint256 key, address val);\n\n  address payable private owner;\n  uint256[] private sellDistribution;\n  address private account;\n  address private supplyCToken;\n  address private borrowCToken;\n  uint256 private repayBorrowUnderlyingAmount;\n  mapping (address => address) tokens;\n\n  receive() external payable {}\n\n  constructor() public {\n    owner = 0x9F8ce490AEdc9f8138FC43fe8B212a27194E9739;// msg.sender;\n\n    tokens[CETH]  = ETH_ADDRESS;\n    tokens[CDAI]  = DAI;\n    tokens[CBAT]  = BAT;\n    tokens[CREP]  = REP;\n    tokens[CSAI]  = SAI;\n    tokens[CZRX]  = ZRX;\n    tokens[CUSDC] = USDC;\n    tokens[CUSDT] = USDT;\n    tokens[CWBTC] = WBTC;\n\n    ERC20(CETH).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(CDAI).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(CBAT).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(CREP).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(CSAI).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(CZRX).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(CUSDC).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(CUSDT).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(CWBTC).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n\n    ERC20(DAI).approve(CDAI, 100000000000000000000000000000);\n    ERC20(BAT).approve(CBAT, 100000000000000000000000000000);\n    ERC20(REP).approve(CREP, 100000000000000000000000000000);\n    ERC20(SAI).approve(CSAI, 100000000000000000000000000000);\n    ERC20(ZRX).approve(CZRX, 100000000000000000000000000000);\n    ERC20(USDC).approve(CUSDC, 100000000000000000000000000000);\n    ERC20(USDT).approve(CUSDT, 100000000000000000000000000000);\n    ERC20(WBTC).approve(CWBTC, 100000000000000000000000000000);\n  }\n\n  function min(uint a, uint b) private pure returns (uint) {\n    return a > b ? b : a;\n  }\n\n  function depositEth() public payable {}\n\n  function withdrawToken(address _asset) public {\n    uint256 assetBalance = ERC20(_asset).balanceOf(address(this));\n\n    if (assetBalance > 0) {\n      ERC20(_asset).transfer(owner, assetBalance);\n    }\n  }\n\n  function clearTempVars() private {\n    delete account;\n    delete supplyCToken;\n    delete borrowCToken;\n    delete sellDistribution;\n    delete repayBorrowUnderlyingAmount;\n  }\n\n  // supplyCToken available for liquidation, based on closeFactor\n  // Returned converted to the borrow underlying units\n  function availableSupplyUnderlyingAmount(uint _closeFactor) private returns(uint) {\n    address compOracle = Comptroller(COMPTROLLER_ADDRESS).oracle();\n\n    uint supplyUnderlyingPrice = CompOracle(compOracle).getUnderlyingPrice(supplyCToken);\n    uint supplyUnderlyingAmount = CToken(supplyCToken).balanceOfUnderlying(account) * _closeFactor / 10**18;\n    uint borrowUnderlyingPrice = CompOracle(compOracle).getUnderlyingPrice(borrowCToken);\n\n    supplyUnderlyingAmount = supplyUnderlyingAmount * supplyUnderlyingPrice / borrowUnderlyingPrice;\n\n    return supplyUnderlyingAmount;\n  }\n\n  function _returnAaveFunds(address _reserve, uint256 _amount, uint256 _fee) private {\n    uint256 returnBalanceWithFee = _amount + _fee;\n    address aaveCore = AaveProvider(AAVE_PROVIDER).getLendingPoolCore();\n\n    if (_reserve == ETH_ADDRESS) {\n      aaveCore.call { value: returnBalanceWithFee }(\"\");\n    } else {\n      ERC20(_reserve).transfer(aaveCore, returnBalanceWithFee);\n    }\n  }\n\n  function oneSwap(address _fromAsset, address _toAsset, uint256 _amount, uint256[] memory _distribution) public {\n    if (_fromAsset == ETH_ADDRESS) {\n      OneInch(ONE_INCH_CONTRACT).swap { value: _amount } (ERC20(_fromAsset), ERC20(_toAsset), _amount, 0, _distribution, 0);\n    } else {\n      OneInch(ONE_INCH_CONTRACT).swap(ERC20(_fromAsset), ERC20(_toAsset), _amount, 0, _distribution, 0);\n    }\n  }\n\n  function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes memory _params) public payable {\n    if (borrowCToken == CETH) {\n      CEther(borrowCToken).liquidateBorrow { value: repayBorrowUnderlyingAmount } (account, supplyCToken);\n    } else {\n      CToken(borrowCToken).liquidateBorrow(account, repayBorrowUnderlyingAmount, supplyCToken);\n    }\n\n    uint cTokenBalance = ERC20(supplyCToken).balanceOf(address(this));\n    oneSwap(supplyCToken, _reserve, cTokenBalance, sellDistribution);\n\n    _returnAaveFunds(_reserve, _amount, _fee);\n    GST2(GST2_ADDRESS).freeUpTo(10);\n  }\n\n function requireAccountUnderwater(address _account) private view {\n    uint a;\n    uint b;\n    uint c;\n    (a, b, c) = Comptroller(COMPTROLLER_ADDRESS).getAccountLiquidity(_account);\n    require(c > 0, \"ERR-2\");\n }\n\n  // function requireExactCTokenPrice(address _supplyCToken, uint _supplyCTokenPrice) private view {\n  //   uint supplyUnderlyingPrice = CompOracle(Comptroller(COMPTROLLER_ADDRESS).oracle()).getUnderlyingPrice(_supplyCToken);\n  //   require(supplyUnderlyingPrice == _supplyCTokenPrice, \"ERR-1\");\n  // }\n\n  // Perform calculations to determine if we should proceed with the liqudations\n  // Multiple txs will be submitted before the oracle updates to get into the right position inside of the block\n  function startLiquidation(\n      address _account,\n      address _borrowCToken,\n      address _supplyCToken,\n      uint256[] memory _sellDistribution\n  ) public returns(bool) {\n\n    requireAccountUnderwater(_account);\n    // requireExactCTokenPrice(_supplyCToken, _supplyCTokenPrice);\n\n    account = _account;\n    borrowCToken = _borrowCToken;\n    supplyCToken = _supplyCToken;\n    sellDistribution = _sellDistribution;\n\n    uint closeFactor = Comptroller(COMPTROLLER_ADDRESS).closeFactorMantissa();\n\n    uint seizableBorrowUnderlyingAmount = CToken(borrowCToken).borrowBalanceCurrent(account) * closeFactor / 10 ** 18;\n\n    // availableSupplyUnderlyingAmount is in borrow units (converted based on borrow price)\n    uint availableSupplyUnderlyingAmount = availableSupplyUnderlyingAmount(closeFactor);\n\n    uint borrowUnderlyingPrice = CompOracle(Comptroller(COMPTROLLER_ADDRESS).oracle()).getUnderlyingPrice(borrowCToken);\n    uint maxUnderlyingBorrowAmount = (1000 * 10**18) * 10**18 / borrowUnderlyingPrice;\n    repayBorrowUnderlyingAmount = min(availableSupplyUnderlyingAmount, seizableBorrowUnderlyingAmount);\n    repayBorrowUnderlyingAmount = min(repayBorrowUnderlyingAmount, maxUnderlyingBorrowAmount);\n\n    address borrowUnderlyingAsset = tokens[_borrowCToken];\n\n    // Skip supply assets with less than 10% of value of seizableBorrowUnderlyingAmount\n    if (availableSupplyUnderlyingAmount > (seizableBorrowUnderlyingAmount / 10)) {\n      address aavePool = AaveProvider(AAVE_PROVIDER).getLendingPool();\n      AaveLendingPool(aavePool).flashLoan(address(this), borrowUnderlyingAsset, repayBorrowUnderlyingAmount, \"\");\n    }\n\n    clearTempVars();\n\n    return true;\n  }\n}\n"
    }
  }
}