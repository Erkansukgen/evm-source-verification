{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DSA_READ/curveGauge.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface ICurveGaugeMapping {\n\n  struct GaugeData {\n    address gaugeAddress;\n    bool rewardToken;\n  }\n\n  function gaugeMapping(bytes32) external view returns(GaugeData memory);\n}\n\ninterface TokenInterface {\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IMintor {\n    function minted(address, address) external view returns (uint);\n}\n\ninterface IGauge {\n  function integrate_fraction(address user) external view returns(uint256 amt);\n  function lp_token() external view returns(address token);\n  function rewarded_token() external view returns(address token);\n  function crv_token() external view returns(address token);\n  function balanceOf(address user) external view returns(uint256 amt);\n  function rewards_for(address user) external view returns(uint256 amt);\n  function claimed_rewards_for(address user) external view returns(uint256 amt);\n}\n\ncontract GaugeHelper {\n  function getCurveGaugeMappingAddr() internal pure returns (address){\n    return 0x1C800eF1bBfE3b458969226A96c56B92a069Cc92;\n  }\n\n  function getCurveMintorAddr() internal pure returns (address){\n    return 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n  }\n\n  /**\n   * @dev Convert String to bytes32.\n   */\n  function stringToBytes32(string memory str) internal pure returns (bytes32 result) {\n    require(bytes(str).length != 0, \"string-empty\");\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      result := mload(add(str, 32))\n    }\n  }\n}\n\n\ncontract Resolver is GaugeHelper {\n    struct PositionData {\n        uint stakedBal;\n        uint crvEarned;\n        uint crvClaimed;\n        uint rewardsEarned;\n        uint rewardsClaimed;\n        uint crvBal;\n        uint rewardBal;\n        bool hasReward;\n    }\n    function getPosition(string memory gaugeName, address user) public view returns (PositionData memory positionData) { \n        ICurveGaugeMapping curveGaugeMapping = ICurveGaugeMapping(getCurveGaugeMappingAddr());\n        ICurveGaugeMapping.GaugeData memory curveGaugeData = curveGaugeMapping.gaugeMapping(\n            bytes32(stringToBytes32(gaugeName)\n        ));\n        IGauge gauge = IGauge(curveGaugeData.gaugeAddress);\n        IMintor mintor = IMintor(getCurveMintorAddr());\n        positionData.stakedBal = gauge.balanceOf(user);\n        positionData.crvEarned = gauge.integrate_fraction(user);\n        positionData.crvClaimed = mintor.minted(user, address(gauge));\n\n        if (curveGaugeData.rewardToken) {\n            positionData.rewardsEarned = gauge.rewards_for(user);\n            positionData.rewardsClaimed = gauge.claimed_rewards_for(user);\n            positionData.rewardBal = TokenInterface(address(gauge.rewarded_token())).balanceOf(user);\n        }\n        positionData.hasReward = curveGaugeData.rewardToken;\n\n        positionData.crvBal = TokenInterface(address(gauge.crv_token())).balanceOf(user);\n    }\n\n    function getPositions(string[] memory gaugesName, address user) public view returns (PositionData[] memory positions) {\n        positions = new PositionData[](gaugesName.length);\n        for (uint i = 0; i < gaugesName.length; i++) {\n            positions[i] = getPosition(gaugesName[i], user);\n        }\n    }\n}\n\n\ncontract InstaCurveGaugeResolver is Resolver {\n    string public constant name = \"Curve-Gauge-Resolver-v1\";\n}"}}}