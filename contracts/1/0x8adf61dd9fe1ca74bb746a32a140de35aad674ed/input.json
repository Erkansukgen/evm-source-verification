{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FlashbotsTrader.sol":{"content":"pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface ERC20 {\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n}\n\ninterface ITradeAsset {\n    function bridgeCall(address _to, uint _value, bytes calldata _payload) external returns (bool,bytes memory);\n}\n\nstruct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    \ninterface ISwapRouter {\n    \n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to,uint deadline) \n        external returns (uint[] memory amounts);\n}\n\ninterface IDoDoPair {\n    function buyBaseToken(uint256 amount, uint256 maxPayQuote, bytes calldata data) external returns (uint256 payQuote);\n    function sellBaseToken(uint256 amount, uint256 minReceiveQuote, bytes calldata data) external returns (uint256 receiveQuote);\n}\n\ninterface IBalancer {\n    function smartSwapExactIn(address tokenIn, address tokenOut, uint totalAmountIn, uint minTotalAmountOut, uint nPools)\n        external returns (uint totalAmountOut);\n    function smartSwapExactOut(address tokenIn, address tokenOut, uint totalAmountOut, uint maxTotalAmountIn, uint nPools)\n        external returns (uint totalAmountIn);\n}\n\ncontract PermissionGroups{\n    \n    address public admin;\n    address public pendingAdmin;\n    mapping(address=>bool) public operatorAllowed;\n    address[] internal operatorsGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n    \n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"onlyAdmin\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operatorAllowed[msg.sender],\"onlyOperator\");\n        _;\n    }\n    \n    function transferAdmin(address newAdmin) external onlyAdmin {\n        require(newAdmin != address(0),\"newAdmin == address(0)\");\n        pendingAdmin = newAdmin;\n    }\n\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender,\"pendingAdmin != msg.sender\");\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) external onlyAdmin {\n        require(!operatorAllowed[newOperator],\"duplicated newOperator\"); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE,\"operatorsGroup.length >= MAX_GROUP_SIZE.\");\n\n        emit OperatorAdded(newOperator, true);\n        operatorAllowed[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) external onlyAdmin {\n        require(operatorAllowed[operator],\"operator is not in the operatorsGroup.\");\n        operatorAllowed[operator] = false;\n\n        for (uint i = 0; i < operatorsGroup.length; i++) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.pop();\n                emit OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n    \n    function getOperators() external view returns(address[] memory) {\n        return operatorsGroup;\n    }\n\n}\n\ncontract AssetManager is PermissionGroups{\n    \n    receive() external payable{}\n    fallback() external payable{}\n    \n    function withdrawEth(address payable _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        _to.transfer(_value);\n    }\n    \n    function withdrawToken(address _token, address _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        (bool success,bytes memory _data) = _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector,_to,_value));\n        require(success,\"ERC20(_token).transfer failed.\");\n        if(_data.length > 0){\n            require(abi.decode(_data,(bool)),\"ERC20(_token).transfer return data is false.\");\n        }\n    }\n\n}\n\ncontract FlashbotsTrader is AssetManager{\n\n    string constant public VERSION = \"Trader v2.8 for Flashbots\";\n    address constant public balancerAddress = 0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21;\n    address constant public uniswapV3Addr = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\n    address public assetAddress;\n    mapping(address=>bool) public tokenAllowed;\n    address[] internal tokensGroup;\n\n    modifier transferFee(uint minerFee) {\n        _;\n        if (minerFee > 0) {\n            block.coinbase.transfer(minerFee);\n        }\n    }\n\n    function setAssetAddress(address newAssetAddress) external onlyAdmin{\n        assetAddress = newAssetAddress;\n    }\n        \n    event TokenAdded(address newToken, bool isAdd);\n\n    function addTokens(address[] calldata newTokens) external onlyAdmin {\n        for(uint i=0; i<newTokens.length; i++){\n            addToken(newTokens[i]);\n        }\n    }\n    \n    function removeTokens (address[] calldata _tokens) external onlyAdmin {\n        for(uint i=0; i<_tokens.length; i++){\n            removeToken(_tokens[i]);\n        }\n    }\n    \n    function getTokensGroup() external view returns (address[] memory){\n        return tokensGroup;\n    }\n    \n    function addToken(address newToken) private {\n        require(!tokenAllowed[newToken],\"duplicated token\"); // prevent duplicates.\n\n        emit TokenAdded(newToken, true);\n        tokenAllowed[newToken] = true;\n        tokensGroup.push(newToken);\n    }\n\n    function removeToken (address token) private {\n        require(tokenAllowed[token],\"token is not in the tokensGroup.\");\n        tokenAllowed[token] = false;\n\n        for (uint i = 0; i < tokensGroup.length; i++) {\n            if (tokensGroup[i] == token) {\n                tokensGroup[i] = tokensGroup[tokensGroup.length - 1];\n                tokensGroup.pop();\n                emit TokenAdded(token, false);\n                break;\n            }\n        }\n    }\n\n    function cancel(uint minerFee) external onlyOperator transferFee(minerFee) {\n\n    }\n    \n    function exactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 deadline, uint256 amountIn,  uint256 amountOutMinimum, uint minerFee) \n        external onlyOperator transferFee(minerFee) \n    {\n        require(tokenAllowed[tokenIn],\"tokenIn is not allowed.\");\n        require(tokenAllowed[tokenOut],\"tokenOut is not allowed.\");\n        ExactInputSingleParams memory params;\n        params.tokenIn = tokenIn;\n        params.tokenIn = tokenOut;\n        params.fee = fee;\n        params.recipient = assetAddress;\n        params.deadline = deadline;\n        params.amountIn = amountIn;\n        params.amountOutMinimum = amountOutMinimum;\n        params.sqrtPriceLimitX96 = 0;\n        bytes memory _payload = abi.encodeWithSelector(ISwapRouter(uniswapV3Addr).exactInputSingle.selector,params);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(uniswapV3Addr,0,_payload);\n        require(success,\"bridgeCall failed!\");\n    }\n    \n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, uint deadline, address uniswapAddress, uint minerFee) \n        external onlyOperator transferFee(minerFee)\n    {\n        require(path.length == 2,\"path.length != 2\");\n        require(tokenAllowed[path[0]],\"path[0] token is not allowed.\");\n        require(tokenAllowed[path[1]],\"path[1] token is not allowed.\");\n        bytes memory _payload = abi.encodeWithSelector\n        (IUniswapV2Router02(uniswapAddress).swapExactTokensForTokens.selector,amountIn,amountOutMin,path,assetAddress,deadline);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(uniswapAddress,0,_payload);\n        require(success,\"bridgeCall failed!\");\n    }\n\n    function buyBaseToken(address _dodoPairAddress, uint256 amount, uint256 maxPayQuote, uint minerFee) external onlyOperator transferFee(minerFee) {\n        bytes memory _data = bytes(\"\");\n        bytes memory _payload = abi.encodeWithSelector(IDoDoPair(_dodoPairAddress).buyBaseToken.selector,amount,maxPayQuote,_data);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(_dodoPairAddress,0,_payload);\n        require(success,\"bridgeCall failed!\");\n    }\n    \n    function sellBaseToken(address _dodoPairAddress, uint256 amount, uint256 minReceiveQuote, uint minerFee) external onlyOperator transferFee(minerFee) {\n        bytes memory _data = bytes(\"\");\n        bytes memory _payload = abi.encodeWithSelector(IDoDoPair(_dodoPairAddress).sellBaseToken.selector,amount,minReceiveQuote,_data);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(_dodoPairAddress,0,_payload);\n        require(success,\"bridgeCall failed!\");\n    }\n\n    function smartSwapExactIn(address tokenIn, address tokenOut, uint totalAmountIn, uint minTotalAmountOut, uint nPools, uint minerFee) \n        external onlyOperator transferFee(minerFee)\n    {\n        require(tokenAllowed[tokenIn],\"tokenIn is not allowed.\");\n        require(tokenAllowed[tokenOut],\"tokenOut is not allowed.\");\n        \n        // IBalancer(balancerAddress).smartSwapExactIn.selector == 0x21b0eb85\n        bytes memory _payload = abi.encodeWithSelector(0x21b0eb85, tokenIn, tokenOut, totalAmountIn, minTotalAmountOut, nPools);\n        bridgeCall(balancerAddress,_payload);\n    }\n\n    function smartSwapExactOut(address tokenIn, address tokenOut, uint totalAmountOut, uint maxTotalAmountIn, uint nPools, uint minerFee)\n         external onlyOperator transferFee(minerFee)\n    {\n        require(tokenAllowed[tokenIn],\"tokenIn is not allowed.\");\n        require(tokenAllowed[tokenOut],\"tokenOut is not allowed.\");\n        // IBalancer(balancerAddress).smartSwapExactOut.selector == 0xb40f39ee \n        bytes memory _payload = abi.encodeWithSelector(0xb40f39ee, tokenIn, tokenOut, totalAmountOut, maxTotalAmountIn, nPools);\n        bridgeCall(balancerAddress,_payload);\n    }\n    \n    function bridgeCall(address _to, bytes memory _payload) internal {\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(_to,0,_payload);\n        require(success,\"bridgeCall failed!\");\n    }\n    \n}\n\n"}}}