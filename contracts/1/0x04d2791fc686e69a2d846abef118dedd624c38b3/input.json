{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Ballot.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >0.6.99 <0.8.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC1363Receiver {\n    function onTransferReceived(address operator, address from, uint256 value, bytes calldata data) external returns (bytes4); // solhint-disable-line  max-line-length\n}\n\ninterface IERC1363Spender {\n    function onApprovalReceived(address owner, uint256 value, bytes calldata data) external returns (bytes4);\n}\n\ncontract Ballot is IERC1363Spender, IERC1363Receiver{   \n    using SafeMath for uint256;\n\n    bytes4 internal constant _INTERFACE_ID_ERC1363_RECEIVER = 0x88a7ca5c;\n    bytes4 internal constant _INTERFACE_ID_ERC1363_SPENDER = 0x7b04a2d0;\n\n    struct Voter{\n        uint256 weight;\n        bool voted;\n    }\n    mapping(address => Voter) private _voters;\n    address [] _voters_list;\n    \n    IERC20 private _token_contract;\n    address private _token_contract_address;\n    address private _receive_address;\n    address private _owner;\n\n    uint256 public _period;\n\n    //need to be update\n    uint256 public _end_time;\n    uint256 private _pool;\n    uint256 private _y_pool; // stat-pool: Yes\n    uint256 private _n_pool; // stat-pool: No\n    uint256 private _threshold; \n    \n    uint256 private _state;\n\n    //Event\n    event Transfer(address indexed from, uint256 value);\n    event StartVote(address indexed to, uint256 end_time);\n    event Vote(address indexed from, uint256 state, bool agree, uint256 weight);\n\n    constructor(address  token_contract){\n        _token_contract_address = token_contract;\n        _token_contract = IERC20(token_contract);\n        _owner = msg.sender;\n        _period = 2419200; // 4 weeks\n\n    }\n    // ERC1363 Receiver\n    function onTransferReceived(address operator, address from, uint256 value, bytes calldata data) public override returns(bytes4){\n        // state check\n        require(_state == 0, \"Token collection not start\");\n        require(msg.sender == _token_contract_address, \"Not called from valid token contract\");\n        require(value > 0, \"Not valid value\");\n\n        record(from, value);\n        return _INTERFACE_ID_ERC1363_RECEIVER;\n    }\n    // ERC1363 Spender\n    function onApprovalReceived(address owner, uint256 value, bytes calldata data) public override returns(bytes4){\n        //state check\n        require(_state == 0, \"Token collection not start\");\n        require(msg.sender == _token_contract_address, \"Not called from valid token contract\");\n        require(value > 0, \"Not valid value\");\n        require(_token_contract.transferFrom(owner, address(this), value),\"Invalid transferFrom call\");\n\n        record(owner, value);\n        return _INTERFACE_ID_ERC1363_SPENDER;\n    }\n    // ERC20\n    function transferToken(address owner, uint256 value) public{\n        //state check\n        require(_state == 0, \"Token collection not start\");\n        require(value > 0, \"Not valid value\");\n        require (_token_contract.transferFrom(owner,address(this),value), \"Invalid transferFrom call\");\n\n        record(owner, value);\n    }\n    \n    function weightOf(address voter) public view returns(uint256){\n        return _voters[voter].weight;\n    }\n\n    function record(address voter, uint256 value) private{\n        if (_voters[voter].weight == 0){\n            _voters_list.push(voter);            \n        }\n        _voters[voter].weight = _voters[voter].weight.add(value);\n        _pool = _pool.add(value);\n\n        emit Transfer(voter, value);\n    }\n\n    function stopCollection(address receiveAddress) public{\n        //state check\n        require(_state == 0, \"Not proper state\");\n\n        require(msg.sender == _owner, \"Not valid owner address\");\n        require(receiveAddress != address(this), \"Please use different address\");\n\n        //check receive enough balance, no less than _pool\n        require(_token_contract.balanceOf(address(this)) >= _pool, \"Not enough balance\");\n\n        _state = 1;\n        _threshold = _pool.div(2);\n        _receive_address = receiveAddress;\n        _end_time = block.timestamp.add(_period); //currentTime + 4 weeks\n\n        emit StartVote(receiveAddress, _end_time);\n    }\n\n    function submitVote(uint256 state, bool agree) public returns(bool){\n        if (block.timestamp > _end_time && _end_time != 0){\n            tokenManagement();\n            reset();\n            return false;\n        }\n\n        //state check\n        require(_state != 0, \"Not voting time\");\n        require(_state == state, \"Not expected stage\");\n\n        require(_voters[msg.sender].weight > 0, \"Not valid voter\");\n        require(!_voters[msg.sender].voted, \"Already vote\");\n\n        _voters[msg.sender].voted = true;\n        uint256 weight = _voters[msg.sender].weight;\n        \n        if (agree){\n            _y_pool = _y_pool.add(weight);\n        } else {\n            _n_pool = _n_pool.add(weight);\n        }\n\n        emit Vote(msg.sender, _state, agree, weight);\n\n        tally();\n        return true;\n    }\n    \n    function tally() public returns(string memory) {\n        require(_state != 0, \"Not tally time\");\n        string memory result;\n\n        if (block.timestamp > _end_time && _end_time != 0){\n            tokenManagement();\n            reset();\n            result = \"Time out\";\n        }\n\n        if (_y_pool >= _threshold){\n            if (_state == 3){\n                require(_token_contract.balanceOf(address(this)) >= _pool, \"Not enough balance\");\n                _token_contract.transfer(_receive_address, _pool);\n                reset();\n            } else{\n                clearVote();\n            }\n            result = \"Success\";\n        }else if (_n_pool > _threshold){\n            tokenManagement();\n            reset();\n            result = \"Fail\";\n        }else{\n            result = \"On going\";\n        }\n\n        return result;\n    }\n\n    // Action if > 50% N votes\n    function tokenManagement() private {\n        //based on _state, calculate percent\n        require(_token_contract.balanceOf(address(this)) >= _pool, \"Not enough balance\");\n    \n        if (_state == 1){\n            for (uint i = 0; i < _voters_list.length ; i++){\n                _token_contract.transfer(_voters_list[i],_voters[_voters_list[i]].weight);\n            }\n        } else if (_state == 2){\n            for (uint i = 0; i < _voters_list.length ; i++){\n                uint256 value = _voters[_voters_list[i]].weight.mul(8).div(10);\n                _token_contract.transfer(_voters_list[i],value);\n                _pool = _pool.sub(value);\n            }\n            _token_contract.transfer(_receive_address, _pool);\n        } else if (_state == 3){\n            for (uint i = 0; i < _voters_list.length ; i++){\n                uint256 value = _voters[_voters_list[i]].weight.div(10);\n                _token_contract.transfer(_voters_list[i],value);\n                _pool = _pool.sub(value);\n            }\n            _token_contract.transfer(_receive_address, _pool);\n        }\n    }\n\n    function clearVote() private{\n        for (uint i = 0; i < _voters_list.length ; i++){\n            _voters[_voters_list[i]].voted = false;\n        }\n        _y_pool = 0;\n        _n_pool = 0;\n        _state += 1;\n        _end_time = block.timestamp.add(_period);\n    }\n\n    function reset() private{\n        for (uint i = 0; i < _voters_list.length ; i++){\n            _voters[_voters_list[i]].weight = 0;\n            _voters[_voters_list[i]].voted = false;\n        }\n        delete _voters_list;\n\n        _end_time = 0;\n        _pool = 0;\n        _n_pool = 0;\n        _y_pool = 0;\n        _threshold = 0;\n        _state = 0;\n    }\n\n}"}}}