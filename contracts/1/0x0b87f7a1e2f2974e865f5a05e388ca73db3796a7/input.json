{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/interfaces/v3pool.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    /*\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n    */\n\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n  \n}"
    },
    "contracts/wildcreditarb.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/v3pool.sol';\nimport './lib/SafeMath.sol';\n// import './lib/PoolAddress.sol';\n// import './lib/CusByteslib.sol';\n\n\ninterface IWETH {\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n}\n\n\ninterface lendingpair{\n    function pendingSupplyInterest(address _token, address _account) external view returns(uint);\n    function accrueAccount(address _account) external;\n}\n\ninterface feereceipt{\n  function convert(\n    address _pair,\n    bytes calldata _path,\n    uint _minWildOutput\n  ) external;  \n}\n\n\ninterface feeconverter{\n    function wildInput(address _fromToken, uint _fromAmount) external view returns(uint);\n}\n\ninterface v2pool{\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n\n\ncontract wildarb {\n    using SafeMath for uint;\n\n    \n    address payable public owner;\n    \n    \n    // main net\n    \n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    \n\n    \n\n    constructor() public {\n        owner = msg.sender;\n        IERC20(address(0x08A75dbC7167714CeaC1a8e43a8d643A4EDd625a)).approve(address(0x31FD80bf06453ACE58bea89727e88003f0e691Bb), \n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n    function withdrawethall() external onlyowner {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n\n\n\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\n    \n        // require(tx.origin == address(0x777D0dCC4615ccfE3E575C20219fdF0BBe8251C7), \"shit\");\n    \n        (address pair, address token, uint256 paybackamount, uint256[] memory sellinfo) = abi.decode(_data, (address, address,uint256, uint256[]));\n    \n        // convert the lp token using wild to target token\n        feereceipt(0x487502F921BA3DADAcF63dBF7a57a978C241B72C).convert(pair, abi.encodePacked(token), 0);\n\n        // sell the target token\n        if(sellinfo.length > 0){\n            uint256 receive_amount = IERC20(token).balanceOf(address(this));\n            IERC20(token).transfer(address(sellinfo[0] \n            & 0x00ffffffffffffffffffffffffffffffffffffffff), receive_amount);\n            \n            bool flag;\n            \n            for(uint i=0; i < sellinfo.length; i++){\n                pair = address(sellinfo[i] & 0x00ffffffffffffffffffffffffffffffffffffffff);\n                \n                // reuse token to store the receiver\n                if((i + 1) == sellinfo.length){\n                    token = address(this);\n                }else{\n                    token = address(sellinfo[i+1] & 0x00ffffffffffffffffffffffffffffffffffffffff);\n                }\n                \n                flag = (sellinfo[i] >> 160 & 0x00ff) == 1;\n                receive_amount = sellinfo[i] >> 168;\n                \n                if(flag){\n                    v2pool(pair).swap(0, receive_amount, token, new bytes(0));\n                }else{\n                    v2pool(pair).swap(receive_amount, 0, token, new bytes(0));\n                }\n                \n            }\n        }\n        \n        \n        // send weth back to the pool\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).transfer(msg.sender, paybackamount);\n    \n    }\n\n\n\n    function wild_credit_arb(uint256 wildamount, uint256 paybackamount, address pair, address path, uint256[] memory sellinfo) public payable{\n         // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }       \n    \n        bytes memory data = abi.encode(pair, path, paybackamount, sellinfo);\n    \n\n        // use v2 to swap the wild credit token\n        v2pool(0xc36068bf159414beb497f8ECe08763868149B2Fe).swap(wildamount, 0, address(this), data);\n\n    \n        wildamount = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this)) - 1;\n        IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(wildamount);\n        msg.sender.transfer(wildamount);\n    }\n\n\n\n\n    function wild_credit_accrue_arb(uint256 wildamount, uint256 paybackamount, address pair, address path,address[] memory accounts, uint256[] memory sellinfo) public payable{\n         // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }       \n    \n        for(uint256 i = 0; i < accounts.length; i++){\n            lendingpair(pair).accrueAccount(accounts[i]);\n        }    \n    \n    \n        bytes memory data = abi.encode(pair, path, paybackamount, sellinfo);\n    \n\n        // use v2 to swap the wild credit token\n        v2pool(0xc36068bf159414beb497f8ECe08763868149B2Fe).swap(wildamount, 0, address(this), data);\n\n    \n        wildamount = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this)) - 1;\n        IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(wildamount);\n        msg.sender.transfer(wildamount);\n    }\n\n\n\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    } \n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // the first flag indicts whether the token transferred to the pool is the token0\n    function v2out(address pool, bool first, uint256 amountIn) private view returns (uint256 amountOut){\n        bytes memory returnData;\n        (, returnData) = pool.staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n        \n        (uint reserveInput, uint reserveOutput) = (first) ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        amountOut = getAmountOut(amountIn, reserveInput, reserveOutput);\n        \n        return(amountOut);\n    }\n\n\n    function cal_benefit(address lptoken, address token, uint256 daoshareeth, address[] memory pools, address[] memory tokens) public view returns(uint256 wethout, uint256 wildin, uint256 weth_need, uint256 benefit, uint256[] memory amountsout){\n        uint256 inputamount;\n        uint256 lpamount = IERC20(lptoken).balanceOf(address(0x487502F921BA3DADAcF63dBF7a57a978C241B72C));\n        \n        amountsout = new uint256[](pools.length);\n        \n        \n        if(token == address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)){\n            wethout = lpamount - lpamount * daoshareeth / 100e18;\n            inputamount = wethout;\n        }else{\n            inputamount = lpamount;\n            for(uint i = 0; i < pools.length; i++){\n                lpamount = v2out(pools[i], tokens[i] < tokens[i+1], lpamount);\n                amountsout[i] = lpamount;\n            }\n            wethout = lpamount;\n        }\n        \n        // how much wild in\n        wildin = feeconverter(address(0x31FD80bf06453ACE58bea89727e88003f0e691Bb)).wildInput(token, inputamount);\n        \n        // how much weth need to swap the target amount wild out\n\n        bytes memory returnData;\n        (, returnData) = address(0xc36068bf159414beb497f8ECe08763868149B2Fe).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n        \n        weth_need = getAmountIn(wildin, reserve1, reserve0);\n \n        if(wethout > weth_need){\n            benefit = wethout - weth_need;\n        }\n \n    }\n\n\n    // provide a lpamount, mainly to cal a optimal amount to accure accounts\n    function cal_benefit_specific(uint256 lpamount, address lptoken, address token, uint256 daoshareeth, address[] memory pools, address[] memory tokens) public view returns(uint256 wethout, uint256 wildin, uint256 weth_need, uint256 benefit, uint256[] memory amountsout){\n        uint256 inputamount;\n        // uint256 lpamount = IERC20(lptoken).balanceOf(address(0x487502F921BA3DADAcF63dBF7a57a978C241B72C));\n        \n        amountsout = new uint256[](pools.length);\n        \n        if(token == address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)){\n            wethout = lpamount - lpamount * daoshareeth / 100e18;\n            inputamount = wethout;\n        }else{\n            inputamount = lpamount;\n            for(uint i = 0; i < pools.length; i++){\n                lpamount = v2out(pools[i], tokens[i] < tokens[i+1], lpamount);\n                amountsout[i] = lpamount;\n            }\n            wethout = lpamount;\n        }\n        \n        // how much wild in\n        wildin = feeconverter(address(0x31FD80bf06453ACE58bea89727e88003f0e691Bb)).wildInput(token, inputamount);\n        \n        // how much weth need to swap the target amount wild out\n\n        bytes memory returnData;\n        (, returnData) = address(0xc36068bf159414beb497f8ECe08763868149B2Fe).staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n        \n        weth_need = getAmountIn(wildin, reserve1, reserve0);\n \n        if(wethout > weth_need){\n            benefit = wethout - weth_need;\n        }\n \n    }\n\n\n\n    // view function returns batch interests info\n    function batch_interest(address pair, address[] memory accounts, address[] memory tokens) public view returns(uint256[] memory amounts){\n        \n        amounts = new uint256[](accounts.length);\n        \n        for(uint i = 0 ; i < accounts.length; i++){\n            amounts[i] = lendingpair(pair).pendingSupplyInterest(tokens[i], accounts[i]);\n        }\n    }\n\n    // view function returns batch lp amounts info\n    function batch_erc20_balance(address target, address[] memory erc20_addr) public view returns(uint256[] memory amounts){\n        amounts = new uint256[](erc20_addr.length);\n        \n        for(uint i = 0; i< erc20_addr.length; i++){\n            amounts[i] = IERC20(erc20_addr[i]).balanceOf(target);\n        }\n    }\n\n}"
    }
  }
}