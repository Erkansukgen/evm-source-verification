{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "EliteFeeTo.sol": {
      "content": "pragma solidity ^0.5.16;\r\n\r\n// this contract gives owner the ability to allow tokens. for pairs in which both tokens are allowed, fees may be\r\n// collected on that pair and send to feeRecipient, though only after burning all fees up to that point\r\ncontract EliteFeeTo {\r\n    address public owner;\r\n    address public feeRecipient;\r\n\r\n    struct TokenAllowState {\r\n        bool    allowed;\r\n        uint128 disallowCount;\r\n    }\r\n    mapping(address => TokenAllowState) public tokenAllowStates;\r\n\r\n    struct PairAllowState {\r\n        uint128 token0DisallowCount;\r\n        uint128 token1DisallowCount;\r\n    }\r\n    mapping(address => PairAllowState) public pairAllowStates;\r\n\r\n    constructor(address owner_) public {\r\n        owner = owner_;\r\n    }\r\n\r\n    function setOwner(address owner_) public {\r\n        require(msg.sender == owner, 'EliteFeeTo::setOwner: not allowed');\r\n        owner = owner_;\r\n    }\r\n\r\n    function setFeeRecipient(address feeRecipient_) public {\r\n        require(msg.sender == owner, 'EliteFeeTo::setFeeRecipient: not allowed');\r\n        feeRecipient = feeRecipient_;\r\n    }\r\n\r\n    function updateTokenAllowState(address token, bool allowed) public {\r\n        require(msg.sender == owner, 'EliteFeeTo::updateTokenAllowState: not allowed');\r\n        TokenAllowState storage tokenAllowState = tokenAllowStates[token];\r\n        // if allowed is not changing, the function is a no-op\r\n        if (allowed != tokenAllowState.allowed) {\r\n            tokenAllowState.allowed = allowed;\r\n            // this condition will only be true on the first call to this function (regardless of the value of allowed)\r\n            // by effectively initializing disallowCount to 1,\r\n            // we force renounce to be called for all pairs including newly allowed token\r\n            if (tokenAllowState.disallowCount == 0) {\r\n                tokenAllowState.disallowCount = 1;\r\n            } else if (allowed == false) {\r\n                tokenAllowState.disallowCount += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateTokenAllowStates(address[] memory tokens, bool allowed) public {\r\n        for (uint i; i < tokens.length; i++) {\r\n            updateTokenAllowState(tokens[i], allowed);\r\n        }\r\n    }\r\n\r\n    function renounce(address pair) public returns (uint value) {\r\n        PairAllowState storage pairAllowState = pairAllowStates[pair];\r\n        TokenAllowState storage token0AllowState = tokenAllowStates[IEliteswapV2Pair(pair).token0()];\r\n        TokenAllowState storage token1AllowState = tokenAllowStates[IEliteswapV2Pair(pair).token1()];\r\n\r\n        // we must renounce if any of the following four conditions are true:\r\n        // 1) token0 is currently disallowed\r\n        // 2) token1 is currently disallowed\r\n        // 3) token0 was disallowed at least once since the last time renounce was called\r\n        // 4) token1 was disallowed at least once since the last time renounce was called\r\n        if (\r\n            token0AllowState.allowed == false ||\r\n            token1AllowState.allowed == false ||\r\n            token0AllowState.disallowCount > pairAllowState.token0DisallowCount ||\r\n            token1AllowState.disallowCount > pairAllowState.token1DisallowCount\r\n        ) {\r\n            value = IEliteswapV2Pair(pair).balanceOf(address(this));\r\n            if (value > 0) {\r\n                // burn balance into the pair, effectively redistributing underlying tokens pro-rata back to LPs\r\n                // (assert because transfer cannot fail with value as balanceOf)\r\n                assert(IEliteswapV2Pair(pair).transfer(pair, value));\r\n                IEliteswapV2Pair(pair).burn(pair);\r\n            }\r\n\r\n            // if token0 is allowed, we can now update the pair's disallow count to match the token's\r\n            if (token0AllowState.allowed) {\r\n                pairAllowState.token0DisallowCount = token0AllowState.disallowCount;\r\n            }\r\n            // if token1 is allowed, we can now update the pair's disallow count to match the token's\r\n            if (token1AllowState.allowed) {\r\n                pairAllowState.token1DisallowCount = token1AllowState.disallowCount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function claim(address pair) public returns (uint value) {\r\n        PairAllowState storage pairAllowState = pairAllowStates[pair];\r\n        TokenAllowState storage token0AllowState = tokenAllowStates[IEliteswapV2Pair(pair).token0()];\r\n        TokenAllowState storage token1AllowState = tokenAllowStates[IEliteswapV2Pair(pair).token1()];\r\n\r\n        // we may claim only if each of the following five conditions are true:\r\n        // 1) token0 is currently allowed\r\n        // 2) token1 is currently allowed\r\n        // 3) renounce was not called since the last time token0 was disallowed\r\n        // 4) renounce was not called since the last time token1 was disallowed\r\n        // 5) feeHandler is not the 0 address\r\n        if (\r\n            token0AllowState.allowed &&\r\n            token1AllowState.allowed &&\r\n            token0AllowState.disallowCount == pairAllowState.token0DisallowCount &&\r\n            token1AllowState.disallowCount == pairAllowState.token1DisallowCount &&\r\n            feeRecipient != address(0)\r\n        ) {\r\n            value = IEliteswapV2Pair(pair).balanceOf(address(this));\r\n            if (value > 0) {\r\n                // transfer tokens to the handler (assert because transfer cannot fail with value as balanceOf)\r\n                assert(IEliteswapV2Pair(pair).transfer(feeRecipient, value));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IEliteswapV2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n}"
    }
  }
}