{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"TESS.sol":{"content":"pragma solidity ^ 0.4.19;\r\n\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function _msgSender() internal view returns (address)\r\n    {\r\n        return msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n\r\n  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\r\n\r\n    uint256 c = a * b;\r\n\r\n    assert(a == 0 || c / a == b);\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\r\n\r\n    assert(b > 0);\r\n\r\n    uint256 c = a / b;\r\n\r\n    assert(a == b * c + a % b);\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n\r\n  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\r\n\r\n    assert(b <= a);\r\n\r\n    return a - b;\r\n\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\r\n\r\n    uint256 c = a + b;\r\n\r\n    assert(c>=a && c>=b);\r\n\r\n    return c;\r\n\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n\r\n    if (!assertion) {\r\n\r\n      throw;\r\n\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\ncontract TESS is Ownable, SafeMath {\r\n\r\n    /* Public variables of the token */\r\n\r\n    string public name = 'TESS COIN';\r\n\r\n    string public symbol = 'TESS';\r\n\r\n    uint8 public decimals = 8;\r\n\r\n    uint256 public totalSupply =(3000000000  * (10 ** uint256(decimals)));\r\n\r\n    uint public TotalHoldersAmount;\r\n\r\n    /*Lock transfer from all accounts */\r\n\r\n    bool private Lock = false;\r\n\r\n    bool public CanChange = true;\r\n\r\n    address public admin;\r\n\r\n    address public AddressForReturn;\r\n\r\n    address[] Accounts;\r\n\r\n    /* This creates an array with all balances */\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n   /*Individual Lock*/\r\n\r\n    mapping(address => bool) public AccountIsLock;\r\n\r\n    /*Allow transfer for ICO, Admin accounts if IsLock==true*/\r\n\r\n    mapping(address => bool) public AccountIsNotLock;\r\n\r\n   /*Allow transfer tokens only to ReturnWallet*/\r\n\r\n    mapping(address => bool) public AccountIsNotLockForReturn;\r\n\r\n    mapping(address => uint) public AccountIsLockByDate;\r\n\r\n    mapping (address => bool) public isHolder;\r\n\r\n    mapping (address => bool) public isArrAccountIsLock;\r\n\r\n    mapping (address => bool) public isArrAccountIsNotLock;\r\n\r\n    mapping (address => bool) public isArrAccountIsNotLockForReturn;\r\n\r\n    mapping (address => bool) public isArrAccountIsLockByDate;\r\n\r\n    address [] public Arrholders;\r\n\r\n    address [] public ArrAccountIsLock;\r\n\r\n    address [] public ArrAccountIsNotLock;\r\n\r\n    address [] public ArrAccountIsNotLockForReturn;\r\n\r\n    address [] public ArrAccountIsLockByDate;\r\n\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n    event StartBurn(address indexed from, uint256 value);\r\n\r\n    event StartAllLock(address indexed account);\r\n\r\n    event StartAllUnLock(address indexed account);\r\n\r\n    event StartUseLock(address indexed account,bool re);\r\n    \r\n    event StartUseUnLock(address indexed account,bool re);\r\n\r\n    event StartAdmin(address indexed account);\r\n\r\n    event ReturnAdmin(address indexed account);\r\n\r\n    event PauseAdmin(address indexed account);\r\n\r\n    modifier IsNotLock{\r\n\r\n      require(((!Lock&&AccountIsLock[msg.sender]!=true)||((Lock)&&AccountIsNotLock[msg.sender]==true))&&now>AccountIsLockByDate[msg.sender]);\r\n\r\n      _;\r\n\r\n     }\r\n\r\n     modifier isCanChange{\r\n\r\n         if(CanChange == true)\r\n\r\n         {\r\n\r\n             require((msg.sender==owner||msg.sender==admin));\r\n\r\n         }\r\n\r\n         else if(CanChange == false)\r\n\r\n         {\r\n\r\n             require(msg.sender==owner);\r\n\r\n         }\r\n\r\n      _;\r\n\r\n     }\r\n\r\n     modifier whenNotPaused(){\r\n\r\n         require(!Lock);\r\n\r\n         _;\r\n\r\n     }\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n\r\n  function TESS() public {\r\n\r\n        balanceOf[msg.sender] = totalSupply;\r\n\r\n        Arrholders[Arrholders.length++]=msg.sender;\r\n\r\n        admin=msg.sender;\r\n\r\n    }\r\n\r\n     function AddAdmin(address _address) public onlyOwner{\r\n\r\n        require(CanChange);\r\n\r\n        admin=_address;\r\n\r\n        StartAdmin(admin);\r\n\r\n    }\r\n\r\n    modifier whenNotLock(){\r\n\r\n        require(!Lock);\r\n\r\n        _;\r\n\r\n    }\r\n\r\n    modifier whenLock() {\r\n\r\n        require(Lock);\r\n\r\n        _;\r\n\r\n    }\r\n\r\n    function AllLock()public isCanChange whenNotLock{\r\n\r\n        Lock = true;\r\n\r\n        StartAllLock(_msgSender()); \r\n\r\n    }\r\n    \r\n    function AllUnLock()public onlyOwner whenLock{\r\n\r\n        Lock = false;\r\n\r\n        StartAllUnLock(_msgSender()); \r\n\r\n    }\r\n\r\n    function UnStopAdmin()public onlyOwner{\r\n\r\n        CanChange = true;\r\n\r\n        ReturnAdmin(_msgSender());\r\n\r\n    }\r\n\r\n    function StopAdmin() public onlyOwner{\r\n\r\n        CanChange = false;\r\n\r\n        PauseAdmin(_msgSender());\r\n\r\n    }\r\n\r\n    function UseLock(address _address)public onlyOwner{\r\n\r\n    bool _IsLock = true;\r\n\r\n     AccountIsLock[_address]=_IsLock;\r\n\r\n     if (isArrAccountIsLock[_address] != true) {\r\n\r\n        ArrAccountIsLock[ArrAccountIsLock.length++] = _address;\r\n\r\n        isArrAccountIsLock[_address] = true;\r\n\r\n    }if(_IsLock == true){\r\n\r\n    StartUseLock(_address,_IsLock);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function UseUnLock(address _address)public onlyOwner{\r\n\r\n        bool _IsLock = false;\r\n\r\n     AccountIsLock[_address]=_IsLock;\r\n\r\n     if (isArrAccountIsLock[_address] != true) {\r\n\r\n        ArrAccountIsLock[ArrAccountIsLock.length++] = _address;\r\n\r\n        isArrAccountIsLock[_address] = true;\r\n\r\n    }\r\n\r\n    if(_IsLock == false){\r\n\r\n    StartUseUnLock(_address,_IsLock);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /* Send coins */\r\n\r\n    function transfer(address _to, uint256 _value) public  {\r\n\r\n        require(((!Lock&&AccountIsLock[msg.sender]!=true)||((Lock)&&AccountIsNotLock[msg.sender]==true)||(AccountIsNotLockForReturn[msg.sender]==true&&_to==AddressForReturn))&&now>AccountIsLockByDate[msg.sender]);\r\n\r\n        require(_to != 0x0);\r\n\r\n        require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\r\n\r\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\r\n\r\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\r\n\r\n        balanceOf[_to] += _value; // Add the same to the recipient\r\n\r\n        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\r\n\r\n        if (isHolder[_to] != true) {\r\n\r\n        Arrholders[Arrholders.length++] = _to;\r\n\r\n        isHolder[_to] = true;\r\n\r\n    }}\r\n\r\n\r\n    /* A contract attempts to get the coins */\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)public IsNotLock returns(bool success)  {\r\n\r\n        require(((!Lock&&AccountIsLock[_from]!=true)||((Lock)&&AccountIsNotLock[_from]==true))&&now>AccountIsLockByDate[_from]);\r\n\r\n        require (balanceOf[_from] >= _value) ; // Check if the sender has enough\r\n\r\n        require (balanceOf[_to] + _value >= balanceOf[_to]) ; // Check for overflows\r\n\r\n        require (_value <= allowance[_from][msg.sender]) ; // Check allowance\r\n\r\n        balanceOf[_from] -= _value; // Subtract from the sender\r\n\r\n        balanceOf[_to] += _value; // Add the same to the recipient\r\n\r\n        allowance[_from][msg.sender] -= _value;\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        if (isHolder[_to] != true) {\r\n\r\n        Arrholders[Arrholders.length++] = _to;\r\n\r\n        isHolder[_to] = true;\r\n\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n /* @param _value the amount of money to burn*/\r\n\r\n    function Burn(uint256 _value)public onlyOwner returns (bool success) {\r\n\r\n        require(msg.sender != address(0));\r\n\r\n        if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough\r\n\r\n\t\tif (_value <= 0) throw; \r\n\r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender\r\n\r\n        totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply\r\n\r\n        Transfer(msg.sender,address(0),_value);\r\n\r\n        StartBurn(msg.sender, _value);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    function GetHoldersCount () public view returns (uint _HoldersCount){\r\n\r\n         return (Arrholders.length-1);\r\n\r\n    }\r\n\r\n    function GetAccountIsLockCount () public view returns (uint _Count){\r\n\r\n         return (ArrAccountIsLock.length);\r\n\r\n    }\r\n\r\n    function GetAccountIsNotLockForReturnCount () public view returns (uint _Count){\r\n\r\n         return (ArrAccountIsNotLockForReturn.length);\r\n\r\n    }\r\n\r\n    function GetAccountIsNotLockCount () public view returns (uint _Count){\r\n\r\n         return (ArrAccountIsNotLock.length);\r\n\r\n    }\r\n\r\n     function GetAccountIsLockByDateCount () public view returns (uint _Count){\r\n\r\n         return (ArrAccountIsLockByDate.length);\r\n\r\n    }\r\n\r\n   function () public payable {\r\n\r\n         revert();\r\n\r\n    }\r\n\r\n\r\n}"}}}