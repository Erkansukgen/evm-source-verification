{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/PiraAdminModifier.sol":{"content":"//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./interfaces/IPiraAdmin.sol\";\r\n\r\ncontract PiraAdminModifier {\r\n    address _piraAdminContractAddress;\r\n\r\n    constructor(address adminContract){\r\n        _piraAdminContractAddress = adminContract;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        IPiraAdmin adminContract = IPiraAdmin(_piraAdminContractAddress);\r\n        require(adminContract.isAdmin(msg.sender), \"Only admins are allowed to call this method.\");\r\n        _;\r\n    }\r\n}\r\n"},"contracts/PiraRoyalty.sol":{"content":"//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./interfaces/IPiraRoyalty.sol\";\r\nimport \"./PiraAdminModifier.sol\";\r\n\r\ncontract PiraRoyalty is IPiraRoyalty, PiraAdminModifier {\r\n    mapping(string => RoyaltyRule) private _rules;\r\n    mapping(address => mapping(uint256 => string)) private _itemRules; //TokenContract[TokenId][RuleId]\r\n    mapping(address => mapping(uint256 => uint256)) private _customRoyalty; //TokenContract[TokenId][RoyaltyValue]\r\n\r\n    constructor(address adminContractAddress)\r\n        PiraAdminModifier(adminContractAddress)\r\n    {}\r\n\r\n    function setRoyaltyRule(\r\n        string memory royaltyHash,\r\n        uint256 firstSalePiraFee,\r\n        uint256 otherSalesPiraFee,\r\n        uint256 puchasePiraFee,\r\n        uint256 piraRoyalty,\r\n        uint256 authorRoyalty\r\n    ) public override onlyAdmin returns (bool) {\r\n        require(\r\n            bytes(royaltyHash).length > 0,\r\n            \"PiraRoyalty: royaltyHash must be a valid hash.\"\r\n        );\r\n\r\n        _rules[royaltyHash] = RoyaltyRule(\r\n            firstSalePiraFee,\r\n            otherSalesPiraFee,\r\n            puchasePiraFee,\r\n            piraRoyalty,\r\n            authorRoyalty,\r\n            true\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    function deleteRoyaltyRule(string memory royaltyHash)\r\n        public\r\n        override\r\n        onlyAdmin\r\n    {\r\n        require(\r\n            bytes(royaltyHash).length > 0,\r\n            \"PiraRoyalty: royaltyHash must be a valid hash.\"\r\n        );\r\n\r\n        _rules[royaltyHash] = RoyaltyRule(0, 0, 0, 0, 0, false);\r\n    }\r\n\r\n    function setMassItemRoyaltyRule(ItemRule[] memory items)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < items.length; i++) {\r\n            this.setItemRoyaltyRule(\r\n                items[i].tokenContract,\r\n                items[i].royaltyHash,\r\n                items[i].tokenIds\r\n            );\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setItemRoyaltyRule(\r\n        address tokenContract,\r\n        string memory royaltyHash,\r\n        uint256[] memory tokenIds\r\n    ) public override returns (bool) {\r\n        require(\r\n            tokenContract != address(0),\r\n            \"PiraRoyalty: tokenContract must be a valid address.\"\r\n        );\r\n\r\n        require(\r\n            (bytes(royaltyHash).length == 0) ||\r\n                (bytes(royaltyHash).length > 0 &&\r\n                    this.checkRoyaltyRule(royaltyHash)),\r\n            \"PiraRoyalty: royaltyHash must be a valid hash.\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            if (bytes(royaltyHash).length == 0) {\r\n                _itemRules[tokenContract][tokenIds[i]] = \"\";\r\n            } else {\r\n                _itemRules[tokenContract][tokenIds[i]] = royaltyHash;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function setItemRoyaltyValue(\r\n        address tokenContract,\r\n        uint256 tokenId,\r\n        uint256 value\r\n    ) public override returns (bool) {\r\n        _customRoyalty[tokenContract][tokenId] = value;\r\n        return true;\r\n    }\r\n\r\n    function getRoyaltyRule(string memory royaltyHash)\r\n        public\r\n        view\r\n        override\r\n        returns (RoyaltyRule memory)\r\n    {\r\n        require(\r\n            bytes(royaltyHash).length > 0,\r\n            \"PiraRoyalty: royaltyHash must be a valid hash.\"\r\n        );\r\n        require(\r\n            _rules[royaltyHash].exists,\r\n            \"PiraRoyalty: royaltyHash does not exists.\"\r\n        );\r\n        return _rules[royaltyHash];\r\n    }\r\n\r\n    function getItemRoyaltyValue(address tokenContract, uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            tokenContract != address(0),\r\n            \"PiraRoyalty: tokenContract must be a valid address.\"\r\n        );\r\n        require(tokenId >= 0, \"PiraNFT: tokenId must be a valid id.\");\r\n\r\n        return _customRoyalty[tokenContract][tokenId];\r\n    }\r\n\r\n    function getItemRoyaltyRuleDetails(address tokenContract, uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (RoyaltyRule memory)\r\n    {\r\n        require(\r\n            tokenContract != address(0),\r\n            \"PiraRoyalty: tokenContract must be a valid address.\"\r\n        );\r\n        require(tokenId >= 0, \"PiraNFT: tokenId must be a valid id.\");\r\n        require(\r\n            _rules[_itemRules[tokenContract][tokenId]].exists,\r\n            \"PiraRoyalty: item does not contains royalty rule.\"\r\n        );\r\n        return _rules[_itemRules[tokenContract][tokenId]];\r\n    }\r\n\r\n    function checkRoyaltyRule(string memory royaltyHash)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(\r\n            bytes(royaltyHash).length > 0,\r\n            \"PiraRoyalty: royaltyHash must be a valid hash.\"\r\n        );\r\n        return _rules[royaltyHash].exists;\r\n    }\r\n\r\n    function checkRoyaltyRuleByTokenId(address tokenContract, uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n         require(\r\n            tokenContract != address(0),\r\n            \"PiraRoyalty: tokenContract must be a valid address.\"\r\n        );\r\n        require(tokenId >= 0, \"PiraNFT: tokenId must be a valid id.\");\r\n\r\n        return _rules[_itemRules[tokenContract][tokenId]].exists;\r\n    }\r\n}\r\n"},"contracts/interfaces/IPiraAdmin.sol":{"content":"//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.4;\r\n\r\ninterface IPiraAdmin {\r\n\r\n    function grant(address admin) external returns(bool);\r\n\r\n    function revoke(address admin) external returns(bool);\r\n\r\n    function isAdmin(address admin) external view returns(bool);\r\n\r\n    function getAdmins() external view returns(address[] memory);\r\n}"},"contracts/interfaces/IPiraRoyalty.sol":{"content":"//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./IPiraUtil.sol\";\r\n\r\ninterface IPiraRoyalty is IPiraUtil {\r\n    struct ItemRule {\r\n        address tokenContract;\r\n        string royaltyHash;\r\n        uint256[] tokenIds;\r\n    }\r\n\r\n    function setMassItemRoyaltyRule(ItemRule[] memory items)\r\n        external\r\n        returns (bool);\r\n\r\n    function setRoyaltyRule(\r\n        string memory royaltyHash,\r\n        uint256 firstSalePiraFee,\r\n        uint256 otherSalesPiraFee,\r\n        uint256 puchasePiraFee,\r\n        uint256 piraRoyalty,\r\n        uint256 authorRoyalty\r\n    ) external returns (bool);\r\n\r\n    function deleteRoyaltyRule(string memory royaltyHash) external;\r\n\r\n    function setItemRoyaltyRule(\r\n        address tokenContract,\r\n        string memory royaltyHash,\r\n        uint256[] memory tokenIds\r\n    ) external returns (bool);\r\n\r\n    function setItemRoyaltyValue(\r\n        address tokenContract,\r\n        uint256 tokenId,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function getItemRoyaltyValue(address tokenContract, uint256 tokenId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getRoyaltyRule(string memory royaltyHash)\r\n        external\r\n        view\r\n        returns (RoyaltyRule memory);\r\n\r\n    function getItemRoyaltyRuleDetails(address tokenContract, uint256 tokenId)\r\n        external\r\n        view\r\n        returns (RoyaltyRule memory);\r\n\r\n    function checkRoyaltyRule(string memory royaltyHash)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function checkRoyaltyRuleByTokenId(address tokenContract, uint256 tokenId)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n"},"contracts/interfaces/IPiraUtil.sol":{"content":"//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.4;\r\n\r\ninterface IPiraUtil {\r\n        struct RoyaltyRule {\r\n        uint256 firstSalePiraFee;\r\n        uint256 otherSalesPiraFee;\r\n        uint256 puchasePiraFee;\r\n        uint256 piraRoyalty;\r\n        uint256 authorRoyalty;\r\n        bool exists;\r\n    }\r\n}\r\n"}}}