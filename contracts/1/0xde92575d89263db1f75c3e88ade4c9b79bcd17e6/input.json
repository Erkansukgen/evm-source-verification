{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/interfaces/v3pool.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    /*\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n    */\n\n}\n"
    },
    "contracts/lib/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.5.0 <0.8.0;\n\nlibrary BytesLib {\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, 'toAddress_overflow');\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, 'toUint24_overflow');\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
    },
    "contracts/lib/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport './BytesLib.sol';\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n\n\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n}\n"
    },
    "contracts/lib/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        //require(key.token0 < key.token1);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        bytes32(0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54)\n                    )\n                )\n            )\n        );\n    }\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n  \n}"
    },
    "contracts/sweepermem.sol": {
      "content": "pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './lib/SafeMath.sol';\nimport './lib/PoolAddress.sol';\nimport './lib/Path.sol';\nimport './interfaces/v3pool.sol';\n\ninterface v2router{\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    \n    function addLiquidity(\n            address tokenA,\n            address tokenB,\n            uint amountADesired,\n            uint amountBDesired,\n            uint amountAMin,\n            uint amountBMin,\n            address to,\n            uint deadline\n        ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n            address token,\n            uint liquidity,\n            uint amountTokenMin,\n            uint amountETHMin,\n            address to,\n            uint deadline\n        ) external;\n\n}\n\ninterface v3router{\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;  \n}\n\ninterface v2pool{\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\ninterface IWETH {\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n}\n\n\ncontract memsweeper{\n    using SafeMath for uint;\n    using Path for bytes;\n    \n    address payable public owner;\n\n    address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IWETH private constant WETH = IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    \n\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n    function withdrawethall() external onlyowner {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n    function approvetoken(address token, address target) external onlyowner {\n        IERC20(address(token)).approve(target, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    }\n\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    } \n\n\n\n    struct SwapCallbackData {\n        bytes path;\n        address payer;\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();\n        \n        // verify caller to make it safe\n        address addr_p = PoolAddress.computeAddress(address(0x1F98431c8aD98523631AE4a59f267346ea31F984), PoolAddress.getPoolKey(tokenIn, tokenOut, fee));\n        require(msg.sender == addr_p);\n\n        (bool isExactInput, uint256 amountToPay) =\n            amount0Delta > 0\n                ? (tokenIn < tokenOut, uint256(amount0Delta))\n                : (tokenOut < tokenIn, uint256(amount1Delta));\n        \n        if (isExactInput) {\n            _safeTransfer(tokenIn, msg.sender, amountToPay);\n        } else {\n            _safeTransfer(tokenIn, msg.sender, amountToPay);\n        }\n    }\n\n    function v2swap(address pool, bool first, uint256 amountin) private returns(uint256 amountOut){\n        (uint112 r1, uint112 r2, ) = v2pool(pool).getReserves();\n        \n        if(first){\n            amountOut = getAmountOut(amountin, r1, r2);\n            v2pool(pool).swap(0, amountOut, address(this), new bytes(0));\n        }else{\n            amountOut = getAmountOut(amountin, r2, r1);\n            v2pool(pool).swap(amountOut, 0, address(this), new bytes(0));\n        }\n    \n    }\n\n    function sweepv2router(address router, address targettoken, address pooladdr) public returns(uint256 benefit){\n        uint256 target_balance;\n        target_balance = IERC20(targettoken).balanceOf(router);\n        require(target_balance > 0, \"shit\");\n\n        // swap target token out\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        bool first = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) < targettoken;\n        _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), pooladdr, 1000000000000000);\n        v2swap(pooladdr, first, 1000000000000000);\n       \n        target_balance = IERC20(targettoken).balanceOf(address(this));\n        IERC20(targettoken).approve(router, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).approve(router, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        // supply liq\n        (, , uint liqamount) = v2router(router).addLiquidity(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), targettoken, 1100000000000000, target_balance, 1, 1, address(this), 2939949778);\n        \n        IERC20(pooladdr).approve(router, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        \n        // remove liq\n        v2router(router).removeLiquidityETHSupportingFeeOnTransferTokens(targettoken, liqamount, 1,1, address(this), 2939949778);\n        \n        // swap target token to eth\n        uint256 token_before = IERC20(targettoken).balanceOf(pooladdr);\n        target_balance = IERC20(targettoken).balanceOf(address(this));\n        _safeTransfer(targettoken, pooladdr, target_balance);\n        v2swap(pooladdr, !first, IERC20(targettoken).balanceOf(pooladdr) - token_before);\n\n\n        // reuse target_balance to store new weth balance\n        target_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        require(target_balance > weth_balance, \"fuck\");\n        \n        benefit =  target_balance - weth_balance;\n        \n    }\n    \n\n    function detectskim(address pool) public view returns(uint256 d1, uint256 d2){\n        (uint112 r0, uint112 r1, ) = v2pool(pool).getReserves();\n        address t0 = v2pool(pool).token0();\n        address t1 = v2pool(pool).token1();\n        \n        d1 = IERC20(t0).balanceOf(pool) - r0;\n        d2 = IERC20(t1).balanceOf(pool) - r1;\n    }\n\n\n    function sweepv2poolskim(address pool, address[] calldata tokens, address[] calldata pools) external returns(uint256 benefit){\n\n        uint256 balance_before;\n        uint256 token_balance;\n\n        // first detect skim\n        (balance_before, token_balance) = detectskim(pool);\n        \n        require(balance_before > 0 || token_balance > 0, \"shit\");\n        \n        \n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n\n        v2pool(pool).skim(address(this));\n        \n\n        uint256 amountin;\n        bool first;\n\n        \n        for(uint i=0; i < pools.length; i++){\n            token_balance = IERC20(tokens[i]).balanceOf(address(this));\n            balance_before = IERC20(tokens[i]).balanceOf(pools[i]);\n            \n            _safeTransfer(tokens[i], pools[i], token_balance);\n            \n            first = tokens[i] < tokens[i+1];\n            \n            v2swap(pools[i], first, IERC20(tokens[i]).balanceOf(pools[i]) - balance_before);\n        }\n\n        token_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        require(token_balance > weth_balance, \"fuck\");\n        \n        benefit = token_balance - weth_balance;\n        \n        \n    }\n \n    function sweepv2poolburn(address pool, address[] calldata tokens, address[] calldata pools) external returns(uint256 benefit){\n\n\n        uint256 balance_before;\n        uint256 token_balance;\n        bool first;\n\n        // reuse token_balance to store the uni balanceOf pool\n        token_balance = IERC20(pool).balanceOf(pool);\n        require(token_balance > 0, \"shit\");\n\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n\n        v2pool(pool).burn(address(this));\n \n        for(uint i=0; i < pools.length; i++){\n            token_balance = IERC20(tokens[i]).balanceOf(address(this));\n            balance_before = IERC20(tokens[i]).balanceOf(pools[i]);\n            \n            _safeTransfer(tokens[i], pools[i], token_balance);\n            \n            first = tokens[i] < tokens[i+1];\n            \n            v2swap(pools[i], first, IERC20(tokens[i]).balanceOf(pools[i]) - balance_before);\n        }    \n  \n        token_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        require(token_balance > weth_balance, \"fuck\");\n \n        benefit = token_balance - weth_balance;\n     \n    }\n \n \n    // swap function that skips the router\n    function v3swap(address pool, address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 amountIn) private returns (uint256 amountOut){\n    \n        bool zeroForOne = tokenIn < tokenOut;\n        \n        bytes memory swapbackdata = abi.encode(SwapCallbackData({path: abi.encodePacked(tokenIn, fee, tokenOut), payer: address(this)}));\n        \n        \n        (int256 amount0, int256 amount1) = v3pool(pool).swap(recipient, zeroForOne, int256(amountIn), \n                       zeroForOne ? 4295128739 + 1 : 1461446703485210103287273052203988822378723970342 - 1, swapbackdata);\n        \n        \n        // re use amountIn to save some gas here\n        amountIn = uint256(-(zeroForOne ? amount1 : amount0));\n        \n        return(amountIn);\n    \n    } \n   \n    \n    function v3routersweep(address targettoken, uint256[] calldata pools, address[] calldata tokens) external returns(uint256 benefit){\n\n        uint256 weth_balance;\n\n        weth_balance = IERC20(targettoken).balanceOf(address(0xE592427A0AEce92De3Edee1F18E0157C05861564));\n        require(weth_balance > 0, \"shit\");\n\n        weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        v3router(address(0xE592427A0AEce92De3Edee1F18E0157C05861564)).sweepToken(targettoken, 0, address(this));\n        //uint256 flag;\n        uint256 amountin;\n        bool first;\n        address swappool;\n        for(uint i=0; i < pools.length; i++){\n            // flag = (pools[i] >> 160) & 0xff;    \n            swappool = address(pools[i] & 0x00ffffffffffffffffffffffffffffffffffffffff);\n            if((pools[i] >> 160) & 0xff == 1){\n                amountin = IERC20(tokens[i]).balanceOf(address(this));\n                v3swap(swappool, tokens[i], tokens[i+1], uint24(pools[i] >> 168), address(this), amountin);\n            }else{\n                first = tokens[i] < tokens[i+1];\n                amountin = IERC20(tokens[i]).balanceOf(address(this));\n                _safeTransfer(tokens[i], address(pools[i] & 0x00ffffffffffffffffffffffffffffffffffffffff), amountin);\n                v2swap(swappool, first, amountin);\n            }\n        }\n        \n        benefit = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        require(benefit > weth_balance, \"fuck\");\n        \n        benefit = benefit - weth_balance;\n\n\n    }\n    \n    \n\n}"
    }
  }
}