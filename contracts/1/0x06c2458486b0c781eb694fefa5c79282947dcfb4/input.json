{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/ethersport11.v2.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.7;\n\ncontract EtherSport11 {\n\n    receive() external payable {\n        _accumulatedFunds += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    address payable _owner;\n    address payable _nextOwner;\n\n    address[] _approvers;\n    uint _requiredApprovals;\n\n    //// contract properties\n    uint _ticketPrice = 0.05 ether; // wei\n    uint _commission = 30; // percents\n    uint[12] _rewards = [0, 0, 0, 0, 0, 0, 0, 14, 16, 20, 24, 26]; // as map [guessedEvents => rewardPercents]\n\n    uint _commissionFunds;\n    uint _accumulatedFunds;\n    ////\n\n    //// lottery types\n    //    uint constant EVRES_FIRST_WON = 1;\n    //    uint constant EVRES_SECOND_WON = 2;\n    //    uint constant EVRES_DRAW = 3;\n\n    uint constant ST_OPEN = 0x01;\n    uint constant ST_STARTED = 0x02; // virtual state (now >= startTimestamp) - doesn't realy stored to Line.state\n    uint constant ST_FINISHED = 0x04;\n    uint constant ST_CANCELED = 0x80;\n\n    uint constant PAYOUT_PRIZE = 1;\n    uint constant PAYOUT_REFUND = 2;\n\n    uint constant PAYOUT_SUCCESSFUL = 1;\n    uint constant PAYOUT_FAILED = 2;\n\n    event NewLine(uint lineId);\n    event NewTicket(address from, uint lineId, uint ticketIndex);\n    event Payout(address indexed to, uint lineId, uint ticketIndex, uint amount, uint guessedEvents, uint payoutType);\n    event Deposit(address from, uint amount);\n    event Error(uint error);\n\n    struct Event {\n        uint leagueIndex; // index of Line.leagues\n        uint startTime;\n        bytes32 player1; // name of player 1\n        bytes32 player2; // name of player 2\n        bool drawAllowed; // is draw allowed\n        uint result; // result (line finished); 1 - first won; 2 - second won; 3 - draw\n    }\n\n    // BIT shifts for ticket data\n    //    uint constant TDSH_BLOCKNUMBER = 0x00;\n    uint constant TDSH_TIMESTAMP = 0x20;\n    uint constant TDSH_ANSWERS = 0x40;\n    uint constant TDSH_GUESSED_EVENTS = 0x80;\n    uint constant TDSH_PAYOUT_TYPE = 0x88;\n    uint constant TDSH_PAYOUT_STATE = 0x90;\n\n    struct Ticket {\n        address payable user; // address of user\n        // data:\n        // 0x00: TicketData.blockNumber;   transaction block number\n        // 0x20: TicketData.timestamp;     transaction block timestamp\n        // 0x40: TicketData.answers;       chosen events results 2 bits right-to-left\n        // 0x80: TicketData.guessedEvents; guessed events; filled after line has been finished\n        // 0x81: TicketData.payoutType;    PAYOUT_PRIZE | PAYOUT_REFUND\n        // 0x82: TicketData.payoutState;   PAYOUT_SUCCESSFUL | PAYOUT_FAILED\n        uint data;\n    }\n\n    struct TicketData {\n        uint blockNumber; // transaction block number\n        uint timestamp; // transaction block timestamp\n        uint answers; // chosen events results 2 bits right-to-left\n        uint guessedEvents; // guessed events; filled after line has been finished\n        uint payoutType; // PAYOUT_PRIZE | PAYOUT_REFUND\n        uint payoutState; // PAYOUT_SUCCESSFUL | PAYOUT_FAILED\n    }\n\n    struct Line {\n        uint id;\n        uint state; // see ST_*\n        address[] approvals;\n        uint startTimestamp;\n        uint ticketPrice;\n        uint commission; // percents of commission\n        uint[12] rewards; // percents of reward by count of gueessed events: guessedEvents => rewardPercentsOfPrizeFunds\n        bytes32[] leagues;\n        Event[11] events;\n        Ticket[] tickets;\n        uint accumulatedFunds; // copied contract accumulatedFunds when line finished\n        uint _refundedTicketsCount; // calculates at line finish for technical reason (gas optimization)\n    }\n    ////\n\n    //// lottery payout types\n    struct Revenue {\n        uint events; // guessed events of this revenue\n        uint guessed; // count of tickets that guessed this number of `events`\n        uint totalGuessed; // with sub events\n        uint amount; // amount of revenue for each ticket\n        bool isJackpot; // if `events` == `maxEvents`\n        uint[13] details; // details of sub events\n    }\n\n    struct PayoutData {\n        uint refundedFunds; // total wei refunded to users that bought ticket after line.startTimestamp\n        uint totalFunds; // total wei collected from all tickets (ticketPrice * ticketsCount - refundedFunds)\n        uint commissionFunds; // wei\n        uint prizeFunds; // wei; totalFunds - commissionFunds\n        uint accumulatedFunds; // wei; lottery's accumulated funds at line finished moment (line.accumulatedFunds)\n        uint paidFunds; // wei; total amount (be) paid to users\n        uint heldFunds; // wei; amount left after\n        bool hasJackpot; // whether is max events count was guessed\n        Revenue[12] revenues;\n    }\n    ////\n\n    //// lottery storage\n    uint _lastLineId = 0;\n\n    mapping(uint => Line) _lines;\n    uint[] _linesIter;\n\n    Line _tmpLine; // technical\n    ////\n\n    //// modifiers\n    modifier ownerOnly() {\n        require(msg.sender == _owner/*, \"Only owner can call this function.\"*/);\n        _;\n    }    \n \n    constructor() {\n        _owner = payable(msg.sender);\n    }\n\n    //// contract properties getters\n    function getProperties() external view returns (\n        address owner,\n        uint eventsPerLine,\n        uint ticketPrice,\n        uint commission,\n        uint[12] memory rewards,\n        uint commissionFunds,\n        uint accumulatedFunds,\n        uint requiredApprovals,\n        address[] memory approvers\n    ) {\n        owner = _owner;\n        eventsPerLine = 11;\n        ticketPrice = _ticketPrice;\n        commission = _commission;\n        rewards = _rewards;\n        commissionFunds = _commissionFunds;\n        accumulatedFunds = _accumulatedFunds;\n        requiredApprovals = _requiredApprovals;\n        approvers = _approvers;\n    }\n    ////\n\n    //// contract control function\n    function setTicketPrice(uint price) external ownerOnly {\n        require(price > 0/*, \"Price must be more than 0\"*/);\n        _ticketPrice = price;\n    }\n\n    function setCommission(uint commission) external ownerOnly {\n        require(commission >= 0 && commission < 100/*, \"Commission must be in [0;100)\"*/);\n\n        _commission = commission;\n    }\n\n    function setRewards(uint[12] calldata rewards) external ownerOnly {\n        uint totalRewards = 0;\n        for (uint i = 0; i < rewards.length; i++) {\n            uint reward = rewards[i];\n\n            // check reward in percents to be correct;\n            require(reward >= 0 && reward <= 100/*, \"Reward must be in [0;100]\"*/);\n\n            // check total rewards not more than 100%;\n            totalRewards += reward;\n            require(totalRewards <= 100/*, \"Sum of all rewards can't be more than 100%\"*/);\n        }\n\n        _rewards = rewards;\n    }\n\n\n    function withdrawCommission(uint amount) external ownerOnly {\n        withdrawCommission(amount, _owner);\n    }\n\n    function withdrawCommission(uint amount, address payable to) public ownerOnly {\n        require(amount <= _commissionFunds, \"Insufficient funds\");\n        _commissionFunds -= amount;\n        to.transfer(amount);\n    }\n\n    function setRequiredApprovals(uint requiredApprovals) external ownerOnly {\n        _requiredApprovals = requiredApprovals;\n    }\n\n    function setApprovers(address[] calldata approvers) external ownerOnly {\n        _approvers = approvers;\n    }\n\n    // This is pretty standard ownership change routine.\n    function approveNextOwner(address payable nextOwner) external ownerOnly {\n        require(nextOwner != _owner/*, \"Next owner and current owner are same\"*/);\n        _nextOwner = nextOwner;\n    }\n\n    function acceptNextOwner() external {\n        require(msg.sender == _nextOwner/*, \"Caller is not next owner\"*/);\n        _owner = _nextOwner;\n    }\n\n    function destroy(uint lastLineId) external ownerOnly {\n        require(_lastLineId == lastLineId/*, \"Onwer must set correct last lineId\"*/);\n        selfdestruct(_owner);\n    }\n\n    //// line control functions\n    function addLine(\n        bytes32[] calldata leagues,\n        uint[11] calldata leagueIndexes,\n        uint[11] calldata startTimes,\n        bytes32[2][11] calldata players,\n        bool[11] calldata draws,\n        uint startTimestamp\n    )\n    external ownerOnly returns (uint lineId) {\n        uint leaguesLen = leagues.length;\n        bool hasLeagues = leaguesLen > 0;\n        if (hasLeagues) {\n            require(leaguesLen <= 11/*, \"Leagues count can't be more than events count\"*/);\n            for (uint i = 0; i < 11; i++) {\n                require(leagueIndexes[0] < leaguesLen/*, \"Invalid league index for event\"*/);\n            }\n        }\n        require(startTimestamp > block.timestamp, \"Start Timestamp must be in future\");\n        require(startTimestamp <= 0xFFFFFFFF);\n\n        lineId = ++_lastLineId;\n\n        delete _tmpLine;\n        _tmpLine.id = lineId;\n        _tmpLine.state = ST_OPEN;\n        _tmpLine.startTimestamp = startTimestamp;\n\n        _tmpLine.ticketPrice = _ticketPrice;\n        _tmpLine.commission = _commission;\n        _tmpLine.rewards = _rewards;\n\n        _tmpLine.leagues = leagues;\n        for (uint i = 0; i < 11; i++) {\n            _tmpLine.events[i] = Event({\n                leagueIndex : hasLeagues ? leagueIndexes[i] : 0,\n                startTime : startTimes[i],\n                player1 : players[i][0],\n                player2 : players[i][1],\n                drawAllowed : draws[i],\n                result : 0\n                });\n        }\n\n        _lines[lineId] = _tmpLine;\n        _linesIter.push(lineId);\n        emit NewLine(lineId);\n    }\n\n    function setLineStartTimestamp(uint lineId, uint startTimestamp) external ownerOnly {\n        require(startTimestamp > 0/*, \"Start Timestamp is empty\"*/);\n        findLine(lineId, ST_OPEN).startTimestamp = startTimestamp;\n    }\n\n    function finishLine(uint lineId, uint[11] calldata results, uint startTimestamp) external returns (uint error) {\n        // check access (owner or approver)\n        bool isOwner = msg.sender == _owner;\n        uint requiredApprovals = _requiredApprovals;\n        require(isOwner || (requiredApprovals > 0 && isApprover())/*, \"Access denide (only owner or approver)\"*/);\n\n        // find open Line\n        Line storage line = findLine(lineId, ST_OPEN);\n\n        // check duplicate approvals (except Owner)\n        uint approvalsCount;\n        if (requiredApprovals > 0) {\n            if (!isOwner) {\n                address[] memory mApprovals = line.approvals;\n                approvalsCount = mApprovals.length;\n                for (uint i = 0; i < approvalsCount; i++) {\n                    require(msg.sender != mApprovals[i], \"Approver result is already accepted\");\n                }\n            } else {\n                approvalsCount = line.approvals.length;\n            }\n        }\n\n        // check and init start timestamp\n        if (startTimestamp > 0) {\n            line.startTimestamp = startTimestamp;\n        } else {\n            startTimestamp = line.startTimestamp;\n        }\n        require(block.timestamp >= startTimestamp, \"Line not started yet\");\n\n        // validate results\n        for (uint i = 0; i < results.length; i++) {\n            Event storage ev = line.events[i];\n            uint res = results[i];\n            uint maxres = ev.drawAllowed ? 3 : 2;\n            require(res > 0 && res <= maxres/*, \"Not valid result\"*/);\n\n            if (approvalsCount == 0) {\n                ev.result = res;\n            } else if (res != ev.result) {\n                delete line.approvals;\n                emit Error(1);\n                return 1;\n            }\n        }\n\n        if (requiredApprovals > 0) {\n            line.approvals.push(msg.sender);\n            if (approvalsCount + 1 < _requiredApprovals) {\n                return 0;\n            }\n        }\n\n        // set state\n        line.state = ST_FINISHED;\n        // save accumulatedFunds for calculating payout\n        line.accumulatedFunds = _accumulatedFunds;\n\n        // init result data for every ticket in line\n        uint ticklen = line.tickets.length;\n        uint refundedTicketsCount = 0;\n        uint[12] memory rewards = line.rewards;\n        for (uint i = 0; i < ticklen; i++) {\n            Ticket storage ticket = line.tickets[i];\n            TicketData memory data = parseTicketData(ticket.data);\n\n            // check ticket timestamp and blockNumber\n            if (data.timestamp > startTimestamp) {\n                // if ticket was bought after the result became known, mark ticket for refund\n                data.payoutType = PAYOUT_REFUND;\n                ticket.data = buildTicketData(data);\n                refundedTicketsCount++;\n                continue;\n            }\n\n            // calculate number of guessed events\n            uint guessedEvents = calcGuessedEvents(data.answers, results);\n            data.guessedEvents = guessedEvents;\n\n            if (rewards[guessedEvents] > 0) {\n                data.payoutType = PAYOUT_PRIZE;\n            }\n            ticket.data = buildTicketData(data);\n        }\n        line._refundedTicketsCount = refundedTicketsCount;\n\n        // process payout\n        PayoutData memory payout = buildPayoutData(line);\n\n        if (payout.hasJackpot) {\n            _accumulatedFunds = payout.heldFunds;\n        } else {\n            _accumulatedFunds += payout.heldFunds;\n        }\n        _commissionFunds += payout.commissionFunds;\n\n        runPayout(line, payout);\n    }\n\n    function payoutLine(uint lineId) external ownerOnly {\n        Line storage line = findLine(lineId, ST_FINISHED);\n        PayoutData memory payout = buildPayoutData(line);\n\n        runPayout(line, payout);\n    }\n\n    function cancelLine(uint lineId) external ownerOnly {\n        Line storage line = findLine(lineId, ST_OPEN);\n        line.state = ST_CANCELED;\n\n        runCanceledPayout(line);\n    }\n\n    function payoutCanceledLine(uint lineId) external ownerOnly {\n        runCanceledPayout(\n            findLine(lineId, ST_CANCELED)\n        );\n    }\n\n    function removeLine(uint id) external ownerOnly {\n        Line memory line = findLine(id, ST_FINISHED | ST_CANCELED);\n\n        uint ticklen = line.tickets.length;\n        uint[12] memory rewards = line.rewards;\n        for (uint i = 0; i < ticklen; i++) {\n            // unreachable case, but... just in case\n            TicketData memory data = parseTicketData(line.tickets[i].data);\n            if (rewards[data.guessedEvents] > 0) {\n                require(data.payoutState != 0, \"Ticket has empty payout state\");\n            }\n        }\n\n        bool found;\n        uint len = _linesIter.length;\n        for (uint i = 0; i < len; i++) {\n            uint iid = _linesIter[i];\n            if (found) {\n                _linesIter[i - 1] = iid;\n                continue;\n            }\n            found = iid == id;\n        }\n        _linesIter.pop();\n\n        delete _lines[id];\n    }\n    ////\n\n    //// user functions\n    function buyTicket(uint lineId, uint answers) external payable returns (uint ticketIndex) {\n        Line storage line = findLine(lineId, ST_OPEN);\n\n        require(block.timestamp <= line.startTimestamp, \"The Line is already started (timestamp restriction)\");\n        require(msg.value == line.ticketPrice/*, \"Amount of wei != ticket price\"*/);\n\n        Ticket storage ticket = line.tickets.push();\n        ticket.user = payable(msg.sender);\n        ticket.data = block.number | (block.timestamp << TDSH_TIMESTAMP) | ((answers & 0xFFFFFFFFFFFFFFFF) << TDSH_ANSWERS);\n\n        ticketIndex = line.tickets.length - 1;\n        emit NewTicket(msg.sender, lineId, ticketIndex);\n    }\n\n    function getLinesIds() external view returns (uint[] memory) {\n        return _linesIter;\n    }\n\n    function getLine(uint lineId) external view returns (\n        uint[6] memory uintData, // [lineId, state, startTimestamp, ticketPrice, commission, accumulatedFunds]\n        uint[12] memory rewards,\n\n        bytes32[] memory leagues,\n        uint[11] memory leagueIndexes,\n        uint[11] memory startTimes,\n        bytes32[2][11] memory players,\n        bool[11] memory drawAllowances,\n        uint[11] memory results\n    ) {\n        Line memory line = findLine(lineId);\n\n        if (line.state == ST_OPEN && block.timestamp >= line.startTimestamp) {\n            line.state = ST_STARTED;\n        }\n\n        uintData = [\n        lineId,\n        line.state,\n        line.startTimestamp,\n        line.ticketPrice,\n        line.commission,\n        line.accumulatedFunds\n        ];\n\n        rewards = line.rewards;\n        leagues = line.leagues;\n\n        for (uint i = 0; i < 11; i++) {\n            Event memory ev = line.events[i];\n            leagueIndexes[i] = ev.leagueIndex;\n            startTimes[i] = ev.startTime;\n            players[i] = [ev.player1, ev.player2];\n            drawAllowances[i] = ev.drawAllowed;\n            results[i] = ev.result;\n        }\n    }\n\n    function getLineApprovals(uint lineId) external view returns (address[] memory) {\n        return findLine(lineId).approvals;\n    }\n\n    function getTicketsInfo(uint lineId) external view returns (\n        uint totalCount,\n        uint[12] memory guessedEvents,\n        uint[3] memory prizeCounts,\n        uint[3] memory refundCounts\n    ) {\n        Line memory line = findLine(lineId);\n\n        Ticket[] memory tickets = line.tickets;\n        totalCount = tickets.length;\n\n        if (line.state == ST_FINISHED) {\n            for (uint i = 0; i < totalCount; i++) {\n                TicketData memory data = parseTicketData(tickets[i].data);\n\n                //\n                guessedEvents[data.guessedEvents]++;\n\n                //\n                uint payoutType = data.payoutType;\n                if (payoutType == 0) continue;\n\n                // as reference\n                uint[3] memory counts;\n                if (payoutType == PAYOUT_REFUND) {\n                    counts = refundCounts;\n                } else if (payoutType == PAYOUT_PRIZE) {\n                    counts = prizeCounts;\n                } else {\n                    assert(false);\n                }\n\n                counts[0]++;\n                if (data.payoutState == PAYOUT_SUCCESSFUL) {\n                    counts[1]++;\n                } else if (data.payoutState == PAYOUT_FAILED) {\n                    counts[2]++;\n                }\n            }\n        }\n    }\n\n    function getTickets(uint lineId) external view returns (\n        address[] memory users,\n        uint[9][] memory data, // blockNumbers, timestamps, answers, guessedEvents, payoutTypes, payoutStates,\n                               // revenue, revenueGuessed, revenueTotalGuessed\n        uint[13][] memory revenueDetails\n    ) {\n        Line memory line = findLine(lineId);\n        bool isFinished = line.state == ST_FINISHED;\n\n        PayoutData memory payout;\n        if (isFinished) {\n            payout = buildPayoutData(line);\n        }\n\n        Ticket[] memory tickets = line.tickets;\n        uint ticklen = tickets.length;\n\n        users = new address[](ticklen);\n        data = new uint[9][](ticklen);\n        if (isFinished) {\n            revenueDetails = new uint[13][](ticklen);\n        }\n\n        for (uint i = 0; i < ticklen; i++) {\n            Ticket memory ticket = tickets[i];\n            TicketData memory _data = parseTicketData(ticket.data);\n\n            users[i] = ticket.user;\n            data[i][0] = _data.blockNumber;\n            data[i][1] = _data.timestamp;\n            data[i][2] = _data.answers;\n\n            if (isFinished) {\n                data[i][3] = _data.guessedEvents;\n                data[i][4] = _data.payoutType;\n                data[i][5] = _data.payoutState;\n\n                Revenue memory revenue = payout.revenues[_data.guessedEvents];\n                data[i][6] = revenue.amount;\n                data[i][7] = revenue.guessed;\n                data[i][8] = revenue.totalGuessed;\n                revenueDetails[i] = revenue.details;\n            }\n        }\n    }\n\n    function getTicket(uint lineId, uint ticketIndex) external view returns (\n        address user,\n        uint blockNumber,\n        uint timestamp,\n        uint answers,\n        uint guessedEvents,\n        uint payoutType,\n        uint payoutState,\n        uint revenue,\n        uint revenueGuessed,\n        uint revenueTotalGuessed,\n        uint[13] memory revenueDetails\n    ) {\n        Line memory line = findLine(lineId);\n\n        require(ticketIndex < line.tickets.length, \"Ticket at index not found\");\n        Ticket memory ticket = line.tickets[ticketIndex];\n        TicketData memory data = parseTicketData(ticket.data);\n\n        user = ticket.user;\n        blockNumber = data.blockNumber;\n        timestamp = data.timestamp;\n        answers = data.answers;\n\n        if (line.state == ST_FINISHED) {\n            guessedEvents = data.guessedEvents;\n            payoutType = data.payoutType;\n            payoutState = data.payoutState;\n\n            PayoutData memory payout = buildPayoutData(line);\n            Revenue memory _revenue = payout.revenues[data.guessedEvents];\n            revenue = _revenue.amount;\n            revenueGuessed = _revenue.guessed;\n            revenueTotalGuessed = _revenue.totalGuessed;\n            revenueDetails = _revenue.details;\n        }\n    }\n\n    function getPayoutData(uint lineId) external view returns (\n        uint refundedFunds,\n        uint totalFunds,\n        uint commission,\n        uint prizeFunds,\n        uint accumulatedFunds,\n        uint paidFunds,\n        uint heldFunds,\n        bool hasJackpot,\n        uint[12] memory guessed,\n        uint[12] memory totalGuessed,\n        uint[12] memory amounts\n    ) {\n        Line storage line = findLine(lineId, ST_FINISHED);\n\n        PayoutData memory payout = buildPayoutData(line);\n        refundedFunds = payout.refundedFunds;\n        totalFunds = payout.totalFunds;\n        commission = payout.commissionFunds;\n        prizeFunds = payout.prizeFunds;\n        accumulatedFunds = payout.accumulatedFunds;\n        paidFunds = payout.paidFunds;\n        heldFunds = payout.heldFunds;\n        hasJackpot = payout.hasJackpot;\n\n        for (uint events = 0; events <= 11; events++) {\n            Revenue memory revenue = payout.revenues[events];\n\n            guessed[events] = revenue.guessed;\n            totalGuessed[events] = revenue.totalGuessed;\n            amounts[events] = revenue.amount;\n        }\n    }\n\n    function getPayoutDataRevenue(uint lineId, uint guessedEvents) external view returns (\n        uint guessed,\n        uint totalGuessed,\n        uint amount,\n        uint[13] memory details\n    ) {\n        Line storage line = findLine(lineId, ST_FINISHED);\n        PayoutData memory payout = buildPayoutData(line);\n\n        Revenue[12] memory revenues = payout.revenues;\n        require(guessedEvents < revenues.length/*, \"Invalid guessedEvents\"*/);\n\n        Revenue memory revenue = revenues[guessedEvents];\n\n        guessed = revenue.guessed;\n        totalGuessed = revenue.totalGuessed;\n        amount = revenue.amount;\n        details = revenue.details;\n    }\n    ////\n\n\n    //// private/internal functions\n    function runPayout(Line storage line, PayoutData memory payout) private {\n        assert(line.state == ST_FINISHED);\n\n        Ticket[] storage tickets = line.tickets;\n        uint ticketPrice = line.ticketPrice;\n        uint ticklen = tickets.length;\n        uint lineId = line.id;\n        for (uint i = 0; i < ticklen; i++) {\n            Ticket storage ticket = tickets[i];\n            TicketData memory data = parseTicketData(ticket.data);\n\n            if (data.payoutType == 0) continue;\n\n            uint amount;\n            if (data.payoutType == PAYOUT_REFUND) {\n                amount = ticketPrice;\n            } else if (data.payoutType == PAYOUT_PRIZE) {\n                amount = payout.revenues[data.guessedEvents].amount;\n            }\n\n            payoutTicket(ticket, data, amount, lineId, i);\n        }\n    }\n\n    function runCanceledPayout(Line storage line) private {\n        // todo: change to \"Line memory line\" (?)\n        assert(line.state == ST_CANCELED);\n\n        uint ticketPrice = line.ticketPrice;\n        uint ticklen = line.tickets.length;\n        uint lineId = line.id;\n        for (uint i = 0; i < ticklen; i++) {\n            Ticket storage ticket = line.tickets[i];\n            TicketData memory data = parseTicketData(ticket.data);\n            data.payoutType = PAYOUT_REFUND;\n            payoutTicket(ticket, data, ticketPrice, lineId, i);\n        }\n    }\n\n    function payoutTicket(\n        Ticket storage ticket,\n        TicketData memory data,\n        uint amount,\n        uint lineId,\n        uint ticketIndex\n    ) private {\n        assert(amount > 0);\n\n        if (data.payoutState == PAYOUT_SUCCESSFUL) {\n            return;\n        }\n\n        address payable user = ticket.user;\n        if (user.send(amount)) {\n            data.payoutState = PAYOUT_SUCCESSFUL;\n            emit Payout(user, lineId, ticketIndex, amount, data.guessedEvents, data.payoutType);\n        } else {\n            data.payoutState = PAYOUT_FAILED;\n        }\n        ticket.data = buildTicketData(data);\n    }\n\n    function buildPayoutData(Line memory line) private pure returns (PayoutData memory) {\n        assert(line.state == ST_FINISHED);\n\n        PayoutData memory payout;\n\n        // calculate total amount of received wei\n        payout.refundedFunds = line.ticketPrice * line._refundedTicketsCount;\n        payout.totalFunds = line.ticketPrice * (line.tickets.length - line._refundedTicketsCount);\n\n        // calculate commission and prize funds\n        payout.commissionFunds = calcPercent(payout.totalFunds, line.commission);\n        assert(payout.commissionFunds <= payout.totalFunds);\n        payout.prizeFunds = payout.totalFunds - payout.commissionFunds;\n\n        //\n        payout.accumulatedFunds = line.accumulatedFunds;\n\n        // shared revenue details for each number of guessed events: guessedEvents => Revenue details\n        payout.revenues = buildRevenues(line, payout.prizeFunds);\n\n        // sum paid funds from shared revenues\n        for (uint events = 0; events <= 11; events++) {\n            Revenue memory revenue = payout.revenues[events];\n            if (revenue.totalGuessed == 0) continue;\n\n            payout.paidFunds += revenue.amount * revenue.guessed;\n        }\n        assert(payout.paidFunds <= payout.prizeFunds);\n\n        // calculate funds left\n        payout.heldFunds = payout.prizeFunds - payout.paidFunds;\n\n        // process jackpot revenue\n        uint jackpoters = payout.revenues[11].guessed;\n        payout.hasJackpot = jackpoters > 0;\n        if (payout.hasJackpot) {\n            // add accum funds and held funds\n            uint accumulatedFunds = payout.accumulatedFunds;\n            accumulatedFunds += payout.heldFunds;\n\n            // additional amount for each jackpoter\n            uint perJackpoter = accumulatedFunds / jackpoters;\n\n            // update jackpot Revenue\n            Revenue memory jackRevenue = payout.revenues[11];\n            jackRevenue.isJackpot = true;\n            jackRevenue.amount += perJackpoter;\n            jackRevenue.details[12] = perJackpoter;\n\n            // update total payout data\n            uint totalPaidAccums = perJackpoter * jackpoters;\n            payout.paidFunds += totalPaidAccums;\n            // payout.heldFunds != 0 if accumulatedFund % jackpoters != 0\n            assert(totalPaidAccums <= accumulatedFunds);\n            payout.heldFunds = accumulatedFunds - totalPaidAccums;\n        }\n\n        return payout;\n    }\n\n    function buildRevenues(Line memory line, uint prizeFunds) private pure returns (Revenue[12] memory revenues) {\n\n        // init `events` field\n        for (uint events = 0; events <= 11; events++) {\n            revenues[events].events = events;\n        }\n\n        // fill `guessed` field (count of tickets that guessed `events` events)\n        Ticket[] memory tickets = line.tickets;\n        for (uint i = 0; i < tickets.length; i++) {\n            TicketData memory data = parseTicketData(tickets[i].data);\n            if (data.payoutType == PAYOUT_REFUND) continue;\n\n            revenues[data.guessedEvents].guessed++;\n        }\n\n        // calculate minimum guessed count with reward\n        uint minRewardEvents = 11;\n        uint[12] memory rewards = line.rewards;\n        for (uint i = 0; i < rewards.length; i++) {\n            if (rewards[i] == 0) continue;\n            minRewardEvents = i;\n            break;\n        }\n\n        // fill count of total guessed events (with sub events)\n        for (uint events = minRewardEvents; events <= 11; events++) {\n            Revenue memory revenue = revenues[events];\n            // `totalGuessed` == initial `guessed` at start\n            revenue.totalGuessed = revenue.guessed;\n\n            // fill `totalGuessed` for sub guessed events\n            for (uint subEvents = minRewardEvents; subEvents < events; subEvents++) {\n                uint subGuessed = calcSublinesGuesses(events, subEvents);\n                revenues[subEvents].totalGuessed += revenue.guessed * subGuessed;\n            }\n        }\n\n        // fill amounts and details (of sub events)\n        uint[12] memory guessedRawRevenues/* = new uint[](maxEvents + 1)*/;\n        for (uint events = minRewardEvents; events <= 11; events++) {\n            Revenue memory revenue = revenues[events];\n            if (revenue.totalGuessed == 0) continue;\n\n            uint reward = rewards[events];\n            uint eventsPrizeFund = calcPercent(prizeFunds, reward);\n            uint amount = eventsPrizeFund / revenue.totalGuessed;\n            guessedRawRevenues[events] = amount;\n\n            revenue.details[events] = amount;\n\n            // add percents for sub guesses\n            for (uint subEvents = minRewardEvents; subEvents < events; subEvents++) {\n                uint subWinnersCount = calcSublinesGuesses(events, subEvents);\n                uint subRevenue = guessedRawRevenues[subEvents] * subWinnersCount;\n                amount += subRevenue;\n\n                revenue.details[subEvents] = subRevenue;\n            }\n\n            revenue.amount = amount;\n        }\n    }\n\n    function findLine(uint id) private view returns (Line storage) {\n        Line storage line = _lines[id];\n        require(line.id > 0/*, \"Line with this id not found\"*/);\n\n        return line;\n    }\n\n    function findLine(uint id, uint stateMask) private view returns (Line storage) {\n        Line storage line = findLine(id);\n        requireLineState(line.state & stateMask != 0);\n\n        return line;\n    }\n\n    function isApprover() private view returns (bool) {\n        address[] memory approvers = _approvers;\n        for (uint i = 0; i < approvers.length; i++) {\n            if (msg.sender == approvers[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function requireLineState(bool result) private pure {\n        require(result, \"Wrong line state\");\n    }\n\n    function parseTicketData(uint data) private pure returns (TicketData memory ticketData) {\n        ticketData.blockNumber = data & 0xFFFFFFFF;\n        ticketData.timestamp = (data >> TDSH_TIMESTAMP) & 0xFFFFFFFF;\n        ticketData.answers = (data >> TDSH_ANSWERS) & 0xFFFFFFFFFFFFFFFF;\n        ticketData.guessedEvents = (data >> TDSH_GUESSED_EVENTS) & 0xFF;\n        ticketData.payoutType = (data >> TDSH_PAYOUT_TYPE) & 0xFF;\n        ticketData.payoutState = (data >> TDSH_PAYOUT_STATE) & 0xFF;\n    }\n\n    function buildTicketData(TicketData memory ticketData) private pure returns (uint data) {\n        data = ticketData.blockNumber\n        | (ticketData.timestamp << TDSH_TIMESTAMP)\n        | (ticketData.answers << TDSH_ANSWERS)\n        | (ticketData.guessedEvents << TDSH_GUESSED_EVENTS)\n        | (ticketData.payoutType << TDSH_PAYOUT_TYPE)\n        | (ticketData.payoutState << TDSH_PAYOUT_STATE)\n        ;\n    }\n\n    function calcGuessedEvents(uint answers, uint[11] memory results) private pure returns (uint) {\n        uint guessedEvents = 0;\n        for (uint j = 0; j < results.length; j++) {\n            uint answer = (answers >> (j * 2)) & 3;\n            if (answer == results[j]) {\n                guessedEvents++;\n            }\n        }\n\n        return guessedEvents;\n    }\n\n    function calcPercent(uint amount, uint percent) private pure returns (uint) {\n        return (amount * percent) / 100;\n    }\n\n    function calcSublinesGuesses(uint n, uint k) private pure returns (uint) {\n        if (n <= k) return 0;\n\n        return 1;\n    }\n}\n"}}}