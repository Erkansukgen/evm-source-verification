{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/apr.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-04-20\n*/\n\n/* \n\n*Submitted for verification at Etherscan.io on 2019-11-12\n*Deployed to Ethereum Mainnet on 20-04-2020\n*Developed by the Technical Team of Greyzdorf BTR LLC\n\nBacked By : Glass Apple Farm Property\nValuation : $8.5 Million - 20-04-2020\nTicker : APR\nTota Supply : Variable Supply ( based on asset valuation )\nDecimal : 0\nBurning : available\nMinting : available\nFreeze : available\nType of Asset : Real Estate Backed\n\n*/\n\npragma solidity ^0.6.3;\n\n/* SafeMath functions */\n\ncontract SafeMath {\n    \n  function safeMul(uint256 a, uint256 b) pure internal returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeDiv(uint256 a, uint256 b) pure internal returns (uint256) {\n    assert(b > 0);\n    uint256 c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function safeSub(uint256 a, uint256 b) pure internal returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint256 a, uint256 b) pure internal returns (uint256) {\n    uint256 c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  } \n\n}\n\ncontract APR is SafeMath {\n    \n    string public constant name = \"Glass Apple Estate\";\n    string public constant symbol = \"APR\";\n    uint256 public constant decimals = 0;\n    uint256 public totalSupply = 0;\n    uint256 public constant version = 2.0;\n    address payable public owner;\n    string public constant issuer = \"Greyzdorf BTR LLC\";\n    string public constant website = \"https://www.greyzdorf.io\";\n    \n    constructor() public{\n        uint256 initalSupply = 0;\n        owner = msg.sender;\n        balanceOf[msg.sender]=initalSupply;\n        totalSupply+=initalSupply;\n        emit Transfer(address(0), owner, initalSupply);\n     }\n\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public freezeOf;\n    mapping(address => mapping(address => uint)) allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Burn(address indexed from, uint256 value);\n    \n    \n    modifier onlyOwner(){\n        require(msg.sender==owner);\n        _;\n    }\n    \n    \n    function mint(uint256 _value) public onlyOwner returns (bool){\n        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender],_value);\n        totalSupply = SafeMath.safeAdd(totalSupply,_value);\n        emit Transfer(address(0),msg.sender,_value);\n        return true;\n    }\n    \n    function burn(uint256 _value) public onlyOwner returns (bool){\n        if(balanceOf[msg.sender]>=_value){\n            balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender],_value);\n            totalSupply = SafeMath.safeSub(totalSupply,_value);\n            emit Burn(msg.sender, _value);\n            emit Transfer(msg.sender,address(0),_value);\n            return true;\n        }\n        else return false;\n    }\n    \n    function transfer(address _reciever, uint256 _value) public returns (bool){\n         uint256 amount = SafeMath.safeSub(_value,freezeOf[msg.sender]);\n         if(amount != 0){\n            balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender],amount);\n            balanceOf[_reciever] = SafeMath.safeAdd(balanceOf[_reciever],amount);\n            emit Transfer(msg.sender,_reciever,amount);\n            return true;\n        }\n        else return false;\n    }\n    \n     function transferFrom( address _from, address _to, uint256 _amount )public returns (bool) {\n     require( _to != address(0));\n     require(balanceOf[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n     balanceOf[_from] = SafeMath.safeSub(balanceOf[_from],_amount);\n     allowed[_from][msg.sender] = SafeMath.safeSub(allowed[_from][msg.sender],_amount);\n     balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_amount);\n     emit Transfer(_from, _to, _amount);\n     return true;\n     }\n    \n    function approve(address _spender, uint256 _amount)public returns (bool) {\n         require( _spender != address(0));\n         allowed[msg.sender][_spender] = _amount;\n         emit  Approval(msg.sender, _spender, _amount);\n         return true;\n     }\n     \n      function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n         require( _owner != address(0) && _spender != address(0));\n         return allowed[_owner][_spender];\n        }\n    \n    function freeze(address _lender, uint256 _value) public onlyOwner returns (bool){\n        if(balanceOf[_lender]>=_value){\n            freezeOf[_lender] = SafeMath.safeAdd(freezeOf[_lender],_value);\n            return true;\n        }\n        else return false;\n        \n    }\n    \n    function Unfreeze(address _lender,uint256 _value) public onlyOwner returns (bool){\n        if(freezeOf[_lender]>=_value){\n            freezeOf[_lender] = SafeMath.safeSub(balanceOf[_lender],_value);\n            return true;\n        }\n        else  return false;\n    }\n    \n    function withdrawEther(uint256 amount) public onlyOwner returns (bool) {\n\t\tif(msg.sender == owner){\n\t\towner.transfer(amount);\n\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\t\n\tfunction updateOwner(address payable _newOwner) public onlyOwner returns(bool){\n\t    if(msg.sender == owner){\n\t        owner = _newOwner;\n\t        return true;\n\t    }\n\t    else return false;\n\t}\n\t\n}"
    }
  }
}