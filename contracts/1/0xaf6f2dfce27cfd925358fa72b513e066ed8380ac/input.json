{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/DSA_READ/curve_sbtc.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface ICurve {\n    function get_virtual_price() external view returns (uint256 out);\n    function coins(int128 tokenId) external view returns (address token);\n    function calc_token_amount(uint256[3] calldata amounts, bool deposit) external view returns (uint256 amount);\n    function get_dy(int128 sellTokenId, int128 buyTokenId, uint256 sellTokenAmt) external view returns (uint256 buyTokenAmt);\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256 amount);\n}\n\ninterface TokenInterface {\n    function decimals() external view returns (uint);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint);\n}\n\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n}\n\ncontract CurveHelpers is DSMath {\n    /**\n     * @dev Return Curve sBTC Swap Address\n     */\n    function getCurveSwapAddr() internal pure returns (address) {\n        return 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714;\n    }\n\n    /**\n     * @dev Return Curve sBTC Token Address\n     */\n    function getCurveTokenAddr() internal pure returns (address) {\n        return 0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3;\n    }\n\n    function getTokenI(address token) internal pure returns (int128 i) {\n        if (token == address(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D)) {\n            // renBTC Token\n            i = 0;\n        } else if (token == address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599)) {\n            // WBTC Token\n            i = 1;\n        } else if (token == address(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6)) {\n            // sBTC Token\n            i = 2;\n        } else {\n            revert(\"token-not-found.\");\n        }\n    }\n\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = mul(_amt, 10 ** (18 - _dec));\n    }\n\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = (_amt / 10 ** (18 - _dec));\n    }\n\n    function getBuyUnitAmt(\n        address buyAddr,\n        address sellAddr,\n        uint sellAmt,\n        uint buyAmt,\n        uint slippage\n    ) internal view returns (uint unitAmt) {\n        uint _sellAmt = convertTo18(TokenInterface(sellAddr).decimals(), sellAmt);\n        uint _buyAmt = convertTo18(TokenInterface(buyAddr).decimals(), buyAmt);\n        unitAmt = wdiv(_buyAmt, _sellAmt);\n        unitAmt = wmul(unitAmt, sub(WAD, slippage));\n    }\n\n    function getDepositUnitAmt(\n        address token,\n        uint depositAmt,\n        uint curveAmt,\n        uint slippage\n    ) internal view returns (uint unitAmt) {\n        uint _depositAmt = convertTo18(TokenInterface(token).decimals(), depositAmt);\n        uint _curveAmt = convertTo18(TokenInterface(getCurveTokenAddr()).decimals(), curveAmt);\n        unitAmt = wdiv(_curveAmt, _depositAmt);\n        unitAmt = wmul(unitAmt, sub(WAD, slippage));\n    }\n\n    function getWithdrawtUnitAmt(\n        address token,\n        uint withdrawAmt,\n        uint curveAmt,\n        uint slippage\n    ) internal view returns (uint unitAmt) {\n        uint _withdrawAmt = convertTo18(TokenInterface(token).decimals(), withdrawAmt);\n        uint _curveAmt = convertTo18(TokenInterface(getCurveTokenAddr()).decimals(), curveAmt);\n        unitAmt = wdiv(_curveAmt, _withdrawAmt);\n        unitAmt = wmul(unitAmt, add(WAD, slippage));\n    }\n}\n\n\ncontract Resolver is CurveHelpers {\n\n    function getBuyAmount(address buyAddr, address sellAddr, uint sellAmt, uint slippage)\n        public\n        view\n        returns (uint buyAmt, uint unitAmt, uint virtualPrice)\n    {\n        ICurve curve = ICurve(getCurveSwapAddr());\n        buyAmt = curve.get_dy(getTokenI(sellAddr), getTokenI(buyAddr), sellAmt);\n        virtualPrice = curve.get_virtual_price();\n        unitAmt = getBuyUnitAmt(buyAddr, sellAddr, sellAmt, buyAmt, slippage);\n    }\n\n    function getDepositAmount(address token, uint depositAmt, uint slippage)\n        public\n        view\n        returns (uint curveAmt, uint unitAmt, uint virtualPrice)\n    {\n        uint[3] memory amts;\n        amts[uint(getTokenI(token))] = depositAmt;\n        ICurve curve = ICurve(getCurveSwapAddr());\n        curveAmt = curve.calc_token_amount(amts, true);\n        virtualPrice = curve.get_virtual_price();\n        unitAmt = getDepositUnitAmt(token, depositAmt, curveAmt, slippage);\n    }\n\n    function getWithdrawAmount(address token, uint withdrawAmt, uint slippage)\n        public\n        view\n        returns (uint curveAmt, uint unitAmt, uint virtualPrice)\n    {\n        uint[3] memory amts;\n        amts[uint(getTokenI(token))] = withdrawAmt;\n        ICurve curve = ICurve(getCurveSwapAddr());\n        curveAmt = curve.calc_token_amount(amts, false);\n        virtualPrice = curve.get_virtual_price();\n        unitAmt = getWithdrawtUnitAmt(token, withdrawAmt, curveAmt, slippage);\n    }\n\n    function getWithdrawTokenAmount(address token, uint curveAmt, uint slippage)\n        public\n        view\n        returns (uint tokenAmt, uint unitAmt, uint virtualPrice)\n    {\n        ICurve curve = ICurve(getCurveSwapAddr());\n        tokenAmt = curve.calc_withdraw_one_coin(curveAmt, getTokenI(token));\n        virtualPrice = curve.get_virtual_price();\n        unitAmt = getWithdrawtUnitAmt(token, tokenAmt, curveAmt, slippage);\n    }\n\n    function getPosition(\n        address user\n    ) public view returns (\n        uint userBal,\n        uint totalSupply,\n        uint virtualPrice,\n        uint userShare,\n        uint poolRenBtcBal,\n        uint poolWbtcBal,\n        uint poolSbtcBal\n    ) {\n        TokenInterface curveToken = TokenInterface(getCurveTokenAddr());\n        userBal = curveToken.balanceOf(user);\n        totalSupply = curveToken.totalSupply();\n        userShare = wdiv(userBal, totalSupply);\n        ICurve curveContract = ICurve(getCurveSwapAddr());\n        virtualPrice = curveContract.get_virtual_price();\n        poolRenBtcBal = TokenInterface(curveContract.coins(0)).balanceOf(getCurveSwapAddr());\n        poolWbtcBal = TokenInterface(curveContract.coins(1)).balanceOf(getCurveSwapAddr());\n        poolSbtcBal = TokenInterface(curveContract.coins(2)).balanceOf(getCurveSwapAddr());\n    }\n}\n\n\ncontract InstaCurveSBTCResolver is Resolver {\n    string public constant name = \"Curve-sBTC-Resolver-v1.1\";\n}"
    }
  }
}