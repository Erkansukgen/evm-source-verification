{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"cav3.sol":{"content":"pragma solidity >=0.8.0;\n// SPDX-License-Identifier: UNLICENSED\n\n// ** 不存资产**\n\ninterface IWETH {\n    /*\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    */\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    /*\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    */\n    function balanceOf(address owner) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n}\n\n//ISoloMargin\ninterface IdYdX {\n    struct AccountInfo {\n        address owner; // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n    enum AssetDenomination {\n        Wei, // the amount is denominated in wei\n        Par // the amount is denominated in par\n    }\n    enum AssetReference {\n        Delta, // the amount is given as a delta from the current value\n        Target // the amount is given as an exact number to end up at\n    }\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n    enum ActionType {\n        Deposit, // supply tokens\n        Withdraw, // borrow tokens\n        Transfer, // transfer balance between accounts\n        Buy, // buy an amount of some token (publicly)\n        Sell, // sell an amount of some token (publicly)\n        Trade, // trade tokens against another account\n        Liquidate, // liquidate an undercollateralized or expiring account\n        Vaporize, // use excess tokens to zero-out a completely negative account\n        Call // send arbitrary data to an address\n    }\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n    function operate(AccountInfo[] memory accounts, ActionArgs[] memory actions) external;\n}\n\n\ncontract CaV3 {\n    address public owner;\n\n    string public name = \"CaV3\";\n    address private constant EMPT = 0x0000000000000000000000000000000000000000;\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    //构造函数\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // receive ETH\n    receive() external payable {}\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"CaV3: sender not owner\");\n        _;\n    }\n\n    function changeOwner(address _owner) public onlyOwner {\n        owner = _owner;\n    }\n\n    //万一有token，提现\n    function withdrawToken(address token) public onlyOwner returns (uint balance) {\n        balance = IERC20(token).balanceOf(address(this));\n        if(balance > 0) {\n            _safeTransfer(token, msg.sender, balance);\n        }\n    }\n\n    function withdrawETH() public onlyOwner returns (uint balance) {\n        balance = address(this).balance;\n        if(balance > 0) {\n            _safeTransferETH(msg.sender, balance);\n        }\n    }\n\n    function _safeTransferETH(address to, uint256 value) private {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'CaV3: ETH transfer failed');\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'CaV3: TRANSFER_FAILED');\n    }\n\n    // 主入口\n    function go(\n        uint _coinbasePercent,\n        address _coinbaseAddress,\n        address _token,\n        address _target, \n        bytes memory _payload\n    ) public onlyOwner returns (uint _profit){\n        require(_coinbasePercent>=0 && _coinbasePercent<100, \"CaV3: invalid coinbasePercent\");\n\n        uint balanceBefor = IERC20(_token).balanceOf(address(this));\n\n        _functionCallWithValue(_target, _payload, 0, \"CaV3XXX\");\n        // uni 借款\n\t    // IUniswapV2Pair(_pair).swap(_amount0Out, _amount1Out, address(this), data);\n        // 回调执行了 uniswapV2Call()\n\n        uint balanceAfter = IERC20(_token).balanceOf(address(this));\n\n        _profit = balanceAfter - balanceBefor;\n\n        require(_profit > 0, \"CaV3: no profit\");\n\n        if(_token != WETH){\n            //其它token, 全部打给sender\n            _safeTransfer(_token, msg.sender, balanceAfter);\n            return _profit;\n        }\n\n        // token是WETH，全部提现\n        IWETH(WETH).withdraw(balanceAfter);\n\n        uint toCoinbase = _profit * _coinbasePercent / 100;\n        uint toSender = balanceAfter - toCoinbase;\n        require(toSender > 0, \"CaV3: sender no profit\");\n\n        _safeTransferETH(msg.sender, toSender);\n\n        if(toCoinbase > 0){\n            if(_coinbaseAddress == EMPT){\n                block.coinbase.transfer(toCoinbase);\n            }else{\n                _safeTransferETH(_coinbaseAddress, toCoinbase);\n            }\n        }\n    }\n\n    // dYdX\n    //SoloMargin 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e\n    //0 market 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    //1 market 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359\n    //2 market 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    //3 market 0x6B175474E89094C44Da98b954EedeAC495271d0F\n    function dYdXFl(address _solo, uint256 _marketId, address _token, uint256 _amount, bytes memory _data) external {\n        require(tx.origin == owner, \"CaV3: origin not owner\");\n        require(msg.sender ==  (address)(this), \"CaV3: sender not this\");\n\n        //address solo = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n        uint256 repayAmount = _amount + 2;\n        IERC20(_token).approve(_solo, repayAmount);\n\n        IdYdX.ActionArgs[] memory operations = new IdYdX.ActionArgs[](3);\n        operations[0] = IdYdX.ActionArgs({\n                actionType: IdYdX.ActionType.Withdraw,\n                accountId: 0,\n                amount: IdYdX.AssetAmount({\n                    sign: false,\n                    denomination: IdYdX.AssetDenomination.Wei,\n                    ref: IdYdX.AssetReference.Delta,\n                    value: _amount\n                }),\n                primaryMarketId: _marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n        operations[1] = IdYdX.ActionArgs({\n                actionType: IdYdX.ActionType.Call,\n                accountId: 0,\n                amount: IdYdX.AssetAmount({\n                    sign: false,\n                    denomination: IdYdX.AssetDenomination.Wei,\n                    ref: IdYdX.AssetReference.Delta,\n                    value: 0\n                }),\n                primaryMarketId: 0,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: _data\n            });\n        operations[2] = IdYdX.ActionArgs({\n                actionType: IdYdX.ActionType.Deposit,\n                accountId: 0,\n                amount: IdYdX.AssetAmount({\n                    sign: true,\n                    denomination: IdYdX.AssetDenomination.Wei,\n                    ref: IdYdX.AssetReference.Delta,\n                    value: repayAmount\n                }),\n                primaryMarketId: _marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n\n        IdYdX.AccountInfo[] memory accountInfos = new IdYdX.AccountInfo[](1);\n        accountInfos[0] = IdYdX.AccountInfo({owner: address(this), number: 1});\n\n        IdYdX(_solo).operate(accountInfos, operations);\n    }\n\n    // dYdX ICallee callback\n    function callFunction(address, IdYdX.AccountInfo memory, bytes memory data) external {\n        require(tx.origin == owner, \"CaV3: origin not owner\");\n\n        (address[] memory targets, bytes[] memory payloads, string[] memory messages) = abi.decode(data, (address[], bytes[], string[]));\n\n        callFuns(targets, payloads, messages);\n    }\n\n    // uni sushi callback\n    //function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {\n    function uniswapV2Call(address, uint, uint, bytes calldata data) external {\n        require(tx.origin == owner, \"CaV3: origin not owner\");\n\n        (address[] memory targets, bytes[] memory payloads, string[] memory messages) = abi.decode(data, (address[], bytes[], string[]));\n\n        callFuns(targets, payloads, messages);\n    }\n\n    function callFuns(address[] memory _targets, bytes[] memory _payloads, string[] memory _messages) private returns (bytes memory _response) {\n        require(tx.origin == owner, \"CaV3: origin not owner\");\n        require(_targets.length == _payloads.length && _targets.length == _messages.length, \"CaV3: callFuns\");\n\n        for (uint i = 0; i < _targets.length; i++) {\n            _response = _functionCallWithValue(_targets[i], _payloads[i], 0, _messages[i]);\n        }\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        //require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n"}}}