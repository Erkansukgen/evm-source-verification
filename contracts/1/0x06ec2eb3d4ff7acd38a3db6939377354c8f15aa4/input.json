{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/bzxflash.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\ninterface bzxRead{\n\n  function getLoan ( bytes32 loanId ) external view returns ( bytes32 loanId1, uint96 endTimestamp, address loanToken, address collateralToken, uint256 principal, uint256 collateral, uint256 interestOwedPerDay, uint256 interestDepositRemaining, uint256 startRate, uint256 startMargin, uint256 maintenanceMargin, uint256 currentMargin, uint256 maxLoanTerm, uint256 maxLiquidatable, uint256 maxSeizable);\n}\n\ninterface bzxWrite{\n  function liquidate(bytes32 loanId, address receiver, uint256 closeAmount) payable external;\n\n}\n\n\ninterface UniswapV2{\n\n\n   function addLiquidity ( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );\n   function addLiquidityETH ( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );\n   function removeLiquidityETH ( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH );\n   function removeLiquidity ( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB );\n   function swapExactETHForTokens ( uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns ( uint256[]  memory amounts );\n   function swapExactTokensForTokens ( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns ( uint256[] memory amounts );\n\n   function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n}\n\n\ninterface FlashLoanInterface {\n      function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes calldata  _params) external;\n}\n\n\n\n\ninterface ERC20 {\n    function totalSupply() external view returns(uint supply);\n\n    function balanceOf(address _owner) external view returns(uint balance);\n\n    function transfer(address _to, uint _value) external returns(bool success);\n\n    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n\n    function approve(address _spender, uint _value) external returns(bool success);\n\n    function allowance(address _owner, address _spender) external view returns(uint remaining);\n\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n     function deposit (  ) external payable;\n     function withdraw ( uint256 wad ) external;\n}\n\n\n\n\n\ncontract bzxliquidate{\n\n\n\n  address payable owner;\n   address ETH_TOKEN_ADDRESS  = address(0x0);\n   address payable aaveRepaymentAddress = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n\n    address uniAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n   bzxRead bzx0= bzxRead(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n\n   address bzx1Address = 0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f;\n\n   bzxWrite bzx1 = bzxWrite(0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f);\n  UniswapV2 usi = UniswapV2(uniAddress);\n  FlashLoanInterface fli = FlashLoanInterface(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n    bytes  theBytes;\n\n\naddress aaveEthAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\nERC20 wethToken = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\naddress currentCToken;\naddress currentLToken ;\n\nuint256  currentMaxLiq;\nbytes32 currentLoanId;\n\n\n   modifier onlyOwner() {\n       if (msg.sender == owner) _;\n     }\n\n\n\nconstructor() public payable {\n  owner = msg.sender;\n\n\n\n}\n\n\n fallback() external payable {\n\n        }\n\n\nfunction updateBZXs(address newAddress) onlyOwner public{\n     bzxRead bzx0= bzxRead(newAddress);\n\n   address bzx1Address = newAddress;\n\n   bzxWrite bzx1 = bzxWrite(newAddress);\n}\n\nfunction updateFlashLoanAddress(address newAddress) onlyOwner public{\n    FlashLoanInterface fli = FlashLoanInterface(newAddress);\n}\n\n\nfunction updateAaveEthAddress(address newAddress) onlyOwner public{\n    aaveEthAddress= newAddress;\n}\n\n\nfunction updateAaveRepayment(address payable newAddress) onlyOwner public{\n    aaveRepaymentAddress = newAddress;\n}\n\nfunction updateUniAddress(address newAddress) onlyOwner public{\n     UniswapV2 usi = UniswapV2(newAddress);\n}\n\nfunction setLoanInfo(address cToken, address lToken, uint maxLiq, bytes32 loanId2) public onlyOwner{\n     currentCToken = cToken;\n   currentLToken = lToken;\n   currentMaxLiq = maxLiq;\n   currentLoanId = loanId2;\n}\n\n function getLoanInfo1 ( bytes32 loanId ) public view returns ( bytes32 loanId1, address loanToken, address collateralToken, uint256 principal, uint256 collateral, uint256 maxLiquidatable){\n   //  return bzx0.getLoan(loanId);\n    (bytes32 loanId1, , address loanToken, address collateralToken, uint256 principal, uint256 collateral, , , , , , , , uint256 maxLiquidatable,) = bzx0.getLoan(loanId);\n    return (loanId1, loanToken, collateralToken, principal, collateral, maxLiquidatable);\n }\n\n\n\nfunction kickAss1(bytes32 loanId) onlyOwner public{\n    //getLoan\n    //get amount  and which token you need to pay / flash loan borrow\n    (bytes32 loanId1, uint96 endTimestamp, address loanToken, address collateralToken, uint256 principal, uint256 collateral, , , , , , uint256 currentMargin, uint256 maxLoanTerm, uint256 maxLiquidatable, uint256 maxSeizable) = bzx0.getLoan(loanId);\n   currentCToken = collateralToken;\n   currentLToken = loanToken;\n   currentMaxLiq = maxLiquidatable;\n   currentLoanId = loanId;\n\n   address tokenAddToUse = loanToken;\n   if(loanToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2){\n       tokenAddToUse = aaveEthAddress;\n   }\n\nperformFlash(tokenAddToUse, maxLiquidatable);\n    //flash borrow that amount\n\n    //and then flash function will call bzx liquidate function, swap the returned token from to our repayment  tokenof aave, and pay back avave with fee\n\n\n}\n\nfunction performFlash(address tokenAddToUse, uint maxLiquidatable) public onlyOwner{\n     fli.flashLoan(address(this), tokenAddToUse, maxLiquidatable, theBytes);\n}\n\n\n\n     function performUniswap(address sellToken, address buyToken, uint amount) public returns (uint256 amounts1){\n\n\n            ERC20 sellToken1     =  ERC20(sellToken);\n\n             if(sellToken1.allowance(address(this), uniAddress) <=amount){\n                    sellToken1.approve(uniAddress, 100000000000000000000000000000000000);\n               }\n\n             address [] memory addresses = new address[](2);\n\n            addresses[0] = sellToken;\n            addresses[1] = buyToken;\n\n\n\n             uint256 [] memory amounts = performUniswapActual(addresses, amount );\n             uint256 resultingTokens = amounts[1];\n             return resultingTokens;\n\n         }\n\n      function performUniswapActual(address  [] memory theAddresses, uint amount) public returns (uint256[] memory amounts1){\n\n\n\n             //uint256  amounts = uniswapContract.getAmountsOut(amount,theAddresses );\n             uint256 deadline = 1000000000000000;\n\n             uint256 [] memory amounts =  usi.swapExactTokensForTokens(amount, 1, theAddresses, address(this),deadline );\n\n             return amounts;\n\n        }\n\n\n\n  function performTrade(bool isItEther, uint256 amount1) public returns(uint256){\n\n\n        if(isItEther ==true){\n          //  wethToken.deposit.value(amount1);\n        }\n      else{\n           ERC20 bzLToken     =  ERC20(currentLToken);\n\n             if(bzLToken.allowance(address(this), bzx1Address) <=currentMaxLiq){\n                    bzLToken.approve(bzx1Address, (1000000000000000000000000000000000));\n             }\n      }\n\n       if(isItEther ==false){\n      bzx1.liquidate(currentLoanId, address(this), currentMaxLiq);\n       }\n       else{\n           bzx1.liquidate.value(amount1)(currentLoanId, address(this), currentMaxLiq);\n       }\n\n      ERC20 tokenToReceive = ERC20(currentCToken);\n\n    uint256 amountBack = performUniswap(currentCToken, currentLToken, tokenToReceive.balanceOf(address(this)));\n    return amountBack;\n\n  }\n\n\n  function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata  _params) external {\n   bool isEther;\n    if(_reserve == aaveEthAddress){\n        isEther=true;\n    }\n    else{\n        isEther = false;\n    }\n\n\n\n        uint256 tradeResp = performTrade(isEther, _amount);\n        require(tradeResp>0, \"You didnt fet anything from uni\");\n\n        if(_reserve == aaveEthAddress){\n\n            uint256 repayAmount = (_amount+_fee);\n            uint256 ourEthBalance = address(this).balance;\n\n\n            wethToken.withdraw( (_amount+_fee));\n              require(tradeResp>=(repayAmount/10), \"Not enough eth\");\n\n            //aaveRepaymentAddress.call.value(repayAmount)();\n            //aaveRepaymentAddress.send((_amount+_fee));\n             aaveRepaymentAddress.call{value:repayAmount}(\"\");\n\n        }else{\n            ERC20 firstToken = ERC20(_reserve);\n             firstToken.transfer(aaveRepaymentAddress, (_amount+_fee));\n        }\n\n\n\n\n    }\n\n\n\n  function changeOwner(address payable newOwner) public  onlyOwner{\n      owner = newOwner;\n  }\n\n  function getTokenBalance(address tokenAddress) public view returns(uint256){\n    ERC20 theToken = ERC20(tokenAddress);\n    return theToken.balanceOf(address(this));\n  }\n\n\n\n\n\n\n  function withdraw(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n\n\n\n\n        if (address(token) == ETH_TOKEN_ADDRESS) {\n            destination.transfer(amount);\n        }\n        else {\n            ERC20 tokenToken = ERC20(token);\n            require(tokenToken.transfer(destination, amount));\n        }\n\n\n\n        return true;\n    }\n\n\n    function kill() virtual public {\n            if (msg.sender == owner){\n                selfdestruct(owner);\n            }\n   }\n}\n"}}}