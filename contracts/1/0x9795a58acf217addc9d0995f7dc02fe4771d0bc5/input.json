{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DtaAmmPool.sol":{"content":"pragma solidity >=0.5.0 <0.8.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender)external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom( address sender, address recipient, uint256 amount ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval( address indexed owner, address indexed spender, uint256 value );\r\n}\r\ncontract DtaAmmPool{\r\n    address public _owner;\r\n    IERC20 public _tokenLp;\r\n    IERC20 public _tokenDta;\r\n    bool public _isRun;\r\n    address public dateTime;\r\n    uint public startBlock;\r\n    uint public allPeopleNum;\r\n    uint public lpExChange;\r\n    uint public decimalsDta;\r\n    uint public daily;\r\n    uint public annualized;\r\n    uint public yearBlock;\r\n    uint public conversionDta;\r\n\r\n    event StakeEve(address indexed from,uint indexed dateTime,uint amount,uint blockNumber,uint timestamp);\r\n    event LeaveEve(address indexed from,uint indexed dateTime,uint amount,uint timestamp);\r\n    event ProfitDtaEve(address indexed from,uint indexed dateTime,uint amount,uint timestamp);\r\n    event mobilityProfitDtaEve(address indexed from,uint indexed blockNumber,uint amount,uint timestamp);\r\n\r\n    constructor(IERC20 LpToken,IERC20 DtaToken) public {\r\n        _tokenLp = LpToken;\r\n        _tokenDta = DtaToken;\r\n        _owner = msg.sender;\r\n        _isRun = true;\r\n        startBlock = block.number;\r\n        decimalsDta = 8;\r\n        lpExChange = 290000000000000;\r\n        annualized = 360;\r\n        yearBlock = 1573800;\r\n        conversionDta = 342000000;\r\n    }\r\n    function updateYear(uint _lpExChange,uint _annualized,uint _yearBlock,uint _conversionDta) public {\r\n        require(msg.sender == _owner, \"Not an administrator！\");\r\n        lpExChange = _lpExChange;\r\n        annualized = _annualized;\r\n        yearBlock = _yearBlock;\r\n        conversionDta = _conversionDta;\r\n    }\r\n    struct Pledgor{\r\n        uint exist;\r\n        uint date;\r\n        uint amount;\r\n        address superiorAddr;\r\n        uint invitarionDta;\r\n        uint profitDate;\r\n        uint lastRewardBlock;\r\n        uint directInvitation;\r\n    }\r\n\r\n    Pledgor[] public pledgor;\r\n    mapping(address => Pledgor) public pledgors;\r\n    address[] public pllist;\r\n    struct Snapshot {\r\n        uint totalLp;\r\n    }\r\n    Snapshot[] public snapshot;\r\n    mapping(uint => Snapshot) public snapshots;\r\n    uint[] public dateList;\r\n    function snapshotCreate(uint _date,uint _totalLp) public {\r\n        require(_owner == msg.sender, \"Not an administrator\");\r\n        uint8 flag = 0;\r\n        for(uint8 i = 0;i < dateList.length;i++){\r\n          if(dateList[i] == _date ){\r\n            flag = 1;\r\n          }\r\n        }\r\n        if(flag == 0){\r\n          snapshots[_date] = Snapshot({ totalLp: _totalLp });\r\n          dateList.push(_date);\r\n        }\r\n    }\r\n    function stake(uint _amount, uint _date,address superiorAddr) public {\r\n        require(_isRun == true, \"It doesn't work\");\r\n        uint totalBalanceSender = _tokenLp.balanceOf(msg.sender);\r\n        require(totalBalanceSender >= _amount,\"ERC20: msg transfer amount exceeds balance\");\r\n        if(pledgors[msg.sender].exist == 0){\r\n          pllist.push(msg.sender);\r\n          pledgors[msg.sender].exist = 1;\r\n          pledgors[msg.sender].profitDate = _date;\r\n          pledgors[msg.sender].lastRewardBlock = block.number;\r\n        }\r\n        if(msg.sender != _owner){\r\n          if(pledgors[msg.sender].superiorAddr == address(0x0)){\r\n            _acceptInvitation(superiorAddr);\r\n          }\r\n        }\r\n        if(pledgors[msg.sender].amount > 0){\r\n          mobilityReceive(msg.sender);\r\n        }\r\n        if(pledgors[msg.sender].superiorAddr != address(0x0)){\r\n          mobilityReceive(pledgors[msg.sender].superiorAddr);\r\n        }\r\n        _tokenLp.transferFrom(msg.sender, address(this), _amount);\r\n        uint8 f = 0;\r\n        pledgors[superiorAddr].directInvitation += (_amount / 10);\r\n        _treeAdd(msg.sender, _amount, f);\r\n        pledgors[msg.sender].date = _date;\r\n        pledgors[msg.sender].amount += _amount;\r\n        uint timestamp = now;\r\n        emit StakeEve(msg.sender,_date,_amount,block.number,timestamp);\r\n    }\r\n    function _acceptInvitation(address addr) internal {\r\n      require(addr != msg.sender, \"You can't invite yourself\");\r\n      require(pledgors[addr].superiorAddr != msg.sender, \"Your subordinates can't be your superiors\");\r\n      pledgors[msg.sender].superiorAddr = addr;\r\n    }\r\n    function _treeAdd(address addr,uint _amount,uint8 f) internal {\r\n        pledgors[addr].invitarionDta += _amount;\r\n        address s = pledgors[addr].superiorAddr;\r\n        if (s != address(0x0) && f < 10) {\r\n            f += 1;\r\n            _treeAdd(s, _amount, f);\r\n        }\r\n    }\r\n    function leave(uint _amount, uint256 _date) public {\r\n        require(_isRun == true, \"It doesn't work\");\r\n        require(pledgors[msg.sender].amount >= _amount,\"ERC20: msg transfer amount exceeds balance\");\r\n        uint8 f = 0;\r\n        mobilityReceive(msg.sender);\r\n        if(pledgors[msg.sender].superiorAddr != address(0x0)){\r\n          mobilityReceive(pledgors[msg.sender].superiorAddr);\r\n        }\r\n\r\n        _treeSub(msg.sender, _amount, f);\r\n        pledgors[msg.sender].date = _date;\r\n        pledgors[msg.sender].amount -= _amount;\r\n        if(pledgors[msg.sender].superiorAddr != address(0x0)){\r\n          address sup = pledgors[msg.sender].superiorAddr;\r\n          if(pledgors[sup].directInvitation < _amount / 10){\r\n            pledgors[sup].directInvitation = 0;\r\n          }else{\r\n            pledgors[sup].directInvitation -= _amount / 10;\r\n          }\r\n        }\r\n        _tokenLp.transfer(msg.sender, _amount);\r\n        uint timestamp = now;\r\n        emit LeaveEve(msg.sender,_date,_amount,timestamp);\r\n    }\r\n    function _treeSub(address addr,uint _amount,uint8 f) internal {\r\n      if(pledgors[addr].invitarionDta < _amount){\r\n        pledgors[addr].invitarionDta = 0;\r\n      } else{\r\n        pledgors[addr].invitarionDta -= _amount;\r\n      }\r\n      address s = pledgors[addr].superiorAddr;\r\n      if (s != address(0x0) && f < 10) {\r\n          f += 1;\r\n          _treeSub(s, _amount, f);\r\n      }\r\n    }\r\n    function getProfitDta(uint _amount,uint _date) public {\r\n      require(_isRun == true, \"It doesn't work\");\r\n      require(_date > pledgors[msg.sender].profitDate, \"The date of collection is less than the last time\");\r\n      require(_amount < 400 * (10**decimalsDta), \"The income received is more than 300\");\r\n      require(pledgors[msg.sender].amount > 0, \"You have no pledge\");\r\n      _tokenDta.transfer(msg.sender, _amount);\r\n      pledgors[msg.sender].profitDate = _date;\r\n      uint timestamp = now;\r\n      emit ProfitDtaEve(msg.sender,_date,_amount,timestamp);\r\n    }\r\n    function mobilityReceive(address addr) public {\r\n      require(_isRun == true, \"It doesn't work\");\r\n      uint userDta = mobilityProfit(addr);\r\n      _tokenDta.transfer(addr, userDta);\r\n      pledgors[addr].lastRewardBlock = block.number;\r\n      uint timestamp = now;\r\n      emit mobilityProfitDtaEve(addr,pledgors[addr].lastRewardBlock,userDta,timestamp);\r\n    }\r\n    function mobilityProfit(address addr) public view returns(uint){\r\n      uint lastRewardBlock = pledgors[addr].lastRewardBlock;\r\n      uint amount = pledgors[addr].amount + pledgors[addr].directInvitation;\r\n      uint dta = amount * conversionDta / lpExChange  * 4 / 5;\r\n      dta = dta * annualized / 100;\r\n      dta = dta / yearBlock;\r\n      uint blockDiff = block.number - lastRewardBlock;\r\n      dta = dta * blockDiff;\r\n      return dta;\r\n    }\r\n    function updateRun(bool run) public{\r\n      require(msg.sender == _owner, \"Not an administrator！\");\r\n      _isRun = run;\r\n    }\r\n    function ownerControlLp(uint _amount) public{\r\n      require(msg.sender == _owner, \"Not an administrator！\");\r\n      _tokenLp.transfer(msg.sender, _amount);\r\n    }\r\n    function ownerControlDta(uint _amount) public{\r\n      require(msg.sender == _owner, \"Not an administrator！\");\r\n      _tokenDta.transfer(msg.sender, _amount);\r\n    }\r\n    function ownerUpdateUser(address addr,uint _amount,address superiorAddr,uint invitarionDta,uint profitDate) public{\r\n      require(msg.sender == _owner, \"Not an administrator！\");\r\n      pledgors[addr].amount = _amount;\r\n      pledgors[addr].superiorAddr = superiorAddr;\r\n      pledgors[addr].invitarionDta = invitarionDta;\r\n      pledgors[addr].profitDate = profitDate;\r\n    }\r\n    function getUserDta(address addr) public view returns(uint){\r\n      return _tokenDta.balanceOf(addr);\r\n    }\r\n    function getUserLp(address addr) public view returns(uint){\r\n      return _tokenLp.balanceOf(addr);\r\n    }\r\n    function getUserDate(address addr) public view returns(uint){\r\n      return pledgors[addr].date;\r\n    }\r\n    function getUserAmount(address addr) public view returns(uint){\r\n      return pledgors[addr].amount;\r\n    }\r\n    function getUserSuperiorAddr(address addr) public view returns(address){\r\n      return pledgors[addr].superiorAddr;\r\n    }\r\n    function getUserInvitarionDta(address addr) public view returns(uint){\r\n      return pledgors[addr].invitarionDta;\r\n    }\r\n    function getUserProfitDate(address addr) public view returns(uint){\r\n      return pledgors[addr].profitDate;\r\n    }\r\n    function allUserAddress(address addr) public view returns (address[] memory) {\r\n        address[] memory addrList = new address[](100);\r\n        uint8 flag = 0;\r\n        for (uint i = 0; i < pllist.length; i++) {\r\n            address s = pllist[i];\r\n            if(pledgors[s].superiorAddr == addr && flag < 99){\r\n              addrList[flag] = s;\r\n              flag += 1;\r\n            }\r\n        }\r\n        return addrList;\r\n    }\r\n    function allAddress() public view returns (address[] memory) {\r\n        return pllist;\r\n    }\r\n    function allDate() public view returns (uint[] memory) {\r\n        return dateList;\r\n    }\r\n  }"}}}