{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/etherhash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract EHA {\n    using SafeMath for uint256;\n    \n    /*==============================\n    =            E-HASH EVENTS            =\n    ==============================*/\n    \n    \n    event Approved(\n        address indexed spender,\n        address indexed recipient,\n        uint256 tokens\n    );\n\n     event Buy(\n         address indexed buyer,\n         uint256 tokensTransfered,\n         uint256 tokenToTransfer,\n         uint256 referralBal\n     );\n     \n      event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 tokens\n    );\n    \n     event sold(\n         address indexed seller,\n         uint256 calculatedEtherTransfer,\n         uint256 tokens\n     );\n     \n     event stake(\n         address indexed staker,\n         uint256 amount,\n         uint256 timing\n     );\n     \n     event onWithdrawal(\n         address indexed holder,\n         uint256 amount\n    );\n     \n     /*=====================================\n    =            E-HASH CONFIGURABLES            =\n    =====================================*/\n    \n     string public token_name;\n     string public token_symbol;\n     uint8 public decimal;\n    \n     uint256 public token_price = 120000000000000;\n\n     uint256 public basePrice1 = 120000000000000;\n     uint256 public basePrice2 = 210000000000000;\n     uint256 public basePrice3 = 350000000000000;\n     uint256 public basePrice4 = 580000000000000;\n     uint256 public basePrice5 = 1100000000000000;\n\n     uint256 public basePrice6 = 3000000000000000;\n\n     uint256 public basePrice7 = 14000000000000000;\n     uint256 public basePrice8 = 35000000000000000;\n     uint256 public basePrice9 = 140000000000000000;\n     uint256 public basePrice10 = 370000000000000000;\n     uint256 public basePrice11= 650000000000000000;\n     uint256 public basePrice12 = 1740000000000000000;\n     uint256 public basePrice13 = 4840000000000000000;\n    \n     uint256 public initialPriceIncrement = 0;\n    \n     uint256 public currentPrice;\n     uint[3] percentage = [11, 4, 1];\n    \n     uint256 public totalSupply_;\n     uint256 public tokenSold = 20000;\n     address payable owner;\n     \n     address stakeHolder;\n    \n     mapping(address => uint256) public tokenLedger;\n     mapping(address => mapping(address => uint256)) public allowed;\n     mapping(address => address) public gen_tree;\n     mapping(address => uint256) public levelIncome;\n     mapping(address => uint256) public mode;\n     mapping(address => uint256) public rewardIncome;\n     mapping(address => uint256) public allTimeSell;\n\n    \n     modifier onlyOwner {\n         require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n     }\n    \n     constructor(string memory _tokenName, string memory _tokenSymbol, uint256 initialSupply) public  {\n        owner = msg.sender;\n        stakeHolder = owner;\n        token_name = _tokenName;\n        token_symbol = _tokenSymbol;\n        decimal = 0;\n        currentPrice = token_price + initialPriceIncrement;\n        totalSupply_ = initialSupply;\n        tokenLedger[owner] = tokenSold;\n    }\n    \n    \n    /*=====================================\n    =            E-HASH Methods            =\n    =====================================*/\n    \n    function contractAddress() public view returns(address) {\n        return address(this);\n    }\n    \n    function get_level_income() public view returns(uint256) {\n        return levelIncome[msg.sender];\n    }\n        \n    function updateCurrentPrice(uint256 _newPrice) external onlyOwner returns (bool) {\n          currentPrice = _newPrice;\n          return true;\n    }\n    \n    \n    function getTaxedEther(uint256 incomingEther) public pure returns(uint256) {\n        uint256 deduction = incomingEther * 15000 / 100000;\n        uint256 taxedEther = incomingEther - deduction;\n        return taxedEther;\n    }\n    \n    \n    function etherToToken(uint256 incomingEtherWei) public view returns(uint256)  {\n        uint256 tokenToTransfer = incomingEtherWei.div(currentPrice);\n        return tokenToTransfer;\n    }\n\n    \n    function tokenToEther(uint256 tokenToSell) public view returns(uint256)  {\n        uint256 convertedEther = tokenToSell * currentPrice;\n        return convertedEther;\n    }\n\n     \n     function taxedTokenTransfer(uint256 incomingEther) internal view returns(uint256) {\n            uint256 deduction = incomingEther * 15000/100000;\n            uint256 taxedEther = incomingEther - deduction;\n            uint256 tokenToTransfer = taxedEther.div(currentPrice);\n            return tokenToTransfer;\n     }\n\n   \n    \n    function balanceOf(address _customerAddress) external\n        view\n        returns(uint256)\n    {\n        return tokenLedger[_customerAddress];\n    }\n    \n    function getCurrentPrice() public view returns(uint) {\n         return currentPrice;\n    }\n     \n    function name() public view returns(string memory) {\n        return token_name;\n    }\n\n\n     function symbol() public view returns(string memory) {\n         return token_symbol;\n     }\n\n    function decimals() public view returns(uint8){\n            return decimal;\n     }\n\n    function totalSupply() public view returns (uint256) {\n          return totalSupply_;\n    }\n    \n    function stake_funds()  public view returns(uint256) {\n        return tokenLedger[stakeHolder];\n    }\n    \n    \n    function setName(string memory _name)\n        onlyOwner\n        public\n    {\n        token_name = _name;\n    }\n   \n    function setSymbol(string memory _symbol)\n        onlyOwner\n        public\n    {\n        token_symbol = _symbol;\n    }\n    \n    \n    function add_level_income( address user, uint256 numberOfTokens) public returns(bool) {\n         \n         address referral;\n          for( uint i = 0 ; i < 3; i++ ){\n            referral = gen_tree[user];\n            \n            if(referral == address(0)) {\n                break;\n            }\n            uint256 convertedEther = tokenLedger[referral] * currentPrice;\n            \n            if( convertedEther >= 100000000000000000 ){\n                \n                uint256 commission = numberOfTokens * percentage[i] / 100;\n                levelIncome[referral] = levelIncome[referral].add(commission);\n            }\n            user = referral; \n         }\n      }\n    \n     \n     function buy_token(address _referredBy ) external payable returns (bool) {\n         require(_referredBy != msg.sender, \"Self reference not allowed\");\n         address buyer = msg.sender;\n         uint256 etherValue = msg.value;\n         uint256 taxedTokenAmount = taxedTokenTransfer(etherValue);\n         uint256 tokenToTransfer = etherValue.div(currentPrice);\n\n         require(tokenToTransfer >= 5, \"Minimum E-hash purchase limit is 5\");\n         require(buyer != address(0), \"Can't send to Zero address\");\n         \n         uint256 referralTokenBal = tokenLedger[_referredBy];\n         \n         if( etherValue >= 200000000000000000 ){\n             rewardIncome[buyer] = rewardIncome[buyer].add(100);\n         }\n         \n         if(mode[buyer] == 0) {\n            gen_tree[buyer] = _referredBy;   \n            mode[buyer] = 1;\n         }\n         \n         if(tokenToTransfer >= 60){\n            add_level_income(buyer, tokenToTransfer);    \n         }\n         \n         emit Transfer(address(this), buyer, taxedTokenAmount);\n         tokenLedger[buyer] = tokenLedger[buyer].add(taxedTokenAmount);\n         tokenSold = tokenSold.add(tokenToTransfer);\n         priceAlgoBuy(tokenToTransfer);\n         emit Buy(buyer,taxedTokenAmount, tokenToTransfer, referralTokenBal);\n         return true;\n     }\n    \n    \n     \n    function sell( uint256 tokenToSell ) external returns(bool){\n          \n          require(tokenSold >= tokenToSell, \"Token sold should be greater than zero\");\n          require(tokenToSell >= 5, \"Minimum token sell amount is 5 E-hash\");\n          require(msg.sender != address(0), \"address zero\");\n          require(tokenToSell <= tokenLedger[msg.sender], \"insufficient balance\");\n          \n           if(msg.sender != owner) {\n               require(tokenToSell <= 500, \"One time transfer is 500\");\n               require(allTimeSell[msg.sender] <= 500, \"Try again later\");\n               allTimeSell[msg.sender] = allTimeSell[msg.sender].add(tokenToSell);       \n           }\n           \n           \n           uint256 convertedWei = etherValueTransfer(tokenToSell);\n           tokenLedger[msg.sender] = tokenLedger[msg.sender].sub(tokenToSell);\n           \n           tokenSold = tokenSold.sub(tokenToSell);\n           priceAlgoSell(tokenToSell);\n           msg.sender.transfer(convertedWei);\n           emit Transfer(msg.sender, address(this), tokenToSell);\n           emit sold(msg.sender,convertedWei, tokenToSell);\n           return true;\n     }\n    \n     \n    function etherValueTransfer(uint256 tokenToSell) public view returns(uint256) {\n        uint256 convertedEther = tokenToSell * currentPrice;\n        return convertedEther;\n     }\n      \n     \n     function totalEthereumBalance() external onlyOwner view returns (uint256) {\n        return address(this).balance;\n    }\n     \n    \n    function mintToken(uint256 _mintedAmount) onlyOwner public {\n        totalSupply_ = totalSupply_.add(_mintedAmount);\n    }\n    \n     function destruct() onlyOwner() public{\n        selfdestruct(owner);\n    }\n    \n    \n    function withdrawReward(uint256 numberOfTokens, address _customerAddress)\n        onlyOwner\n        public\n    {\n        tokenLedger[_customerAddress] = tokenLedger[_customerAddress].add(numberOfTokens);\n    }\n    \n    \n    function withdraw_bal(uint256 numberOfTokens, address _customerAddress)\n        public returns(bool)\n    {\n      require(numberOfTokens >= 10, \"Minimum E-hash withdrawal amount is 10 E-hash\");\n      require(_customerAddress != address(0), \"address zero\");\n      require(numberOfTokens <= levelIncome[_customerAddress], \"insufficient bonus\");\n      levelIncome[_customerAddress] = levelIncome[_customerAddress].sub(numberOfTokens);\n      tokenLedger[_customerAddress] = tokenLedger[_customerAddress].add(numberOfTokens);\n      emit onWithdrawal(_customerAddress, numberOfTokens);\n      return true;\n    }\n    \n    \n    function holdStake(uint256 _amount, uint256 _timing)\n        public\n    {\n           address _customerAddress = msg.sender;\n           require(_amount <= tokenLedger[_customerAddress], \"insufficient balance\");\n           require(_amount >= 20, \"Minimum stake is 20 E-hash\");\n           tokenLedger[_customerAddress] = tokenLedger[_customerAddress].sub(_amount);\n           tokenLedger[stakeHolder] = tokenLedger[stakeHolder].add(_amount);\n           emit stake(_customerAddress, _amount, _timing);\n     }\n       \n    function unstake(uint256 _amount, address _customerAddress)\n        onlyOwner\n        public\n    {\n        tokenLedger[_customerAddress] = tokenLedger[_customerAddress].add(_amount);\n        tokenLedger[stakeHolder] = tokenLedger[stakeHolder].sub(_amount);\n    }\n    \n    \n    function alot_tokens(uint256 _amountOfTokens, address _toAddress) onlyOwner public returns(bool) {\n        address _customerAddress = msg.sender;\n        require(_amountOfTokens <= tokenLedger[_customerAddress]);\n        \n        tokenLedger[_customerAddress] = tokenLedger[_customerAddress].sub(_amountOfTokens);\n        tokenLedger[_toAddress] = tokenLedger[_toAddress].add(_amountOfTokens);\n        return true;\n    }\n    \n\n     function transfer(address _toAddress, uint256 _amountOfTokens) onlyOwner\n        public\n        returns(bool)\n      {\n        address _customerAddress = msg.sender;\n        require(_amountOfTokens <= tokenLedger[_customerAddress]);\n        \n        tokenLedger[_customerAddress] = tokenLedger[_customerAddress].sub(_amountOfTokens);\n        tokenLedger[_toAddress] = tokenLedger[_toAddress].add(_amountOfTokens);\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 tokens) public returns(bool success)  {\n        require(tokens <= tokenLedger[_from]);\n        require(tokens > 0);\n        require(tokens <= allowed[_from][msg.sender]);\n        \n        tokenLedger[_from] = tokenLedger[_from].sub(tokens);\n        tokenLedger[_to] = tokenLedger[_to].add(tokens);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(tokens);\n        emit Transfer(_from, _to, tokens);\n        return true;\n    }\n    \n    \n   function priceAlgoBuy(uint256 tokenQty) internal{\n\n        if ( tokenSold >= 0 && tokenSold <= 35000 ) {\n            currentPrice = basePrice1;\n            basePrice1 = currentPrice;\n        }\n        \n        if ( tokenSold >= 35000 && tokenSold <= 100000 ) {\n            initialPriceIncrement = tokenQty * 200000000;\n            currentPrice = basePrice2 + initialPriceIncrement;\n            basePrice2 = currentPrice;\n        }\n    \n        if ( tokenSold > 100000 && tokenSold <= 150000 ) {\n            initialPriceIncrement = tokenQty * 300000000;\n            currentPrice = basePrice3 + initialPriceIncrement;\n            basePrice3 = currentPrice;\n        }\n    \n        if ( tokenSold > 150000 && tokenSold <= 200000 ) {\n            initialPriceIncrement = tokenQty * 450000000;\n            currentPrice = basePrice4 + initialPriceIncrement;\n            basePrice4 = currentPrice;\n        }\n        \n        if ( tokenSold > 200000 && tokenSold <= 250000 ) {\n            initialPriceIncrement = tokenQty * 770000000;\n            currentPrice = basePrice5 + initialPriceIncrement;\n            basePrice5 = currentPrice;\n        }\n        \n        if ( tokenSold > 250000 && tokenSold <= 300000 ) {\n            initialPriceIncrement = tokenQty * 870000000;\n            currentPrice = basePrice6 + initialPriceIncrement;\n            basePrice6 = currentPrice;\n        }\n        \n        if ( tokenSold > 300000 && tokenSold <= 350000 ) {\n            initialPriceIncrement = tokenQty * 5725000000;\n            currentPrice = basePrice7 + initialPriceIncrement;\n            basePrice7 = currentPrice;\n        }\n    \n        if ( tokenSold > 350000 && tokenSold <= 400000 ) {\n            initialPriceIncrement = tokenQty * 9725000000;\n            currentPrice = basePrice8 + initialPriceIncrement;\n            basePrice8 = currentPrice;\n        }\n    \n        if ( tokenSold > 400000 && tokenSold <= 450000 ) {\n            initialPriceIncrement = tokenQty * 13900000000;\n            currentPrice = basePrice9 + initialPriceIncrement;\n            basePrice9 = currentPrice;\n        }\n    \n        if ( tokenSold > 450000 && tokenSold <= 500000 ) {\n            initialPriceIncrement = tokenQty * 34200000000;\n            currentPrice = basePrice10 + initialPriceIncrement;\n            basePrice10 = currentPrice;\n        }\n    \n        if ( tokenSold > 500000 && tokenSold <= 550000 ) {\n            initialPriceIncrement = tokenQty * 103325000000;\n            currentPrice = basePrice11 + initialPriceIncrement;\n            basePrice11 = currentPrice;\n        }\n    \n        if(tokenSold > 550000 && tokenSold <= 600000){\n            initialPriceIncrement = tokenQty*394050000000;\n            currentPrice = basePrice12 + initialPriceIncrement;\n            basePrice12 = currentPrice;\n    \n        }\n        \n        if(tokenSold > 600000 && tokenSold <= 650000){\n            initialPriceIncrement = tokenQty*694050000000;//\n            currentPrice = basePrice13 + initialPriceIncrement;\n            basePrice13 = currentPrice;\n        }\n   }\n\n     \n      function priceAlgoSell(uint256 tokenQty) internal{\n\n        if ( tokenSold >= 0 && tokenSold <= 35000 ) {\n            currentPrice = basePrice1;\n            basePrice1 = currentPrice;\n        }\n\n        if ( tokenSold >= 35000 && tokenSold <= 100000 ) {\n            initialPriceIncrement = tokenQty * 200000000;\n            currentPrice = basePrice2 - initialPriceIncrement;\n            basePrice2 = currentPrice;\n        }\n\n        if ( tokenSold > 100000 && tokenSold <= 150000 ) {\n            initialPriceIncrement = tokenQty * 300000000;\n            currentPrice = basePrice3 - initialPriceIncrement;\n            basePrice3 = currentPrice;\n        }\n\n        if ( tokenSold > 150000 && tokenSold <= 200000 ) {\n            initialPriceIncrement = tokenQty * 450000000;\n            currentPrice = basePrice4 - initialPriceIncrement;\n            basePrice4 = currentPrice;\n        }\n        if ( tokenSold > 200000 && tokenSold <= 250000 ) {\n            initialPriceIncrement = tokenQty * 770000000;\n            currentPrice = basePrice5 - initialPriceIncrement;\n            basePrice5 = currentPrice;\n        }\n        if ( tokenSold > 250000 && tokenSold <= 300000 ) {\n            initialPriceIncrement = tokenQty * 870000000;\n            currentPrice = basePrice6 - initialPriceIncrement;\n            basePrice6 = currentPrice;\n        }\n        if ( tokenSold > 300000 && tokenSold <= 350000 ) {\n            initialPriceIncrement = tokenQty * 5725000000;\n            currentPrice = basePrice7 - initialPriceIncrement;\n            basePrice7 = currentPrice;\n        }\n\n        if ( tokenSold > 350000 && tokenSold <= 400000 ) {\n            initialPriceIncrement = tokenQty * 9725000000;\n            currentPrice = basePrice8 - initialPriceIncrement;\n            basePrice8 = currentPrice;\n        }\n\n        if ( tokenSold > 400000 && tokenSold <= 450000 ) {\n            initialPriceIncrement = tokenQty * 13900000000;\n            currentPrice = basePrice9 - initialPriceIncrement;\n            basePrice9 = currentPrice;\n        }\n\n        if ( tokenSold > 450000 && tokenSold <= 500000 ) {\n            initialPriceIncrement = tokenQty * 34200000000;\n            currentPrice = basePrice10 - initialPriceIncrement;\n            basePrice10 = currentPrice;\n        }\n\n        if ( tokenSold > 500000 && tokenSold <= 550000 ) {\n            initialPriceIncrement = tokenQty * 103325000000;\n            currentPrice = basePrice11 - initialPriceIncrement;\n            basePrice11 = currentPrice;\n        }\n\n\n        if(tokenSold > 550000 && tokenSold <= 600000){\n            initialPriceIncrement = tokenQty*394050000000;\n            currentPrice = basePrice12 - initialPriceIncrement;\n            basePrice12 = currentPrice;\n\n        }\n\n        if(tokenSold > 600000 && tokenSold <= 650000){\n            initialPriceIncrement = tokenQty*694050000000;//\n            currentPrice = basePrice13 - initialPriceIncrement;\n            basePrice13 = currentPrice;\n\n        }\n      }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n    \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  }
}