{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/forwarderAllInOne.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// https://blog.coinbase.com/usdc-payment-processing-in-coinbase-commerce-b1af1c82fb0#89c1\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n  function transfer(address recipient, uint256 amount) external;\r\n  function balanceOf(address account) external view returns (uint256);\r\n  //function transferFrom(address sender, address recipient, uint256 amount) external;\r\n}\r\n\r\ncontract Forwarder {\r\n  address payable public destination;\r\n\r\n  //for parentForwarder\r\n  constructor(address payable _destination) payable {\r\n    destination = _destination;\r\n  }\r\n\r\n  //for cloneForwarder, run immediately after cloned\r\n  function init(address payable _destination) public {\r\n    destination = _destination;\r\n    \r\n    uint256 balance = address(this).balance;\r\n    destination.transfer(balance);\r\n  }\r\n\r\n  //for new pay to this charge's clonedForwarder created before\r\n  function flushEther() public {\r\n    uint256 balance = address(this).balance;\r\n    destination.transfer(balance);\r\n  }\r\n  \r\n  // @param tokenContractAddress\r\n  //  => USDC\r\n  //    => mainnet: 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\r\n  //    => Ropsten: 0x07865c6e87b9f70255377e024ace6630c1eaa37f\r\n  //  => USDT\r\n  //    => mainnet: 0xdac17f958d2ee523a2206206994597c13d831ec7\r\n  //    => Ropsten: \r\n  //  => RIPT\r\n  //    => mainnet:\r\n  //    => Ropsten:\r\n  function flushERC20(address tokenContractAddress) public {\r\n    IERC20 tokenContract = IERC20(tokenContractAddress);\r\n    uint256 forwarderBalance = tokenContract.balanceOf(address(this));\r\n    tokenContract.transfer(destination, forwarderBalance); //destionation: merchant waller adderss\r\n  }\r\n  \r\n  receive() external payable {\r\n  }\r\n}\r\n\r\ncontract ForwarderFactory {\r\n  // function initForwarder(address payable destination) public returns (Forwarder forwarder) {\r\n  //   forwarder = new Forwarder(destination);\r\n  // }\r\n  \r\n  // called only once for a certain merchant destination at the first time\r\n  // TODO remove param salt, replaced by 0 always\r\n  function initForwarder(address destination, uint256 salt) public returns (Forwarder forwarder) {\r\n    bytes memory initCode = abi.encodePacked(\r\n      type(Forwarder).creationCode,\r\n      uint256(uint160(destination))\r\n    );\r\n\r\n    assembly {\r\n      forwarder := create2(\r\n        0x0, add(0x20, initCode), mload(initCode), salt\r\n      )\r\n    }\r\n  }\r\n\r\n  // called after a new charge invoice is created and paid\r\n  // https://ethereum.stackexchange.com/questions/65693/how-to-cast-address-to-address-payable-in-solidity-0-5-0\r\n  function cloneForwarder(address payable forwarder, uint256 salt) public returns (Forwarder chargeForwarder) {\r\n    address payable clonedAddress = payable(createClone(forwarder, salt));\r\n    chargeForwarder = Forwarder(clonedAddress);\r\n    \r\n    Forwarder parentForwarder = Forwarder(forwarder);\r\n\r\n    chargeForwarder.init(parentForwarder.destination());\r\n    chargeForwarder.flushEther();\r\n  }\r\n\r\n  function createClone(address forwarder, uint256 salt) private returns (address result) {\r\n    bytes20 targetBytes = bytes20(forwarder);\r\n    assembly {\r\n      let clone := mload(0x40)\r\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n      mstore(add(clone, 0x14), targetBytes)\r\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n      result := create2(0, clone, 0x37, salt)\r\n    }\r\n  }\r\n}\r\n\r\n"}}}