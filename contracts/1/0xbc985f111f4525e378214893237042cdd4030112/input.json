{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Escrow.sol":{"content":"pragma solidity ^0.6.6;\n\ncontract TweetMarket {\n\tstruct Auction {\n\t\tbool closed;\n\t\tbool multipleBidders;\n\t\tuint64 highBidExpiration;\n\t\taddress highBidder;\n\t\tuint256 highBid;\n\t}\n\n\taddress private admin;\n\tuint256 private adminFees;\n\n\taddress private constant NULL_ADDRESS = address(0);\n\tuint256 private constant BID_MIN_PCT = 5;\n\tuint64 private BID_LOCK_PERIOD = 24 hours;\n\n\n\taddress[] private delegateHistory;\n\tmapping(address => bool) private delegates;\n\tmapping(address => uint256) private balanceOf;\n\tmapping(uint256 => Auction) private auctions;\n\n\tevent Bid (\n\t\tuint256 indexed tweetID,\n\t\taddress indexed actor,\n\t\tuint256 amount,\n\t\tuint256 timestamp\n\t);\n\n\tevent Outbid (\n\t\tuint256 indexed tweetID,\n\t\taddress indexed actor,\n\t\tuint256 amount,\n\t\tbool transferSuccess,\n\t\tuint256 timestamp\n\t);\n\n\tevent Cancel (\n\t\tuint256 indexed tweetID,\n\t\taddress indexed actor,\n\t\tuint256 amount,\n\t\tuint256 timestamp\n\t);\n\n\tevent Purchase (\n\t\tuint256 indexed tweetID,\n\t\taddress indexed actor,\n\t\tuint256 amount,\n\t\tuint256 timestamp\n\t);\n\n\tevent Close (\n\t\tuint256 indexed tweetID,\n\t\taddress indexed actor,\n\t\tuint256 amount,\n\t\tbool transferSuccess,\n\t\tuint256 timestamp\n\t);\n\n\tevent Withdraw (\n\t\taddress indexed actor,\n\t\tuint256 amount,\n\t\tuint256 timestamp\n\t);\n\n\tmodifier onlyAdmin {\n\t\trequire(msg.sender == admin, 'Not authorized');\n\t\t_;\n\t}\n\n\tmodifier onlyDelegates {\n\t\trequire(msg.sender == admin || delegates[msg.sender], 'Not authorized');\n\t\t_;\n\t}\n\n\tconstructor() public {\n\t\tadmin = msg.sender;\n\t}\n\n\tfunction bid(uint256 tweetID) public payable {\n\t\taddress bidder = msg.sender;\n\t\tuint256 msgValue = msg.value;\n\t\trequire(msgValue > 0, \"Invalid bid amount\");\n\n\t\tAuction storage auction = auctions[tweetID];\n\t\trequire(auction.closed == false, \"Auction has ended\");\n\n\t\tbool payoutSuccess = false;\n\t\tuint256 bidAmount = msgValue;\n\t\tuint256 bidPayout = 0;\n\t\tuint256 oldBid = auction.highBid;\n\t\taddress oldBidder = auction.highBidder;\n\t\t// Start the auction\n\t\tif (oldBidder == NULL_ADDRESS) {\n\t\t\tauction.highBidExpiration = uint64(now) + BID_LOCK_PERIOD;\n\t\t\tauction.highBidder = bidder;\n\t\t\tauction.highBid = bidAmount;\n\t\t}\n\t\t// New high bidder, outbid the previous high bidder\n\t\telse if (oldBidder != bidder) {\n\t\t\tbidPayout = oldBid + (oldBid * BID_MIN_PCT / 100);\n\t\t\trequire(bidAmount >= bidPayout, \"Bid too low\");\n\t\t\tauction.highBidExpiration = uint64(now) + BID_LOCK_PERIOD;\n\t\t\tauction.highBidder = bidder;\n\t\t\tauction.highBid = bidAmount;\n\t\t\tif (!auction.multipleBidders) {\n\t\t\t\tauction.multipleBidders = true;\n\t\t\t}\n\t\t\t// 10% of new bid is split between fees and kickback.\n\t\t\t// Previous high bidder gets 10% of *their* bid amount kicked back.\n\t\t\t// 10% of the new high bid is used to cover this. Excess fees go to the admin.\n\t\t\tuint256 fees = msgValue - bidPayout;\n\t\t\tif (fees > 0) {\n\t\t\t\tadminFees += fees;\n\t\t\t}\n\t\t\tpayoutSuccess = _payOrStore(oldBidder, bidPayout);\n\t\t\temit Outbid(\n\t\t\t\ttweetID,\n\t\t\t\toldBidder,\n\t\t\t\tbidPayout,\n\t\t\t\tpayoutSuccess,\n\t\t\t\tnow\n\t\t\t);\n\n\t\t}\n\t\t// Same high bidder, raise their previous bid\n\t\telse {\n\t\t\tbidAmount += oldBid;\n\t\t\tauction.highBidExpiration = uint64(now) + BID_LOCK_PERIOD;\n\t\t\tauction.highBid = bidAmount;\n\t\t\tif (auction.multipleBidders) {\n\t\t\t\tadminFees += msgValue * BID_MIN_PCT / 100;\n\t\t\t}\n\t\t}\n\n\t\temit Bid(\n\t\t\ttweetID,\n\t\t\tbidder,\n\t\t\tbidAmount,\n\t\t\tnow\n\t\t);\n\t}\n\n\tfunction _payOrStore(address recipient, uint256 amount) internal returns (bool) {\n\t\t(bool success, ) = recipient.call{value: amount, gas: 0}(\"\");\n\t\tif (!success) {\n\t\t\tbalanceOf[recipient] += amount;\n\t\t}\n\t\treturn success;\n\t}\n\n\tfunction _payOrFail(address recipient, uint256 amount) internal {\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\n \t\trequire(success, \"Transfer failed.\");\n\t}\n\n\tfunction cancelBid(uint256 tweetID) public {\n\t\taddress msgSender = msg.sender;\n\n\t\tAuction storage auction = auctions[tweetID];\n\n\t\trequire(auction.closed == false, \"Auction has ended\");\n\t\trequire(auction.highBidder == msgSender, \"Bid already cancelled\");\n\t\trequire(auction.highBidExpiration <= now, \"Minimum time not met\");\n\t\trequire(auction.highBid > 0, \"Invalid bid\");\n\n\t\tuint256 bidAmount = auction.highBid;\n\t\tuint256 bidRefund = bidAmount;\n\t\tif (auction.multipleBidders) {\n\t\t\tbidRefund -= bidAmount * BID_MIN_PCT / 100;\n\t\t}\n\n\t\tauction.multipleBidders = false;\n\t\tauction.highBid = 0;\n\t\tauction.highBidder = NULL_ADDRESS;\n\t\tauction.highBidExpiration = 0;\n\n\t\t_payOrFail(msgSender, bidRefund);\n\n\t\temit Cancel(\n\t\t\ttweetID,\n\t\t\tmsgSender,\n\t\t\tbidRefund,\n\t\t\tnow\n\t\t);\n\t}\n\n\t/**\n\t * For users that were outbid but the transfer back to them failed (e.g. smart contracts)\n\t */\n\tfunction withdraw() public {\n\t\taddress msgSender = msg.sender;\n\t\tuint256 amount = balanceOf[msgSender] = 0;\n\t\tbalanceOf[msgSender] = 0;\n\n\t\t_payOrFail(msgSender, amount);\n\n\t\temit Withdraw(msgSender, amount, now);\n\t}\n\n\tfunction withdrawAdmin() public onlyAdmin {\n\t\tuint256 amount = adminFees;\n\t\tadminFees = 0;\n\t\t_payOrFail(admin, amount);\n\t}\n\n\tfunction _close(uint256 tweetID, address seller) private returns (uint256 newFees) {\n\t\tAuction storage auction = auctions[tweetID];\n\t\trequire(!auction.closed, \"Auction already closed\");\n\t\tuint256 highBid = auction.highBid;\n\t\trequire(highBid > 0, \"Auction not started\");\n\n\t\tuint256 feesOnProceeds = highBid * BID_MIN_PCT / 100;\n\t\tuint256 proceeds = highBid - feesOnProceeds;\n\t\tif (auction.multipleBidders) {\n\t\t\t// When a bidder is outbid we take fees in the outbidding transaction.\n\t\t\tnewFees = 0;\n\t\t}\n\t\telse {\n\t\t\tnewFees = feesOnProceeds;\n\t\t}\n\t\taddress highBidder = auction.highBidder;\n\t\tauction.multipleBidders = false;\n\t\tauction.highBid = 0;\n\t\tauction.highBidder = NULL_ADDRESS;\n\t\tauction.highBidExpiration = 0;\n\t\tauction.closed = true;\n\n\t\tbool payoutSuccess = _payOrStore(seller, proceeds);\n\n\t\temit Close(\n\t\t\ttweetID,\n\t\t\tseller,\n\t\t\tproceeds,\n\t\t\tpayoutSuccess,\n\t\t\tnow\n\t\t);\n\n\t\temit Purchase(\n\t\t\ttweetID,\n\t\t\thighBidder,\n\t\t\thighBid,\n\t\t\tnow\n\t\t);\n\n\t\treturn newFees;\n\t}\n\n\tfunction close(uint256 tweetID, address seller) public onlyDelegates {\n\t\tuint256 newFees = _close(tweetID, seller);\n\t\tif (newFees > 0) {\n\t\t\tadminFees += newFees;\n\t\t}\n\t}\n\n\tfunction closeMany(uint256[] memory tweetIDs, address[] memory sellers) public onlyDelegates {\n\t\tuint256 newFees = 0;\n\t\trequire(tweetIDs.length == sellers.length, \"Parameter mismatch\");\n\t\tfor (uint i = 0; i < tweetIDs.length; i++) {\n\t\t\tnewFees += _close(tweetIDs[i], sellers[i]);\n\t\t}\n\t\tif (newFees > 0) {\n\t\t\tadminFees += newFees;\n\t\t}\n\t}\n\n\tfunction setDelegate(address delegate, bool privileged) public onlyAdmin {\n\t\tdelegates[delegate] = privileged;\n\t\tif (privileged) {\n\t\t\tdelegateHistory.push(delegate);\n\t\t}\n\t}\n\n\tfunction changeAdmin(address newAdmin) public onlyAdmin {\n\t\tadmin = newAdmin;\n\t}\n\n\tfunction setBidPeriod(uint64 numSeconds) public onlyAdmin {\n\t\tBID_LOCK_PERIOD = numSeconds;\n\t}\n\n\tfunction halt() public onlyAdmin {\n\t\t_payOrFail(msg.sender, address(this).balance);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\tfunction getAuction(uint256 tweetID) public view returns (bool, bool, uint64, address, uint256) {\n\t\tAuction memory auction = auctions[tweetID];\n\t\treturn (\n\t\t\tauction.closed,\n\t\t\tauction.multipleBidders,\n\t\t\tauction.highBidExpiration,\n\t\t\tauction.highBidder,\n\t\t\tauction.highBid\n\t\t);\n\t}\n\n\tfunction getDelegates() public view returns (address[] memory) {\n\t\treturn delegateHistory;\n\t}\n\n\tfunction isDelegate(address delegate) public view returns (bool) {\n\t\treturn delegates[delegate];\n\t}\n\n\tfunction getBalance(address owner) public view returns (uint256) {\n\t\treturn balanceOf[owner];\n\t}\n\n\tfunction getAdmin() public view returns (address) {\n\t\treturn admin;\n\t}\n\n}\n"}}}