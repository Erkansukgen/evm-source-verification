{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"HakkaIntelligenceAlpha.sol":{"content":"pragma solidity 0.5.17;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) \r\n            return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256) {\r\n        uint256 z = add(x >> 1, 1);\r\n        uint256 y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z), z)) / 2);\r\n        }\r\n        return y;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract Oracle {\r\n    function latestAnswer() external view returns (int256);\r\n}\r\n\r\ncontract HakkaIntelligenceAlpha {\r\n    using SafeMath for *;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public token;\r\n\r\n    uint256 public totalStake;\r\n    uint256 public revealedStake;\r\n    uint256 public totalScore;\r\n    uint256 public offset;\r\n\r\n    // timeline\r\n    //                          poke                     poke\r\n    // deploy contract ---- period start ---- period stop-|-reveal open --- reveal close～～～\r\n    //        \\----- can bet -----/                        \\---- must reveal----/  \\---can claim--\r\n\r\n    uint256 public periodStart;\r\n    uint256 public periodStop;\r\n    uint256 public revealOpen;\r\n    uint256 public revealClose;\r\n\r\n    uint256 public elementCount;\r\n    address[] public oracles;\r\n    uint256[] public priceSnapshot;\r\n    uint256[] public answer;\r\n\r\n    struct Player {\r\n        bool revealed;\r\n        bool claimed;\r\n        uint256 stake;\r\n        uint256 score;\r\n        uint256[] submission;\r\n    }\r\n\r\n    mapping(address => Player) public players;\r\n\r\n    event Submit(address indexed player, uint256[] submission);\r\n    event Reveal(address indexed player, uint256 score);\r\n    event Claim(address indexed player, uint256 amount);\r\n\r\n    constructor(address[] memory _oracles, address _token, uint256 _periodStart, uint256 _periodStop) public {\r\n        oracles = _oracles;\r\n        elementCount = _oracles.length;\r\n        token = IERC20(_token);\r\n        periodStart = _periodStart;\r\n        periodStop = _periodStop;\r\n    }\r\n\r\n    function calcLength(uint256[] memory vector) public pure returns (uint256 l) {\r\n        for(uint256 i = 0; i < vector.length; i++)\r\n            l = l.add(vector[i].mul(vector[i]));\r\n        l = l.sqrt();\r\n    }\r\n\r\n    function innerProduct(uint256[] memory vector1, uint256[] memory vector2) public pure returns (uint256 xy) {\r\n        require(vector1.length == vector2.length);\r\n        for(uint256 i = 0; i < vector1.length; i++)\r\n            xy = xy.add(vector1[i].mul(vector2[i]));\r\n    }\r\n\r\n    function playerSubmission(address _player) external view returns (uint256[] memory submission) {\r\n        Player storage player = players[_player];\r\n        return player.submission;\r\n    }\r\n\r\n    function submit(uint256 stake, uint256[] memory submission) public {\r\n        Player storage player = players[msg.sender];\r\n\r\n        require(now <= periodStart);\r\n        require(submission.length == elementCount);\r\n        require(player.submission.length == 0);\r\n        require(calcLength(submission) <= 1e18);\r\n\r\n        totalStake = totalStake.add(stake);\r\n        player.stake = stake;\r\n\r\n        require(stake <= 10000e18, \"too much\");\r\n\r\n        player.submission = submission;\r\n        token.safeTransferFrom(msg.sender, address(this), stake);\r\n        emit Submit(msg.sender, submission);\r\n    }\r\n\r\n    function reveal(address _player) public returns (uint256 score) {\r\n        Player storage player = players[_player];\r\n\r\n        require(!player.revealed);\r\n        require(now >= revealOpen && now <= revealClose);\r\n\r\n        score = innerProduct(answer, player.submission).mul(player.stake).div(1e36);\r\n        revealedStake = revealedStake.add(player.stake);\r\n        player.revealed = true;\r\n        player.score = score;\r\n        totalScore = totalScore.add(score);\r\n\r\n        emit Reveal(_player, score);\r\n    }\r\n\r\n    function claim(address _player) public returns (uint256 amount) {\r\n        Player storage player = players[_player];\r\n\r\n        require(now > revealClose);\r\n        require(!player.claimed);\r\n        player.claimed = true;\r\n        amount = token.balanceOf(address(this)).mul(player.score).div(totalScore.sub(offset));\r\n        offset = offset.add(player.score);\r\n        token.safeTransfer(_player, amount);\r\n\r\n        emit Claim(_player, amount);\r\n    }\r\n\r\n    function proceed() public {\r\n        if(priceSnapshot.length == 0) {\r\n            require(now >= periodStart);\r\n            for(uint256 i = 0; i < elementCount; i++) {\r\n                priceSnapshot.push(uint256(Oracle(oracles[i]).latestAnswer()));\r\n            }\r\n        }\r\n        else if(answer.length == 0) {\r\n            require(now >= periodStop);\r\n            uint256[] memory _answer = new uint256[](elementCount);\r\n            for(uint256 i = 0; i < elementCount; i++)\r\n                _answer[i] = uint256(Oracle(oracles[i]).latestAnswer()).mul(1e18).div(priceSnapshot[i]);\r\n            uint256 _length = calcLength(_answer).add(1);\r\n            for(uint256 i = 0; i < elementCount; i++)\r\n                _answer[i] = _answer[i].mul(1e18).div(_length);\r\n            answer = _answer;\r\n            revealOpen = now;\r\n            revealClose = now.add(14 days);\r\n        }\r\n        else revert();\r\n    }\r\n\r\n}"}}}