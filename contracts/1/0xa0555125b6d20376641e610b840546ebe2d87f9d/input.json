{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/CalculationsCurve.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\ncontract Ownable {\n    address public ownerAddress;\n\n    constructor() {\n        ownerAddress = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == ownerAddress, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function setOwnerAddress(address _ownerAddress) public onlyOwner {\n        ownerAddress = _ownerAddress;\n    }\n}\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n}\n\ninterface ICurvePool {\n    function get_virtual_price() external view returns (uint256);\n    function coins(uint256 arg0) external view returns (address);\n}\n\ninterface ICurveRegistry {\n    function get_pool_from_lp_token(address arg0)\n        external\n        view\n        returns (address);\n\n    function get_underlying_coins(address arg0)\n        external\n        view\n        returns (address[8] memory);\n\n    function get_virtual_price_from_lp_token(address arg0)\n        external\n        view\n        returns (uint256);\n}\n\ninterface ICryptoPool {\n    function balances(uint256) external view returns (uint256);\n\n    function price_oracle(uint256) external view returns (uint256);\n\n    // Some crypto pools only consist of 2 coins, one of which is usd so \n    // it can be assumed that the price oracle doesn't need an argument\n    // and the price of the oracle refers to the other coin.\n    // This function is mutually exclusive with the price_oracle function that takes \n    // an argument of the index of the coin, only one will be present on the pool\n    function price_oracle() external view returns (uint256);\n\n    function coins(uint256) external view returns (address);\n}\n\ninterface ILp {\n    function totalSupply() external view returns (uint256);\n}\n\ninterface IOracle {\n    function getPriceUsdcRecommended(address tokenAddress)\n        external\n        view\n        returns (uint256);\n\n    function usdcAddress() external view returns (address);\n}\n\ninterface IYearnAddressesProvider {\n    function addressById(string memory) external view returns (address);\n}\n\ninterface ICurveAddressesProvider {\n    function get_registry() external view returns (address);\n\n    function get_address(uint256) external view returns (address);\n}\n\ninterface ICalculationsChainlink {\n    function oracleNamehashes(address) external view returns (bytes32);\n}\n\ncontract CalculationsCurve is Ownable {\n    address public yearnAddressesProviderAddress;\n    address public curveAddressesProviderAddress;\n    IYearnAddressesProvider internal yearnAddressesProvider;\n    ICurveAddressesProvider internal curveAddressesProvider;\n\n    constructor(\n        address _yearnAddressesProviderAddress,\n        address _curveAddressesProviderAddress\n    ) {\n        yearnAddressesProviderAddress = _yearnAddressesProviderAddress;\n        curveAddressesProviderAddress = _curveAddressesProviderAddress;\n        yearnAddressesProvider = IYearnAddressesProvider(\n            _yearnAddressesProviderAddress\n        );\n        curveAddressesProvider = ICurveAddressesProvider(\n            _curveAddressesProviderAddress\n        );\n    }\n\n    function updateYearnAddressesProviderAddress(address _yearnAddressesProviderAddress) external onlyOwner {\n        yearnAddressesProviderAddress = _yearnAddressesProviderAddress;\n        yearnAddressesProvider = IYearnAddressesProvider(\n            _yearnAddressesProviderAddress\n        );\n    }\n\n    function updateCurveAddressesProviderAddress(address _curveAddressesProviderAddress) external onlyOwner {\n        curveAddressesProviderAddress = _curveAddressesProviderAddress;\n        curveAddressesProvider = ICurveAddressesProvider(\n            _curveAddressesProviderAddress\n        );\n    }\n\n    function oracle() internal view returns (IOracle) {\n        return IOracle(yearnAddressesProvider.addressById(\"ORACLE\"));\n    }\n\n    function curveRegistry() internal view returns (ICurveRegistry) {\n        return ICurveRegistry(curveAddressesProvider.get_registry());\n    }\n    \n    function cryptoPoolRegistry() internal view returns (ICurveRegistry) {\n        return ICurveRegistry(curveAddressesProvider.get_address(5));\n    }\n\n    function getCurvePriceUsdc(address lpAddress)\n        public\n        view\n        returns (uint256)\n    {\n        if (isLpCryptoPool(lpAddress)) {\n            return cryptoPoolLpPriceUsdc(lpAddress);\n        }\n        uint256 basePrice = getBasePrice(lpAddress);\n        uint256 virtualPrice = getVirtualPrice(lpAddress);\n        IERC20 usdc = IERC20(oracle().usdcAddress());\n        uint256 decimals = usdc.decimals();\n        uint256 decimalsAdjustment = 18 - decimals;\n        uint256 priceUsdc = (virtualPrice *\n            basePrice *\n            (10**decimalsAdjustment)) / 10**(decimalsAdjustment + 18);\n        return priceUsdc;\n    }\n\n    function cryptoPoolLpTotalValueUsdc(address lpAddress)\n        public\n        view\n        returns (uint256)\n    {\n        address poolAddress = getPoolFromLpToken(lpAddress);\n\n        address[] memory underlyingTokensAddresses = cryptoPoolUnderlyingTokensAddressesByPoolAddress(poolAddress);\n        uint256 totalValue;\n        for (\n            uint256 tokenIdx;\n            tokenIdx < underlyingTokensAddresses.length;\n            tokenIdx++\n        ) {\n            uint256 tokenValueUsdc = cryptoPoolTokenAmountUsdc(\n                poolAddress,\n                tokenIdx\n            );\n            totalValue += tokenValueUsdc;\n        }\n        return totalValue;\n    }\n\n    function cryptoPoolLpPriceUsdc(address lpAddress)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 totalValueUsdc = cryptoPoolLpTotalValueUsdc(lpAddress);\n        uint256 totalSupply = ILp(lpAddress).totalSupply();\n        uint256 priceUsdc = (totalValueUsdc * 10**18) / totalSupply;\n        return priceUsdc;\n    }\n\n    struct TokenAmount {\n        address tokenAddress;\n        string tokenSymbol;\n        uint256 amountUsdc;\n    }\n\n    function cryptoPoolTokenAmountsUsdc(address poolAddress)\n        public\n        view\n        returns (TokenAmount[] memory)\n    {\n        address[] memory underlyingTokensAddresses = cryptoPoolUnderlyingTokensAddressesByPoolAddress(poolAddress);\n        TokenAmount[] memory _tokenAmounts = new TokenAmount[](\n            underlyingTokensAddresses.length\n        );\n        for (\n            uint256 tokenIdx;\n            tokenIdx < underlyingTokensAddresses.length;\n            tokenIdx++\n        ) {\n            address tokenAddress = underlyingTokensAddresses[tokenIdx];\n            string memory tokenSymbol = IERC20(tokenAddress).symbol();\n            uint256 amountUsdc = cryptoPoolTokenAmountUsdc(\n                poolAddress,\n                tokenIdx\n            );\n            _tokenAmounts[tokenIdx] = TokenAmount({\n                tokenAddress: tokenAddress,\n                tokenSymbol: tokenSymbol,\n                amountUsdc: amountUsdc\n            });\n        }\n        return _tokenAmounts;\n    }\n\n    function cryptoPoolTokenAmountUsdc(address poolAddress, uint256 tokenIdx)\n        public\n        view\n        returns (uint256)\n    {\n        ICryptoPool pool = ICryptoPool(poolAddress);\n        address tokenAddress = pool.coins(tokenIdx);\n        uint8 decimals = IERC20(tokenAddress).decimals();\n        uint256 tokenPrice = oracle().getPriceUsdcRecommended(tokenAddress);\n        uint256 tokenValueUsdc = pool.balances(tokenIdx) * tokenPrice / 10 ** decimals;\n        return tokenValueUsdc;\n    }\n\n    function cryptoPoolUnderlyingTokensAddressesByPoolAddress(\n        address poolAddress\n    ) public view returns (address[] memory) {\n        uint256 numberOfTokens;\n        address[] memory _tokensAddresses = new address[](8);\n        for (uint256 coinIdx; coinIdx < 8; coinIdx++) {\n            (bool success, bytes memory data) = address(poolAddress).staticcall(\n                abi.encodeWithSignature(\"coins(uint256)\", coinIdx)\n            );\n            if (success) {\n                address tokenAddress = abi.decode(data, (address));\n                _tokensAddresses[coinIdx] = tokenAddress;\n                numberOfTokens++;\n            } else {\n                break;\n            }\n        }\n        bytes memory encodedAddresses = abi.encode(_tokensAddresses);\n        assembly {\n            mstore(add(encodedAddresses, 0x40), numberOfTokens)\n        }\n        address[] memory filteredAddresses = abi.decode(\n            encodedAddresses,\n            (address[])\n        );\n        return filteredAddresses;\n    }\n\n    function getBasePrice(address lpAddress) public view returns (uint256) {\n        address poolAddress = getPoolFromLpToken(lpAddress);\n        address underlyingCoinAddress = getUnderlyingCoinFromPool(poolAddress);\n        uint256 basePriceUsdc = oracle().getPriceUsdcRecommended(\n            underlyingCoinAddress\n        );\n        return basePriceUsdc;\n    }\n\n    // should not be used with lpAddresses that are from the crypto swap registry\n    function getVirtualPrice(address lpAddress) public view returns (uint256) {\n        return curveRegistry().get_virtual_price_from_lp_token(lpAddress);\n    }\n\n    function isCurveLpToken(address lpAddress) public view returns (bool) {\n        address poolAddress = getPoolFromLpToken(lpAddress);\n        bool tokenHasCurvePool = poolAddress != address(0);\n        return tokenHasCurvePool;\n    }\n\n    function isLpCryptoPool(address lpAddress) public view returns (bool) {\n        address poolAddress = getPoolFromLpToken(lpAddress);\n\n        if (poolAddress != address(0)) {\n            return isPoolCryptoPool(poolAddress);\n        }\n\n        return false;\n    }\n\n    function isPoolCryptoPool(address poolAddress) public view returns (bool) {\n        (bool success, ) = address(poolAddress).staticcall(\n            abi.encodeWithSignature(\"price_oracle(uint256)\", 0)\n        );\n\n        if (success) {\n            return true;\n        }\n\n        (bool successNoParams, ) = address(poolAddress).staticcall(\n            abi.encodeWithSignature(\"price_oracle()\")   \n        );\n\n        return successNoParams;\n    }\n\n    function getPoolFromLpToken(address lpAddress) public view returns (address) {\n        address poolAddress = curveRegistry().get_pool_from_lp_token(lpAddress);\n\n        if (poolAddress != address(0)) {\n            return poolAddress;\n        }\n\n        return cryptoPoolRegistry().get_pool_from_lp_token(lpAddress);\n    }\n\n    function isBasicToken(address tokenAddress) public view returns (bool) {\n        return\n            ICalculationsChainlink(\n                yearnAddressesProvider.addressById(\"CALCULATIONS_CHAINLINK\")\n            ).oracleNamehashes(tokenAddress) != bytes32(0);\n    }\n\n    // should not be used with pools from the crypto pool registry\n    function getUnderlyingCoinFromPool(address poolAddress)\n        public\n        view\n        returns (address)\n    {\n        address[8] memory coins = curveRegistry().get_underlying_coins(\n            poolAddress\n        );\n\n        return getPreferredCoinFromCoins(coins);\n    }\n\n    function getPreferredCoinFromCoins(address[8] memory coins)\n        internal\n        view\n        returns (address)\n    {\n        // Look for preferred coins (basic coins)\n        address preferredCoinAddress;\n        for (uint256 coinIdx = 0; coinIdx < 8; coinIdx++) {\n            address coinAddress = coins[coinIdx];\n            if (coinAddress != address(0) && isBasicToken(coinAddress)) {\n                preferredCoinAddress = coinAddress;\n                break;\n            } else if (coinAddress != address(0)) {\n                preferredCoinAddress = coinAddress;\n            }\n            // Found preferred coin and we're at the end of the token array\n            if (\n                (preferredCoinAddress != address(0) &&\n                    coinAddress == address(0)) || coinIdx == 7\n            ) {\n                break;\n            }\n        }\n        return preferredCoinAddress;\n    }\n\n    function getPriceUsdc(address assetAddress) public view returns (uint256) {\n        if (isCurveLpToken(assetAddress)) {\n            return getCurvePriceUsdc(assetAddress);\n        }\n        \n        ICurvePool pool = ICurvePool(assetAddress);\n        uint256 virtualPrice = pool.get_virtual_price();\n        address[8] memory coins;\n        for (uint i = 0; i < 8; i++) {\n            try pool.coins(i) returns (address coin) {\n                coins[i] = coin;\n            } catch {}\n        }\n        address preferredCoin = getPreferredCoinFromCoins(coins);\n        uint256 price = oracle().getPriceUsdcRecommended(preferredCoin);\n        if (price == 0) {\n            revert();\n        }\n        return price * virtualPrice / 10 ** 18;\n    }\n}\n"}}}