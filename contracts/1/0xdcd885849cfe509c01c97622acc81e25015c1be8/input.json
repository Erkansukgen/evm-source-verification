{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/CurveSwapV2.sol": {
      "content": "pragma solidity >=0.6.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./comm/IERC20.sol\";\r\nimport \"./dydx/DydxFlashloanBase.sol\";\r\nimport \"./dydx/IDydx.sol\";\r\nimport \"./curve/ICurveFiCurve.sol\";\r\n\r\ncontract CurveSwapV2 is DydxFlashloanBase {\r\n    struct CSDParams {\r\n        address pool1; \r\n        address pool2; \r\n        address tokenSwap;\r\n        int128 ij1;\r\n        int128 ij2;\r\n        uint256 dx;\r\n    }\r\n\r\n    address public addrAdmin;\r\n    address addrSolo = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n    mapping(address => bool) public operatorMap;\r\n    uint256 public options = 1;\r\n\r\n    constructor() public {\r\n        addrAdmin = msg.sender;\r\n    }  \r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == addrAdmin);\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address _addr) external onlyAdmin {\r\n        addrAdmin = _addr;\r\n    }\r\n\r\n    function setOpiton(uint256 _opt, address _solo) external onlyAdmin {\r\n        options = _opt;\r\n        if (_solo != address(0)) {\r\n            addrSolo = _solo;\r\n        }\r\n    }\r\n\r\n    function setOperator(address _addr, bool _val) external onlyAdmin {\r\n        operatorMap[_addr] = _val;\r\n    }\r\n\r\n    function approve(address _token, address _pool1, address _pool2, uint256 _val) external onlyAdmin {\r\n        IERC20(_token).approve(_pool1, _val);\r\n        if (_pool2 != address(0)) {\r\n            IERC20(_token).approve(_pool2, _val);\r\n        }\r\n    }\r\n\r\n    function approveAll(address _token, address[7] memory _pools, uint256 _val) external onlyAdmin {\r\n        IERC20 token = IERC20(_token);\r\n        for (uint256 i = 0; i < 7; ++i) {\r\n            if (_pools[i] != address(0)) {\r\n                if (_token != 0xdAC17F958D2ee523a2206206994597C13D831ec7) {\r\n                    token.approve(_pools[i], _val);\r\n                } else {\r\n                    IUSDT(_token).approve(_pools[i], _val);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function doSwap(address[4] memory _addrParam, int128[4] memory _ij, uint256 _dx, uint256 _minpf) external {\r\n        require(msg.sender == addrAdmin || operatorMap[msg.sender]);\r\n\r\n        if (options % 10 > 0) {\r\n            uint256 dy1 = ICurveFiCurve(_addrParam[0]).get_dy_underlying(_ij[0], _ij[1], _dx);\r\n            uint256 dy2 = ICurveFiCurve(_addrParam[1]).get_dy_underlying(_ij[2], _ij[3], dy1);\r\n            require((_dx + _minpf) < dy2);\r\n        }\r\n        \r\n        uint256 marketId = _getMarketIdFromTokenAddress(_addrParam[2]);\r\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\r\n        operations[0] = _getWithdrawAction(marketId, _dx);\r\n        operations[1] = _getCallAction(\r\n            abi.encode(\r\n                CSDParams({\r\n                    pool1: _addrParam[0],\r\n                    pool2: _addrParam[1],\r\n                    tokenSwap: _addrParam[3],\r\n                    ij1: (_ij[0] + _ij[1] * 10),\r\n                    ij2: (_ij[2] + _ij[3] * 10),\r\n                    dx: _dx\r\n                })\r\n            )\r\n        );\r\n        operations[2] = _getDepositAction(marketId, _dx + 2);\r\n        Account.Info[] memory accountInfos = new Account.Info[](1);\r\n        accountInfos[0] = _getAccountInfo();\r\n\r\n        ISoloMargin solo = ISoloMargin(addrSolo);\r\n        solo.operate(accountInfos, operations);\r\n\r\n        IERC20 token = IERC20(_addrParam[2]);\r\n        uint256 val = token.balanceOf(address(this));\r\n        if (_addrParam[2] != 0xdAC17F958D2ee523a2206206994597C13D831ec7) {\r\n            token.transfer(addrAdmin, val - 1);\r\n        } else {\r\n            IUSDT(_addrParam[2]).transfer(addrAdmin, val - 1);\r\n        }\r\n    }\r\n\r\n    function callFunction(\r\n        address sender,\r\n        Account.Info memory account,\r\n        bytes memory data\r\n    ) public {\r\n        CSDParams memory csdp = abi.decode(data, (CSDParams));\r\n        // t1 to t2\r\n        if (csdp.pool1 == 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7) {\r\n            ICurveFiCurve(csdp.pool1).exchange(\r\n                csdp.ij1 % 10,\r\n                csdp.ij1 / 10,\r\n                csdp.dx - 1,\r\n                0\r\n            );\r\n        } else {\r\n            ICurveFiCurve(csdp.pool1).exchange_underlying(\r\n                csdp.ij1 % 10,\r\n                csdp.ij1 / 10,\r\n                csdp.dx - 1,\r\n                0\r\n            );\r\n        }\r\n        \r\n        uint256 dy = IERC20(csdp.tokenSwap).balanceOf(address(this));\r\n        // t2 to t1\r\n        if (csdp.pool2 == 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7) {\r\n            ICurveFiCurve(csdp.pool2).exchange(\r\n                csdp.ij2 % 10, \r\n                csdp.ij2 / 10,\r\n                dy - 1, \r\n                csdp.dx + 2\r\n            );\r\n        } else {\r\n            ICurveFiCurve(csdp.pool2).exchange_underlying(\r\n                csdp.ij2 % 10, \r\n                csdp.ij2 / 10,\r\n                dy - 1, \r\n                csdp.dx + 2\r\n            );\r\n        }\r\n    }\r\n\r\n    function withdraw20(address _addr) external onlyAdmin {\r\n        IERC20 token = IERC20(_addr);\r\n        uint256 val = token.balanceOf(address(this));\r\n        if (_addr != 0xdAC17F958D2ee523a2206206994597C13D831ec7) {\r\n            token.transfer(addrAdmin, val);\r\n        } else {\r\n            IUSDT(_addr).transfer(addrAdmin, val);\r\n        }\r\n        \r\n        if (address(this).balance > 0) {\r\n            msg.sender.transfer(address(this).balance - 1);\r\n        }\r\n    }\r\n}\r\n"
    },
    "browser/comm/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IUSDT {\r\n    function transfer(address _to, uint _value) external;\r\n    function approve(address _spender, uint _value) external;\r\n}\r\n"
    },
    "browser/curve/ICurveFiCurve.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.7.0;\r\n\r\ninterface ICurveFiCurve {\r\n    function get_dy_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view returns (uint256 out);\r\n\r\n    function exchange_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external;\r\n    \r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external;\r\n}"
    },
    "browser/dydx/DydxFlashloanBase.sol": {
      "content": "// SPDX-License-Identifier:\r\npragma solidity >=0.6.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./IDydx.sol\";\r\n\r\ncontract DydxFlashloanBase {\r\n    function _getMarketIdFromTokenAddress(address token)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (token == 0x6B175474E89094C44Da98b954EedeAC495271d0F) {\r\n            return 3;       // DAI\r\n        }\r\n        else if (token == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) {\r\n            return 2;       // USDC\r\n        }\r\n        require(false);\r\n    }\r\n\r\n    function _getAccountInfo() internal view returns (Account.Info memory) {\r\n        return Account.Info({owner: address(this), number: 1});\r\n    }\r\n\r\n    function _getWithdrawAction(uint256 marketId, uint256 amount)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Withdraw,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: amount\r\n                }),\r\n                primaryMarketId: marketId,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: \"\"\r\n            });\r\n    }\r\n\r\n    function _getCallAction(bytes memory data)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Call,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: 0\r\n                }),\r\n                primaryMarketId: 0,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: data\r\n            });\r\n    }\r\n\r\n    function _getDepositAction(uint256 marketId, uint256 amount)\r\n        internal\r\n        view\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Deposit,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: true,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: amount\r\n                }),\r\n                primaryMarketId: marketId,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: \"\"\r\n            });\r\n    }\r\n}"
    },
    "browser/dydx/IDydx.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary Account {\r\n    enum Status {Normal, Liquid, Vapor}\r\n    struct Info {\r\n        address owner; // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n    struct Storage {\r\n        mapping(uint256 => Types.Par) balances; // Mapping from marketId to principal\r\n        Status status;\r\n    }\r\n}\r\n\r\nlibrary Actions {\r\n    enum ActionType {\r\n        Deposit, // supply tokens\r\n        Withdraw, // borrow tokens\r\n        Transfer, // transfer balance between accounts\r\n        Buy, // buy an amount of some token (externally)\r\n        Sell, // sell an amount of some token (externally)\r\n        Trade, // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize, // use excess tokens to zero-out a completely negative account\r\n        Call // send arbitrary data to an address\r\n    }\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n}\r\n\r\nlibrary Types {\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n}\r\n\r\ninterface ISoloMargin {\r\n    function getMarketTokenAddress(uint256 marketId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getNumMarkets() external view returns (uint256);\r\n\r\n    function operate(\r\n        Account.Info[] calldata accounts,\r\n        Actions.ActionArgs[] calldata actions\r\n    ) external;\r\n}\r\n\r\n// interface ICallee {\r\n//     function callFunction(\r\n//         address sender,\r\n//         Account.Info calldata accountInfo,\r\n//         bytes calldata data\r\n//     ) external;\r\n// }"
    }
  }
}