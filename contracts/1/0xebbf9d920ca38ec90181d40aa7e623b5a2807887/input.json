{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/UniswapV2FlashCalculate.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\n\r\n// In order to quickly load up data from Uniswap-like market, this contract allows easy iteration with a single eth_call\r\ncontract UniswapFlashCalculate {\r\n\r\n    address private owner;\r\n    IUniswapV2Router public immutable UniswapV2Router;\r\n    IUniswapV2Factory public immutable UniswapV2Factory;\r\n\r\n    address private bundleExecutorAddress;\r\n    uint16 private exact = 1000;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    constructor(address _bundleExecutorAddress) public payable {\r\n        owner = msg.sender;\r\n        bundleExecutorAddress = _bundleExecutorAddress;\r\n\r\n        UniswapV2Router = IUniswapV2Router(address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\r\n        UniswapV2Factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));\r\n    }\r\n\r\n    // 设置打包合约的地址\r\n    function setBundleExecutorAddress(address _address) internal onlyOwner {\r\n        bundleExecutorAddress = _address;\r\n    }\r\n\r\n    // 设置精确度，默认为100，建议不要超过1000\r\n    function setExact(uint16 _num) internal onlyOwner {\r\n        exact = _num;\r\n    }\r\n\r\n    // V2判断Token0、Token1\r\n    function V2GetPairToken(address[] memory path) internal view returns (address pair, bool isToken1, address path0, address path1){\r\n        path0 = path[path.length - 2];\r\n        path1 = path[path.length - 1];\r\n        pair = UniswapV2Factory.getPair(path0, path1);\r\n\r\n        isToken1 = IUniswapV2Pair(pair).token1() == path1 ? true : false;\r\n    }\r\n\r\n    // V2\r\n    function V2GetAmountsOutByStepPath(uint256 amountIn, address[] memory path) internal view returns (uint256[] memory amounts){\r\n        amounts = UniswapV2Router.getAmountsOut(amountIn, path);\r\n    }\r\n\r\n    function V2GetAmountOut(uint256 amountIn, uint256 reserveA, uint256 reserveB) internal view returns (uint256 amountOut){\r\n        amountOut = UniswapV2Router.getAmountOut(amountIn, reserveB, reserveA);\r\n    }\r\n\r\n    // 路径反转，计算利润\r\n    function reversePathAndRemoveLast(address[] memory path) internal pure returns (address[] memory){\r\n        address[] memory newPath;\r\n        uint16 n = 0;\r\n        for (uint i = path.length; i > 1; i--) {\r\n            newPath[n] = path[i - 2];\r\n            n++;\r\n        }\r\n        return newPath;\r\n    }\r\n\r\n    // 计算利润\r\n    // @returns:\r\n    // @maxAmountBuy 最大购买额度\r\n    // @finallyAmountOutOfBot 最终可获得的Token数量\r\n    // @finallyAmountOutOfUser 对手最终可获得Token数量\r\n    // @profit 利润\r\n    function V2CalculateMaxAmount(uint256 amountInOfUser, uint256 amountOutMin, address[] memory userPath, address[] memory minePath) external view returns (\r\n        uint256 maxAmountBuy,\r\n        uint256 finallyAmountOutOfBot,\r\n        uint256 finallyAmountOutOfUser,\r\n        int256 profit,\r\n        uint256 step\r\n    ) {\r\n\r\n        require(userPath.length > 1, \"Opponent path length error\");\r\n\r\n        // uint256 ETHBalance = WETH.balanceOf(address(this));\r\n\r\n        // 判断Pair里面的 Token0 是否为需要购买的Token；主要用来区别 reserves 位置\r\n        (address pair,bool isToken1, ,) = V2GetPairToken(userPath);\r\n        // 将合约的WETH余额分成100等份，然后按照各个梯度进行模拟购买；从而判断最大购买值\r\n        // uint256 step = uint256(1000e18 / 1000);\r\n        step = uint256(IERC20(minePath[0]).balanceOf(bundleExecutorAddress) / exact);\r\n\r\n        require(step > 0, \"Path Insufficient balance\");\r\n\r\n        // 如果对方是复合路径，则需要重新计算amountInOfUser；新的amountInOfUser为复合路径的倒数第二个值；\r\n        if (userPath.length > 2) {\r\n            uint256[] memory opponentAmounts = V2GetAmountsOutByStepPath(amountInOfUser, userPath);\r\n            amountInOfUser = opponentAmounts[opponentAmounts.length - 2];\r\n        }\r\n\r\n        // 交易对库存\r\n        (uint256 reserveA, uint256 reserveB,) = IUniswapV2Pair(pair).getReserves();\r\n\r\n        // ============计算最终购买数量、用户最终购买数量、机器人最终获得Token数量=================\r\n        (maxAmountBuy, finallyAmountOutOfBot, finallyAmountOutOfUser) = _V2CalculateMaxAmount(amountInOfUser, amountOutMin, reserveA, reserveB, step, minePath, isToken1);\r\n\r\n        // 用户实际可买到的Token数量 amountOut[i-1],用户实际支付的WETH数量：amountInOfUser\r\n        // 机器人干预的买入数量：maxAmountBuy，机器人干预后实际买到的Token数量：\r\n        // 计算毛利 profit ，此处不考虑机器人复合path的情况\r\n        profit = 0;\r\n        if (maxAmountBuy > 0) {\r\n            uint256 amountOutOfIn = _V2CalculateProfit(amountInOfUser, maxAmountBuy, finallyAmountOutOfBot, finallyAmountOutOfUser, reserveA, reserveB, isToken1);\r\n            // 处理机器人购买路径为复合路径的情况下计算有效利润。\r\n            if (amountOutOfIn > 0 && amountOutOfIn > maxAmountBuy && minePath.length > 2) {\r\n                profit = int256(V2GetAmountsOutByStepPath(amountOutOfIn - maxAmountBuy, reversePathAndRemoveLast(minePath))[0]);\r\n            } else {\r\n                profit = int256(amountOutOfIn) - int256(maxAmountBuy);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    // 如果用户按照精确购买Token数量购买\r\n    function V2CalculateMaxAmountByAmountInMax(uint256 amountInMax, address[] calldata userPath, address[] calldata minePath) external view returns (\r\n        uint256 maxAmountBuy,\r\n        uint256 finallyAmountOutOfBot,\r\n        uint256 finallyAmountOutOfUser,\r\n        int256 profit,\r\n        uint256 step\r\n    )  {\r\n        uint256[] memory amounts = UniswapV2Router.getAmountsOut(amountInMax, userPath);\r\n        (maxAmountBuy, finallyAmountOutOfBot, finallyAmountOutOfUser, profit, step) = this.V2CalculateMaxAmount(amountInMax, amounts[amounts.length - 1], userPath, minePath);\r\n    }\r\n\r\n    // 利润计算器核心\r\n    function _V2CalculateMaxAmount(uint256 amountInOfUser, uint256 amountOutMin, uint256 reserveA, uint256 reserveB, uint256 step, address[] memory minePath, bool isToken1) internal view returns (\r\n        uint256 maxAmountBuy,\r\n        uint256 finallyAmountOutOfBot,\r\n        uint256 finallyAmountOutOfUser\r\n\r\n    ){\r\n        uint16 i = 1;\r\n\r\n        uint256 amountOut;\r\n        finallyAmountOutOfUser = 0;\r\n        finallyAmountOutOfBot = 0;\r\n        maxAmountBuy = 0;\r\n\r\n        for (; i <= exact; i++) {\r\n            uint256[] memory amounts = V2GetAmountsOutByStepPath(step * i, minePath);\r\n\r\n            if (isToken1) {\r\n                // 如果Token1对应流出池子的代币，那么reserveB则为代币的库存（Reserve），reserveA 则为主流货币的库存（reserve）\r\n                // amounts 倒数第二个为机器人干预后买入的主流代币数量；倒数第一个为机器人干预后得到的Token数量；\r\n                if (reserveB <= amounts[amounts.length - 1]) {\r\n                    continue;\r\n                }\r\n                // 参数1：流入池子的主流货币数量\r\n                // 参数2：对应流出池子的代币（reserveB）\r\n                // 参数3：对应流入池子的主流货币（reserveA）\r\n                amountOut = V2GetAmountOut(\r\n                    amountInOfUser,\r\n                    reserveB - amounts[amounts.length - 1],\r\n                    reserveA + amounts[amounts.length - 2]\r\n                );\r\n\r\n            } else {\r\n                // 如果Token0对应流出池子的代币，那么reserveA 则为代币的库存（Reserve），reserveB 则为主流货币的库存（reserve）\r\n                // amounts 倒数第二个为机器人干预后买入的主流代币数量；倒数第一个为机器人干预后得到的Token数量；\r\n                if (reserveA <= amounts[amounts.length - 1]) {\r\n                    continue;\r\n                }\r\n                // 参数1：流入池子的主流货币数量\r\n                // 参数2：对应流出池子的代币（reserveA）\r\n                // 参数3：对应流入池子的主流货币（reserveB）\r\n                amountOut = V2GetAmountOut(\r\n                    amountInOfUser,\r\n                    reserveA - amounts[amounts.length - 1],\r\n                    reserveB + amounts[amounts.length - 2]\r\n                );\r\n            }\r\n\r\n            // 从小量购买不断网上增加购买额度，如果机器人干预后的实际 amountOut < 用户能接受的最小值（amountOutMin），那么 i-1 则为最大购买量\r\n            if (amountOut < amountOutMin) {\r\n                break;\r\n            } else {\r\n                // 如果 amountOut 小于 amountOutMin\r\n                // 用户最终能购买的Token数量\r\n                finallyAmountOutOfUser = amountOut;\r\n                // 机器人最大购买量：WETH\r\n                maxAmountBuy = step * i;\r\n                // 机器人可获得最大Token数量\r\n                finallyAmountOutOfBot = amounts[amounts.length - 1];\r\n            }\r\n        }\r\n    }\r\n\r\n    function _V2CalculateProfit(uint256 amountInOfUser, uint256 maxAmountBuy, uint256 finallyAmountOutOfBot, uint256 finallyAmountOutOfUser, uint256 reserveA, uint256 reserveB, bool isToken1) internal view returns (uint256 amountOutOfIn){\r\n        amountOutOfIn = 0;\r\n        if (isToken1) {\r\n            if (reserveB > finallyAmountOutOfBot + finallyAmountOutOfUser) {\r\n                amountOutOfIn = V2GetAmountOut(\r\n                    finallyAmountOutOfBot,\r\n                    reserveA + maxAmountBuy + amountInOfUser,\r\n                    reserveB - finallyAmountOutOfBot - finallyAmountOutOfUser\r\n                );\r\n            }\r\n        } else {\r\n            if (reserveA > finallyAmountOutOfBot + finallyAmountOutOfUser) {\r\n                amountOutOfIn = V2GetAmountOut(\r\n                    finallyAmountOutOfBot,\r\n                    reserveB + maxAmountBuy + amountInOfUser,\r\n                    reserveA - finallyAmountOutOfBot - finallyAmountOutOfUser\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // 提取合约内部的Token\r\n    function WithdrawToken(IERC20 token, uint256 amount) public onlyOwner {\r\n        require(token.balanceOf(address(this)) >= amount, \"Insufficient balance\");\r\n        token.transfer(msg.sender, amount);\r\n    }\r\n\r\n    // 转移所有者\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n\r\n    // 提取ETH\r\n    function withdraw(uint256 amount) onlyOwner public {\r\n        require(address(this).balance >= amount, \"Insufficient balance\");\r\n        msg.sender.transfer(amount);\r\n        amount = 0;\r\n    }\r\n}\r\n"
    }
  }
}