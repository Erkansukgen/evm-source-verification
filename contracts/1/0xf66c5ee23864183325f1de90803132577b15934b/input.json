{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "buyFirstUniswap.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract buyFirstUniswap{\n    \n    address OWNER = 0x07432d559Fa617b6e23a516f9A6187440FbFB086;\n    address OWNER2 = 0xE9Aca74Ecc2C253AFec43a24498b83d4D49dbC4F;\n    address addrUniswapRouterV2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;   // ПРОВЕРИТЬ BSC ИЛИ ETHER\n\n    modifier onlyOwner() {\n        require(tx.origin == OWNER || tx.origin == OWNER2, \"caller is not the owner!\");\n        _;\n    }\n    \n    \n    function doSwapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) public onlyOwner {\n        addrUniswapRouterV2.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",amountIn,amountOutMin,path,to,deadline));\n    }\n    \n    function doSwapExactTokensForTokensAndApprove(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) public onlyOwner {\n        IERC20 tokenInIERC20 = IERC20(path[0]);\n        tokenInIERC20.approve(addrUniswapRouterV2, 1e60);\n        addrUniswapRouterV2.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",amountIn,amountOutMin,path,to,deadline));\n    }\n    \n    function doSwapExactTokensForTokensTest(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline,address[] calldata pathSell) public onlyOwner {\n        addrUniswapRouterV2.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",amountIn,amountOutMin,path,to,deadline));\n        IERC20 tokenInIERC20 = IERC20(pathSell[0]);\n        tokenInIERC20.approve(addrUniswapRouterV2, 1e60);\n        uint256 balanceBought = IERC20(pathSell[0]).balanceOf(address(this));\n        require(balanceBought > 0, \"Could not buy.\");\n        addrUniswapRouterV2.call(abi.encodeWithSignature(\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",balanceBought,100,pathSell,to,deadline));\n        uint256 balanceAfter = IERC20(pathSell[0]).balanceOf(address(this));\n        require(balanceAfter == 0, \"Could not sell.\");\n    }\n    \n    \n    function approveSet(address _addrWETH) public onlyOwner {\n        IERC20 tokenInIERC20 = IERC20(_addrWETH);\n        tokenInIERC20.approve(addrUniswapRouterV2, 1e60);\n\n    }\n///////////////////////////////////    WITHDRAW        ///////////////////////////\n\n    function withdrawToken(address _tokenAddress) public onlyOwner {\n        uint256 balance = IERC20(_tokenAddress).balanceOf(address(this));\n        IERC20(_tokenAddress).transfer(OWNER, balance);\n    }\n\n    function withdrawEther() public onlyOwner {\n        address self = address(this); \n        uint256 balance = self.balance;\n        payable(OWNER).transfer(balance);\n    }\n\n    fallback () external payable  {}\n\n}"
    }
  }
}