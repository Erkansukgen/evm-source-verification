{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/GebLenderFIrstResortRewardsVested.sol":{"content":"/// GebLenderFirstResortRewardsVested.sol\n\n// Copyright (C) 2021 Reflexer Labs, INC\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.7;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\nabstract contract TokenLike {\n    function decimals() virtual public view returns (uint8);\n    function totalSupply() virtual public view returns (uint256);\n    function balanceOf(address) virtual public view returns (uint256);\n    function mint(address, uint) virtual public;\n    function burn(address, uint) virtual public;\n    function approve(address, uint256) virtual external returns (bool);\n    function transfer(address, uint256) virtual external returns (bool);\n    function transferFrom(address,address,uint256) virtual external returns (bool);\n}\nabstract contract AuctionHouseLike {\n    function activeStakedTokenAuctions() virtual public view returns (uint256);\n    function startAuction(uint256, uint256) virtual external returns (uint256);\n}\nabstract contract AccountingEngineLike {\n    function debtAuctionBidSize() virtual public view returns (uint256);\n    function unqueuedUnauctionedDebt() virtual public view returns (uint256);\n}\nabstract contract SAFEEngineLike {\n    function coinBalance(address) virtual public view returns (uint256);\n    function debtBalance(address) virtual public view returns (uint256);\n}\nabstract contract RewardDripperLike {\n    function dripReward() virtual external;\n    function dripReward(address) virtual external;\n    function rewardPerBlock() virtual external view returns (uint256);\n    function rewardToken() virtual external view returns (TokenLike);\n}\nabstract contract StakingRewardsEscrowLike {\n    function escrowRewards(address, uint256) virtual external;\n}\n\n// Stores tokens, owned by GebLenderFirstResortRewardsVested\ncontract TokenPool {\n    TokenLike public token;\n    address   public owner;\n\n    constructor(address token_) public {\n        token = TokenLike(token_);\n        owner = msg.sender;\n    }\n\n    // @notice Transfers tokens from the pool (callable by owner only)\n    function transfer(address to, uint256 wad) public {\n        require(msg.sender == owner, \"unauthorized\");\n        require(token.transfer(to, wad), \"TokenPool/failed-transfer\");\n    }\n\n    // @notice Returns token balance of the pool\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n}\n\ncontract GebLenderFirstResortRewardsVested is ReentrancyGuard {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"GebLenderFirstResortRewardsVested/account-not-authorized\");\n        _;\n    }\n\n    // --- Structs ---\n    struct ExitRequest {\n        // Exit window deadline\n        uint256 deadline;\n        // Ancestor amount queued for exit\n        uint256 lockedAmount;\n    }\n\n    // --- Variables ---\n    // Flag that allows/blocks joining\n    bool      public canJoin;\n    // Flag that indicates whether canPrintProtocolTokens can ignore auctioning ancestor tokens\n    bool      public bypassAuctions;\n    // Whether the contract allows forced exits or not\n    bool      public forcedExit;\n    // Last block when a reward was pulled\n    uint256   public lastRewardBlock;\n    // The current delay enforced on an exit\n    uint256   public exitDelay;\n    // Min maount of ancestor tokens that must remain in the contract and not be auctioned\n    uint256   public minStakedTokensToKeep;\n    // Max number of auctions that can be active at a time\n    uint256   public maxConcurrentAuctions;\n    // Amount of ancestor tokens to auction at a time\n    uint256   public tokensToAuction;\n    // Initial amount of system coins to request in exchange for tokensToAuction\n    uint256   public systemCoinsToRequest;\n    // Amount of rewards per share accumulated (total, see rewardDebt for more info)\n    uint256   public accTokensPerShare;\n    // Balance of the rewards token in this contract since last update\n    uint256   public rewardsBalance;\n    // Staked Supply (== sum of all staked balances)\n    uint256   public stakedSupply;\n    // Percentage of claimed rewards that will be vested\n    uint256   public percentageVested;\n    // Whether the escrow is paused or not\n    uint256   public escrowPaused;\n\n    // Balances (not affected by slashing)\n    mapping(address => uint256)    public descendantBalanceOf;\n    // Exit data\n    mapping(address => ExitRequest) public exitRequests;\n    // The amount of tokens inneligible for claiming rewards (see formula below)\n    mapping(address => uint256)    internal rewardDebt;\n    // Pending reward = (descendant.balanceOf(user) * accTokensPerShare) - rewardDebt[user]\n\n    // The token being deposited in the pool\n    TokenPool                public ancestorPool;\n    // The token used to pay rewards\n    TokenPool                public rewardPool;\n    // Descendant token\n    TokenLike                public descendant;\n    // Auction house for staked tokens\n    AuctionHouseLike         public auctionHouse;\n    // Accounting engine contract\n    AccountingEngineLike     public accountingEngine;\n    // The safe engine contract\n    SAFEEngineLike           public safeEngine;\n    // Contract that drips rewards\n    RewardDripperLike        public rewardDripper;\n    // Escrow for rewards\n    StakingRewardsEscrowLike public escrow;\n\n    // Max delay that can be enforced for an exit\n    uint256 public immutable MAX_DELAY;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 indexed parameter, uint256 data);\n    event ModifyParameters(bytes32 indexed parameter, address data);\n    event ToggleJoin(bool canJoin);\n    event ToggleBypassAuctions(bool bypassAuctions);\n    event ToggleForcedExit(bool forcedExit);\n    event AuctionAncestorTokens(address auctionHouse, uint256 amountAuctioned, uint256 amountRequested);\n    event RequestExit(address indexed account, uint256 deadline, uint256 amount);\n    event Join(address indexed account, uint256 price, uint256 amount);\n    event Exit(address indexed account, uint256 price, uint256 amount);\n    event RewardsPaid(address account, uint256 amount);\n    event EscrowRewards(address escrow, address who, uint256 amount);\n    event PoolUpdated(uint256 accTokensPerShare, uint256 stakedSupply);\n    event FailEscrowRewards(bytes revertReason);\n\n    constructor(\n      address ancestor_,\n      address descendant_,\n      address rewardToken_,\n      address auctionHouse_,\n      address accountingEngine_,\n      address safeEngine_,\n      address rewardDripper_,\n      address escrow_,\n      uint256 maxDelay_,\n      uint256 exitDelay_,\n      uint256 minStakedTokensToKeep_,\n      uint256 tokensToAuction_,\n      uint256 systemCoinsToRequest_,\n      uint256 percentageVested_\n    ) public {\n        require(maxDelay_ > 0, \"GebLenderFirstResortRewardsVested/null-max-delay\");\n        require(exitDelay_ <= maxDelay_, \"GebLenderFirstResortRewardsVested/invalid-exit-delay\");\n        require(minStakedTokensToKeep_ > 0, \"GebLenderFirstResortRewardsVested/null-min-staked-tokens\");\n        require(tokensToAuction_ > 0, \"GebLenderFirstResortRewardsVested/null-tokens-to-auction\");\n        require(systemCoinsToRequest_ > 0, \"GebLenderFirstResortRewardsVested/null-sys-coins-to-request\");\n        require(auctionHouse_ != address(0), \"GebLenderFirstResortRewardsVested/null-auction-house\");\n        require(accountingEngine_ != address(0), \"GebLenderFirstResortRewardsVested/null-accounting-engine\");\n        require(safeEngine_ != address(0), \"GebLenderFirstResortRewardsVested/null-safe-engine\");\n        require(rewardDripper_ != address(0), \"GebLenderFirstResortRewardsVested/null-reward-dripper\");\n        require(escrow_ != address(0), \"GebLenderFirstResortRewardsVested/null-escrow\");\n        require(percentageVested_ < 100, \"GebLenderFirstResortRewardsVested/invalid-percentage-vested\");\n        require(descendant_ != address(0), \"GebLenderFirstResortRewardsVested/null-descendant\");\n\n        authorizedAccounts[msg.sender] = 1;\n        canJoin                        = true;\n        maxConcurrentAuctions          = uint(-1);\n\n        MAX_DELAY                      = maxDelay_;\n\n        exitDelay                      = exitDelay_;\n\n        minStakedTokensToKeep          = minStakedTokensToKeep_;\n        tokensToAuction                = tokensToAuction_;\n        systemCoinsToRequest           = systemCoinsToRequest_;\n        percentageVested               = percentageVested_;\n\n        auctionHouse                   = AuctionHouseLike(auctionHouse_);\n        accountingEngine               = AccountingEngineLike(accountingEngine_);\n        safeEngine                     = SAFEEngineLike(safeEngine_);\n        rewardDripper                  = RewardDripperLike(rewardDripper_);\n        escrow                         = StakingRewardsEscrowLike(escrow_);\n        descendant                     = TokenLike(descendant_);\n\n        ancestorPool                   = new TokenPool(ancestor_);\n        rewardPool                     = new TokenPool(rewardToken_);\n\n        lastRewardBlock                = block.number;\n\n        require(ancestorPool.token().decimals() == 18, \"GebLenderFirstResortRewardsVested/ancestor-decimal-mismatch\");\n        require(descendant.decimals() == 18, \"GebLenderFirstResortRewardsVested/descendant-decimal-mismatch\");\n\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    // --- Math ---\n    uint256 public constant WAD = 10 ** 18;\n    uint256 public constant RAY = 10 ** 27;\n\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"GebLenderFirstResortRewardsVested/add-overflow\");\n    }\n    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"GebLenderFirstResortRewardsVested/sub-underflow\");\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"GebLenderFirstResortRewardsVested/mul-overflow\");\n    }\n    function wdivide(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0, \"GebLenderFirstResortRewardsVested/wdiv-by-zero\");\n        z = multiply(x, WAD) / y;\n    }\n    function wmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Switch between allowing and disallowing joins\n    */\n    function toggleJoin() external isAuthorized {\n        canJoin = !canJoin;\n        emit ToggleJoin(canJoin);\n    }\n    /*\n    * @notify Switch between ignoring and taking into account auctions in canPrintProtocolTokens\n    */\n    function toggleBypassAuctions() external isAuthorized {\n        bypassAuctions = !bypassAuctions;\n        emit ToggleBypassAuctions(bypassAuctions);\n    }\n    /*\n    * @notify Switch between allowing exits when the system is underwater or blocking them\n    */\n    function toggleForcedExit() external isAuthorized {\n        forcedExit = !forcedExit;\n        emit ToggleForcedExit(forcedExit);\n    }\n    /*\n    * @notify Modify an uint256 parameter\n    * @param parameter The name of the parameter to modify\n    * @param data New value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"exitDelay\") {\n          require(data <= MAX_DELAY, \"GebLenderFirstResortRewardsVested/invalid-exit-delay\");\n          exitDelay = data;\n        }\n        else if (parameter == \"minStakedTokensToKeep\") {\n          require(data > 0, \"GebLenderFirstResortRewardsVested/null-min-staked-tokens\");\n          minStakedTokensToKeep = data;\n        }\n        else if (parameter == \"tokensToAuction\") {\n          require(data > 0, \"GebLenderFirstResortRewardsVested/invalid-tokens-to-auction\");\n          tokensToAuction = data;\n        }\n        else if (parameter == \"systemCoinsToRequest\") {\n          require(data > 0, \"GebLenderFirstResortRewardsVested/invalid-sys-coins-to-request\");\n          systemCoinsToRequest = data;\n        }\n        else if (parameter == \"maxConcurrentAuctions\") {\n          require(data > 1, \"GebLenderFirstResortRewardsVested/invalid-max-concurrent-auctions\");\n          maxConcurrentAuctions = data;\n        }\n        else if (parameter == \"escrowPaused\") {\n          require(data <= 1, \"GebLenderFirstResortRewardsVested/invalid-escrow-paused\");\n          escrowPaused = data;\n        }\n        else if (parameter == \"percentageVested\") {\n          require(data < 100, \"GebLenderFirstResortRewardsVested/invalid-percentage-vested\");\n          percentageVested = data;\n        }\n        else revert(\"GebLenderFirstResortRewardsVested/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /*\n    * @notify Modify an address parameter\n    * @param parameter The name of the parameter to modify\n    * @param data New value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"GebLenderFirstResortRewardsVested/null-data\");\n\n        if (parameter == \"auctionHouse\") {\n          auctionHouse = AuctionHouseLike(data);\n        }\n        else if (parameter == \"accountingEngine\") {\n          accountingEngine = AccountingEngineLike(data);\n        }\n        else if (parameter == \"rewardDripper\") {\n          rewardDripper = RewardDripperLike(data);\n        }\n        else if (parameter == \"escrow\") {\n          escrow = StakingRewardsEscrowLike(data);\n        }\n        else revert(\"GebLenderFirstResortRewardsVested/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Getters ---\n    /*\n    * @notify Return the ancestor token balance for this contract\n    */\n    function depositedAncestor() public view returns (uint256) {\n        return ancestorPool.balance();\n    }\n    /*\n    * @notify Returns how many ancestor tokens are offered for one descendant token\n    */\n    function ancestorPerDescendant() public view returns (uint256) {\n        return stakedSupply == 0 ? WAD : wdivide(depositedAncestor(), stakedSupply);\n    }\n    /*\n    * @notify Returns how many descendant tokens are offered for one ancestor token\n    */\n    function descendantPerAncestor() public view returns (uint256) {\n        return stakedSupply == 0 ? WAD : wdivide(stakedSupply, depositedAncestor());\n    }\n    /*\n    * @notify Given a custom amount of ancestor tokens, it returns the corresponding amount of descendant tokens to mint when someone joins\n    * @param wad The amount of ancestor tokens to compute the descendant tokens for\n    */\n    function joinPrice(uint256 wad) public view returns (uint256) {\n        return wmultiply(wad, descendantPerAncestor());\n    }\n    /*\n    * @notify Given a custom amount of descendant tokens, it returns the corresponding amount of ancestor tokens to send when someone exits\n    * @param wad The amount of descendant tokens to compute the ancestor tokens for\n    */\n    function exitPrice(uint256 wad) public view returns (uint256) {\n        return wmultiply(wad, ancestorPerDescendant());\n    }\n\n    /*\n    * @notice Returns whether the protocol is underwater or not\n    */\n    function protocolUnderwater() public view returns (bool) {\n        uint256 unqueuedUnauctionedDebt = accountingEngine.unqueuedUnauctionedDebt();\n\n        return both(\n          accountingEngine.debtAuctionBidSize() <= unqueuedUnauctionedDebt,\n          safeEngine.coinBalance(address(accountingEngine)) < unqueuedUnauctionedDebt\n        );\n    }\n\n    /*\n    * @notice Burn descendant tokens in exchange for getting ancestor tokens from this contract\n    * @return Whether the pool can auction ancestor tokens\n    */\n    function canAuctionTokens() public view returns (bool) {\n        return both(\n          both(protocolUnderwater(), addition(minStakedTokensToKeep, tokensToAuction) <= depositedAncestor()),\n          auctionHouse.activeStakedTokenAuctions() < maxConcurrentAuctions\n        );\n    }\n\n    /*\n    * @notice Returns whether the system can mint new ancestor tokens\n    */\n    function canPrintProtocolTokens() public view returns (bool) {\n        return both(\n          !canAuctionTokens(),\n          either(auctionHouse.activeStakedTokenAuctions() == 0, bypassAuctions)\n        );\n    }\n\n    /*\n    * @notice Returns unclaimed rewards for a given user\n    */\n    function pendingRewards(address user) public view returns (uint256) {\n        uint accTokensPerShare_ = accTokensPerShare;\n        if (block.number > lastRewardBlock && stakedSupply != 0) {\n            uint increaseInBalance = (block.number - lastRewardBlock) * rewardDripper.rewardPerBlock();\n            accTokensPerShare_ = addition(accTokensPerShare_, multiply(increaseInBalance, RAY) / stakedSupply);\n        }\n        return subtract(multiply(descendantBalanceOf[user], accTokensPerShare_) / RAY, rewardDebt[user]);\n    }\n\n    /*\n    * @notice Returns rewards earned per block for each token deposited (WAD)\n    */\n    function rewardRate() public view returns (uint256) {\n        if (stakedSupply == 0) return 0;\n        return (rewardDripper.rewardPerBlock() * WAD) / stakedSupply;\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notify Updates the pool and pays rewards (if any)\n    * @dev Must be included in deposits and withdrawals\n    */\n    modifier payRewards() {\n        updatePool();\n\n        if (descendantBalanceOf[msg.sender] > 0 && rewardPool.balance() > 0) {\n            // Pays the reward\n            uint256 pending = subtract(multiply(descendantBalanceOf[msg.sender], accTokensPerShare) / RAY, rewardDebt[msg.sender]);\n\n            uint256 vested;\n            if (both(address(escrow) != address(0), escrowPaused == 0)) {\n              vested = multiply(pending, percentageVested) / 100;\n\n              try escrow.escrowRewards(msg.sender, vested) {\n                rewardPool.transfer(address(escrow), vested);\n                emit EscrowRewards(address(escrow), msg.sender, vested);\n              } catch(bytes memory revertReason) {\n                emit FailEscrowRewards(revertReason);\n              }\n            }\n\n            rewardPool.transfer(msg.sender, subtract(pending, vested));\n            rewardsBalance = rewardPool.balance();\n\n            emit RewardsPaid(msg.sender, pending);\n        }\n        _;\n\n        rewardDebt[msg.sender] = multiply(descendantBalanceOf[msg.sender], accTokensPerShare) / RAY;\n    }\n\n    /*\n    * @notify Pays outstanding rewards to msg.sender\n    */\n    function getRewards() external nonReentrant payRewards {}\n\n    /*\n    * @notify Pull funds from the dripper\n    */\n    function pullFunds() public {\n        rewardDripper.dripReward(address(rewardPool));\n    }\n\n    /*\n    * @notify Updates pool data\n    */\n    function updatePool() public {\n        if (block.number <= lastRewardBlock) return;\n        lastRewardBlock = block.number;\n        if (stakedSupply == 0) return;\n\n        pullFunds();\n        uint256 increaseInBalance = subtract(rewardPool.balance(), rewardsBalance);\n        rewardsBalance = addition(rewardsBalance, increaseInBalance);\n\n        // Updates distribution info\n        accTokensPerShare = addition(accTokensPerShare, multiply(increaseInBalance, RAY) / stakedSupply);\n        emit PoolUpdated(accTokensPerShare, stakedSupply);\n    }\n\n    /*\n    * @notify Create a new auction that sells ancestor tokens in exchange for system coins\n    */\n    function auctionAncestorTokens() external nonReentrant {\n        require(canAuctionTokens(), \"GebLenderFirstResortRewardsVested/cannot-auction-tokens\");\n\n        ancestorPool.transfer(address(this), tokensToAuction);\n        ancestorPool.token().approve(address(auctionHouse), tokensToAuction);\n        auctionHouse.startAuction(tokensToAuction, systemCoinsToRequest);\n        updatePool();\n\n        emit AuctionAncestorTokens(address(auctionHouse), tokensToAuction, systemCoinsToRequest);\n    }\n\n    /*\n    * @notify Join ancestor tokens\n    * @param wad The amount of ancestor tokens to join\n    */\n    function join(uint256 wad) external nonReentrant payRewards {\n        require(both(canJoin, !protocolUnderwater()), \"GebLenderFirstResortRewardsVested/join-not-allowed\");\n        require(wad > 0, \"GebLenderFirstResortRewardsVested/null-ancestor-to-join\");\n        uint256 price = joinPrice(wad);\n        require(price > 0, \"GebLenderFirstResortRewardsVested/null-join-price\");\n\n        require(ancestorPool.token().transferFrom(msg.sender, address(ancestorPool), wad), \"GebLenderFirstResortRewardsVested/could-not-transfer-ancestor\");\n        descendant.mint(msg.sender, price);\n\n        descendantBalanceOf[msg.sender] = addition(descendantBalanceOf[msg.sender], price);\n        stakedSupply = addition(stakedSupply, price);\n\n        emit Join(msg.sender, price, wad);\n    }\n    /*\n    * @notice Request an exit for a specific amount of ancestor tokens\n    * @param wad The amount of tokens to exit\n    */\n    function requestExit(uint wad) external nonReentrant payRewards {\n        require(wad > 0, \"GebLenderFirstResortRewardsVested/null-amount-to-exit\");\n\n        exitRequests[msg.sender].deadline      = addition(now, exitDelay);\n        exitRequests[msg.sender].lockedAmount  = addition(exitRequests[msg.sender].lockedAmount, wad);\n\n        descendantBalanceOf[msg.sender] = subtract(descendantBalanceOf[msg.sender], wad);\n        descendant.burn(msg.sender, wad);\n\n        emit RequestExit(msg.sender, exitRequests[msg.sender].deadline, wad);\n    }\n    /*\n    * @notify Exit ancestor tokens\n    */\n    function exit() external nonReentrant {\n        require(both(now >= exitRequests[msg.sender].deadline, exitRequests[msg.sender].lockedAmount > 0), \"GebLenderFirstResortRewardsVested/wait-more\");\n        require(either(!protocolUnderwater(), forcedExit), \"GebLenderFirstResortRewardsVested/exit-not-allowed\");\n\n        uint256 price = exitPrice(exitRequests[msg.sender].lockedAmount);\n        stakedSupply  = subtract(stakedSupply, exitRequests[msg.sender].lockedAmount);\n        ancestorPool.transfer(msg.sender, price);\n        emit Exit(msg.sender, price, exitRequests[msg.sender].lockedAmount);\n        delete exitRequests[msg.sender];\n    }\n}"}}}