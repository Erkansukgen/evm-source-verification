{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ConfiigurationRegistry.sol":{"content":"pragma solidity 0.6.10;\n\n\ninterface ConfigurationRegistryInterface {\n  event ConfigurationModified(bytes32 indexed key, bytes32 value);\n  function set(bytes32 key, bytes32 value) external;\n  function get(bytes32 key) external view returns (bytes32 value);\n  function getKey(\n    string calldata stringToHash\n  ) external pure returns (bytes32 key);\n}\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n *\n * In order to transfer ownership, a recipient must be specified, at which point\n * the specified recipient can call `acceptOwnership` and take ownership.\n */\ncontract TwoStepOwnable {\n  address private _owner;\n\n  address private _newPotentialOwner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Initialize contract by setting transaction submitter as initial owner.\n   */\n  constructor() internal {\n    _owner = tx.origin;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner(), \"TwoStepOwnable: caller is not the owner.\");\n    _;\n  }\n\n  /**\n   * @dev Returns true if the caller is the current owner.\n   */\n  function isOwner() public view returns (bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows a new account (`newOwner`) to accept ownership.\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(\n      newOwner != address(0),\n      \"TwoStepOwnable: new potential owner is the zero address.\"\n    );\n\n    _newPotentialOwner = newOwner;\n  }\n\n  /**\n   * @dev Cancel a transfer of ownership to a new account.\n   * Can only be called by the current owner.\n   */\n  function cancelOwnershipTransfer() public onlyOwner {\n    delete _newPotentialOwner;\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to the caller.\n   * Can only be called by a new potential owner set by the current owner.\n   */\n  function acceptOwnership() public {\n    require(\n      msg.sender == _newPotentialOwner,\n      \"TwoStepOwnable: current owner must set caller as new potential owner.\"\n    );\n\n    delete _newPotentialOwner;\n\n    emit OwnershipTransferred(_owner, msg.sender);\n\n    _owner = msg.sender;\n  }\n}\n\n\ncontract ConfigurationRegistry is\n  ConfigurationRegistryInterface, TwoStepOwnable {\n  mapping(bytes32 => bytes32) private _values;\n    \n  function set(bytes32 key, bytes32 value) external override onlyOwner {\n    _values[key] = value;\n    emit ConfigurationModified(key, value);\n  }\n    \n  function get(\n    bytes32 key\n  ) external view override returns (bytes32 value) {\n    value = _values[key];\n  }\n  \n  function getKey(\n    string calldata stringToHash\n  ) external pure override returns (bytes32 key) {\n    key = keccak256(bytes(stringToHash));\n  }\n}"}}}