{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NFTOracle.sol":{"content":"pragma solidity >=0.5.0 <0.6.0;\r\n\r\ncontract NFTRegistryLike {\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n    function data(uint tokenID) public view returns (address, uint, bytes32, uint64);\r\n}\r\n\r\ncontract NFTUpdateLike {\r\n    function update(bytes32 nftID, uint value, uint risk) public;\r\n    function file(bytes32 name, bytes32 nftID, uint maturityDate) public;\r\n}\r\n\r\ncontract NFTOracle {\r\n    bytes32 public fingerprint;\r\n\r\n    // mapping (owners => uint);\r\n    mapping (address => uint) public wards;\r\n\r\n    // mapping (token holders)\r\n    mapping (address => uint) public tokenHolders;\r\n\r\n    // mapping (nftID => loanData);\r\n    mapping (uint => NFTData) public nftData;\r\n\r\n    // nft registry that holds the metadata for each nft\r\n    NFTRegistryLike public registry;\r\n\r\n    // nft update that holds the value of NFT's risk and value\r\n    NFTUpdateLike public nftUpdate;\r\n\r\n    struct NFTData {\r\n        uint80 riskScore;\r\n        uint128 value;\r\n        uint64 maturityDate;\r\n        uint48 timestamp;\r\n    }\r\n\r\n    event NFTValueUpdated(uint indexed tokenID);\r\n\r\n    constructor (\r\n        address _nftUpdate,\r\n        address _registry,\r\n        bytes32 _fingerprint,\r\n        address _ward,\r\n        address[] memory _tokenHolders) public {\r\n\r\n        fingerprint = _fingerprint;\r\n        registry = NFTRegistryLike(_registry);\r\n        nftUpdate = NFTUpdateLike(_nftUpdate);\r\n\r\n        // update nft token holders\r\n        uint i;\r\n        for (i=0; i<_tokenHolders.length; i++) {\r\n            tokenHolders[_tokenHolders[i]] = 1;\r\n        }\r\n\r\n        // add the creator to auth\r\n        wards[_ward] = 1;\r\n        wards[msg.sender] = 1;\r\n    }\r\n\r\n    function rely(address usr) public auth { wards[usr] = 1; }\r\n    function deny(address usr) public auth { wards[usr] = 0; }\r\n    function relyTokenHolder(address usr) public auth { tokenHolders[usr] = 1; }\r\n    function denyTokenHolder(address usr) public auth { tokenHolders[usr] = 0; }\r\n    modifier auth { require(wards[msg.sender] == 1); _; }\r\n    modifier authToken(uint token) {\r\n        require(tokenHolders[registry.ownerOf(token)] == 1, \"oracle/token owner not allowed\");\r\n        _;\r\n    }\r\n\r\n    function depend(address _nftUpdate) public auth {\r\n        nftUpdate = NFTUpdateLike(_nftUpdate);\r\n    }\r\n\r\n    function update(uint tokenID, bytes32 _fingerprint, bytes32 _result) public authToken(tokenID) {\r\n        require(fingerprint == _fingerprint, \"oracle/fingerprint mismatch\");\r\n        (uint80 risk, uint128 value) = getRiskAndValue(_result);\r\n        (, , , uint64 maturityDate) = registry.data(tokenID);\r\n        nftData[tokenID] = NFTData(risk, value, maturityDate, uint48(block.timestamp));\r\n\r\n        // pass value to NFT update\r\n        bytes32 nftID = keccak256(abi.encodePacked(address(registry), tokenID));\r\n        nftUpdate.update(nftID, uint(value), uint(risk));\r\n        nftUpdate.file(\"maturityDate\",nftID,uint(maturityDate));\r\n        emit NFTValueUpdated(tokenID);\r\n    }\r\n\r\n    function getRiskAndValue(bytes32 _result) public pure returns (uint80, uint128) {\r\n        bytes memory riskb = sliceFromBytes32(_result, 0, 16);\r\n        bytes memory valueb = sliceFromBytes32(_result, 16, 32);\r\n        return (uint80(toUint128(riskb)), toUint128(valueb));\r\n    }\r\n\r\n    function sliceFromBytes32(bytes32 data, uint start, uint end) internal pure returns (bytes memory) {\r\n        bytes memory res = new bytes(end -start);\r\n        for (uint i=0; i< end -start; i++){\r\n            res[i] = data[i+start];\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function toUint128(bytes memory _bytes) internal pure returns (uint128) {\r\n        uint128 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x10), 0))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}"}}}