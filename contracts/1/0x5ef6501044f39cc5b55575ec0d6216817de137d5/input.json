{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/CertECRecovery.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/**\n * @title Eliptic curve signature operations\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\n * See https://github.com/ethereum/solidity/issues/864\n */\nlibrary CertECRecovery {\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        if (sig.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            // solium-disable-next-line arg-overflow\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * toEthSignedMessageHash\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n     * and hash the result\n     */\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n            );\n    }\n}\n"},"browser/CertOwnable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract CertOwnable {\n    address public owner;\n\n    event OwnershipRenounced(address indexed previousOwner);\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /// @dev reference to the address that can modify the ether fee.\n    address public dappManager;\n\n    /// @dev Needed to move the DappManager here due to the fact that only the owners can call performFeelessTransaction\n    function setDappManager(address _dappManager) external onlyOwner {\n        dappManager = _dappManager;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"CertOwnable: Only owner can call this\");\n        _;\n    }\n\n    modifier onlyDappManagerOrOwner() virtual {\n        require(\n            msg.sender == dappManager || msg.sender == owner,\n            \"CertOwnable: Dapp manager or owner permissions required\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(owner);\n        owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address _newOwner) internal {\n        require(\n            _newOwner != address(0),\n            \"CertOwnable: New owner must have a valid address\"\n        );\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n"},"browser/CertPausable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/// @title Pausable\n/// @notice This contract should override the pause an put permissioned access on it.\n/// @notice WARNING: If a permissioned access from children is not provided\n/// to the pause and unpause functions this can become a security issue. Backed up by tests on each contract.\n/// @dev Base contract which allows children to implement an emergency stop mechanism.\n/// @dev Base on open zeppelin pausable.\ncontract CertPausable {\n    event Paused();\n    event Unpaused();\n\n    bool public paused = false;\n\n    /// @dev Modifier to make a function callable only when the contract is unpaused.\n    modifier whenNotPaused() {\n        require(!paused, \"CertPausable: Contract paused\");\n        _;\n    }\n\n    /// @dev Modifier to make a function callable only when the contract is paused.\n    modifier whenPaused() {\n        require(paused, \"CertPausable: Contract not paused\");\n        _;\n    }\n\n    /// @dev called by the owner to pause, triggers stopped state\n    function pause() public virtual whenNotPaused {\n        paused = true;\n        emit Paused();\n    }\n\n    /// @dev called by the owner to unpause, returns to normal state\n    function unpause() public virtual whenPaused {\n        paused = false;\n        emit Unpaused();\n    }\n}\n"},"browser/CertSafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary CertSafeMath {\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n"},"browser/Feeless.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\nimport {CertOwnable} from \"./CertOwnable.sol\";\nimport {CertECRecovery} from \"./CertECRecovery.sol\";\nimport {IValidatorRegistry} from \"./IValidatorRegistry.sol\";\n\n/// @title Feeless\n/// @notice Usage: Used as an extension in contracts that want to execute feeless functions.\n/// @notice Usage: Apply the feeless modifier.\n/// @dev Based on https://github.com/bitclave/Feeless\ncontract Feeless is CertOwnable {\n    /// @dev The replacement for msg.sender on functions that use the feeless modifier.\n    address internal msgSender;\n\n    /// @dev Simple address reference to the validatorRegistry.\n    IValidatorRegistry public validatorRegistry;\n\n    /// @dev Mimics the blockchain nonce relative to this contract (or contract that extents).\n    mapping(address => uint256) public nonces;\n\n    /// @dev Holds reference to the initial signer of the transaction in the msgSender variable.\n    /// @dev After execution the variable is reset.\n    modifier feeless() {\n        if (msgSender == address(0)) {\n            msgSender = msg.sender;\n            _;\n            msgSender = address(0);\n        } else {\n            _;\n        }\n    }\n\n    struct CallResult {\n        bool success;\n        bytes payload;\n    }\n\n    /// @notice Only the certSign owner can call this function.\n    /// @dev Signed transactions are passed to this function.\n    function performFeelessTransaction(\n        address sender,\n        address payable target,\n        bytes memory data,\n        uint256 nonce,\n        bytes memory sig\n    ) public payable onlyDappManagerOrOwnerOrValidator {\n        require(\n            address(this) == target,\n            \"Feeless: Target should be the extended contract\"\n        );\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                prefix,\n                keccak256(abi.encodePacked(target, data, nonce))\n            )\n        );\n        msgSender = CertECRecovery.recover(hash, sig);\n        require(msgSender == sender, \"Feeless: Unexpected sender\");\n        require(nonces[msgSender]++ == nonce, \"Feeless: nonce does not comply\");\n        (bool _success, bytes memory _payload) = target.delegatecall(data);\n        CallResult memory callResult = CallResult(_success, _payload);\n        require(callResult.success, \"Feeless: Call failed\");\n        msgSender = address(0);\n    }\n\n    modifier onlyDappManagerOrOwnerOrValidator() {\n        bool isValidator = IValidatorRegistry(validatorRegistry).isValidator(\n            msg.sender\n        );\n        require(\n            msg.sender == dappManager || msg.sender == owner || isValidator,\n            \"CertOwnable: Dapp manager, owner or validator permissions required\"\n        );\n        _;\n    }\n}\n"},"browser/IAttributeRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/// @title Attribute Registry interface\ninterface IAttributeRegistry {\n    function attributePositionMapping(bytes32) external view returns (uint256);\n\n    function attributesCount() external view returns (uint256 _count);\n\n    function validAttributeMask() external view returns (bytes8);\n}\n"},"browser/IClientRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/// @title Client Registry Interface\ninterface IClientRegistry {\n    function isClient(address _client) external view returns (bool _isClient);\n\n    function isValidatorForClient(address _validator, address _client)\n        external\n        view\n        returns (bool _isValidator);\n\n    function isValidatedClient(address _client) external view returns (bool);\n\n    function getValidatorsForClient(address _client)\n        external\n        view\n        returns (address[] memory _validators);\n\n    function canAddRequestWithMap(address _client, bytes8 _requestAttributeMap)\n        external\n        view\n        returns (bool _canAdd);\n\n    function isClientRevoked(address _identity)\n        external\n        view\n        returns (bool _isRevoked);\n\n    function revokeIdentity(address _revokeIdentity, bytes32 _revokeReason)\n        external;\n\n    function suspendIdentity(address _suspendIdentity) external;\n\n    function unsuspendIdentity(address _unSuspendIdentity) external;\n}\n"},"browser/IDataConsumerRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/// @title Data Consumer Registry Interface\ninterface IDataConsumerRegistry {\n    function isDataConsumer(address _dataConsumer)\n        external\n        view\n        returns (bool _isDataConsumer);\n\n    function isTrusted(address _dataConsumer)\n        external\n        view\n        returns (bool _isTrusted);\n}\n"},"browser/IIdentityRequestRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/// @title Identity Request Registry Interface\ninterface IIdentityRequestRegistry {\n    function isRequesterForRequest(address _requester, uint256 _id)\n        external\n        view\n        returns (bool _isRequester);\n}\n"},"browser/ITaxRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/// @title Tax registry interface.\ninterface ITaxRegistry {\n    function registerFee(\n        uint256 _index,\n        uint256 _value,\n        address payable _sender\n    ) external payable;\n\n    function isExpired(uint256 _index) external returns (bool _isExpired);\n}\n"},"browser/IValidatorRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\n/// @title Validator Registry Interface\ninterface IValidatorRegistry {\n    function isValidator(address _validator)\n        external\n        view\n        returns (bool _isValidator);\n\n    function getSubstantialLevel(address _validator)\n        external\n        view\n        returns (bool _substantialLevel);\n}\n"},"browser/IdentityRequestRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\nimport {CertSafeMath} from \"./CertSafeMath.sol\";\nimport {IClientRegistry} from \"./IClientRegistry.sol\";\nimport {IValidatorRegistry} from \"./IValidatorRegistry.sol\";\nimport {IAttributeRegistry} from \"./IAttributeRegistry.sol\";\nimport {IDataConsumerRegistry} from \"./IDataConsumerRegistry.sol\";\nimport {Feeless} from \"./Feeless.sol\";\nimport {CertPausable} from \"./CertPausable.sol\";\nimport {ITaxRegistry} from \"./ITaxRegistry.sol\";\nimport {IIdentityRequestRegistry} from \"./IIdentityRequestRegistry.sol\";\n\n/// @title Identity Request Registry\n/// @notice Request for identity shares are added here.\n/// @dev Key agreements are logged here.\ncontract IdentityRequestRegistry is\n    Feeless,\n    CertPausable,\n    IIdentityRequestRegistry\n{\n    using CertSafeMath for uint256;\n\n    /// @notice Offchain event\n    /// @notice Event fired when a request has been added.\n    /// @param _id Id of the request (auto incremented in the requests mapping).\n    /// @param _requester The provider address.\n    /// @param _client The validated client.\n    /// @param _requestAttributeMap Specifies the attributes that the provider wants to certify.\n    /// @param _keyExchangeConsumerValidator Part of the Diffie-Hellman symmetric key exchange algorithm. Generated by provider.\n    /// @param _isPreauthorised Indicates if the request was created using addPreauthroisedRequest function.\n    /// @param _keyExchangeConsumerClient Will hold a value only if @param _isPreauthorised is false.\n    event RequestCreated(\n        uint256 indexed _id,\n        address indexed _requester,\n        address indexed _client,\n        bytes8 _requestAttributeMap,\n        bytes32 _keyExchangeConsumerValidator,\n        bool _isPreauthorised,\n        bytes32 _keyExchangeConsumerClient\n    );\n\n    /// @notice Offchain event\n    /// @notice Event fired when a request has been confirmed by a client.\n    /// @param _id Id of the request (auto incremented in the requests mapping).\n    /// @param _accepted Marks if the client granted permission.\n    /// @param _client Client for which the request with the specified @param _id was launched.\n    /// @param _dataConsumer Data consumer that initially launched this request.\n    /// @param _validators The validators that should answer to this specific request.\n    event RequestClientAccepted(\n        uint256 indexed _id,\n        bool _accepted,\n        address _client,\n        address indexed _dataConsumer,\n        address[] indexed _validators,\n        bool _isPreauthorised,\n        bytes32 _keyExchangeClientConsumer\n    );\n\n    /// @notice Offchain event\n    /// @notice Event fired when a request has been confirmed by a client.\n    /// @param _id Id of the request (auto incremented in the requests mapping).\n    /// @param _accepted Marks if the client granted permission.\n    /// @param _client Client for which the request with the specified @param _id was launched.\n    /// @param _dataConsumer Data consumer that initially launched this request.\n    /// @param _validators The validators that should answer to this specific request.\n    event RequestClientRejected(\n        uint256 indexed _id,\n        bool _accepted,\n        address _client,\n        address indexed _dataConsumer,\n        address[] indexed _validators\n    );\n\n    /// @notice Offchain event\n    /// @notice Event fired when a request was verified.\n    /// @param _id Id of the request (auto incremented in the requests mapping).\n    /// @param _keyExchangeValidatorConsumer Part of the Diffie-Hellman symmetric key exchange algorithm generated by validator.\n    /// @param _hashedDataWithSharedSecret A message signed with AES-CMAC(requestMasterHash, secret) for this request.\n    /// @param _dataConsumer Data consumer that initially launched this request.\n    event RequestVerified(\n        uint256 indexed _id,\n        bytes32 _keyExchangeValidatorConsumer,\n        bytes32 _hashedDataWithSharedSecret,\n        address indexed _dataConsumer,\n        bool _substantialLevel\n    );\n\n    /// @dev Both keyAgreement1 (KA1) and keyAgreement2 (KA2) create a shared key. -> Diffie-Hellman algorithm.\n    /// @dev id - autogenerated.\n    /// @dev The keyExchangeConsumerValidator and keyExchangeValidatorConsumer create a shared key between the consumer and validator. -> Diffie-Hellman algorithm.\n    /// @dev The keyExchangeConsumerClient and keyExchangeClientConsumer create a shared key between the consumer and client. -> Diffie-Hellman algorithm.\n    struct Request {\n        uint256 id;\n        address requester;\n        address client;\n        bytes8 attributeMap;\n        bytes32 keyExchangeConsumerValidator;\n        bytes32 keyExchangeValidatorConsumer;\n        bytes32 hashedDataWithSharedSecret;\n        bool clientAgreed;\n        // unused (kept in code so that it won't break web implementation)\n        /// @deprecated\n        bool expired;\n        bool clientRejected;\n        bool preauthorised;\n        bytes32 keyExchangeConsumerClient;\n        bytes32 keyExchangeClientConsumer;\n    }\n\n    /// @dev Index used for id auto-generation.\n    uint256 internal index;\n\n    /// @dev Auto Incremented Id mapping of requests.\n    mapping(uint256 => Request) public requests;\n\n    /// @dev Interface reference to validator registry.\n    IDataConsumerRegistry public dataConsumerRegistry;\n\n    /// @dev Interface reference to attribute registry.\n    IAttributeRegistry public attributeRegistry;\n\n    /// @dev Interface reference to client registry.\n    IClientRegistry public clientRegistry;\n\n    /// @dev Interface reference to tax registry.\n    address payable public taxRegistryAddress;\n\n    /// @param _validatorRegistry Requires ValidatorRegistry to be deployed before this.\n    /// @param _dataConsumerRegistry Requires DataConsumerRegistry to be deployed before this.\n    /// @param _attributeRegistry Requires AttributeRegistry to be deployed before this.\n    /// @param _clientRegistry Requires ClientRegistry to be deployed before this.\n    constructor(\n        address _validatorRegistry,\n        address _dataConsumerRegistry,\n        address _attributeRegistry,\n        address _clientRegistry,\n        address payable _taxRegistryAddress\n    ) public {\n        validatorRegistry = IValidatorRegistry(_validatorRegistry);\n        dataConsumerRegistry = IDataConsumerRegistry(_dataConsumerRegistry);\n        attributeRegistry = IAttributeRegistry(_attributeRegistry);\n        clientRegistry = IClientRegistry(_clientRegistry);\n        taxRegistryAddress = _taxRegistryAddress;\n    }\n\n    /// @notice Creates an empty request with auto generated index.\n    /// @notice Requires fee payment directly in the smart contract.\n    /// @dev KeyExchangeConsumerValidator Is computed with provider's privateKey.\n    /// @param _requestAttributeMap uses the bitmask to specify the attributes required.\n    /// @param _client The validated client.\n    /// @param _requestAttributeMap Specifies the attributes that the provider wants to certify.\n    /// @param _keyExchangeConsumerValidator Part of the Diffie-Hellman symmetric key exchange algorithm. Generated by provider.\n    /// @param _keyExchangeConsumerClient Part of the Diffie-Hellman symmetric key exchange algorithm. Generated by provider.\n    /// @return _id Id of the newly created request request.\n    function addRequest(\n        address _client,\n        bytes8 _requestAttributeMap,\n        bytes32 _keyExchangeConsumerValidator,\n        bytes32 _keyExchangeConsumerClient\n    )\n        external\n        payable\n        whenNotPaused\n        canAddRequests(msg.sender, _client, false)\n        returns (uint256 _id)\n    {\n        _id = _addRequest(\n            _client,\n            _requestAttributeMap,\n            _keyExchangeConsumerValidator,\n            _keyExchangeConsumerClient,\n            msg.sender,\n            false\n        );\n        taxRegistryAddress.transfer(msg.value);\n        taxRegistry().registerFee(_id, msg.value, msg.sender);\n    }\n\n    /// @notice Creates a preauthorised request with auto generated index.\n    /// @notice Requires fee payment directly in the smart contract.\n    /// @dev KeyExchangeConsumerValidator Is computed with provider's privateKey.\n    /// @param _requestAttributeMap uses the bitmask to specify the attributes required.\n    /// @param _client The validated client.\n    /// @param _requestAttributeMap Specifies the attributes that the provider wants to certify.\n    /// @param _keyExchangeConsumerValidator Part of the Diffie-Hellman symmetric key exchange algorithm. Generated by provider.\n    /// @return _id of the newly created request request.\n    function addPreauthorisedRequest(\n        address _client,\n        bytes8 _requestAttributeMap,\n        bytes32 _keyExchangeConsumerValidator\n    )\n        external\n        payable\n        whenNotPaused\n        canAddRequests(msg.sender, _client, true)\n        returns (uint256 _id)\n    {\n        _id = _addRequest(\n            _client,\n            _requestAttributeMap,\n            _keyExchangeConsumerValidator,\n            bytes32(0),\n            msg.sender,\n            true\n        );\n        _grantPermission(_id, true, bytes32(0), _client);\n        taxRegistryAddress.transfer(msg.value);\n        taxRegistry().registerFee(_id, msg.value, msg.sender);\n    }\n\n    /// @notice An empty request with auto generated index is created.\n    /// @dev Index is returned.\n    /// @dev KeyExchangeConsumerValidator Is computed with provider's privateKey.\n    /// @param _requestAttributeMap uses the bitmask to specify the attributes required.\n    /// @param _client The validated client.\n    /// @param _keyExchangeConsumerValidator Part of the Diffie-Hellman symmetric key exchange algorithm. Generated by provider.\n    /// @param _keyExchangeConsumerClient Part of the Diffie-Hellman symmetric key exchange algorithm. Generated by provider.\n    /// @return _id Id of the newly created request request.\n    function addRequestFeeless(\n        address _client,\n        bytes8 _requestAttributeMap,\n        bytes32 _keyExchangeConsumerValidator,\n        bytes32 _keyExchangeConsumerClient\n    )\n        external\n        feeless()\n        whenNotPaused\n        canAddRequests(msgSender, _client, false)\n        returns (uint256 _id)\n    {\n        _id = _addRequest(\n            _client,\n            _requestAttributeMap,\n            _keyExchangeConsumerValidator,\n            _keyExchangeConsumerClient,\n            msgSender,\n            false\n        );\n    }\n\n    /// @notice Creates a preauthorised request with auto generated index.\n    /// @dev Index is returned.\n    /// @dev KeyExchangeConsumerValidator Is computed with provider's privateKey.\n    /// @param _client The validated client.\n    /// @param _keyExchangeConsumerValidator Part of the Diffie-Hellman symmetric key exchange algorithm. Generated by provider.\n    /// @param _requestAttributeMap uses the bitmask to specify the attributes required.\n    /// @return _id Id of the newly created request request.\n    function addPreauthorisedRequestFeeless(\n        address _client,\n        bytes8 _requestAttributeMap,\n        bytes32 _keyExchangeConsumerValidator\n    )\n        external\n        feeless()\n        whenNotPaused\n        canAddRequests(msgSender, _client, true)\n        returns (uint256 _id)\n    {\n        _id = _addRequest(\n            _client,\n            _requestAttributeMap,\n            _keyExchangeConsumerValidator,\n            bytes32(0),\n            msgSender,\n            true\n        );\n        _grantPermission(_id, true, bytes32(0), _client);\n    }\n\n    /// @notice Response for request from client with key exchange.\n    /// @dev updates the request object associated with the ID.\n    /// @param _id Id of the request (auto incremented in the requests mapping).\n    /// @param _keyExchangeClientConsumer   Part of the Diffie-Hellman symmetric key exchange algorithm. Generated by client.\n    function grantPermission(\n        uint256 _id,\n        bool _clientAgreed,\n        bytes32 _keyExchangeClientConsumer\n    ) external whenNotPaused {\n        _grantPermission(\n            _id,\n            _clientAgreed,\n            _keyExchangeClientConsumer,\n            msg.sender\n        );\n    }\n\n    /// @notice Response for request from client with key exchange.\n    /// @dev updates the request object associated with the ID.\n    /// @param _id Id of the request (auto incremented in the requests mapping).\n    function grantPermissionFeeless(\n        uint256 _id,\n        bool _clientAgreed,\n        bytes32 _keyExchangeClientConsumer\n    ) external whenNotPaused feeless() {\n        _grantPermission(\n            _id,\n            _clientAgreed,\n            _keyExchangeClientConsumer,\n            msgSender\n        );\n    }\n\n    /// @notice Response for request from validator with Validator-Provider's key agreement\n    /// @param _hashedDataWithSharedSecret Obtained from a AES-CMAC(hashOfData, sharedSecret)\n    /// @param _keyExchangeValidatorConsumer Is computed with provider's privateKey.\n    /// @param _id Id of the request (auto incremented in the requests mapping).\n    /// @dev SharedSecret is computed from KA1 and KA2 with private key\n    function verifyRequest(\n        uint256 _id,\n        bytes32 _keyExchangeValidatorConsumer,\n        bytes32 _hashedDataWithSharedSecret\n    ) external onlyValidatorForRequest(_id) whenNotPaused clientAgreed(_id) {\n        require(\n            requests[_id].keyExchangeConsumerValidator != bytes32(0),\n            \"Key exchangeCV should not be empty\"\n        );\n        // require(requests[_id].clientAgreed, \"Client should agree first\");\n        require(\n            requests[_id].keyExchangeValidatorConsumer == bytes32(0),\n            \"Key exchangeVC should not be empty\"\n        );\n        requests[_id]\n            .keyExchangeValidatorConsumer = _keyExchangeValidatorConsumer;\n        requests[_id].hashedDataWithSharedSecret = _hashedDataWithSharedSecret;\n        address _dataConsumer = requests[_id].requester;\n        bool _substantialLevel = validatorRegistry.getSubstantialLevel(\n            _dataConsumer\n        );\n\n        emit RequestVerified(\n            _id,\n            _keyExchangeValidatorConsumer,\n            _hashedDataWithSharedSecret,\n            _dataConsumer,\n            _substantialLevel\n        );\n    }\n\n    /// @dev Part of the IIdentityRequestRegistry interface\n    function isRequesterForRequest(address _requester, uint256 _id)\n        external\n        override\n        view\n        returns (bool _isRequester)\n    {\n        _isRequester = requests[_id].requester == _requester;\n    }\n\n    /// @dev Called by the owner to pause, triggers stopped state.\n    /// @dev Overrides base function with permissioned access.\n    function pause() public override onlyDappManagerOrOwner {\n        super.pause();\n    }\n\n    /// @dev Called by the owner to unpause, returns to normal state.\n    /// @dev Overrides base function with permissioned access.\n    function unpause() public override onlyDappManagerOrOwner {\n        super.unpause();\n    }\n\n    /// @dev Inner function for logic encapsulation.\n    /// @dev Can't be executed if provider already withdrawed the eth.\n    /// @dev Internal function.\n    /// @dev Bitwise mask verification implementation.\n    function _grantPermission(\n        uint256 _id,\n        bool _clientAgreed,\n        bytes32 _keyExchangeClientConsumer,\n        address _sender\n    ) internal {\n        require(\n            requests[_id].client == _sender,\n            \"Grant permission should be called only by the client binded to the request\"\n        );\n        require(!taxRegistry().isExpired(_id), \"Request expired\");\n        require(\n            !requests[_id].clientAgreed && !requests[_id].clientRejected,\n            \"Client already agreed or rejected\"\n        );\n        requests[_id].clientAgreed = _clientAgreed;\n        requests[_id].clientRejected = !_clientAgreed;\n\n        requests[_id].keyExchangeClientConsumer = _keyExchangeClientConsumer;\n\n        address _client = requests[_id].client;\n        address _dataConsumer = requests[_id].requester;\n        address[] memory _validators = new address[](0);\n        \n        if (requests[_id].clientAgreed) {\n            emit RequestClientAccepted(\n                _id,\n                requests[_id].clientAgreed,\n                _client,\n                _dataConsumer,\n                _validators,\n                requests[_id].preauthorised,\n                _keyExchangeClientConsumer\n            );\n        } else {\n            emit RequestClientRejected(\n                _id,\n                requests[_id].clientAgreed,\n                _client,\n                _dataConsumer,\n                _validators\n            );\n        }\n    }\n\n    /// @dev Internal function.\n    /// @dev Request object creation.\n    /// @dev Bitwise mask verification implementation.\n    /// @dev Example:\n    /// OK - request example:\n    /// Valid attrs: 1 1 1 1 1 1\n    /// Request    : 0 1 0 1 0 0\n    /// AND         -------------\n    /// Match      :[0 1 0 1 0 0] <- [MATCH]\n    /// NOT OK - request example:\n    /// Valid attrs: 1 1 1 0 1 1\n    /// Request    : 0 0 0 1 0 0\n    /// AND         -------------\n    /// Match      : 0 0 0 0 0 0] <- THROW\n    function _addRequest(\n        address _client,\n        bytes8 _requestAttributeMap,\n        bytes32 _keyExchangeConsumerValidator,\n        bytes32 _keyExchangeConsumerClient,\n        address _requester,\n        bool _preauthorised\n    ) internal returns (uint256) {\n        require(\n            clientRegistry.canAddRequestWithMap(_client, _requestAttributeMap),\n            \"Request attribute map is not compatible with client's validated attributes\"\n        );\n        index = index.add(1);\n        requests[index] = Request(\n            index,\n            _requester,\n            _client,\n            _requestAttributeMap,\n            _keyExchangeConsumerValidator,\n            bytes32(0),\n            bytes32(0),\n            false,\n            false,\n            false,\n            _preauthorised,\n            _keyExchangeConsumerClient,\n            bytes32(0)\n        );\n        emit RequestCreated(\n            index,\n            _requester,\n            _client,\n            _requestAttributeMap,\n            _keyExchangeConsumerValidator,\n            _preauthorised,\n            _keyExchangeConsumerClient\n        );\n        return index;\n    }\n\n    /// @notice Tax registry interface implementation.\n    function taxRegistry() internal view returns (ITaxRegistry _taxRegistry) {\n        _taxRegistry = ITaxRegistry(taxRegistryAddress);\n    }\n\n    /// @notice Only the validators that validated the client can call this function.\n    modifier onlyValidatorForRequest(uint256 _id) {\n        address _client = requests[_id].client;\n        require(\n            clientRegistry.isValidatorForClient(msg.sender, _client),\n            \"Only the validators that validated the client can call this function\"\n        );\n        _;\n    }\n\n    /// @dev Verifies if the requester and the client are eligible for a request creation.\n    /// @dev Trusted data consumers are required in pre-authorised requests.\n    modifier canAddRequests(\n        address _sender,\n        address _client,\n        bool _trustedRequest\n    ) {\n        require(\n            dataConsumerRegistry.isDataConsumer(_sender),\n            \"Sender is not a data consumer\"\n        );\n        require(\n            clientRegistry.isClient(_client),\n            \"Subject is not a valid client\"\n        );\n        require(\n            ((_trustedRequest && dataConsumerRegistry.isTrusted(_sender)) ||\n                !_trustedRequest),\n            \"Sender is not trusted\"\n        );\n        _;\n    }\n\n    /// @dev Verifies if the client agreed\n    modifier clientAgreed(uint256 _id) {\n        require(requests[_id].clientAgreed, \"Client should agree first\");\n        _;\n    }\n\n}\n"}}}