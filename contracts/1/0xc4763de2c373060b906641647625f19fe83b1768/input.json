{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/TESToken.sol":{"content":"pragma solidity ^0.6.12;\n\n// ----------------------------------------------------------------------------\n// TRUSTED TEAM SMART ERC20 TOKEN/Bank\n// Website       : https://eth.tts.best/bank\n// Symbol        : TES\n// Name          : Trust Ethereum Smart\n// Max supply    : 21000000\n// Decimals      : 18\n//\n// Enjoy.\n//\n// (c) by TRUSTED TEAM SMART 2020. MIT Licence.\n// Developers Signature(MD5 Hash) : d6b0169c679a33d9fb19562f135ce6ee\n// ----------------------------------------------------------------------------\n// SPDX-License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n}\n/**\nContract function to receive approval and execute function in one call\n*/\ninterface ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) external;\n}\n\ncontract ERC20 is IERC20{\n    using SafeMath for uint256;\n\n    mapping (address => uint256) internal _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 internal _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    uint256 private CAPLIMIT;\n    uint256 private startTime;\n    uint256 private INFLATIONPERCENT = 3;\n    uint256 private MONTHLY_INFLATION = 90;\n    address internal _mainWallet;\n    uint256 private lastTime;\n    uint256 private _cap;\n    uint256 private _capAddition;\n    bool private isFirstInflation;\n    \n    // ------------------------------------------------------------------------\n    // Constructor\n    // initSupply = 10TES\n    // ------------------------------------------------------------------------\n    constructor() internal {\n        _symbol = \"TES\";\n        _name = \"Trust Ethereum Smart\";\n        _decimals = 18;\n        _totalSupply = 10 * 10**18;\n        CAPLIMIT = 21 * 10**24;\n        _cap = 21 * 10**23;\n        _capAddition = _cap;\n        _balances[msg.sender] = _totalSupply;\n        startTime = block.timestamp;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    \n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender, \n            _allowances[msg.sender][spender].sub(subtractedValue,\n            \"ERC20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        ApproveAndCallFallBack spender = ApproveAndCallFallBack(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _product(uint256 amount) internal {\n        if (block.timestamp - startTime > 6387 days) {\n            if (block.timestamp - lastTime > 365 days || !isFirstInflation) {\n                if (!isFirstInflation) {\n                    if (CAPLIMIT > _totalSupply)\n                        amount = CAPLIMIT.sub(_totalSupply);\n                    _cap = CAPLIMIT;\n                    isFirstInflation = true;\n                }\n                _cap = _cap.mul(100 + INFLATIONPERCENT).div(100);\n                lastTime = block.timestamp;\n            }\n        } else {\n            if (block.timestamp - lastTime > 30 days) {\n                _capAddition = _capAddition.mul(MONTHLY_INFLATION).div(100);\n                _cap = _cap.add(_capAddition);\n                lastTime = block.timestamp;\n            }  \n        }\n        \n        amount = amount.add(amount.div(100));\n\n        if (_totalSupply.add(amount) > _cap)\n            amount = _cap.sub(_totalSupply);\n        if (amount == 0)\n            return;\n            \n        _balances[_mainWallet] = _balances[_mainWallet].add(amount.div(101));\n        _balances[address(this)] = _balances[address(this)].add(amount.mul(100).div(101));\n        _totalSupply = _totalSupply.add(amount);\n        emit Transfer(address(0), address(this), amount.div(101));\n        emit Transfer(address(0), _mainWallet, amount.mul(100).div(101));\n    }\n\n    function burn(uint256 amount) external {\n        require(msg.sender != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n\n\ncontract TESToken is ERC20{\n    using SafeMath for uint256;\n    \n    \n    uint256 private buyAmountLimit = 500 * 1e18;\n    uint256 private pulseAmount = 500 * 1e18;\n    uint256 private pulseCoef = 10002; // / 10000\n    uint256 private CoefLimit = 200000000;\n    \n    uint256 public currentCoef = 500000; // /10000000\n    uint256 public pulseCounter;\n    uint256 public currentPulse;\n\n\n    event Sell(address indexed seller, uint256 TESAmount, uint256 ETHAmount, uint256 price);\n    event Buy(address indexed buyer, uint256 TESAmount, uint256 ETHAmount, uint256 price);\n\n    constructor(address mainWallet) public {\n        _mainWallet = mainWallet;\n    }\n\n    function recieve() public payable{\n    }\n    \n    //pays ETH gets TES\n    function buyToken() public payable returns(uint256 TESAmount, uint256 ETHAmount, uint256 payBackETH) {\n        uint256 price = getSellPrice(msg.value).mul(10000000 + currentCoef).div(10000000);\n        TESAmount = msg.value.mul(1e12).div(price);\n        ETHAmount = msg.value;\n        payBackETH = 0;\n        if (TESAmount > buyAmountLimit) {\n            uint256 payBackTES = TESAmount - buyAmountLimit;\n            payBackETH = price.mul(payBackTES).div(1e12);\n            TESAmount = buyAmountLimit;\n        }\n       \n        if (_balances[address(this)] < TESAmount) {\n            _product(pulseAmount);\n        }\n\n        if (_balances[address(this)] < TESAmount) {\n            uint256 payBackTES = TESAmount - _balances[address(this)];\n            payBackETH = payBackETH.add(price.mul(payBackTES).div(1e12));\n            TESAmount = _balances[address(this)];\n        }\n\n        currentPulse = currentPulse.add(TESAmount);\n        if (currentPulse > pulseAmount) {\n            currentPulse = currentPulse.sub(pulseAmount);\n            pulseCounter++;\n            if (currentCoef < CoefLimit) {\n                currentCoef = currentCoef.mul(pulseCoef).div(10000);\n                if (currentCoef > CoefLimit)\n                    currentCoef = CoefLimit;\n            }\n        }\n\n        if (payBackETH > 0) {\n            msg.sender.transfer(payBackETH);\n            ETHAmount = ETHAmount.sub(payBackETH);\n        }\n\n        if (TESAmount > 0) {\n            _transfer(address(this), msg.sender, TESAmount);   \n            emit Buy(msg.sender, TESAmount, ETHAmount, price);\n        }\n    }\n    \n    //pays TES gets eth\n    function sellToken(uint256 amount) public {\n        uint256 price = getSellPrice();\n        _transfer(msg.sender, address(this), amount);\n        uint256 ETHAmount = amount.mul(price).div(1e12);\n        msg.sender.transfer(ETHAmount);\n\n        emit Sell(msg.sender, amount, ETHAmount, price);\n    }\n\n\n    // decimals : 12\n    function getSellPrice() public view returns(uint256 price) {\n        return getSellPrice(0);\n    }\n    \n    // decimals : 12\n    function getSellPrice(uint256 value) private view returns(uint256 price) {\n        uint256 balance = address(this).balance.sub(value).mul(1e12);\n        return balance.div(_totalSupply - _balances[address(this)]);\n    }\n\n    \n    function getBuyPrice() public view returns (uint256 price) {\n        return getSellPrice().mul(10000000 + currentCoef).div(10000000);\n    }\n}\n"}}}