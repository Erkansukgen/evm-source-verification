{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/TRIA.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n contract Math {\r\n    function add(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function subtract(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n}\r\n\r\ncontract Auth {\r\n    address observer = address(0);\r\n    address owner = address(0);\r\n    address admin = address(0);\r\n\r\n    modifier isOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier isAdmin {\r\n        require(owner == msg.sender || admin == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    function setObserver(address _observer) public {\r\n        require(observer == msg.sender);\r\n        observer = _observer;\r\n    }\r\n    \r\n    function setAdmin(address _admin) isOwner public {\r\n        admin = _admin;\r\n    }\r\n    \r\n    function setOwner(address _owner) public {\r\n        require(observer == msg.sender);\r\n        owner = _owner;\r\n    }\r\n    \r\n    function managers() public view returns (address _owner, address _admin) {\r\n        return (owner, admin);\r\n    }\r\n}\r\n\r\ncontract Manage is Auth {\r\n    \r\n    /**\r\n     *  0 : init, 1 : limited, 2 : running, 3 : finishing\r\n     */\r\n    uint8 public status = 0;\r\n\r\n    modifier isRunning {\r\n        require(status == 2 || owner == msg.sender || admin == msg.sender || (status == 1 && (owner == msg.sender || admin == msg.sender)));\r\n        _;\r\n    }\r\n\r\n    function limit() isAdmin public {\r\n    \trequire(status != 1);\r\n        status = 1;\r\n    }\r\n    \r\n    function start() isAdmin public {\r\n    \trequire(status != 2);\r\n        status = 2;\r\n    }\r\n    \r\n    function close() isAdmin public {\r\n    \trequire(status != 3);\r\n        status = 3;\r\n    }\r\n}\r\n\r\ninterface EIP20Interface {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract TokenBase is EIP20Interface, Manage, Math {\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n        admin = msg.sender;\r\n        observer = msg.sender;\r\n    }\r\n    \r\n    function init(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals) internal virtual {\r\n        require(status == 0);\r\n        _totalSupply = initialSupply * 10 ** uint256(tokenDecimals);\r\n        _balances[msg.sender] = _totalSupply;\r\n        _name = tokenName;\r\n        _symbol = tokenSymbol;\r\n        _decimals = tokenDecimals;\r\n        status = 2;\r\n    }\r\n    \r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n    \r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    \r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    \r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function balanceOf(address _owner) public view virtual override returns (uint256) {\r\n        return _balances[_owner];\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) public virtual override returns (bool) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint256 _value) isRunning internal virtual {\r\n    \trequire(address(0) != _from, \"ERC20: transfer from the zero address\");\r\n    \trequire(address(0) != _to, \"ERC20: transfer to the zero address\");\r\n        require(_balances[_from] >= _value, \"ERC20: transfer amount exceeds balance\");\r\n        require(_balances[_to] + _value >= _balances[_to]);\r\n        uint previousBalances = _balances[_from] + _balances[_to];\r\n        _balances[_from] = Math.subtract(_balances[_from], _value);\r\n        _balances[_to] = Math.add(_balances[_to], _value);\r\n        emit Transfer(_from, _to, _value);\r\n        assert(_balances[_from] + _balances[_to] == previousBalances);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) isRunning public virtual override returns (bool) {\r\n    \trequire(address(0) != _from, \"ERC20: transfer from the zero address\");\r\n    \trequire(address(0) != _to, \"ERC20: transfer to the zero address\");\r\n        require(_value <= _allowances[_from][msg.sender], \"ERC20: transfer amount exceeds allowance\");\r\n        _allowances[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) isRunning public virtual override returns (bool) {\r\n    \trequire(address(0) != _spender, \"ERC20: approve spender the zero address\");\r\n        require(_value == 0 || _allowances[msg.sender][_spender] == 0);\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function increaseAllowance(address _spender, uint256 _value) isRunning public virtual returns (bool) {\r\n    \trequire(address(0) != _spender, \"ERC20: approve spender the zero address\");\r\n   \t\t_allowances[msg.sender][_spender] = Math.add(_allowances[msg.sender][_spender], _value);\r\n   \t\temit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\r\n   \t\treturn true;\r\n\t}\r\n\r\n\tfunction decreaseAllowance(address _spender, uint _value) isRunning public virtual returns (bool) {\r\n    \trequire(address(0) != _spender, \"ERC20: approve spender the zero address\");\r\n\t   \tuint256 oldValue = _allowances[msg.sender][_spender];\r\n\t   \tif (_value >= oldValue) {\r\n\t       _allowances[msg.sender][_spender] = 0;\r\n\t   \t} else {\r\n\t       _allowances[msg.sender][_spender] = Math.subtract(oldValue, _value);\r\n\t   \t}\r\n\t   \temit Approval(msg.sender, _spender, _allowances[msg.sender][_spender]);\r\n\t   \treturn true;\r\n\t}\r\n    \r\n    function burn(uint256 _value) public virtual returns (bool) {\r\n        require(_balances[msg.sender] >= _value, \"ERC20: burn amount exceeds balances\");   // Check if the sender has enough\r\n        _balances[msg.sender] -= _value;            // Subtract from the sender\r\n        _totalSupply -= _value;                      // Updates _totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function burnFrom(address _from, uint256 _value) public virtual returns (bool) {\r\n    \trequire(address(0) != _from, \"ERC20: burn from the zero address\");\r\n        require(_balances[_from] >= _value, \"ERC20: burn amount exceeds balances\");                // Check if the targeted balance is enough\r\n        require(_value <= _allowances[_from][msg.sender], \"ERC20: burn amount exceeds allowances\");    // Check allowance\r\n        _balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        _allowances[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        _totalSupply -= _value;                              // Update _totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) public view virtual override returns (uint256) {\r\n        return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function destruct() isOwner public {\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n}\r\n\r\ncontract TRIA is TokenBase {\r\n    uint256 private sellPrice;\r\n    uint256 private buyPrice;\r\n    uint8 freezePercent;\r\n    address[] private frozenAddresses;\r\n    mapping (address => uint256) private frozenBalances;\r\n    \r\n    event FrozenBalance(address indexed target, uint256 balance);\r\n    event Price(uint256 newSellPrice, uint256 newBuyPrice);\r\n    \r\n    constructor() TokenBase() payable {\r\n        init(10000000000, \"TRIA\", \"TRC\", 18);\r\n        freezePercent = 100;\r\n        \r\n        emit Transfer(address(0), msg.sender, 10000000000);\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint256 _value) isRunning internal virtual override {\r\n        require(frozenBalances[_from] <= balanceOf(_from) - _value);\r\n        \r\n        super._transfer(_from, _to, _value);\r\n        \r\n        if(status == 1) \r\n        \tfreeze(_to, freezePercent);\r\n    }\r\n    \r\n    function increaseFrozenBalances(address target, uint256 _value) isAdmin public virtual {\r\n        require(_value > 0);\r\n        if(frozenBalances[target] == 0)\r\n        \tfrozenAddresses.push(target);\r\n        \t\r\n        frozenBalances[target] += _value;\r\n        emit FrozenBalance(target, frozenBalances[target]);\r\n    }\r\n    \r\n    function decreaseFrozenBalances(address target, uint256 _value) isAdmin public virtual {\r\n        require(_value > 0 && frozenBalances[target] >= _value);\r\n        frozenBalances[target] -= _value;\r\n        \r\n        if(frozenBalances[target] == 0)\r\n        \tdeleteFrozenAddresses(target);\r\n        \t\r\n        emit FrozenBalance(target, frozenBalances[target]);\r\n    }\r\n    \r\n    function freeze(address target, uint8 percent) isAdmin public virtual {\r\n        require(percent > 0 && percent <= 100);\r\n        if(frozenBalances[target] == 0)\r\n        \tfrozenAddresses.push(target);\r\n        \r\n        uint256 frozenBalance = balanceOf(target) * percent / 100;\r\n        frozenBalances[target] = frozenBalance;\r\n        \r\n        emit FrozenBalance(target, frozenBalance);\r\n    }\r\n    \r\n    function changeFrozenBalanceAll(uint8 percent) isAdmin public virtual {\r\n        uint arrayLength = frozenAddresses.length;\r\n\t\tfor (uint i=0; i<arrayLength; i++) {\r\n\t\t\tuint256 frozenBalance = balanceOf(frozenAddresses[i]) * percent / 100;\r\n        \tfrozenBalances[frozenAddresses[i]] = frozenBalance;\r\n\t\t}\r\n    }\r\n    \r\n    function unfreeze(address target) isAdmin public virtual {\r\n    \tdeleteFrozenAddresses(target);\r\n    \tdelete frozenBalances[target];\r\n    }\r\n    \r\n    function deleteFrozenAddresses(address target) internal virtual {\r\n    \tuint arrayLength = frozenAddresses.length;\r\n    \tuint indexToBeDeleted;\r\n    \tbool exists = false;\r\n\t\tfor (uint i=0; i<arrayLength; i++) {\r\n  \t\t\tif (frozenAddresses[i] == target) {\r\n    \t\t\tindexToBeDeleted = i;\r\n    \t\t\texists = true;\r\n    \t\t\tbreak;\r\n  \t\t\t}\r\n\t\t}\r\n\t\tif(exists) {\r\n    \t\taddress lastAddress = frozenAddresses[frozenAddresses.length-1];\r\n            frozenAddresses[indexToBeDeleted] = lastAddress;\r\n            frozenAddresses.pop();\r\n    \t}\r\n    }\r\n    \r\n    function unfreezeAll() isAdmin public virtual {\r\n    \tuint arrayLength = frozenAddresses.length;\r\n\t\tfor (uint i=0; i<arrayLength; i++) {\r\n    \t\tdelete frozenBalances[frozenAddresses[i]];\r\n\t\t}\r\n\t\tdelete frozenAddresses;\r\n    }\r\n    \r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) isAdmin public virtual {\r\n        sellPrice = newSellPrice;\r\n        buyPrice = newBuyPrice;\r\n        emit Price(sellPrice, buyPrice);\r\n    }\r\n    \r\n    function buy() payable public virtual {\r\n        require(buyPrice > 0);\r\n        uint amount = msg.value / buyPrice;\r\n        _transfer(address(this), msg.sender, amount);\r\n    }\r\n    \r\n    function sell(uint256 amount) payable public virtual {\r\n        require(sellPrice > 0);\r\n        address myAddress = address(this);\r\n        require(myAddress.balance >= amount * sellPrice);\r\n        _transfer(msg.sender, address(this), amount);\r\n        payable(msg.sender).transfer(amount * sellPrice);\r\n    }\r\n    \r\n    function setFreezePercent(uint8 percent) isAdmin public virtual {\r\n    \tfreezePercent = percent;\r\n    }\r\n    \r\n    function frozenBalancesOf(address target) public view virtual returns (uint256) {\r\n        return frozenBalances[target];\r\n    }\r\n    \r\n    function frozenAddressesOf(address target) public view virtual returns (address) {\r\n        uint arrayLength = frozenAddresses.length;\r\n\t\tfor (uint i=0; i<arrayLength; i++) {\r\n  \t\t\tif (frozenAddresses[i] == target) {\r\n    \t\t\treturn frozenAddresses[i];\r\n  \t\t\t}\r\n\t\t}\r\n\t\treturn address(0);\r\n    }\r\n    \r\n    function frozenCount() public view virtual returns (uint) {\r\n        return frozenAddresses.length;\r\n    }\r\n}"}}}