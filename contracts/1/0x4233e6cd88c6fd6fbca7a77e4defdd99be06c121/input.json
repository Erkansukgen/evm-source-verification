{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ColorbayMultiSign.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n}\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(account)}\r\n        return size > 0;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\"SafeERC20: approve from non-zero to non-zero allowance\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ColorbayMultiSign {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\r\n    event Revocation(address indexed sender, uint256 indexed transactionId);\r\n    event Submission(uint256 indexed transactionId);\r\n    event Execution(uint256 indexed transactionId);\r\n    event ExecutionSuccess(uint256 indexed transactionId);\r\n    event ExecutionFailure(uint256 indexed transactionId);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint256 required);\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint256 value;\r\n        bool executed;\r\n        uint256 beginTime;\r\n    }\r\n\r\n    mapping (uint256 => Transaction) public transactions;\r\n    mapping (uint256 => mapping(address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint256 public required;\r\n    uint256 public dTime = 48*3600;\r\n    uint256 public transactionCount;\r\n    IERC20 public token;\r\n\r\n\r\n    constructor(address _token, address[] memory _owners, uint256 _required) public validRequirement(_owners.length, _required){\r\n        require(_owners.length >= _required ,\"ColorbayMultiSign: Required bigger than Owner num\");\r\n        token = IERC20(_token);\r\n        require(_owners.length <= 100);\r\n        for (uint256 i=0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != address(0));\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n    function getConfirmationCount(uint256 transactionId) public view returns (uint256 count){\r\n        for (uint256 i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                count = count.add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getLastTransactionId() public view returns (uint256 lastID){\r\n       return transactionCount.sub(1);\r\n    }\r\n\r\n    function getTransactionCount(bool pending, bool executed) public view returns (uint256 count){\r\n        for (uint256 i=0; i<transactionCount; i++) {\r\n            if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\r\n                count = count.add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getOwners() public view returns (address[] memory){\r\n        return owners;\r\n    }\r\n\r\n    function getConfirmationAddress(uint256 transactionId) public view returns (address[] memory _confirmations) {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint256 count = 0;\r\n        for (uint256 i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count = count.add(1);\r\n            }\r\n        }\r\n        _confirmations = new address[](count);\r\n        for (uint256 i=0; i<count; i++) {\r\n            _confirmations[i] = confirmationsTemp[i];\r\n        }\r\n    }\r\n    function isConfirmed(uint256 transactionId) public view returns (bool){\r\n        uint256 count = 0;\r\n        for (uint256 i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                count = count.add(1);\r\n            }\r\n            if (count >= required) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    //---write---//\r\n    modifier validRequirement(uint256 tLenOwner , uint256 tRequired) {\r\n        require(tLenOwner >= tRequired ,\"ColorbayMultiSign: Required bigger than Owner num\");\r\n        _;\r\n    }\r\n    modifier ownerExists(address addr) {\r\n        require(isOwner[addr] ,\"ColorbayMultiSign: not Owner\");\r\n        _;\r\n    }\r\n    function submitTransaction(address destination, uint256 value) public ownerExists(msg.sender) returns (uint256 transactionId){\r\n        require(destination != address(0), \"transfer from 0\");\r\n        require(value <= token.balanceOf(address(this)), \"value too big\");\r\n        transactionId = addTransaction(destination, value);\r\n\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    function confirmTransaction(uint256 transactionId) public ownerExists(msg.sender){\r\n        require(transactionId< transactionCount,\"ColorbayMultiSign: transactionId not exit\");\r\n        require(!transactions[transactionId].executed,\"ColorbayMultiSign: transactionId executed\");\r\n        require(!confirmations[transactionId][msg.sender],\"ColorbayMultiSign: transactionId Confirmed\");\r\n        require(block.timestamp <= transactions[transactionId].beginTime + dTime,\"ColorbayMultiSign: onwer can only confirm in 48 hours!\");\r\n\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    function revokeConfirmation(uint256 transactionId) public ownerExists(msg.sender){\r\n        require(transactionId< transactionCount,\"ColorbayMultiSign: transactionId not exit\");\r\n        require(!transactions[transactionId].executed,\"ColorbayMultiSign: transactionId executed\");\r\n        require(confirmations[transactionId][msg.sender],\"ColorbayMultiSign: transactionId not Confirmed\");\r\n        require(block.timestamp <= transactions[transactionId].beginTime + dTime,\"ColorbayMultiSign: onwer can only revoke confirm in 48 hours!\");\r\n\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    function executeTransaction(uint256 transactionId) internal {\r\n        require(!transactions[transactionId].executed,\"ColorbayMultiSign: transactionId executed\");\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage ta = transactions[transactionId];\r\n            ta.executed = true;\r\n            token.safeTransfer(ta.destination, ta.value);\r\n            emit ExecutionSuccess(transactionId);\r\n        }\r\n    }\r\n\r\n    function addTransaction(address destination, uint256 value) internal returns (uint256 transactionId){\r\n        require(destination != address(0),\"ColorbayMultiSign: destination 0\");\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            executed: false,\r\n            beginTime: block.timestamp\r\n        });\r\n        transactionCount = transactionCount.add(1);\r\n        emit Submission(transactionId);\r\n    }\r\n\r\n\r\n    function removeOwner() public ownerExists(msg.sender){\r\n        require(owners.length >1,\"ColorbayMultiSign: only one owner\");\r\n        isOwner[msg.sender] = false;\r\n\r\n        for (uint256 i=0; i<owners.length.sub(1); i++) {\r\n            if (owners[i] == msg.sender) {\r\n                owners[i] = owners[owners.length.sub(1)];\r\n                break;\r\n            }\r\n        }\r\n        owners.pop();\r\n        if (required > owners.length) {\r\n            changeRequirement(owners.length);\r\n        }\r\n        emit OwnerRemoval(msg.sender);\r\n    }\r\n\r\n    function changeRequirement(uint256 _required) private validRequirement(owners.length, _required){\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n}"}}}