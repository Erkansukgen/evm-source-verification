{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "foo.sol": {
      "content": "// Sources flattened with hardhat v2.6.0 https://hardhat.org\n\n// File contracts/Interfaces/ERC20.sol\n\npragma solidity ^0.8.0;\n\ninterface ERC20 {\n    function approve(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function allowance(address, address) external view returns (uint256);\n}\n\n\n// File contracts/Interfaces/GnosisSafe.sol\n\n\npragma solidity ^0.8.4;\n\ninterface GnosisSafe {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    ) external returns (bool);\n\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    ) external returns (bool, bytes memory);\n\n    function isOwner(address owner) external view returns (bool);\n}\n\n\n// File contracts/Interfaces/Uniswap.sol\n\n\npragma solidity ^0.8.4;\n\ninterface Uniswap {\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory);\n\n    function getAmountsIn(uint256 amountOut, address[] memory path) external view returns (uint256[] memory);\n}\n\n\n// File contracts/Libraries/SafeHelper.sol\n\n\npragma solidity ^0.8.4;\n\n\n\nlibrary SafeHelper {\n    function call(\n        GnosisSafe safe,\n        address to,\n        bytes memory data,\n        string memory reason\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory data) = safe.execTransactionFromModuleReturnData(to, 0, data, GnosisSafe.Operation.Call);\n        if (!success) {\n            revertWithData(reason, data);\n        }\n\n        return data;\n    }\n\n    function approve(\n        GnosisSafe safe,\n        ERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        call(safe, address(token), abi.encodeWithSelector(token.approve.selector, spender, amount), \"failed to approve\");\n    }\n\n    function swapExactTokensForTokens(\n        GnosisSafe safe,\n        Uniswap exchange,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) internal returns (uint256[] memory) {\n        return\n            abi.decode(\n                call(\n                    safe,\n                    address(exchange),\n                    abi.encodeWithSelector(exchange.swapExactTokensForTokens.selector, amountIn, amountOutMin, path, to, deadline),\n                    \"failed to swap\"\n                ),\n                (uint256[])\n            );\n    }\n\n    /// @dev Reverts with the reason of an external call if provided.\n    /// @param reason The reason we provided\n    /// @param data The return data of our external call\n    function revertWithData(string memory reason, bytes memory data) internal {\n        if (data.length < 68) {\n            revert(reason);\n        }\n\n        assembly {\n            data := add(data, 0x04)\n        }\n\n        revert(string(abi.encodePacked(reason, \" with error \", abi.decode(data, (string)))));\n    }\n}\n\n\n// File contracts/Libraries/ExchangeHelper.sol\n\n\npragma solidity ^0.8.4;\n\n\n\nlibrary ExchangeHelper {\n    Uniswap public constant UNI = Uniswap(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    Uniswap public constant SUSHI = Uniswap(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    event Traded(GnosisSafe indexed safe, address from, address to, uint256 amountFrom, uint256 amountTo);\n\n    // @TODO THIS FEELS A BIT MESSY\n\n    function sellForBestPriceWithSlippage(\n        GnosisSafe safe,\n        address[] memory path,\n        uint256 sellAmount,\n        uint256 slippage\n    ) internal returns (uint256) {\n        // Check for best price\n        (Uniswap exchange, uint256 amount) = dataForBestExchange(UNI, SUSHI, path, sellAmount);\n\n        // Return if we won't be able to sell any\n        if (amount == 0) {\n            return 0;\n        }\n\n        // Approve Token on best exchange\n        SafeHelper.approve(safe, ERC20(path[0]), address(exchange), sellAmount);\n\n        // Trade\n        uint256[] memory balances = swapExactTokensForTokens(\n            safe,\n            exchange,\n            sellAmount,\n            (amount * (1000 - slippage)) / 1000,\n            path,\n            address(safe),\n            block.timestamp + 180\n        );\n\n        uint256 balance = balances[balances.length - 1];\n\n        emit Traded(safe, path[0], path[path.length - 1], sellAmount, balance);\n\n        return balance;\n    }\n\n    function amountOutFor(\n        Uniswap exchange,\n        address[] memory path,\n        uint256 amountIn\n    ) internal view returns (uint256) {\n        try exchange.getAmountsOut(amountIn, path) returns (uint256[] memory amountsOut) {\n            return amountsOut[amountsOut.length - 1];\n        } catch {\n            return 0;\n        }\n    }\n\n    function dataForBestExchange(\n        Uniswap a,\n        Uniswap b,\n        address[] memory path,\n        uint256 amount\n    ) internal view returns (Uniswap, uint256) {\n        uint256 aAmount = amountOutFor(a, path, amount);\n        uint256 bAmount = amountOutFor(b, path, amount);\n\n        if (aAmount > bAmount) {\n            return (a, aAmount);\n        } else {\n            return (b, bAmount);\n        }\n    }\n\n    function swapExactTokensForTokens(\n        GnosisSafe safe,\n        Uniswap exchange,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) private returns (uint256[] memory) {\n        (bool success, bytes memory data) = safe.execTransactionFromModuleReturnData(\n            address(exchange),\n            0,\n            abi.encodeWithSelector(exchange.swapExactTokensForTokens.selector, amountIn, amountOutMin, path, to, deadline),\n            GnosisSafe.Operation.Call\n        );\n        require(success, \"failed to swap\");\n\n        return abi.decode(data, (uint256[]));\n    }\n}\n\n\n// File contracts/Modules/Strategies/AbstractStrategy.sol\n\n\npragma solidity ^0.8.4;\n\n\n\n\nabstract contract AbstractStrategy {\n    using SafeHelper for GnosisSafe;\n\n    struct Harvest {\n        ERC20 token;\n        uint256 amount;\n    }\n\n    ERC20 public constant WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /// The harvesters for the safe.\n    mapping(address => mapping(address => bool)) harvesters;\n\n    event Harvested(GnosisSafe indexed safe, address indexed token, uint256 amount);\n    event Deposited(GnosisSafe indexed safe, uint256 amount);\n    event Withdrew(GnosisSafe indexed safe, uint256 amount);\n\n    modifier onlyOwner(GnosisSafe safe) {\n        require(safe.isOwner(msg.sender), \"not owner\");\n        _;\n    }\n\n    modifier onlyHarvesters(GnosisSafe safe) {\n        require(harvesters[address(safe)][msg.sender] || safe.isOwner(msg.sender), \"not harvester\");\n        _;\n    }\n\n    function addHarvester(address harvester) external {\n        harvesters[msg.sender][harvester] = true;\n    }\n\n    function removeHarvester(address harvester) external {\n        harvesters[msg.sender][harvester] = false;\n    }\n\n    function harvest(GnosisSafe safe) external virtual;\n\n    function withdraw(GnosisSafe safe, uint256 amount) external virtual;\n\n    function deposit(GnosisSafe safe, uint256 amount) external virtual;\n\n    function depositToken() external view virtual returns (ERC20);\n\n    function depositedAmount(GnosisSafe safe) external view virtual returns (uint256);\n\n    function harvestableAmountIn(GnosisSafe safe, ERC20 token) external view virtual returns (uint256) {\n        Harvest[] memory harvests = harvestableAmount(safe);\n\n        uint256 length = harvests.length;\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < length; i++) {\n            Harvest memory harvest = harvests[i];\n\n            if (harvest.amount == 0) {\n                continue;\n            }\n\n            address[] memory path = new address[](3);\n            path[0] = address(harvest.token);\n            path[1] = address(WETH);\n            path[2] = address(token);\n\n            (, uint256 sum) = ExchangeHelper.dataForBestExchange(ExchangeHelper.UNI, ExchangeHelper.SUSHI, path, harvest.amount);\n            amount += sum;\n        }\n\n        return amount;\n    }\n\n    function NAME() external view virtual returns (string memory);\n\n    function harvestableAmount(GnosisSafe safe) public view virtual returns (Harvest[] memory);\n\n    function harvest(\n        GnosisSafe safe,\n        address to,\n        bytes memory data,\n        address[] memory path\n    ) internal returns (uint256) {\n        ERC20 token = ERC20(path[0]);\n\n        uint256 amountBefore = token.balanceOf(address(safe));\n\n        safe.call(to, data, \"failed to harvest\");\n\n        uint256 balance = token.balanceOf(address(safe)) - amountBefore;\n\n        require(balance > 0, \"balance was 0\");\n\n        uint256 amountOut = ExchangeHelper.sellForBestPriceWithSlippage(safe, path, balance, 20);\n\n        emit Harvested(safe, path[path.length - 1], amountOut);\n\n        return amountOut;\n    }\n}\n\n\n// File contracts/Interfaces/Convex/Booster.sol\n\npragma solidity ^0.8.4;\n\ninterface Booster {\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    function withdraw(uint256, uint256) external returns (bool);\n\n    function deposit(\n        uint256,\n        uint256,\n        bool\n    ) external returns (bool);\n\n    function poolInfo(uint256) external view returns (PoolInfo memory);\n}\n\n\n// File contracts/Interfaces/Convex/RewardPool.sol\n\npragma solidity ^0.8.4;\n\ninterface RewardPool {\n    function getReward(address, bool) external returns (bool);\n\n    function withdraw(uint256, bool) external returns (bool);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function earned(address) external view returns (uint256);\n\n    function rewardToken() external view returns (ERC20);\n\n    function extraRewards(uint256) external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n}\n\n\n// File contracts/Interfaces/Convex/VirtualBalanceRewardPool.sol\n\npragma solidity ^0.8.4;\n\ninterface VirtualBalanceRewardPool {\n    function rewardToken() external view returns (ERC20);\n\n    function earned(address) external view returns (uint256);\n}\n\n\n// File contracts/Interfaces/Convex/CVXRewardPool.sol\n\npragma solidity ^0.8.4;\n\ninterface CVXRewardPool {\n    function earned(address) external view returns (uint256);\n\n    function rewardToken() external view returns (ERC20);\n\n    function extraRewards(uint256) external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function getReward(\n        address,\n        bool,\n        bool\n    ) external;\n}\n\n\n// File contracts/Modules/Strategies/ConvexStrategy.sol\n\npragma solidity ^0.8.4;\n\n\n\n\n\ncontract ConvexStrategy is AbstractStrategy {\n    using ExchangeHelper for Uniswap;\n    using SafeHelper for GnosisSafe;\n\n    struct Reward {\n        ERC20 token;\n        uint256 amount;\n    }\n\n    string public constant VERSION = \"1.1.0\";\n\n    ERC20 public constant CVX = ERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    ERC20 public constant USDC = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n    CVXRewardPool cvxRewards = CVXRewardPool(0xCF50b810E57Ac33B91dCF525C6ddd9881B139332);\n\n    uint256 public immutable pool;\n\n    Booster public immutable booster;\n    RewardPool public immutable rewards;\n\n    ERC20 public immutable stakingToken;\n\n    address[] public cvx = [address(CVX), address(WETH), address(USDC)];\n\n    constructor(Booster _booster, uint256 _pool) {\n        booster = _booster;\n        pool = _pool;\n\n        Booster.PoolInfo memory info = _booster.poolInfo(_pool);\n\n        stakingToken = ERC20(info.lptoken);\n        rewards = RewardPool(info.crvRewards);\n    }\n\n    function harvest(GnosisSafe safe) external override onlyHarvesters(safe) {\n        uint256 amountBefore = CVX.balanceOf(address(safe));\n        uint256 usdcAmountBefore = USDC.balanceOf(address(safe));\n\n        uint256 length = rewards.extraRewardsLength();\n\n        Reward[] memory claimableRewards = new Reward[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            VirtualBalanceRewardPool reward = VirtualBalanceRewardPool(rewards.extraRewards(i));\n            claimableRewards[i] = Reward({token: reward.rewardToken(), amount: reward.earned(address(safe))});\n        }\n\n        ERC20 rewardToken = rewards.rewardToken();\n        uint256 rewardTokenBefore = rewardToken.balanceOf(address(safe));\n\n        rewards.getReward(address(safe), true);\n        cvxRewards.getReward(address(safe), true, false);\n\n        sellReward(safe, rewardToken, rewardToken.balanceOf(address(safe)) - rewardTokenBefore);\n        sellReward(safe, CVX, CVX.balanceOf(address(safe)) - amountBefore);\n\n        for (uint256 i = 0; i < length; i++) {\n            Reward memory reward = claimableRewards[i];\n            sellReward(safe, reward.token, reward.amount);\n        }\n\n        emit Harvested(safe, address(USDC), USDC.balanceOf(address(safe)) - usdcAmountBefore);\n    }\n\n    function withdraw(GnosisSafe safe, uint256 amount) external override onlyOwner(safe) {\n        safe.call(address(rewards), abi.encodeWithSelector(rewards.withdraw.selector, amount, true), \"failed to withdraw\");\n        safe.call(address(booster), abi.encodeWithSelector(booster.withdraw.selector, pool, amount), \"failed to withdraw\");\n\n        emit Withdrew(safe, amount);\n    }\n\n    function deposit(GnosisSafe safe, uint256 amount) external override onlyOwner(safe) {\n        safe.approve(stakingToken, address(booster), amount);\n\n        safe.call(address(booster), abi.encodeWithSelector(booster.deposit.selector, pool, amount, true), \"failed to deposit\");\n\n        emit Deposited(safe, amount);\n    }\n\n    function depositToken() external view override returns (ERC20) {\n        return stakingToken;\n    }\n\n    function depositedAmount(GnosisSafe safe) external view override returns (uint256) {\n        return rewards.balanceOf(address(safe));\n    }\n\n    function NAME() external view override returns (string memory) {\n        return string(abi.encodePacked(\"Convex \", stakingToken.name(), \" Strategy Module\"));\n    }\n\n    function harvestableAmount(GnosisSafe safe) public view override returns (Harvest[] memory) {\n        uint256 length = rewards.extraRewardsLength();\n\n        Harvest[] memory harvests = new Harvest[](length + 2);\n\n        for (uint256 i = 0; i < length; i++) {\n            VirtualBalanceRewardPool reward = VirtualBalanceRewardPool(rewards.extraRewards(i));\n            harvests[i] = Harvest({token: reward.rewardToken(), amount: reward.earned(address(safe))});\n        }\n\n        harvests[length] = Harvest({token: rewards.rewardToken(), amount: rewards.earned(address(safe))});\n        harvests[length + 1] = Harvest({token: cvxRewards.rewardToken(), amount: cvxRewards.earned(address(safe))});\n\n        return harvests;\n    }\n\n    function sellReward(\n        GnosisSafe safe,\n        ERC20 token,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = address(token);\n        path[1] = address(WETH);\n        path[2] = address(USDC);\n\n        ExchangeHelper.sellForBestPriceWithSlippage(safe, path, amount, 20);\n    }\n}\n"
    }
  }
}