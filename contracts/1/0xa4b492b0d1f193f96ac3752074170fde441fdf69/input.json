{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/FlashMoneyPrinterRedux.sol": {
      "content": "// SPDX-License-Identifier: ARB ASSASSIN SQUAD\r\npragma solidity 0.8.9;\r\ninterface IUniswapV2Pair {function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;}\r\ninterface IERC20 {function transfer(address recipient, uint256 amount) external returns (bool); function balanceOf(address account) external view returns (uint256);}\r\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\ncontract MoneyPrinter {\r\n    constructor() {owner = msg.sender;}\r\n    address public owner;\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner,\"ow\");\r\n        _;\r\n    }\r\n    function arb(uint256 _amountIn,uint256 _amountOut1,uint256 _amountOut2,uint256 _expectedEth,address _sourcePool,address _targetPool,bool _swap0)external onlyOwner{\r\n        IERC20(WETH).transfer(_sourcePool,_amountIn);\r\n        uint256 balanceBefore = IERC20(WETH).balanceOf(address(this));\r\n        if(_swap0){\r\n            IUniswapV2Pair(_sourcePool).swap(_amountOut1,0,_targetPool,new bytes(0));\r\n            IUniswapV2Pair(_targetPool).swap(0,_amountOut2,address(this), new bytes(0));\r\n        }else{\r\n            IUniswapV2Pair(_sourcePool).swap(0,_amountOut1,_targetPool,new bytes(0));\r\n            IUniswapV2Pair(_targetPool).swap(_amountOut2,0,address(this), new bytes(0)); \r\n        }\r\n        uint256 balanceAfter = IERC20(WETH).balanceOf(address(this));\r\n        require(balanceAfter - balanceBefore >= _expectedEth, \"Nice Try.\");\r\n    }\r\n    function arbFlash(uint256 _amountIn,uint256 _amountOut1,uint256 _amountOut2,uint256 _expectedEth,address _sourcePool,address _targetPool,bool _swap0)external onlyOwner{\r\n        uint256 balanceBefore = IERC20(WETH).balanceOf(address(this));\r\n        if(_swap0){\r\n            IUniswapV2Pair(_targetPool).swap(0,_amountOut2,address(this),abi.encode(_amountIn,_amountOut1,_expectedEth,balanceBefore,_sourcePool,_targetPool,_swap0));\r\n        }else{\r\n            IUniswapV2Pair(_targetPool).swap(_amountOut2,0,address(this),abi.encode(_amountIn,_amountOut1,_expectedEth,balanceBefore,_sourcePool,_targetPool,_swap0));\r\n        }\r\n    }\r\n    function execute(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data)internal{\r\n        (uint256 amountIn,uint256 amountOut1,uint256 expectedEth,uint256 balanceBefore,address sourcePool,address targetPool, bool swap0) = abi.decode(_data, (uint256,uint256,uint256,uint256,address,address,bool));\r\n        IERC20(WETH).transfer(sourcePool,amountIn);\r\n        if(swap0){\r\n            IUniswapV2Pair(sourcePool).swap(amountOut1,0,targetPool,new bytes(0));\r\n        }else{\r\n            IUniswapV2Pair(sourcePool).swap(0,amountOut1,targetPool,new bytes(0));  \r\n        }\r\n        uint256 balanceAfter = IERC20(WETH).balanceOf(address(this));\r\n        require(balanceAfter - balanceBefore >= expectedEth, \"Nice Try.\");\r\n    }\r\n    function uniswapV2Call(address _sender, uint256 _amount0, uint256 _amount1, bytes calldata _data)external{\r\n        require(_sender == address(this),\"ow\");\r\n        execute(_sender, _amount0, _amount1, _data);\r\n    }\r\n    function arbHarvest(address _tokenContract, uint256 _amount)external onlyOwner{\r\n        IERC20 tokenContract = IERC20(_tokenContract);\r\n        tokenContract.transfer(owner, _amount);\r\n    }\r\n}\r\n\r\n"
    }
  }
}