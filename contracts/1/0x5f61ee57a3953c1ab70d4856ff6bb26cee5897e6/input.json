{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Owner.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Owner\n * @dev Set & change owner\n */\ncontract Owner {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}"
    },
    "getMoney.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.7.0 <0.8.9;\n\nimport \"Owner.sol\";\n\ninterface ISavingsManager { function collectAndDistributeInterest(address _mAsset) external; }\ninterface IContribute     { function claimInterest() external;\n                            function invest(uint256 reserveAmount) external;\n                            function sell(uint256 tokenAmount) external; }\ninterface IERC20          { function allowance(address owner, address spender) external view returns (uint256);\n                            function balanceOf(address account) external view returns (uint256);\n                            function approve(address spender, uint256 amount) external returns (bool);\n                            function transfer(address recipient, uint256 amount) external returns (bool);\n                            function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); }\ninterface ITRIB is IERC20 {}\ninterface ImUSD is IERC20 {}\n\ncontract Claimer is Owner {\n    address payable owner = msg.sender;\n    ITRIB           constant TRIB = ITRIB(0xe09216F1d343Dd39D6Aa732a08036fee48555Af0);\n    ImUSD           constant mUSD = ImUSD(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n    ISavingsManager contract_SavingsManager = ISavingsManager(0xBC3B550E0349D74bF5148D86114A48C3B4Aa856F);\n    IContribute     constant contract_Contribute     = IContribute(0x0DdfE92234b9DCA2de799736bBBa1D2F25CFC3b8);\n    address         constant _mAsset = 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5;\n    \n\n    function changeSavingsManager(address _address) external isOwner {\n        contract_SavingsManager = ISavingsManager(_address);\n    }\n\n\n    function approveTRIB() external isOwner {\n        TRIB.approve(address(0x0DdfE92234b9DCA2de799736bBBa1D2F25CFC3b8), uint(-1));\n    }\n\n\n    function approvemUSD() external isOwner {\n        mUSD.approve(address(0x0DdfE92234b9DCA2de799736bBBa1D2F25CFC3b8), uint(-1));\n    }\n\n\n    function withdrawETH(uint256 _amount) external isOwner {\n        owner.transfer(_amount);\n    }\n\n\n    function withdrawERC20(IERC20 _token) external isOwner {\n        _token.transfer(owner, _token.balanceOf(address(this)));\n    }\n\n\n    function withdrawERC20toAddress(IERC20 _token, address _address) external isOwner {\n        _token.transfer(_address, _token.balanceOf(address(this)));\n    }\n\n\n    function buyTRIB() external isOwner {\n        contract_Contribute.invest(mUSD.balanceOf(address(this)));\n    }\n\n\n    function sellTRIB(uint256 _amount) external isOwner {\n        contract_Contribute.sell(_amount);\n    }\n\n\n    function trigMoney() public {\n        contract_SavingsManager.collectAndDistributeInterest(_mAsset);\n        contract_Contribute.claimInterest();\n    }\n\n\n    function getMoney() public {\n        contract_Contribute.claimInterest();\n    }\n\n\n    function getMoney_check() external isOwner returns (uint256 tribBalanceA, uint256 tribBalanceB, uint256 musdBalanceA, uint256 musdBalanceB, uint256 gasSpent) {\n        tribBalanceA = TRIB.balanceOf(address(this));\n        musdBalanceA = mUSD.balanceOf(address(this));\n        uint256 gasStart = gasleft();\n        getMoney();\n        gasSpent = gasStart - gasleft();\n        tribBalanceB = TRIB.balanceOf(address(this));\n        musdBalanceB = mUSD.balanceOf(address(this));\n    }\n    \n\n    function trigMoney_check() external isOwner returns (uint256 tribBalanceA, uint256 tribBalanceB, uint256 musdBalanceA, uint256 musdBalanceB, uint256 gasSpent) {\n        tribBalanceA = TRIB.balanceOf(address(this));\n        musdBalanceA = mUSD.balanceOf(address(this));\n        uint256 gasStart = gasleft();\n        trigMoney();\n        gasSpent = gasStart - gasleft();\n        tribBalanceB = TRIB.balanceOf(address(this));\n        musdBalanceB = mUSD.balanceOf(address(this));\n    }\n\n\n    receive() external payable {}\n    \n    // 1. zrobić approve dla TRIB (poprzez funkcję tutaj)\n    // 2. działać\n    // 3. zrobić approve dla mUSD\n    // 4. kupować TRIB za mUSD\n}"
    }
  }
}