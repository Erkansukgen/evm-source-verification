{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ERC20.sol":{"content":"pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}"},"browser/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"},"browser/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"},"browser/tests/4_Ballot_test.sol":{"content":"pragma solidity ^0.6.6;\nimport \"../IUniswapV2Router02.sol\";\nimport \"../ERC20.sol\";\n\ncontract Ownable {\n    address public  owner;\n\n    constructor () public {\n        owner = msg.sender;\n    }\n\n    /**\n     * 判断当前用户是否是合约所有人\n     */\n    modifier onlyOwner () {\n        require(msg.sender == owner);\n        _;\n    }\n}\n\n\ncontract Musk is Ownable{\n   // address public WETH = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;\n    IUniswapV2Router02 unisawp = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    function swapETHToTokens(uint256 ethAmount,address  _address) public payable returns(uint[] memory) {\n        ethAmount=ethAmount*100000000000000000;\n        require(ethAmount <= address(this).balance, \"Not enough Eth in contract to perform swap.\");\n        address[] memory _paths = new address[](2);\n        _paths[0]=unisawp.WETH();\n        _paths[1]=_address;\n        \n        return unisawp.swapExactETHForTokens{value: ethAmount}(0,_paths,owner,now + 120);\n    }\n    \n    receive() external payable { \n    \t// some code\n\t}\n    \n    function swapTokenForETH(uint ethAmount,address  _address) public  payable returns(uint[] memory) {\n        IERC20 Dai = IERC20(_address);\n        ethAmount=ethAmount*100000000000000000;\n        //require(Dai.transferFrom(msg.sender, address(this), _DaiAmount));\n        address[] memory _paths = new address[](2);\n        _paths[0] = _address;\n        _paths[1] = unisawp.WETH();\n        Dai.approve(address(unisawp), ethAmount);\n        return unisawp.swapExactTokensForETH(ethAmount, 0, _paths, msg.sender, now + 120);\n    }\n    \n    function withdrawEth(uint256 ethAmount) public payable {\n        require(msg.sender == owner,\"auth err\");\n        ethAmount=ethAmount*100000000000000000;\n        require(ethAmount <= address(this).balance, \"Not enough Eth in contract to perform withdrawEth.\");\n        msg.sender.transfer(ethAmount);\n    }\n    \n    \n    \n     function withdrawToken(uint256 ethAmount,address  _address) public payable {\n        require(msg.sender == owner,\"auth err\");\n        ethAmount=ethAmount*100000000000000000;\n        IERC20 Dai = IERC20(_address);\n        require(ethAmount <= Dai.balanceOf(address(this)), \"Not enough token in contract to perform withdrawToken.\");\n        Dai.transfer(msg.sender, ethAmount);\n    }\n    \n    function transferEths(address[] memory _to ,uint ethAmount) public payable {\n        require(msg.sender == owner,\"auth err\");\n        ethAmount=ethAmount*10000000000000000;\n        require(ethAmount*_to.length <= address(this).balance, \"Not enough token in contract to perform withdrawToken.\");\n         for(uint i=0; i < _to.length ; i++){\n             address payable add = address(uint160(_to[i]));\n             //bytes4 id= bytes4(keccak256(\"transfer(address,uint256)\"));\n          //address(this).call(id,this, _to[i], ethAmount);\n          add.transfer(ethAmount);\n         }\n    }\n    \n}"}}}