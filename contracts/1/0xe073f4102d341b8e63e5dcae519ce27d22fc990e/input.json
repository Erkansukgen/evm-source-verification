{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "PPTreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IPricingSessionFactory.sol\";\n\n/// @author Medici\n/// @title Treasury contract for Pricing Protocol\ncontract PpTreasury{\n    \n    uint public nftsPriced;\n    uint public profitGenerated;\n    uint public tokensClaimed;\n    address public pricingSessionFactory;\n    address public admin;\n    address public ppToken;\n    \n    //For testnet\n    bool public checkMaxValue;\n\n    /* ======== MAPPINGS ======== */\n    mapping(address => bool) public isChild;\n\n    //For testnet\n    mapping(address => uint) public pointsLost;\n    mapping(address => uint) public pointsGained;\n    mapping(address => bool) public whitelist;\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    /* ======== ADMIN FUNCTIONS ======== */\n\n    function setPPTokenAddress(address _ppToken) onlyAdmin external {\n        require(ppToken == address(0));\n        ppToken = _ppToken;\n    }\n\n    function withdraw(uint _amount) onlyAdmin external {\n        (bool sent, ) = payable(msg.sender).call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function setAdmin(address _newAdmin) onlyAdmin external {\n        admin = _newAdmin;\n    }\n\n    function setPricingFactory(address _pricingFactory) onlyAdmin external {\n        pricingSessionFactory = _pricingFactory;\n    }\n\n    //For testnet\n    function toggleMaxValue() onlyAdmin external {\n        checkMaxValue = !checkMaxValue;\n    }\n\n    //For testnet\n    function addToWhitelist(address user) onlyAdmin external {\n        whitelist[user] = true;\n    }\n\n    //For testnet\n    function removeFromWhiteList(address user) onlyAdmin external {\n        whitelist[user] = false;\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n    \n    function checkWhitelist(address user) view external returns (bool){\n        return whitelist[user];\n    }\n\n    /* ======== CHILD FUNCTIONS ======== */\n    \n    function sendPPToken(address recipient, uint _amount) checkIsChild external {\n        IERC20(ppToken).transfer(recipient, _amount);\n        tokensClaimed += _amount;\n    }\n\n    /// @notice Allows validated child contract to update the profit generated value\n    function updateProfitGenerated(\n        uint _amount \n    ) checkIsChild external {\n        profitGenerated += _amount;\n    }\n    \n    /// @notice Allows validated child contract to update the amount of NFTs that have been priced\n    function updateNftPriced() checkIsChild external {\n        nftsPriced++;\n    }\n    \n    function addChild(address _child) isFactory external {\n        isChild[_child] = true;\n    }\n    \n    function removeChild(address _child) checkIsChild external {\n        isChild[_child] = false;\n    }\n\n    //For testnet\n    function updateUserPoints(address _user, uint _amountGained, uint _amountLost) isFactory external {\n        require(!checkMaxValue);\n        if(_amountGained > _amountLost) {\n            pointsGained[_user] += _amountGained;\n        }\n        else {\n            pointsLost[_user] += _amountLost;\n        }\n    }\n\n    /* ======== FALLBACKS ======== */\n\n    receive() external payable {}\n    fallback() external payable {}\n\n    /* ======== MODIFIERS ======== */\n\n    modifier onlyAdmin() {\n        require(admin == msg.sender);\n        _;\n    }\n    \n    modifier isFactory() {\n        require(msg.sender == pricingSessionFactory);\n        _;\n    }\n    \n    modifier checkIsChild() {\n        require(isChild[msg.sender]);\n        _;\n    }\n}\n"
    },
    "PricingSessionFactory.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"./helpers/ReentrancyGuard.sol\";\nimport \"./interfaces/IPPTreasury.sol\";\nimport \"./PrinciplePricingSession.sol\";\n\n\n/// @author Medici\n/// @title Factory contract for Pricing Protocol\ncontract PricingSessionFactory is ReentrancyGuard {\n\n    /* ======== EVENTS ======== */\n\n    event PricingSessionCreated(address DaoTokenContract, address creator_, address nftAddress_, uint tokenid_, uint initialAppraisal_, uint bounty_);\n\n    /* ======== STATE VARIABLES ======== */\n    \n    address immutable PPToken;\n    address immutable Treasury;\n    address immutable HASHER;\n    address immutable VOTEMASK;\n    address immutable MULTISIG;\n    // address[] public listOfNfts;\n\n    /* ======== MAPPINGS ======== */\n    \n    mapping(address => bool) public isChild;\n    mapping(address => address[]) public userSessionsParticipated;\n    mapping(address => mapping(uint => address)) public recentCompletedSessionAddress;\n    mapping(address => mapping(uint => address)) public currentSessionAddress;\n    mapping(address => mapping(uint => address[])) public listOfNftSpecificSessions;\n\n    /* ======== CONSTRUCTOR ======== */\n    \n    constructor(address _ppToken, address _multisig, address voteMask_, address _hasher, address _treasury) {\n        MULTISIG = _multisig;\n        Treasury = _treasury;\n        HASHER = _hasher;\n        VOTEMASK = voteMask_;\n        PPToken = _ppToken;\n    }\n\n    /* ======== CREATION + BOUNTY ======== */\n\n    /// @notice Instantiate public pricing session \n    /// @dev Bounty is set by msg.value sent and immediately sent to child contract\n    function createNewSession(\n        address nftAddress, \n        uint tokenid, \n        uint initialAppraisal,\n        uint votingTime,\n        address DaoTokenContract\n    ) stopOverwrite(nftAddress, tokenid) external payable {\n        require(votingTime <= 1 days && IPPTreasury(Treasury).checkWhitelist(msg.sender));\n        (bool ppSent) = IERC20(PPToken).transferFrom(msg.sender, Treasury, 10*10^18);\n        require(ppSent);\n        PricingSession session = new PricingSession(DaoTokenContract, MULTISIG, VOTEMASK, HASHER, Treasury, \n            nftAddress, tokenid, initialAppraisal, msg.value, votingTime);\n        (bool sent, ) = payable(address(session)).call{value: msg.value}(\"\");\n        require(sent);\n        currentSessionAddress[nftAddress][tokenid] = address(session);\n        unlockChildState(address(session));\n        listOfNftSpecificSessions[nftAddress][tokenid].push(address(session));\n        // listOfNfts.push(address(session));\n        emit PricingSessionCreated(DaoTokenContract, msg.sender, nftAddress, tokenid, initialAppraisal, msg.value);\n    }\n\n    /* ======== CHILD FUNCTIONS ======== */\n    \n    function unlockChildState(address _contract) internal {\n        isChild[msg.sender] = true;\n        IPPTreasury(Treasury).addChild(_contract);\n    }\n    \n    /// @notice Allows validated child contract to remove a completed contract from child status\n    function lockChildState(address _contract) isCallerChild external {\n        isChild[_contract] = false;\n        IPPTreasury(Treasury).removeChild(_contract);\n    }\n    \n    /// @notice Allows validated child contract to update the sessions a user has participated in\n    function updateUserSessions(\n        address _user, \n        address _contract\n    ) isCallerChild() external {\n        userSessionsParticipated[_user].push(_contract);\n    }\n    \n    function updateRecentCompletedSession(address _nftAddress, uint _tokenid) isCallerChild external {\n        recentCompletedSessionAddress[_nftAddress][_tokenid] = msg.sender;\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n    \n    function checkIsChild() view external returns (bool){\n        return isChild[msg.sender] == true; \n    }\n\n    /* ======== MODIFIERS ======== */\n\n    /// @notice Creates cool down buffer between sessions for the same NFT\n    modifier stopOverwrite(\n        address nftAddress, \n        uint tokenid\n    ) {\n        require(\n            currentSessionAddress[nftAddress][tokenid] == address(0) \n            || PricingSession(payable(currentSessionAddress[nftAddress][tokenid])).getStatus() == 7\n        );\n        _;\n    }\n    \n    /// @notice Make sure state changing calls are made from factory produced contract\n    modifier isCallerChild() {\n        require(isChild[msg.sender]);\n        _;\n    }\n    \n}"
    },
    "PrinciplePricingSession.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"./helpers/ReentrancyGuard.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/sqrtLibrary.sol\";\nimport \"./libraries/PostSessionLibrary.sol\";\nimport \"./PPTreasury.sol\";\nimport \"./interfaces/IPricingSessionFactory.sol\";\nimport \"./interfaces/IMaskVote.sol\";\nimport \"./interfaces/IHasher.sol\";\nimport \"./interfaces/IPPTreasury.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IPPTreasury.sol\";\n\n/// @author Medici\n/// @title Individual session contract for Pricing Protocol\ncontract PricingSession is ReentrancyGuard, PostSessionLibrary {\n\n    /* ======== DEPENDINCIES ======== */\n    \n    using SafeMath for uint;\n\n    /* ======== STRUCTS ======== */\n\n    struct Voter {\n        uint base;\n        uint appraisal;\n        uint stake;\n    }\n\n    /* ======== STATE VARIABLES ======== */\n\n    bool claimsComplete;\n    bool finalAppraisalSet;\n    bool harvestLossComplete;\n    bool sessionOver;\n    bool votesWeighted;\n    bool votingActive;\n\n    address public immutable HASHER;\n    address public immutable VOTEMASK;\n    address public immutable NFTADDRESS;\n    address public immutable PARENTCONTRACT;\n    address public immutable MULTISIG;\n    address public immutable TREASURY;\n    address public immutable DAO;\n\n    uint public immutable TOKENID;\n\n    uint amountOfClaims;\n    uint amountVotesWeighted;\n    uint public bounty;\n    uint endTime;\n    uint public finalAppraisal;\n    uint harvestLossesCalled;\n    uint lowestStake;\n    uint maxAppraisal;\n    uint timeFinalAppraisalSet;\n    uint totalAppraisalValue;\n    uint totalSessionStake;\n    uint public totalSessionStake_;\n    uint totalWinnerPoints;\n    uint totalVotes;\n    uint public uniqueVoters;\n    uint votingTime;\n    uint weighTime;\n    uint harvestTime;\n    uint claimTime;\n\n    /* ======== MAPPINGS ======== */\n\n    mapping (address => bool) oneClaim;\n    mapping (address => bool) oneHarvestLoss;\n    mapping (address => bool) oneWeight;\n    mapping (address => bool) voterCheck;\n    mapping (address => uint) amountHarvested;\n    mapping (address => uint) ethPayout;\n    mapping (address => uint) winnerPoints;\n    mapping (address => Voter) nftVotes;\n\n    /* ======== EVENTS ======== */\n\n    event newAppraisalAdded(address voter_, uint stake_, uint appraisal, uint weight);\n    event finalAppraisalDetermined(uint finalAppraisal, uint amountOfParticipants, uint totalStake);\n    event lossHarvestedFromUser(address user_, uint harvested);\n    event ethClaimedByUser(address user_, uint ethClaimed);\n    event ethToPPExchange(address user_, uint ethExchanged, uint ppSent);\n    event sessionEnded(address contract_);\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(address _dao, address _multisig, address voteMask_, address _hasher, address _treasury, \n        address _nftAddress, uint _tokenid, uint _initialAppraisal, uint _bounty, uint _votingTime) {\n        TREASURY = _treasury;\n        PARENTCONTRACT = msg.sender;\n        NFTADDRESS = _nftAddress;\n        TOKENID = _tokenid;\n        HASHER = _hasher;\n        VOTEMASK = voteMask_;\n        MULTISIG = _multisig;\n        maxAppraisal = _initialAppraisal;\n        endTime = block.timestamp + _votingTime;\n        lowestStake = 10000000 ether;\n        votingActive = true;\n        bounty = _bounty;\n        DAO = _dao;\n        votingTime = _votingTime;\n        weighTime = _votingTime;\n        harvestTime = _votingTime * 2;\n        claimTime = _votingTime * 2;\n    }\n    \n    /* ======== BOUNTY ======== */\n    function addToBounty() payable external {\n        require(!finalAppraisalSet);\n        bounty = bounty.add(msg.value);\n    } \n\n    /* ======== USER VOTE FUNCTIONS ======== */\n    \n    /// @notice Allows user to set vote in party \n    /** \n    @dev Users appraisal is hashed so users can't track final appraisal and submit vote right before session ends.\n    Therefore, users must remember their appraisal in order to reveal their appraisal in the next function.\n    */\n    function setVote(\n        bytes32 concealedBid, \n        uint a,\n        uint b, \n        uint c, \n        uint d, \n        uint e\n    ) checkStake oneVoteEach payable external {\n        require(\n            //For testnet\n            IPPTreasury(TREASURY).checkWhitelist(msg.sender)\n            && endTime > block.timestamp\n            && IMaskVote(VOTEMASK).verifyWithinLimit(maxAppraisal, a, b, c, d, e)\n            && IMaskVote(VOTEMASK).verifyTrueAppraisal(concealedBid, a, b, c, d, e, msg.sender),\n            \"Set vote condition not met\"\n        );\n        if(DAO != address(0)) {\n            require(IERC20(DAO).balanceOf(msg.sender) > 0);\n        }\n        voterCheck[msg.sender] = true;\n        uint _appraisal;\n        uint[5] memory valueList = [a,b,c,d,e];\n        for(uint x = 0; x < valueList.length; x++) {\n            if(concealedBid == keccak256(abi.encodePacked(valueList[x], msg.sender, IHasher(HASHER).getUserRandomValue(msg.sender)))) {\n                _appraisal = valueList[x];\n            }\n        }\n        if(_appraisal > maxAppraisal) {\n            maxAppraisal = _appraisal;\n        }\n        if (msg.value < lowestStake) {\n            lowestStake = msg.value;\n        }\n        uniqueVoters++;\n        totalSessionStake = totalSessionStake.add(msg.value);\n        nftVotes[msg.sender] = Voter(0, _appraisal, msg.value);\n        IPricingSessionFactory(PARENTCONTRACT).updateUserSessions(msg.sender, address(this));\n    }\n\n    /// @notice Allow a user to update their vote within the voting window\n    function updateMyVote(\n        bytes32 concealedBid, \n        uint a,\n        uint b, \n        uint c, \n        uint d, \n        uint e\n    ) checkParticipation payable external {\n        require(\n            endTime > block.timestamp\n            && IMaskVote(VOTEMASK).verifyWithinLimit(maxAppraisal, a, b, c, d, e)\n            && msg.value >= nftVotes[msg.sender].stake\n        );\n        uint _appraisal;\n        uint[5] memory valueList = [a,b,c,d,e];\n        for(uint x = 0; x < valueList.length; x++) {\n            if(concealedBid == keccak256(abi.encodePacked(valueList[x], msg.sender, IHasher(HASHER).getUserRandomValue(msg.sender)))) {\n                _appraisal = valueList[x];\n            }\n        }\n        if(_appraisal > maxAppraisal) {\n            maxAppraisal = _appraisal;\n        }\n        uint oldStake = nftVotes[msg.sender].stake;\n        nftVotes[msg.sender].stake = msg.value;\n        nftVotes[msg.sender].appraisal = _appraisal;\n        (bool sent, ) = payable(msg.sender).call{value: oldStake}(\"\");\n        require(sent);\n    }\n\n    /// @notice Reveals user vote and weights based on the sessions lowest stake\n    /**\n    @dev calculation can be found in the weightVoteLibrary.sol file. \n    Votes are weighted as sqrt(userStake/lowestStake). Depending on a votes weight\n    it is then added as multiple votes of that appraisal (i.e. if someoneone has\n    voting weight of 8, 8 votes are submitted using their appraisal).\n    */\n    function weightVote() nonReentrant checkParticipation external {\n        require(endTime < block.timestamp\n                && !oneWeight[msg.sender]\n        );\n\n        // require(!oneWeight[msg.sender]);\n\n        votingActive = false;\n        oneWeight[msg.sender] = true;\n                \n        uint weight = weightUserVote(nftVotes[msg.sender].stake, lowestStake);\n        totalVotes += weight;\n        amountVotesWeighted++;\n        \n        totalAppraisalValue = totalAppraisalValue.add((weight) * nftVotes[msg.sender].appraisal);\n        emit newAppraisalAdded(msg.sender, nftVotes[msg.sender].stake, nftVotes[msg.sender].appraisal, weight);\n        if(amountVotesWeighted == uniqueVoters) {\n            votesWeighted = true;\n        }\n    }\n    \n    /// @notice takes average of appraisals and outputs a final appraisal value.\n    function setFinalAppraisal() nonReentrant checkParticipation external {\n        require(\n            !finalAppraisalSet\n            && (block.timestamp > endTime + weighTime || votesWeighted)\n        );\n\n        IPPTreasury(TREASURY).updateNftPriced();\n        votesWeighted = true;\n        timeFinalAppraisalSet = block.timestamp;\n        totalSessionStake += bounty;\n        totalSessionStake_ = totalSessionStake;\n        finalAppraisal = (totalAppraisalValue)/(totalVotes);\n        finalAppraisalSet = true;\n        IPricingSessionFactory(PARENTCONTRACT).updateRecentCompletedSession(NFTADDRESS, TOKENID);\n        emit finalAppraisalDetermined(finalAppraisal, uniqueVoters, totalSessionStake_);\n    }\n\n    /// @notice Calculates users base and harvests their loss before returning remaining stake\n    /**\n    @dev A couple notes:\n    1. Tracks totalWinnerStake for calculating \"in the money\" users share of harvested profit\n    2. Base is calculated based on margin of error.\n        > +/- 5% = 1\n        > +/- 4% = 2\n        > +/- 3% = 3\n        > +/- 2% = 4\n        > +/- 1% = 5\n        > Exact = 6\n    3. Losses are harvested based on --> (margin of error - 5%) * stake\n    */\n    function harvestLoss() nonReentrant checkParticipation external {\n        require(\n            !harvestLossComplete\n            && !oneHarvestLoss[msg.sender]\n            && finalAppraisalSet\n        );\n        oneHarvestLoss[msg.sender] = true;\n        harvestLossesCalled++;\n        nftVotes[msg.sender].base = \n            calculateBase(\n                finalAppraisal, \n                nftVotes[msg.sender].appraisal\n            );\n\n        totalWinnerPoints += nftVotes[msg.sender].base * nftVotes[msg.sender].stake;\n        winnerPoints[msg.sender] = nftVotes[msg.sender].base * nftVotes[msg.sender].stake;\n\n        amountHarvested[msg.sender] = harvest( \n            nftVotes[msg.sender].stake, \n            nftVotes[msg.sender].appraisal,\n            finalAppraisal\n        );\n\n        //For testnet\n        IPPTreasury(TREASURY).updateUserPoints(msg.sender, winnerPoints[msg.sender], amountHarvested[msg.sender]);\n\n        nftVotes[msg.sender].stake -= amountHarvested[msg.sender];\n        uint totalCommission = setCommission(TREASURY.balance).mul(amountHarvested[msg.sender]).div(10000);\n        totalSessionStake -= totalCommission; \n        IPPTreasury(TREASURY).updateProfitGenerated(amountHarvested[msg.sender]);\n        uint _payout = totalCommission/2;\n        (bool sent, ) = payable(TREASURY).call{value: _payout}(\"\");\n        require(sent);\n        // payout(TREASURY, _payout);\n        (bool sent1, ) = payable(MULTISIG).call{value: totalCommission - _payout}(\"\");\n        require(sent1);\n        // payout(MULTISIG, totalCommission - _payout);\n\n        emit lossHarvestedFromUser(msg.sender, amountHarvested[msg.sender]);\n\n        (bool sent2, ) = payable(msg.sender).call{value: nftVotes[msg.sender].stake}(\"\");\n        require(sent2);\n        totalSessionStake -= nftVotes[msg.sender].stake;\n        nftVotes[msg.sender].stake = 0;\n\n        if(harvestLossesCalled == uniqueVoters) {\n            harvestLossComplete = true;\n        }\n    }\n\n    /// @notice Allow user to claim profit from session profit pool in ETH\n    function claimProfit() checkHarvestLoss nonReentrant checkParticipation external returns(uint){\n        require(!oneClaim[msg.sender] && !claimsComplete);\n        if(totalWinnerPoints == 0) {\n            _executeEnd();\n            return 0;\n        }\n        harvestLossComplete = true;\n        oneClaim[msg.sender] = true;\n        amountOfClaims++;\n        ethPayout[msg.sender] = totalSessionStake * winnerPoints[msg.sender] / totalWinnerPoints;\n        totalSessionStake -= ethPayout[msg.sender];\n        totalWinnerPoints -= winnerPoints[msg.sender];\n        winnerPoints[msg.sender] = 0;\n        (bool sent, ) = payable(msg.sender).call{value: ethPayout[msg.sender]}(\"\");\n        require(sent, \"Failed to send Ether\");\n        emit ethClaimedByUser(msg.sender, ethPayout[msg.sender]);\n        if(amountOfClaims == uniqueVoters || block.timestamp > timeFinalAppraisalSet + 2 hours) {\n            _executeEnd();\n            return 0;\n        }\n\n        return 1;\n    }\n\n    /// @notice Allow user to enact primary purchase of PP by sending profit earned to treasury in exchange for PP\n    /**\n    @dev the v1 ETH to PP exchange rate will be (0.0001 ether + 0.0001 ether * parentLookup.tokensClaimed() / 1000000)\n    */\n    function exchangeForPP() checkHarvestLoss nonReentrant checkParticipation external returns(uint){\n        require(!oneClaim[msg.sender] && !claimsComplete);\n        if(totalWinnerPoints == 0) {\n            _executeEnd();\n            return 0;\n        }\n        oneClaim[msg.sender] = true;\n        amountOfClaims++;\n        uint ppPayout = (totalSessionStake * winnerPoints[msg.sender] * 1e18 / totalWinnerPoints) / (0.0001 ether + 0.0001 ether * IPPTreasury(TREASURY).tokensClaimed() / 1000000);\n        totalSessionStake -= totalSessionStake * winnerPoints[msg.sender] / totalWinnerPoints;\n        (bool sent, ) = payable(MULTISIG).call{value: totalSessionStake * winnerPoints[msg.sender] / totalWinnerPoints}(\"\");\n        require(sent, \"Failed to send Ether\");\n        totalWinnerPoints -= winnerPoints[msg.sender];\n        IPPTreasury(TREASURY).sendPPToken(msg.sender, ppPayout);\n        emit ethToPPExchange(msg.sender, ethPayout[msg.sender], ppPayout);\n        if(amountOfClaims == uniqueVoters || block.timestamp > timeFinalAppraisalSet + 2 hours) {\n            _executeEnd();\n            return 0;\n        }\n        return 1;\n    }\n    \n    /// @notice Custodial function to clear funds and remove session as child\n    /// @dev Caller receives 25% of the funds that are meant to be cleared\n    function endSession() checkParticipation public {\n        require(!sessionOver && (block.timestamp > timeFinalAppraisalSet + claimTime + harvestTime || claimsComplete));\n        _executeEnd();\n    }\n\n    /* ======== INTERNAL FUNCTIONS ======== */\n    \n    /// @notice Send payment to general treasury\n    // function payout(address recipient, uint _amount) internal {\n    //     (bool sent, ) = payable(recipient).call{value: _amount}(\"\");\n    //     require(sent);\n    // }\n\n    function _executeEnd() internal {\n        sessionOver = true;\n        claimsComplete = true;\n        IPricingSessionFactory(PARENTCONTRACT).setChildState(address(this));\n        uint tPayout = 90*address(this).balance/100;\n        uint cPayout = address(this).balance - tPayout;\n        (bool sent, ) = payable(TREASURY).call{value: tPayout}(\"\");\n        require(sent);\n        // payout(TREASURY, tPayout);\n        (bool sent1, ) = payable(msg.sender).call{value: cPayout}(\"\");\n        require(sent1);\n        totalSessionStake = 0;\n        emit sessionEnded(address(this));\n    }\n\n    /* ======== VIEW FUNCTIONS ======== */\n    \n    function getMaxAppraisal() view external returns(uint){\n        return maxAppraisal; \n    }\n\n    function weightUserVote(uint stake, uint _lowestStake) pure internal returns(uint) {\n        return sqrtLibrary.sqrt(stake/_lowestStake);\n    }\n\n    function getStatus() view external returns(uint) {\n        if(sessionOver) {\n            return 7;\n        }\n        else if(claimsComplete) {\n            return 6;\n        }\n        else if(harvestLossComplete) {\n            return 5;\n        }\n        else if(finalAppraisalSet) {\n            return 4;\n        }\n        else if(votesWeighted){\n            return 3;\n        }\n        else if(!votingActive){\n            return 2;\n        }\n        else{\n            return 1;\n        }    \n    }\n\n    function getPpPayout() view external returns(uint) {\n        if(totalWinnerPoints == 0) {\n            return 0;\n        }\n        return (totalSessionStake * winnerPoints[msg.sender] * 1e18 / totalWinnerPoints) / (0.0001 ether + 0.0001 ether * IPPTreasury(TREASURY).tokensClaimed() / 1000000);\n    }\n\n    function getEthPayout() view external returns(uint) {\n        if(totalWinnerPoints == 0) {\n            return 0;\n        }\n        return totalSessionStake * winnerPoints[msg.sender] / totalWinnerPoints;\n    }\n\n    function getVotingEndTime() view external returns(uint) {\n        return endTime;\n    }\n\n    function getWeightingEndTime() view external returns(uint) {\n        return endTime + weighTime;\n    }\n\n    function getHarvestLossEndTime() view external returns(uint) {\n        return timeFinalAppraisalSet + harvestTime;\n    }\n\n    function getClaimEndTime() view external returns(uint) {\n        return timeFinalAppraisalSet + claimTime + harvestTime;\n    }\n\n    /* ======== FALLBACK FUNCTIONS ======== */\n\n    receive() external payable {}\n    fallback() external payable {}\n\n    /* ======== MODIFIERS ======== */\n\n    modifier oneVoteEach {\n        require(!voterCheck[msg.sender]);\n        _;\n    }\n    \n    modifier checkStake {\n        require(msg.value >= 0.001 ether);\n        _;\n    }\n\n    modifier checkParticipation() {\n        require(voterCheck[msg.sender]);\n        _;\n    }\n\n    modifier checkHarvestLoss() {\n        require(harvestLossComplete || block.timestamp > timeFinalAppraisalSet + harvestTime);\n        _;\n    }\n}"
    },
    "helpers/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.8.0;\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  /// @dev counter to allow mutex lock with only one SSTORE operation\n  uint256 private _guardCounter = 1;\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * If you mark a function `nonReentrant`, you should also\n   * mark it `external`. Calling one `nonReentrant` function from\n   * another is not supported. Instead, you can implement a\n   * `private` function doing the actual work, and an `external`\n   * wrapper marked as `nonReentrant`.\n   */\n  modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n  }\n\n}"
    },
    "interfaces/IERC20.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "interfaces/IHasher.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IHasher {\n    function getUserRandomValue(address _user) view external returns (uint);\n}"
    },
    "interfaces/IMaskVote.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IMaskVote {\n    function verifyTrueAppraisal(\n        bytes32 concealedBid, \n        uint a, \n        uint b, \n        uint c, \n        uint d, \n        uint e,\n        address _user\n    ) view external returns (bool);\n    \n    function verifyWithinLimit(\n        uint _maxAppraisal, \n        uint a, \n        uint b, \n        uint c, \n        uint d, \n        uint e\n    ) pure external returns (bool);\n}"
    },
    "interfaces/IPPTreasury.sol": {
      "content": "pragma solidity ^0.8.0;\n\ninterface IPPTreasury {\n    function sendPPToken(address recipient, uint _amount) external;\n\n    function updateUserPoints(address _user, uint _amountGained, uint _amountLost) external;\n\n    function tokensClaimed() external view returns(uint);\n\n    function checkWhitelist(address user) external view returns(bool);\n    \n    function updateNftPriced() external;\n    \n    function updateProfitGenerated(uint _amount) external;\n    \n    function addChild(address _child) external;\n    \n    function removeChild(address _child) external;\n\n}"
    },
    "interfaces/IPricingSessionFactory.sol": {
      "content": "pragma solidity ^0.8.0;\n\n/// @author Medici\n/// @title Used to interface with parent contract\ninterface IPricingSessionFactory {\n    function updateProfitsGenerated(uint _amount) external;\n    \n    function updateNftPriced() external;\n    \n    function updateUserSessions(address _recipient, address _contract) external;\n    \n    function setChildState(address _contract) external;\n    \n    function checkIsChild() external returns (bool);\n    \n    function sendPP(address recipient, uint _amount) external;\n    \n    function updateUserPoints(address _user, uint _amountGained, uint _amountLost) external;\n    \n    function updateRecentCompletedSession(address _nftAddress, uint _tokenid) external;\n}"
    },
    "libraries/PostSessionLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./sqrtLibrary.sol\";\n\ncontract PostSessionLibrary {\n\n    using sqrtLibrary for *;\n\n    /////////////////////\n    ///      Base     ///\n    /////////////////////\n\n    function calculateBase(uint finalAppraisalValue, uint userAppraisalValue) pure internal returns(uint){\n        uint base = 1;\n        uint userVal = 100 * userAppraisalValue;\n        for(uint i=5; i >= 1; i--) {\n            uint lowerOver = (100 + (i - 1)) * finalAppraisalValue;\n            uint upperOver = (100 + i) * finalAppraisalValue;\n            uint lowerUnder = (100 - i) * finalAppraisalValue;\n            uint upperUnder = (100 - i + 1) * finalAppraisalValue;\n            if (lowerOver < userVal && userVal <= upperOver) {\n                return base; \n            }\n            if (lowerUnder < userVal && userVal <= upperUnder) {\n                return base;\n            }\n            base += 1;\n        }\n        if(userVal == 100*finalAppraisalValue) {\n            return 6;\n        }\n        return 0;\n    }\n\n    /////////////////////\n    ///    Harvest    ///\n    /////////////////////\n\n    // function harvestUserOver(uint _stake, uint _userAppraisal, uint _finalAppraisal) pure internal returns(uint) {\n    //     return _stake * (_userAppraisal*100 - 105*_finalAppraisal)/(_finalAppraisal*100);\n    // }\n    \n    // function harvestUserUnder(uint _stake, uint _userAppraisal, uint _finalAppraisal) pure internal returns(uint) {\n    //     return _stake * (95*_finalAppraisal - 100*_userAppraisal)/(_finalAppraisal*100);\n    // }\n\n    function harvest(uint _stake, uint _userAppraisal, uint _finalAppraisal) pure internal returns(uint) {\n        if(_userAppraisal*100 > 105*_finalAppraisal) {\n            return _stake * (_userAppraisal*100 - 105*_finalAppraisal)/(_finalAppraisal*100);\n        }\n        else if(_userAppraisal*100 < 95*_finalAppraisal) {\n            return _stake * (95*_finalAppraisal - 100*_userAppraisal)/(_finalAppraisal*100);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /////////////////////\n    ///   Commission  ///\n    /////////////////////   \n    function setCommission(uint _treasurySize) pure internal returns(uint) {\n        if (_treasurySize < 25000 ether) {\n            return 500;\n        }\n        else if(_treasurySize >= 25000 ether && _treasurySize < 50000 ether) {\n            return 400;\n        }\n        else if(_treasurySize >= 50000 ether && _treasurySize < 100000 ether) {\n            return 300;\n        }\n        else if(_treasurySize >= 100000 ether && _treasurySize < 2000000 ether) {\n            return 200;\n        }\n        else if(_treasurySize >= 200000 ether && _treasurySize < 400000 ether) {\n            return 100;\n        }\n        else if(_treasurySize >= 400000 ether && _treasurySize < 700000 ether) {\n            return 50;\n        }\n        else {\n            return 25;\n        }\n    }\n\n\n}"
    },
    "libraries/SafeMath.sol": {
      "content": "pragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "libraries/sqrtLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nlibrary sqrtLibrary {\n    \n    function sqrt(uint x) pure internal returns (uint y) {\n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}"
    }
  }
}