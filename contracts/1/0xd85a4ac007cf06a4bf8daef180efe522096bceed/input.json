{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/degen.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(),\"Not Owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0),\"Zero address not allowed\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ninterface ISwapFactory {\n    function swap(address tokenA, address tokenB, uint256 amount, address user, uint256 crossOrderType, uint256 dexId, uint256 deadline) \n    external payable returns (bool);\n}\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IUni {\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external payable\n    returns (uint[] memory amounts);\n    \n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) \n    external \n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function WETH() external pure returns (address);\n\n}\n\ninterface IReimbursement {\n    function getLicenseeFee(address licenseeVault, address projectContract) external view returns(uint256); // return fee percentage with 2 decimals\n    function getVaultOwner(address vault) external view returns(address);\n    // returns address of fee receiver or address(0) if licensee can't receive the fee (fee should be returns to user)\n    function requestReimbursement(address user, uint256 feeAmount, address licenseeVault) external returns(address);\n}\n\ncontract Degen is Ownable {\n    using TransferHelper for address;\n    enum OrderType {EthForTokens, TokensForEth, TokensForTokens, EthForEth}\n    \n    IUni public Uni = IUni(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //mainnet network address for uniswap (valid for Ropsten as well)\n    IUni public Sushi = IUni(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Mainnet network address for sushiswap\n    //address public _sushi = address(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506); // Ropsten network address for sushiswap\n    //address public USDT = address(0x47A530f3Fa882502344DC491549cA9c058dbC7Da); // Ropsten test net USDT test token\n    address public USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7); // USDT Token Address\n    address public system;\n    uint256 public processingFee = 0 ;\n    \n    uint256 private deadlineLimit = 20*60;      // 20 minutes by default \n    \n    uint256 private collectedFees = 1; // amount of collected fee (starts from 1 to avoid additional gas usage)\n    address public feeReceiver; // address which receive the fee (by default is validator)\n\n\n    IReimbursement public reimbursementContract;      // reimbursement contract address\n\n    address public companyVault;    // the vault address of our company registered in reimbursement contract\n\n    ISwapFactory public swapFactory;\n   \n    modifier onlySystem() {\n        require(msg.sender == system || owner() == msg.sender,\"Caller is not the system\");\n        _;\n    }\n    \n    constructor(address _swapFactory, address _system) \n    {\n        swapFactory = ISwapFactory(_swapFactory);\n        system = _system;\n    }\n    \n\n    function setCompanyVault(address _comapnyVault) external onlyOwner {\n        companyVault = _comapnyVault;\n    }\n\n    function setReimbursementContract(address _reimbursementContarct) external onlyOwner {\n        reimbursementContract = IReimbursement(_reimbursementContarct);\n    }\n\n    function setProcessingFee(uint256 _processingFees) external onlySystem {\n        processingFee = _processingFees;\n    }\n\n    function setSwapFactory(address _swapFactory) external onlyOwner {\n        swapFactory = ISwapFactory(_swapFactory);\n    }\n    \n    function setSystem(address _system) external onlyOwner {\n        system = _system;\n    }\n    \n    function setFeeReceiver(address _addr) external onlyOwner {\n        feeReceiver = _addr;\n    }\n    \n    function getDeadlineLimit() public view returns(uint256) {\n        return deadlineLimit;\n    }\n    \n    function setDeadlineLimit(uint256 limit) external onlyOwner {\n        deadlineLimit = limit;\n    }\n\n    // get amount of collected fees that can be claimed\n    function getColletedFees() external view returns (uint256) {\n        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\n        return collectedFees - 1;\n    }\n\n    // claim fees by feeReceiver\n    function claimFee() external returns (uint256 feeAmount) {\n        require(msg.sender == feeReceiver, \"This fee can be claimed only by fee receiver!!\");\n        feeAmount = collectedFees - 1;\n        collectedFees = 1;        \n        TransferHelper.safeTransferETH(msg.sender, feeAmount);\n    }\n    \n    \n    // Call function processFee() at the end of main function for correct gas usage calculation.\n    // txGas - is gasleft() on start of calling contract. Put `uint256 txGas = gasleft();` as a first command in function\n    // feeAmount - fee amount that user paid\n    // processing - processing fee (for cross-chain swaping)\n    // licenseeVault - address that licensee received on registration and should provide when users comes from their site\n    // user - address of user who has to get reimbursement (usually msg.sender)\n\n    function processFee(uint256 txGas, uint256 feeAmount, uint256 processing, address licenseeVault, address user) internal {\n        if (address(reimbursementContract) == address(0)) {\n            payable(user).transfer(feeAmount); // return fee to sender if no reimbursement contract\n            return;\n        }\n        \n        uint256 licenseeFeeAmount;\n        if (licenseeVault != address(0)) {\n            uint256 companyFeeRate = reimbursementContract.getLicenseeFee(companyVault, address(this));\n            uint256 licenseeFeeRate = reimbursementContract.getLicenseeFee(licenseeVault, address(this));\n            if (licenseeFeeRate != 0)\n                licenseeFeeAmount = (feeAmount * licenseeFeeRate)/(licenseeFeeRate + companyFeeRate);\n            if (licenseeFeeAmount != 0) {\n                address licenseeFeeTo = reimbursementContract.requestReimbursement(user, licenseeFeeAmount, licenseeVault);\n                if (licenseeFeeTo == address(0)) {\n                    payable(user).transfer(licenseeFeeAmount);    // refund to user\n                } else {\n                    payable(licenseeFeeTo).transfer(licenseeFeeAmount);  // transfer to fee receiver\n                }\n            }\n        }\n        feeAmount -= licenseeFeeAmount; // company's part of fee\n        collectedFees += feeAmount; \n        \n        if (processing != 0) \n            payable(system).transfer(processing);  // transfer to fee receiver\n        \n        txGas -= gasleft(); // get gas amount that was spent on Licensee fee\n        txGas = txGas * tx.gasprice;\n        // request reimbursement for user\n        reimbursementContract.requestReimbursement(user, feeAmount+txGas+processing, companyVault);\n    }\n    \n    \n    function _swap( \n        OrderType orderType, \n        address[] memory path, \n        uint256 assetInOffered,\n        uint256 minExpectedAmount, \n        address to,\n        uint256 dexId,\n        uint256 deadline\n    ) internal returns(uint256 amountOut) {\n         \n        require(dexId < 2, \"Invalid DEX Id!\");\n        require(deadline >= block.timestamp, \"EXPIRED: Deadline for transaction already passed.\");\n\n       if(dexId == 0){\n            uint[] memory swapResult;\n            if(orderType == OrderType.EthForTokens) {\n                 path[0] = Uni.WETH();\n                 swapResult = Uni.swapExactETHForTokens{value:assetInOffered}(0, path, to,block.timestamp);\n            }\n            else if (orderType == OrderType.TokensForEth) {\n                path[path.length-1] = Uni.WETH();\n                TransferHelper.safeApprove(path[0], address(Uni), assetInOffered);\n                swapResult = Uni.swapExactTokensForETH(assetInOffered, 0, path,to, block.timestamp);\n            }\n            else if (orderType == OrderType.TokensForTokens) {\n                TransferHelper.safeApprove(path[0], address(Uni), assetInOffered);\n                swapResult = Uni.swapExactTokensForTokens(assetInOffered, minExpectedAmount, path, to, block.timestamp);\n            }\n            amountOut = swapResult[swapResult.length - 1];\n        } else if(dexId == 1) {\n            uint[] memory swapResult;\n            if(orderType == OrderType.EthForTokens) {\n                 path[0] = Sushi.WETH();\n                 swapResult = Sushi.swapExactETHForTokens{value:assetInOffered}(minExpectedAmount, path, to, block.timestamp);\n            }\n            else if (orderType == OrderType.TokensForEth) {\n                path[path.length-1] = Sushi.WETH();\n                TransferHelper.safeApprove(path[0], address(Sushi), assetInOffered);\n                swapResult = Sushi.swapExactTokensForETH(assetInOffered, minExpectedAmount, path, to, block.timestamp);\n            }\n            else if (orderType == OrderType.TokensForTokens) {\n                TransferHelper.safeApprove(path[0], address(Sushi), assetInOffered);\n                swapResult = Sushi.swapExactTokensForTokens(assetInOffered, minExpectedAmount, path, to, block.timestamp);\n            }\n            amountOut = swapResult[swapResult.length - 1];\n        }\n    }\n    \n    function executeSwap(\n        OrderType orderType, \n        address[] memory path, \n        uint256 assetInOffered, \n        uint256 fees, \n        uint256 minExpectedAmount,\n        address licenseeVault,\n        uint256 dexId,\n        uint256 deadline\n    ) external payable {\n        uint256 gasA = gasleft();\n        uint256 receivedFees = 0;\n        if(deadline == 0) {\n            deadline = block.timestamp + deadlineLimit;\n        }\n        \n        if(orderType == OrderType.EthForTokens){\n            require(msg.value >= (assetInOffered + fees), \"Payment = assetInOffered + fees\");\n            receivedFees = receivedFees + msg.value - assetInOffered;\n        } else {\n            require(msg.value >= fees, \"fees not received\");\n            receivedFees = receivedFees + msg.value;\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\n        }\n        \n        _swap(orderType, path, assetInOffered, minExpectedAmount, msg.sender, dexId, deadline);\n   \n        processFee(gasA, receivedFees, 0, licenseeVault, msg.sender);\n    }\n    \n    function executeCrossExchange(\n        address[] memory path, \n        OrderType orderType,\n        uint256 crossOrderType,\n        uint256 assetInOffered,\n        uint256 fees, \n        uint256 minExpectedAmount,\n        address licenseeVault,\n        uint256[3] memory dexId_deadline // dexId_deadline[0] - native swap dexId, dexId_deadline[1] - foreign swap dexId, dexId_deadline[2] - deadline\n    ) public payable {\n        uint256[2] memory feesPrice;\n        feesPrice[0] = gasleft();       // equivalent to gasA\n        feesPrice[1] = 0;               // processing fees\n        \n        if (dexId_deadline[2] == 0) {   // if deadline == 0, set deadline to deadlineLimit\n            dexId_deadline[2] = block.timestamp + deadlineLimit;\n        }\n\n        if(orderType == OrderType.EthForTokens){\n            require(msg.value >= (assetInOffered + fees + processingFee), \"Payment = assetInOffered + fees + processingFee\");\n            feesPrice[1] = msg.value - assetInOffered - fees;\n        } else {\n            require(msg.value >= (fees + processingFee), \"fees not received\");\n            feesPrice[1] = msg.value - fees;\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\n        }\n        \n        if(path[0] == USDT) {\n            TransferHelper.safeApprove(USDT, address(swapFactory), assetInOffered);\n            swapFactory.swap(USDT, path[path.length-1], assetInOffered, msg.sender, crossOrderType, dexId_deadline[1], dexId_deadline[2]);\n        }\n        else {\n            address tokenB = path[path.length-1];\n            path[path.length-1] = USDT;\n            uint256 minAmountExpected = _swap(orderType, path, assetInOffered, minExpectedAmount, address(this), dexId_deadline[0], dexId_deadline[2]);\n                \n            TransferHelper.safeApprove(USDT, address(swapFactory),minAmountExpected);\n            swapFactory.swap(USDT, tokenB, minAmountExpected, msg.sender, crossOrderType, dexId_deadline[1], dexId_deadline[2]);\n        }        \n\n        processFee(feesPrice[0], fees, feesPrice[1], licenseeVault, msg.sender);\n    }\n\n    function callbackCrossExchange( \n        uint256 orderType, \n        address[] memory path, \n        uint256 assetInOffered, \n        address user,\n        uint256 dexId,\n        uint256 deadline\n    ) public returns(bool) {\n        require(msg.sender == address(swapFactory) , \"Degen : caller is not SwapFactory\");\n        if(deadline==0) {\n            deadline = block.timestamp + deadlineLimit;\n        }\n        _swap(OrderType(orderType), path, assetInOffered, uint256(0), user, dexId, deadline);\n        return true;\n    }\n\n    // user has to approve 1Inch router contract to transfer `assetInOffered` before calling this function \n    // when call `swap` API of 1Inch, you have to set:\n    // `fromTokenAddress` - token user want to swap (if user swap ETH use address: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n    // `toTokenAddress ` - token user want to receive\n    // `amount` - amount of tokens user want to swap\n    // `fromAddress` - the user's address. MAY NOT WORK\n    // `slippage` - from user's setting\n    function executeSwap1Inch(\n        address[2] memory path, // path[0] - from token, path[1] - to token\n        OrderType orderType, \n        uint256 assetInOffered, // token amount or value of ETH (Form API response).\n        uint256 fees, \n        address licenseeVault,\n        address to, // 1Inch router. Form API response.\n        bytes memory data   // Form API response.\n    ) external payable {\n        uint256 gasA = gasleft();\n        uint256 receivedFees;\n        uint256 value;\n        \n        if(orderType == OrderType.EthForTokens){\n            require(msg.value >= (assetInOffered + fees), \"Payment = assetInOffered + fees\");\n            receivedFees = msg.value - assetInOffered;\n            value = assetInOffered;\n        } else {\n            require(msg.value >= fees, \"fees not received\");\n            receivedFees = msg.value;\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\n            TransferHelper.safeApprove(path[0],to,assetInOffered);\n        }\n        \n        callTo(to, value, data);\n   \n        processFee(gasA, receivedFees, 0, licenseeVault, msg.sender);\n    }\n    \n    // user has to approve 1Inch router contract to transfer `assetInOffered` before calling this function \n    // when call `swap` API of 1Inch, you have to set:\n    // `fromTokenAddress` - token user want to swap (if user swap ETH use address: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n    // `toTokenAddress ` - token user want to receive\n    // `amount` - amount of tokens user want to swap\n    // `fromAddress` - the user's address\n    // `slippage` - from user's setting\n    // `destReceiver` - Degen contract address\n    function executeCrossExchange1Inch(\n        address[2] memory path, // path[0] - from token, path[1] - to token\n        OrderType crossOrderType, \n        uint256 assetInOffered, // token amount or value of ETH (Form API response).\n        uint256 fees, \n        address licenseeVault,\n        address to, // 1Inch router. Form API response.\n        bytes memory data,   // Form API response.\n        uint256 toDEX,  // destination dex that will be used on foreign chain.\n        uint256 deadline\n    ) external payable {\n        uint256 gasA = gasleft();\n        uint256 _crossOrderType = uint256(crossOrderType);\n        uint256 value;\n        \n        if(deadline==0) {\n            deadline = block.timestamp + deadlineLimit;\n        }\n        \n        if(crossOrderType == OrderType.EthForTokens || crossOrderType == OrderType.EthForEth){\n            require(msg.value >= (assetInOffered + fees), \"Payment = assetInOffered + fees\");\n            fees = msg.value - assetInOffered;\n            value = assetInOffered;\n        } else {\n            require(msg.value >= fees, \"fees not received\");\n            fees = msg.value;\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\n            TransferHelper.safeApprove(path[0],to,assetInOffered);\n        }\n               \n        uint256 balanceUSDT = IERC20(USDT).balanceOf(address(this));\n        callTo(to, value, data);\n        balanceUSDT = IERC20(USDT).balanceOf(address(this)) - balanceUSDT;  // USDT amount that received from 1Inch swap\n        TransferHelper.safeApprove(USDT, address(swapFactory), balanceUSDT);\n        \n        swapFactory.swap(USDT, path[1], balanceUSDT, msg.sender, _crossOrderType, toDEX, deadline);\n\n        processFee(gasA, fees, 0, licenseeVault, msg.sender);\n    }\n\n    function callTo(address to, uint256 value, bytes memory data) internal {\n        (bool success,) = to.call{value: value}(data);\n        require(success, \"call to contract error\");\n    }\n\n    // If someone accidentally transfer tokens to this contract, the owner will be able to rescue it and refund sender.\n    function rescueTokens(address _token) external onlyOwner {\n        if (address(0) == _token) {\n            payable(msg.sender).transfer(address(this).balance);\n        } else {\n            uint256 available = IERC20(_token).balanceOf(address(this));\n            TransferHelper.safeTransfer(_token, msg.sender, available);\n        }\n    }\n\n}"
    }
  }
}