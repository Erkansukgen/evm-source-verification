{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/db.sol":{"content":"pragma solidity >=0.6.0 <0.7.0;\nimport \"./safeMath.sol\";\ncontract Db {\n    using SafeMath for uint256;\n    address own = msg.sender;\n    address coreAddress;\n    address toolAddress;\n    address tokenAddress;\n    Tool tool;\n    uint day = 86400;\n    modifier isCore(){\n        require(msg.sender == coreAddress);\n        _;\n    }\n    modifier isOwn(){\n        require(msg.sender == own);\n        _;\n    }\n    modifier isToken(){\n        require(msg.sender == tokenAddress);\n        _;\n    }\n    function init(address _coreAddress,address _toolAddress) isOwn public{\n        coreAddress = _coreAddress;\n        toolAddress = _toolAddress;\n        tool = Tool(_toolAddress);\n    }\n    function getNow() public view returns(uint){\n        return now;\n    }\n    function setLuckPool(uint _luckNum,uint _luckType,uint _luckArea,uint _balance) isCore public{\n        luckPool[_luckNum][_luckType][_luckArea] = _balance;\n    }\n    function setLuckPool(uint _luckNum) isCore public{\n        luckNum = _luckNum;\n    }\n    function setLastTime(uint _time) isCore public{\n        lastTime = _time;\n    }\n    function setSystemPlayerNum(uint _num) public isCore {\n        systemPlayerNum = _num;\n    }\n    function setPlayerLev(address _own,uint _lev) public isCore{\n        if(_lev > 0 && true == playerList[_own].isExist){\n            playerList[_own].lev = _lev;\n        }\n    }\n    function getPlayerInfo(address _own) public view returns(address _parent,bool _isExist,bool _isParent){\n        return (playerList[_own].parentAddress,playerList[_own].isExist,playerList[_own].isParent);\n    }\n    function _getProgenitorAddress(address _own) internal view returns (address[30] memory){\n        address[30] memory _progenitor;\n        Player memory _tempPlayer = playerList[_own];\n        for (uint i = 0; i < 30; i++) {\n            if (playerList[_tempPlayer.parentAddress].isExist == true) {\n                _progenitor[i] = _tempPlayer.parentAddress;\n                _tempPlayer = playerList[_tempPlayer.parentAddress];\n            }\n        }\n        return _progenitor;\n    }\n    function setMyTeam(address _own) internal{\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\n        for(uint i = 0;i<30;i++){\n            if(false == playerList[_progenitor[i]].isExist){\n                break;\n            }\n            if(i == 0){\n                playerList[_progenitor[i]].sonAddress.push(_own);\n            }\n            playerList[_progenitor[i]].teamAddress.push(_own);\n        }\n    }\n    function setPlayerParentAddress(address _own,address _parent) public isCore{\n        if(playerList[_own].isParent == false){\n            playerList[_own].isParent = true;\n            playerList[_own].isExist = true;\n            playerList[_own].parentAddress = _parent;\n            systemPlayerNum = systemPlayerNum.add(1);\n            setMyTeam(_own);\n        }\n    }\n    function getFreeWithdrawBalance(address _own) public view returns (uint){\n        require(playerList[_own].isExist == true);\n        uint _balance = playerList[_own].allIncome.sub(playerList[_own].withdrawAmount); \n        return _balance;\n    }\n    function setPlayerWithdraw(address _own) public isCore{\n        require(playerList[_own].isExist == true);\n        uint _balance = getFreeWithdrawBalance(_own);\n        if(_balance <= 0){\n            return;\n        }\n        playerList[_own].withdrawAmount = playerList[_own].withdrawAmount.add(_balance);\n        playerList[_own].lastWithdrawTime = getNow();\n    }\n    function _setMyTeamIncome(address _own,uint _balance) internal{\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\n        for(uint i = 0;i<30;i++){\n            if(false == playerList[_progenitor[i]].isExist){\n                break;\n            }\n            playerList[_progenitor[i]].teamRechargeAmount = playerList[_progenitor[i]].teamRechargeAmount.add(_balance);\n        }\n    }\n    function _setPlayerInvest(address _own,uint _balance) internal isCore{\n        require(playerList[_own].isExist == true);\n        playerList[_own].rechargeAmount = playerList[_own].rechargeAmount.add(_balance);\n        playerList[_own].teamRechargeAmount = playerList[_own].teamRechargeAmount.add(_balance);\n        _setMyTeamIncome(_own,_balance);\n        if(lastPool >= 9990000e6){\n            _setLastPoolOverflowReward(_balance);\n        }else{\n            lastPool = lastPool.add(_balance.mul(8).div(100));\n        }\n    }\n    function addInvestBurnNum(uint _num) public isCore{\n        investTokenUsdtNum[luckCodeNum] = investTokenUsdtNum[luckCodeNum].add(_num);\n    }\n    function getAreaPerformance(address _own) public view returns (uint _maxPerformance, uint _minPerformance){\n        uint _ownBalance = playerList[_own].rechargeAmount;\n        address[] memory _sonList = playerList[_own].sonAddress;\n        _maxPerformance = 0;\n        for (uint i = 0; i < _sonList.length; i++) {\n            if (playerList[_sonList[i]].teamRechargeAmount > _maxPerformance) {\n                _maxPerformance = playerList[_sonList[i]].teamRechargeAmount;\n            }\n        }\n        _minPerformance = playerList[_own].teamRechargeAmount.sub(_maxPerformance.add(_ownBalance));\n        return (_maxPerformance, _minPerformance);\n    }\n    function getAddressSomeInfo(address _own) public view returns(uint _teamCount,uint _sonCount,uint _investBalance,uint _lev,uint _incomeBalance,uint _withdrawBalance){\n        return (\n            playerList[_own].teamAddress.length,\n            playerList[_own].sonAddress.length,\n            playerList[_own].rechargeAmount,\n            playerList[_own].lev,\n            playerList[_own].allIncome,\n            playerList[_own].withdrawAmount\n            );\n    }\n    function addIncome(address _own,uint _type, uint _time ,uint _balance,address _fromAddress) public isCore{\n        if(_balance == 0){\n            return;\n        }\n        playerList[_own].allIncome = playerList[_own].allIncome.add(_balance);\n        incomeList[_own].push(Income({\n            incomeType : _type,\n            createTime : _time,\n            balance : _balance,\n            fromAddress : _fromAddress\n        }));\n    }\n    function addInvest(address _own,uint _balance) public isCore{\n        _setPlayerInvest(_own,_balance);\n        uint _ratio = tool._getRatio(_balance);\n        Invest memory _invest = Invest({\n            own : _own,\n            createTime : getNow(),\n            withdrawTime : getNow(),\n            balance : _balance,\n            ratio : _ratio,\n            profit : 0,\n            isFull : false\n        });\n        investList[_own].push(_invest);\n        systemInvest.push(_invest);\n    }\n    function addCodeToPlayer(address _own,uint _count) public isCore{\n        luckCodeBurnTokenNum[luckCodeNum] = luckCodeBurnTokenNum[luckCodeNum].add(_count);//增加消耗门票记录\n        for(uint i = 0; i < _count;i++){\n            luckCodeList[luckCodeNum].push(_own);\n        }\n    }\n    function _checkOpenLuckCodeLev() internal view returns (bool , bool){\n        uint _investBurnToken = investTokenUsdtNum[luckCodeNum];\n        uint _nowCodeNum = (luckCodeList[luckCodeNum].length).mul(1e6);\n        if(_investBurnToken >= _nowCodeNum.mul(2)){\n            return (true,true);\n        }else if(_investBurnToken >= _nowCodeNum){\n            return (false,true);\n        }else{\n            return (false,false);\n        }\n    }\n    function _giveUserLuckCodeReward(uint[25] memory _code,uint _length) internal{\n        for(uint i = 0;i < _length;i++){\n            address _tempAddress = luckCodeList[luckCodeNum][_code[i]];\n            luckCodeResList[luckCodeNum].push(_code[i]);\n            uint _tempBalance;\n            if(i >= 24){\n                _tempBalance = luckPool[luckCodeNum][1][1];\n                \n            }else if(i >= 18){\n                _tempBalance = luckPool[luckCodeNum][1][2].div(6);\n            }else{\n                _tempBalance = luckPool[luckCodeNum][1][3].div(18);\n            }\n            addIncome(_tempAddress,8,getNow(),_tempBalance,address(0x01));\n        }\n    }\n    function openLuckCodeReward() internal{\n        address[] memory _address = luckCodeList[luckCodeNum];\n        uint[25] memory _codeList = tool._crateLuckCodeList(_address.length);\n        uint[4] memory _poolBalance = luckPool[luckCodeNum][1];\n        uint _length;\n        (bool isLev1,bool isLev2) = _checkOpenLuckCodeLev();\n        if(true == isLev1){\n            _length = 25;\n        }else if(true == isLev2){\n            _length = 24;\n        }else{\n            _length = 18;\n        }\n        _giveUserLuckCodeReward(_codeList,_length);\n        luckCodeNum = luckCodeNum.add(1);\n        luckCodeList[luckCodeNum].push(address(0x00));\n        uint _frozenTempBalance;\n        if(true == isLev1){\n            return;\n        }else if(true == isLev2){\n            _frozenTempBalance = _poolBalance[1];\n        }else{\n            _frozenTempBalance = _poolBalance[1].add(_poolBalance[2]);\n        }\n        luckPool[luckCodeNum][1][0] = luckPool[luckCodeNum][1][1].add(_frozenTempBalance);\n        luckPool[luckCodeNum][1][1] = luckPool[luckCodeNum][1][1].add(_frozenTempBalance);\n    }\n    function openLuckInvestReward() internal{\n        Invest[21] memory _invest = _getLuckInvestList(true);\n        if(_invest[0].own == address(0x00) || _invest[0].balance == 0){\n            return;\n        }\n        uint _balance1 = luckPool[luckInvestNum][0][1];\n        uint _balance2 = luckPool[luckInvestNum][0][2].div(5);\n        uint _balance3 =luckPool[luckInvestNum][0][3].div(15);\n        for(uint i = 0; i < 21;i++){\n            if(_invest[i].balance == 0){\n                continue;\n            }\n            if(i == 0){\n                addIncome(_invest[i].own,8,getNow(),_balance1,address(0x00));\n            }else if(i <= 5){\n                addIncome(_invest[i].own,8,getNow(),_balance2,address(0x00));\n            }else{\n                addIncome(_invest[i].own,8,getNow(),_balance3,address(0x00));\n            }\n        }\n        lastLuckOpenTime = getNow();\n        luckInvestNum = luckInvestNum.add(1);\n    }\n    function setAssignment(uint _balance) public isCore{\n        uint _tempBalance = _balance.mul(5).div(100);\n        luckPool[luckCodeNum][0][0] = luckPool[luckCodeNum][0][0].add(_tempBalance); \n        luckPool[luckCodeNum][0][1] = luckPool[luckCodeNum][0][1].add(_tempBalance.mul(20).div(100)); \n        luckPool[luckCodeNum][0][2] = luckPool[luckCodeNum][0][2].add(_tempBalance.mul(30).div(100)); \n        luckPool[luckCodeNum][0][3] = luckPool[luckCodeNum][0][3].add(_tempBalance.mul(50).div(100)); \n        luckPool[luckCodeNum][1][0] = luckPool[luckCodeNum][1][0].add(_tempBalance); \n        luckPool[luckCodeNum][1][1] = luckPool[luckCodeNum][1][1].add(_tempBalance.mul(30).div(100)); \n        luckPool[luckCodeNum][1][2] = luckPool[luckCodeNum][1][2].add(_tempBalance.mul(30).div(100)); \n        luckPool[luckCodeNum][1][3] = luckPool[luckCodeNum][1][3].add(_tempBalance.mul(40).div(100)); \n    }\n    function getSurplusBalance(address _own) public view returns (uint, uint){\n        Invest[] memory _orderList = investList[_own];\n        uint _investCount = _orderList.length;\n        uint _surplusBanalce = 0;\n        uint _index = 0;\n        for (uint i = 0; i < _investCount; i++) {\n            if (_orderList[i].isFull == false) {\n                _surplusBanalce = ((_orderList[i].balance).mul(_orderList[i].ratio)).sub(_orderList[i].profit);\n                _index = i;\n                break;\n            }\n        }\n        return (_index, _surplusBanalce);\n    }\n    function setIncomeBurn(address _own,uint _balance) internal returns (uint) {\n        uint _tempBalance = _balance;\n        (uint _index, uint _surplusAmount) = getSurplusBalance(_own);\n        if (_surplusAmount <= 0) {\n            return 0;\n        }\n        if (_surplusAmount < _tempBalance) {\n            _tempBalance = _surplusAmount;\n            investList[_own][_index].isFull = true;\n            investList[_own][_index].profit = (investList[_own][_index].balance).mul(investList[_own][_index].ratio);\n        } else {\n            investList[_own][_index].profit = (investList[_own][_index].profit).add(_tempBalance);\n        }\n        return _tempBalance;\n    }\n    function _setParentReward(address _own,uint _balance) internal{\n        if(false == playerList[_own].isExist || false == playerList[_own].isParent || false == playerList[playerList[_own].parentAddress].isExist){\n            return;\n        }\n        uint _tempBalance = _balance.mul(10).div(100);\n        address _parent = playerList[_own].parentAddress;\n        _tempBalance = setIncomeBurn(_parent,_tempBalance);\n        addIncome(_parent,6,getNow(),_tempBalance,_own);\n    }\n    function _setSonsReward(address _own,uint _balance) internal{\n        if(false == playerList[_own].isExist){\n            return;\n        }\n        address[] memory _mySons = playerList[_own].sonAddress;\n        uint _sonNum = _mySons.length;\n        if(_sonNum <= 0){\n            return;\n        }\n        uint _giveBalance = _balance.mul(10).div(100).div(_sonNum);\n        for(uint i = 0;i < _mySons.length;i++){\n            uint _tempBalance = _giveBalance;\n            address _son = _mySons[i];\n            _tempBalance = setIncomeBurn(_son,_tempBalance);\n            addIncome(_son,7,getNow(),_tempBalance,_own);\n        }\n    }\n    function _setParentAndSonReward(address _own,uint _balance) internal{\n        _setParentReward(_own,_balance);\n        _setSonsReward(_own,_balance);\n    }\n    function giveShare(address _own, uint _balance) public isCore{\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\n        address[3] memory _parents;\n        _parents[0] = _progenitor[0];\n        _parents[1] = _progenitor[1];\n        _parents[2] = _progenitor[2];\n        uint[3] memory _ratio = [uint(9), 6, 3];\n        for (uint i = 0; i < 3; i++) {\n            if (playerList[_parents[i]].isExist) {\n                uint _tempBalance = _balance.mul(_ratio[i]).div(100);\n                _tempBalance = setIncomeBurn(_parents[i],_tempBalance);\n                addIncome(_parents[i],1,getNow(),_tempBalance,_own);\n                _setParentAndSonReward(_parents[i],_tempBalance);\n            }\n        }\n    }\n    function _getSon(address _own) internal view returns (address[] memory){\n        address[] memory _sonList = playerList[_own].sonAddress;\n        return _sonList;\n    }\n    function _getTeam(address _own) internal view returns (address[] memory){\n        address[] memory _teamList = playerList[_own].teamAddress;\n        return _teamList;\n    }\n    function _getTeamLevNum(address _own, uint _lev) internal view returns (uint, uint) {\n        address[] memory _teamAddress = _getTeam(_own);\n        uint _count = 0;\n        uint _nowLevCount = 0;\n        for (uint i = 0; i < _teamAddress.length; i++) {\n            if (playerList[_teamAddress[i]].lev >= _lev) {\n                _count = _count.add(1);\n                if (playerList[_teamAddress[i]].lev == _lev) {\n                    _nowLevCount = _nowLevCount.add(1);\n                }\n            }\n        }\n        if (playerList[_own].lev >= _lev) {\n            _count = _count.add(1);\n            if (playerList[_own].lev == _lev) {\n                _nowLevCount = _nowLevCount.add(1);\n            }\n        }\n        return (_count, _nowLevCount);\n    }\n    function getSystemTopLevUser() public view isCore returns (address[] memory) {\n        address[] memory _addressList = topLevUser;\n        return _addressList;\n    }\n    function _addAddressToSystem(address _own) internal {\n        address[] memory _addressList = getSystemTopLevUser();\n        bool _isExist = false;\n        for (uint i = 0; i < _addressList.length; i++) {\n            if (_addressList[i] == _own) {\n                _isExist = true;\n            }\n        }\n        if (false == _isExist) {\n            topLevUser.push(_own);\n        }\n    }\n    function _setLev1(address _own) internal {\n        uint _ownBalance = playerList[_own].rechargeAmount;\n        (uint _maxPerformance,uint _minPerformance) = getAreaPerformance(_own);\n        uint _nowLev = playerList[_own].lev;\n        if (_ownBalance >= 0 && _maxPerformance >= 30000e6 && _minPerformance >= 30000e6 && _nowLev < 1) {\n            playerList[_own].lev = 1;\n        }\n    }\n    function _setLev2(address _own, uint _setLevNum) internal {\n        require(_setLevNum >= 2, \"_setLevNum < 2\");\n        require(_setLevNum <= 4, \"_setLevNum > 4\");\n        uint _ownBalance = playerList[_own].rechargeAmount;\n        address[] memory _son = _getSon(_own);\n        uint _teamCount = 0;\n        for (uint i = 0; i < _son.length; i++) {\n            (uint _tempCountGtLev,uint _tempCountNowLev) = _getTeamLevNum(_son[i], _setLevNum.sub(1));\n            delete _tempCountNowLev;\n            if (_tempCountGtLev > 0) {\n                _teamCount = _teamCount.add(1);\n            }\n        }\n        uint _minBalance = 0;\n        if (_ownBalance >= _minBalance && _teamCount >= 2 && playerList[_own].lev < _setLevNum) {\n            playerList[_own].lev = _setLevNum;\n            if (_setLevNum == 4) {\n                _addAddressToSystem(_own);\n            }\n        }\n    }\n    function _addLevNumToSystem(uint _lev) internal {\n        require(_lev < 5);\n        systemLevNum[_lev] = systemLevNum[_lev].add(1);\n        if(_lev == 1){\n            return;\n        }\n        if(systemLevNum[_lev.sub(1)] == 0){\n            return;\n        }\n        systemLevNum[_lev.sub(1)] = systemLevNum[_lev.sub(1)].sub(1);\n    }\n    function _setLev(address _own) internal {\n        _setLev1(_own);\n        _setLev2(_own, 2);\n        _setLev2(_own, 3);\n        _setLev2(_own, 4);\n    }\n    function setParentLev(address _own) public isCore {\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\n        _setLev(_own);\n        for (uint i = 0; i < 30; i++) {\n            if (true == playerList[_progenitor[i]].isExist) {\n                _setLev(_progenitor[i]);\n            }\n        }\n    }\n    function setTeamLevReward(address _own, uint _balance) public isCore{\n        uint[5] memory _teamLevRewardRatio = [0, uint(3), 6, 9, 12];\n        address[30] memory _progenitor = _getProgenitorAddress(_own);\n        uint _nowLev = playerList[_own].lev;\n        teamLevReward[4] memory _teamLevRewardList;\n        uint _index = 0;\n        for (uint i = 0; i < 30; i++) {\n            if (true == playerList[_progenitor[i]].isExist) {\n                uint _tempPlayerLev = playerList[_progenitor[i]].lev;\n                if (_tempPlayerLev > _nowLev) {\n                    uint _ratio = _teamLevRewardRatio[_tempPlayerLev].sub(_teamLevRewardRatio[_nowLev]);\n                    _teamLevRewardList[_index].playerAddress = _progenitor[i];\n                    _teamLevRewardList[_index].ratio = _ratio;\n                    _teamLevRewardList[_index].balance = _balance;\n                    _teamLevRewardList[_index].fromAddress = _own;\n                    _teamLevRewardList[_index].isExist = true;\n                    _nowLev = _tempPlayerLev;\n                    _index = _index.add(1);\n                }\n            }\n        }\n        for (uint j = 0; j < 4; j++) {\n            if (true == _teamLevRewardList[j].isExist) {\n                _setTeamLevRewardAct(_teamLevRewardList[j].playerAddress, _teamLevRewardList[j].balance, _teamLevRewardList[j].ratio, _teamLevRewardList[j].fromAddress);\n            }\n        }\n    }\n    function _setTeamLevRewardAct(address _own, uint _balance, uint _ratio, address _formAddress) internal {\n        uint _tempBalance = (_balance.mul(_ratio)).div(100);\n        (,uint _surplusAmount) = getSurplusBalance(_own);\n        if (_surplusAmount <= 0) {\n            return;\n        }\n        _tempBalance = setIncomeBurn(_own,_tempBalance);\n        addIncome(_own,2,getNow(),_tempBalance,_formAddress);\n        _setParentAndSonReward(_own,_tempBalance);\n    }\n    function _setLastPoolOverflowReward(uint _balance) internal {\n        uint _giveBalance = _balance.mul(20).div(100);\n        _setTopLevReward(_giveBalance);\n    }\n    function setTopLevReward(uint _balance) public isCore{\n        _setTopLevReward(_balance);\n    }\n    function _setTopLevReward(uint _balance) internal {\n        address[] memory topLevList = topLevUser;\n        uint _topLevNum = topLevList.length;\n        if (_topLevNum <= 0) {\n            return;\n        }\n        uint _tempBalance = _balance.div(_topLevNum);\n        for (uint i = 0; i < _topLevNum; i++) {\n            addIncome(topLevList[i],4,getNow(),_tempBalance,tx.origin);\n        }\n    }\n    function getEstimateReward(address _own) public isCore view returns(uint,uint){\n        Invest[] memory _invest = investList[_own];\n        uint _min;\n        uint _max;\n        for(uint i = 0;i < _invest.length;i++){\n            if(true == _invest[i].isFull){\n                continue;\n            }\n            Invest memory _tempInvest = _invest[i]; \n            (uint _num,uint _endTime,uint _beginTime) = _getCompInvestNum(_tempInvest.withdrawTime);\n            _endTime.add(_beginTime);\n            _min = _min.add((_invest[i].balance).mul(_num).mul(30).div(10000));\n            _max = _max.add((_invest[i].balance).mul(_num).mul(180).div(10000));\n        }\n        return (_min,_max);\n    }\n    function _setStaticRewardToInvest(address _own, uint _index,uint _random,uint _actionTime) internal {\n        Invest memory _invest = investList[_own][_index];\n        if (_invest.isFull == true) {\n            return;\n        }\n        uint _ratio = tool._createRandomNum(30, 150, _index.add(_random));\n        uint _tempBalance = _invest.balance.mul(_ratio).div(10000);\n        _tempBalance = setIncomeBurn(_own,_tempBalance);\n        addIncome(_own,5,_actionTime,_tempBalance,address(0x00));\n    }\n    function _getCompInvestNum(uint _lastTime) public view returns(uint _num,uint _withdrawTime,uint _beginTime){\n        uint _day = day;\n        uint _nowTime = getNow();\n        _nowTime = _nowTime.sub(_nowTime.mod(day));\n        uint _extTime = _lastTime.mod(_day);\n        if(_extTime != 0){\n            _lastTime.sub(_extTime);\n        }\n        uint _dayNum;\n        if(_nowTime < _lastTime){\n            _dayNum = 0;\n        }else{\n            _dayNum = _nowTime.sub(_lastTime).div(_day);\n        }\n        return (_dayNum,_nowTime,_lastTime);\n    }\n    function _setInvestAllDayReward(address _own,uint _index) internal {\n        uint _day = day;\n        Invest memory _invest = investList[_own][_index];\n        (uint _num,uint _endTime,uint _beginTime) = _getCompInvestNum(_invest.withdrawTime);\n        for(uint i=0;i<_num;i++){\n            _beginTime = _beginTime.add(_day);\n            _setStaticRewardToInvest(_own,_index,i,_beginTime);\n        }\n        investList[_own][_index].withdrawTime = _endTime;\n    }\n    function setAllStaticReward(address _own) public isCore {\n        Invest[] memory _ownInvest = investList[_own];\n        for (uint i = 0; i < _ownInvest.length; i++) {\n            _setInvestAllDayReward(_own, i);\n        }\n    }\n    function getLastOpenLuckCodeList() public view returns(uint[] memory){\n        require(luckCodeNum >= 0);\n        uint[] memory _code;\n        _code = luckCodeResList[luckCodeNum.sub(1)];\n        return  _code;\n    }\n    function _getRewardList(address _own) internal view  returns (uint[9] memory){\n        uint[9] memory _reward;\n        Income[] memory _incomeList = incomeList[_own];\n        for(uint i=0;i < _incomeList.length;i++){\n            if(_incomeList[i].balance > 0){\n                _reward[_incomeList[i].incomeType] = _reward[_incomeList[i].incomeType].add(_incomeList[i].balance);\n            }\n        }\n        return _reward;\n    }\n    function getIncomeList(address _own) public view returns (uint[50] memory , uint[50] memory , uint[50] memory, address[50] memory ) {\n        Income[] memory _incomeList = incomeList[_own];\n        uint j = 0;\n        uint[50] memory _type;\n        uint[50] memory _createTime;\n        uint[50] memory _balance;\n        address[50] memory _address;\n        for(uint i = _incomeList.length;i > 0;i--){\n            if(j >= 50){\n                break;\n            }\n            _type[j] = _incomeList[i.sub(1)].incomeType;\n            _createTime[j] = _incomeList[i.sub(1)].createTime;\n            _balance[j] = _incomeList[i.sub(1)].balance;\n            _address[j] = _incomeList[i.sub(1)].fromAddress;\n            j++;\n        }\n        return (_type,_createTime,_balance,_address);\n    }\n    function getMyReward(address _own) public view  returns (uint[9] memory){\n        return _getRewardList(_own);\n    }\n    function _getDayMinInvest(Invest[21] memory _invest) internal pure returns (uint _value,uint _keyIndex){\n        uint _minValue = 0;\n        uint _index = 0;\n        for(uint i = 0; i < 21;i++){\n            if(_invest[i].balance  == 0){\n                return (0,i);\n            }\n            if(_minValue == 0){\n                _minValue = _invest[i].balance;\n                _index = i;\n            }\n            if(_minValue > _invest[i].balance){\n                _minValue = _invest[i].balance;\n                _index = i;\n            }\n        }\n        return (_minValue,_index);\n    }\n    function _setSortInvest(Invest[21] memory _invest) internal pure returns (Invest[21] memory){\n        for(uint i = 0;i < 21;i++){\n            for(uint j = i+1;j < 21;j++){\n                if(_invest[i].balance < _invest[j].balance){\n                    (_invest[i], _invest[j]) = (_invest[j], _invest[i]);\n                }\n            }\n        }\n        return _invest;\n    }\n    function _getLuckInvestList(bool _flag) internal view  returns (Invest[21] memory){\n        uint _lastTime;\n        uint _endTime;\n        if(true == _flag){\n            _lastTime = lastLuckOpenTime;\n            _endTime = getNow();\n        }else{\n            _lastTime = 0;\n            _endTime = getNow();\n        }\n        Invest[] memory _allInvest = systemInvest;\n        uint _allInvestNum = _allInvest.length;\n        require (_allInvestNum > 0);\n        _allInvestNum = _allInvestNum;\n        uint _endIndex;\n        bool _endFlag = false;\n        uint _startIndex;\n\n        for(;_allInvestNum > 0;_allInvestNum--){\n            if(_allInvest[_allInvestNum.sub(1)].createTime < _lastTime){\n                break;\n            }\n            if(_allInvest[_allInvestNum.sub(1)].createTime <= _endTime){\n                if(false == _endFlag){\n                    _endIndex = _allInvestNum.sub(1);\n                    _endFlag = true;\n                }\n                _startIndex = _allInvestNum.sub(1);\n            }\n        }\n        Invest[21] memory _dayMaxInvest;\n        for(uint i = _startIndex;i <= _endIndex;i++){\n            (uint _minValue,uint _minIndex) = _getDayMinInvest(_dayMaxInvest);\n            if(_minValue < _allInvest[i].balance){\n                _dayMaxInvest[_minIndex] = _allInvest[i];\n            }\n        }\n        _dayMaxInvest = _setSortInvest(_dayMaxInvest);\n        return _dayMaxInvest;\n    }\n    function getInvestList(bool _flag) public view isCore returns (address[21] memory) {\n        Invest[21] memory investList = _getLuckInvestList(_flag);\n        address[21] memory _address;\n        for(uint i = 0; i < 21;i++){\n            _address[i] = investList[i].own;\n        }\n        return _address;\n    }\n    function getSystemInvestLength() public view isCore returns (uint){\n        return systemInvest.length;\n    }\n    function getSystemInvestInfo(uint _index) public view isCore returns (address,uint){\n        return (systemInvest[_index].own,systemInvest[_index].createTime);\n    }\n    function getLuckCode(address _own) public view returns(uint[100] memory){\n        address[] memory _luckCodeList = luckCodeList[luckCodeNum];\n        uint[100] memory _code;\n        uint j = 0;\n        for(uint i = 0; i< _luckCodeList.length;i++){\n            if(j >= 100){\n                continue;\n            }\n            if(_luckCodeList[i] == _own){\n                _code[j] = i;\n                j++;\n            }\n        }\n        return _code;\n    }\n    function openReward() public isCore{\n        uint _nowTime = getNow();\n        uint _day = day;\n        if(_nowTime.sub(luckCodeLastTime) <= _day){\n            return;\n        }\n        openLuckInvestReward();\n        openLuckCodeReward();\n        luckCodeLastTime = getNow();\n    }\n    function openLastPoolReward() public isCore{\n        Invest[] memory _investList = systemInvest;\n        uint _length = systemInvest.length;\n        uint _index = _length.sub(1);\n        address[568] memory _player;\n        for(uint i=0;i<568;i++){\n            _player[i] = _investList[_index].own;\n            if(_index == 0){\n                break;\n            }\n            _index = _index.sub(1);\n        }\n        uint _num1 = lastPool.mul(10).div(100).div(8);\n        uint _num2 = lastPool.mul(20).div(100).div(60);\n        uint _num3 = lastPool.mul(70).div(100).div(500);\n        lastPool = 0;\n        for(uint j = 0;j<568;j++){\n            if(_player[j] == address(0x00)){\n                break;\n            }\n            if(j < 8){\n                addIncome(_player[j],3,getNow(),_num1,address(0x00));\n            }else if(j < 68){\n                addIncome(_player[j],3,getNow(),_num2,address(0x00));\n            }else{\n                addIncome(_player[j],3,getNow(),_num3,address(0x00));\n            }\n        }\n    }\n    mapping(uint=>uint[4][2]) public luckPool;\n    uint luckNum = 1;\n    uint luckInvestNum = 1;\n    uint public systemPlayerNum;\n    mapping(address => Player) public playerList;\n    address[] public topLevUser;\n    Invest[] public systemInvest;\n    mapping(address => Income[]) public incomeList;\n    mapping(address => Invest[]) public investList;\n    mapping(uint =>address[]) public luckCodeList;\n    mapping(uint =>uint[]) public luckCodeResList;\n    mapping(uint =>uint) public luckCodeBurnTokenNum;\n    mapping(uint =>uint) public investTokenUsdtNum;\n    uint public luckCodeNum = 1;\n    uint public luckCodeLastTime = now;\n    uint public lastLuckOpenTime = now;\n    uint luckInvestCycle = day;\n    uint public lastPool;\n    uint public lastTime;\n    uint[5] public systemLevNum; \n    struct Player {\n        uint lev;\n        uint withdrawAmount;\n        uint allIncome;\n        uint rechargeAmount;\n        uint teamRechargeAmount;\n        uint lastWithdrawTime;\n        bool isExist;\n        bool isParent;\n        address parentAddress;\n        address[] sonAddress;\n        address [] teamAddress;\n    }\n    struct Income {\n        uint incomeType;\n        uint createTime;\n        uint balance;\n        address fromAddress;\n    }\n    struct Invest{\n        address own;\n        uint createTime;\n        uint withdrawTime;\n        uint balance;\n        uint ratio;\n        uint profit;\n        bool isFull;\n    }\n    struct luckIncome{\n        uint balance;\n        address own;\n    }\n    struct luckIncomeHistory{\n        uint num;\n        luckIncome[] list;\n        bool isExist;\n    }\n    struct teamLevReward{\n        address playerAddress;\n        address fromAddress;\n        uint ratio;\n        uint balance;\n        bool isExist;\n    }\n}\nabstract contract Tool {\n    function _getNeedTicketNum(uint _balance) view public virtual returns (uint);\n    function _getRatio(uint _balance) pure public virtual returns (uint);\n    function _createRandomNum(uint _min, uint _max, uint _randNonce) public virtual view returns (uint);\n    function _crateLuckCodeList(uint _max) public view virtual returns (uint[25] memory);\n}"},"browser/safeMath.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\r\n\r\nlibrary SafeMath {\r\n    //加\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    //减\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    //乘\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    //除\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    //取余\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}}