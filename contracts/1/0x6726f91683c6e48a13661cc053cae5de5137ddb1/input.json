{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "/TokenOrbit/tokenorbiter/1/0x6726f91683c6e48a13661cc053cae5de5137ddb1/HyperTraderTokenOrbiter.sol": {
      "content": "\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n    \n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IKyberNetworkProxy {\n    function maxGasPrice() external view returns(uint);\n    function getUserCapInWei(address user) external view returns(uint);\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\n    function enabled() external view returns(bool);\n    function info(bytes32 id) external view returns(uint);\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\n    function swapEtherToToken(ERC20 token, uint minRate) external payable returns (uint);\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external returns (uint);\n}\n\ninterface Eth2DaiInterface {\n    function getBuyAmount(address dest, address src, uint srcAmt) external view returns(uint);\n\tfunction getPayAmount(address src, address dest, uint destAmt) external view returns (uint);\n\tfunction sellAllAmount(\n        address src,\n        uint srcAmt,\n        address dest,\n        uint minDest\n    ) external returns (uint destAmt);\n\tfunction buyAllAmount(\n        address dest,\n        uint destAmt,\n        address src,\n        uint maxSrc\n    ) external returns (uint srcAmt);\n}\n\npragma solidity ^0.5.7;\npragma experimental ABIEncoderV2;\n\nlibrary Account {\n    enum Status {Normal, Liquid, Vapor}\n    struct Info {\n        address owner; // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n    struct Storage {\n        mapping(uint256 => Types.Par) balances; // Mapping from marketId to principal\n        Status status;\n    }\n}\n\ncontract IERC20Token {\n    function name() public view returns (string memory) {this;}\n    function symbol() public view returns (string memory) {this;}\n    function decimals() public view returns (uint8) {this;}\n    function totalSupply() public view returns (uint256) {this;}\n    function balanceOf(address _owner) public view returns (uint256) {_owner; this;}\n    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n}\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint supply);\n    function balanceOf(address _owner) external view returns (uint balance);\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\n    function decimals() external view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\nlibrary Actions {\n    enum ActionType {\n        Deposit, // supply tokens\n        Withdraw, // borrow tokens\n        Transfer, // transfer balance between accounts\n        Buy, // buy an amount of some token (publicly)\n        Sell, // sell an amount of some token (publicly)\n        Trade, // trade tokens against another account\n        Liquidate, // liquidate an undercollateralized or expiring account\n        Vaporize, // use excess tokens to zero-out a completely negative account\n        Call // send arbitrary data to an address\n    }\n\n    enum AccountLayout {OnePrimary, TwoPrimary, PrimaryAndSecondary}\n\n    enum MarketLayout {ZeroMarkets, OneMarket, TwoMarkets}\n\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        Types.AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    struct DepositArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address from;\n    }\n\n    struct WithdrawArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address to;\n    }\n\n    struct TransferArgs {\n        Types.AssetAmount amount;\n        Account.Info accountOne;\n        Account.Info accountTwo;\n        uint256 market;\n    }\n\n    struct BuyArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 makerMarket;\n        uint256 takerMarket;\n        address exchangeWrapper;\n        bytes orderData;\n    }\n\n    struct SellArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 takerMarket;\n        uint256 makerMarket;\n        address exchangeWrapper;\n        bytes orderData;\n    }\n\n    struct TradeArgs {\n        Types.AssetAmount amount;\n        Account.Info takerAccount;\n        Account.Info makerAccount;\n        uint256 inputMarket;\n        uint256 outputMarket;\n        address autoTrader;\n        bytes tradeData;\n    }\n\n    struct LiquidateArgs {\n        Types.AssetAmount amount;\n        Account.Info solidAccount;\n        Account.Info liquidAccount;\n        uint256 owedMarket;\n        uint256 heldMarket;\n    }\n\n    struct VaporizeArgs {\n        Types.AssetAmount amount;\n        Account.Info solidAccount;\n        Account.Info vaporAccount;\n        uint256 owedMarket;\n        uint256 heldMarket;\n    }\n\n    struct CallArgs {\n        Account.Info account;\n        address callee;\n        bytes data;\n    }\n}\n\nlibrary Decimal {\n    struct D256 {\n        uint256 value;\n    }\n}\n\nlibrary Interest {\n    struct Rate {\n        uint256 value;\n    }\n\n    struct Index {\n        uint96 borrow;\n        uint96 supply;\n        uint32 lastUpdate;\n    }\n}\n\nlibrary Monetary {\n    struct Price {\n        uint256 value;\n    }\n    struct Value {\n        uint256 value;\n    }\n}\n\nlibrary Storage {\n    // All information necessary for tracking a market\n    struct Market {\n        // Contract address of the associated ERC20 token\n        address token;\n        // Total aggregated supply and borrow amount of the entire market\n        Types.TotalPar totalPar;\n        // Interest index of the market\n        Interest.Index index;\n        // Contract address of the price oracle for this market\n        address priceOracle;\n        // Contract address of the interest setter for this market\n        address interestSetter;\n        // Multiplier on the marginRatio for this market\n        Decimal.D256 marginPremium;\n        // Multiplier on the liquidationSpread for this market\n        Decimal.D256 spreadPremium;\n        // Whether additional borrows are allowed for this market\n        bool isClosing;\n    }\n\n    // The global risk parameters that govern the health and security of the system\n    struct RiskParams {\n        // Required ratio of over-collateralization\n        Decimal.D256 marginRatio;\n        // Percentage penalty incurred by liquidated accounts\n        Decimal.D256 liquidationSpread;\n        // Percentage of the borrower's interest fee that gets passed to the suppliers\n        Decimal.D256 earningsRate;\n        // The minimum absolute borrow value of an account\n        // There must be sufficient incentivize to liquidate undercollateralized accounts\n        Monetary.Value minBorrowedValue;\n    }\n\n    // The maximum RiskParam values that can be set\n    struct RiskLimits {\n        uint64 marginRatioMax;\n        uint64 liquidationSpreadMax;\n        uint64 earningsRateMax;\n        uint64 marginPremiumMax;\n        uint64 spreadPremiumMax;\n        uint128 minBorrowedValueMax;\n    }\n\n    // The entire storage state of Solo\n    struct State {\n        // number of markets\n        uint256 numMarkets;\n        // marketId => Market\n        mapping(uint256 => Market) markets;\n        // owner => account number => Account\n        mapping(address => mapping(uint256 => Account.Storage)) accounts;\n        // Addresses that can control other users accounts\n        mapping(address => mapping(address => bool)) operators;\n        // Addresses that can control all users accounts\n        mapping(address => bool) globalOperators;\n        // mutable risk parameters of the system\n        RiskParams riskParams;\n        // immutable risk limits of the system\n        RiskLimits riskLimits;\n    }\n}\n\nlibrary Types {\n    enum AssetDenomination {\n        Wei, // the amount is denominated in wei\n        Par // the amount is denominated in par\n    }\n\n    enum AssetReference {\n        Delta, // the amount is given as a delta from the current value\n        Target // the amount is given as an exact number to end up at\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n\n    struct TotalPar {\n        uint128 borrow;\n        uint128 supply;\n    }\n\n    struct Par {\n        bool sign; // true if positive\n        uint128 value;\n    }\n\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n}\n\ncontract ISoloMargin {\n    struct OperatorArg {\n        address operator;\n        bool trusted;\n    }\n\n    function ownerSetSpreadPremium(\n        uint256 marketId,\n        Decimal.D256 memory spreadPremium\n    ) public;\n\n    function getIsGlobalOperator(address operator) public view returns (bool);\n\n    function getMarketTokenAddress(uint256 marketId)\n        public\n        view\n        returns (address);\n\n    function ownerSetInterestSetter(uint256 marketId, address interestSetter)\n        public;\n\n    function getAccountValues(Account.Info memory account)\n        public\n        view\n        returns (Monetary.Value memory, Monetary.Value memory);\n\n    function getMarketPriceOracle(uint256 marketId)\n        public\n        view\n        returns (address);\n\n    function getMarketInterestSetter(uint256 marketId)\n        public\n        view\n        returns (address);\n\n    function getMarketSpreadPremium(uint256 marketId)\n        public\n        view\n        returns (Decimal.D256 memory);\n\n    function getNumMarkets() public view returns (uint256);\n\n    function ownerWithdrawUnsupportedTokens(address token, address recipient)\n        public\n        returns (uint256);\n\n    function ownerSetMinBorrowedValue(Monetary.Value memory minBorrowedValue)\n        public;\n\n    function ownerSetLiquidationSpread(Decimal.D256 memory spread) public;\n\n    function ownerSetEarningsRate(Decimal.D256 memory earningsRate) public;\n\n    function getIsLocalOperator(address owner, address operator)\n        public\n        view\n        returns (bool);\n\n    function getAccountPar(Account.Info memory account, uint256 marketId)\n        public\n        view\n        returns (Types.Par memory);\n\n    function ownerSetMarginPremium(\n        uint256 marketId,\n        Decimal.D256 memory marginPremium\n    ) public;\n\n    function getMarginRatio() public view returns (Decimal.D256 memory);\n\n    function getMarketCurrentIndex(uint256 marketId)\n        public\n        view\n        returns (Interest.Index memory);\n\n    function getMarketIsClosing(uint256 marketId) public view returns (bool);\n\n    function getRiskParams() public view returns (Storage.RiskParams memory);\n\n    function getAccountBalances(Account.Info memory account)\n        public\n        view\n        returns (address[] memory, Types.Par[] memory, Types.Wei[] memory);\n\n    function renounceOwnership() public;\n\n    function getMinBorrowedValue() public view returns (Monetary.Value memory);\n\n    function setOperators(OperatorArg[] memory args) public;\n\n    function getMarketPrice(uint256 marketId) public view returns (address);\n\n    function owner() public view returns (address);\n\n    function isOwner() public view returns (bool);\n\n    function ownerWithdrawExcessTokens(uint256 marketId, address recipient)\n        public\n        returns (uint256);\n\n    function ownerAddMarket(\n        address token,\n        address priceOracle,\n        address interestSetter,\n        Decimal.D256 memory marginPremium,\n        Decimal.D256 memory spreadPremium\n    ) public;\n\n    function operate(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    ) public;\n\n    function getMarketWithInfo(uint256 marketId)\n        public\n        view\n        returns (\n            Storage.Market memory,\n            Interest.Index memory,\n            Monetary.Price memory,\n            Interest.Rate memory\n        );\n\n    function ownerSetMarginRatio(Decimal.D256 memory ratio) public;\n\n    function getLiquidationSpread() public view returns (Decimal.D256 memory);\n\n    function getAccountWei(Account.Info memory account, uint256 marketId)\n        public\n        view\n        returns (Types.Wei memory);\n\n    function getMarketTotalPar(uint256 marketId)\n        public\n        view\n        returns (Types.TotalPar memory);\n\n    function getLiquidationSpreadForPair(\n        uint256 heldMarketId,\n        uint256 owedMarketId\n    ) public view returns (Decimal.D256 memory);\n\n    function getNumExcessTokens(uint256 marketId)\n        public\n        view\n        returns (Types.Wei memory);\n\n    function getMarketCachedIndex(uint256 marketId)\n        public\n        view\n        returns (Interest.Index memory);\n\n    function getAccountStatus(Account.Info memory account)\n        public\n        view\n        returns (uint8);\n\n    function getEarningsRate() public view returns (Decimal.D256 memory);\n\n    function ownerSetPriceOracle(uint256 marketId, address priceOracle) public;\n\n    function getRiskLimits() public view returns (Storage.RiskLimits memory);\n\n    function getMarket(uint256 marketId)\n        public\n        view\n        returns (Storage.Market memory);\n\n    function ownerSetIsClosing(uint256 marketId, bool isClosing) public;\n\n    function ownerSetGlobalOperator(address operator, bool approved) public;\n\n    function transferOwnership(address newOwner) public;\n\n    function getAdjustedAccountValues(Account.Info memory account)\n        public\n        view\n        returns (Monetary.Value memory, Monetary.Value memory);\n\n    function getMarketMarginPremium(uint256 marketId)\n        public\n        view\n        returns (Decimal.D256 memory);\n\n    function getMarketInterestRate(uint256 marketId)\n        public\n        view\n        returns (Interest.Rate memory);\n}\n\ncontract IUniswapExchange {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\n    // ERC20 comaptibility for liquidity tokens\n    bytes32 public name;\n    bytes32 public symbol;\n    uint256 public decimals;\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    // Never use\n    function setup(address token_addr) external;\n}\n\ninterface IUniswapFactory {\n    function createExchange(address token) external returns (address exchange);\n    function getExchange(address token) external view returns (address exchange);\n    function getToken(address exchange) external view returns (address token);\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\n    function initializeFactory(address template) external;\n}\n\ninterface IContractRegistry {\n    function addressOf(bytes32 _contractName) external view returns (address);\n}\n\ninterface IBancorNetwork {\n    function getReturnByPath(address[] calldata  _path, uint256 _amount) external view returns (uint256, uint256);\n    function convert2(address[] calldata _path, uint256 _amount,\n        uint256 _minReturn,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) external payable returns (uint256);\n\n    function claimAndConvert2(\n        address[] calldata _path,\n        uint256 _amount,\n        uint256 _minReturn,\n        address _affiliateAccount,\n        uint256 _affiliateFee\n    ) external returns (uint256);\n}\n\ninterface IBancorNetworkPathFinder {\n    function generatePath(address _sourceToken, address _targetToken) external view returns (address[] memory);\n}\n\ncontract OtcLike {\n    function sellAllAmount(address, uint, address, uint) public returns (uint);\n    function buyAllAmount(address, uint, address, uint) public returns (uint);\n    function getPayAmount(address, address, uint) public view returns (uint);\n}\n\ncontract TokenLike {\n    function balanceOf(address) public returns (uint);\n    function allowance(address, address) public returns (uint);\n    function approve(address, uint) public;\n    function transfer(address,uint) public returns (bool);\n    function transferFrom(address, address, uint) public returns (bool);\n    function deposit() public payable;\n    function withdraw(uint) public;\n}\npragma solidity ^0.5.7;\n\ncontract DydxFlashloanBase {\n    using SafeMath for uint256;\n\n    // -- Internal Helper functions -- //\n\n    function _getMarketIdFromTokenAddress(address _solo, address token)\n        internal\n        view\n        returns (uint256)\n    {\n        ISoloMargin solo = ISoloMargin(_solo);\n\n        uint256 numMarkets = solo.getNumMarkets();\n\n        address curToken;\n        for (uint256 i = 0; i < numMarkets; i++) {\n            curToken = solo.getMarketTokenAddress(i);\n\n            if (curToken == token) {\n                return i;\n            }\n        }\n\n        revert(\"No marketId found for provided token\");\n    }\n\n    function _getRepaymentAmountInternal(uint256 amount)\n        internal\n        pure\n        returns (uint256)\n    {\n        // Needs to be overcollateralize\n        // Needs to provide +2 wei to be safe\n        return amount.add(2);\n    }\n\n    function _getAccountInfo() internal view returns (Account.Info memory) {\n        return Account.Info({owner: address(this), number: 1});\n    }\n\n    function _getWithdrawAction(uint marketId, uint256 amount)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Withdraw,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n\n    function _getCallAction(bytes memory data)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Call,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: 0\n                }),\n                primaryMarketId: 0,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: data\n            });\n    }\n\n    function _getDepositAction(uint marketId, uint256 amount)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Deposit,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: true,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: address(this),\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n}\n\npragma solidity ^0.5.7;\n\ncontract ICallee {\n\n    // ============ Public Functions ============\n\n    /**\n     * Allows users to send this contract arbitrary data.\n     *\n     * @param  sender       The msg.sender to Solo\n     * @param  accountInfo  The account from which the data is being sent\n     * @param  data         Arbitrary data given by the sender\n     */\n    function callFunction(\n        address sender,\n        Account.Info memory accountInfo,\n        bytes memory data\n    )\n        public;\n}\npragma solidity ^0.5.0;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\npragma solidity ^0.5.0;\n\n\ncontract IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\npragma solidity ^0.5.0;\ninterface IWETH {\n  function deposit() external payable;\n  function withdraw(uint wad) external;\n  function totalSupply() external view returns (uint);\n  function approve(address guy, uint wad) external returns (bool);\n  function transfer(address dst, uint wad) external returns (bool);\n  function transferFrom(address src, address dst, uint wad) external returns (bool);\n  function () external payable;\n}\n\npragma solidity ^0.5.0;\n\n\n//Hyper Techniques\ncontract TokenOrbiter is ICallee, DydxFlashloanBase {\n    using SafeMath\n    for uint256;\n    using SafeMath\n    for uint;\n    address owner;\n    bytes  theBytes;\n    bytes  PERM_HINT = \"PERM\";\n    string[] portalTokens;\n    uint256 portalAmount;\n    string[] portalExchanges;\n    address portalFirstTokenAddress;\n    address portalReturnAddress;\n\n    mapping (uint256=>uint256) results;\n    mapping(uint256=>uint8[3]) public orders;\n\n\n\taddress uni_v2_addr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address uni_v1_factory_addr = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n    address solo_addr = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n\taddress weth_addr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\taddress dai_addr = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\taddress usdc_addr = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address oasis_addr= 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n    address oasis_maker_otc_methods_address = 0x9b3F075b12513afe56Ca2ED838613B7395f57839;\n    address kyber_proxy_address = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\n    address contract_registry = 0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4;\n    address bancore_network_addr = 0x3Ab6564d5c214bc416EE8421E05219960504eeAD;\n    address bancore_network_pathfinder_addr = 0x6F0cD8C4f6F06eAB664C7E3031909452b4B72861;\n\n    IKyberNetworkProxy kyberProxy = IKyberNetworkProxy(kyber_proxy_address);\n    IContractRegistry contractRegistry = IContractRegistry(contract_registry);\n    IBancorNetwork bancorNetwork = IBancorNetwork(bancore_network_addr);\n    IBancorNetworkPathFinder bancorNetworkPathFinder = IBancorNetworkPathFinder(bancore_network_pathfinder_addr);\n    IUniswapFactory uniswapFactory = IUniswapFactory(uni_v1_factory_addr);\n    IUniswapV2Router02 uni = IUniswapV2Router02(uni_v2_addr);\n\tISoloMargin solo = ISoloMargin(solo_addr);\n\n\n\n    constructor() public {\n\t\towner = msg.sender;\n    }\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner); // Eddie Thomas Blockchain Wizard 21 years of Computer Engineering Excellence \n\t\t_;\n\t}\n\n    function setAllowance(IERC20 _token, address _spender) internal {\n        if (_token.allowance(address(this), _spender) != uint(-1)) {\n            _token.approve(_spender, uint(-1));\n        }\n    }\n\n\n    function beamWethToWallet(\n        address token,\n        uint amount\n    ) internal {\n        TokenLike(token).withdraw(amount);\n        (bool ok,) = msg.sender.call.value(amount)(\"\");\n        require(ok, \"\");\n    }\n\n    function beamToWallet(address tokenAddress) onlyOwner external{\n        ERC20 token = ERC20(tokenAddress);\n        token.transfer(owner, token.balanceOf(address(this)));\n    }\n  \n    function bancorConvert(address token1, address token2, uint256 amount) onlyOwner external  returns (uint256){\n      \n        if (token1 == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || token1 == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2){\n            token1 = 0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315;\n        }\n        if (token2 == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || token2 == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2){\n            token2 = 0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315;\n        }\n        \n        address[] memory addressPath;\n        addressPath = bancorNetworkPathFinder.generatePath(token2, token1);\n       \n        uint256 price = bancorNetwork.convert2.value(amount)(addressPath, amount,1 ,address(0x0),0);\n        return price;\n    }\n\n\tfunction setOwner(address _o) onlyOwner external {\n\t\towner = _o;\n\t}\n\n    function startXOrbiter(address[] memory tokens,  uint256 amount, string[] memory exchanges, uint256[] memory minCoinSellAmounts) onlyOwner public returns(bool){\n        // if(liquidityProviderContractAddress == fundsReturnToAddress){\n            xorbiter1( tokens, amount, exchanges, minCoinSellAmounts);\n        // }else{\n        //     if(equal(exchanges[0], \")){\n        //         string[]  memory newTokens = new string[](tokens.length-1);\n        //         string[]  memory newExchanges = new string[](exchanges.length-1);\n                \n        //         if(exchanges.length==3){\n        //             newTokens[0]=tokens[1];\n        //             newTokens[1]=tokens[2];\n\n        //             newExchanges[0]=exchanges[1];\n        //             newExchanges[1]=exchanges[2];\n        //         }else if(exchanges.length==4){\n        //             newTokens[0]=tokens[1];\n        //             newTokens[1]=tokens[2];\n        //             newTokens[2]=tokens[3];\n\n        //             newExchanges[0]=exchanges[1];\n        //             newExchanges[1]=exchanges[2];\n        //             newExchanges[2]=exchanges[3];\n        //         } else if(exchanges.length==5){\n        //             newTokens[0]=tokens[1];\n        //             newTokens[1]=tokens[2];\n        //             newTokens[2]=tokens[3];\n        //             newTokens[3]=tokens[4];\n\n        //             newExchanges[0]=exchanges[1];\n        //             newExchanges[1]=exchanges[2];\n        //             newExchanges[2]=exchanges[3];\n        //             newExchanges[3]=exchanges[4];\n        //         } else{\n        //             newTokens[0]=tokens[1];\n        //             newTokens[1]=tokens[2];\n        //             newTokens[2]=tokens[3];\n        //             newTokens[3]=tokens[4];\n        //             newTokens[4]=tokens[5];\n\n        //             newExchanges[0]=exchanges[1];\n        //             newExchanges[1]=exchanges[2];\n        //             newExchanges[2]=exchanges[3];\n        //             newExchanges[3]=exchanges[4];\n        //             newExchanges[4]=exchanges[5];\n        //         }\n                \n        //         latestTokens = newTokens;\n        //         latestAmount = amount;\n        //         latestExchanges = newExchanges;\n                \n        //         latestFirstTokenAddress = newTokens[0];\n        //     } else {\n\n        //         latestTokens = tokens;\n        //         latestAmount = amount;\n        //         latestExchanges = exchanges;\n        //         latestFirstTokenAddress = tokens[0];\n            \n        //         //  flash.flashLoan(this, latestFirstTokenAddress, amount, theBytes);\n        //     }\n        // }\n        return true;\n    }\n\n    function xorbiter1( address[] memory tokens,  uint256 amount, string[] memory exchanges, uint256[] memory minCoinSellAmounts) onlyOwner internal returns(bool){\n\n        uint[] memory eOrder1 = new uint[](exchanges.length);\n        bool back = true;\n\n        for(uint i =0; i<exchanges.length; i++){\n           if(equal(exchanges[i], \"KYBER\")){\n               eOrder1[i] =1;       \n           }\n           else if(equal(exchanges[i], \"UNIV1\")){\n               eOrder1[i] =2;   \n           }\n           else if(equal(exchanges[i], \"BANCOR\")){\n               eOrder1[i] =3;   \n           }\n           else if(equal(exchanges[i], \"UNIV2\")){\n               eOrder1[i] =4;   \n           }\n           else if(equal(exchanges[i], \"OASIS\")){\n               eOrder1[i] =5;   \n           }\n           else{\n               eOrder1[i] =4;\n           }\n        }\n        \n        xorbiter2(eOrder1, tokens, amount, back, minCoinSellAmounts);\n        uint tLast = tokens.length-1;\n\n        address lastToken = tokens[tLast];\n\n        ERC20 lToken = ERC20(lastToken);\n        uint256 balanceHere = lToken.balanceOf(address(this));\n        lToken.transfer(owner, balanceHere);\n    \n         return true;       \n    }\n\n    function xorbiter2(uint[] memory eOrder, address[] memory tOrder, uint256 amount, bool back, uint256[] memory minCoinSellAmounts) onlyOwner internal {\n        uint256 final1 = eOrder.length -1;\n        uint lastSell = amount;\n\n        for(uint i =0; i<eOrder.length; i++){\n            uint256 next = i+1;\n            if(i < final1){\n                if(eOrder[i] ==1){\n                    //kyber buy\n                    lastSell = beamKyber(tOrder[i], lastSell, tOrder[next]);\n                }\n                else if(eOrder[i] ==2){\n                    lastSell = beamUniswap(tOrder[i], lastSell, tOrder[next]);\n                }\n                else if(eOrder[i] ==3){\n                    lastSell = beamBancor(tOrder[i], tOrder[next], lastSell);\n                }\n                else if(eOrder[i] ==4){\n                        lastSell = beamUniswapV2(tOrder[i], lastSell, tOrder[next], tOrder);\n                }\n                else if(eOrder[i] ==5){\n                        lastSell = beamOutOasisSwap(tOrder[i], lastSell, tOrder[next], minCoinSellAmounts[next]);\n                }\n                else{\n                    lastSell = beamBancor(tOrder[next], tOrder[i], lastSell);\n                }\n            }\n            else{\n                    //sell \n                if(back == true){\n                    if(eOrder[i] ==1){\n                        //kyber buy\n                        lastSell = beamKyber(tOrder[i], lastSell, tOrder[0]);\n                    }\n                    else if(eOrder[i] ==2){\n                        lastSell = beamUniswap(tOrder[i], lastSell, tOrder[0]);\n                    }\n                    else if(eOrder[i] ==3){\n                        lastSell = beamBancor(tOrder[i], tOrder[0], lastSell);\n                    }\n                     else if(eOrder[i] ==4){\n                        lastSell = beamUniswapV2(tOrder[i], lastSell, tOrder[0], tOrder);\n                    }\n                     else if(eOrder[i] ==5){\n                        lastSell = beamOutOasisSwap(tOrder[i], lastSell, tOrder[0], minCoinSellAmounts[0]);\n                    }\n\n                    else{\n                        lastSell = beamBancor(tOrder[0], tOrder[i], lastSell);\n                    }\n                }\n            }\n        }\n    }\n\n    function beamBancor(address token1, address token2, uint256 amount) onlyOwner public returns (uint256){\n        address[] memory addressPath;\n        // IContractRegistry contractRegistry = IContractRegistry(contract_registry);\n        // IBancorNetwork bancorNetwork = IBancorNetwork(bancore_network_addr);\n        // IBancorNetworkPathFinder bancorNetworkPathFinder = IBancorNetworkPathFinder(bancore_network_pathfinder_addr);\n\n        if (token1 == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || token1 == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2){\n            // the EtherToken addresss for BancorNetwork\n            token1 = 0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315;\n        }\n        if (token2 == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE || token2 == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2){\n            token2 = 0xc0829421C1d260BD3cB3E0F06cfE2D52db2cE315;\n        }\n\n        addressPath = bancorNetworkPathFinder.generatePath(token2, token1);\n    \n        ERC20 token = ERC20(token1);\n        ERC20 tokenT = ERC20(token2);\n    \n        uint startAmount =token.balanceOf(address(this));\n        token.approve(bancore_network_addr, 8000000000000000000000000000000);\n        tokenT.approve(bancore_network_addr, 8000000000000000000000000000000);\n\n        bancorNetwork.claimAndConvert2(addressPath, amount,1 ,address(0x0),0);\n        \n        return token.balanceOf(address(this)) - startAmount;\n    }\n\t\n    function beamKyber(address sellToken1, uint sellTokenAmount, address  buyToken1) onlyOwner public  returns (uint) {\n        ERC20 sellToken = ERC20(sellToken1);\n        ERC20 buyToken = ERC20(buyToken1);\n        uint startAmount =buyToken.balanceOf(address(this));\n        \n        sellToken.approve(address(kyberProxy), sellTokenAmount);\n\n        kyberProxy.tradeWithHint(sellToken, sellTokenAmount, buyToken, address(this), 8000000000000000000000000000000000000000000000000000000000000000, 0, 0x0000000000000000000000000000000000000004, PERM_HINT);\n        \n        return buyToken.balanceOf(address(this)) - startAmount;\n    }\n\n    function beamInOasisSwap(\n        address payToken,\n        uint payAmt,\n        address buyToken,\n        uint minBuyAmt\n    ) onlyOwner public returns (uint buyAmt) {\n        require(TokenLike(payToken).transferFrom(msg.sender, address(this), payAmt), \"\");\n        if (TokenLike(payToken).allowance(address(this), oasis_maker_otc_methods_address) < payAmt) {\n            TokenLike(payToken).approve(oasis_maker_otc_methods_address, uint(-1));\n        }\n        buyAmt = OtcLike(oasis_maker_otc_methods_address).sellAllAmount(payToken, payAmt, buyToken, minBuyAmt);\n        require(TokenLike(buyToken).transfer(msg.sender, buyAmt), \"\");\n    }\n\n    function beamOutOasisSwap(\n        address buyToken,\n        uint buyAmt,\n        address payToken,\n        uint maxPayAmt\n    ) onlyOwner public returns (uint payAmt) {\n        uint payAmtNow = OtcLike(oasis_maker_otc_methods_address).getPayAmount(payToken, buyToken, buyAmt);\n        require(payAmtNow <= maxPayAmt, \"\");\n        require(TokenLike(payToken).transferFrom(msg.sender, address(this), payAmtNow), \"\");\n        if (TokenLike(payToken).allowance(address(this), oasis_maker_otc_methods_address) < payAmtNow) {\n            TokenLike(payToken).approve(oasis_maker_otc_methods_address, uint(-1));\n        }\n        payAmt = OtcLike(oasis_maker_otc_methods_address).buyAllAmount(buyToken, buyAmt, payToken, payAmtNow);\n        // To avoid rounding issues we check the minimum value:\n        require(TokenLike(buyToken).transfer(msg.sender, SafeMath.min(buyAmt, TokenLike(buyToken).balanceOf(address(this)))), \"\");\n    }\n\n    function beamUniswap(address sellToken1, uint sellTokenAmount, address buyToken1) onlyOwner public returns (uint) {\n        ERC20 sellToken = ERC20(sellToken1);\n        ERC20 buyToken = ERC20(buyToken1);\n        uint startAmount =buyToken.balanceOf(address(this));\n        uint256 minTokensBought = 1;\n        uint256 minEtherBought = 1;\n        address exchangeAddress = uniswapFactory.getExchange(address(sellToken));\n        IUniswapExchange exchange = IUniswapExchange(exchangeAddress);\n        sellToken.approve(address(exchange), sellTokenAmount);\n        exchange.tokenToTokenSwapInput(sellTokenAmount, minTokensBought, minEtherBought, block.timestamp, address(buyToken));\n        return buyToken.balanceOf(address(this)) - startAmount;\n    }\n\n    function beamUniswapV2(address sellToken1, uint sellTokenAmount, address buyToken1, address[] memory path ) onlyOwner public returns (uint) {\n        // ERC20 sellToken = ERC20(sellToken1);\n        ERC20 buyToken = ERC20(buyToken1);\n        uint startAmount = buyToken.balanceOf(address(this));\n               \n        IERC20 erc20 = IERC20(sellToken1);\n        erc20.transferFrom(msg.sender, address(this), sellTokenAmount);\n\t\terc20.approve(uni_v2_addr, sellTokenAmount); \n        uni.swapExactTokensForTokens(sellTokenAmount, sellTokenAmount, path, msg.sender, now + 5 minutes);\n        \n        \n        return buyToken.balanceOf(address(this)) - startAmount;\n    }\n\n    // function getRateOasis(address src, address dest, uint srcAmt) onlyOwner public view returns (uint destAmt) {\n    //     if (src == weth_addr) {\n    //         destAmt = Eth2DaiInterface(oasis_addr).getBuyAmount(dest, weth_addr, srcAmt);\n    //     } else if (dest == weth_addr) {\n    //         destAmt = Eth2DaiInterface(oasis_addr).getBuyAmount(weth_addr, src, srcAmt);\n    //     } else {\n    //         destAmt = Eth2DaiInterface(oasis_addr).getBuyAmount(dest, src, srcAmt);\n    //     }\n    // }\n\n    // function getRateKyber(address src, address dest, uint srcAmt) onlyOwner public view returns (uint destAmt) {\n    //     (uint kyberPrice,) = kyberProxy.getExpectedRate(src, dest, srcAmt);\n    //     destAmt = SafeMath.wmul(srcAmt, kyberPrice);\n    // }\n\n    function remove(uint index, string[] memory array) pure  internal returns(string[] memory) {\n        if (index >= array.length) return array;\n        string[] memory arrayCreate;\n        for (uint i = index; i<array.length-1; i++){\n            arrayCreate[i] = array[i+1];\n        }\n        return arrayCreate;\n    }\n\n    function compare(string memory _a, string memory _b) internal pure returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n    \n    function equal(string memory _a, string memory _b) internal pure returns (bool) {\n        return compare(_a, _b) == 0;\n    }\n    \n    function indexOf(string memory _haystack, string memory _needle) internal pure returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1)) // since we have to be able to return -1 (if the char isn't found or input error), this function must return an \"int\" type with a max length of (2^128 - 1)\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0]) // found the first char of b\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) // search until the chars don't match or until we reach the end of a or b\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n    \n    function beamOrbiterTokens(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address tokenOut,\n        string memory exchange\n    ) onlyOwner public {\n        IERC20 erc20 = IERC20(tokenIn);\n        erc20.transferFrom(msg.sender, address(this), amountIn);\n\n        if (equal(exchange,\"BANCOR\")){\n            beamBancor(tokenIn,tokenOut, amountIn);\n        }else if (equal(exchange,\"KYBER\")){\n            beamKyber(tokenIn,amountIn,tokenOut);\n        }else if (equal(exchange,\"OASIS\")){\n            beamOutOasisSwap(tokenOut,amountOutMin,tokenIn,amountIn);\n        }else if (equal(exchange,\"UNIV1\")){\n            beamUniswap(tokenIn,amountIn,tokenOut);\n        }else{\n            address[] memory path;\n            path[0]=tokenIn;\n            path[1]=tokenOut;\n            beamUniswapV2(tokenIn,amountIn,tokenOut,path);\n        }\n    }\n\n  \n    function callFunction(\n        address sender,\n        Account.Info memory account,\n        bytes memory data\n    ) public {\n\t\t(address tokenIn, uint amountIn, string[] memory exchanges, address[] memory path, string memory phaseShift, uint256[] memory minCoinSellAmounts, uint256 minProfit) = abi.decode(data, (address, uint256, string[], address[], string, uint256[], uint256));\n        uint256 repayAmount = amountIn + 2;\n        if (equal(phaseShift,\"PLANETARY\")){\n            beamOrbiterTokens(tokenIn, amountIn,minProfit,tokenIn,exchanges[0]);\n        }else if (equal(phaseShift,\"LUNAR\")){\n            startXOrbiter(path, amountIn, exchanges, minCoinSellAmounts);\n        }else if (equal(phaseShift,\"SOLAR\")){\n            startXOrbiter(path, amountIn, exchanges, minCoinSellAmounts); //Thinking Yield Farming, Staking, Liquidity, etc..\n        }else if (equal(phaseShift,\"GALATIC\")){\n            startXOrbiter(path, amountIn, exchanges, minCoinSellAmounts);\n        }else if (equal(phaseShift,\"UNIVERSE\")){\n            startXOrbiter(path, amountIn, exchanges, minCoinSellAmounts);\n        }else if (equal(phaseShift,\"MULTIVERSE\")){\n            startXOrbiter(path, amountIn, exchanges, minCoinSellAmounts);\n        }else if (equal(phaseShift,\"DIMENSIONAL\")){\n            startXOrbiter(path, amountIn, exchanges, minCoinSellAmounts);\n        }else{\n           startXOrbiter(path, amountIn, exchanges, minCoinSellAmounts);\n        }\n\t\t\n        // uint256 balance = IERC20(tokenIn).balanceOf(address(this));\n        require(\n            IERC20(tokenIn).balanceOf(address(this)) >= minProfit,\n            \"Not enough funds to repay dydx loan!\"\n        );\n\n        uint profit = IERC20(tokenIn).balanceOf(address(this)) - repayAmount; \n        IERC20(tokenIn).transfer(owner, profit);\n    }\n\n    function flashBeamOrbiterTokens(\n      address tokenIn, \n      uint256 amountIn, \n      string[] calldata exchanges,\n      address[] calldata path,\n      string calldata phaseShift,\n      uint256[] calldata minCoinSellAmounts,\n      uint256 minProfit\n\t) onlyOwner external {\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(solo_addr, tokenIn);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(amountIn);\n        IERC20(tokenIn).approve(solo_addr, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, amountIn);\n        operations[1] = _getCallAction(\n            abi.encode(tokenIn, amountIn, exchanges, path, phaseShift, minCoinSellAmounts, (minProfit+repayAmount))\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount);\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        solo.operate(accountInfos, operations);\n    }\n\n    function() external payable {}\n}\n"
    }
  }
}