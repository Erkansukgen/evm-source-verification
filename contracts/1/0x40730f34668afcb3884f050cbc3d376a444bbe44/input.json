{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/MaticDelegationProxy.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\n// File contracts/lib/IERC20.sol\npragma solidity 0.7.3;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// File contracts/lib/Ownable.sol\npragma solidity 0.7.3;\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n// File contracts/lib/DelegationProxy.sol\npragma solidity 0.7.3;\n\ninterface StakingNFT {\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n  function approve(address to, uint256 tokenId) external;\n  function getApproved(uint256 tokenId) external view returns (address operator);\n  function setApprovalForAll(address operator, bool _approved) external;\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n  function transferFrom(address from, address to, uint256 tokenId) external;\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;\n}\n\ninterface ValidatorShare {\n  function buyVoucher(uint256, uint256) external;\n  function withdrawRewards() external;\n  function sellVoucher(uint256, uint256) external;\n  function unstakeClaimTokens() external;\n  function getLiquidRewards(address user) external view returns (uint256);\n}\n\ninterface ValidatorShare_New {\n  function buyVoucher(uint256, uint256) external returns(uint256);\n  function withdrawRewards() external;\n  function sellVoucher(uint256, uint256) external;\n  function unstakeClaimTokens() external;\n  function sellVoucher_new(uint256, uint256) external;\n  function unstakeClaimTokens_new(uint256) external;\n}\n\ninterface IStakeManager {\n  function getValidatorContract(uint256 validatorId) external view returns (address);\n  function token() external view returns (IERC20);\n  function NFTContract() external view returns (StakingNFT);\n}\n\ncontract DelegationProxy is Ownable {\n  uint256[] public validatorsList;\n  mapping(uint256 => bool) public validatorsLookup;\n\n  IStakeManager public stakeManager;\n\n  constructor(IStakeManager _stakeManager) {\n    require(_stakeManager != IStakeManager(0x0));\n\n    stakeManager = _stakeManager;\n  }\n\n  function getLiquidRewards(uint256 validatorId) public view returns(uint256) {\n    ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\n    require(delegationContract != ValidatorShare(0x0));\n\n    return delegationContract.getLiquidRewards(address(this));\n  }\n\n  function withdrawTokens(address tokenAddress, uint256 amount) public onlyOwner {\n    IERC20(tokenAddress).transfer(owner(), amount);\n  }\n\n  function delegate(uint256[] memory validators, uint256[] memory amount, uint256 totalAmount) public onlyOwner {\n    require(validators.length == amount.length);\n    \n    IERC20 token = stakeManager.token();\n    token.approve(address(stakeManager), totalAmount);\n    \n    for (uint256 i = 0; i < validators.length; ++i) {\n      uint256 validatorId = validators[i];\n\n      if (!validatorsLookup[validatorId]) {\n        validatorsLookup[validatorId] = true;\n        validatorsList.push(validatorId);\n      }\n\n      ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\n      require(delegationContract != ValidatorShare(0x0));\n\n      // buy voucher\n      delegationContract.buyVoucher(amount[i], 0);\n    }\n  }\n\n  function delegate_new(uint256[] memory validators, uint256[] memory amount, uint256 totalAmount) public onlyOwner {\n    require(validators.length == amount.length);\n    \n    IERC20 token = stakeManager.token();\n    token.approve(address(stakeManager), totalAmount);\n    \n    for (uint256 i = 0; i < validators.length; ++i) {\n      uint256 validatorId = validators[i];\n\n      if (!validatorsLookup[validatorId]) {\n        validatorsLookup[validatorId] = true;\n        validatorsList.push(validatorId);\n      }\n\n      ValidatorShare_New delegationContract = ValidatorShare_New(stakeManager.getValidatorContract(validatorId));\n      require(delegationContract != ValidatorShare_New(0x0));\n\n      // buy voucher\n      delegationContract.buyVoucher(amount[i], 0);\n    }\n  }\n\n  function transferRewards(uint256[] memory validators) public onlyOwner {\n    IERC20 token = stakeManager.token();\n    StakingNFT nft = stakeManager.NFTContract();\n\n    uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n    for (uint256 i = 0; i < validators.length; ++i) {\n      uint256 validatorId = validators[i];\n      \n      ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\n      require(delegationContract != ValidatorShare(0x0));\n\n      delegationContract.withdrawRewards();\n\n      uint256 rewards = token.balanceOf(address(this)) - tokenBalanceBefore;\n      token.transfer(nft.ownerOf(validatorId), rewards);\n    }\n  }\n\n  function collectRewards(uint256[] memory validators) public onlyOwner {\n    for (uint256 i = 0; i < validators.length; ++i) {\n      uint256 validatorId = validators[i];\n      \n      ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\n      require(delegationContract != ValidatorShare(0x0));\n\n      delegationContract.withdrawRewards();\n    }\n  }\n\n  function sellVoucher(uint256 validatorId, uint256 claimAmount, uint256 maximumSharesToBurn) public onlyOwner {\n    ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\n    require(delegationContract != ValidatorShare(0x0));\n\n    delegationContract.sellVoucher(claimAmount, maximumSharesToBurn);\n  }\n\n  function sellVoucher_new(uint256 validatorId, uint256 claimAmount, uint256 maximumSharesToBurn) public onlyOwner {\n    ValidatorShare_New delegationContract = ValidatorShare_New(stakeManager.getValidatorContract(validatorId));\n    require(delegationContract != ValidatorShare_New(0x0));\n\n    delegationContract.sellVoucher_new(claimAmount, maximumSharesToBurn);\n  }\n\n  function unstakeClaimTokens(uint256 validatorId) public onlyOwner {\n    ValidatorShare delegationContract = ValidatorShare(stakeManager.getValidatorContract(validatorId));\n    require(delegationContract != ValidatorShare(0x0));\n\n    delegationContract.unstakeClaimTokens();\n  }\n\n  function unstakeClaimTokens_new(uint256 validatorId, uint256 unbondNonce) public onlyOwner {\n    ValidatorShare_New delegationContract = ValidatorShare_New(stakeManager.getValidatorContract(validatorId));\n    require(delegationContract != ValidatorShare_New(0x0));\n\n    delegationContract.unstakeClaimTokens_new(unbondNonce);\n  }\n\n  function callAny(address target, bytes memory data) public onlyOwner {\n    (bool success, ) = target.call(data); /* bytes memory returnData */\n    require(success, \"Call failed\");\n  }\n}"}}}