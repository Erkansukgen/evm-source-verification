{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/MyContract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity =0.7.6;\npragma abicoder v2;\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\ninterface IUniswapV3Pool {\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n    \n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n}\n\nlibrary BytesLib {\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n    \n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8)\n    {\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n    \n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96)\n    {\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xC), _start))\n        }\n\n        return tempUint;\n    }\n    \n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n}\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            bytes8 previousTokenPairs,\n            uint8 zeroForOne,\n            uint8 isSimulation,\n            uint96 firstAmountIn,\n            uint8 lastPairIndex,\n            address[] memory previousPairsPath,\n            uint96[] memory previousRevertAmounts\n        )\n    {\n        previousTokenPairs = bytes8(path.toUint64(0));\n        \n        zeroForOne = path.toUint8(8); // 1 octet\n        isSimulation = path.toUint8(9); // 1 octet\n        firstAmountIn = path.toUint96(10); // 12 octeti\n        lastPairIndex = path.toUint8(22); // 1 octet\n\n        //get array size of addresses\n        uint8 addressSize = path.toUint8(23); // 1 octet\n        \n        address[] memory aNewAddr = new address[](addressSize);\n        \n        for(uint i = 0; i < addressSize; ++i)\n        {\n            aNewAddr[i] = (path.toAddress((24 + (i * 20))));\n        }\n        previousPairsPath = aNewAddr;\n        \n        //get array of revert amount\n        uint8 lastIndex = (24 + (addressSize * 20));\n        uint8 aRevertSize = path.toUint8(lastIndex); // 1 octet\n        uint96[] memory aNewRevert = new uint96[](aRevertSize);\n        \n        for(uint i = 0; i < aRevertSize; ++i)\n        {\n            aNewRevert[i] = (path.toUint96(((lastIndex + 1) + (i * 12))));\n        }\n        previousRevertAmounts = aNewRevert;\n    }\n}\n\nlibrary UniswapV2Library {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n}\n\ninterface IERC20 {\n    function transfer(address to, uint value) external returns (bool);\n}\n\ninterface IWETH is IERC20{\n    function deposit() external payable;\n    function withdraw(uint) external;\n}\n\ninterface IUniswapV3SwapCallback {\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\ncontract SwappingContract is IUniswapV3SwapCallback\n{\n    using Path for bytes;\n    \n\tIWETH private constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\t\n    //Constructor\n\tconstructor()\n\t{\t\t\n\t}\n\t\n   /**\n   * @dev Throws if called by any account that's not whitelisted.\n   */\n    modifier onlyWhitelisted() {\n    require(msg.sender == 0xd7E1236C08731C3632519DCd1A581bFe6876a3B2, '_|_');\n    _;\n    }\n    \n  \t//Represents the actual swap function..\n  \tfunction internalSwapV3(address[] memory pairsPath, uint96[] memory aRevertAmounts, bytes8 indexTokensPairs, uint64 maxBlockPermitted, uint64 amountIn, uint64 minerTip) internal\n  \t{\n  \t    require(block.number <= maxBlockPermitted, \"Zzzz...\");\n  \t    \n  \t    //this is valid if first pair is v2\n  \t    if(indexTokensPairs[1] == 0x00 || indexTokensPairs[1] == 0x01)\n  \t    {\n  \t        //else continue\n\t\t    WETH.transfer(pairsPath[0], amountIn);\n  \t    }\n  \t    \n        for(uint256 i = 1; i <= pairsPath.length; ++i)\n        {\n            byte aPairType = indexTokensPairs[i];\n            \n            if(i < pairsPath.length) //not last pair\n            {\n                if(indexTokensPairs[i + 1] == 0x03 || indexTokensPairs[i + 1] == 0x04)\n                {\n                    uint currentIndex = i;\n                    \n                    while(currentIndex < pairsPath.length) // we are not last pair\n                    {\n                        if(indexTokensPairs[currentIndex + 1] == 0x03 || indexTokensPairs[currentIndex + 1] == 0x04)\n                        {\n                            //if index the last one..and we have v3,,,execuyte it\n                            if(currentIndex == (pairsPath.length - 1))\n                            {\n                                prepareV3Data(pairsPath, aRevertAmounts, indexTokensPairs, currentIndex, amountIn);\n                                currentIndex++;\n                                break;\n                            }\n                            \n                            currentIndex++;\n                        }\n                        else\n                        {\n                            //finish line.. execute swap on last v3 pair\n                            prepareV3Data(pairsPath, aRevertAmounts, indexTokensPairs, currentIndex - 1, amountIn);\n                            break;\n                        }\n                    }\n                    \n                    i = currentIndex;\n                    continue;\n                }\n            }\n\n            if(aPairType == 0x03 || aPairType == 0x04)\n            {\n                IUniswapV3Pool aPool = IUniswapV3Pool(pairsPath[i - 1]);\n                \n                (address tokenIn, address tokenOut) = aPairType == 0x03? (aPool.token0(), aPool.token1()) : (aPool.token1(), aPool.token0());\n                bool zeroForOne = tokenIn < tokenOut;\n\n                aPool.swap(\n                    (i < pairsPath.length? pairsPath[i] : address(this)), zeroForOne, i == 1? amountIn : int256(aRevertAmounts[i - 2]), (zeroForOne ? 4295128740 : 1461446703485210103287273052203988822378723970341), \n                    abi.encodePacked(bytes8(0), zeroForOne, false, uint96(0), uint8(10), uint8(1), address(0), uint8(1), uint96(0)));\n            }\n            else\n            {\n                (uint96 amount0Out, uint96 amount1Out) = (aPairType == 0x01) ? (uint96(0), aRevertAmounts[i - 1]) : (aRevertAmounts[i - 1], uint96(0));\n\n\t\t\t    IUniswapV2Pair(pairsPath[i - 1]).swap(\n\t\t\t\t     amount0Out, amount1Out, (i < pairsPath.length? pairsPath[i] : address(this)), new bytes(0));\n            }\n        }\n        \n        //check if last pair was v3..check the \n        byte actionType = indexTokensPairs[7];\n        if(actionType == 0x01)\n        {\n            WETH.withdraw(200000000000000000); //0.2 eth unwrap..then send to wallet.\n            msg.sender.transfer(200000000000000000);\n        }\n        else if(actionType == 0x02)\n        {\n            block.coinbase.transfer(minerTip);\n        }\n  \t}\n  \t\n  \tfunction prepareV3Data(address[] memory pairsPath, uint96[] memory aRevertAmounts, bytes8 indexTokensPairs, uint256 myIndex, uint96 amountIn) internal\n  \t{\n  \t    //add all information regarding current pair\n        IUniswapV3Pool aPool = IUniswapV3Pool(pairsPath[myIndex]);\n\n        (address tokenIn, address tokenOut) = indexTokensPairs[myIndex + 1] == 0x03? (aPool.token0(), aPool.token1()) : (aPool.token1(), aPool.token0());\n        bytes memory encodedData = encodePacking(tokenIn < tokenOut, amountIn, (myIndex == 0? uint8(10) : uint8(myIndex)), indexTokensPairs, pairsPath, aRevertAmounts);\n        \n        aPool.swap(\n            (myIndex < (pairsPath.length - 1)? pairsPath[myIndex + 1] : address(this)), tokenIn < tokenOut, myIndex == 0? int256(amountIn) : int256(aRevertAmounts[myIndex - 1]), (tokenIn < tokenOut ? 4295128740 : 1461446703485210103287273052203988822378723970341), \n            encodedData);\n  \t}\n  \t\n  \tfunction encodePacking(bool zeroOne, uint96 amountIn, uint8 lastIndex, bytes8 tokenPairs, address[] memory pairsPath, uint96[] memory aRevertAmounts) internal pure returns(bytes memory)\n  \t{\n  \t    if(pairsPath.length == 2)\n  \t    {\n  \t       return abi.encodePacked(tokenPairs, zeroOne, false, amountIn, (lastIndex == 0? uint8(10) : uint8(lastIndex)), uint8(2), pairsPath[0], pairsPath[1], uint8(2), aRevertAmounts[0], aRevertAmounts[1]); \n  \t    }\n  \t    else if(pairsPath.length == 3)\n  \t    {\n  \t        return abi.encodePacked(tokenPairs, zeroOne, false, amountIn, (lastIndex == 0? uint8(10) : uint8(lastIndex)), uint8(3), pairsPath[0], pairsPath[1],  pairsPath[2], uint8(3), aRevertAmounts[0], aRevertAmounts[1], aRevertAmounts[2]); \n  \t    }\n  \t    else if(pairsPath.length == 4)\n  \t    {\n  \t        bytes memory firstPart = abi.encodePacked(tokenPairs, zeroOne, false, amountIn, (lastIndex == 0? uint8(10) : uint8(lastIndex)), uint8(4), pairsPath[0], pairsPath[1]);\n  \t        return abi.encodePacked(firstPart, pairsPath[2], pairsPath[3], uint8(4), aRevertAmounts[0], aRevertAmounts[1], aRevertAmounts[2], aRevertAmounts[3]);\n  \t    }\n  \t    else \n  \t    {\n  \t        bytes memory firstPart = abi.encodePacked(tokenPairs, zeroOne, false, amountIn, (lastIndex == 0? uint8(10) : uint8(lastIndex)), uint8(5), pairsPath[0], pairsPath[1], pairsPath[2], pairsPath[3]);\n  \t        return abi.encodePacked(firstPart, pairsPath[4], uint8(5), aRevertAmounts[0], aRevertAmounts[1], aRevertAmounts[2], aRevertAmounts[3], aRevertAmounts[4]);\n  \t    }\n  \t}\n  \t\n  \t//Represents the actual swap function..\n  \tfunction internalSwap(address[] memory pairsPath, uint96[] memory aRevertAmounts, bytes8 indexTokensPairs, uint64 maxBlockPermitted, uint64 amountIn, uint64 minerTip) internal\n  \t{\n  \t    require(block.number <= maxBlockPermitted, \"Zzzz...\");\n  \t    \n  \t    //else continue\n\t    WETH.transfer(pairsPath[0], amountIn);\n  \t    \n        for(uint256 i = 1; i <= pairsPath.length; ++i)\n        {\n            (uint96 amount0Out, uint96 amount1Out) = (indexTokensPairs[i] == 0x01) ? (uint96(0), aRevertAmounts[i - 1]) : (aRevertAmounts[i - 1], uint96(0));\n\n\t\t\tIUniswapV2Pair(pairsPath[i - 1]).swap(\n\t\t\t    amount0Out, amount1Out, (i < pairsPath.length? pairsPath[i]: address(this)), new bytes(0));\n        }\n        \n        byte actionType = indexTokensPairs[7];\n        if(actionType == 0x01)\n        {\n            WETH.withdraw(200000000000000000); //0.2 eth unwrap..then send to wallet.\n            msg.sender.transfer(200000000000000000);\n        }\n        else if(actionType == 0x02)\n        {\n            block.coinbase.transfer(minerTip);\n        }\n  \t}\n  \t\n  \t//for 3 pairs! Max Hop: 4\n  \tfunction thirdWaySwap(bytes32 aInputData1, bytes32 aInputData2, bytes32 aInputData3, bytes32 aFinalData) onlyWhitelisted external payable\n\t{\n        uint96[] memory aRevertAmounts = new uint96[](3);\n        address[] memory pairsPath = new address[](3);\n        bytes8 indexTokensPairs;\n        uint64 maxBlockPermitted;\n        uint64 minerTip;\n        uint64 amountIn;\n        \n        assembly \n        {\n            //now the hardest part....\n            //======================DECODE FIRST PART====================//\n            mstore(0x0C, aInputData1)\n            mstore(add(pairsPath, 32), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData1)\n            mstore(add(aRevertAmounts, 32), mload(0))\n            \n            //=======================DECODE SECOND PART=============================//\n            mstore(0x0C, aInputData2)\n            mstore(add(pairsPath, 64), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData2)\n            mstore(add(aRevertAmounts, 64), mload(0))\n            \n            //=======================DECODE THIRD PART=============================//\n            mstore(0x0C, aInputData3)\n            mstore(add(pairsPath, 96), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData3)\n            mstore(add(aRevertAmounts, 96), mload(0))\n            \n            //=======================DECODE FINAL PART==============================//\n            indexTokensPairs := aFinalData\n            \n            mstore(0x10, aFinalData) //primii 8 octeti sunt token inputs... pos 24\n            maxBlockPermitted := mload(0)\n            \n            mstore(0x08, aFinalData) //primii 8 octeti sunt token inputs... pos 24\n            amountIn := mload(0)\n            \n            mstore(0, aFinalData) //and final miner tip\n            minerTip := mload(0)\n        }\n        \n        if(indexTokensPairs[6] == 0x01) // we have 3\n        {\n            internalSwapV3(pairsPath, aRevertAmounts, indexTokensPairs, maxBlockPermitted, amountIn, minerTip);\n        }\n        else\n        {\n            internalSwap(pairsPath, aRevertAmounts, indexTokensPairs, maxBlockPermitted, amountIn, minerTip);\n        }\n  \t}\n  \t\n  \t//for 4 pairs! Max Hop: 5\n  \tfunction forthWaySwap(bytes32 aInputData1, bytes32 aInputData2, bytes32 aInputData3, bytes32 aInputData4, bytes32 aFinalData) onlyWhitelisted external payable\n\t{\n        uint96[] memory aRevertAmounts = new uint96[](4);\n        address[] memory pairsPath = new address[](4);\n        bytes8 indexTokensPairs;\n        uint64 maxBlockPermitted;\n        uint64 minerTip;\n        uint64 amountIn;\n        \n        assembly \n        {\n            //now the hardest part....\n            //======================DECODE FIRST PART====================//\n            mstore(0x0C, aInputData1)\n            mstore(add(pairsPath, 32), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData1)\n            mstore(add(aRevertAmounts, 32), mload(0))\n            \n            //=======================DECODE SECOND PART=============================//\n            mstore(0x0C, aInputData2)\n            mstore(add(pairsPath, 64), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData2)\n            mstore(add(aRevertAmounts, 64), mload(0))\n            \n            //=======================DECODE THIRD PART=============================//\n            mstore(0x0C, aInputData3)\n            mstore(add(pairsPath, 96), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData3)\n            mstore(add(aRevertAmounts, 96), mload(0))\n            \n             //=======================DECODE FORFTH PART=============================//\n            mstore(0x0C, aInputData4)\n            mstore(add(pairsPath, 128), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData4)\n            mstore(add(aRevertAmounts, 128), mload(0))\n            \n            //=======================DECODE FINAL PART==============================//\n            indexTokensPairs := aFinalData\n            \n            mstore(0x10, aFinalData) //primii 8 octeti sunt token inputs... pos 24\n            maxBlockPermitted := mload(0)\n            \n            mstore(0x08, aFinalData) //primii 8 octeti sunt token inputs... pos 24\n            amountIn := mload(0)\n            \n            mstore(0, aFinalData) //and final miner tip\n            minerTip := mload(0)\n        }\n    \n        if(indexTokensPairs[6] == 0x01) // we have 3\n        {\n            internalSwapV3(pairsPath, aRevertAmounts, indexTokensPairs, maxBlockPermitted, amountIn, minerTip);\n        }\n        else\n        {\n            internalSwap(pairsPath, aRevertAmounts, indexTokensPairs, maxBlockPermitted, amountIn, minerTip);\n        }\n  \t}\n  \t\n  \t//for 5 pairs! Max Hop: 6\n  \tfunction fiveWaySwap(bytes32 aInputData1, bytes32 aInputData2, bytes32 aInputData3, bytes32 aInputData4, bytes32 aInputData5, bytes32 aFinalData) onlyWhitelisted external payable\n\t{\n        uint96[] memory aRevertAmounts = new uint96[](5);\n        address[] memory pairsPath = new address[](5);\n        bytes8 indexTokensPairs;\n        uint64 maxBlockPermitted;\n        uint64 minerTip;\n        uint64 amountIn;\n        \n        assembly \n        {\n            //now the hardest part....\n            //======================DECODE FIRST PART====================//\n            mstore(0x0C, aInputData1)\n            mstore(add(pairsPath, 32), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData1)\n            mstore(add(aRevertAmounts, 32), mload(0))\n            \n            //=======================DECODE SECOND PART=============================//\n            mstore(0x0C, aInputData2)\n            mstore(add(pairsPath, 64), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData2)\n            mstore(add(aRevertAmounts, 64), mload(0))\n            \n            //=======================DECODE THIRD PART=============================//\n            mstore(0x0C, aInputData3)\n            mstore(add(pairsPath, 96), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData3)\n            mstore(add(aRevertAmounts, 96), mload(0))\n            \n            //=======================DECODE FORFTH PART=============================//\n            mstore(0x0C, aInputData4)\n            mstore(add(pairsPath, 128), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData4)\n            mstore(add(aRevertAmounts, 128), mload(0))\n            \n            //=======================DECODE FIFTH PART=============================//\n            mstore(0x0C, aInputData5)\n            mstore(add(pairsPath, 160), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData5)\n            mstore(add(aRevertAmounts, 160), mload(0))\n            \n            //=======================DECODE FINAL PART==============================//\n            indexTokensPairs := aFinalData\n            \n            mstore(0x10, aFinalData) //primii 8 octeti sunt token inputs... pos 24\n            maxBlockPermitted := mload(0)\n            \n            mstore(0x08, aFinalData) //primii 8 octeti sunt token inputs... pos 24\n            amountIn := mload(0)\n            \n            mstore(0, aFinalData) //and final miner tip\n            minerTip := mload(0)\n        }\n    \n        if(indexTokensPairs[6] == 0x01) // we have 3\n        {\n            internalSwapV3(pairsPath, aRevertAmounts, indexTokensPairs, maxBlockPermitted, amountIn, minerTip);\n        }\n        else\n        {\n            internalSwap(pairsPath, aRevertAmounts, indexTokensPairs, maxBlockPermitted, amountIn, minerTip);\n        }\n  \t}\n\n  \t//for 2 pairs! Max Hop: 3\n  \tfunction twoWaySwap(bytes32 aInputData1, bytes32 aInputData2, bytes32 aFinalData) onlyWhitelisted external payable\n\t{\n        uint96[] memory aRevertAmounts = new uint96[](2);\n        address[] memory pairsPath = new address[](2);\n        bytes8 indexTokensPairs;\n        uint64 maxBlockPermitted;\n        uint64 minerTip;\n        uint64 amountIn;\n        \n        assembly \n        {\n             //now the hardest part....\n            //======================DECODE FIRST PART====================//\n            mstore(0x0C, aInputData1)\n            mstore(add(pairsPath, 32), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData1)\n            mstore(add(aRevertAmounts, 32), mload(0))\n            \n            //=======================DECODE SECOND PART=============================//\n            mstore(0x0C, aInputData2)\n            mstore(add(pairsPath, 64), mload(0)) // add it to first element from array\n            \n            //now take the first total amount\n            mstore(0, aInputData2)\n            mstore(add(aRevertAmounts, 64), mload(0))\n            \n            //=======================DECODE FINAL PART==============================//\n            indexTokensPairs := aFinalData\n            \n            mstore(0x10, aFinalData) //primii 8 octeti sunt token inputs... pos 24\n            maxBlockPermitted := mload(0)\n            \n            mstore(0x08, aFinalData) //primii 8 octeti sunt token inputs... pos 24\n            amountIn := mload(0)\n            \n            mstore(0, aFinalData) //and final miner tip\n            minerTip := mload(0)\n        }\n    \n        if(indexTokensPairs[6] == 0x01) // we have 3\n        {\n            internalSwapV3(pairsPath, aRevertAmounts, indexTokensPairs, maxBlockPermitted, amountIn, minerTip);\n        }\n        else\n        {\n            internalSwap(pairsPath, aRevertAmounts, indexTokensPairs, maxBlockPermitted, amountIn, minerTip);\n        }\n  \t}\n  \t\n  \t\n  \t// performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address[] calldata pairsPath, uint amountIn, address[] calldata path, uint[] calldata tokenPairPositions) external returns (uint[] memory amounts) {\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        \n        amounts[0] = amountIn;\n        \n        for (uint i = 0; i < path.length - 1; i++)\n        {\n            //v3\n            if(tokenPairPositions[i] == 3 || tokenPairPositions[i] == 4)\n            {\n                amounts[i + 1] = getAmountsOutV3(amounts[i], pairsPath[i], path[i], path[i + 1]);\n            }\n            //v2\n            else\n            {\n                (uint reserveIn, uint reserveOut) = getReserves(pairsPath[i], path[i], path[i + 1]);\n                amounts[i + 1] = UniswapV2Library.getAmountOut(amounts[i], reserveIn, reserveOut);\n            }\n        }\n    }\n    \n    //Get reserves for v3 pool\n    function getAmountsOutV3(uint amountIn, address pairID, address tokenIn, address tokenOut) internal returns (uint256 amountOut) \n    {\n        bool zeroForOne = tokenIn < tokenOut;\n        \n        try\n        IUniswapV3Pool(pairID).swap(\n                address(this), // address(0) might cause issues with some tokens\n                zeroForOne,\n                int256(amountIn),\n                (zeroForOne ? 4295128740 : 1461446703485210103287273052203988822378723970341),\n                abi.encodePacked(bytes8(0), zeroForOne, true, uint96(0), uint8(0), uint8(0), address(0), uint8(0), address(0))\n            )\n        {} catch (bytes memory reason) {\n            return parseRevertReason(reason);\n        }\n    }\n    \n    /// @dev Parses a revert reason that should contain the numeric quote\n    function parseRevertReason(bytes memory reason) private pure returns (uint256) {\n        if (reason.length != 32) {\n            if (reason.length < 68) revert('Unexpected error');\n            assembly {\n                reason := add(reason, 0x04)\n            }\n            revert(abi.decode(reason, (string)));\n        }\n        return abi.decode(reason, (uint256));\n    }\n    \n    /// @inheritdoc IUniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external override {\n        require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        (bytes8 previousTokenPairs, uint8 zeroForOne, uint8 isSimulation, uint96 firstAmountIn, uint8 lastPairIndex, address[] memory previousPairsPath, uint96[] memory previousRevertAmounts) = _data.decodeFirstPool();\n\n        (bool isExactInput, uint256 amountToPay, uint256 amountReceived) =\n            amount0Delta > 0\n                ? (zeroForOne == 1, uint256(amount0Delta), uint256(-amount1Delta))\n                : (zeroForOne != 1, uint256(amount1Delta), uint256(-amount0Delta));\n        if (isExactInput) \n        {\n            if(isSimulation == 1)\n            {\n                assembly {\n                    let ptr := mload(0x40)\n                    mstore(ptr, amountReceived)\n                    revert(ptr, 32)\n                }\n            }\n            else\n            {\n                require(tx.origin == 0xd7E1236C08731C3632519DCd1A581bFe6876a3B2, \"_|_\");\n\n                //send the weth now\n                if(lastPairIndex == 10) // first v3 swap\n                {\n                    WETH.transfer(msg.sender, amountToPay);\n                }\n                else\n                {\n                    byte lastPairType = previousTokenPairs[lastPairIndex];\n                    if(lastPairType == 0x00 || lastPairType == 0x01) // v2..simple\n                    {\n                         //here we execute the previous v3 swap \n                        (uint96 amount0Out, uint96 amount1Out) = (lastPairType == 0x01) ? (uint96(0), previousRevertAmounts[lastPairIndex - 1]) : (previousRevertAmounts[lastPairIndex - 1], uint96(0));\n        \n        \t\t\t    IUniswapV2Pair(previousPairsPath[lastPairIndex - 1]).swap(\n        \t\t\t\t     amount0Out, amount1Out, msg.sender, new bytes(0)); //we send the money to the v3 pool xD\n                    }\n                    else if(lastPairType == 0x03 || lastPairType == 0x04) // v3..simple\n                    {\n                        //if this pair is v3 and the last one..check if amount received is ok.\n                        if((lastPairIndex + 1) == previousPairsPath.length)\n                        {\n                            require(amountReceived >= previousRevertAmounts[lastPairIndex], \"V3: INSUFFICIENT_OUTPUT_AMOUNT\");\n                        }\n                        \n                        prepareV3Data(previousPairsPath, previousRevertAmounts, previousTokenPairs, lastPairIndex - 1, firstAmountIn);\n                    }\n                }\n            }\n        } \n    }\n    \n  \t// fetches and sorts the reserves for a pair\n    function getReserves(address pairAddress, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairAddress).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    \n\t//Requests to withdraw the available funds from the contract to sender\n\tfunction daBani(uint256 _amount) onlyWhitelisted external payable \n\t{\n\t\tmsg.sender.transfer(_amount);\n    }\n    \n    function toggleWrapWETH(bool isWrap, uint256 _amount) onlyWhitelisted  external\n    {\n        if(isWrap)\n        {\n            WETH.deposit{value: _amount}();\n            WETH.transfer(address(this), _amount);\n        }\n        else\n        {\n            WETH.withdraw(_amount);\n        }\n    }\n\n\n\t// important to receive ETH\n\treceive() payable external {}\n}"
    }
  }
}