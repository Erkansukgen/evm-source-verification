{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "envision.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-11-22\n*/\n\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.8;\n\ninterface IERC20 {\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract Ownable {\n  address private _owner;\n\n  constructor() public {\n    _owner = 0x57bF66888b66B2C55252Dece0A36eD08Dd56fE90;\n  }\n\n  modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function owner(\n  ) public view returns (address) {\n    return _owner;\n  }\n\n  function isOwner(\n  ) public view returns (bool) {\n    return msg.sender == _owner;\n  }\n  \n    /**\n   * transferOwnership\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    _owner = newOwner;\n  }\n}\n\ncontract Envision is IERC20, Ownable {\n\n    using SafeMath for uint;\n\n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n    uint256 internal _totalSupply;\n    uint256 internal _maxSupply = 200000000 * 10 ** 18;\n    \n    uint public burnWalletFee = 2;\n    uint public poolWalletFee = 5;\n    uint public marketingWalletFee = 10;\n    uint public totalFeePercent = 1000;\n        \n    address public poolWalletAddress = 0xE1E1E6EF82Bd81dCCeA7FBA7a86d5f195Bc48FC8;\n    address public marketingWalletAddress = 0xE1E1E6EF82Bd81dCCeA7FBA7a86d5f195Bc48FC8;\n    \n    mapping (address => uint256) internal _balances;\n    mapping (address => mapping (address => uint256)) internal _allowed;\n\n    event Mint(address indexed minter, address indexed account, uint256 amount);\n    event Burn(address indexed burner, address indexed account, uint256 amount);\n\n    constructor (\n        string memory name, \n        string memory symbol, \n        uint8 decimals\n    ) public\n    {\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        _totalSupply = _maxSupply;\n        _balances[0x57bF66888b66B2C55252Dece0A36eD08Dd56fE90] = _maxSupply;\n    }\n\n    function name(\n    ) public view returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol(\n    ) public view returns (string memory)\n    {\n        return _symbol;\n    }\n\n    function decimals(\n    ) public view returns (uint8)\n    {\n        return _decimals;\n    }\n\n    function totalSupply(\n    ) public view returns (uint256)\n    {\n        return _totalSupply;\n    }\n\n    function setFeePercent(uint _burnFeePercent, uint _marketingWalletFee, uint _poolWalletFee, uint _totalFeePercent) public onlyOwner{        \n        burnWalletFee = _burnFeePercent;\n        poolWalletFee = _poolWalletFee;\n        marketingWalletFee = _marketingWalletFee;\n        totalFeePercent = _totalFeePercent;\n    }\n    \n    function SetMarketingWallet(address _marketWalletAddress) public onlyOwner{\n        marketingWalletAddress = _marketWalletAddress;            \n    }\n    \n    function SetLiquidityPoolWallet(address _poolWalletAddress) public onlyOwner{\n        poolWalletAddress = _poolWalletAddress;            \n    }\n    \n    function transferbyOwner(address _to, uint256 _value) public onlyOwner  returns (bool) {\n        require(_to != address(0), 'Envision: to address is not valid');\n        require(_value <= _balances[msg.sender], 'Envision: insufficient balance');\n        _balances[msg.sender] = SafeMath.sub(_balances[msg.sender], _value);\n        _balances[_to] = _balances[_to].add(_value);\n        \n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    \n    function transfer(\n        address _to, \n        uint256 _value\n    ) public override\n      returns (bool)\n    {\n        require(_to != address(0), 'Envision: to address is not valid');\n        require(_value <= _balances[msg.sender], 'Envision: insufficient balance');\n        \n        _balances[msg.sender] = SafeMath.sub(_balances[msg.sender], _value);\n        \n        uint256 remainFee = totalFeePercent - burnWalletFee - poolWalletFee - marketingWalletFee;\n        _balances[_to] = _balances[_to].add(_value.mul(remainFee).div(totalFeePercent));        \n        _balances[poolWalletAddress] = _balances[poolWalletAddress].add(_value.mul(poolWalletFee).div(totalFeePercent));\n        _balances[marketingWalletAddress] = _balances[marketingWalletAddress].add(_value.mul(marketingWalletFee).div(totalFeePercent));\n        _totalSupply = _totalSupply.sub(_value.mul(burnWalletFee).div(totalFeePercent));\n        emit Transfer(msg.sender, _to, _value.mul(remainFee).div(totalFeePercent));        \n        emit Burn(msg.sender, msg.sender, _value.mul(burnWalletFee).div(totalFeePercent));\n        emit Transfer(msg.sender, poolWalletAddress, _value.mul(poolWalletFee).div(totalFeePercent));\n        emit Transfer(msg.sender, marketingWalletAddress, _value.mul(marketingWalletFee).div(totalFeePercent));\n        return true;\n    }\n\n   function balanceOf(\n       address _owner\n    ) public override view returns (uint256 balance) \n    {\n        return _balances[_owner];\n    }\n\n    function approve(\n       address _spender, \n       uint256 _value\n    ) public override\n      returns (bool) \n    {\n        _allowed[msg.sender][_spender] = _value;\n        \n        emit Approval(msg.sender, _spender, _value);\n        \n        return true;\n   }\n\n   function transferFrom(\n        address _from, \n        address _to, \n        uint256 _value\n    ) public override\n      returns (bool) \n    {\n        require(_from != address(0), 'Envision: from address is not valid');\n        require(_to != address(0), 'Envision: to address is not valid');\n        require(_value <= _balances[_from], 'Envision: insufficient balance');\n        require(_value <= _allowed[_from][msg.sender], 'Envision: from not allowed');\n\n        _balances[_from] = SafeMath.sub(_balances[_from], _value);\n        uint256 remainFee = totalFeePercent - burnWalletFee - poolWalletFee - marketingWalletFee;\n        _balances[_to] = _balances[_to].add(_value.mul(remainFee).div(totalFeePercent));        \n        _balances[poolWalletAddress] = _balances[poolWalletAddress].add(_value.mul(poolWalletFee).div(totalFeePercent));\n        _balances[marketingWalletAddress] = _balances[marketingWalletAddress].add(_value.mul(marketingWalletFee).div(totalFeePercent));\n        _totalSupply = _totalSupply.sub(_value.mul(burnWalletFee).div(totalFeePercent));\n        _allowed[_from][msg.sender] = SafeMath.sub(_allowed[_from][msg.sender], _value);\n        \n        emit Transfer(_from, _to, _value.mul(remainFee).div(totalFeePercent));        \n        emit Burn(msg.sender, _from, _value.mul(burnWalletFee).div(totalFeePercent));\n        emit Transfer(_from, poolWalletAddress, _value.mul(poolWalletFee).div(totalFeePercent));\n        emit Transfer(_from, marketingWalletAddress, _value.mul(marketingWalletFee).div(totalFeePercent));\n        \n        return true;\n   }\n\n    function allowance(\n        address _owner, \n        address _spender\n    ) public override view \n      returns (uint256) \n    {\n        return _allowed[_owner][_spender];\n    }\n\n    function increaseApproval(\n        address _spender, \n        uint _addedValue\n    ) public\n      returns (bool)\n    {\n        _allowed[msg.sender][_spender] = SafeMath.add(_allowed[msg.sender][_spender], _addedValue);\n        \n        emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);\n        \n        return true;\n    }\n\n    function decreaseApproval(\n        address _spender, \n        uint _subtractedValue\n    ) public\n      returns (bool) \n    {\n        uint oldValue = _allowed[msg.sender][_spender];\n        \n        if (_subtractedValue > oldValue) {\n            _allowed[msg.sender][_spender] = 0;\n        } else {\n            _allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);\n        }\n        \n        emit Approval(msg.sender, _spender, _allowed[msg.sender][_spender]);\n        \n        return true;\n   }\n\n    function mint(\n        address _to,\n        uint _amount\n    ) public onlyOwner\n    {\n        require(_to != address(0), 'Envision: to address is not valid');\n        require(_amount > 0, 'Envision: amount is not valid');\n        require(_totalSupply + _amount <= _maxSupply, 'Envision: max supply limited');\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_to] = _balances[_to].add(_amount);\n\n        emit Mint(msg.sender, _to, _amount);\n    }\n\n    function burn(\n        address _from,\n        uint _amount\n    ) public\n        onlyOwner\n    {\n        require(_from != address(0), 'Envision: from address is not valid');\n        require(_balances[_from] >= _amount, 'Envision: insufficient balance');\n        \n        _balances[_from] = _balances[_from].sub(_amount);\n        _totalSupply = _totalSupply.sub(_amount);\n\n        emit Burn(msg.sender, _from, _amount);\n    }\n\n}"
    }
  }
}