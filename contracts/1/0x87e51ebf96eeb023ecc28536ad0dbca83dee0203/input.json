{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "chfry-mainnet/YearnVaultAdapter.sol": {
      "content": "// Dependency file: @openzeppelin/contracts/math/SafeMath.sol\n\n// SPDX-License-Identifier: MIT\n\n// pragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n// Dependency file: contracts/libraries/FixedPointMath.sol\n\n// pragma solidity >=0.6.5 <0.8.0;\n\n\nlibrary FixedPointMath {\n  uint256 public constant DECIMALS = 18;\n  uint256 public constant SCALAR = 10**DECIMALS;\n\n  struct uq192x64 {\n    uint256 x;\n  }\n\n  function fromU256(uint256 value) internal pure returns (uq192x64 memory) {\n    uint256 x;\n    require(value == 0 || (x = value * SCALAR) / SCALAR == value);\n    return uq192x64(x);\n  }\n\n  function maximumValue() internal pure returns (uq192x64 memory) {\n    return uq192x64(uint256(-1));\n  }\n\n  function add(uq192x64 memory self, uq192x64 memory value) internal pure returns (uq192x64 memory) {\n    uint256 x;\n    require((x = self.x + value.x) >= self.x);\n    return uq192x64(x);\n  }\n\n  function add(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\n    return add(self, fromU256(value));\n  }\n\n  function sub(uq192x64 memory self, uq192x64 memory value) internal pure returns (uq192x64 memory) {\n    uint256 x;\n    require((x = self.x - value.x) <= self.x);\n    return uq192x64(x);\n  }\n\n  function sub(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\n    return sub(self, fromU256(value));\n  }\n\n  function mul(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\n    uint256 x;\n    require(value == 0 || (x = self.x * value) / value == self.x);\n    return uq192x64(x);\n  }\n\n  function div(uq192x64 memory self, uint256 value) internal pure returns (uq192x64 memory) {\n    require(value != 0);\n    return uq192x64(self.x / value);\n  }\n\n  function cmp(uq192x64 memory self, uq192x64 memory value) internal pure returns (int256) {\n    if (self.x < value.x) {\n      return -1;\n    }\n\n    if (self.x > value.x) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  function decode(uq192x64 memory self) internal pure returns (uint256) {\n    return self.x / SCALAR;\n  }\n}\n\n// Dependency file: contracts/libraries/TransferHelper.sol\n\n// pragma solidity >=0.6.5 <0.8.0;\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n\n// Dependency file: contracts/interfaces/IDetailedERC20.sol\n\n// pragma solidity >=0.6.5 <0.8.0;\n\ninterface IDetailedERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\n\n// Dependency file: contracts/interfaces/IVaultAdapter.sol\n\n// pragma solidity >=0.6.5 <0.8.0;\n\n/// Interface for all Vault Adapter implementations.\ninterface IVaultAdapter {\n\n  /// @dev Gets the token that the adapter accepts.\n  function token() external view returns (address);\n\n  /// @dev The total value of the assets deposited into the vault.\n  function totalValue() external view returns (uint256);\n\n  /// @dev Deposits funds into the vault.\n  ///\n  /// @param _amount  the amount of funds to deposit.\n  function deposit(uint256 _amount) external;\n\n  /// @dev Attempts to withdraw funds from the wrapped vault.\n  ///\n  /// The amount withdrawn to the recipient may be less than the amount requested.\n  ///\n  /// @param _recipient the recipient of the funds.\n  /// @param _amount    the amount of funds to withdraw.\n  function withdraw(address _recipient, uint256 _amount) external;\n}\n\n// Dependency file: contracts/interfaces/IyVaultV2.sol\n\n// pragma solidity >=0.6.5 <0.8.0;\n\ninterface IyVaultV2 {\n    function token() external view returns (address);\n    function deposit(uint) external returns (uint);\n    function withdraw(uint, address) external returns (uint);\n    function pricePerShare() external view returns (uint);\n    function decimals() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n}\n\n// Root file: contracts/adapters/YearnVaultAdapter.sol\n\npragma solidity >=0.6.5 <0.8.0;\n\npragma experimental ABIEncoderV2;\n\n\n// import \"/Users/sg99022ml/Downloads/chfry-protocol-internal-feat/node_modules/@openzeppelin/contracts/math/SafeMath.sol\";\n\n// import \"contracts/libraries/FixedPointMath.sol\";\n// import \"contracts/libraries/TransferHelper.sol\";\n// import \"contracts/interfaces/IDetailedERC20.sol\";\n// import \"contracts/interfaces/IVaultAdapter.sol\";\n// import \"contracts/interfaces/IyVaultV2.sol\";\n\n/// @title YearnVaultAdapter\n///\n/// @dev A vault adapter implementation which wraps a yEarn vault.\ncontract YearnVaultAdapter is IVaultAdapter {\n    using FixedPointMath for FixedPointMath.uq192x64;\n    using TransferHelper for address;\n    using SafeMath for uint256;\n\n    /// @dev The vault that the adapter is wrapping.\n    IyVaultV2 public vault;\n\n    /// @dev The address which has admin control over this contract.\n    address public admin;\n\n    /// @dev The decimals of the token.\n    uint256 public decimals;\n\n    constructor(IyVaultV2 _vault, address _admin) public {\n        vault = _vault;\n        admin = _admin;\n        updateApproval();\n        decimals = _vault.decimals();\n    }\n\n    /// @dev A modifier which reverts if the caller is not the admin.\n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"YearnVaultAdapter: only admin\");\n        _;\n    }\n\n    /// @dev Gets the token that the vault accepts.\n    ///\n    /// @return the accepted token.\n    function token() external view override returns (address) {\n        return vault.token();\n    }\n\n    /// @dev Gets the total value of the assets that the adapter holds in the vault.\n    ///\n    /// @return the total assets.\n    function totalValue() external view override returns (uint256) {\n        return _sharesToTokens(vault.balanceOf(address(this)));\n    }\n\n    /// @dev Deposits tokens into the vault.\n    ///\n    /// @param _amount the amount of tokens to deposit into the vault.\n    function deposit(uint256 _amount) external override {\n        vault.deposit(_amount);\n    }\n\n    /// @dev Withdraws tokens from the vault to the recipient.\n    ///\n    /// This function reverts if the caller is not the admin.\n    ///\n    /// @param _recipient the account to withdraw the tokes to.\n    /// @param _amount    the amount of tokens to withdraw.\n    function withdraw(address _recipient, uint256 _amount)\n        external\n        override\n        onlyAdmin\n    {\n        vault.withdraw(_tokensToShares(_amount), _recipient);\n    }\n\n    /// @dev Updates the vaults approval of the token to be the maximum value.\n    function updateApproval() public {\n        address _token = vault.token();\n        _token.safeApprove(address(vault), uint256(-1));\n    }\n\n    /// @dev Computes the number of tokens an amount of shares is worth.\n    ///\n    /// @param _sharesAmount the amount of shares.\n    ///\n    /// @return the number of tokens the shares are worth.\n\n    function _sharesToTokens(uint256 _sharesAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return _sharesAmount.mul(vault.pricePerShare()).div(10**decimals);\n    }\n\n    /// @dev Computes the number of shares an amount of tokens is worth.\n    ///\n    /// @param _tokensAmount the amount of shares.\n    ///\n    /// @return the number of shares the tokens are worth.\n    function _tokensToShares(uint256 _tokensAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        return _tokensAmount.mul(10**decimals).div(vault.pricePerShare());\n    }\n}\n"
    }
  }
}