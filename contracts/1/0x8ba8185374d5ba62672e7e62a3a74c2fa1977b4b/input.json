{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Briber1.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// ============ Interface declarations ============\n\n// CryptoPunks\ninterface CryptoPunks {\n  // Punk id => address\n  function punkIndexToAddress(uint256) external view returns (address);\n}\n\n/**\n * @title Briber\n * @author Anish Agnihotri\n * @dev Checks if all punks provided are owned by an address and pays miner, or reverts\n */\ncontract Briber {\n  // ============ Immutable storage ============\n\n  // Punks contract\n  CryptoPunks punkContract = CryptoPunks(0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB);\n\n  // ============ Functions ============\n\n  /**\n   * @dev Verifies ownership of punks and pays bribe\n   * @dev Param: {address} _owner expected owner of punks\n   * @dev Param: {uint256[]} _punkIds expected punks to have owned\n   */\n  function verifyPunkOwnershipAndPay(\n    address _owner, \n    uint256[] calldata _punkIds\n  ) external payable {\n    // Success starts as true by default\n    bool _success = true;\n\n    for (uint256 i = 0; i < _punkIds.length; i++) {\n      // Verify ownership of each expected punks\n      if (punkContract.punkIndexToAddress(_punkIds[i]) != _owner) {\n        _success = false;\n      }\n    }\n\n    require(_success, \"Briber: Address does not own all punks in array\");\n    (bool sent, ) = payable(block.coinbase).call{value: msg.value}(\"\");\n    require(sent, \"Briber: Unable to bribe miner\");\n  }\n}"}}}