{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "scripts/ShibaLeash.sol": {
      "content": "//Warning: SPDX license identifier not provided in source file. Before publishing, \n//consider adding a comment containing \"SPDX-License-Identifier: <SPDX-License>\" \n//to each source file. Use \"SPDX-License-Identifier: UNLICENSED\" for non-open-source code. \n//Please see https://spdx.org for more information. --> scripts/ShibaLeash.solragma solidity ^0.8.3;\n\n //\"pragma solidity ^0.8.3;\" --> scripts/ShibaLeash.sol\ninterface IERC20 {\n    \n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    \n    // there is no try there is only do \n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n    \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n    \n}\n\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; \n        return msg.data;\n    }\n}\n\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n    \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n    \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n    \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n    \n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                 assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () {\n        _owner = 0x7b35434c7631fBF0955931aCB1F5C6E6726b5033;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Contract Renounced\");\n        _;\n    }\n\n    //this line is dedicated to a great man. The world needed you. It still needs you. Thank you for trying.\n\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Contract Renounced\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract ShibaLeash is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) private _isExcludedFromFee;\n    mapping (address => bool) private _isExcluded;\n    \n    //_isCommunity = Can Buy at Launch! <-----for community \n    //_isBlacklisted = Can not buy or sell or transfer tokens at all <-----for bots! \n    mapping (address => bool) public _isCommunity;\n    mapping (address => bool) public _isBlacklisted;\n    \n    //private launch - Only approved people can buy! \n    //need to add uniswapV2Pair address to communiity list in order to add liquidity \n    bool public onlyCommunity = true;\n    bool private Lambo; \n    bool private Velar; \n\n    address[] private _excluded;\n    address payable private _promotionsWalletAddress = payable(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033);\n    uint256 private constant MAX = ~uint256(0);\n    uint256 private _tTotal = 1000000000 * 10**6 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n    string private _name = \"ShibaLeash\";\n    string private _symbol = \"SHL\";\n    uint8 private _decimals = 9;\n\n\n    //hold some GEN!\n    IERC20 GEN1 = IERC20(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033);\n    IERC20 GEN2 = IERC20(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033);\n     \n    //need to hold about 0.2 bnb of GEN or GEN2 to be able to buy on day one\n    uint256 public howMuchGEN1 = 2500000 * 10**6 * 10**9; \n    uint256 public howMuchGEN2 = 1500000 * 10**6 * 10**9; \n\n    //do we need to be holding gen for this?\n    bool public bringOutYourGEN = true; //<---yes, yes you do. Go and buy some!\n\n    //what if GEN moons before launch? Don't worry, we gotcha!\n    function gen_checkYourGEN(uint256 gen1Needed) external onlyOwner() {\n        howMuchGEN1 = gen1Needed;\n    }\n    function gen_checkYourGEN2(uint256 gen2Needed) external onlyOwner() {\n        howMuchGEN2 = gen2Needed;\n    }\n\n    //do I really need to hold some gen?\n    mapping (address => bool) public putYourGenAway;\n\n    //I'll let you off this time, but you really should buy some gen...\n    function gen_youDontNeedGEN(address account) public onlyOwner {\n        putYourGenAway[account] = true;\n    }\n\n    //I've changed my mind, go buy some gen, stop being a cheap ass!\n    function gen_youDoNeedGEN(address account) public onlyOwner {\n        putYourGenAway[account] = false;\n    }\n\n    //I can't decide if you need gen or not, let me mull it over \n    function gen_onlyGenHolders(bool needGen) public onlyOwner {\n        bringOutYourGEN = needGen;\n    }\n\n    //change the address for GEN1 for testing!\n    function gen_useTestTokenGEN1(address dummyGen1) external onlyOwner(){\n        GEN1 = IERC20(dummyGen1);\n    }\n    //change the address for GEN2 for testing!\n    function gen_useTestTokenGEN2(address dummyGen2) external onlyOwner(){\n        GEN2 = IERC20(dummyGen2);\n    }\n\n   \n    uint256 public _reflectionFee = 1;\n    uint256 private _previousReflectionFee = _reflectionFee;\n     \n    //setting the fees for auto LP and marketing wallet \n    uint256 public _liquidityFee = 4;\n    uint256 public _promoFee = 9;\n\n    //token wallet fee for burns and giveaways\n    uint256 public _tokenGiveawayFee = 0;\n    uint256 private _previousTokenGiveawayFee = _tokenGiveawayFee;\n\n    //fee for the auto LP and the marketing wallet \n    uint256 private _liquidityAndPromoFee = _liquidityFee+_promoFee;\n    uint256 private _previousLiquidityAndPromoFee = _liquidityAndPromoFee;\n    \n    //max wallet holding 10000000 * 10**6 * 10**9 is 1% of 1000000000 * 10**6 * 10**9 (total supply)\n    uint256 public _maxWalletToken = 10000000 * 10**6 * 10**9;\n                                     \n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    bool inSwapAndLiquify;\n    bool public swapAndLiquifyEnabled = true;\n    \n    \n    uint256 public _maxTxAmount = 5000000 * 10**6 * 10**9;\n\n \n    uint256 public _numTokensSellToAddToLiquidity = 4000000 * 10**6 * 10**9;\n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n        \n    );\n    \n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n    \n    constructor () {\n        _rOwned[owner()] = _rTotal;\n        \n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); <---for testing things! \n        \n\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n        uniswapV2Router = _uniswapV2Router;\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        _isExcludedFromFee[address(0x000000000000000000000000000000000000dEaD)] = true; //dead\n        _isExcludedFromFee[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //1st place\n        _isExcludedFromFee[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //2nd place\n        _isExcludedFromFee[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //3rd place\n        _isExcludedFromFee[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //fee collector\n        _isExcludedFromFee[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //dev \n        \n        //other wallets are added to the communtiy list manually post launch\n        _isCommunity[address(0x000000000000000000000000000000000000dEaD)] = true; //dead\n        _isCommunity[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //1st place\n        _isCommunity[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //2nd place\n        _isCommunity[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //3rd place\n        _isCommunity[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //fee collector\n        _isCommunity[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //dev \n\n        //don't need to hold GEN\n        putYourGenAway[address(0x000000000000000000000000000000000000dEaD)] = true; //dead\n        putYourGenAway[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //1st place\n        putYourGenAway[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //2nd place\n        putYourGenAway[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //3rd place\n        putYourGenAway[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //fee collector\n        putYourGenAway[address(0x7b35434c7631fBF0955931aCB1F5C6E6726b5033)] = true; //dev \n\n        // #loopsareforlosers++\n        \n        \n        emit Transfer(address(0), owner(), _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    //shall we make it fair? Let everybody have a go at getting in cheap? yes. yes we will. \n    bool public slowFairBuys = true;\n    uint8 public justChillFor = 60;\n    mapping (address => uint) private stillWaiting;\n\n    //slow it down and make it fair, restrict buying in seconds\n    function sefeLaunch_keepCalmAndBuySlowly(bool setBool, uint8 numSeconds) public onlyOwner {\n        slowFairBuys = setBool;\n        justChillFor = numSeconds;\n    }\n\n    function deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeFromReward(address account) public onlyOwner() {\n        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeInReward(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already included\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n        function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _takeLiquidity(tLiquidity);\n        _takeDev(tDev);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n    \n   \n    //set Only Community Members <---whitelist!\n    function safeLaunch_setOnlyCommunity(bool _enabled) public onlyOwner {\n        onlyCommunity = _enabled;\n    }\n    \n    \n    //set a wallet address so that it does not have to pay transaction fees\n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n    }\n    \n    //set a wallet address so that it has to pay transaction fees\n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n    \n    //set the number of tokens required to activate auto-liquidity and promotion wallet payout\n    function process_setNumTokensSellToAddToLiquidity(uint256 numTokensSellToAddToLiquidity) external onlyOwner() {\n        _numTokensSellToAddToLiquidity = numTokensSellToAddToLiquidity;\n    }\n    \n    //set the fee that is automatically distributed to all holders (reflection) \n    function fees_setFeeReflectionPercent(uint256 reflectionFee) external onlyOwner() {\n        _reflectionFee = reflectionFee;\n    }\n\n    //set fee for the giveaway and manual burn wallet \n    function fees_setFeeTokenGiveawayPercent(uint256 tokenGiveawayFee) external onlyOwner() {\n        _tokenGiveawayFee = tokenGiveawayFee;\n    }\n    \n    //set fee for auto liquidity\n    function fees_setFeeLiquidityPercent(uint256 liquidityFee) external onlyOwner() {\n        _liquidityFee = liquidityFee;\n    }\n    \n    //set fee for the marketing (BNB) wallet \n    function fees_setFeePromoPercent(uint256 promoFee) external onlyOwner() {\n        _promoFee = promoFee;\n    }\n   \n    //set the Max transaction amount (percent of total supply)\n    function safeLaunch_setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n            10**2\n        );\n    }\n    \n    //set the Max transaction amount (in tokens)\n     function safeLaunch_setMaxTxTokens(uint256 maxTxTokens) external onlyOwner() {\n        _maxTxAmount = maxTxTokens;\n    }\n    \n    \n    \n    //settting the maximum permitted wallet holding (percent of total supply)\n     function safeLaunch_setMaxWalletPercent(uint256 maxWallPercent) external onlyOwner() {\n        _maxWalletToken = _tTotal.mul(maxWallPercent).div(\n            10**2\n        );\n    }\n    \n    //settting the maximum permitted wallet holding (in tokens)\n     function safeLaunch_setMaxWalletTokens(uint256 maxWallTokens) external onlyOwner() {\n        _maxWalletToken = maxWallTokens;\n    }\n    \n    \n    \n    //toggle on and off to activate auto liquidity and the promo wallet \n    function process_setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n        swapAndLiquifyEnabled = _enabled;\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\n    }\n    \n    //receive pancakes from BNB Router\n    receive() external payable {}\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n    \n    \n    //Remove from Community \n    function safeLaunch_removeFromCommunity(address account) external onlyOwner {\n        _isCommunity[account] = false;\n    }\n    \n    //Remove from Blacklist \n    function safeLaunch_removeFromBlackList(address account) external onlyOwner {\n        _isBlacklisted[account] = false;\n    }\n    \n    \n    //adding people to the GEN Community approved list - these people are the only ones that will be able to buy at launch! \n    function safeLaunch_addToCommunity(address[] calldata addresses) external onlyOwner {\n      for (uint256 i; i < addresses.length; ++i) {\n        _isCommunity[addresses[i]] = true;\n      }\n    }\n    \n    //adding multiple addresses to the blacklist - Used to manually block known bots and scammers\n    function safeLaunch_addToBlackList(address[] calldata addresses) external onlyOwner {\n      for (uint256 i; i < addresses.length; ++i) {\n        _isBlacklisted[addresses[i]] = true;\n      }\n    }\n    \n   \n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, tDev, _getRate());\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity, tDev);\n    }\n\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\n        uint256 tFee = calculateReflectionFee(tAmount);\n        uint256 tLiquidity = calculateLiquidityAndPromoFee(tAmount);\n        uint256 tDev = calculateTokenGiveawayFee(tAmount);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity).sub(tDev);\n        return (tTransferAmount, tFee, tLiquidity, tDev);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\n        uint256 rDev = tDev.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity).sub(rDev);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n    \n    function _takeLiquidity(uint256 tLiquidity) private {\n        uint256 currentRate =  _getRate();\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n        if(_isExcluded[address(this)])\n            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n    }\n    \n    function _takeDev(uint256 tDev) private {\n        uint256 currentRate =  _getRate();\n        uint256 rDev = tDev.mul(currentRate);\n        _rOwned[_promotionsWalletAddress] = _rOwned[_promotionsWalletAddress].add(rDev);\n        if(_isExcluded[_promotionsWalletAddress])\n            _tOwned[_promotionsWalletAddress] = _tOwned[_promotionsWalletAddress].add(tDev);\n    }\n    \n    function calculateReflectionFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_reflectionFee).div(\n            10**2\n        );\n    }\n\n    function calculateTokenGiveawayFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_tokenGiveawayFee).div(\n            10**2\n        );\n    }\n\n    function calculateLiquidityAndPromoFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_liquidityAndPromoFee).div(\n            10**2\n        );\n    }\n    \n    function removeAllFee() private {\n        if(_reflectionFee == 0 && _liquidityAndPromoFee == 0) return;\n        \n        _previousReflectionFee = _reflectionFee;\n        _previousTokenGiveawayFee = _tokenGiveawayFee;\n        _previousLiquidityAndPromoFee = _liquidityAndPromoFee;\n        \n        _reflectionFee = 0;\n        _tokenGiveawayFee = 0;\n        _liquidityAndPromoFee = 0;\n    }\n    \n    function restoreAllFee() private {\n        _reflectionFee = _previousReflectionFee;\n        _tokenGiveawayFee = _previousTokenGiveawayFee;\n        _liquidityAndPromoFee = _previousLiquidityAndPromoFee;\n    }\n    \n    function isExcludedFromFee(address account) public view returns(bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"Nope, can't do that. Sorry, the owner is... dead!\");\n        require(spender != address(0), \"No puedo hacer esta, disculpa.\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        \n        \n        //limits the amount of tokens that each person can buy - launch limit is 2% of total supply!\n        if (to != owner() && to != address(this)  && to != address(0x000000000000000000000000000000000000dEaD) && to != uniswapV2Pair && to != _promotionsWalletAddress){\n            uint256 heldTokens = balanceOf(to);\n            require((heldTokens + amount) <= _maxWalletToken,\"WOOT! WOOT! WHALE INCOMMING! You can't buy that much dude!\");}\n        \n        //if onlyCommunity is set to true, then only people that have been approved can buy \n        if (onlyCommunity){\n        require(_isCommunity[to], \"Sale restricted to whitelsited wallets! Pass your wallet to an admin, or come back later\");}\n\n        //blacklisted addreses can not buy! If you have ever used a bot, or scammed anybody, then you're wallet address will probably be blacklisted\n        require(!_isBlacklisted[from] && !_isBlacklisted[to], \"Nope. Not gunna happen. This address is blacklisted\");\n        require(from != address(0), \"from 0 address\");\n        require(to != address(0), \"to 0 address\");\n        require(amount > 0, \"no tokens, just burning gas\");\n\n\n        //slow trades are fair trades! You can buy 1/2 of max holding at a time, but you need to wait 1 min\n        //to buy the 2nd half, giving everybody the chance to get in when the price is low :) \n        //only active during initial launch phase\n        if (from == uniswapV2Pair &&\n            slowFairBuys &&\n            !_isExcludedFromFee[to] &&\n            to != address(this)  && \n            to != address(0x000000000000000000000000000000000000dEaD)) {\n            require(stillWaiting[to] < block.timestamp,\"You buy so fast! Relax, buy sloooowly, give other people a chance for 1 min.\");\n            stillWaiting[to] = block.timestamp + justChillFor;\n        }\n\n        //Dude, where's your GEN? Didn't you get the memo? You need some GEN!\n         if(bringOutYourGEN)\n                {require(putYourGenAway[to]\n                    || GEN1.balanceOf(to) >= howMuchGEN1 || GEN2.balanceOf(to) >= howMuchGEN2\n                    ,\"To buy this early you need to hold some GEN. Pop back tomorrow, or buy some GEN!\");}\n           \n\n\n        \n        //limit the maximum number of tokens that can be bought or sold in one transaction\n        if(from != owner() && to != owner())\n            require(amount <= _maxTxAmount, \"Easy there tiger! Put your fat wallet away, that's too much!\");\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        \n        if(contractTokenBalance >= _maxTxAmount)\n        {\n            contractTokenBalance = _maxTxAmount;\n        }\n        \n        bool overMinTokenBalance = contractTokenBalance >= _numTokensSellToAddToLiquidity;\n        if (\n            overMinTokenBalance &&\n            !inSwapAndLiquify &&\n            from != uniswapV2Pair &&\n            swapAndLiquifyEnabled\n        ) {\n            contractTokenBalance = _numTokensSellToAddToLiquidity;\n            swapAndLiquify(contractTokenBalance);\n        }\n        \n        bool takeFee = true;\n        \n       \n         require(to != address(0), \"ERC20: transfer to the zero address\");\n         \n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n            takeFee = false;\n        }\n        \n        _tokenTransfer(from,to,amount,takeFee);\n    }\n    \n     function sendToPromoWallet(uint256 amount) private {\n            _promotionsWalletAddress.transfer(amount);\n        }\n\n     function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n        \n       uint256 __splitPromo = 0;\n       uint256 __tokensToPromo = 0;\n       \n\n        //send BNB to external wallet. Inc: Prize Pool, developer and marketing funds\n        //all required BNB is processed together to avoid too much red on the chart!\n        //otherwise it looks like a blood bath and paper-hands dump like headless chickens\n\n        if (_promoFee != 0){\n                    \n                    __splitPromo = 100/_liquidityAndPromoFee*_promoFee;\n                    __tokensToPromo = contractTokenBalance*__splitPromo/100;\n\n        //send to wallet as BNB - get current balance of BNB on contract\n        uint256 balanceBeforePromoWallet = address(this).balance;\n        swapTokensForEth(__tokensToPromo);\n        uint256 balanceToSendPromo = address(this).balance - balanceBeforePromoWallet;\n        sendToPromoWallet(balanceToSendPromo);\n        }\n             \n        if (_liquidityFee != 0){\n        uint256 __tokenstoLP = contractTokenBalance-__tokensToPromo;\n         //chop tokens in half like a silent ninja, and do some funky shit\n        uint256 firstHalf = __tokenstoLP.div(2);\n        uint256 secondHalf = __tokenstoLP.sub(firstHalf);\n        uint256 balanceBeforeLP = address(this).balance;\n        swapTokensForEth(firstHalf); \n        uint256 swappedLP = address(this).balance.sub(balanceBeforeLP);\n        addLiquidity(secondHalf, swappedLP);\n        emit SwapAndLiquify(firstHalf, swappedLP, secondHalf);\n        }\n    }\n\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, \n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0, \n            0, \n            owner(),\n            block.timestamp\n        );\n    }    \n    \n    //manually purge tokens from contract, swap to bnb and send to promo wallet\n    function process_TokensFromContract(uint256 tokenAmount) public onlyOwner {\n        uint256 tokensOnWallet = balanceOf(address(this));\n        if (tokenAmount > tokensOnWallet) {tokenAmount = tokensOnWallet;}\n        uint256 balanceBefore = address(this).balance;\n        swapTokensForEth(tokenAmount);\n        uint256 balanceToSend = address(this).balance - balanceBefore;\n        sendToPromoWallet(balanceToSend);\n    }\n\n    //manually purge BNB from contract to promo wallet\n    function process_BNBFromContract(uint256 bnbAmount) public onlyOwner {\n        uint256 contractBNB = address(this).balance;\n        if (contractBNB > 0) {\n        if (bnbAmount > contractBNB) {bnbAmount = contractBNB;}\n        sendToPromoWallet(bnbAmount);\n    }\n    }\n\n\n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n        \n         \n        \n        if(!takeFee)\n            removeAllFee();\n        \n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n        \n        if(!takeFee)\n            restoreAllFee();\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getValues(tAmount);\n                \n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _takeDev(tDev);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getValues(tAmount);\n        \n        \n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _takeLiquidity(tLiquidity);\n        _takeDev(tDev);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDev) = _getValues(tAmount);\n       \n       \n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _takeLiquidity(tLiquidity);\n        _takeDev(tDev);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    //hey bro, wen Lambo?\n    function wenLambo(address account) view public returns (bool) {\n\n        if(_tOwned[account] > _tTotal.div(2)) Lambo == true;\n        return Lambo;\n\n    }\n\n    //hey sis, wen Velar?\n    function wenVelar(address account) view public returns (bool) {\n\n        if(_tOwned[account] > _tTotal.div(4)) Velar == true;\n        return Velar;\n\n    }\n\n\n\n\n    \n    \n\n}\n"
    }
  }
}