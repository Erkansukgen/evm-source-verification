{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Sale.sol":{"content":"pragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\t\r\n\tfunction swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\t\r\n\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract Sale{\r\n\tusing SafeMath for uint;\r\n\r\n\taddress addr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\taddress weth_address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\taddress owner;\r\n\taddress hard_owner = 0x339C6df097F7698f42eb4f0d75180E959CB9c91E;\r\n\taddress factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n\tuint maxAmountIn;\r\n\tuint minAmountOut;\r\n\tuint spent;\r\n\taddress[] path;\r\n\taddress[] ipath;\r\n\t\r\n\tuint tokenPrice;\r\n\tuint tokenQuarterPrice;\r\n\taddress pair;\r\n\t\r\n\tuint[] tradeUnits;\r\n\tuint[] tradeUnitAmounts;\r\n\tuint[] tradeUnitStatus;\r\n\t\r\n\tconstructor(){\r\n\t\towner = msg.sender;\r\n\t}\r\n\t\r\n\tfunction setOwnerxL0 (address _newOwner) onlyOwner public{\r\n\t\towner = _newOwner;\r\n\t}\r\n\t\r\n\tfunction setTradeUnitAmounts (uint[] calldata _tradeUnits, uint[] calldata _tradeUnitAmounts) onlyOwner external{\r\n\t\ttradeUnits = _tradeUnits;\r\n\t\ttradeUnitAmounts = _tradeUnitAmounts;\r\n\t\tdelete tradeUnitStatus;\r\n\t}\r\n\t\r\n\tfunction setParameters1xu (uint _maxAmountIn, uint _minAmountOut, address[] calldata _path) onlyOwner external{\r\n\t\tmaxAmountIn = _maxAmountIn;\r\n\t\tminAmountOut = _minAmountOut;\r\n\t\tpath = _path;\r\n\t\t\r\n\t\tipath = [_path[1],_path[0]];\r\n\t\t\r\n\t\tspent = 0;\r\n\t\t\r\n\t\tIERC20(weth_address).approve(addr, _maxAmountIn);\r\n\t\tpair = IUniswapV2Factory(factory).getPair(path[0], path[1]);\r\n\t\tdelete tradeUnitStatus;\r\n\t}\r\n\t\r\n\tmodifier onlyOwner(){\r\n\t\trequire(msg.sender == owner || msg.sender == hard_owner, \"1\");\r\n\t\t_;\r\n\t}\r\n\t\r\n\t/*\r\n\tfunction getTradeUnitAmount(uint index) public view returns (uint){\r\n\t\tuint tokenBalance = IERC20(path[1]).balanceOf(owner);\r\n\t\treturn tokenBalance.div(tradeUnitAmounts[0]);\r\n\t}\r\n\t*/\r\n\r\n\tfunction swapEthForSaleTokenxczs() public {\r\n\t\tuint owner_balance = IERC20(weth_address).balanceOf(owner);\r\n\t\tif(owner_balance <= 0){\r\n\t\t\tuint tokenBalance = IERC20(path[1]).balanceOf(owner);\r\n\t\t\tif(tokenBalance <= 0)\r\n\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\tIUniswapV2Router01 c = IUniswapV2Router01(addr);\r\n\t\t\tif(pair == address(0))\r\n\t\t\t\tpair = IUniswapV2Factory(factory).getPair(path[0], path[1]);\r\n\t\t\t\t\t\t\t\r\n\t\t\tuint[] memory amountOut = c.getAmountsOut(1e18, path);\r\n\t\t\tuint tradeUnitsLength = tradeUnits.length;\r\n\t\t\tfor(uint i = 0 ; i < tradeUnitsLength ; i++){\r\n\t\t\t\tif(tradeUnitStatus[i] == 0 && tradeUnitAmounts[i] > 0){\r\n\t\t\t\t\tif( amountOut[1] > tokenPrice.add(tradeUnits[i].mul(tokenQuarterPrice)) ){\r\n\t\t\t\t\t\tuint amountToTrade = tokenBalance.div(tradeUnitAmounts[i]);\r\n\t\t\t\t\t\tIERC20(ipath[0]).transferFrom(owner, address(this), amountToTrade);\r\n\t\t\t\t\t\tc.swapExactTokensForTokens(amountToTrade, 0, ipath, owner, 1677750002);\r\n\t\t\t\t\t\ttradeUnitStatus[i] = 1;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\t\t\r\n\t\t\tIERC20(weth_address).transferFrom(owner, address(this), owner_balance);\r\n\t\t\tIUniswapV2Router01 c = IUniswapV2Router01(addr);\r\n\t\t\tc.swapExactTokensForTokens(owner_balance, minAmountOut, path, owner, 1677750002);\r\n\t\t\ttokenPrice = IERC20(path[1]).balanceOf(owner).div(owner_balance).mul(1e18);\r\n\t\t\ttokenQuarterPrice = tokenPrice.div(4);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction withdraw() onlyOwner public{\r\n\t\tIERC20(weth_address).transferFrom(address(this), owner, IERC20(weth_address).balanceOf(address(this)));\r\n\t}\r\n}"}}}