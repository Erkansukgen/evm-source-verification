{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"OpenOraclePriceData.sol":{"content":"// File: contracts/OpenOracleData.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.6.10;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title The Open Oracle Data Base Contract\r\n * @author Compound Labs, Inc.\r\n */\r\ncontract OpenOracleData {\r\n    /**\r\n     * @notice The event emitted when a source writes to its storage\r\n     */\r\n    //event Write(address indexed source, <Key> indexed key, string kind, uint64 timestamp, <Value> value);\r\n\r\n    /**\r\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\r\n     * @param message The payload containing the timestamp, and (key, value) pairs\r\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\r\n     * @return The keys that were written\r\n     */\r\n    //function put(bytes calldata message, bytes calldata signature) external returns (<Key> memory);\r\n\r\n    /**\r\n     * @notice Read a single key with a pre-defined type signature from an authenticated source\r\n     * @param source The verifiable author of the data\r\n     * @param key The selector for the value to return\r\n     * @return The claimed Unix timestamp for the data and the encoded value (defaults to (0, 0x))\r\n     */\r\n    //function get(address source, <Key> key) external view returns (uint, <Value>);\r\n\r\n    /**\r\n     * @notice Recovers the source address which signed a message\r\n     * @dev Comparing to a claimed address would add nothing,\r\n     *  as the caller could simply perform the recover and claim that address.\r\n     * @param message The data that was presumably signed\r\n     * @param signature The fingerprint of the data + private key\r\n     * @return The source address which signed the message, presumably\r\n     */\r\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\r\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n}\r\n\r\n// File: contracts/OpenOraclePriceData.sol\r\n\r\npragma solidity ^0.6.10;\r\n\r\n\r\n/**\r\n * @title The Open Oracle Price Data Contract\r\n * @notice Values stored in this contract should represent a USD price with 6 decimals precision\r\n * @author Compound Labs, Inc.\r\n */\r\ncontract OpenOraclePriceData is OpenOracleData {\r\n    ///@notice The event emitted when a source writes to its storage\r\n    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\r\n    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\r\n    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\r\n\r\n    ///@notice The fundamental unit of storage for a reporter source\r\n    struct Datum {\r\n        uint64 timestamp;\r\n        uint64 value;\r\n    }\r\n\r\n    /**\r\n     * @dev The most recent authenticated data from all sources.\r\n     *  This is private because dynamic mapping keys preclude auto-generated getters.\r\n     */\r\n    mapping(address => mapping(string => Datum)) private data;\r\n\r\n    /**\r\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\r\n     * @param message The payload containing the timestamp, and (key, value) pairs\r\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\r\n     * @return The keys that were written\r\n     */\r\n    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\r\n        (address source, uint64 timestamp, string memory key, uint64 value) = decodeMessage(message, signature);\r\n        return putInternal(source, timestamp, key, value);\r\n    }\r\n\r\n    function putInternal(address source, uint64 timestamp, string memory key, uint64 value) internal returns (string memory) {\r\n        // Only update if newer than stored, according to source\r\n        Datum storage prior = data[source][key];\r\n        if (timestamp > prior.timestamp && timestamp < block.timestamp + 60 minutes && source != address(0)) {\r\n            data[source][key] = Datum(timestamp, value);\r\n            emit Write(source, key, timestamp, value);\r\n        } else {\r\n            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    function decodeMessage(bytes calldata message, bytes calldata signature) internal pure returns (address, uint64, string memory, uint64) {\r\n        // Recover the source address\r\n        address source = source(message, signature);\r\n\r\n        // Decode the message and check the kind\r\n        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\r\n        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked(\"prices\")), \"Kind of data must be 'prices'\");\r\n        return (source, timestamp, key, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Read a single key from an authenticated source\r\n     * @param source The verifiable author of the data\r\n     * @param key The selector for the value to return\r\n     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\r\n     */\r\n    function get(address source, string calldata key) external view returns (uint64, uint64) {\r\n        Datum storage datum = data[source][key];\r\n        return (datum.timestamp, datum.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Read only the value for a single key from an authenticated source\r\n     * @param source The verifiable author of the data\r\n     * @param key The selector for the value to return\r\n     * @return The price value (defaults to 0)\r\n     */\r\n    function getPrice(address source, string calldata key) external view returns (uint64) {\r\n        return data[source][key].value;\r\n    }\r\n}"}}}