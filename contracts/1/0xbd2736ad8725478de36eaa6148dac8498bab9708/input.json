{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity = 0.8.4;\n\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n  \n}"
    },
    "contracts/synliq.sol": {
      "content": "pragma solidity = 0.8.4;\npragma experimental ABIEncoderV2;\n\nimport './lib/SafeMath.sol';\n\n\ninterface IWETH {\n    function withdraw(uint) external;\n}\n\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n\ninterface chitoken {\n  function freeUpTo(uint256 value) external returns (uint256 freed);\n}\n\ninterface synthetix{\n    function liquidateDelinquentAccount(address account, uint susdAmount)\n        external\n        returns (bool);\n}\n\ninterface IUniswapV2Pair{\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\ninterface sUSDv2{\n  function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\n}\n\n\n\ncontract synliqsnx {\n  using SafeMath for uint;\n\n  \n  address payable public owner;\n\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n  \n\n  // main net\n\n  address constant wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n  address sUSD = address(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\n  address USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n  address SNX = address(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\n\n  address curve_sUSDpooladdr = address(0xA5407eAE9Ba41422680e2e00537571bcC53efBfD);\n  address susd_eth_pool = address(0xF1F85b2C54a2bD284B1cf4141D64fD171Bd85539);\n  //address snx_eth_pool = address(0xF1F85b2C54a2bD284B1cf4141D64fD171Bd85539);\n  address[] snx_sell_path = [address(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F), address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)];\n  address[] snx_sell_pools = [address(0xA1d7b2d891e3A1f9ef4bBC5be20630C2FEB1c470), address(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0)];\n  \n  IWETH private constant WETH = IWETH(wethaddr);\n  synthetix syncontract = synthetix(address(0x97767D7D04Fd0dB0A1a2478DCd4BA85290556B48));\n  sUSDv2 curve_susdpool = sUSDv2(curve_sUSDpooladdr);\n  // chi\n  chitoken chi = chitoken(address(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c));\n\n  constructor() public {\n    owner = payable(msg.sender);\n\n    // let the curve susd v2 contract take our USDC\n    IERC20(USDC).approve(\n                curve_sUSDpooladdr,\n                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n              );   \n\n  }\n\n\n  modifier onlyowner{\n    require(msg.sender == owner);\n    _;\n  }\n\n    modifier discountCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        chi.freeUpTo((gasSpent + 14154) / 41947);\n    }\n\n\n\n  receive() external payable {}\n\n\n  function deposit() payable external{\n  }\n\n\n  function _safeTransfer(address token, address to, uint value) private {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n  }\n\n  function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n    _safeTransfer(tokenaddr, owner, amount);\n  }\n\n  function withdrawtokenall(address tokenaddr) external onlyowner{\n    _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n  }\n\n  function withdrawethall() external onlyowner {\n    payable(msg.sender).transfer(address(this).balance);\n  }\n\n  function withdrawethamount(uint amount) external onlyowner {\n    payable(msg.sender).transfer(amount);\n  }\n\n\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n\n\n    // sell the snx with predefined sell path\n    function sell_snx() private {\n        \n        uint256 amountin = IERC20(SNX).balanceOf(address(this));\n\n        bool first;\n        uint reserve0;\n        uint reserve1;\n        uint reserveInput;\n        uint reserveOutput;\n        bytes memory returnData;\n        \n        IERC20(SNX).transfer(snx_sell_pools[0], amountin);\n        for(uint i; i < snx_sell_pools.length; i++){\n            (, returnData) = snx_sell_pools[i].staticcall(abi.encodeWithSelector(0x0902f1ac));\n            (reserve0, reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n            first = snx_sell_path[i] < snx_sell_path[i+1];\n            (reserveInput, reserveOutput) = (first) ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n            amountin = getAmountOut(amountin, reserveInput, reserveOutput);\n        \n            // use reserveinput and output here to save some gas\n            (reserveInput, reserveOutput) = (first) ? (uint(0),amountin) : (amountin,uint(0));  \n            address recipient = i < snx_sell_pools.length - 1? snx_sell_pools[i+1] : address(this); \n            snx_sell_pools[i].call(abi.encodeWithSelector(0x022c0d9f, reserveInput, reserveOutput, recipient, new bytes(0)));\n            \n        }\n        \n        \n    }\n\n    // sell the susd amount and pay the tips to miner\n    function paytips(uint256 amount) private {\n        bytes memory returnData;\n        uint reserve0;\n        uint reserve1;\n        uint256 amountout;\n        \n        (, returnData) = susd_eth_pool.staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (reserve0, reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n        amountout = getAmountOut(amount, reserve0, reserve1);\n        IERC20(sUSD).transfer(susd_eth_pool, amount);\n        \n        susd_eth_pool.call(abi.encodeWithSelector(0x022c0d9f, 0, amountout, address(this), new bytes(0)));\n        \n        WETH.withdraw(amountout);\n        block.coinbase.call{value:amountout}(new bytes(0));\n    }\n\n\n\n\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\n        // access control\n        require(msg.sender == susd_eth_pool, \"only permissioned UniswapV2 pair can call\");\n        require(_sender == address(this), \"only this contract may initiate\");\n\n\n        (address _account ,uint256 _amount) = abi.decode(_data, (address, uint256));\n        uint fee = ((_amount * 3) / 997) + 1;\n        uint amountToRepay = _amount + fee;\n\n        // liq the account and get the snx\n        syncontract.liquidateDelinquentAccount(_account, _amount);\n        \n        // swap snx -> eth -> usdc\n        sell_snx();\n        \n        // sell usdc to susd on curve\n        \n        uint256 usdc_balance = IERC20(USDC).balanceOf(address(this));\n       // swap from usdc to sUSD on curve\n       curve_susdpool.exchange(1,3, usdc_balance,0);        \n\n        // repay the susd\n        IERC20(sUSD).transfer(susd_eth_pool, amountToRepay);\n\n    }\n    \n    \n    \n    function flashliqsnx(address account, uint susdAmount, uint percent) public discountCHI{\n        \n        uint256 balance_before = IERC20(sUSD).balanceOf(address(this));\n        \n        // the susdAmount is the amount we are going to loan out\n        // in susd_eth_pool, susd is token0\n        \n        uint amount0Out = susdAmount;\n\n        bytes memory data = abi.encode(account, susdAmount);        \n        \n        IUniswapV2Pair(susd_eth_pool).swap(amount0Out, 0, address(this), data);\n        \n        uint256 balance_after = IERC20(sUSD).balanceOf(address(this));\n        require(balance_after > balance_before, \"no profit\");\n        \n        // pay the tips, swap susd to eth\n        uint256 tip_susd = (balance_after - balance_before) * percent / 100;\n        \n        paytips(tip_susd);\n        \n        \n        uint256 balance_final = IERC20(sUSD).balanceOf(address(this));\n        require(balance_final > balance_before, \"no profit2\");\n    }\n\n\n    \n}"
    }
  }
}