{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/TankBaseGene.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Fortress Arena Tank Base Gene Contract\n * @author Atomrigs Lab \n */\n\ncontract TankBaseGene is Ownable {\n\n    address public _tankNft;\n\n    string[] private races = [\n        \"carrot\",       //0\n        \"cannon\",       //1\n        \"poseidon\",     //2\n        \"crossbow\",     //3\n        \"catapult\",     //4\n        \"ionattacker\",  //5\n        \"multi\",        //6\n        \"missile\",      //7\n        \"minelander\",   //8\n        \"secwind\",      //9\n        \"laser\",        //10\n        \"duke\",         //11\n        \"ironhammer\",   //12\n        \"walkietalkie\", //13\n        \"rainbowshell\", //14\n        \"windblow\",     //15\n        \"dragoncannon\", //16\n        \"solartank\",    //17\n        \"blazer\",       //18\n        \"overcharger\"   //19\n    ];\n\n    string[] private colors = [\n        \"blue\",     //0\n        \"red\",      //1\n        \"green\",    //2\n        \"brown\",    //3\n        \"yellow\",   //4\n        \"purple\"    //5\n    ];\n\n    string[] private materials = [\n        \"steel\", //0\n        \"wood\",  //1\n        \"radios\" //2\n    ];\n\n    string[] private classes = [\n        \"normal\",   //0\n        \"superior\", //1\n        \"rare\",     //2\n        \"epic\",     //3\n        \"legendary\"    //4\n    ];\n\n    string[] private elements = [\n        \"fire\",     //0\n        \"wind\",     //1\n        \"earth\",    //2\n        \"water\",    //3\n        \"light\",    //4\n        \"dark\"      //5\n    ];\n\n    string[] private generations = [\n        \"generation-0\",\n        \"generation-1\"\n    ];\n\n    string[] private founderTanks = [\n        \"founder-tank\",\n        \"regular-tank\"\n    ];\n\n    modifier onlyNftOrOwner() {\n        require(_msgSender() == _tankNft || _msgSender() == owner(), \"TankGene: caller is not the NFT tank contract address\");\n        _;\n    }\n\n    constructor(address _tankNftAddr) {\n        _tankNft = _tankNftAddr;\n    }    \n\n    function tankNft() external view returns (address) {\n        return _tankNft;\n    }\n\n    function setTankNft(address _nftAddr) external onlyOwner {\n        _tankNft = _nftAddr;\n    }\n\n    function getSeed(uint _tokenId) public view onlyNftOrOwner returns (uint) {\n        return uint256(keccak256(abi.encodePacked(_tokenId, uint(2021))));\n    }\n\n    function getBaseGenes(uint _tokenId) public view onlyNftOrOwner returns (uint[] memory) {\n        uint[] memory genes = new uint[](7);\n        if (_tokenId > 0 && _tokenId <= 120) {\n            genes[0] = (_tokenId-1) % 20;\n            genes[1] = colors.length - 1; \n            genes[2] = materials.length - 1;\n            genes[3] = classes.length - 1;\n            genes[4] = (_tokenId-1) / 20;\n            genes[5] = uint(0);\n            genes[6] = uint(0);\n        } else {\n            uint seed = getSeed(_tokenId);\n            genes[0] = getRaceIdx(seed);\n            genes[1] = getColorIdx(seed);\n            genes[2] = getMaterialIdx(seed);\n            genes[3] = getClassIdx(seed);\n            genes[4] = getElementIdx(seed);\n            genes[5] = getGeneration();\n            genes[6] = getFounderTank(_tokenId);\n        }\n        return genes;\n    }\n\n    function getBaseGeneNames(uint _tokenId) public view onlyNftOrOwner returns (string[] memory) {\n\n        uint[] memory genes = getBaseGenes(_tokenId);\n        string[] memory geneNames = new string[](7);\n        geneNames[0] = races[genes[0]];\n        geneNames[1] = colors[genes[1]];\n        geneNames[2] = materials[genes[2]];\n        geneNames[3] = classes[genes[3]];\n        geneNames[4] = elements[genes[4]];\n        geneNames[5] = generations[genes[5]];\n        geneNames[6] = founderTanks[genes[6]];\n        return geneNames;\n    }    \n\n    function getImgIdx(uint _tokenId) public view onlyNftOrOwner returns (string memory) {\n\n        uint[] memory genes = getBaseGenes(_tokenId);\n        string memory race = toString(genes[0] + uint(101));\n        string memory color;\n        if(genes[1] <= 8) {\n            color = string(abi.encodePacked(\"0\", toString(genes[1] + uint(1))));\n        } else {\n            color = toString(genes[1] + uint(1));\n        }\n        string memory material = toString(genes[2] + uint(1));\n        string memory class = toString(genes[3] + uint(1));\n        string memory element = toString(genes[4] + uint(1));\n        return string(abi.encodePacked(race, color, material, class, element));\n    }\n\n    function getRaceIdx(uint _seed) private pure returns (uint) {\n        uint v = (_seed/10) % 100;\n        if (v < 10) {\n            return uint(0);\n        } else if (v < 19) {\n            return uint(1);\n        } else if (v < 28) {\n            return uint(2);\n        } else if (v < 36) {\n            return uint(3);\n        } else if (v < 43) {\n            return uint(4);\n        } else if (v < 49) {\n            return uint(5);\n        } else if (v < 54) {\n            return uint(6);\n        } else if (v < 59) {\n            return uint(7);\n        } else if (v < 64) {\n            return uint(8);\n        } else if (v < 69) {\n            return uint(9);\n        } else if (v < 73) {\n            return uint(10);\n        } else if (v < 77) {\n            return uint(11);\n        } else if (v < 81) {\n            return uint(12);\n        } else if (v < 85) {\n            return uint(13);\n        } else if (v < 88) {\n            return uint(14);\n        } else if (v < 91) {\n            return uint(15);\n        } else if (v < 94) {\n            return uint(16);\n        } else if (v < 96) {\n            return uint(17);\n        } else if (v < 98) {\n            return uint(18);\n        } else {\n            return uint(19);\n        }\n    }\n\n    function getColorIdx(uint _seed) private pure returns (uint) {\n        uint v = (_seed/1000) % 100;\n        if (v < 30) {\n            return uint(0);\n        } else if (v < 50) {\n            return uint(1);\n        } else if (v < 70) {\n            return uint(2);\n        } else if (v < 85) {\n            return uint(3);\n        } else if (v < 95) {\n            return uint(4);\n        } else {\n            return uint(5);\n        }\n    }\n\n    function getMaterialIdx(uint _seed) private pure returns (uint) {\n        uint v = (_seed/100000) % 100;\n        if (v < 50) {\n            return uint(0);\n        } else if (v < 80) {\n            return uint(1);\n        } else {\n            return uint(2);\n        }\n    }       \n\n    function getClassIdx(uint _seed) private pure returns (uint) {\n        uint v = (_seed/10000000) % 100;\n        if (v < 40) {\n            return uint(0);\n        } else if (v < 70) {\n            return uint(1);\n        } else if (v < 90) {\n            return uint(2);\n        } else if (v < 98) {\n            return uint(3);\n        } else {\n            return uint(4);\n        }\n    }       \n\n    function getElementIdx(uint _seed) private pure returns (uint) {\n        uint v = (_seed/1000000000) % 100;\n        if (v < 20) {\n            return uint(0);\n        } else if (v < 40) {\n            return uint(1);\n        } else if (v < 60) {\n            return uint(2);\n        } else if (v < 80) {\n            return uint(3);\n        } else if (v < 94) {\n            return uint(4);\n        } else {\n            return uint(5);\n        }\n    }\n\n    function getGeneration() private pure returns (uint) {\n        return uint(0); //this contract owns all genration 0 tanks only\n    }\n\n    function getFounderTank(uint _tokenId) private pure returns (uint) {\n        if (_tokenId > 0 && _tokenId <= 120) {\n            return uint(0);\n        } else {\n            return uint(1);\n        }\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT license\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }    \n}"
    }
  }
}