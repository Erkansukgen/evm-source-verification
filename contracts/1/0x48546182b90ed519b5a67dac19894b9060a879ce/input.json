{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/EditionIndexerLogicV1.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\nimport \"./VCProxy.sol\";\nimport \"./EditionIndexerV1.sol\";\n\n/// @title Edition Indexer Logic Contract\n/// @author Guillaume Gonnaud\n/// @notice Provides the logic code for publishing and interacting with editions, nested into the Cryptograph Indexer\n/// @dev This contract and its functions should be called by the relevant proxy smart contract only\ncontract EditionIndexerLogicV1 is VCProxyData, EditionIndexerHeaderV1, EditionIndexerStoragePublicV1  {\n\n    /// @notice Generic constructor, empty\n    /// @dev This contract is meant to be used in a delegatecall and hence its memory state is irrelevant\n    constructor() public\n    {\n        //Self intialize (nothing)\n    }\n\n    //Modifier for functions that require to be called only by the index\n    modifier restrictedToIndex(){\n        require((msg.sender == index), \"Only the cryptograph index smart contract can call this function\");\n        _;\n    }\n\n    /// @notice Init function of the Indexer, starting at index 1\n    /// @dev Callable only once after instanciation\n    /// @param _index The address of the parent, main indexer\n    /// @param _minter The address of the minter for this edition\n    /// @param _editionSize The maximum number of cryptographs in this edition\n    /// @return true\n    function init(address _index, address _minter, uint256 _editionSize) external returns(bool){\n        require(!initialized, \"This Edition Indexer has already been initialized\");\n        index = _index;\n        minter = _minter;\n        editionSize = _editionSize;\n        initialized = true;\n        cryptographs.push(address(0x0)); //There is no cryptograph edition with serial 0\n        return true;\n    }\n\n    /// @notice Init function of the Indexer, starting at index 0\n    /// @dev Callable only once after instanciation\n    /// @param _index The address of the parent, main indexer\n    /// @param _minter The address of the minter for this edition\n    /// @param _editionSize The maximum number of cryptographs in this edition\n    /// @return true\n    function init0(address _index, address _minter, uint256 _editionSize) external returns(bool){\n        require(!initialized, \"This Edition Indexer has already been initialized\");\n        index = _index;\n        minter = _minter;\n        editionSize = _editionSize;\n        initialized = true;\n        return true;\n    }\n\n    /// @notice Insert a cryptograph in the array and return the new index position\n    /// @dev Callable only by the index\n    /// @param _cryptograph The address of the inserted cryptograph\n    /// @param _minter The address of the minter for this cryptograph\n    /// @return The new position in the array\n    function insertACryptograph(address _cryptograph, address _minter) external restrictedToIndex() returns(uint){\n        require(cryptographs.length <= editionSize, \"The full amount of Cryptographs for this edition has been published\");\n        require(_minter == minter, \"Only the publisher can mint new Cryptographs for this edition\");\n        cryptographs.push(_cryptograph);\n        return (cryptographs.length - 1); //Inserting the cryptograph and returning the position in the array\n    }\n\n    /// @notice Insert a cryptograph in the array at a specific position\n    /// @dev Callable only by the index. Must be smaller than edition size. HAS A LOOP.\n    /// @param _cryptograph The address of the inserted cryptograph\n    /// @param _index The desired position\n    function insertACryptographAt(address _cryptograph, uint256 _index) external restrictedToIndex(){\n\n        if(cryptographs.length <= _index){\n            while(cryptographs.length <= _index){\n                cryptographs.push();\n            }\n        }\n        cryptographs[_index] = _cryptograph; //Inserting the cryptograph\n    }\n\n}\n\n"
    },
    "browser/EditionIndexerV1.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/// @author Guillaume Gonnaud 2019\n/// @title Edition Indexer Header\n/// @notice Contain all the events emitted by the Edition Indexer\ncontract EditionIndexerHeaderV1 {\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Edition Indexer Storage Internal\n/// @notice Contain all the storage of the Edition Indexer declared in a way that don't generate getters for Proxy use\ncontract EditionIndexerStorageInternalV1 {\n    bool internal initialized; //Bool to check if the indexer have been initialized\n    address internal minter; //The address of the minter, the only person allowed to add new cryptographs\n    address internal index; //The address of the index, the only address allowed to interact with the publishing functions\n    uint256 internal editionSize; //The total amount of cryptographs to be minted in this edition\n    address[] internal cryptographs;\n}\n\n\n/// @author Guillaume Gonnaud 2019\n/// @title Edition Indexer Storage Public\n/// @notice Contain all the storage of the Edition Indexer declared in a way that generate getters for Logic use\ncontract EditionIndexerStoragePublicV1 {\n    bool public initialized; //Bool to check if the index has been initialized\n    address public minter; //The address of the minter, only person allowed to add new cryptographs\n    address public index; //The address of the index, only address allowed to interact with the publishing functions\n    uint256 public editionSize; //The total amount of cryptographs to be minted in this edition\n    address[] public cryptographs;\n}\n\n"
    },
    "browser/VCProxy.sol": {
      "content": "// © Copyright 2020. Patent pending. All rights reserved. Perpetual Altruism Ltd.\npragma solidity 0.6.6;\n\n/* Based on a variation of https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201\nThis generic proxy is gonna ask a version control smart contract for its logic code instead\nof storing the remote address himself\n*/\n\n/*\nSmart contract only containing a public array named the same as VC so that the compiler call the proper\nfunction signature in our generic proxy\n*/\ncontract VersionControlStoragePublic {\n    address[] public code;\n}\n\n\n/*\nStorage stack of a proxy contract. VCproxy inherit this, as well as ALL logic contracts associated to a proxy for storage alignment reasons.\n*/\ncontract VCProxyData {\n    address internal vc; //Version Control Smart Contract Address\n    uint256 internal version; //The index of our logic code in the Version Control array.\n}\n\n\n/*\nLogic of a proxy contract. EVERY proxied contract inherit this\n*/\ncontract VCProxy is VCProxyData {\n    constructor(uint256 _version, address _vc) public {\n        version = _version;\n        vc = _vc;\n    }\n\n    fallback () virtual external payable {\n\n        address addr = VersionControlStoragePublic(vc).code(version);\n        assembly {\n            let freememstart := mload(0x40)\n            calldatacopy(freememstart, 0, calldatasize())\n            let success := delegatecall(not(0), addr, freememstart, calldatasize(), freememstart, 0)\n            returndatacopy(freememstart, 0, returndatasize())\n            switch success\n            case 0 { revert(freememstart, returndatasize()) }\n            default { return(freememstart, returndatasize()) }\n        }\n    }\n\n    \n    /// @notice Generic catch-all function that refuse payments to prevent accidental Eth burn.\n    receive() virtual external payable{\n       require(false, \"Do not send me Eth without a reason\");\n    }\n}"
    }
  }
}