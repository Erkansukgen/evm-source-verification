{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/StakedTokensToKeep.sol": {
      "content": "pragma solidity 0.6.7;\n\nabstract contract TokenLike {\n    function balanceOf(address) virtual public view returns (uint256);\n}\nabstract contract AccountingEngineLike {\n    function debtAuctionBidSize() virtual public view returns (uint256);\n    function unqueuedUnauctionedDebt() virtual public view returns (uint256);\n}\nabstract contract GebLenderFirstResortLike {\n    function ancestorPool() virtual external view returns (address);\n    function modifyParameters(bytes32, uint256) virtual external;\n}\nabstract contract SAFEEngineLike {\n    function coinBalance(address) virtual public view returns (uint256);\n    function debtBalance(address) virtual public view returns (uint256);\n}\nabstract contract TokenPoolLike {\n    function token() virtual external view returns (address);\n}\n\ncontract StakedTokensToKeepSetter {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"StakedTokensToKeepSetter/account-not-authorized\");\n        _;\n    }\n\n    // --- Variables ---\n    // Percentage of tokens to keep in the pool at all times\n    uint256                  public tokenPercentageToKeep;\n    // The lender of first resort pool\n    GebLenderFirstResortLike public lenderFirstResort;\n    // Accounting engine contract\n    AccountingEngineLike     public accountingEngine;\n    // SAFE database\n    SAFEEngineLike           public safeEngine;\n\n    uint256 public constant  MIN_TOKENS = 1 ether;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event RecomputeTokensToKeep(uint256 tokensToKeep);\n\n    constructor(address safeEngine_, address accountingEngine_, address lenderFirstResort_, uint256 tokenPercentageToKeep_) public {\n        require(accountingEngine_ != address(0), \"StakedTokensToKeepSetter/null-accounting-engine\");\n        require(lenderFirstResort_ != address(0), \"StakedTokensToKeepSetter/null-lender-first-resort\");\n        require(safeEngine_ != address(0), \"StakedTokensToKeepSetter/null-safe-engine\");\n        require(both(tokenPercentageToKeep_ > 0, tokenPercentageToKeep_ < HUNDRED), \"StakedTokensToKeepSetter/invalid-pc-to-keep\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        accountingEngine      = AccountingEngineLike(accountingEngine_);\n        lenderFirstResort     = GebLenderFirstResortLike(lenderFirstResort_);\n        safeEngine            = SAFEEngineLike(safeEngine_);\n        tokenPercentageToKeep = tokenPercentageToKeep_;\n\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Boolean Logic ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Math ---\n    uint256 public constant HUNDRED = 100;\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"StakedTokensToKeepSetter/mul-overflow\");\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Modify an uint256 parameter\n    * @param parameter The name of the parameter to modify\n    * @param data New value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"tokenPercentageToKeep\") {\n          require(both(data > 0, data < HUNDRED), \"StakedTokensToKeepSetter/invalid-pc-to-keep\");\n          tokenPercentageToKeep = data;\n        }\n        else revert(\"StakedTokensToKeepSetter/modify-unrecognized-param\");\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notice Returns whether the protocol is underwater or not\n    */\n    function protocolUnderwater() public view returns (bool) {\n        uint256 unqueuedUnauctionedDebt = accountingEngine.unqueuedUnauctionedDebt();\n\n        return both(\n          accountingEngine.debtAuctionBidSize() <= unqueuedUnauctionedDebt,\n          safeEngine.coinBalance(address(accountingEngine)) < unqueuedUnauctionedDebt\n        );\n    }\n\n    /*\n    * @notice Recompute and set the new min amount of tokens to keep unauctioned in the lender of first resort pool\n    */\n    function recomputeTokensToKeep() external {\n        require(!protocolUnderwater(), \"StakedTokensToKeepSetter/cannot-compute-when-underwater\");\n\n        TokenPoolLike ancestorPool = TokenPoolLike(address(lenderFirstResort.ancestorPool()));\n        TokenLike ancestorToken    = TokenLike(address(ancestorPool.token()));\n\n        uint256 tokensToKeep       = multiply(tokenPercentageToKeep, ancestorToken.balanceOf(address(ancestorPool))) / HUNDRED;\n        if (tokensToKeep == 0) {\n          tokensToKeep = MIN_TOKENS;\n        }\n\n        lenderFirstResort.modifyParameters(\"minStakedTokensToKeep\", tokensToKeep);\n\n        emit RecomputeTokensToKeep(tokensToKeep);\n    }\n}"
    }
  }
}