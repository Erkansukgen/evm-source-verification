{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "arbitrager.sol": {
      "content": "pragma solidity >= 0.7.6;\r\npragma abicoder v2;\r\nimport \"./interfaces/external/IERC20.sol\";\r\nimport './libraries/BytesLib.sol';\r\nimport './libraries/TransferHelper.sol';\r\nimport \"./interfaces/callback/IUniswapV3SwapCallback.sol\";\r\n\r\ncontract swapper is IUniswapV3SwapCallback  {\r\n    \r\n    //0-1\r\n    address owner;\r\n    // IERC20 internal constant weth=IERC20(0xE99E01489A983aCB43d53b2553410dFBB0db1aaF);\r\n    IERC20 internal constant weth=IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    constructor()  {\r\n        owner=msg.sender;\r\n    }\r\n    \r\n    \r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner,'not owner');\r\n      _;\r\n    }\r\n    \r\n    /// @inheritdoc IUniswapV3SwapCallback\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata _data\r\n    ) external override {\r\n        require(tx.origin == owner,'not owner');\r\n        address tokenIn  = BytesLib.toAddress(_data,0);\r\n        uint256 amountToPay =amount0Delta > 0? uint256(amount0Delta): uint256(amount1Delta);\r\n        \r\n        // pay(tokenIn, payer, msg.sender, amountToPay);\r\n        // IERC20(tokenIn).transferFrom(payer, msg.sender, amountToPay);\r\n        // require(1==2,'callback');\r\n        tokenIn.call(abi.encodeWithSelector(0xa9059cbb,msg.sender, amountToPay));\r\n    }\r\n    \r\n\r\n    function drawETH()public payable onlyOwner{\r\n        address payable addr = payable(owner);\r\n        selfdestruct(addr);\r\n    }\r\n\r\n    function drawToken(address token,uint amount)public onlyOwner{\r\n        \r\n        IERC20 erc20=IERC20(token);\r\n        if(amount>0){\r\n            erc20.transfer(owner,amount);\r\n        }\r\n        else{\r\n            uint bal=erc20.balanceOf(address(this));\r\n            erc20.transfer(owner,bal);\r\n        }\r\n    }\r\n    \r\n    function approve(address token,address spender,uint amount)public onlyOwner{\r\n        IERC20 erc20=IERC20(token);\r\n        erc20.approve(spender,amount);\r\n    }\r\n    \r\n     function swap1(address address1,bytes calldata bts1)external onlyOwner{\r\n         (bool success1,)=address1.delegatecall(bts1);\r\n         require(success1,'step1');\r\n\r\n    }\r\n\r\n    function swap2(address address1,bytes calldata bts1,address address2,bytes calldata bts2,uint thr)external onlyOwner{\r\n        uint start=weth.balanceOf(address(this));\r\n        // IERC20(BytesLib.toAddress(bts1,68)).approve(address1,amountIn);\r\n\r\n        (bool success1,)=address1.delegatecall(bts1);\r\n        require(success1,'step1');\r\n        // IERC20(BytesLib.toAddress(bts2,68)).approve(address2,BytesLib.toUint(bts2,108));\r\n\r\n        (bool success2,)= address2.delegatecall(bts2);\r\n        require(success2,'step2');\r\n        \r\n        require(weth.balanceOf(address(this))>=start+thr,'no profit');\r\n    }\r\n    \r\n    \r\n    function swap3(address address1,bytes calldata bts1,address address2,bytes calldata bts2,address address3,bytes calldata bts3,uint thr)external onlyOwner{\r\n        uint start=weth.balanceOf(address(this));\r\n\r\n        // IERC20(BytesLib.toAddress(bts1,68)).approve(address1,amountIn);\r\n        // BytesLib.toAddress(bts1,68).call(abi.encodeWithSelector(0x095ea7b3, address1, BytesLib.toUint(bts1,108)));\r\n        (bool success1,)=address1.delegatecall(bts1);\r\n        \r\n        //!!!!!!!!!!!!!!!!lackOf in Mainnet\r\n        require(success1,'step2');\r\n        \r\n        // BytesLib.toAddress(bts2,68).call(abi.encodeWithSelector(0x095ea7b3, address2, BytesLib.toUint(bts2,108)));\r\n        (bool success2,)= address2.delegatecall(bts2);\r\n        require(success2,'step2');\r\n\r\n        // IERC20(BytesLib.toAddress(bts2,68)).approve(address2,BytesLib.toUint(bts2,108));\r\n        // BytesLib.toAddress(bts3,68).call(abi.encodeWithSelector(0x095ea7b3, address3, BytesLib.toUint(bts3,108)));\r\n        (bool success3,)= address3.delegatecall(bts3);\r\n        require(success3,'step3');\r\n\r\n\r\n        require(weth.balanceOf(address(this))>=start+thr,'no profit');\r\n    }\r\n\r\n}\r\n"
    },
    "interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "interfaces/external/IERC20.sol": {
      "content": "pragma solidity >=0.7.6;\n\n\n/// @title Interface for WETH9\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    \n}"
    },
    "libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gon?alo SÃ¡ <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\nlibrary BytesLib {\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, 'slice_overflow');\r\n        require(_start + _length >= _start, 'slice_overflow');\r\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    //zero out the 32 bytes slice we are about to return\r\n                    //we need to do it because Solidity does not garbage collect\r\n                    mstore(tempBytes, 0)\r\n\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_start + 20 >= _start, 'toAddress_overflow');\r\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n    \r\n    function toUint(bytes memory bs, uint start)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(bs.length >= start + 32, \"slicing out of range\");\r\n        uint x;\r\n        assembly {\r\n            x := mload(add(bs, add(0x20, start)))\r\n        }\r\n        return x;\r\n    }\r\n\r\n\r\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\r\n        require(_start + 3 >= _start, 'toUint24_overflow');\r\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}"
    },
    "libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '../interfaces/external/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    }
  }
}