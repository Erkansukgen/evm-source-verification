{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Trader.sol": {
      "content": "pragma solidity ^0.6.0;\r\n\r\ncontract RopstenAddresses {\r\n    address payable internal constant KYBER = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n    address payable internal constant UNISWAP = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;\r\n    address internal constant PBTC = 0xEB770B1883Dcce11781649E8c4F1ac5F4B40C978;\r\n    address internal constant DAI = 0xaD6D458402F60fD3Bd25163575031ACDce07538D;\r\n    address internal constant MANA = 0x72fd6C7C1397040A66F33C2ecC83A0F71Ee46D5c;\r\n    address internal constant BAT = 0xDb0040451F373949A4Be60dcd7b6B8D6E42658B6;\r\n    //Uniswap WETH 0xc778417e063141139fce010982780140aa0cd5ab\r\n}\r\n\r\ncontract Ownable {\r\n    address payable private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Withdrawable is Ownable {\r\n    function withdrawEther() external onlyOwner {\r\n        this.owner().transfer(address(this).balance);\r\n    }\r\n    \r\n    function withdrawToken(ERC20 token) external onlyOwner {\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n    \r\n    function etherBalance() external view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n    function tokenBalance(ERC20 token) external view returns (uint) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n}\r\n\r\ncontract Payable {\r\n    receive() external payable { }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() external view returns(uint);\r\n    function getUserCapInWei(address user) external view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\r\n    function enabled() external view returns(bool);\r\n    function info(bytes32 id) external view returns(uint);\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\r\n    function swapEtherToToken(ERC20 token, uint minRate) external payable returns (uint);\r\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external returns (uint);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n  function WETH() external pure returns (address);\r\n\r\n//   function addLiquidity(\r\n//       address tokenA,\r\n//       address tokenB,\r\n//       uint amountADesired,\r\n//       uint amountBDesired,\r\n//       uint amountAMin,\r\n//       uint amountBMin,\r\n//       address to,\r\n//       uint deadline\r\n//   ) external returns (uint amountA, uint amountB, uint liquidity);\r\n//   function addLiquidityETH(\r\n//       address token,\r\n//       uint amountTokenDesired,\r\n//       uint amountTokenMin,\r\n//       uint amountETHMin,\r\n//       address to,\r\n//       uint deadline\r\n//   ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n//   function removeLiquidity(\r\n//       address tokenA,\r\n//       address tokenB,\r\n//       uint liquidity,\r\n//       uint amountAMin,\r\n//       uint amountBMin,\r\n//       address to,\r\n//       uint deadline\r\n//   ) external returns (uint amountA, uint amountB);\r\n//   function removeLiquidityETH(\r\n//       address token,\r\n//       uint liquidity,\r\n//       uint amountTokenMin,\r\n//       uint amountETHMin,\r\n//       address to,\r\n//       uint deadline\r\n//   ) external returns (uint amountToken, uint amountETH);\r\n//   function removeLiquidityWithPermit(\r\n//       address tokenA,\r\n//       address tokenB,\r\n//       uint liquidity,\r\n//       uint amountAMin,\r\n//       uint amountBMin,\r\n//       address to,\r\n//       uint deadline,\r\n//       bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n//   ) external returns (uint amountA, uint amountB);\r\n//   function removeLiquidityETHWithPermit(\r\n//       address token,\r\n//       uint liquidity,\r\n//       uint amountTokenMin,\r\n//       uint amountETHMin,\r\n//       address to,\r\n//       uint deadline,\r\n//       bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n//   ) external returns (uint amountToken, uint amountETH);\r\n  function swapExactTokensForTokens(\r\n      uint amountIn,\r\n      uint amountOutMin,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapTokensForExactTokens(\r\n      uint amountOut,\r\n      uint amountInMax,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\nabstract contract Exchange is Withdrawable, Payable {\r\n    address public exchangeAddress;\r\n    \r\n    function setupExchange(address payable _address) virtual external;\r\n    function swapEtherToToken(ERC20 token, uint price) virtual external payable returns (uint amount);\r\n    function swapTokenToEther(ERC20 token, uint quantity, uint price) virtual external returns (uint amount);\r\n    function rate(ERC20 source, ERC20 destination, uint quantity) virtual external view returns (uint price, uint slippageRate);\r\n    function swap(ERC20 source, ERC20 destination, uint quantity,uint price) virtual external payable returns(uint amount);\r\n}\r\n\r\ncontract KyberExchange is Exchange {\r\n    KyberNetworkProxyInterface internal exchange;\r\n    \r\n    constructor() public {\r\n        exchangeAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n        exchange = KyberNetworkProxyInterface(exchangeAddress);\r\n    }\r\n    \r\n    function setupExchange(address payable _address) override onlyOwner external {\r\n        exchangeAddress = _address;\r\n        exchange = KyberNetworkProxyInterface(_address);\r\n    }\r\n    \r\n    function swapEtherToToken(ERC20 token, uint price) override public payable returns (uint){\r\n        uint qty = exchange.swapEtherToToken.value(msg.value)(token, price);\r\n        require(token.transfer(msg.sender, qty));\r\n        return qty;\r\n    }\r\n\r\n    function swapTokenToEther(ERC20 token, uint quantity, uint price) override external returns (uint){\r\n        token.approve(exchangeAddress, quantity);\r\n        uint qty = exchange.swapTokenToEther(token, quantity, price);\r\n        (msg.sender).transfer(qty);\r\n        return qty;\r\n    }\r\n\r\n    function rate(ERC20 source, ERC20 destination, uint quantity) override external view returns (uint expectedRate, uint slippageRate){\r\n        return exchange.getExpectedRate(source, destination, quantity);\r\n    }\r\n    \r\n    function swap(ERC20 source, ERC20 destination, uint quantity,uint price) override external payable returns(uint){\r\n        source.approve(exchangeAddress, quantity);\r\n        return exchange.tradeWithHint(source, quantity, destination, msg.sender, 100000000000000000000000000000000000 , price, 0x0000000000000000000000000000000000000000,'');\r\n    }\r\n}\r\n\r\ncontract UniswapExchange is Exchange {\r\n    IUniswapV2Router01 private exchange;\r\n    address WETH; \r\n    constructor() public {\r\n        exchangeAddress = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;\r\n        exchange = IUniswapV2Router01(exchangeAddress);\r\n        WETH = exchange.WETH();\r\n    }\r\n    \r\n    function setupExchange(address payable _address) override onlyOwner external {\r\n        exchangeAddress = _address;\r\n        exchange = IUniswapV2Router01(_address);\r\n    }\r\n    \r\n    function getPath(address a1, address a2) private view returns (address[] memory amounts) {\r\n        //return [a1,a2];\r\n        \r\n        //for testing \r\n        if (a1 == WETH || a2 == WETH){\r\n            address[] memory array = new address[](2);\r\n            array[0] = a1;\r\n            array[1] = a2;\r\n            return array;\r\n        } else {\r\n            address[] memory array = new address[](3);\r\n            array[0] = a1;\r\n            array[1] = WETH;//swap tokens via WETH because for testing most pairs dont exist\r\n            array[2] = a2;\r\n            return array;\r\n        }\r\n        \r\n        // address[] memory array = new address[](2);\r\n        // array[0] = a1;\r\n        // array[2] = a2;\r\n        // return array;\r\n    }\r\n    \r\n    function swapEtherToToken(ERC20 token, uint price) override external payable returns (uint){\r\n        address[] memory path = getPath(WETH, address(token));\r\n        uint amountOut = (msg.value*price)/10**18;\r\n        uint[] memory amounts = exchange.swapExactETHForTokens.value(msg.value)(amountOut, path, msg.sender, now + 60*5);\r\n        return amounts[amounts.length-1];\r\n    }\r\n\r\n    function swapTokenToEther(ERC20 token, uint quantity, uint price) override external returns (uint){\r\n        token.approve(exchangeAddress, quantity);\r\n        address[] memory path = getPath(address(token), WETH);\r\n        uint amountOutMin = (quantity*price)/10**18;\r\n        uint[] memory amounts = exchange.swapExactTokensForETH(quantity, amountOutMin,path, msg.sender, now + 60*5);\r\n        return amounts[amounts.length-1];\r\n    }\r\n    \r\n    function swap(ERC20 source, ERC20 destination, uint quantity,uint price) override external payable returns(uint) {\r\n        source.approve(exchangeAddress, quantity);\r\n        address[] memory path = getPath(address(source), address(destination));\r\n        uint amountOutMin = (quantity*price)/10**18;\r\n        uint[] memory amounts = exchange.swapExactTokensForTokens(quantity, amountOutMin, path, msg.sender,now + 60*5);\r\n        return amounts[amounts.length-1];\r\n    }\r\n    \r\n    function rate(ERC20 source, ERC20 destination, uint quantity) override external view returns (uint expectedRate, uint slippageRate){\r\n        address[] memory path = getPath(address(source), address(destination));\r\n        uint[] memory amounts = exchange.getAmountsOut(quantity,path);\r\n        return ((amounts[amounts.length-1]*10**18)/quantity, 0);\r\n    }\r\n}\r\n\r\ncontract Trader is Payable, Withdrawable, RopstenAddresses {\r\n    \r\n    constructor() public {\r\n        \r\n    }\r\n    \r\n    function depositEtherToToken(Exchange exchange, ERC20 token, uint rate) external payable returns (uint) {\r\n        return exchange.swapEtherToToken.value(msg.value)(token, rate);//{value : msg.value}\r\n    }\r\n    \r\n    function swapTokenToEther(Exchange exchange, ERC20 token, uint quantity, uint rate) external returns (uint) {\r\n        uint qty = this.tokenBalance(token);\r\n        require(token.transfer(address(exchange), qty));\r\n        return exchange.swapTokenToEther(token, quantity, rate);\r\n    }\r\n    \r\n    //\"0x90b1aE35202A2a1b41194139FEe4DaF49B10f9F4\",\"0x4A301331fb544BCa887050476fa4eAEEfd5B82E2\",\"0xDb0040451F373949A4Be60dcd7b6B8D6E42658B6\",\"0xaD6D458402F60fD3Bd25163575031ACDce07538D\",\"1061100215235000000\",\"1\",\"1\"\r\n    function arb(Exchange exchange1, Exchange exchange2, ERC20 source, ERC20 destination, uint quantity, uint buyPrice, uint sellPrice) external returns (uint) {\r\n        //swap source to destination on exchange1\r\n        require(source.transfer(address(exchange1), quantity));\r\n        uint sellQuantity = exchange1.swap(source, destination, quantity, buyPrice);\r\n        //swap destination back to source on exchange2\r\n        require(destination.transfer(address(exchange2), sellQuantity));\r\n        uint endQuantity = exchange2.swap(destination, source, sellQuantity, sellPrice);\r\n        //as long as we have more than we started with trade is a success\r\n        require(endQuantity >= quantity);\r\n        return endQuantity;\r\n    }\r\n    \r\n    function rate(Exchange exchange, ERC20 src, ERC20 dest, uint qty) external view returns (uint) {\r\n        (uint exchangeRate,) = exchange.rate(src, dest, qty);\r\n        return exchangeRate;\r\n    }\r\n}\r\n\r\ncontract HasExchangesAndTokens {\r\n    Exchange internal exchange1;\r\n    Exchange internal exchange2;\r\n    ERC20 internal token1;\r\n    ERC20 internal token2;\r\n    \r\n    function setExchange1(address payable _address) external{\r\n        exchange1 = Exchange(_address);\r\n    }\r\n    \r\n    function setExchange2(address payable _address) external{\r\n        exchange2 = Exchange(_address);\r\n    }\r\n    \r\n    function setToken1(address _address) external{\r\n        token1 = ERC20(_address);\r\n    }\r\n    \r\n    function setToken2(address _address) external{\r\n        token2 = ERC20(_address);\r\n    }\r\n    \r\n    function exchanges() external view  returns (address, address) {\r\n        return (address(exchange1), address(exchange2));\r\n    }\r\n    \r\n    function tokens() external view  returns (address, address) {\r\n        return (address(token1), address(token2));\r\n    }\r\n    \r\n    function swapExchanges() external {\r\n        Exchange temp = exchange1;\r\n        exchange1 = exchange2;\r\n        exchange2 = temp;\r\n    }\r\n    \r\n    function tokensBalance() external view returns (uint, uint) {\r\n        return (token1.balanceOf(address(this)), token2.balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract ExchangeTester is Trader, HasExchangesAndTokens {\r\n    constructor() public {\r\n        //Kyber\r\n        exchange1 = Exchange(0xDb0040451F373949A4Be60dcd7b6B8D6E42658B6);\r\n        //Uniswap\r\n        exchange2 = Exchange(0x90b1aE35202A2a1b41194139FEe4DaF49B10f9F4);\r\n        token1 = ERC20(DAI);\r\n        token2 = ERC20(BAT);\r\n    }\r\n    \r\n    function testAll() external payable returns (uint,uint,uint) {\r\n        uint token1 = this.testETHtoToken1.value(msg.value)();\r\n        uint token2 = this.testToken1toToken2();\r\n        uint eth = this.testToken2toETH();\r\n        return (token1,token2,eth);\r\n    }\r\n    //swapEtherToToken\r\n    function testETHtoToken1() external payable returns (uint) {\r\n        return this.depositEtherToToken.value(msg.value)(exchange1, token1, 1);\r\n    }\r\n    //swapTokenToToken\r\n    function testToken1toToken2() external returns (uint) {\r\n        uint qty = this.tokenBalance(token1);\r\n        require(token1.transfer(address(exchange1), qty));\r\n        return exchange1.swap(token1, token2, qty, 1);\r\n    }\r\n    function testToken1toToken2Exchange2() internal returns (uint) {\r\n        uint qty = this.tokenBalance(token1);\r\n        require(token1.transfer(address(exchange2), qty));\r\n        return exchange2.swap(token1, token2, qty, 1);\r\n    }\r\n    //swapTokenToEther\r\n    function testToken2toETH() external returns (uint) {\r\n        uint qty = this.tokenBalance(token2);\r\n        require(token2.transfer(address(exchange1), qty));\r\n        return exchange1.swapTokenToEther(token2, qty, 1);\r\n    }\r\n    \r\n    function testTransToken1toExch1() external returns (uint) {\r\n        uint qty = this.tokenBalance(token1);\r\n        require(token1.transfer(address(exchange1), qty));\r\n        return qty;\r\n    }\r\n    \r\n    function testArbBetweenExchanges() external payable returns (uint) {\r\n        this.testETHtoToken1.value(msg.value)();\r\n        testToken1toToken2Exchange2();\r\n        return this.testToken2toETH();\r\n    }\r\n    \r\n    function rateToken1ToToken2(uint srcQty) external view returns (uint expectedRate, uint slippageRate){\r\n        return exchange1.rate(token1, token2, srcQty);\r\n    }\r\n}\r\n"
    }
  }
}