{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 9999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/StandardToken.sol": {
      "content": "// Sources flattened with hardhat v2.0.3 https://hardhat.org\n\n// File contracts/Library/SafeMath.sol\n\n// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant RAD = 1e45;\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"Math/Add-Overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"Math/Sub-Overflow\");\n    }\n\n    function sub(\n        uint256 x,\n        uint256 y,\n        string memory message\n    ) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, message);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || ((z = x * y) / y) == x, \"Math/Mul-Overflow\");\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y > 0, \"Math/Div-Overflow\");\n        z = x / y;\n    }\n\n    function mod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y != 0, \"Math/Mod-Overflow\");\n        z = x % y;\n    }\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    function toWAD(uint256 wad, uint256 decimal)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        require(decimal < 18, \"Math/Too-high-decimal\");\n        z = mul(wad, 10**(18 - decimal));\n    }\n}\n\n\n// File contracts/Library/Address.sol\n\npragma solidity ^0.6.0;\n\nlibrary Address {\n    function isContract(address target) internal view returns (bool result) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := gt(extcodesize(target), 0)\n        }\n    }\n}\n\n\n// File contracts/Interface/IERC173.sol\n\npragma solidity ^0.6.0;\n\n/// @title ERC-173 Contract Ownership Standard\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return The address of the owner.\n    function owner() external view returns (address);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @param newOwner The address of the new owner of the contract\n    function transferOwnership(address newOwner) external;\n}\n\n\n// File contracts/Library/Authority.sol\n\npragma solidity ^0.6.0;\n\ncontract Authority is IERC173 {\n    address private _owner;\n\n    modifier onlyAuthority() {\n        require(_owner == msg.sender, \"Authority/Not-Authorized\");\n        _;\n    }\n\n    function owner() external override view returns (address) {\n        return _owner;\n    }\n\n    function initialize(address newOwner) internal {\n        _owner = newOwner;\n        emit OwnershipTransferred(address(0), newOwner);\n    }\n\n    function transferOwnership(address newOwner)\n        external\n        override\n        onlyAuthority\n    {\n        _owner = newOwner;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n\n\n// File contracts/Interface/IERC20.sol\n\npragma solidity ^0.6.0;\n\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function balanceOf(address target) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\n\n\n// File contracts/Interface/IERC165.sol\n\npragma solidity ^0.6.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID)\n        external\n        view\n        returns (bool);\n}\n\n\n// File contracts/Interface/IERC2612.sol\n\npragma solidity ^0.6.0;\n\n\ninterface IERC2612 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n\n// File contracts/Interface/Iinitialize.sol\n\npragma solidity ^0.6.0;\n\ninterface Iinitialize {\n    function initialize(\n        string calldata contractVersion,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        uint8 tokenDecimals\n    ) external;\n}\n\n\n// File contracts/abstract/ERC20.sol\n\npragma solidity ^0.6.0;\n\nabstract contract AbstractERC20 {\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal virtual;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual;\n}\n\n\n// File contracts/abstract/ERC2612.sol\n\npragma solidity ^0.6.0;\n\n/**\n * @title Permit\n * @notice An alternative to approveWithAuthorization, provided for\n * compatibility with the draft EIP2612 proposed by Uniswap.\n * @dev Differences:\n * - Uses sequential nonce, which restricts transaction submission to one at a\n *   time, or else it will revert\n * - Has deadline (= validBefore - 1) but does not have validAfter\n * - Doesn't have a way to change allowance atomically to prevent ERC20 multiple\n *   withdrawal attacks\n */\nabstract contract AbstractERC2612 is AbstractERC20 {\n    bytes32 public constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    string private _version;\n\n    mapping(address => uint256) public nonces;\n\n    function version() external view returns (string memory) {\n        return _version;\n    }\n\n    /**\n     * @notice Initialize EIP712 Domain Separator\n     * @param version     version of contract\n     * @param name        name of contract\n     */\n    function _initDomainSeparator(string memory version, string memory name)\n        internal\n    {\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        _version = version;\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(bytes(name)), // name\n                keccak256(bytes(version)), // version\n                chainId, // chainid\n                address(this) // this address\n            )\n        );\n    }\n\n    /**\n     * @notice Verify a signed approval permit and execute if valid\n     * @param owner     Token owner's address (Authorizer)\n     * @param spender   Spender's address\n     * @param value     Amount of allowance\n     * @param deadline  The time at which this expires (unix time)\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     */\n    function _permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        require(owner != address(0), \"ERC2612/Invalid-address-0\");\n        require(deadline >= now, \"ERC2612/Expired-time\");\n\n        // @TODO: Gas Testing\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n\n        // bytes memory digest = abi.encode(\n        //     PERMIT_TYPEHASH,\n        //     owner,\n        //     spender,\n        //     value,\n        //     nonces[owner]++,\n        //     deadline\n        // );\n\n        address recovered = ecrecover(digest, v, r, s);\n        require(\n            recovered != address(0) && recovered == owner,\n            \"ERC2612/Invalid-Signature\"\n        );\n\n        _approve(owner, spender, value);\n    }\n}\n\n\n// File contracts/StandardToken.sol\n\npragma solidity ^0.6.0;\n\n\n\n\n\n\n\n\n\ncontract StandardToken is\n    Authority,\n    AbstractERC2612,\n    IERC2612,\n    IERC165,\n    IERC20\n{\n    using SafeMath for uint256;\n    using Address for address;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    constructor(\n        string memory contractVersion,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 tokenDecimals\n    ) public {\n        Authority.initialize(msg.sender);\n        _initDomainSeparator(contractVersion, tokenName);\n\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        _decimals = tokenDecimals;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function approve(address spender, uint256 value)\n        external\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function balanceOf(address target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _balances[target];\n    }\n\n    function allowance(address owner, address spender)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address to, uint256 value)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(\n            value,\n            \"ERC20/Not-Enough-Allowance\"\n        );\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function mint(uint256 value) external onlyAuthority returns (bool) {\n        _totalSupply = _totalSupply.add(value);\n        _balances[msg.sender] = _balances[msg.sender].add(value);\n        emit Transfer(address(0), msg.sender, value);\n        return true;\n    }\n\n    function burn(uint256 value) external onlyAuthority returns (bool) {\n        _balances[msg.sender] = _balances[msg.sender].sub(\n            value,\n            \"ERC20/Not-Enough-Balance\"\n        );\n        _totalSupply = _totalSupply.sub(value);\n        emit Transfer(msg.sender, address(0), value);\n        return true;\n    }\n\n    /**\n     * @notice Update allowance with a signed permit\n     * @param owner       Token owner's address (Authorizer)\n     * @param spender     Spender's address\n     * @param value       Amount of allowance\n     * @param deadline    Expiration time, seconds since the epoch\n     * @param v           v of the signature\n     * @param r           r of the signature\n     * @param s           s of the signature\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        _permit(owner, spender, value, deadline, v, r, s);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC20).interfaceId || // ERC20\n            interfaceID == type(IERC165).interfaceId || // ERC165\n            interfaceID == type(IERC173).interfaceId || // ERC173\n            interfaceID == type(IERC2612).interfaceId ||\n            interfaceID == type(Iinitialize).interfaceId; // ERC2612\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        require(to != address(this), \"ERC20/Not-Allowed-Transfer\");\n        _balances[from] = _balances[from].sub(\n            value,\n            \"ERC20/Not-Enough-Balance\"\n        );\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal override {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n}\n"
    }
  }
}