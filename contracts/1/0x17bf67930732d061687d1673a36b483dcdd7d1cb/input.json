{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/main.sol":{"content":"/*\n\nSmart Contract was developed by nodeberry.com for cubebit business solutions.\n\n*/\n\n\n\npragma solidity ^0.7.0;\n\ncontract AdcubeContract1 {\n    \n    constructor(){\n        owner = msg.sender;\n    }\n    \n    uint256 public price = 50000000000000000;\n    uint256 public spillover = 3880000000000000;\n    uint256 public referralBonus = 5000000000000000;\n    address public owner;\n    \n    uint256 public totalUsers = 0;\n    uint256 public userAccounts = 0;\n    \n    struct User{\n        address referrer;\n        uint256 totalAccounts;\n        bool active;\n        mapping(uint256 => Account) accounts;\n    }\n    \n    struct UserDetails{\n        string fname;\n        string lname;\n        string username;\n        string country;\n        string location;\n        bool show;\n    }\n    \n    struct Account {\n        bool active;\n        address[] uplines;\n        address[] downlines;\n    }\n    \n    mapping(address => User) public users;\n    \n    mapping (address => UserDetails) public details;\n    \n    event Recieved(address,uint);\n    \n    event Referral(address,uint);\n    \n    event LevelBonus(address,uint);\n\n    modifier onlyOwner(){\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function updateFiatPrice(uint256 _price, uint256 _referralBonus, uint256 _spillover) public onlyOwner{\n         price = _price;\n         spillover = _spillover;\n         referralBonus = _referralBonus;\n    }\n    \n    function register(address payable _referrer, uint256 _referrerAccount) external payable{\n        require(msg.value == price);\n        if(_referrer == owner){\n            registration(msg.sender,_referrer,_referrerAccount);\n        }\n        else{\n            User storage u = users[msg.sender];\n            User storage r = users[_referrer];\n            Account storage ra = r.accounts[_referrerAccount];\n            require(r.active == true);\n            require(ra.active == true);\n            require(u.active == false);\n            registration(msg.sender,_referrer,_referrerAccount);\n        }\n    }\n    \n    function deactive(address _account, uint256 _accountNo) public onlyOwner{\n        User storage u = users[_account];\n        Account storage ua = u.accounts[_accountNo];\n        ua.active = false;\n    }\n    \n    function blacklist(address _account) public onlyOwner{\n        User storage u = users[_account];\n        u.active = false;\n    }\n    \n    function reactivate(address _account) public onlyOwner{\n        User storage u = users[_account];\n        u.active = true;\n    }\n    \n    function registration(address _user, address payable _referrer, uint256 _referrerAccount) private{\n        totalUsers = totalUsers + 1;\n        userAccounts = userAccounts + 1;\n        User storage u = users[_user];\n        Account storage ua = u.accounts[1];\n        if(_referrer != owner){\n            u.referrer = _referrer;\n            u.totalAccounts = 1;\n            u.active = true;\n            ua.active = true;\n            pushDownlines(_user,_referrer,_referrerAccount);\n            pushUplines(_user,_referrer,_referrerAccount,1);\n            sendDirectBonus(_referrer);\n        } \n        else{\n            u.referrer = owner;\n            u.totalAccounts = 1;\n            u.active = true;\n            ua.active = true;\n            sendDirectBonus(payable(owner));\n            pushDownlines(_user,_referrer,_referrerAccount);\n            pushUplines(_user,_referrer,_referrerAccount,1);\n        }\n    }\n    \n    function pushUplines(address _user, address payable _referrer,uint256 _referrerAccount, uint256 _userAccount) private{\n        User storage u = users[_user];\n        User storage r = users[_referrer];\n        Account storage ra = r.accounts[_referrerAccount];\n        Account storage ua = u.accounts[_userAccount];\n        ua.uplines.push(_referrer);   \n        for(uint256 i = 0; i < ra.uplines.length; i++){\n               ua.uplines.push(ra.uplines[i]);\n         }\n        sendSpillOver(ua.uplines);\n    }\n    \n    function pushDownlines(address _user, address payable _referrer, uint256 _referrerAccount) private {\n        User storage r = users[_referrer];\n        Account storage ra = r.accounts[_referrerAccount];\n        ra.downlines.push(_user);\n        for(uint256 i=0; i < ra.uplines.length; i++ ){\n            User storage u = users[ra.uplines[i]];\n            uint256 total = u.totalAccounts;\n            for(uint256 j=total;j>0;j--){\n              Account storage ua = u.accounts[j];\n              if(ua.active == true){\n                  ua.downlines.push(_user);\n                  break;\n              }\n              j++;\n            }\n         }\n        if(_referrerAccount == 1 && ra.downlines.length >= 39){\n                 ra.active = false;\n         }\n         else if(_referrerAccount == 2 && ra.downlines.length >= 1082){\n                 ra.active = false;\n         }\n         else if(_referrerAccount > 2 && ra.downlines.length >= 29514){\n                ra.active = false;\n         }\n         else{\n             ra.active = true;\n         }\n    }\n    \n    \n    function purchase() external payable{\n         require(msg.value == price);\n         User storage u = users[msg.sender];\n         uint256 newAccount = u.totalAccounts;\n         newAccount = newAccount + 1;\n         uint256 oldAccount = u.totalAccounts;\n         require(u.active == true);\n         userAccounts = userAccounts + 1;\n         Account storage o = u.accounts[oldAccount];\n         Account storage a = u.accounts[newAccount];\n         a.active = true;\n         a.uplines = o.uplines;\n         u.totalAccounts = newAccount;\n         sendDirectBonus(payable(u.referrer));\n         sendSpillOver(a.uplines);\n    }\n    \n    \n    function sendSpillOver(address[] memory _reciepients) private{\n        if(_reciepients.length > 9){\n           for(uint i=0;i< 9;i++){\n              payable( _reciepients[i]).transfer(spillover);\n              emit LevelBonus(_reciepients[i],spillover);\n           }\n        }\n        else{\n          for(uint i=0;i<_reciepients.length;i++){\n              payable( _reciepients[i]).transfer(spillover);\n              emit LevelBonus(_reciepients[i],spillover);\n           }  \n        }\n    }\n    \n    function sendDirectBonus(address payable _reciever) private {\n        _reciever.transfer(referralBonus);\n        emit Referral(_reciever,referralBonus);\n    }\n    \n    function updateOwnership(address _newOwner) public onlyOwner{\n        owner = _newOwner;\n    }\n    \n    function balanceOf() external view returns(uint256){\n        return address(this).balance;\n    }\n    \n    function getUplines(uint _accountId) public view returns(address[] memory, bool status){\n        User storage u = users[msg.sender];\n        require(u.totalAccounts >= _accountId);\n        Account storage a = u.accounts[_accountId];\n        return(a.uplines,a.active);\n    }\n    \n    function getDownlines(uint _accountId) public view returns(address[] memory, bool status){\n        User storage u = users[msg.sender];\n        Account storage a = u.accounts[_accountId];\n        require(a.active == true);\n        return(a.downlines,a.active);\n    }\n    \n    function getOwnerDonwlines(uint _accountId) public view onlyOwner returns(address[] memory){\n        User storage u = users[owner];\n        Account storage a = u.accounts[_accountId];\n        return(a.downlines);\n    }\n    \n    function getAccountDetails(address _user) public view returns(address, uint, bool){\n        User storage u = users[_user];\n        return(u.referrer,u.totalAccounts,u.active);\n    }\n    \n    function getUserAccountDetails(address _user, uint256 _account) public view returns(address[] memory, address[] memory){\n        User storage u = users[_user];\n        Account storage a = u.accounts[_account];\n        return(a.uplines,a.downlines);\n    }\n    \n    function validate(address _address) public view returns(bool){\n        User storage u = users[_address];\n        return u.active;\n    }\n    \n    function updateProfile(string memory _fname, string memory _lname, string memory _country, string memory _location, string memory _username, bool _show) public{\n        UserDetails storage detail = details[msg.sender];\n        detail.fname = _fname;\n        detail.lname = _lname;\n        detail.country = _country;\n        detail.location = _location;\n        detail.username = _username;\n        detail.show = _show;\n    }\n    \n    function getProfile() public view returns(string memory,string memory,string memory,string memory,string memory,bool){\n        UserDetails storage detail = details[msg.sender];\n        return(detail.fname,detail.lname,detail.country,detail.location,detail.username,detail.show);\n    }\n    \n    function drain() public onlyOwner{\n        payable(owner).transfer(address(this).balance);\n    }\n \n}"}}}