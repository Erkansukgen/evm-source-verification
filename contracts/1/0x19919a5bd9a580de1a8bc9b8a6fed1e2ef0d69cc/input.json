{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/SnxLashLoanLiq/FlashLoanReceiverBase.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport {IFlashLoanReceiver, ILendingPoolAddressesProvider, ILendingPool, IERC20  } from \"./InterfacesAave.sol\";\r\nimport { SafeERC20, SafeMath } from \"./LibrariesAave.sol\";\r\n\r\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint256;\r\n\r\n  ILendingPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\r\n  ILendingPool public immutable LENDING_POOL;\r\n\r\n  constructor(ILendingPoolAddressesProvider provider) {\r\n    ADDRESSES_PROVIDER = provider;\r\n    LENDING_POOL = ILendingPool(provider.getLendingPool());\r\n  }\r\n}"},"contracts/SnxLashLoanLiq/InterfacesAave.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\r\npragma solidity >=0.7.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport { DataTypes } from \"./LibrariesAave.sol\";\r\n\r\ninterface IERC20 {\r\n \r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IFlashLoanReceiver {\r\n  function executeOperation(\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata premiums,\r\n    address initiator,\r\n    bytes calldata params\r\n  ) external returns (bool);\r\n}\r\n\r\ninterface ILendingPoolAddressesProvider {\r\n  event LendingPoolUpdated(address indexed newAddress);\r\n  event ConfigurationAdminUpdated(address indexed newAddress);\r\n  event EmergencyAdminUpdated(address indexed newAddress);\r\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n  event PriceOracleUpdated(address indexed newAddress);\r\n  event LendingRateOracleUpdated(address indexed newAddress);\r\n  event ProxyCreated(bytes32 id, address indexed newAddress);\r\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n  function setAddress(bytes32 id, address newAddress) external;\r\n\r\n  function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n  function getAddress(bytes32 id) external view returns (address);\r\n\r\n  function getLendingPool() external view returns (address);\r\n\r\n  function setLendingPoolImpl(address pool) external;\r\n\r\n  function getLendingPoolConfigurator() external view returns (address);\r\n\r\n  function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n  function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n  function setLendingPoolCollateralManager(address manager) external;\r\n\r\n  function getPoolAdmin() external view returns (address);\r\n\r\n  function setPoolAdmin(address admin) external;\r\n\r\n  function getEmergencyAdmin() external view returns (address);\r\n\r\n  function setEmergencyAdmin(address admin) external;\r\n\r\n  function getPriceOracle() external view returns (address);\r\n\r\n  function setPriceOracle(address priceOracle) external;\r\n\r\n  function getLendingRateOracle() external view returns (address);\r\n\r\n  function setLendingRateOracle(address lendingRateOracle) external;\r\n}\r\n\r\ninterface ILendingPool {\r\n  event Deposit(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\r\n\r\n  event Borrow(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint256 borrowRateMode,\r\n    uint256 borrowRate,\r\n    uint16 indexed referral\r\n  );\r\n  event Repay(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    address indexed repayer,\r\n    uint256 amount\r\n  );\r\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\r\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\r\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\r\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\r\n  event FlashLoan(\r\n    address indexed target,\r\n    address indexed initiator,\r\n    address indexed asset,\r\n    uint256 amount,\r\n    uint256 premium,\r\n    uint16 referralCode\r\n  );\r\n  event Paused();\r\n  event Unpaused();\r\n  event LiquidationCall(\r\n    address indexed collateralAsset,\r\n    address indexed debtAsset,\r\n    address indexed user,\r\n    uint256 debtToCover,\r\n    uint256 liquidatedCollateralAmount,\r\n    address liquidator,\r\n    bool receiveAToken\r\n  );\r\n  event ReserveDataUpdated(\r\n    address indexed reserve,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external;\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external;\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external;\r\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\r\n  function rebalanceStableBorrowRate(address asset, address user) external;\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external;\r\n  function flashLoan(\r\n    address receiverAddress,\r\n    address[] calldata assets,\r\n    uint256[] calldata amounts,\r\n    uint256[] calldata modes,\r\n    address onBehalfOf,\r\n    bytes calldata params,\r\n    uint16 referralCode\r\n  ) external;\r\n  function getUserAccountData(address user)\r\n    external\r\n    view\r\n    returns (\r\n      uint256 totalCollateralETH,\r\n      uint256 totalDebtETH,\r\n      uint256 availableBorrowsETH,\r\n      uint256 currentLiquidationThreshold,\r\n      uint256 ltv,\r\n      uint256 healthFactor\r\n    );\r\n\r\n  function initReserve(\r\n    address reserve,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external;\r\n\r\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\r\n    external;\r\n\r\n  function setConfiguration(address reserve, uint256 configuration) external;\r\n\r\n  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\r\n\r\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\r\n\r\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\r\n\r\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\r\n\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromAfter,\r\n    uint256 balanceToBefore\r\n  ) external;\r\n\r\n  function getReservesList() external view returns (address[] memory);\r\n\r\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\r\n\r\n  function setPause(bool val) external;\r\n\r\n  function paused() external view returns (bool);\r\n}\r\n"},"contracts/SnxLashLoanLiq/LibrariesAave.sol":{"content":"\r\npragma solidity >=0.7.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport { IERC20 } from \"./InterfacesAave.sol\";\r\n\r\nlibrary SafeMath {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n\r\n  function isContract(address account) internal view returns (bool) {\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      codehash := extcodehash(account)\r\n    }\r\n    return (codehash != accountHash && codehash != 0x0);\r\n  }\r\n\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n    (bool success, ) = recipient.call{value: amount}('');\r\n    require(success, 'Address: unable to send value, recipient may have reverted');\r\n  }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      'SafeERC20: approve from non-zero to non-zero allowance'\r\n    );\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n  }\r\n\r\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = address(token).call(data);\r\n    require(success, 'SafeERC20: low-level call failed');\r\n\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      // solhint-disable-next-line max-line-length\r\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\r\n    }\r\n  }\r\n}\r\n\r\nlibrary DataTypes {\r\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n  struct ReserveData {\r\n    //stores the reserve configuration\r\n    ReserveConfigurationMap configuration;\r\n    //the liquidity index. Expressed in ray\r\n    uint128 liquidityIndex;\r\n    //variable borrow index. Expressed in ray\r\n    uint128 variableBorrowIndex;\r\n    //the current supply rate. Expressed in ray\r\n    uint128 currentLiquidityRate;\r\n    //the current variable borrow rate. Expressed in ray\r\n    uint128 currentVariableBorrowRate;\r\n    //the current stable borrow rate. Expressed in ray\r\n    uint128 currentStableBorrowRate;\r\n    uint40 lastUpdateTimestamp;\r\n    //tokens addresses\r\n    address aTokenAddress;\r\n    address stableDebtTokenAddress;\r\n    address variableDebtTokenAddress;\r\n    //address of the interest rate strategy\r\n    address interestRateStrategyAddress;\r\n    //the id of the reserve. Represents the position in the list of the active reserves\r\n    uint8 id;\r\n  }\r\n\r\n  struct ReserveConfigurationMap {\r\n    //bit 0-15: LTV\r\n    //bit 16-31: Liq. threshold\r\n    //bit 32-47: Liq. bonus\r\n    //bit 48-55: Decimals\r\n    //bit 56: Reserve is active\r\n    //bit 57: reserve is frozen\r\n    //bit 58: borrowing is enabled\r\n    //bit 59: stable rate borrowing enabled\r\n    //bit 60-63: reserved\r\n    //bit 64-79: reserve factor\r\n    uint256 data;\r\n  }\r\n\r\n  struct UserConfigurationMap {\r\n    uint256 data;\r\n  }\r\n\r\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n}\r\n"},"contracts/SnxLashLoanLiq/SnxLashLoanLiq.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport { FlashLoanReceiverBase } from \"./FlashLoanReceiverBase.sol\";\r\nimport { ILendingPool, ILendingPoolAddressesProvider, IERC20 } from \"./InterfacesAave.sol\";\r\nimport { SafeMath } from \"./LibrariesAave.sol\";\r\n\r\ninterface ISynthetix {\r\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n}\r\n\r\ncontract SnxLashLoanLiq is FlashLoanReceiverBase {\r\n    using SafeMath for uint256;\r\n    \r\n    address owner;\r\n    address mAdrSynthetix = 0x43AE8037179a5746D618DA077A38DdeEa9640cBa;\r\n    address mAdrSushiRouter = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\r\n    \r\n    address[] pathSwap;\r\n    address adrWETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address adrSNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\r\n    address adrSUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\r\n    \r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n//    aave lending pool provider    ------- 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5\r\n    constructor(ILendingPoolAddressesProvider _addressProvider) FlashLoanReceiverBase(_addressProvider) {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function executeOperation(\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata premiums,\r\n        address initiator,\r\n        bytes calldata params\r\n    ) external override returns (bool) {\r\n\t\t//(address accountLiq, uint256 amountLiq) = abi.decode(params, (address, uint256));\r\n\t\t(address accountLiq) = abi.decode(params, (address));\r\n\t\tuint256 amountLiq = amounts[0];\r\n        ISynthetix(mAdrSynthetix).liquidateDelinquentAccount(accountLiq, amountLiq);\r\n        \r\n        //exchange SNX to WETH\r\n        uint amountInSnx = IERC20(adrSNX).balanceOf(address(this));\r\n        pathSwap = [adrSNX, adrWETH];\r\n        IERC20(adrSNX).approve(mAdrSushiRouter, amountInSnx);\r\n        IUniswapV2Router01(mAdrSushiRouter).swapExactTokensForTokens(amountInSnx, 0, pathSwap, address(this), block.timestamp + 1000);\r\n        //exchange WETH to sUSD\r\n        uint amountOwing = amountLiq.add(premiums[0]);\r\n        uint amountInMaxWETH = IERC20(adrWETH).balanceOf(address(this));\r\n        IERC20(adrWETH).approve(mAdrSushiRouter, amountInMaxWETH);\r\n        pathSwap = [adrWETH, adrSUSD];\r\n        IUniswapV2Router01(mAdrSushiRouter).swapTokensForExactTokens(amountOwing, amountInMaxWETH, pathSwap, address(this), block.timestamp + 1000);\r\n\r\n        //repay\r\n        IERC20(adrSUSD).approve(address(LENDING_POOL), amountOwing);\r\n        return true;\r\n    }\r\n\r\n    function myLashLoanCall(address accountLiq, uint256 amountLiq, uint256 deadlineLiq) public {\r\n        require(_deadlinePassed(deadlineLiq), \"not ppp\");\r\n        \r\n        address receiverAddress = address(this);\r\n\r\n        address[] memory assets = new address[](1);\r\n        assets[0] = adrSUSD; // sUSD\r\n\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = amountLiq;\r\n\r\n        // 0 = no debt, 1 = stable, 2 = variable\r\n        uint256[] memory modes = new uint256[](1);\r\n        modes[0] = 0;\r\n\r\n        address onBehalfOf = address(this);\r\n        //bytes memory params = abi.encode(accountLiq, amountLiq);\r\n        bytes memory params = abi.encode(accountLiq);\r\n        uint16 referralCode = 0;\r\n\r\n        LENDING_POOL.flashLoan(\r\n            receiverAddress,\r\n            assets,\r\n            amounts,\r\n            modes,\r\n            onBehalfOf,\r\n            params,\r\n            referralCode\r\n        );\r\n    }\r\n    \r\n    //check deadline\r\n    function _deadlinePassed(uint deadline) internal view returns (bool) {\r\n        return block.timestamp > deadline;\r\n    }\r\n\r\n    function setSnxAddress(address adr) public ownerOnly {\r\n        mAdrSynthetix = adr;\r\n    }\r\n\r\n    function setSushiRouterAddress(address adr) public ownerOnly {\r\n        mAdrSushiRouter = adr;\r\n    }\r\n\r\n    function setOwner(address adr) public ownerOnly {\r\n        owner = adr;\r\n    }\r\n\r\n    function withrawTokenAll(address token) public {\r\n        uint balanceToken = IERC20(token).balanceOf(address(this));\r\n        bool success = IERC20(token).transfer(owner, balanceToken);\r\n    }\r\n\r\n    function withdrawETHAll() public {\r\n        uint balanceETH = address(this).balance;\r\n        (bool success, ) = owner.call{value: balanceETH}(new bytes(0));\r\n    }\r\n    \r\n}\r\n"}}}