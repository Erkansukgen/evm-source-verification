{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/autobuy.sol":{"content":"pragma solidity =0.6.6;\n\ninterface IUniswapV2Router01 {\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\ncontract Owned {\n    modifier onlyOwner() {\n        require(msg.sender==owner);\n        _;\n    }\n    address payable owner;\n    address payable newOwner;\n    function changeOwner(address payable _newOwner) public onlyOwner {\n        require(_newOwner!=address(0));\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        if (msg.sender==newOwner) {\n            owner = newOwner;\n        }\n    }\n}\ncontract AutoBuy is Owned{\n     event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n    \n    mapping(address=>uint256) buyer;\n    address Wcontract;\n    address payable UniAddress;\n    uint WamountOutMin;\n    address[] Wpath;\n    address Wto;\n    uint Wdeadline;\n    constructor() public{\n        deposit();\n        owner = msg.sender;\n    }\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        emit Deposit(msg.sender, msg.value);\n    }\n    \n    \n    function setSwap(address payable _UniAddress, address _Wcontract, uint _WamountOutMin, address[] calldata _Wpath, address _Wto, uint _Wdeadline) external onlyOwner{\n        UniAddress=_UniAddress;\n        Wcontract=_Wcontract;\n        WamountOutMin=_WamountOutMin;\n        Wpath=_Wpath;\n        Wto=_Wto;\n        Wdeadline=_Wdeadline;\n    }\n    function allowApprove(address _token, uint256 _amount, address _UniRoute) public onlyOwner{\n        TransferHelper.safeApprove(_token, _UniRoute, _amount);\n    }\n    function setBuyer(address _target, uint256 _status) public onlyOwner{\n        buyer[_target]=_status;\n    }\n    function buy() public{\n        require(buyer[msg.sender]==1);\n        IUniswapV2Router01 Uniswap= IUniswapV2Router01(Wcontract);\n        Uniswap.swapETHForExactTokens{value: address(this).balance}(WamountOutMin, Wpath, Wto, Wdeadline);\n    }\n    function safeFund(address _token, uint256 _amount) public onlyOwner{\n        TransferHelper.safeTransfer(_token, msg.sender, _amount);\n    }\n    function getInfor() view public returns(address, uint, address[] memory, address, uint){\n        return(Wcontract, WamountOutMin, Wpath, Wto, Wdeadline);\n    }\n    function withdraw(uint256 amount) public onlyOwner{\n        msg.sender.transfer(amount);\n    }\n}"}}}