{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"browser/EsusuAdapter.sol":{"content":"pragma solidity >=0.6.6;\n\nimport \"./IDaiToken.sol\";\nimport \"./IYDaiToken.sol\";\n\nimport \"./IDaiLendingService.sol\";\nimport \"./OwnableService.sol\";\n\nimport \"./ISavingsConfig.sol\";\nimport \"./ISavingsConfigSchema.sol\";\nimport \"./IGroups.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IEsusuStorage.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./IERC20.sol\";\n\ncontract EsusuAdapter is OwnableService, ISavingsConfigSchema {\n    \n    using SafeMath for uint256;\n\n    using SafeERC20 for IDaiToken; \n\n    using SafeERC20 for IYDaiToken; \n\n    /*\n        Events to emit\n        1. Creation of Esusu Cycle\n        2. Joining of Esusu Cycle\n        3. Starting of Esusu Cycle\n        4. Withdrawal of ROI\n        5. Withdrawal of Capital\n    */\n    event CreateEsusuCycleEvent\n    (\n        uint256 date,\n        uint256 indexed cycleId,\n        uint256 depositAmount,\n        address  Owner,\n        uint256 payoutIntervalSeconds,\n        CurrencyEnum currency,\n        string currencySymbol,\n        uint256 cycleState\n    );\n\n    event DepricateContractEvent(\n        \n        uint256 date,\n        address owner, \n        string reason,\n        uint256 yDaiSharesTransfered\n    );\n    event JoinEsusuCycleEvent\n    (\n        uint256 date,\n        address indexed member,   \n        uint256 memberPosition,\n        uint256 totalAmountDeposited,\n        uint256 cycleId\n    );\n    \n    event StartEsusuCycleEvent\n    (\n        uint256 date,\n        uint256 totalAmountDeposited,\n        uint256 totalCycleDuration,\n        uint256 totalShares,\n        uint256 indexed cycleId\n    );\n\n    /*  Enum definitions */\n    enum CurrencyEnum {Dai}\n\n    enum CycleStateEnum {\n        Idle, // Cycle has just been created and members can join in this state\n        Active, // Cycle has started and members can take their ROI\n        Expired, // Cycle Duration has elapsed and members can withdraw their capital as well as ROI\n        Inactive // Total beneficiaries is equal to Total members, so all members have withdrawn their Capital and ROI\n    }\n\n    \n    //  Member variables\n    ISavingsConfig _savingsConfigContract;\n    IGroups immutable _groupsContract;\n\n    IDaiLendingService _iDaiLendingService;\n    IDaiToken immutable _dai = IDaiToken(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    IYDaiToken immutable _yDai = IYDaiToken(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01);\n    IEsusuStorage _esusuStorage;\n    address _delegateContract;\n    bool _isActive = true;\n    \n\n    constructor (address payable serviceContract, \n                     address groupsContract,\n                    address esusuStorageContract) public OwnableService(serviceContract){\n        _groupsContract = IGroups(groupsContract);\n        _esusuStorage = IEsusuStorage(esusuStorageContract);\n    }\n\n    function UpdateDaiLendingService(address daiLendingServiceContractAddress)\n        external\n        onlyOwner\n        active\n    {\n        _iDaiLendingService = IDaiLendingService(\n            daiLendingServiceContractAddress\n        );\n    }\n\n    function UpdateEsusuAdapterWithdrawalDelegate(address delegateContract)\n        external\n        onlyOwner\n        active\n    {\n        _delegateContract = delegateContract;\n    }\n\n    /*\n        NOTE: startTimeInSeconds is the time at which when elapsed, any one can start the cycle\n        -   Creates a new EsusuCycle\n        -   Esusu Cycle can only be created by the owner of the group\n    */\n    \n    function CreateEsusu(uint256 groupId, uint256 depositAmount, uint256 payoutIntervalSeconds,uint256 startTimeInSeconds, address owner, uint256 maxMembers) external active onlyOwnerAndServiceContract {\n        //  Get Current EsusuCycleId\n        uint256 currentEsusuCycleId = _esusuStorage.GetEsusuCycleId();\n\n        // Get Group information by Id\n        (uint256 id, string memory name, string memory symbol, address creatorAddress) = GetGroupInformationById(groupId);\n        \n        require(owner == creatorAddress, \"EsusuCycle can only be created by group owner\");\n        \n        _esusuStorage.CreateEsusuCycleMapping(groupId,depositAmount,payoutIntervalSeconds,startTimeInSeconds,owner,maxMembers);\n        \n        //  emit event\n        emit CreateEsusuCycleEvent(now, currentEsusuCycleId, depositAmount, owner, payoutIntervalSeconds,CurrencyEnum.Dai,\"Dai Stablecoin\",_esusuStorage.GetEsusuCycleState(currentEsusuCycleId));\n        \n    }\n\n    //  Join a particular Esusu Cycle\n    /*\n        - Check if the cycle ID is valid\n        - Check if the cycle is in Idle state, that is the only state a member can join\n        - Check if member is already in Cycle\n        - Ensure member has approved this contract to transfer the token on his/her behalf\n        - If member has enough balance, transfer the tokens to this contract else bounce\n        - Increment the total deposited amount in this cycle and total deposited amount for the member cycle struct\n        - Increment the total number of Members that have joined this cycle\n    */\n    \n    function JoinEsusu(uint256 esusuCycleId, address member) external onlyOwnerAndServiceContract active {\n        //  Get Current EsusuCycleId\n        uint256 currentEsusuCycleId = _esusuStorage.GetEsusuCycleId();\n        \n        //  Check if the cycle ID is valid\n        require(\n            esusuCycleId > 0 && esusuCycleId <= currentEsusuCycleId,\n            \"Cycle ID must be within valid EsusuCycleId range\"\n        );\n\n        //  Get the Esusu Cycle struct\n        \n        (uint256 CycleId, uint256 DepositAmount, uint256 CycleState,uint256 TotalMembers,uint256 MaxMembers) = _esusuStorage.GetEsusuCycleBasicInformation(esusuCycleId);\n        //  If cycle is not in Idle State, bounce \n        require( CycleState == uint(CycleStateEnum.Idle), \"Esusu Cycle must be in Idle State before you can join\");\n\n        \n        //  If cycle is filled up, bounce \n\n        require(TotalMembers < MaxMembers, \"Esusu Cycle is filled up, you can't join\");\n        \n        //  check if member is already in this cycle \n        require(!_isMemberInCycle(member,esusuCycleId), \"Member can't join same Esusu Cycle more than once\");\n        \n        //  If user does not have enough Balance, bounce. For now we use Dai as default\n        uint256 memberBalance = _dai.balanceOf(member);\n        \n        require(memberBalance >= DepositAmount, \"Balance must be greater than or equal to Deposit Amount\");\n        \n        \n        //  If user balance is greater than or equal to deposit amount then transfer from member to this contract\n        //  NOTE: approve this contract to withdraw before transferFrom can work\n        _dai.safeTransferFrom(member, address(this), DepositAmount);\n        \n        //  Increment the total deposited amount in this cycle\n        uint256 totalAmountDeposited = _esusuStorage.IncreaseTotalAmountDepositedInCycle(esusuCycleId,DepositAmount);\n        \n        \n        _esusuStorage.CreateMemberAddressToMemberCycleMapping(member,esusuCycleId);\n        \n        //  Increase TotalMembers count by 1\n        _esusuStorage.IncreaseTotalMembersInCycle(esusuCycleId);\n        //  Create the position of the member in the cycle\n        _esusuStorage.CreateMemberPositionMapping(CycleId, member);\n        //  Create mapping to track the Cycles a member belongs to by index and by ID\n        _esusuStorage.CreateMemberToCycleIndexToCycleIDMapping(member, CycleId);\n\n        //  emit event\n        emit JoinEsusuCycleEvent(\n            now,\n            member,\n            TotalMembers,\n            totalAmountDeposited,\n            esusuCycleId\n        );\n    }\n\n    /*\n        - Check if the Id is a valid ID\n        - Check if the cycle is in Idle State\n        - Anyone  can start that cycle -\n        - Get the total number of members and then multiply by the time interval in seconds to get the total time this Cycle will last for\n        - Set the Cycle start time to now \n        - Take everyones deposited DAI from this Esusu Cycle and then invest through Yearn \n        - Track the yDai shares that belong to this cycle using the derived equation below for save/investment operation\n            - yDaiSharesPerCycle = Change in yDaiSharesForContract + Current yDai Shares in the cycle\n            - Change in yDaiSharesForContract = yDai.balanceOf(address(this) after save operation - yDai.balanceOf(address(this) after before operation\n    */\n    \n    function StartEsusuCycle(uint256 esusuCycleId) external onlyOwnerAndServiceContract active{\n        \n        //  Get Current EsusuCycleId\n        uint256 currentEsusuCycleId = _esusuStorage.GetEsusuCycleId();\n        \n        //  Get Esusu Cycle Basic information\n        (uint256 CycleId, uint256 DepositAmount, uint256 CycleState,uint256 TotalMembers,uint256 MaxMembers) = _esusuStorage.GetEsusuCycleBasicInformation(esusuCycleId);\n\n        //  Get Esusu Cycle Total Shares\n        (uint256 EsusuCycleTotalShares) = _esusuStorage.GetEsusuCycleTotalShares(esusuCycleId);\n        \n        \n        //  Get Esusu Cycle Payout Interval \n        (uint256 EsusuCyclePayoutInterval) = _esusuStorage.GetEsusuCyclePayoutInterval(esusuCycleId);\n        \n        \n        //  If cycle ID is valid, else bonunce\n        require(esusuCycleId != 0 && esusuCycleId <= currentEsusuCycleId, \"Cycle ID must be within valid EsusuCycleId range\");\n        \n\n        require(\n            now > _esusuStorage.GetEsusuCycleStartTime(esusuCycleId),\n            \"Cycle can only be started when start time has elapsed\"\n        );\n\n        //  Calculate Cycle LifeTime in seconds\n        uint256 toalCycleDuration = EsusuCyclePayoutInterval * TotalMembers;\n\n        //  Get all the dai deposited for this cycle\n        uint256 esusuCycleBalance = _esusuStorage.GetEsusuCycleTotalAmountDeposited(esusuCycleId);\n        \n        //  Get the balance of yDaiSharesForContract before save opration\n        uint256 yDaiSharesForContractBeforeSave = _yDai.balanceOf(address(this));\n        \n        //  Invest the dai in Yearn Finance using Dai Lending Service.\n\n        //  NOTE: yDai will be sent to this contract\n        //  Transfer dai from this contract to dai lending adapter and then call a new save function that will not use transferFrom internally\n        //  Approve the daiLendingAdapter so it can spend our Dai on our behalf\n        address daiLendingAdapterContractAddress = _iDaiLendingService\n            .GetDaiLendingAdapterAddress();\n        _dai.approve(daiLendingAdapterContractAddress, esusuCycleBalance);\n\n        _iDaiLendingService.save(esusuCycleBalance);\n\n        //  Get the balance of yDaiSharesForContract after save operation\n        uint256 yDaiSharesForContractAfterSave = _yDai.balanceOf(address(this));\n        \n        \n        //  Save yDai Total balanceShares\n        uint256 totalShares = yDaiSharesForContractAfterSave.sub(yDaiSharesForContractBeforeSave).add(EsusuCycleTotalShares);\n        \n        //  Increase TotalDeposits made to this contract \n\n        _esusuStorage.IncreaseTotalDeposits(esusuCycleBalance);\n\n        //  Update Esusu Cycle State, total cycle duration, total shares  and  cycle start time,\n        _esusuStorage.UpdateEsusuCycleDuringStart(\n            CycleId,\n            uint256(CycleStateEnum.Active),\n            toalCycleDuration,\n            totalShares,\n            now\n        );\n\n        //  emit event\n        emit StartEsusuCycleEvent(\n            now,\n            esusuCycleBalance,\n            toalCycleDuration,\n            totalShares,\n            esusuCycleId\n        );\n    }\n    \n    \n  \n    function GetMemberCycleInfo(address memberAddress, uint256 esusuCycleId) active external view returns(uint256 CycleId, address MemberId, uint256 TotalAmountDepositedInCycle, uint256 TotalPayoutReceivedInCycle, uint256 memberPosition) {\n        \n        return _esusuStorage.GetMemberCycleInfo(memberAddress, esusuCycleId);\n    }\n\n    function GetEsusuCycle(uint256 esusuCycleId) external view returns(uint256 CycleId, uint256 DepositAmount, \n                                                            uint256 PayoutIntervalSeconds, uint256 CycleState, \n                                                            uint256 TotalMembers, uint256 TotalAmountDeposited, uint256 TotalShares, \n                                                            uint256 TotalCycleDurationInSeconds, uint256 TotalCapitalWithdrawn, uint256 CycleStartTimeInSeconds,\n                                                            uint256 TotalBeneficiaries, uint256 MaxMembers){\n        \n        return _esusuStorage.GetEsusuCycle(esusuCycleId);\n    }\n\n    function GetDaiBalance(address member)\n        external\n        view\n        active\n        returns (uint256)\n    {\n        return _dai.balanceOf(member);\n    }\n\n    function GetYDaiBalance(address member)\n        external\n        view\n        active\n        returns (uint256)\n    {\n        return _yDai.balanceOf(member);\n    }\n    \n    \n    \n    function GetTotalDeposits() active external view returns(uint)  {\n        return _esusuStorage.GetTotalDeposits();\n    }\n\n    \n    function GetCurrentEsusuCycleId() active external view returns(uint){\n        \n        return _esusuStorage.GetEsusuCycleId();\n    }\n    \n    function _isMemberInCycle(address memberAddress,uint256 esusuCycleId ) internal view returns(bool){\n        \n        return _esusuStorage.IsMemberInCycle(memberAddress,esusuCycleId);\n    }\n    \n    function _isMemberABeneficiaryInCycle(address memberAddress,uint256 esusuCycleId ) internal view returns(bool){\n\n        return _esusuStorage.GetMemberCycleToBeneficiaryMapping(esusuCycleId, memberAddress) > 0;\n    }\n    \n    function _isMemberInWithdrawnCapitalMapping(address memberAddress,uint256 esusuCycleId ) internal view returns(bool){\n        \n        return _esusuStorage.GetMemberWithdrawnCapitalInEsusuCycle(esusuCycleId, memberAddress) > 0;\n    }\n\n    /*\n        - Get the group index by name\n        - Get the group information by index\n    */\n    function GetGroupInformationByName(string calldata name) active external view returns (uint256 groupId, string memory groupName, string memory groupSymbol, address groupCreatorAddress){\n        \n        //  Get the group index by name\n        (, uint256 index ) = _groupsContract.getGroupIndexerByName(name);\n        \n        //  Get the group id by index and return \n\n        return _groupsContract.getGroupByIndex(index);\n    }\n\n    /*\n        - Get the group information by Id\n    */\n    function GetGroupInformationById(uint256 id) active public view returns (uint256 groupId, string memory groupName, string memory groupSymbol, address groupCreatorAddress){\n        \n        //  Get the group id by index and return \n\n        return _groupsContract.getGroupById(id);\n    }\n\n    /*\n        - Creates the group\n        - returns the ID and other information\n    */\n    function CreateGroup(string calldata name, string calldata symbol, address groupCreator) active external {\n        \n           _groupsContract.createGroup(name,symbol,groupCreator);\n           \n    }\n    \n    function TransferYDaiSharesToWithdrawalDelegate(uint256 amount) external active onlyOwnerAndDelegateContract {\n        \n        _yDai.safeTransfer(_delegateContract, amount);\n    }\n\n    function DepricateContract(\n        address newEsusuAdapterContract,\n        string calldata reason\n    ) external onlyOwner {\n        //  set _isActive to false\n        _isActive = false;\n        \n        uint256 yDaiSharesBalance = _yDai.balanceOf(address(this));\n\n        //  Send yDai shares to the new contract and halt operations of this contract\n        _yDai.safeTransfer(newEsusuAdapterContract, yDaiSharesBalance);\n        \n        DepricateContractEvent(now, owner, reason, yDaiSharesBalance);\n\n    }\n\n    modifier onlyOwnerAndDelegateContract() {\n        require(\n            msg.sender == owner || msg.sender == _delegateContract,\n            \"Unauthorized access to contract\"\n        );\n        _;\n    }\n    \n    modifier active(){\n        require(_isActive, \"This contract is depricated, use new version of contract\");\n        _;\n    }\n}\n"},"browser/EsusuAdapterWithdrawalDelegate.sol":{"content":"pragma solidity 0.6.6;\n\nimport \"./IDaiToken.sol\";\nimport \"./IYDaiToken.sol\";\nimport \"./IDaiLendingService.sol\";\nimport \"./OwnableService.sol\";\nimport \"./ITreasury.sol\";\nimport \"./ISavingsConfig.sol\";\nimport \"./ISavingsConfigSchema.sol\";\nimport \"./IRewardConfig.sol\";\nimport \"./IXendToken.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IEsusuStorage.sol\";\nimport \"./IEsusuAdapter.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./IERC20.sol\";\n\n\ncontract EsusuAdapterWithdrawalDelegate is OwnableService, ISavingsConfigSchema {\n\n        using SafeMath for uint256;\n\n        using SafeERC20 for IDaiToken; \n\n        using SafeERC20 for IYDaiToken; \n\n        event ROIWithdrawalEvent\n        (\n            uint256 date,\n            address indexed member,  \n            uint256 cycleId,\n            uint256 amount       \n        );\n\n        event CapitalWithdrawalEvent\n        (\n            uint256 date,\n            address indexed member,  \n            uint256 cycleId,\n            uint256 amount\n        );\n\n        event XendTokenReward (\n          uint256 date,\n          address indexed member,\n          uint256 cycleId,\n          uint256 amount\n        );\n\n        enum CycleStateEnum{\n            Idle,               // Cycle has just been created and members can join in this state\n            Active,             // Cycle has started and members can take their ROI\n            Expired,            // Cycle Duration has elapsed and members can withdraw their capital as well as ROI\n            Inactive            // Total beneficiaries is equal to Total members, so all members have withdrawn their Capital and ROI\n        }\n\n        event DepricateContractEvent(        \n        uint256 date,\n        address owner, \n        string reason\n        );\n\n        ITreasury immutable _treasuryContract;\n        ISavingsConfig immutable _savingsConfigContract;\n        IRewardConfig immutable _rewardConfigContract;\n        IXendToken  immutable _xendTokenContract;\n        string _feeRuleKey;\n        uint256 _groupCreatorRewardPercent;\n\n        IEsusuStorage immutable _esusuStorage;\n        IEsusuAdapter immutable _esusuAdapterContract;\n        IDaiToken immutable _dai = IDaiToken(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n        IYDaiToken immutable _yDai = IYDaiToken(0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01);\n        IDaiLendingService _iDaiLendingService;\n        bool _isActive = true;\n        uint256 _feePrecision = 10;     //  This determines the lower limit of the fee to be charged. With precsion of 10, it means our fee can have a precision of 0.1% and above\n        uint256 _totalTokenReward;      //  This tracks the total number of token rewards distributed on the esusu \n\n        constructor(address payable serviceContract, address esusuStorageContract, address esusuAdapterContract,\n                    string memory feeRuleKey, address treasuryContract, address rewardConfigContract, address xendTokenContract, address savingsConfigContract)public OwnableService(serviceContract){\n\n            _esusuStorage = IEsusuStorage(esusuStorageContract);\n            _esusuAdapterContract = IEsusuAdapter(esusuAdapterContract);\n            _feeRuleKey = feeRuleKey;\n            _treasuryContract = ITreasury(treasuryContract);\n            _rewardConfigContract = IRewardConfig(rewardConfigContract);\n            _xendTokenContract = IXendToken(xendTokenContract);\n            _savingsConfigContract = ISavingsConfig(savingsConfigContract);\n\n        }\n\n        function UpdateDaiLendingService(address daiLendingServiceContractAddress) active onlyOwner external {\n            _iDaiLendingService = IDaiLendingService(daiLendingServiceContractAddress);\n        }\n     function setGroupCreatorRewardPercent (uint256 percent) external onlyOwner {\n            _groupCreatorRewardPercent = percent;\n     }\n\n        function UpdateFeePrecision(uint256 feePrecision) onlyOwner external{\n            _feePrecision = feePrecision;\n        }\n\n        function GetTotalTokenRewardDistributed() external view returns(uint256){\n            return _totalTokenReward;\n        }\n        /*\n            This function allows members to withdraw their capital from the esusu cycle\n\n            - Check if member can withdraw capital\n            - Withdraw capital and increase TotalCapitalWithdrawn\n                - Get the total balanceShares from the calling contract\n                - Withdraw all the money from dai lending service\n                - Send the member's deposited amount to his/her address\n                - re-invest the remaining dai until all members have taken their capital, then we set the cycle inactive\n            - Reward member with Xend Tokens\n            - Add this member to the EsusuCycleCapitalMapping\n            - Check if TotalCapitalWithdrawn == TotalAmountDeposited && if TotalMembers == TotalBeneficiaries, if yes, set the Cycle to Inactive\n\n        */        \n        function WithdrawCapitalFromEsusuCycle(uint256 esusuCycleId, address member) external active onlyOwnerAndServiceContract {\n\n        //  Get Esusu Cycle Basic information\n        (uint256 CycleId, uint256 DepositAmount, uint256 CycleState,uint256 TotalMembers,uint256 MaxMembers) = _esusuStorage.GetEsusuCycleBasicInformation(esusuCycleId);\n        \n        require(_isMemberEligibleToWithdrawCapital(esusuCycleId,member), \"member is not eligible to withdraw\");        \n        //  Add member to capital withdrawn mapping\n\n        //  Get the current yDaiSharesPerCycle and call the WithdrawByShares function on the daiLending Service\n        uint256 yDaiSharesPerCycle = _esusuStorage.GetEsusuCycleTotalShares(esusuCycleId);\n\n\n        //  transfer yDaiShares from the adapter contract to here\n        _esusuAdapterContract.TransferYDaiSharesToWithdrawalDelegate(yDaiSharesPerCycle);        \n        //  Get the yDaiSharesForContractBeforeWithdrawal \n        uint256 yDaiSharesForContractBeforeWithdrawal = _yDai.balanceOf(address(this));\n        //  Withdraw the Dai. At this point, we have withdrawn  Dai Capital deposited by this member for this cycle and we will now transfer the dai capital to the member\n        address daiLendingAdapterContractAddress = _iDaiLendingService.GetDaiLendingAdapterAddress();\n\n        _yDai.approve(daiLendingAdapterContractAddress,yDaiSharesPerCycle);\n\n        _iDaiLendingService.WithdrawByShares(DepositAmount,yDaiSharesPerCycle);\n        \n        //  Now the Dai is in this contract, transfer it to the member \n        _dai.safeTransfer(member, DepositAmount);\n        \n        //  Reward member with Xend Tokens\n        _rewardMember(_esusuStorage.GetEsusuCycleDuration(esusuCycleId),member,DepositAmount,CycleId);\n        \n        //  Get the yDaiSharesForContractAfterWithdrawal \n        uint256 yDaiSharesForContractAfterWithdrawal = _yDai.balanceOf(address(this));\n        \n        require(yDaiSharesForContractBeforeWithdrawal > yDaiSharesForContractAfterWithdrawal, \"yDai shares before withdrawal must be greater !!!\");\n        \n        //  Update the total balanceShares for this cycle \n        uint256 cycleTotalShares = yDaiSharesPerCycle.sub(yDaiSharesForContractBeforeWithdrawal.sub(yDaiSharesForContractAfterWithdrawal));\n\n        //  Add this member to the CycleToMemberWithdrawnCapitalMapping\n\n        //  Create Member Capital Mapping\n        _esusuStorage.CreateMemberCapitalMapping(esusuCycleId,member);        \n        //  Increase total capital withdrawn \n        uint256 TotalCapitalWithdrawnInCycle = _esusuStorage.GetEsusuCycleTotalCapitalWithdrawn(CycleId).add(DepositAmount);\n        \n        //   Check if TotalCapitalWithdrawn == TotalAmountDeposited && if TotalMembers == TotalBeneficiaries, if yes, set the Cycle to Inactive\n\n        if(TotalCapitalWithdrawnInCycle == _esusuStorage.GetEsusuCycleTotalAmountDeposited(esusuCycleId) && TotalMembers == _esusuStorage.GetEsusuCycleTotalBeneficiaries(esusuCycleId)){\n\n            _esusuStorage.UpdateEsusuCycleState(esusuCycleId, uint(CycleStateEnum.Inactive));\n\n            //  Since this cycle is inactive, send whatever Total shares Dai equivalent that is left to our treasury contract\n\n            //  Withdraw DAI equivalent fof TotalShares\n\n            _yDai.approve(daiLendingAdapterContractAddress,cycleTotalShares);\n            _iDaiLendingService.WithdrawBySharesOnly(cycleTotalShares);\n                   \n            //  Now the Dai is in this contract, transfer it to the treasury contract \n            uint256 balance = _dai.balanceOf(address(this));\n            _dai.approve(address(_treasuryContract),balance);\n            _treasuryContract.depositToken(address(_dai));\n\n        }else{\n\n            //  Since we have not withdrawn all the capital, then Send the yDai shares back to the adapter contract,\n            //  this contract should not hold any coins\n            _yDai.safeTransfer(address(_esusuAdapterContract),_yDai.balanceOf(address(this)));\n\n        }\n\n        //  Update Esusu Cycle Information For Capital Withdrawal\n        _esusuStorage.UpdateEsusuCycleDuringCapitalWithdrawal(CycleId, cycleTotalShares,TotalCapitalWithdrawnInCycle);\n\n        //  emit event\n        emit CapitalWithdrawalEvent(now, member, esusuCycleId,DepositAmount);\n\n    }\n\n      /*\n        Assumption:\n        - We assume even distribution of Overall accumulated ROI among members of the group when a member places a withdrawal request at a time inverval\n          greater than members in the previous position who have not placed a withdrawal request.\n\n        This function sends all ROI generated within an Esusu Cycle Payout Interval to a particular member\n\n        - Check if member is eligible to withdraw\n        - Get the price per full share from Dai Lending Service\\\n        - Get overall DAI => yDai balanceShares * pricePerFullShare (NOTE: value is in 1e36)\n        - Get ROI => overall Dai - Total Deposited Dai in this esusu cycle\n        - Implement our derived equation to determine what ROI will be allocated to this member who is withdrawing\n        - Deduct fees from Member's ROI\n        - Equation Parameters\n            - Ta => Total available time in seconds\n            - Bt => Total Time Interval for beneficiaries in this cycle in seconds\n            - Tnow => Current Time in seconds\n            - T => Cycle PayoutIntervalSeconds\n            - Troi => Total accumulated ROI\n            - Mroi => Member ROI    \n                    \n            Equations - Update from CertiK Audit\n            - Bt = number of beneficiaries\n            - Ta = Total Members In Cycle - Bt\n            - Troi = ((balanceShares * pricePerFullShare ) - TotalDeposited - TotalCapitalWithdrawn)\n            - Mroi = (Total accumulated ROI at Tnow) / (Ta) \n        NOTE: As members withdraw their funds, the yDai balanceShares will change and we will be updating the TotalShares with this new value\n        at all times till TotalShares becomes approximately zero when all amounts have been withdrawn including capital invested\n\n        - Track the yDai shares that belong to this cycle using the derived equation below for withdraw operation\n            - yDaiSharesPerCycle = Current yDai Shares in the cycle - Change in yDaiSharesForContract\n            - Change in yDaiSharesForContract = yDai.balanceOf(address(this)) before withdraw operation - yDai.balanceOf(address(this)) after withdraw operation\n\n    */\n        function WithdrawROIFromEsusuCycle(uint256 esusuCycleId, address member)  external active onlyOwnerAndServiceContract {\n        \n        uint256 totalMembers = _esusuStorage.GetTotalMembersInCycle(esusuCycleId);\n\n        bool isMemberEligibleToWithdraw = _isMemberEligibleToWithdrawROI(esusuCycleId,member);\n\n        require(isMemberEligibleToWithdraw, \"Member cannot withdraw at this time\");\n        \n        uint256 currentBalanceShares = _esusuStorage.GetEsusuCycleTotalShares(esusuCycleId);\n        \n        // uint256 pricePerFullShare = _iDaiLendingService.getPricePerFullShare();\n        \n        uint256 overallGrossDaiBalance = currentBalanceShares.mul(_iDaiLendingService.getPricePerFullShare()).div(1e18);\n        \n        uint256 CycleId = esusuCycleId;\n\n        // address memberAddress = member;\n\n        //  Implement our derived equation to get the amount of Dai to transfer to the member as ROI\n        uint256 Bt = _esusuStorage.GetEsusuCycleTotalBeneficiaries(esusuCycleId);\n\n        uint256 Ta = totalMembers.sub(Bt);\n        uint256 Troi = overallGrossDaiBalance.sub(_esusuStorage.GetEsusuCycleTotalAmountDeposited(esusuCycleId).sub(_esusuStorage.GetEsusuCycleTotalCapitalWithdrawn(esusuCycleId)));\n\n        uint Mroi = Troi.div(Ta);\n\n        //  Get the current yDaiSharesPerCycle and call the WithdrawByShares function on the daiLending Service\n        // uint yDaiSharesPerCycle = currentBalanceShares;\n\n        //  transfer yDaiShares from the adapter contract to here\n        _esusuAdapterContract.TransferYDaiSharesToWithdrawalDelegate(currentBalanceShares);\n\n        //  Get the yDaiSharesForContractBeforeWithdrawal\n        uint yDaiSharesForContractBeforeWithdrawal = _yDai.balanceOf(address(this));\n\n        //  Withdraw the Dai. At this point, we have withdrawn the Dai ROI for this member and the dai ROI is in this contract, we will now transfer it to the member\n        address daiLendingAdapterContractAddress = _iDaiLendingService.GetDaiLendingAdapterAddress();\n\n        //  Before this function is called, we will have triggered a transfer of yDaiShares from the adapter to this withdrawal contract\n        _yDai.approve(daiLendingAdapterContractAddress,currentBalanceShares);\n        _iDaiLendingService.WithdrawByShares(Mroi,currentBalanceShares);\n\n\n        //  Now the Dai is in this contract, transfer the net ROI to the member and fee to treasury contract\n        sendROI(Mroi,member,CycleId);\n          \n        //  Get the yDaiSharesForContractAfterWithdrawal \n        uint256 yDaiSharesForContractAfterWithdrawal = _yDai.balanceOf(address(this));\n        \n        require(yDaiSharesForContractBeforeWithdrawal > yDaiSharesForContractAfterWithdrawal, \"yDai shares before withdrawal must be greater !!!\");\n        \n        //  Update the total balanceShares for this cycle \n        uint256 totalShares = currentBalanceShares.sub(yDaiSharesForContractBeforeWithdrawal.sub(yDaiSharesForContractAfterWithdrawal));\n        \n        //  Increase total number of beneficiaries by 1\n        uint256 totalBeneficiaries = _esusuStorage.GetEsusuCycleTotalBeneficiaries(CycleId).add(1);\n        \n\n        /*\n\n            - Check whether the TotalCycleDuration has elapsed, if that is the case then this cycle has expired\n            - If cycle has expired then we move the left over yDai to treasury\n        */\n\n        if(now > _esusuStorage.GetEsusuCycleDuration(CycleId)){\n\n            _esusuStorage.UpdateEsusuCycleState(CycleId, uint(CycleStateEnum.Expired));\n        }\n\n        //  Update Esusu Cycle During ROI withdrawal\n        _esusuStorage.UpdateEsusuCycleDuringROIWithdrawal(CycleId, totalShares,totalBeneficiaries);\n\n        //  Send the yDai shares back to the adapter contract, this contract should not hold any coins\n        _yDai.safeTransfer(address(_esusuAdapterContract),_yDai.balanceOf(address(this)));\n        \n        //  emit event \n        _emitROIWithdrawalEvent(member,Mroi,CycleId);\n    }\n\n    // function WithdrawROIFromEsusuCycle(uint256 esusuCycleId, address member)  public active onlyOwnerAndServiceContract {\n    //     //  Get Esusu Cycle Basic information\n    //     (uint256 CycleId, uint256 DepositAmount, uint256 CycleState,uint256 TotalMembers,uint256 MaxMembers) = _esusuStorage.GetEsusuCycleBasicInformation(esusuCycleId);\n                \n    //     require( _isMemberEligibleToWithdrawROI(esusuCycleId,member), \"Member cannot withdraw at this time\");\n        \n    //     uint256 currentBalanceShares = _esusuStorage.GetEsusuCycleTotalShares(esusuCycleId);\n                                \n    //     //  Implement our derived equation to get the amount of Dai to transfer to the member as ROI\n    //     uint256 Troi = currentBalanceShares.mul(_iDaiLendingService.getPricePerFullShare()).div(1e18).sub(_esusuStorage.GetEsusuCycleTotalAmountDeposited(esusuCycleId).sub(_esusuStorage.GetEsusuCycleTotalCapitalWithdrawn(esusuCycleId)));\n\n    //     uint256 Mroi = Troi.div(TotalMembers.sub(_esusuStorage.GetEsusuCycleTotalBeneficiaries(esusuCycleId)));\n        \n    //     //  Get the current yDaiSharesPerCycle and call the WithdrawByShares function on the daiLending Service\n    //     // uint256 yDaiSharesPerCycle = currentBalanceShares;\n        \n    //     //  transfer yDaiShares from the adapter contract to here \n    //     _esusuAdapterContract.TransferYDaiSharesToWithdrawalDelegate(currentBalanceShares);\n        \n    //     //  Get the yDaiSharesForContractBeforeWithdrawal \n    //     uint256 yDaiSharesForContractBeforeWithdrawal = _yDai.balanceOf(address(this));\n        \n    //     //  Withdraw the Dai. At this point, we have withdrawn the Dai ROI for this member and the dai ROI is in this contract, we will now transfer it to the member        \n    //     //  Before this function is called, we will have triggered a transfer of yDaiShares from the adapter to this withdrawal contract \n    //     _yDai.approve(_iDaiLendingService.GetDaiLendingAdapterAddress(),currentBalanceShares);\n    //     _iDaiLendingService.WithdrawByShares(Mroi,currentBalanceShares);\n        \n        \n    //     //  Now the Dai is in this contract, transfer the net ROI to the member and fee to treasury contract \n    //     sendROI(Mroi,member,CycleId);\n        \n        \n        \n        \n    //     require(yDaiSharesForContractBeforeWithdrawal > _yDai.balanceOf(address(this)), \"yDai shares before withdrawal must be greater !!!\");\n        \n    //     //  Update the total balanceShares for this cycle \n    //     uint256 totalShares = currentBalanceShares.sub(yDaiSharesForContractBeforeWithdrawal.sub(_yDai.balanceOf(address(this))));\n        \n    //     //  Increase total number of beneficiaries by 1\n        \n    //     /*\n                \n    //         - Check whether the TotalCycleDuration has elapsed, if that is the case then this cycle has expired\n    //         - If cycle has expired then we move the left over yDai to treasury\n    //     */\n        \n    //     if(now > _esusuStorage.GetEsusuCycleDuration(CycleId)){\n            \n    //         _esusuStorage.UpdateEsusuCycleState(CycleId, uint(CycleStateEnum.Expired));\n    //     }\n        \n    //     //  Update Esusu Cycle During ROI withdrawal \n    //     _esusuStorage.UpdateEsusuCycleDuringROIWithdrawal(CycleId, totalShares,_esusuStorage.GetEsusuCycleTotalBeneficiaries(CycleId).add(1));\n        \n    //     //  Send the yDai shares back to the adapter contract, this contract should not hold any coins\n    //     _yDai.transfer(address(_esusuAdapterContract),_yDai.balanceOf(address(this)));\n        \n    //     //  emit event \n    //     _emitROIWithdrawalEvent(member,Mroi,CycleId);\n    // }\n    \n    /*\n        This gets the fee percentage from the fee contract, deducts the fee and sends to treasury contract\n\n        For now let us assume fee percentage is 0.1%\n        - Get the fee\n        - Send the net ROI in dai to member\n        - Send the fee to the treasury\n        - Add member to beneficiary mapping\n    */\n    function sendROI(uint256 Mroi, address memberAddress, uint256 esusuCycleId) internal{       \n        //  get feeRate from fee contract\n\n        (uint256 minimum, uint256 maximum, uint256 exact, bool applies, RuleDefinition e)  = _savingsConfigContract.getRuleSet(_feeRuleKey);\n        /**\n            fee = ( (exact/precision)/(100) * roi)\n         */\n\n        uint256 feeRate = exact; \n        uint256 fee = Mroi.mul(feeRate).div(_feePrecision.mul(100));\n        \n        //  Deduct the fee\n        uint256 memberROINet = Mroi.sub(fee); \n        \n\n         //  Add member to beneficiary mapping\n\n        _esusuStorage.CreateEsusuCycleToBeneficiaryMapping(esusuCycleId,memberAddress,memberROINet); \n\n\n        //  Send ROI to member \n        _dai.safeTransfer(memberAddress, memberROINet);\n\n        uint256 creatorReward =  fee.mul(_groupCreatorRewardPercent).div(_feePrecision.mul(100));\n\n        uint256 finalFee = fee.sub(creatorReward);\n        //  Send deducted fee to treasury\n        //  Approve the treasury contract\n        _dai.approve(address(_treasuryContract),finalFee);\n        _treasuryContract.depositToken(address(_dai));\n\n        address cycleOwner = _esusuStorage.GetCycleOwner(esusuCycleId);\n        \n        \n\n        _dai.safeTransfer(cycleOwner, creatorReward);\n\n\n    }\n\n        /*\n        This function checks whether the user can withdraw at the time at which the user is making this call\n\n        - Check if cycle is valid\n        - Check if cycle is in active state\n        - Check if member is in cycle\n        - Check if member is a beneficiary\n        - Calculate member withdrawal time\n        - Check if member can withdraw at this time\n    */\n    function IsMemberEligibleToWithdrawROI(uint256 esusuCycleId, address member) active external view returns(bool){\n        \n        return _isMemberEligibleToWithdrawROI(esusuCycleId,member);\n\n    }\n\n    /*\n        This function checks whether the user can withdraw capital after the Esusu Cycle is complete.\n\n        The cycle must be in an inactive state before capital can be withdrawn\n    */\n    function IsMemberEligibleToWithdrawCapital(uint256 esusuCycleId, address member) active external view returns(bool){\n        \n        return _isMemberEligibleToWithdrawCapital(esusuCycleId,member);\n\n    }\n    \n    function _isMemberEligibleToWithdrawROI(uint256 esusuCycleId, address member) internal view returns(bool){\n        \n        //  Get Current EsusuCycleId\n        uint256 currentEsusuCycleId = _esusuStorage.GetEsusuCycleId();        \n        \n        require(esusuCycleId != 0 && esusuCycleId <= currentEsusuCycleId, \"Cycle ID must be within valid EsusuCycleId range\");\n        \n        uint256 cycleState = _esusuStorage.GetEsusuCycleState(esusuCycleId);\n        \n\n\n        require(cycleState == uint(CycleStateEnum.Active) || cycleState == uint(CycleStateEnum.Expired), \"Cycle must be in active or expired state\");\n\n        require(_isMemberInCycle(member,esusuCycleId), \"Member is not in this cycle\");\n        \n        require(!_isMemberABeneficiaryInCycle(member,esusuCycleId), \"Member is already a beneficiary\");\n        \n        uint256 memberWithdrawalTime = _calculateMemberWithdrawalTime(esusuCycleId,member); \n        \n        return now > memberWithdrawalTime;\n        \n    }\n    \n    function _isMemberEligibleToWithdrawCapital(uint256 esusuCycleId, address member) internal view returns(bool){\n        \n        //  Get Current EsusuCycleId\n        uint256 currentEsusuCycleId = _esusuStorage.GetEsusuCycleId();\n        \n        require(esusuCycleId != 0 && esusuCycleId <= currentEsusuCycleId, \"Cycle ID must be within valid EsusuCycleId range\");\n        \n        uint256 cycleState = _esusuStorage.GetEsusuCycleState(esusuCycleId);\n        \n        require(cycleState == uint(CycleStateEnum.Expired), \"Cycle must be in Expired state for you to withdraw capital\");\n\n        require(_isMemberInCycle(member,esusuCycleId), \"Member is not in this cycle\");\n        \n        require(_isMemberABeneficiaryInCycle(member,esusuCycleId), \"Member must be a beneficiary before you can withdraw capital\");\n\n        require(!_isMemberInWithdrawnCapitalMapping(member,esusuCycleId), \"Member can't withdraw capital twice\");\n\n        return true;\n\n    }\n    \n    function _isMemberInCycle(address memberAddress,uint256 esusuCycleId ) internal view returns(bool){\n        \n        return _esusuStorage.IsMemberInCycle(memberAddress,esusuCycleId);\n    }\n    \n    function _isMemberABeneficiaryInCycle(address memberAddress,uint256 esusuCycleId ) internal view returns(bool){\n        \n        uint256 amount = _esusuStorage.GetMemberCycleToBeneficiaryMapping(esusuCycleId, memberAddress);\n\n        //  If member has received money from this cycle, the amount recieved should be greater than 0\n\n        return amount > 0;\n    }\n    \n    function _isMemberInWithdrawnCapitalMapping(address memberAddress,uint256 esusuCycleId ) internal view returns(bool){\n        \n        uint256 amount = _esusuStorage.GetMemberWithdrawnCapitalInEsusuCycle(esusuCycleId, memberAddress);\n        //  If member has withdrawn capital from this cycle, the amount recieved should be greater than 0\n        return amount > 0;\n    }\n    \n    function _calculateMemberWithdrawalTime(uint256 cycleId, address member) internal view returns(uint){\n      \n        return _esusuStorage.CalculateMemberWithdrawalTime(cycleId,member);\n    }\n    \n    function _emitROIWithdrawalEvent(address member,uint256 Mroi, uint256 esusuCycleId) internal{\n\n        emit ROIWithdrawalEvent(now, member,esusuCycleId,Mroi);\n    }\n\n    function _emitXendTokenReward(address member, uint amount, uint esusuCycleId) internal {\n      emit XendTokenReward(now, member, esusuCycleId, amount);\n    }\n\n    function _rewardMember(uint totalCycleTime, address member, uint amount, uint esusuCycleId) internal {\n\n        uint256 reward = _rewardConfigContract.CalculateEsusuReward(totalCycleTime, amount);\n\n        // get Xend Token contract and mint token for member\n        _xendTokenContract.mint(payable(member), reward);\n\n        //  update the xend token reward for the member\n        _esusuStorage.UpdateMemberToXendTokeRewardMapping(member,reward);\n\n        //  increase the total number of xend token rewards distributed\n        _totalTokenReward = _totalTokenReward.add(reward);\n\n        _emitXendTokenReward(member, reward, esusuCycleId);\n    }\n\n    function DepricateContract(string calldata reason) external onlyOwner{\n        //  set _isActive to false\n        _isActive = false;\n\n        DepricateContractEvent(now, owner, reason);\n\n    }\n\n    modifier active(){\n        require(_isActive == true, \"This contract is depricated, use new version of contract\");\n        _;\n    }\n}\n"},"browser/EsusuService.sol":{"content":"pragma solidity >=0.6.6;\n\nimport \"./EsusuAdapter.sol\";\nimport \"./EsusuAdapterWithdrawalDelegate.sol\";\n\n\ncontract EsusuService{\n\n    address _owner;\n    EsusuAdapter _esusuAdapter;\n    EsusuAdapterWithdrawalDelegate _esusuAdapterWithdrawalDelegate;\n    \n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function TransferOwnership(address account) onlyOwner() external{\n        _owner = account;\n    }\n\n    function UpdateAdapter(address adapterAddress) onlyOwner() external{\n        _esusuAdapter = EsusuAdapter(adapterAddress);\n    }\n\n    function UpdateAdapterWithdrawalDelegate(address delegateAddress) onlyOwner() external{\n        _esusuAdapterWithdrawalDelegate = EsusuAdapterWithdrawalDelegate(delegateAddress);\n    }\n    \n    function GetGroupInformationByName(string calldata name) external view returns (uint256 groupId, string memory groupName, string memory groupSymbol, address groupCreatorAddress){\n        \n\n        return _esusuAdapter.GetGroupInformationByName(name);\n    }\n\n    function GetEsusuAdapterAddress() external view returns (address){\n        return address(_esusuAdapter);\n    }\n\n\n    function CreateGroup(string calldata name, string calldata symbol) external {\n\n           _esusuAdapter.CreateGroup(name,symbol,msg.sender);\n\n    }\n    \n    function CreateEsusu(uint256 groupId, uint256 depositAmount, uint256 payoutIntervalSeconds,uint256 startTimeInSeconds,uint256 maxMembers) external {\n        require(depositAmount > 0, \"Deposit Amount Can't Be Zero\");\n        _esusuAdapter.CreateEsusu(groupId,depositAmount,payoutIntervalSeconds,startTimeInSeconds,msg.sender,maxMembers);\n    }\n\n    /*\n        NOTE: member must approve _esusuAdapter to transfer deposit amount on his/her behalf\n    */\n    function JoinEsusu(uint256 esusuCycleId) external {\n        _esusuAdapter.JoinEsusu(esusuCycleId,msg.sender);\n    }\n\n\n    /*\n        This function returns information about a member in an esusu Cycle\n    */\n    function GetMemberCycleInfo(address memberAddress, uint256 esusuCycleId) \n                                external view returns(uint256 CycleId, address MemberId, uint256 TotalAmountDepositedInCycle, \n                                uint256 TotalPayoutReceivedInCycle, uint256 memberPosition){\n        \n        return _esusuAdapter.GetMemberCycleInfo(memberAddress,esusuCycleId);\n    }\n    \n     function GetEsusuCycle(uint256 esusuCycleId) external view returns(uint256 CycleId, uint256 DepositAmount, \n                                                            uint256 PayoutIntervalSeconds, uint256 CycleState, \n                                                            uint256 TotalMembers, uint256 TotalAmountDeposited, uint256 TotalShares, \n                                                            uint256 TotalCycleDurationInSeconds, uint256 TotalCapitalWithdrawn, uint256 CycleStartTimeInSeconds,\n                                                            uint256 TotalBeneficiaries, uint256 MaxMembers){\n    \n        return _esusuAdapter.GetEsusuCycle(esusuCycleId);                                                        \n    }\n    \n    function StartEsusuCycle(uint256 esusuCycleId) external {\n        _esusuAdapter.StartEsusuCycle(esusuCycleId);\n    }\n    \n    function WithdrawROIFromEsusuCycle(uint256 esusuCycleId) external{\n        _esusuAdapterWithdrawalDelegate.WithdrawROIFromEsusuCycle(esusuCycleId,msg.sender);\n    }\n    \n    function WithdrawCapitalFromEsusuCycle(uint256 esusuCycleId) external{\n        _esusuAdapterWithdrawalDelegate.WithdrawCapitalFromEsusuCycle(esusuCycleId,msg.sender);\n    }\n    \n    function IsMemberEligibleToWithdrawROI(uint256 esusuCycleId, address member) external view returns(bool){\n        return _esusuAdapterWithdrawalDelegate.IsMemberEligibleToWithdrawROI(esusuCycleId,member);\n    }\n    \n    function IsMemberEligibleToWithdrawCapital(uint256 esusuCycleId, address member) external view returns(bool){\n        return _esusuAdapterWithdrawalDelegate.IsMemberEligibleToWithdrawCapital(esusuCycleId,member);\n    }\n\n    function GetCurrentEsusuCycleId() external view returns(uint){\n        return _esusuAdapter.GetCurrentEsusuCycleId();\n    }\n\n    function GetTotalDeposits() external view returns(uint)  {\n        return _esusuAdapter.GetTotalDeposits();\n    }\n    modifier onlyOwner(){\n        require(_owner == msg.sender, \"Only owner can make this call\");\n        _;\n    }\n\n\n}\n"},"browser/IDaiLendingService.sol":{"content":"pragma solidity ^0.6.6;\n\ninterface IDaiLendingService {\n    function getPricePerFullShare() external view returns (uint256);\n\n    function save(uint256 amount) external;\n\n    function userShares() external view returns (uint256);\n\n    function userDaiBalance() external view returns (uint256);\n\n    function GetUserGrossRevenue() external view returns (uint256);\n\n    function GetNetRevenue() external view returns (uint256);\n\n    function GetUserDepositedDaiBalance() external view returns (uint256);\n\n    function Withdraw(uint256 amount) external;\n    \n    function WithdrawByShares(uint amount, uint sharesAmount) external;\n    \n    function GetDaiLendingAdapterAddress() external view returns (address);\n    \n    function WithdrawBySharesOnly(uint sharesAmount) external;\n}"},"browser/IDaiToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './IERC20.sol';\n\n/*\n    This contract returns the address of the Dai Stable Coin Smart Contract\n*/\ninterface IDaiToken is IERC20{\n     \n    function getDaiContractAddress() external view returns(address);      \n}\n\n"},"browser/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"browser/IEsusuAdapter.sol":{"content":"pragma solidity >=0.6.6;\n\ninterface IEsusuAdapter {\n    function TransferYDaiSharesToWithdrawalDelegate(uint amount) external;\n\n}"},"browser/IEsusuStorage.sol":{"content":"pragma solidity >=0.6.6;\n\ninterface IEsusuStorage {\n    /* Getters */\n    function GetEsusuCycleId() external view returns(uint);\n\n    function GetEsusuCycle(uint esusuCycleId) external view returns(uint CycleId, uint DepositAmount,\n                                                            uint PayoutIntervalSeconds, uint CycleState,\n                                                            uint TotalMembers, uint TotalAmountDeposited, uint TotalShares,\n                                                            uint TotalCycleDurationInSeconds, uint TotalCapitalWithdrawn, uint CycleStartTimeInSeconds,\n                                                            uint TotalBeneficiaries, uint MaxMembers);\n    function GetEsusuCycleBasicInformation(uint esusuCycleId) external view returns(uint CycleId, uint DepositAmount, uint CycleState,uint TotalMembers,uint MaxMembers);\n    function GetEsusuCycleTotalShares(uint esusuCycleId) external view returns(uint TotalShares);\n    function GetEsusuCycleStartTime(uint esusuCycleId)external view returns(uint EsusuCycleStartTime);\n    function GetEsusuCyclePayoutInterval(uint esusuCycleId)external view returns(uint EsusuCyclePayoutInterval);\n    function GetEsusuCycleTotalAmountDeposited(uint esusuCycleId)external view returns(uint EsusuCycleTotalAmountDeposited);\n    function GetEsusuCycleDuration(uint esusuCycleId)external view returns(uint EsusuCycleDuration);\n    function GetEsusuCycleTotalCapitalWithdrawn(uint esusuCycleId)external view returns(uint EsusuCycleTotalCapitalWithdrawn);\n    function GetEsusuCycleTotalBeneficiaries(uint esusuCycleId)external view returns(uint EsusuCycleTotalBeneficiaries);\n\n    function GetCycleOwner(uint esusuCycleId)external view returns(address EsusuCycleOwner);\n    function GetMemberCycleInfo(address memberAddress, uint esusuCycleId) external view returns(uint CycleId, address MemberId, uint TotalAmountDepositedInCycle, uint TotalPayoutReceivedInCycle, uint memberPosition);\n    function GetMemberWithdrawnCapitalInEsusuCycle(uint esusuCycleId,address memberAddress) external view returns (uint);\n    function GetMemberCycleToBeneficiaryMapping(uint esusuCycleId,address memberAddress) external view returns(uint);\n    function IsMemberInCycle(address memberAddress,uint esusuCycleId ) external view returns(bool);\n    function CalculateMemberWithdrawalTime(uint cycleId, address member) external view returns(uint);\n    function GetTotalDeposits() external view returns (uint);\n    function GetEsusuCycleState(uint esusuCycleId) external view returns (uint);\n    function GetTotalMembersInCycle(uint esusuCycleId)external view returns(uint TotalMembers); \n    function GetEsusuCycleTotalSharesAtStart(uint esusuCycleId) external view returns(uint TotalSharesAtStart);\n    function GetCycleIndexFromGroupId(uint groupId) external view returns(uint);\n    function GetCycleIdFromCycleIndexAndGroupId(uint groupId, uint cycleIndex) external view returns(uint);\n    function GetCycleIndexFromCycleCreator(address cycleCreator) external view returns(uint);\n    function GetCycleIdFromCycleIndexAndCycleCreator(uint cycleIndex, address cycleCreator) external view returns(uint);\n    function GetCycleIndexFromCycleMember(address member) external view returns(uint);\n    function GetCycleIdFromCycleIndexAndCycleMember(uint cycleIndex, address member) external view returns(uint);\n    function GetMemberXendTokenReward(address member) external returns(uint);\n\n\n    /* Setters - only owner or service contract can call */\n\n    function CreateEsusuCycleMapping(uint groupId, uint depositAmount, uint payoutIntervalSeconds,uint startTimeInSeconds, address owner, uint maxMembers) external;\n    function IncreaseTotalAmountDepositedInCycle(uint esusuCycleId, uint amount) external returns(uint);\n    function CreateMemberAddressToMemberCycleMapping(address member,uint esusuCycleId) external;\n    function IncreaseTotalMembersInCycle(uint esusuCycleId) external;\n    function CreateMemberPositionMapping(uint esusuCycleId, address member) external;\n    function IncreaseTotalDeposits(uint esusuCycleBalance) external;\n    function UpdateEsusuCycleDuringStart(uint esusuCycleId,uint cycleStateEnum, uint toalCycleDuration, uint totalShares,uint currentTime) external;\n    function UpdateEsusuCycleState(uint esusuCycleId,uint cycleStateEnum) external;\n    function CreateMemberCapitalMapping(uint esusuCycleId, address member) external;\n    function UpdateEsusuCycleDuringCapitalWithdrawal(uint esusuCycleId, uint cycleTotalShares, uint totalCapitalWithdrawnInCycle) external;\n    function UpdateEsusuCycleDuringROIWithdrawal(uint esusuCycleId, uint totalShares, uint totalBeneficiaries) external;\n    function CreateEsusuCycleToBeneficiaryMapping(uint esusuCycleId, address memberAddress, uint memberROINet) external;\n    function CreateMemberToCycleIndexToCycleIDMapping(address member, uint esusuCycleId) external;\n    function UpdateEsusuCycleSharesDuringJoin(uint esusuCycleId, uint memberShares) external;\n    function UpdateMemberToXendTokeRewardMapping(address member, uint rewardAmount) external;\n\n}\n"},"browser/IGroupSchema.sol":{"content":"pragma solidity 0.6.6;\n\ninterface IGroupSchema {\n    struct Group {\n        uint256 id;\n        string name;\n        string symbol;\n        bool exists;\n        address payable creatorAddress;\n    }\n\n    struct Cycle {\n        uint256 id;\n        uint256 groupId;\n        uint256 numberOfDepositors;\n        uint256 cycleStartTimeStamp;\n        uint256 cycleDuration;\n        uint256 maximumSlots;\n        uint256 cycleStakeAmount;\n        // represents the total stakes of every cycle member deposits\n        uint256 totalStakes;\n        //represents the total stakes of every cycle member withdrawal\n        uint256 stakesClaimed;\n        bool hasMaximumSlots;\n        bool exists;\n        CycleStatus cycleStatus;\n        // represents the number of cycle stakes that user's have cashed out on before the cycle has ended\n        uint256 stakesClaimedBeforeMaturity;\n    }\n\n    struct CycleFinancial {\n        bool exists;\n        uint256 cycleId;\n        //total underlying asset deposited into contract\n        uint256 underlyingTotalDeposits;\n        //total underlying asset that have been withdrawn by cycle members\n        uint256 underlyingTotalWithdrawn;\n        // underlying amount gotten after lending period has ended and shares have been reedemed for underlying asset;\n        uint256 underlyingBalance;\n        // lending shares representation of amount deposited in lending protocol\n        uint256 derivativeBalance;\n        // represents the total underlying crypto amount that has been cashed out before the cycle ended\n        uint256 underylingBalanceClaimedBeforeMaturity;\n        // represents the total derivative crypto amount that has been cashed out on before the cycle ended\n        uint256 derivativeBalanceClaimedBeforeMaturity;\n    }\n\n    struct CycleMember {\n        uint256 cycleId;\n        uint256 groupId;\n        uint256 totalLiquidityAsPenalty;\n        uint256 numberOfCycleStakes;\n        uint256 stakesClaimed;\n        bool exist;\n        address payable _address;\n        bool hasWithdrawn;\n    }\n\n    struct Member {\n        bool exists;\n        address payable _address;\n    }\n\n    struct GroupMember {\n        bool exists;\n        address payable _address;\n        uint256 groupId;\n    }\n\n    struct RecordIndex {\n        bool exists;\n        uint256 index;\n    }\n\n    enum CycleStatus {NOT_STARTED, ONGOING, ENDED}\n}\n"},"browser/IGroups.sol":{"content":"pragma solidity ^0.6.6;\nimport \"./IGroupSchema.sol\";\n\ninterface IGroups is IGroupSchema {\n\n    function getXendTokensReward(address payable receiverAddress)\n        external\n        view\n        returns (uint256);\n\n    function setXendTokensReward(address payable depositorAddress, uint256 amount)\n        external;\n    function getLengthOfTokenAddressesUsedInDeposit()\n        external\n        view\n        returns (uint256);\n\n    function incrementTokenDeposit(address tokenAddress, uint256 amount)\n        external\n        returns (uint256);\n\n    function decrementTokenDeposit(address tokenAddress, uint256 amount)\n        external\n        returns (uint256);\n\n    function getTokenDeposit(address tokenAddress)\n        external\n        view\n        returns (uint256);\n\n    function incrementEtherDeposit(uint256 amount) external returns (uint256);\n\n    function decrementEtherDeposit(uint256 amount) external returns (uint256);\n\n    function getEtherDeposit() external view returns (uint256);\n\n    function createMember(address payable depositor) external;\n\n    function getMember(address _address) external view returns (address);\n\n    function createGroup(\n        string calldata name,\n        string calldata symbol,\n        address groupCreator\n    ) external returns (uint256);\n\n    function updateGroup(\n        uint256 id,\n        string calldata name,\n        string calldata symbol,\n        address payable creatorAddress0\n    ) external;\n\n    function doesGroupExist(uint256 groupId) external view returns (bool);\n\n    function doesGroupExist(string calldata groupName)\n        external\n        view\n        returns (bool);\n\n    function doesMemberExist(address depositor) external view returns (bool);\n\n    function createGroupMember(uint256 groupId, address payable depositor)\n        external;\n\n    function getGroupMember(uint256 index)\n        external\n        view\n        returns (address payable _address, uint256 groupId);\n\n    function getGroupMembersDeepIndexer(uint256 groupId, address depositor)\n        external\n        view\n        returns (bool exists, uint256 index);\n\n    function getRecordIndexLengthForGroupMembersIndexer(uint256 groupId)\n        external\n        view\n        returns (uint256);\n\n    function getRecordIndexLengthForGroupMembersIndexerByDepositor(\n        address depositor\n    ) external view returns (uint256);\n\n    function getGroupMembersIndexer(uint256 groupId, uint256 indexerLocation)\n        external\n        view\n        returns (bool exist, uint256 index);\n\n    function getGroupMembersIndexerByDepositor(\n        address depositor,\n        uint256 indexerLocation\n    ) external view returns (bool exist, uint256 index);\n\n    function doesGroupMemberExist(uint256 groupId, address depositor)\n        external\n        view\n        returns (bool);\n\n    function getGroupIndexer(uint256 groupId)\n        external\n        view\n        returns (bool exist, uint256 index);\n\n    function getRecordIndexLengthForCreator(address groupCreator)\n        external\n        view\n        returns (uint256);\n\n    function getGroupForCreatorIndexer(\n        address groupCreator,\n        uint256 indexerLocation\n    ) external view returns (bool exist, uint256 index);\n\n    function getGroupIndexerByName(string calldata groupName)\n        external\n        view\n        returns (bool exist, uint256 index);\n\n    function getGroupById(uint256 groupId)\n        external\n        view\n        returns (\n            uint256,\n            string memory,\n            string memory,\n            address payable\n        );\n\n    function getGroupByIndex(uint256 index)\n        external\n        view\n        returns (\n            uint256,\n            string memory,\n            string memory,\n            address payable\n        );\n\n    function getGroupIndex(uint256 groupId) external view returns (uint256);\n\n    function activateStorageOracle(address oracle) external;\n\n    function deactivateStorageOracle(address oracle) external;\n\n    function reAssignStorageOracle(address newOracle) external;\n}\n"},"browser/IRewardConfig.sol":{"content":"pragma solidity ^0.6.6;\n\n\ninterface IRewardConfig{\n\n    function CalculateIndividualSavingsReward(uint totalCycleTimeInSeconds, uint amountDeposited) external view returns(uint);\n\n    function CalculateCooperativeSavingsReward(uint totalCycleTimeInSeconds, uint amountDeposited) external view returns(uint);\n    \n    function CalculateEsusuReward(uint totalCycleTimeInSeconds, uint amountDeposited) external view returns(uint);\n}"},"browser/ISavingsConfig.sol":{"content":"pragma solidity ^0.6.6;\nimport './ISavingsConfigSchema.sol';\n\n\n\n\n\ninterface  ISavingsConfig is ISavingsConfigSchema {\n   \n    function getRuleSet(string calldata ruleKey) external returns (uint ,uint , uint ,  bool ,RuleDefinition );\n    function getRuleManager(string calldata ruleKey) external returns (address);\n    function changeRuleCreator(string calldata ruleKey, address newRuleManager) external;\n    function createRule(string calldata ruleKey, uint minimum, uint maximum, uint exact, RuleDefinition ruleDefinition) external;\n    function modifyRule(string calldata ruleKey, uint minimum, uint maximum, uint exact,  RuleDefinition  ruleDefinition ) external;\n    function disableRule(string calldata ruleKey) external;\n    function enableRule(string calldata ruleKey)  external;\n    \n   \n    \n}"},"browser/ISavingsConfigSchema.sol":{"content":"pragma solidity 0.6.6;\n\ninterface ISavingsConfigSchema {\n    struct RuleSet {\n        uint256 minimum;\n        uint256 maximum;\n        uint256 exact;\n        bool applies;\n        RuleDefinition ruleDefinition;\n        bool exists;\n    }\n\n    enum RuleDefinition {RANGE, VALUE}\n}\n"},"browser/ITreasury.sol":{"content":"pragma solidity ^0.6.6;\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./IERC20.sol\";\n\ninterface ITreasury {\n    function depositToken(address token) external;\n\n    function getEtherBalance() external view returns (uint256);\n\n    function getTokenBalance(address token) external view returns (uint256);\n\n    function withdrawEthers(uint256 amount) external;\n\n    function withdrawTokens(address tokenAddress, uint256 amount) external;\n}\n"},"browser/IXendToken.sol":{"content":"pragma solidity ^0.6.6;\n\ninterface IXendToken {\n    function mint(address payable recipient, uint256 amount) external;\n}\n"},"browser/IYDaiToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport './IERC20.sol';\n\n/*\n    This interface returns the address of the YDai Token contract\n    Learn more about YTokens here: https://docs.yearn.finance/faq#ytokens\n    IYDaiV3: https://github.com/iearn-finance/itoken/blob/master/contracts/YDAIv3.sol\n*/\n\n\n\ninterface IYDaiToken is IERC20{\n \n      function recommend() external view returns (uint256);\n\n      function supplyDydx(uint256 amount) external returns(uint);\n    \n      function balance() external view returns (uint256);\n      function deposit(uint amount) external;\n      function withdraw(uint256 shares) external;\n      function getAave() external view returns (address);\n      function getAaveCore() external view returns (address);\n    \n      function approveToken() external;\n    \n      function balanceDydx() external view returns (uint256);\n      function balanceCompound() external view returns (uint256);\n      function balanceCompoundInToken() external view returns (uint256);\n      function balanceFulcrumInToken() external view returns (uint256);\n      function balanceFulcrum() external view returns (uint256);\n      function balanceAave() external view returns (uint256);\n    \n      function rebalance() external;\n    \n      function supplyAave(uint amount) external;\n      function supplyFulcrum(uint amount) external;\n      function supplyCompound(uint amount) external;\n    \n      // Invest ETH\n      function invest(uint256 _amount) external;\n    \n      // Invest self eth from external profits\n      function investSelf() external;\n    \n      function calcPoolValueInToken() external view returns (uint256);\n    \n      function getPricePerFullShare() external view returns (uint256);\n    \n      // Redeem any invested tokens from the pool\n      function redeem(uint256 _shares) external;\n    \n}"},"browser/Ownable.sol":{"content":"pragma solidity ^0.6.4;\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\ncontract Ownable {\n    address payable public owner;\n\n    constructor() internal {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized access to contract\");\n        _;\n    }\n\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n"},"browser/OwnableService.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.8.0;\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\ncontract OwnableService {\n    address payable public owner;\n    address payable public serviceContract;\n\n    constructor(address payable _serviceContract) internal {\n        owner = msg.sender;\n        serviceContract = _serviceContract;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized access to contract\");\n        _;\n    }\n\n    modifier onlyOwnerAndServiceContract() {\n        require(\n            msg.sender == owner || msg.sender == serviceContract,\n            \"Unauthorized access to contract\"\n        );\n        _;\n    }\n\n    function transferOwnership(address payable newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n\n    function transferContractOwnership(address payable newServiceContract)\n        public\n        onlyOwnerAndServiceContract\n    {\n        if (newServiceContract != address(0)) {\n            serviceContract = newServiceContract;\n        }\n    }\n}\n"},"browser/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"},"browser/SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}}