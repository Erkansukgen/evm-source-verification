{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "openNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0 <0.9.0;\n\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation with open minting.\ncontract OpenNFT {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    \n    string public name;\n    string public symbol;\n    \n    uint256 public totalSupply;\n    \n    mapping(address => uint256) public balanceOf;\n    mapping(uint256 => address) public ownerOf;\n    mapping(uint256 => string) public tokenURI;\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n    \n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_ALL_TYPEHASH = \n        keccak256(\"Permit(address owner,address spender,uint256 nonce,uint256 deadline)\");\n    \n    uint256 internal immutable DOMAIN_SEPARATOR_CHAIN_ID;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    mapping(uint256 => uint256) public nonces;\n    mapping(address => uint256) public noncesForAll;\n    \n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n        \n        DOMAIN_SEPARATOR_CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator();\n    }\n    \n    function _calculateDomainSeparator() internal view returns (bytes32 domainSeperator) {\n        domainSeperator = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n    \n    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeperator) {\n        domainSeperator = block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator();\n    }\n    \n    function supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\n    }\n    \n    function approve(address spender, uint256 tokenId) external {\n        address owner = ownerOf[tokenId];\n        \n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_APPROVED\");\n        \n        getApproved[tokenId] = spender;\n        \n        emit Approval(owner, spender, tokenId); \n    }\n    \n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n        \n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n    \n    function transfer(address to, uint256 tokenId) external {\n        require(msg.sender == ownerOf[tokenId], \"NOT_OWNER\");\n        \n        // This is safe because ownership is checked\n        // against decrement, and sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked {\n            balanceOf[msg.sender]--; \n        \n            balanceOf[to]++;\n        }\n        \n        delete getApproved[tokenId];\n        \n        ownerOf[tokenId] = to;\n        \n        emit Transfer(msg.sender, to, tokenId); \n    }\n\n    function transferFrom(address, address to, uint256 tokenId) public {\n        address owner = ownerOf[tokenId];\n        \n        require(\n            msg.sender == owner \n            || msg.sender == getApproved[tokenId]\n            || isApprovedForAll[owner][msg.sender], \n            \"NOT_APPROVED\"\n        );\n        \n        // This is safe because ownership is checked\n        // against decrement, and sum of all user\n        // balances can't exceed type(uint256).max!\n        unchecked { \n            balanceOf[owner]--; \n        \n            balanceOf[to]++;\n        }\n        \n        delete getApproved[tokenId];\n        \n        ownerOf[tokenId] = to;\n        \n        emit Transfer(owner, to, tokenId); \n    }\n    \n    function safeTransferFrom(address, address to, uint256 tokenId) external {\n        safeTransferFrom(address(0), to, tokenId, \"\");\n    }\n    \n    function safeTransferFrom(address, address to, uint256 tokenId, bytes memory data) public {\n        transferFrom(address(0), to, tokenId); \n        \n        if (to.code.length != 0) {\n            // selector = `onERC721Received(address,address,uint,bytes)`\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\n                msg.sender, address(0), tokenId, data));\n                \n            bytes4 selector = abi.decode(returned, (bytes4));\n            \n            require(selector == 0x150b7a02, \"NOT_ERC721_RECEIVER\");\n        }\n    }\n    \n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        \n        address owner = ownerOf[tokenId];\n        // This is reasonably safe from overflow because incrementing `nonces` beyond\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits!\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) \n                    && recoveredAddress == owner\n                    || isApprovedForAll[owner][recoveredAddress], \n                    \"INVALID_PERMIT_SIGNATURE\"\n            );\n        }\n        \n        getApproved[tokenId] = spender;\n\n        emit Approval(owner, spender, tokenId);\n    }\n    \n    function permitAll(\n        address owner,\n        address operator,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        \n        // This is reasonably safe from overflow because incrementing `nonces` beyond\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits!\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, operator, noncesForAll[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) \n                    && recoveredAddress == owner\n                    || isApprovedForAll[owner][recoveredAddress], \n                    \"INVALID_PERMIT_SIGNATURE\"\n            );\n        }\n        \n        isApprovedForAll[owner][operator] = true;\n\n        emit ApprovalForAll(owner, operator, true);\n    }\n    \n    function mint(address to, uint256 tokenId, string memory _tokenURI) external { \n        require(ownerOf[tokenId] == address(0), \"ALREADY_MINTED\");\n  \n        // This is reasonably safe from overflow because incrementing `nonces` beyond\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits,\n        // and because the sum of all user balances can't exceed type(uint256).max!\n        unchecked {\n            totalSupply++;\n            \n            balanceOf[to]++;\n        }\n        \n        ownerOf[tokenId] = to;\n        \n        tokenURI[tokenId] = _tokenURI;\n        \n        emit Transfer(address(0), to, tokenId); \n    }\n    \n    function burn(uint256 tokenId) external { \n        address owner = ownerOf[tokenId];\n        \n        require(ownerOf[tokenId] != address(0), \"NOT_MINTED\");\n        require(ownerOf[tokenId] == msg.sender, \"NOT_OWNER\");\n        \n        // This is safe because a user won't ever\n        // have a balance larger than totalSupply!\n        unchecked {\n            totalSupply--;\n        \n            balanceOf[owner]--;\n        }\n        \n        delete ownerOf[tokenId];\n        \n        delete tokenURI[tokenId];\n        \n        emit Transfer(owner, address(0), tokenId); \n    }\n}"
    }
  }
}