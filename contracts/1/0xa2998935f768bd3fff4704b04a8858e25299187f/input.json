{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/MCDMonitorV2.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nabstract contract StaticV2 {\n\n    enum Method { Boost, Repay }\n\n    struct CdpHolder {\n        uint128 minRatio;\n        uint128 maxRatio;\n        uint128 optimalRatioBoost;\n        uint128 optimalRatioRepay;\n        address owner;\n        uint cdpId;\n        bool boostEnabled;\n        bool nextPriceEnabled;\n    }\n\n    struct SubPosition {\n        uint arrPos;\n        bool subscribed;\n    }\n}\n\nabstract contract ISubscriptionsV2 is StaticV2 {\n\n    function getOwner(uint _cdpId) external view virtual returns(address);\n    function getSubscribedInfo(uint _cdpId) public view virtual returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt);\n    function getCdpHolder(uint _cdpId) public view virtual returns (bool subscribed, CdpHolder memory);\n} \n\nabstract contract DSProxyInterface {\n    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);\n    function owner() public virtual returns (address);\n} \n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function decimals() external view returns (uint256 digits);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n} \n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n}\n\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     */\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n} \n\n\ncontract AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public owner;\n    address public admin;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner\n    /// @param _admin Address of multisig that becomes admin\n    function setAdminByOwner(address _admin) public {\n        require(msg.sender == owner);\n        require(admin == address(0));\n\n        admin = _admin;\n    }\n\n    /// @notice Admin is able to set new admin\n    /// @param _admin Address of multisig that becomes new admin\n    function setAdminByAdmin(address _admin) public {\n        require(msg.sender == admin);\n\n        admin = _admin;\n    }\n\n    /// @notice Admin is able to change owner\n    /// @param _owner Address of new owner\n    function setOwnerByAdmin(address _owner) public {\n        require(msg.sender == admin);\n\n        owner = _owner;\n    }\n\n    /// @notice Destroy the contract\n    function kill() public onlyOwner {\n        selfdestruct(payable(owner));\n    }\n\n    /// @notice  withdraw stuck funds\n    function withdrawStuckFunds(address _token, uint _amount) public onlyOwner {\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(owner).transfer(_amount);\n        } else {\n            ERC20(_token).safeTransfer(owner, _amount);\n        }\n    }\n} \n\ncontract MCDMonitorProxyV2 {\n    function callExecute(address _owner, address _saverProxy, bytes memory _data) public payable {}\n} \n\ncontract ConstantAddressesMainnet {\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n    address public constant AUTOMATIC_LOGGER_ADDRESS = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;\n\n    // new MCD contracts\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n}\n\n\ncontract ConstantAddresses is ConstantAddressesMainnet {} \n\n\nabstract contract GasTokenInterface is ERC20 {\n    function free(uint256 value) public virtual returns (bool success);\n} \n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n} \n\nabstract contract Manager {\n    function last(address) virtual public returns (uint);\n    function cdpCan(address, uint, address) virtual public view returns (uint);\n    function ilks(uint) virtual public view returns (bytes32);\n    function owns(uint) virtual public view returns (address);\n    function urns(uint) virtual public view returns (address);\n    function vat() virtual public view returns (address);\n    function open(bytes32, address) virtual public returns (uint);\n    function give(uint, address) virtual public;\n    function cdpAllow(uint, address, uint) virtual public;\n    function urnAllow(address, uint) virtual public;\n    function frob(uint, int, int) virtual public;\n    function flux(uint, address, uint) virtual public;\n    function move(uint, address, uint) virtual public;\n    function exit(address, uint, address, uint) virtual public;\n    function quit(uint, address) virtual public;\n    function enter(address, uint) virtual public;\n    function shift(uint, uint) virtual public;\n} \n\nabstract contract Vat {\n\n    struct Urn {\n        uint256 ink;   // Locked Collateral  [wad]\n        uint256 art;   // Normalised Debt    [wad]\n    }\n\n    struct Ilk {\n        uint256 Art;   // Total Normalised Debt     [wad]\n        uint256 rate;  // Accumulated Rates         [ray]\n        uint256 spot;  // Price with Safety Margin  [ray]\n        uint256 line;  // Debt Ceiling              [rad]\n        uint256 dust;  // Urn Debt Floor            [rad]\n    }\n\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => Ilk)                       public ilks;\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\n\n    function can(address, address) virtual public view returns (uint);\n    function dai(address) virtual public view returns (uint);\n    function frob(bytes32, address, address, address, int, int) virtual public;\n    function hope(address) virtual public;\n    function move(address, address, uint) virtual public;\n    function fork(bytes32, address, address, int, int) virtual public;\n} \n\nabstract contract PipInterface {\n    function read() public virtual returns (bytes32);\n} \n\nabstract contract Spotter {\n    struct Ilk {\n        PipInterface pip;\n        uint256 mat;\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    uint256 public par;\n\n} \n\ncontract AutomaticLogger {\n    event CdpRepay(uint indexed cdpId, address indexed caller, uint amount, uint beforeRatio, uint afterRatio, address logger);\n    event CdpBoost(uint indexed cdpId, address indexed caller, uint amount, uint beforeRatio, uint afterRatio, address logger);\n\n    function logRepay(uint cdpId, address caller, uint amount, uint beforeRatio, uint afterRatio) public {\n        emit CdpRepay(cdpId, caller, amount, beforeRatio, afterRatio, msg.sender);\n    }\n\n    function logBoost(uint cdpId, address caller, uint amount, uint beforeRatio, uint afterRatio) public {\n        emit CdpBoost(cdpId, caller, amount, beforeRatio, afterRatio, msg.sender);\n    }\n}\n\n\n/// @title Implements logic that allows bots to call Boost and Repay\ncontract MCDMonitorV2 is AdminAuth, ConstantAddresses, DSMath, StaticV2 {\n\n    uint public REPAY_GAS_TOKEN = 25;\n    uint public BOOST_GAS_TOKEN = 25;\n\n    uint public MAX_GAS_PRICE = 200000000000; // 200 gwei\n\n    uint public REPAY_GAS_COST = 2000000;\n    uint public BOOST_GAS_COST = 2000000;\n\n    MCDMonitorProxyV2 public monitorProxyContract;\n    ISubscriptionsV2 public subscriptionsContract;\n    GasTokenInterface gasToken = GasTokenInterface(GAS_TOKEN_INTERFACE_ADDRESS);\n    address public automaticSaverProxyAddress;\n\n    Manager public manager = Manager(MANAGER_ADDRESS);\n    Vat public vat = Vat(VAT_ADDRESS);\n    Spotter public spotter = Spotter(SPOTTER_ADDRESS);\n    AutomaticLogger public logger = AutomaticLogger(AUTOMATIC_LOGGER_ADDRESS);\n\n    /// @dev Addresses that are able to call methods for repay and boost\n    mapping(address => bool) public approvedCallers;\n\n    modifier onlyApproved() {\n        require(approvedCallers[msg.sender]);\n        _;\n    }\n\n    constructor(address _monitorProxy, address _subscriptions, address _automaticSaverProxyAddress) public {\n        approvedCallers[msg.sender] = true;\n        approvedCallers[0xAED662abcC4FA3314985E67Ea993CAD064a7F5cF] = true;\n        approvedCallers[0xa5d330F6619d6bF892A5B87D80272e1607b3e34D] = true;\n        approvedCallers[0x5feB4DeE5150B589a7f567EA7CADa2759794A90A] = true;\n        approvedCallers[0x7ca06417c1d6f480d3bB195B80692F95A6B66158] = true;\n\n        monitorProxyContract = MCDMonitorProxyV2(_monitorProxy);\n        subscriptionsContract = ISubscriptionsV2(_subscriptions);\n        automaticSaverProxyAddress = _automaticSaverProxyAddress;\n    }\n\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _data Array of uints representing [cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _nextPrice Next price in Maker protocol\n    /// @param _joinAddr Address of collateral join for specific CDP\n    /// @param _exchangeAddress Address to call 0x exchange\n    /// @param _callData Bytes representing call data for 0x exchange\n    function repayFor(\n        uint[6] memory _data, // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\n        uint256 _nextPrice,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable onlyApproved {\n        if (gasToken.balanceOf(address(this)) >= REPAY_GAS_TOKEN) {\n            gasToken.free(REPAY_GAS_TOKEN);\n        }\n\n        uint ratioBefore;\n        bool isAllowed;\n        (isAllowed, ratioBefore) = canCall(Method.Repay, _data[0], _nextPrice);\n        require(isAllowed);\n\n        uint gasCost = calcGasCost(REPAY_GAS_COST);\n        _data[4] = gasCost;\n\n        monitorProxyContract.callExecute{value: msg.value}(subscriptionsContract.getOwner(_data[0]), automaticSaverProxyAddress, abi.encodeWithSignature(\"automaticRepay(uint256[6],address,address,bytes)\", _data, _joinAddr, _exchangeAddress, _callData));\n\n        uint ratioAfter;\n        bool isGoodRatio;\n        (isGoodRatio, ratioAfter) = ratioGoodAfter(Method.Repay, _data[0], _nextPrice);\n        // doesn't allow user to repay too much\n        require(isGoodRatio);\n\n        returnEth();\n\n        logger.logRepay(_data[0], msg.sender, _data[1], ratioBefore, ratioAfter);\n    }\n\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _data Array of uints representing [cdpId, collateralAmount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _nextPrice Next price in Maker protocol\n    /// @param _joinAddr Address of collateral join for specific CDP\n    /// @param _exchangeAddress Address to call 0x exchange\n    /// @param _callData Bytes representing call data for 0x exchange\n    function boostFor(\n        uint[6] memory _data, // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\n        uint256 _nextPrice,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable onlyApproved {\n        if (gasToken.balanceOf(address(this)) >= BOOST_GAS_TOKEN) {\n            gasToken.free(BOOST_GAS_TOKEN);\n        }\n\n        uint ratioBefore;\n        bool isAllowed;\n        (isAllowed, ratioBefore) = canCall(Method.Boost, _data[0], _nextPrice);\n        require(isAllowed);\n\n        uint gasCost = calcGasCost(BOOST_GAS_COST);\n        _data[4] = gasCost;\n\n        monitorProxyContract.callExecute{value: msg.value}(subscriptionsContract.getOwner(_data[0]), automaticSaverProxyAddress, abi.encodeWithSignature(\"automaticBoost(uint256[6],address,address,bytes)\", _data, _joinAddr, _exchangeAddress, _callData));\n\n        uint ratioAfter;\n        bool isGoodRatio;\n        (isGoodRatio, ratioAfter) = ratioGoodAfter(Method.Boost, _data[0], _nextPrice);\n        // doesn't allow user to boost too much\n        require(isGoodRatio);\n\n        returnEth();\n\n        logger.logBoost(_data[0], msg.sender, _data[1], ratioBefore, ratioAfter);\n    }\n\n/******************* INTERNAL METHODS ********************************/\n    function returnEth() internal {\n        // return if some eth left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n/******************* STATIC METHODS ********************************/\n\n    /// @notice Returns an address that owns the CDP\n    /// @param _cdpId Id of the CDP\n    function getOwner(uint _cdpId) public view returns(address) {\n        return manager.owns(_cdpId);\n    }\n\n    /// @notice Gets CDP info (collateral, debt)\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getCdpInfo(uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\n        address urn = manager.urns(_cdpId);\n\n        (uint collateral, uint debt) = vat.urns(_ilk, urn);\n        (,uint rate,,,) = vat.ilks(_ilk);\n\n        return (collateral, rmul(debt, rate));\n    }\n\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    function getPrice(bytes32 _ilk) public view returns (uint) {\n        (, uint mat) = spotter.ilks(_ilk);\n        (,,uint spot,,) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    /// @notice Gets CDP ratio\n    /// @param _cdpId Id of the CDP\n    /// @param _nextPrice Next price for user\n    function getRatio(uint _cdpId, uint _nextPrice) public view returns (uint) {\n        bytes32 ilk = manager.ilks(_cdpId);\n        uint price = (_nextPrice == 0) ? getPrice(ilk) : _nextPrice;\n\n        (uint collateral, uint debt) = getCdpInfo(_cdpId, ilk);\n\n        if (debt == 0) return 0;\n\n        return rdiv(wmul(collateral, price), debt) / (10 ** 18);\n    }\n\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by MCDMonitor to enforce the min/max check\n    function canCall(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\n        bool subscribed;\n        CdpHolder memory holder;\n        (subscribed, holder) = subscriptionsContract.getCdpHolder(_cdpId);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if using next price is allowed\n        if (_nextPrice > 0 && !holder.nextPriceEnabled) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        // check if owner is still owner\n        if (getOwner(_cdpId) != holder.owner) return (false, 0);\n\n        uint currRatio = getRatio(_cdpId, _nextPrice);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }\n\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    function ratioGoodAfter(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\n        CdpHolder memory holder;\n\n        (, holder) = subscriptionsContract.getCdpHolder(_cdpId);\n\n        uint currRatio = getRatio(_cdpId, _nextPrice);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }\n\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }\n\n/******************* OWNER ONLY OPERATIONS ********************************/\n\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for boost method\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change max gas price\n    /// @param _maxGasPrice New max gas price\n    function changeMaxGasPrice(uint _maxGasPrice) public onlyOwner {\n        require(_maxGasPrice < 500000000000);\n\n        MAX_GAS_PRICE = _maxGasPrice;\n    }\n\n    /// @notice Allows owner to change the amount of gas token burned per function call\n    /// @param _gasAmount Amount of gas token\n    /// @param _isRepay Flag to know for which function we are setting the gas token amount\n    function changeGasTokenAmount(uint _gasAmount, bool _isRepay) public onlyOwner {\n        if (_isRepay) {\n            REPAY_GAS_TOKEN = _gasAmount;\n        } else {\n            BOOST_GAS_TOKEN = _gasAmount;\n        }\n    }\n\n    /// @notice Adds a new bot address which will be able to call repay/boost\n    /// @param _caller Bot address\n    function addCaller(address _caller) public onlyOwner {\n        approvedCallers[_caller] = true;\n    }\n\n    /// @notice Removes a bot address so it can't call repay/boost\n    /// @param _caller Bot address\n    function removeCaller(address _caller) public onlyOwner {\n        approvedCallers[_caller] = false;\n    }\n\n}"
    }
  }
}