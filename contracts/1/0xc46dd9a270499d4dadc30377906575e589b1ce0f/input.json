{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Untitled3.sol": {
      "content": "/*\n██╗     ███████╗██╗  ██╗    \n██║     ██╔════╝╚██╗██╔╝    \n██║     █████╗   ╚███╔╝     \n██║     ██╔══╝   ██╔██╗     \n███████╗███████╗██╔╝ ██╗    \n╚══════╝╚══════╝╚═╝  ╚═╝                                                                             \n██╗      ██████╗  ██████╗██╗  ██╗███████╗██████╗     \n██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    \n██║     ██║   ██║██║     █████╔╝ █████╗  ██████╔╝    \n██║     ██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    \n███████╗╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    \n╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\nDEAR MSG.SENDER(S):\n/ LXL is a project in beta\n// Please audit & use at your own risk\n/// Entry into LXL shall not create an attorney/client relationship\n//// Likewise, LXL should not be construed as legal advice or replacement for professional counsel\n///// STEAL THIS C0D3SL4W \n~presented by LexDAO LLC \\+|+/ \n*/\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.7.5;\n\ninterface IERC20 { // brief interface for erc20 token\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\nlibrary Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n\nlibrary SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\n    using Address for address;\n    \n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\n    }\n    \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\n    }\n    \n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n        (bool success, bytes memory returnData) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returnData.length > 0) { // return data is optional\n            require(abi.decode(returnData, (bool)), \"SafeERC20: erc20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary SafeMath { // arithmetic wrapper for under/overflow check\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n    \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n        return c;\n    }\n    \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        return c;\n    }\n}\n\ncontract ReentrancyGuard { // call wrapper for reentrancy check - see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\n/**\n * @title LexLocker.\n * @author LexDAO LLC.\n * @notice Token locker registry with embedded terms and resolution protocol. \n */\ncontract LexLocker is ReentrancyGuard { \n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /*$<⚖️️> LXL <⚔️>$*/\n    address public manager; // account managing LXL settings - see 'Manager Functions' - updateable by manager\n    address public swiftResolverToken; // token required to participate as swift resolver - updateable by manager\n    address public userRewardToken; // token for LXL user rewards - updateable by manager\n    address public wETH; // ether token wrapper contract reference - updateable by manager\n    uint256 public lockerCount; // lockers counted into LXL registry\n    uint256 public MAX_DURATION; // time limit in seconds on token lockup - default 63113904 (2-year) - updateable by manager\n    uint256 public resolutionRate; // rate to determine resolution fee for disputed locker (e.g., 20 = 5% of remainder) - updateable by manager\n    uint256 public swiftResolverTokenBalance; // balance required in `swiftResolverToken` to participate as swift resolver - updateable by manager\n    uint256 public userReward; // reward amount granted to LXL users in `userRewardToken`- updateable by manager\n    string public lockerTerms; // general terms wrapping LXL - updateable by manager\n    string[] public marketTerms; // embedded market LXL terms - attach to locker `details` (e.g., \"MT:1\") - updateable by manager\n    string[] public resolutions; // locker resolutions stamped by LXL resolvers\n    \n    mapping(address => uint256[]) private registrations; // tracks registered lockers per account (client/provider)\n    mapping(address => bool) public swiftResolverRegistrations; // tracks registered swift resolvers\n    mapping(uint256 => ADR) public adrs; // tracks ADR details for registered lockers\n    mapping(uint256 => Locker) public lockers; // tracks registered lockers details\n    \n    event DepositLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\n    event RegisterLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\n    event ConfirmLocker(address token, uint256 registration, uint256 sum); \n    event RequestLockerResolution(address indexed client, address indexed counterparty, address indexed resolver, address token, uint256 registration, uint256 sum, string details, bool swiftResolver); \n    event Release(uint256 milestone, uint256 payment, uint256 registration); \n    event Withdraw(address indexed client, uint256 registration);\n    event AssignClientOracle(address indexed clientOracle, uint256 registration);\n    event ClientProposeResolver(address indexed proposedResolver, uint256 registration, string details);\n    event ProviderProposeResolver(address indexed proposedResolver, uint256 registration, string details);\n    event UpdateSwiftResolverStatus(address indexed swiftResolver, string details, bool registered);\n    event Lock(address indexed caller, uint256 registration, string details);\n    event Resolve(address indexed resolver, uint256 clientAward, uint256 providerAward, uint256 registration, uint256 resolutionFee, string resolution); \n    event AddMarketTerms(uint256 index, string terms);\n    event AmendMarketTerms(uint256 index, string terms);\n    event UpdateLockerSettings(address indexed manager, address swiftResolverToken, address userRewardToken, address wETH, uint256 MAX_DURATION, uint256 resolutionRate, uint256 swiftResolverTokenBalance, uint256 userReward, string lockerTerms);\n    event TributeToManager(address indexed caller, uint256 amount, string details);\n\n    struct ADR {  \n        address proposedResolver;\n        address resolver;\n        uint8 clientProposedResolver;\n        uint8 providerProposedResolver;\n        uint256 clientAward;\n        uint256 providerAward;\n\t    uint256 resolutionRate;\n\t    string resolution;\n\t    bool swiftResolver;\n    }\n    \n    struct Locker {  \n        address client; \n        address clientOracle;\n        address provider;\n        address token;\n        uint8 confirmed;\n        uint8 locked;\n        uint256[] amount;\n        uint256 currentMilestone;\n        uint256 milestones;\n        uint256 released;\n        uint256 sum;\n        uint256 termination;\n        string details; \n    }\n    \n    constructor(\n        address _manager, \n        address _swiftResolverToken,\n        address _userRewardToken,\n        address _wETH,\n        uint256 _MAX_DURATION,\n        uint256 _resolutionRate, \n        uint256 _swiftResolverTokenBalance, \n        uint256 _userReward,\n        string memory _lockerTerms\n    ) {\n        require(_resolutionRate > 0, \"_resolutionRate < 1\");\n        \n        manager = _manager;\n        swiftResolverToken = _swiftResolverToken;\n        userRewardToken = _userRewardToken;\n        wETH = _wETH;\n        MAX_DURATION = _MAX_DURATION;\n        resolutionRate = _resolutionRate;\n        swiftResolverTokenBalance = _swiftResolverTokenBalance;\n        userReward = _userReward;\n        lockerTerms = _lockerTerms;\n    }\n\n    /***************\n    LOCKER FUNCTIONS\n    ***************/\n    // ************\n    // REGISTRATION\n    // ************\n    /**\n     * @notice LXL can be registered as deposit from `client` for benefit of `provider`.\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\n     * @param provider Account to receive registered `amount`s.\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\n     * @param token Token address for `amount` deposit.\n     * @param amount Array of milestone `amount`s to be sent to `provider` on call of `release()`.\n     * @param termination Exact `termination` date in seconds since epoch.\n     * @param details Context re: LXL.\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\n     */\n    function depositLocker( // CLIENT-TRACK\n        address clientOracle, \n        address provider,\n        address resolver,\n        address token,\n        uint256[] calldata amount, \n        uint256 termination, \n        string memory details,\n        bool swiftResolver \n    ) external nonReentrant payable returns (uint256) {\n        require(msg.sender != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\n        \n        uint256 sum;\n        for (uint256 i = 0; i < amount.length; i++) {\n            sum = sum.add(amount[i]);\n        }\n\n        if (msg.value > 0) {\n            address weth = wETH;\n            require(token == weth && msg.value == sum, \"!ethBalance\");\n            (bool success, ) = weth.call{value: msg.value}(\"\");\n            require(success, \"!ethCall\");\n            IERC20(weth).safeTransfer(address(this), msg.value);\n        } else {\n            IERC20(token).safeTransferFrom(msg.sender, address(this), sum);\n        }\n        \n        lockerCount++;\n        uint256 registration = lockerCount;\n        \n        registrations[msg.sender].push(registration);\n        registrations[provider].push(registration);\n        \n        adrs[registration] = ADR( \n            address(0),\n            resolver,\n            0,\n            0,\n            0,\n            0,\n\t        resolutionRate, \n\t        \"\",\n\t        swiftResolver);\n\n        lockers[registration] = Locker( \n            msg.sender, \n            clientOracle,\n            provider,\n            token,\n            1,\n            0,\n            amount,\n            1,\n            amount.length,\n            0,\n            sum,\n            termination,\n            details);\n        \n        if (userReward > 0) {IERC20(userRewardToken).transfer(msg.sender, userReward);} // grant LXL user reward\n\n        emit DepositLocker(msg.sender, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \n        \n\t    return registration;\n    }\n    \n    /**\n     * @notice LXL can be registered as single deposit (lump sum) from `client` for benefit of `provider`.\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\n     * @param provider Account to receive registered `amount`s.\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\n     * @param token Token address for `amount` deposit.\n     * @param sum Lump `sum` to be sent to `provider` on call of `release()`.\n     * @param termination Exact `termination` date in seconds since epoch.\n     * @param details Context re: LXL.\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\n     */\n    function depositLockerSingleMilestone( // CLIENT-TRACK\n        address clientOracle, \n        address provider,\n        address resolver,\n        address token,\n        uint256 sum, \n        uint256 termination, \n        string calldata details,\n        bool swiftResolver \n    ) external nonReentrant payable returns (uint256) {\n        require(msg.sender != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\n        \n        if (msg.value > 0) {\n            address weth = wETH;\n            require(token == weth && msg.value == sum, \"!ethBalance\");\n            (bool success, ) = weth.call{value: msg.value}(\"\");\n            require(success, \"!ethCall\");\n            IERC20(weth).safeTransfer(address(this), msg.value);\n        } else {\n            IERC20(token).safeTransferFrom(msg.sender, address(this), sum);\n        }\n        \n        uint256[] memory amount = new uint256[](1);\n        amount[0] = sum;\n        \n        lockerCount++;\n        uint256 registration = lockerCount;\n        \n        registrations[msg.sender].push(registration);\n        registrations[provider].push(registration);\n        \n        adrs[registration] = ADR( \n            address(0),\n            resolver,\n            0,\n            0,\n            0,\n            0,\n\t        resolutionRate, \n\t        \"\",\n\t        swiftResolver);\n\n        lockers[registration] = Locker( \n            msg.sender, \n            clientOracle,\n            provider,\n            token,\n            1,\n            0,\n            amount,\n            1,\n            1,\n            0,\n            sum,\n            termination,\n            details);\n        \n        if (userReward > 0) {IERC20(userRewardToken).transfer(msg.sender, userReward);} // grant LXL user reward\n\n        emit DepositLocker(msg.sender, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \n        \n\t    return registration;\n    }\n    \n    /**\n     * @notice LXL can be registered as `provider` request for `client` deposit (by calling `confirmLocker()`).\n     * @param client Account to provide `sum` deposit and call `release()` of registered `amount`s.\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\n     * @param provider Account to receive registered `amount`s.\n     * @param resolver Account that can call `resolve()` to award `sum` remainder between LXL parties.\n     * @param token Token address for `amount` deposit.\n     * @param amount Array of milestone `amount`s to be sent to `provider` on call of `release()`.\n     * @param termination Exact `termination` date in seconds since epoch.\n     * @param details Context re: LXL.\n     * @param swiftResolver If `true`, `sum` remainder can be resolved by holders of `swiftResolverToken`.\n     */\n    function registerLocker( // PROVIDER-TRACK\n        address client,\n        address clientOracle, \n        address provider,\n        address resolver,\n        address token,\n        uint256[] calldata amount, \n        uint256 termination, \n        string memory details,\n        bool swiftResolver \n    ) external nonReentrant returns (uint256) {\n        require(client != resolver && clientOracle != resolver && provider != resolver, \"client/clientOracle/provider = resolver\");\n        require(termination <= block.timestamp.add(MAX_DURATION), \"duration maxed\");\n        \n        uint256 sum;\n        for (uint256 i = 0; i < amount.length; i++) {\n            sum = sum.add(amount[i]);\n        }\n \n        lockerCount++;\n        uint256 registration = lockerCount;\n        \n        registrations[client].push(registration);\n        registrations[provider].push(registration);\n       \n        adrs[registration] = ADR( \n            address(0),\n            resolver,\n            0,\n            0,\n            0,\n            0,\n\t        resolutionRate, \n\t        \"\",\n\t        swiftResolver);\n\n        lockers[registration] = Locker( \n            client, \n            clientOracle,\n            provider,\n            token,\n            0,\n            0,\n            amount,\n            1,\n            amount.length,\n            0,\n            sum,\n            termination,\n            details);\n        \n        if (userReward > 0) {IERC20(userRewardToken).transfer(msg.sender, userReward);} // grant LXL user reward\n\n        emit RegisterLocker(client, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \n        \n\t    return registration;\n    }\n    \n    /**\n     * @notice LXL `client` can confirm after `registerLocker()` is called to deposit `sum` for `provider`.\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\n     * @param registration Registered LXL number.\n     */\n    function confirmLocker(uint256 registration) external nonReentrant payable { // PROVIDER-TRACK\n        Locker storage locker = lockers[registration];\n        \n        require(msg.sender == locker.client, \"!client\");\n        require(locker.confirmed == 0, \"confirmed\");\n        \n        address token = locker.token;\n        uint256 sum = locker.sum;\n        \n        if (msg.value > 0) {\n            address weth = wETH;\n            require(token == weth && msg.value == sum, \"!ethBalance\");\n            (bool success, ) = weth.call{value: msg.value}(\"\");\n            require(success, \"!ethCall\");\n            IERC20(weth).safeTransfer(address(this), msg.value);\n        } else {\n            IERC20(token).safeTransferFrom(msg.sender, address(this), sum);\n        }\n        \n        locker.confirmed = 1;\n        \n        emit ConfirmLocker(token, registration, sum); \n    }\n    \n    /**\n     * @notice LXL depositor (`client`) can request direct resolution between selected `counterparty` over `sum`. E.g., staked wager to benefit charity as `counterparty`.\n     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call. \n     * @param counterparty Other account (`provider`) that can receive award from `resolver`.\n     * @param resolver Account that can call `resolve()` to award `sum` between LXL parties.\n     * @param token Token address for `sum`.\n     * @param sum Lump `sum` amount for resolution.\n     * @param details Context re: resolution request.\n     * @param swiftResolver If `true`, `sum` can be resolved by holders of `swiftResolverToken`.\n     */\n    function requestLockerResolution(address counterparty, address resolver, address token, uint256 sum, string calldata details, bool swiftResolver) external nonReentrant payable returns (uint256) {\n        require(msg.sender != resolver && counterparty != resolver, \"client/counterparty = resolver\");\n        \n        if (msg.value > 0) {\n            address weth = wETH;\n            require(token == weth && msg.value == sum, \"!ethBalance\");\n            (bool success, ) = weth.call{value: msg.value}(\"\");\n            require(success, \"!ethCall\");\n            IERC20(weth).safeTransfer(address(this), msg.value);\n        } else {\n            IERC20(token).safeTransferFrom(msg.sender, address(this), sum);\n        }\n        \n        uint256[] memory amount = new uint256[](1);\n        amount[0] = sum;\n        \n        lockerCount++;\n        uint256 registration = lockerCount;\n        \n        registrations[msg.sender].push(registration);\n        registrations[counterparty].push(registration);\n        \n        adrs[registration] = ADR( \n            address(0),\n            resolver,\n            0,\n            0,\n            0,\n            0,\n\t        resolutionRate, \n\t        \"\",\n\t        swiftResolver);\n     \n        lockers[registration] = Locker( \n            msg.sender, \n            address(0),\n            counterparty,\n            token,\n            1,\n            1,\n            amount,\n            0,\n            0,\n            0,\n            sum,\n            0,\n            details);\n        \n        if (userReward > 0) {IERC20(userRewardToken).transfer(msg.sender, userReward);} // grant LXL user reward\n\n        emit RequestLockerResolution(msg.sender, counterparty, resolver, token, registration, sum, details, swiftResolver); \n        \n\t    return registration;\n    }\n    \n    // ***********\n    // CLIENT MGMT\n    // ***********\n    /**\n     * @notice LXL `client` can assign account as `clientOracle` to help call `release()` and `withdraw()`.\n     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\n     * @param registration Registered LXL number.\n     */\n    function assignClientOracle(address clientOracle, uint256 registration) external nonReentrant {\n        ADR storage adr = adrs[registration];\n        Locker storage locker = lockers[registration];\n        \n        require(msg.sender == locker.client, \"!client\");\n        require(clientOracle != adr.resolver, \"clientOracle = resolver\");\n        require(locker.locked == 0, \"locked\");\n\t    require(locker.released < locker.sum, \"released\");\n        \n        locker.clientOracle = clientOracle;\n        \n        emit AssignClientOracle(clientOracle, registration);\n    }\n    \n    /**\n     * @notice LXL `client` or `clientOracle` can release milestone `amount` to `provider`. \n     * @param registration Registered LXL number.\n     */\n    function release(uint256 registration) external nonReentrant {\n    \tLocker storage locker = lockers[registration];\n    \t\n    \tuint256 milestone = locker.currentMilestone-1;\n        uint256 payment = locker.amount[milestone];\n        uint256 released = locker.released;\n        uint256 sum = locker.sum;\n\t    \n\t    require(msg.sender == locker.client || msg.sender == locker.clientOracle, \"!client/oracle\");\n\t    require(locker.confirmed == 1, \"!confirmed\");\n\t    require(locker.locked == 0, \"locked\");\n\t    require(released < sum, \"released\");\n\n        IERC20(locker.token).safeTransfer(locker.provider, payment);\n        locker.released = released.add(payment);\n        \n        if (locker.released < sum) {locker.currentMilestone++;}\n        \n\t    emit Release(milestone+1, payment, registration); \n    }\n    \n    /**\n     * @notice LXL `client` or `clientOracle` can withdraw `sum` remainder after `termination`. \n     * @dev `release()` can still be called by `client` or `clientOracle` after `termination` to preserve extension option. \n     * @param registration Registered LXL number.\n     */\n    function withdraw(uint256 registration) external nonReentrant {\n    \tLocker storage locker = lockers[registration];\n    \t\n    \taddress client = locker.client;\n    \tuint256 released = locker.released;\n    \tuint256 sum = locker.sum;\n        \n        require(msg.sender == client || msg.sender == locker.clientOracle, \"!client/oracle\");\n        require(locker.confirmed == 1, \"!confirmed\");\n        require(locker.locked == 0, \"locked\");\n        require(released < sum, \"released\");\n        require(locker.termination < block.timestamp, \"!terminated\");\n        \n        IERC20(locker.token).safeTransfer(client, sum.sub(released));\n        locker.released = sum; \n        \n\t    emit Withdraw(client, registration); \n    }\n    \n    // **********\n    // RESOLUTION\n    // **********\n    /**\n     * @notice LXL `client` or `provider` can lock to freeze release and withdrawal of `sum` remainder until `resolver` calls `resolve()`. \n     * @dev `lock()` can be called repeatedly to allow LXL parties to continue to provide context until resolution. \n     * @param registration Registered LXL number.\n     * @param details Context re: lock / dispute.\n     */\n    function lock(uint256 registration, string calldata details) external nonReentrant {\n        Locker storage locker = lockers[registration]; \n        \n        require(msg.sender == locker.client || msg.sender == locker.provider, \"!party\"); \n        require(locker.confirmed == 1, \"!confirmed\");\n        require(locker.released < locker.sum, \"released\");\n\n\t    locker.locked = 1; \n\t    \n\t    emit Lock(msg.sender, registration, details);\n    }\n    \n    /**\n     * @notice After LXL is locked, selected `resolver` awards `sum` remainder between `client` and `provider` minus fee.\n     * @param clientAward Remainder awarded to `client`.\n     * @param providerAward Remainder awarded to `provider`.\n     * @param registration Registered LXL number.\n     * @param resolution Context re: resolution.\n     */\n    function resolve(uint256 clientAward, uint256 providerAward, uint256 registration, string calldata resolution) external nonReentrant {\n        ADR storage adr = adrs[registration];\n        Locker storage locker = lockers[registration];\n        \n        address token = locker.token;\n        uint256 released = locker.released;\n\t    uint256 sum = locker.sum;\n\t    // calculate resolution fee as set on registration:\n\t    uint256 remainder = sum.sub(released); \n\t    uint256 resolutionFee = remainder.div(adr.resolutionRate); \n\t    \n\t    require(locker.locked == 1, \"!locked\"); \n\t    require(released < sum, \"released\");\n\t    require(clientAward.add(providerAward) == remainder.sub(resolutionFee), \"awards != remainder - fee\");\n\t    \n\t    if (adr.swiftResolver) {\n\t        require(msg.sender != locker.client && msg.sender != locker.provider, \"client/provider = swiftResolver\");\n\t        require(IERC20(swiftResolverToken).balanceOf(msg.sender) >= swiftResolverTokenBalance && swiftResolverRegistrations[msg.sender], \"!swiftResolverTokenBalance/registered\");\n        } else {\n            require(msg.sender == adr.resolver, \"!resolver\");\n        }\n        \n        IERC20(token).safeTransfer(msg.sender, resolutionFee);\n        IERC20(token).safeTransfer(locker.client, clientAward);\n        IERC20(token).safeTransfer(locker.provider, providerAward);\n        \n        adr.clientAward = clientAward;\n\t    adr.providerAward = providerAward;\n\t    adr.resolution = resolution;\n\t    locker.released = sum; \n\t    resolutions.push(resolution);\n\t    \n\t    emit Resolve(msg.sender, clientAward, providerAward, registration, resolutionFee, resolution);\n    }\n    \n    /**\n     * @notice Fallback to allow LXL party to suggest new `resolver` to counterparty.\n     * @dev LXL `client` calls to update `resolver` selection - if matches `provider` suggestion or confirmed, `resolver` updates. \n     * @param proposedResolver Proposed account to resolve LXL.\n     * @param registration Registered LXL number.\n     * @param details Context re: proposed `resolver`.\n     */\n    function clientProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \n        ADR storage adr = adrs[registration];\n        Locker storage locker = lockers[registration]; \n        \n        require(msg.sender == locker.client, \"!client\"); \n        require(msg.sender != proposedResolver && locker.clientOracle != proposedResolver && locker.provider != proposedResolver, \"client/clientOracle/provider = proposedResolver\");\n        require(adr.clientProposedResolver == 0, \"pending\");\n\t    require(locker.released < locker.sum, \"released\");\n        \n        if (adr.proposedResolver == proposedResolver) {\n            adr.resolver = proposedResolver;\n        } \n\n\t    adr.proposedResolver = proposedResolver; \n\t    adr.clientProposedResolver = 1;\n\t    adr.providerProposedResolver = 0;\n\t    \n\t    emit ClientProposeResolver(proposedResolver, registration, details);\n    }\n    \n    /**\n     * @notice Fallback to allow LXL party to suggest new `resolver` to counterparty.\n     * @dev LXL `provider` calls to update `resolver` selection - if matches `client` suggestion or confirmed, `resolver` updates. \n     * @param proposedResolver Proposed account to resolve LXL.\n     * @param registration Registered LXL number.\n     * @param details Context re: proposed `resolver`.\n     */\n    function providerProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \n        ADR storage adr = adrs[registration];\n        Locker storage locker = lockers[registration]; \n        \n        require(msg.sender == locker.provider, \"!provider\"); \n        require(locker.client != proposedResolver && locker.clientOracle != proposedResolver && msg.sender != proposedResolver, \"client/clientOracle/provider = proposedResolver\");\n        require(adr.providerProposedResolver == 0, \"pending\");\n\t    require(locker.released < locker.sum, \"released\");\n\n\t    if (adr.proposedResolver == proposedResolver) {\n            adr.resolver = proposedResolver;\n        } \n\t    \n\t    adr.proposedResolver = proposedResolver;\n\t    adr.clientProposedResolver = 0;\n\t    adr.providerProposedResolver = 1;\n\t    \n\t    emit ProviderProposeResolver(proposedResolver, registration, details);\n    }\n    \n    /**\n     * @notice Swift resolvers call to update LXL service status.\n     * @dev Swift resolvers must first confirm to participate and can continue with details / cancel LXL service.  \n     * @param details Context re: status update.\n     * @param registered If `true`, swift resolver can participate in LXL resolution.\n     */\n    function updateSwiftResolverStatus(string calldata details, bool registered) external nonReentrant {\n        require(IERC20(swiftResolverToken).balanceOf(msg.sender) >= swiftResolverTokenBalance, \"!swiftResolverTokenBalance\");\n        swiftResolverRegistrations[msg.sender] = registered;\n        emit UpdateSwiftResolverStatus(msg.sender, details, registered);\n    }\n    \n    // *******\n    // GETTERS\n    // *******\n    function latestLockerRegistration(address account) external view returns (uint256 latest) { // get latest registered locker per account\n        uint256[] memory registered = registrations[account];\n        if (registered.length == 0) {return 0;} else {return registered[registered.length-1];}\n    }\n    \n    function lockerRegistrations(address account) external view returns (uint256[] memory registered) { // get registered lockers per account\n        return registrations[account];\n    }\n    \n    function marketTermsCount() external view returns (uint256 count) { // get total market terms stamped by `manager`\n        return marketTerms.length;\n    }\n    \n    function providerAmounts(uint256 registration) external view returns (address token, uint256[] memory amount) { // get `token` and milestone `amount`s for `provider`\n        return (lockers[registration].token, lockers[registration].amount);\n    }\n    \n    function resolutionsCount() external view returns (uint256 count) { // get total resolutions passed by LXL `resolver`s\n        return resolutions.length;\n    }\n   \n    /****************\n    MANAGER FUNCTIONS\n    ****************/\n    /**\n     * @dev Throws if caller is not LXL `manager`.\n     */\n    modifier onlyManager {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n    \n    /**\n     * @notice Updates LXL with new market `terms`. \n     * @param terms New `terms` to add to LXL market. \n     */\n    function addMarketTerms(string calldata terms) external nonReentrant onlyManager {\n        marketTerms.push(terms);\n        emit AddMarketTerms(marketTerms.length-1, terms);\n    }\n    \n    /**\n     * @notice Updates LXL with amended market `terms`. \n     * @param index Targeted location in `marketTerms` array.\n     * @param terms Amended `terms` to add to LXL market. \n     */\n    function amendMarketTerms(uint256 index, string calldata terms) external nonReentrant onlyManager {\n        marketTerms[index] = terms;\n        emit AmendMarketTerms(index, terms);\n    }\n    \n    /**\n     * @notice General ether payment function for `manager` of LXL contract. \n     * @param details Describes context for ether transfer.\n     */\n    function tributeToManager(string calldata details) external nonReentrant payable { \n        (bool success, ) = manager.call{value: msg.value}(\"\");\n        require(success, \"!ethCall\");\n        emit TributeToManager(msg.sender, msg.value, details);\n    }\n    \n    /**\n     * @notice Updates LXL management settings.\n     * @param _manager Account that governs LXL contract settings.\n     * @param _swiftResolverToken Token to mark participants in swift resolution.\n     * @param _userRewardToken Token for LXL user rewards.\n     * @param _wETH Standard contract reference to wrap ether. \n     * @param _MAX_DURATION Time limit in seconds on token lockup - default 63113904 (2-year).\n     * @param _resolutionRate Rate to determine resolution fee for locker (e.g., 20 = 5% of remainder).\n     * @param _swiftResolverTokenBalance Token balance required to perform swift resolution. \n     * @param _userReward Reward amount granted to LXL users in `userRewardToken`.\n     * @param _lockerTerms General terms wrapping LXL.  \n     */\n    function updateLockerSettings(\n        address _manager, \n        address _swiftResolverToken, \n        address _userRewardToken,\n        address _wETH, \n        uint256 _MAX_DURATION, \n        uint256 _resolutionRate, \n        uint256 _swiftResolverTokenBalance,\n        uint256 _userReward,\n        string calldata _lockerTerms\n    ) external nonReentrant onlyManager { \n        require(_resolutionRate > 0, \"_resolutionRate < 1\");\n        \n        manager = _manager;\n        swiftResolverToken = _swiftResolverToken;\n        userRewardToken = _userRewardToken;\n        wETH = _wETH;\n        MAX_DURATION = _MAX_DURATION;\n        resolutionRate = _resolutionRate;\n        swiftResolverTokenBalance = _swiftResolverTokenBalance;\n        userReward = _userReward;\n        lockerTerms = _lockerTerms;\n\t    \n\t    emit UpdateLockerSettings(_manager, _swiftResolverToken, _userRewardToken, _wETH, _MAX_DURATION, _resolutionRate, _swiftResolverTokenBalance, _userReward, _lockerTerms);\n    }\n}"
    }
  }
}