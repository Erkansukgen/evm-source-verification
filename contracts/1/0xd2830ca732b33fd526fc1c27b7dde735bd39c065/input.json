{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "localhost/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity ^0.6.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length), \"Read out of bounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= (_start + 20), \"Read out of bounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= (_start + 2), \"Read out of bounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= (_start + 4), \"Read out of bounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= (_start + 8), \"Read out of bounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= (_start + 12), \"Read out of bounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= (_start + 16), \"Read out of bounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "localhost/Common.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ncontract Common {\n    // configs\n    bytes32 internal EMPTY_BYTES32;\n    uint256 internal constant PERCENT_BASE = 1000;\n    uint256 internal constant ROOT_ID = 6666;\n    uint256 internal constant MAX_LEVEL_DEEP = 7;\n    uint256 internal constant BLOCK_PER_ROUND = 5760;\n    uint256 internal constant DELAY_ROUND = 10;\n    uint256 internal constant ROUND_ALLOW_PREORDER = 15;\n    uint256 internal constant NEWBIE_BLOCKS = 160;\n    uint256 internal constant ROUND_PREORDER_LIMIT_PERCENT = 700;\n\n    // error codes\n    string constant ERROR_HELPING_FUND_NOT_ENOUGH = \"1\"; // helpingFund not enough\n    string constant ERROR_DEFI_IS_BANKRUPT = \"2\"; // defi is bankrupt\n    string constant ERROR_ACCOUNT_IS_DISABLED = \"3\"; // account is disabled\n    string constant ERROR_UNINVESTABLE = \"4\"; // The investable quota is full\n    string constant ERROR_INVALID_STATUS = \"5\"; // invalid status\n    string constant ERROR_INVALID_INVITE_CODE = \"6\"; // invalid inviteCode\n    string constant ERROR_REFERRER_NOT_FOUND = \"7\"; // Referrer not found\n    string constant ERROR_USER_ALREADY_REGISTED = \"8\"; // user already registed\n    string constant ERROR_USER_IS_NOT_REGISTED = \"9\"; // user is not registed\n    string constant ERROR_USER_HAS_NOT_INVESTED = \"10\"; // User has not invested\n    string constant ERROR_ROUND_IS_NOT_OVER = \"11\"; // Round is not over\n    string constant ERROR_TRY_AGAIN_IN_A_DAY = \"12\"; // Try again in a day\n    string constant ERROR_USER_ACTIVATED = \"13\"; // User activated\n    string constant ERROR_USER_IS_NOT_ACTIVATED = \"14\"; // User is not activated\n    string constant ERROR_USER_INVESTED = \"15\"; // User invested\n    string constant ERROR_INVESTMENT_GEAR_IS_INCORRECT = \"16\"; // Investment gear is incorrect\n    string constant ERROR_USER_IS_NOT_NODE = \"17\"; // user is not node\n    string constant ERROR_USER_IS_NOT_SUPER_NODE = \"18\"; // user is not super node\n    string constant ERROR_NO_MORE_BONUS = \"19\"; // no more bonus\n    string constant ERROR_ALREADY_CLAIMED = \"20\"; // already claimed\n    string constant ERROR_NOT_IN_LAST100 = \"21\"; // not in last 100 users\n    string constant ERROR_NO_ORIGINAL_ACCOUNT_QUOTA = \"22\"; // no original account quota\n    string constant ERROR_ETH_NOT_ENOUGH = \"23\"; // ETH not enough\n    string constant ERROR_TOKEN_NOT_ENOUGH = \"24\"; // Token not enough\n    string constant ERROR_UNMATCHED_PAYMENT_ACTION = \"25\"; // Unmatched payment action\n\n    enum EventAction {\n        Unknown,\n        PurchaseOriginalAccount,\n        UserActive,\n        UserInvestment,\n        ReferralUserInvestment,\n        ClaimROI,\n        ClaimCompensation,\n        ClaimNodeBonus,\n        ClaimSuperNodeBonus,\n        ClaimLast100Bonus\n    }\n\n    event UserRegister(\n        uint256 indexed eventID,\n        uint256 indexed userID,\n        uint256 blockNumber,\n        uint256 referralUserID,\n        address userAddr\n    );\n\n    event UserActive(\n        uint256 indexed eventID,\n        uint256 indexed userID,\n        uint256 blockNumber,\n        uint256[MAX_LEVEL_DEEP + 1] referrers,\n        uint256[MAX_LEVEL_DEEP + 1] tokenAmts,\n        uint256[MAX_LEVEL_DEEP + 1] usdAmts,\n        bytes32 inviteCode\n    );\n\n    event Billing(\n        uint256 indexed eventID,\n        uint256 indexed userID,\n        uint256 blockNumber,\n        EventAction action,\n        uint256 extData,\n        uint256 extData1,\n        uint256 extData2,\n        uint256 tokenAmt,\n        uint256 usdAmt,\n        uint256 feeUSD\n    );\n\n    event UserData(\n        uint256 indexed eventID,\n        uint256 indexed userID,\n        uint256 blockNumber,\n        EventAction action,\n        uint256 fromUserID,\n        uint256 extData,\n        bool[2] userBoolArray,\n        uint256[21] userUint256Array\n    );\n\n    event RoundData(\n        uint256 indexed eventID,\n        uint256 indexed roundID,\n        uint256 blockNumber,\n        uint256[4] roundUint256Vars\n    );\n}\n"
    },
    "localhost/DeFiCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./Common.sol\";\n\n\ncontract DeFiCommon is Common {\n    event Error(string reason, uint256 extData, uint256 blockNumber);\n}\n"
    },
    "localhost/DeFiLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./IDeFi.sol\";\nimport \"./IDeFiLogic.sol\";\nimport \"./ILast100Logic.sol\";\nimport \"./IDeFiStorage.sol\";\nimport \"./IGlobalLogic.sol\";\nimport \"./IUpgradable.sol\";\nimport \"./Common.sol\";\nimport \"./DeFiCommon.sol\";\nimport \"./SafeMath.sol\";\nimport \"./SafeERC20.sol\";\nimport \"./BytesLib.sol\";\n\ncontract DeFiLogic is Common, DeFiCommon, IUpgradable, IDeFiLogic {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n\n    uint256 private constant ACTIVE_FEE = 5e5;\n    uint256 private constant ACTION_ACTIVE = 1001;\n    uint256 private constant AVAILABLE_BRING_OUT_PERCENT = 500;\n    uint256 private constant OriginalAccountPrice = 1e18;\n    uint256 private constant OriginalAccountPriceGrow = 1e17;\n    uint256 private constant OriginalAccountNewOpenQuota = 10;\n    uint256 private constant OriginalAccountNewOpenQuotaDelayDays = 30;\n\n    IDeFiStorage _fs;\n    IGlobalLogic _gl;\n    IDeFi _df;\n    mapping(uint256 => uint256) private _quotas;\n\n    modifier ensureStatus(IDeFiStorage.GlobalStatus requireStatus) {\n        IDeFiStorage.GlobalStatus status = _fs.getGlobalStatus();\n        require(\n            status == requireStatus ||\n                (requireStatus == IDeFiStorage.GlobalStatus.Pending &&\n                    (status == IDeFiStorage.GlobalStatus.Pending ||\n                        status == IDeFiStorage.GlobalStatus.Started)),\n            ERROR_INVALID_STATUS\n        );\n        _;\n    }\n\n    /// internal functions\n    function onTokenReceived(\n        address token,\n        address,\n        address msgSender,\n        address,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory\n    ) public override onlyInternal {\n        // check token\n        assert(token == _fs.getToken());\n        if (msgSender == address(0)) return; // mint\n        // convert userData to uint256;\n        uint256 userDataUint256;\n        if (userData.length > 0) {\n            userDataUint256 = userData.toUint256(0);\n        }\n        uint256 usdAmt = _fs.T2U(amount);\n\n        if (ACTION_ACTIVE == userDataUint256) {\n            assert(usdAmt == ACTIVE_FEE);\n            activation(msgSender, amount, usdAmt);\n            return;\n        } else if (userDataUint256 > 0) {\n            uint256 gear = _fs.getInvestGear(usdAmt);\n            if (gear > 0) {\n                invest(msgSender, userDataUint256, amount, usdAmt, gear);\n                return;\n            }\n            revert(ERROR_UNMATCHED_PAYMENT_ACTION);\n        }\n    }\n\n    function getOriginalAccountQuota()\n        public\n        override\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256[3] memory globalBlocks = _fs.getGlobalBlocks();\n        uint256 rounds = block.number <= globalBlocks[0]\n            ? 0\n            : block.number.sub(globalBlocks[0]).div(\n                BLOCK_PER_ROUND * OriginalAccountNewOpenQuotaDelayDays\n            );\n        return (\n            OriginalAccountPrice.add(rounds.mul(OriginalAccountPriceGrow)),\n            OriginalAccountNewOpenQuota > _quotas[rounds]\n                ? OriginalAccountNewOpenQuota.sub(_quotas[rounds])\n                : 0,\n            rounds\n        );\n    }\n\n    function register(\n        address msgSender,\n        uint256 msgValue,\n        bytes32 inviteCode,\n        bool purchaseOriginAccount\n    )\n        public\n        override\n        onlyInternal\n        ensureStatus(IDeFiStorage.GlobalStatus.Pending)\n    {\n        require(_fs.getIDByAddr(msgSender) == 0, ERROR_USER_ALREADY_REGISTED);\n        uint256 userID = _fs.issueUserID(msgSender);\n        uint256[21] memory userUint256Array;\n\n        if (!purchaseOriginAccount) {\n            require(inviteCode != EMPTY_BYTES32, ERROR_INVALID_INVITE_CODE);\n            uint256 fatherID = _fs.getIDByInviteCode(inviteCode);\n            require(fatherID != 0, ERROR_REFERRER_NOT_FOUND);\n            bool[2] memory userBoolArray;\n            userUint256Array[1] = fatherID; // bind referrer\n            _fs.setUser(userID, userBoolArray, userUint256Array);\n            emit UserRegister(\n                _fs.issueEventIndex(),\n                userID,\n                block.number,\n                fatherID,\n                msgSender\n            );\n        } else {\n            (\n                uint256 price,\n                uint256 quota,\n                uint256 rounds\n            ) = getOriginalAccountQuota();\n            require(quota > 0, ERROR_NO_ORIGINAL_ACCOUNT_QUOTA);\n            _quotas[rounds]++;\n            require(price <= msgValue, ERROR_ETH_NOT_ENOUGH);\n            userUint256Array[1] = ROOT_ID; // bind referrer\n            emit UserRegister(\n                _fs.issueEventIndex(),\n                userID,\n                block.number,\n                ROOT_ID,\n                msgSender\n            );\n\n            uint256 _stackTooDeep_msgValue = msgValue;\n            emit Billing(\n                _fs.issueEventIndex(),\n                userID,\n                block.number,\n                EventAction.PurchaseOriginalAccount,\n                0,\n                0,\n                0,\n                0,\n                _stackTooDeep_msgValue,\n                0\n            );\n            _df.sendETH(_fs.getPlatformAddress(), _stackTooDeep_msgValue);\n        }\n\n        // issue new inviteCode\n        bytes32 newInviteCode = _gl.generateInviteCode(userID);\n        _fs.setUserInviteCode(userID, newInviteCode);\n        // set user level\n        userUint256Array[0]++;\n        bool[2] memory userBoolArray;\n        _fs.setUser(userID, userBoolArray, userUint256Array);\n        uint256[MAX_LEVEL_DEEP + 1] memory empty;\n        emit UserActive(\n            _fs.issueEventIndex(),\n            userID,\n            block.number,\n            empty,\n            empty,\n            empty,\n            newInviteCode\n        );\n    }\n\n    function claimROI(address msgSender)\n        public\n        override\n        onlyInternal\n        ensureStatus(IDeFiStorage.GlobalStatus.Started)\n    {\n        _gl.internalSplitPool();\n        uint256 userID = _fs.getIDByAddr(msgSender);\n        require(userID > 0, ERROR_USER_IS_NOT_REGISTED);\n        (\n            bool[2] memory userBoolArray,\n            uint256[21] memory userUint256Array\n        ) = _fs.getUser(userID);\n        require(userUint256Array[6] > 0, ERROR_USER_HAS_NOT_INVESTED);\n        require(\n            block.number.sub(BLOCK_PER_ROUND * DELAY_ROUND) >\n                userUint256Array[6],\n            ERROR_ROUND_IS_NOT_OVER\n        );\n        if (\n            userUint256Array[5] > 0 &&\n            userUint256Array[5].add(BLOCK_PER_ROUND) > block.number\n        ) revert(ERROR_TRY_AGAIN_IN_A_DAY);\n\n        uint256 income = _fs.getLevelConfig(\n            userUint256Array[3],\n            IDeFiStorage.ConfigType.StaticIncomeAmt\n        );\n        income = income.add(userUint256Array[7]); // add dynamicIncome bringOut\n        uint256 allAmt = income.add(\n            _fs.getLevelConfig(\n                userUint256Array[3],\n                IDeFiStorage.ConfigType.InvestAmt\n            )\n        );\n        uint256 allToken = _fs.U2T(allAmt);\n\n        uint256 distPool;\n        uint256[5] memory pools = _fs.getDeFiAccounts();\n        if (pools[distPool] < allToken) {\n            if (userUint256Array[4] >= 3) distPool = 1;\n            else if (userUint256Array[5].add(BLOCK_PER_ROUND) <= block.number) {\n                userUint256Array[4]++;\n                userUint256Array[5] = block.number;\n                _fs.setUser(userID, userBoolArray, userUint256Array);\n                emit Error(\n                    ERROR_HELPING_FUND_NOT_ENOUGH,\n                    userUint256Array[4],\n                    block.number\n                );\n                return;\n            }\n        }\n        if (pools[distPool] < allToken) {\n            // DeFi broken\n            uint256[3] memory globalBlocks = _fs.getGlobalBlocks();\n            globalBlocks[1] = block.number;\n            _fs.setGlobalBlocks(globalBlocks);\n            emit Error(ERROR_DEFI_IS_BANKRUPT, globalBlocks[1], block.number);\n            return;\n        }\n\n        uint256 fee = allAmt.per(\n            PERCENT_BASE,\n            _fs.getLevelConfig(\n                userUint256Array[3],\n                IDeFiStorage.ConfigType.ClaimFeePercent\n            )\n        );\n        uint256 distAmt = allAmt.sub(fee);\n        uint256 distTokenAmt = _fs.U2T(distAmt);\n        pools[distPool] = pools[distPool].sub(allToken);\n        _df.sendToken(_fs.getPlatformAddress(), allToken.sub(distTokenAmt));\n        _fs.setDeFiAccounts(pools);\n\n        address _stackTooDeep_msgSender = msgSender;\n        uint256 _stackTooDeep_userID2 = userID;\n        // update user info\n        (\n            uint256 investGear,\n            uint256 roundBringOut,\n            uint256 roundID\n        ) = _clearUserInvestmentInfo(userUint256Array, income);\n\n        bool[2] memory _stackTooDeep_userBoolArray2 = userBoolArray;\n        uint256[21] memory _stackTooDeep_userUint256Array2 = userUint256Array;\n        uint256 _stackTooDeep_distTokenAmt = distTokenAmt;\n        uint256 _stackTooDeep_distAmt = distAmt;\n        _fs.setUser(\n            _stackTooDeep_userID2,\n            _stackTooDeep_userBoolArray2,\n            _stackTooDeep_userUint256Array2\n        );\n        _df.sendToken(_stackTooDeep_msgSender, _stackTooDeep_distTokenAmt);\n\n        uint256 _stackTooDeep_fee = fee;\n        emit Billing(\n            _fs.issueEventIndex(),\n            _stackTooDeep_userID2,\n            block.number,\n            EventAction.ClaimROI,\n            roundID,\n            investGear,\n            roundBringOut,\n            _stackTooDeep_distTokenAmt,\n            _stackTooDeep_distAmt,\n            _stackTooDeep_fee\n        );\n        emit UserData(\n            _fs.issueEventIndex(),\n            _stackTooDeep_userID2,\n            block.number,\n            EventAction.ClaimROI,\n            _stackTooDeep_userID2,\n            0,\n            _stackTooDeep_userBoolArray2,\n            _stackTooDeep_userUint256Array2\n        );\n    }\n\n    function deposit(\n        address,\n        uint256 poolID,\n        uint256 tokenAmt\n    ) public override onlyInternal {\n        uint256[5] memory pools = _fs.getDeFiAccounts();\n        pools[poolID] = pools[poolID].add(tokenAmt);\n        _fs.setDeFiAccounts(pools);\n    }\n\n    /// private functions\n    function activation(\n        address msgSender,\n        uint256 tokenAmt,\n        uint256 usdAmt\n    ) private ensureStatus(IDeFiStorage.GlobalStatus.Pending) {\n        uint256 userID = _fs.getIDByAddr(msgSender);\n        require(userID > 0, ERROR_USER_IS_NOT_REGISTED);\n        require(\n            _fs.getInviteCodeByID(userID) == EMPTY_BYTES32,\n            ERROR_USER_ACTIVATED\n        );\n        // set inviteCode\n        bytes32 inviteCode = _gl.generateInviteCode(userID);\n        _fs.setUserInviteCode(userID, inviteCode);\n        // set user level\n        (\n            bool[2] memory userBoolArray,\n            uint256[21] memory userUint256Array\n        ) = _fs.getUser(userID);\n        userUint256Array[0]++;\n        _fs.setUser(userID, userBoolArray, userUint256Array);\n        // dispatch activation bonus\n        emit Billing(\n            _fs.issueEventIndex(),\n            userID,\n            block.number,\n            EventAction.UserActive,\n            0,\n            0,\n            0,\n            tokenAmt,\n            usdAmt,\n            0\n        );\n        uint256 balance = tokenAmt;\n        uint256 usdBalance = ACTIVE_FEE;\n        uint256 splitedAmt = tokenAmt.div(10);\n        uint256 splitedUsdAmt = usdBalance.div(10);\n        uint256[MAX_LEVEL_DEEP] memory fathers = _fs.getUserFatherIDs(userID);\n        address[MAX_LEVEL_DEEP] memory fatherAddrs = _fs.getUserFatherAddrs(\n            userID\n        );\n        uint256[MAX_LEVEL_DEEP + 1] memory referrers;\n        uint256[MAX_LEVEL_DEEP + 1] memory usdAmts;\n        uint256[MAX_LEVEL_DEEP + 1] memory tokenAmts;\n        bool isBreak;\n        for (uint256 i = 0; i <= MAX_LEVEL_DEEP && !isBreak; i++) {\n            referrers[i] = (i == MAX_LEVEL_DEEP || fathers[i] == 0)\n                ? ROOT_ID\n                : fathers[i];\n            if (referrers[i] == ROOT_ID) {\n                usdAmts[i] = usdBalance;\n                tokenAmts[i] = balance;\n                isBreak = true;\n            } else if (i == 0) {\n                tokenAmts[i] = splitedAmt.mul(3);\n                usdAmts[i] = splitedUsdAmt.mul(3);\n            } else {\n                tokenAmts[i] = splitedAmt;\n                usdAmts[i] = splitedUsdAmt;\n            }\n            if (\n                referrers[i] != ROOT_ID &&\n                i != MAX_LEVEL_DEEP &&\n                fatherAddrs[i] == address(0)\n            ) {\n                continue;\n            }\n            balance = balance.sub(tokenAmts[i]);\n            usdBalance = usdBalance.sub(usdAmts[i]);\n            _df.sendToken(\n                referrers[i] == ROOT_ID\n                    ? _fs.getPlatformAddress()\n                    : fatherAddrs[i],\n                tokenAmts[i]\n            );\n        }\n        bytes32 _stackTooDeep_inviteCode2 = inviteCode;\n        emit UserActive(\n            _fs.issueEventIndex(),\n            userID,\n            block.number,\n            referrers,\n            tokenAmts,\n            usdAmts,\n            _stackTooDeep_inviteCode2\n        );\n    }\n\n    function invest(\n        address msgSender,\n        uint256 roundID,\n        uint256 tokenAmt,\n        uint256 usdAmt,\n        uint256 gear\n    ) private ensureStatus(IDeFiStorage.GlobalStatus.Started) {\n        uint256 userID = _fs.getIDByAddr(msgSender);\n        require(userID > 0, ERROR_USER_IS_NOT_REGISTED);\n        require(\n            userID == ROOT_ID || _fs.getInviteCodeByID(userID) != EMPTY_BYTES32,\n            ERROR_USER_IS_NOT_ACTIVATED\n        );\n        _gl.checkDeactiveReferrals(userID);\n        (\n            bool[2] memory userBoolArray,\n            uint256[21] memory userUint256Array\n        ) = _fs.getUser(userID);\n        require(userUint256Array[6] == 0, ERROR_USER_INVESTED);\n        require(\n            userUint256Array[0] >= gear && userUint256Array[3] <= gear,\n            ERROR_INVESTMENT_GEAR_IS_INCORRECT\n        );\n\n        bool isNewUser = userUint256Array[3] == 0;\n\n        if (\n            !_gl.checkUserAlive(\n                userID,\n                userUint256Array[6],\n                userUint256Array[2],\n                msgSender\n            )\n        ) {\n            emit Error(ERROR_ACCOUNT_IS_DISABLED, userID, block.number);\n            _df.sendToken(msgSender, tokenAmt);\n            return;\n        }\n        updateUserInfo(\n            userID,\n            userUint256Array,\n            isNewUser,\n            roundID,\n            gear,\n            tokenAmt,\n            usdAmt\n        );\n\n        _fs.setUser(userID, userBoolArray, userUint256Array);\n\n        uint256[5] memory selfInvestCount;\n        if (gear <= userUint256Array[0] && userUint256Array[0] < 5) {\n            selfInvestCount = _fs.getSelfInvestCount(userID);\n            selfInvestCount[gear - 1] = selfInvestCount[gear - 1].add(1);\n            _fs.setSelfInvestCount(userID, selfInvestCount);\n        }\n        if (userID != ROOT_ID) _fs.pushToInvestQueue(userID);\n\n        _fs.effectReferrals(userID, roundID, usdAmt, isNewUser);\n    }\n\n    function updateUserInfo(\n        uint256 userID,\n        uint256[21] memory userUint256Array,\n        bool isNewUser,\n        uint256 roundID,\n        uint256 gear,\n        uint256 tokenAmt,\n        uint256 usdAmt\n    ) private {\n        // chech round available and update round info\n        if (\n            !_fs.checkRoundAvailableAndUpdate(\n                isNewUser,\n                roundID,\n                usdAmt,\n                tokenAmt\n            )\n        ) revert(ERROR_UNINVESTABLE);\n        // update user info\n        userUint256Array[2] = block.number; // lastActiveBlock\n        userUint256Array[3] = gear; // maxInvestGear\n        userUint256Array[6] = roundID; // investRound\n        userUint256Array[9] = userUint256Array[9].add(usdAmt); // personalPerformance\n        userUint256Array[7] = usdAmt.per(\n            PERCENT_BASE,\n            AVAILABLE_BRING_OUT_PERCENT\n        ); // available bring out\n        if (userUint256Array[7] > userUint256Array[8]) {\n            userUint256Array[7] = userUint256Array[8];\n        }\n        userUint256Array[7] = userUint256Array[7].div(1e6).mul(1e6);\n        emit Billing(\n            _fs.issueEventIndex(),\n            userID,\n            block.number,\n            EventAction.UserInvestment,\n            roundID,\n            userUint256Array[3],\n            userUint256Array[7],\n            tokenAmt,\n            usdAmt,\n            0\n        );\n    }\n\n    function _clearUserInvestmentInfo(\n        uint256[21] memory userUint256Array,\n        uint256 income\n    )\n        private\n        view\n        returns (\n            uint256 investGear,\n            uint256 roundBringOut,\n            uint256 roundID\n        )\n    {\n        investGear = userUint256Array[3];\n        roundBringOut = userUint256Array[7];\n        userUint256Array[2] = block.number; // lastActiveBlock\n        userUint256Array[4] = 0; // claimRetryCount\n        userUint256Array[5] = 0; // claimRetryBlock\n        roundID = userUint256Array[6];\n        userUint256Array[6] = 0; // investRound\n        userUint256Array[8] = userUint256Array[8].sub(userUint256Array[7]); // dynamic return balance\n        userUint256Array[7] = 0; // bringOut\n        userUint256Array[16] = userUint256Array[16].add(income); // invest return\n    }\n\n    /// implements functions\n    function changeDependentContractAddress() public override {\n        _gl = IGlobalLogic(master.getLatestAddress(\"GL\"));\n        _fs = IDeFiStorage(master.getLatestAddress(\"FS\"));\n        _df = IDeFi(master.getLatestAddress(\"DF\"));\n    }\n}\n"
    },
    "localhost/IDeFi.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IDeFi {\n    function sendToken(address to, uint256 amt) external;\n\n    function sendETH(address payable to, uint256 amt) external;\n}\n"
    },
    "localhost/IDeFiLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IDeFiLogic {\n    function onTokenReceived(\n        address token,\n        address operator,\n        address msgSender,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n\n    function getOriginalAccountQuota()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function register(\n        address msgSender,\n        uint256 msgValue,\n        bytes32 inviteCode,\n        bool purchaseOriginAccount\n    ) external;\n\n    function claimROI(address msgSender) external;\n\n    function deposit(\n        address msgSender,\n        uint256 poolID,\n        uint256 tokenAmt\n    ) external;\n}\n"
    },
    "localhost/IDeFiStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IDeFiStorage {\n    enum ConfigType {\n        InvestAmt,\n        StaticIncomeAmt,\n        DynamicIncomePercent,\n        ClaimFeePercent,\n        UpgradeRequiredInviteValidPlayerCount,\n        UpgradeRequiredMarketPerformance,\n        UpgradeRequiredSelfInvestCount\n    }\n    enum InvestType {Newbie, Open, PreOrder}\n    enum GlobalStatus {Pending, Started, Bankruptcy, Ended}\n    event GlobalBlocks(uint256 indexed eventID, uint256[3] blocks);\n\n    // public\n    function getCurrentRoundID(bool enableCurrentBlock)\n        external\n        view\n        returns (uint256);\n\n    function getAvailableRoundID(bool isNewUser, bool enableCurrentBlock)\n        external\n        view\n        returns (uint256 id, InvestType investType);\n\n    function getInvestGear(uint256 usdAmt) external view returns (uint256);\n\n    function U2T(uint256 usdAmt) external view returns (uint256);\n\n    function U2E(uint256 usdAmt) external view returns (uint256);\n\n    function T2U(uint256 tokenAmt) external view returns (uint256);\n\n    function E2U(uint256 etherAmt) external view returns (uint256);\n\n    function T2E(uint256 tokenAmt) external view returns (uint256);\n\n    function E2T(uint256 etherAmt) external view returns (uint256);\n\n    function getGlobalStatus() external view returns (GlobalStatus);\n\n    function last100() external view returns (uint256[100] memory);\n\n    function getGlobalBlocks() external view returns (uint256[3] memory);\n\n    function getDeFiAccounts() external view returns (uint256[5] memory);\n\n    function getPoolSplitStats() external view returns (uint256[3] memory);\n\n    function getPoolSplitPercent(uint256 roundID) external view returns (uint256[6] memory splitPrcent, uint256[2] memory nodeCount);\n\n    // internal\n    function isLast100AndLabel(uint256 userID) external returns (bool);\n\n    function increaseRoundData(\n        uint256 roundID,\n        uint256 dataID,\n        uint256 num\n    ) external;\n\n    function getNodePerformance(\n        uint256 roundID,\n        uint256 nodeID,\n        bool isSuperNode\n    ) external view returns (uint256);\n\n    function increaseUserData(\n        uint256 userID,\n        uint256 dataID,\n        uint256 num,\n        bool isSub,\n        bool isSet\n    ) external;\n\n    function checkRoundAvailableAndUpdate(\n        bool isNewUser,\n        uint256 roundID,\n        uint256 usdAmt,\n        uint256 tokenAmt\n    ) external returns (bool success);\n\n    function increaseDeFiAccount(\n        uint256 accountID,\n        uint256 num,\n        bool isSub\n    ) external returns (bool);\n\n    function getUser(uint256 userID)\n        external\n        view\n        returns (\n            bool[2] memory userBoolArray,\n            uint256[21] memory userUint256Array\n        );\n\n    function getUserUint256Data(uint256 userID, uint256 dataID)\n        external\n        view\n        returns (uint256);\n\n    function setDeFiAccounts(uint256[5] calldata data) external;\n\n    function splitDone() external;\n\n    function getSelfInvestCount(uint256 userID)\n        external\n        view\n        returns (uint256[5] memory selfInvestCount);\n\n    function setSelfInvestCount(\n        uint256 userID,\n        uint256[5] calldata selfInvestCount\n    ) external;\n\n    function pushToInvestQueue(uint256 userID) external;\n\n    function effectReferrals(\n        uint256 userID,\n        uint256 roundID,\n        uint256 usdAmt,\n        bool isNewUser\n    ) external;\n\n    function getLevelConfig(uint256 level, ConfigType configType)\n        external\n        view\n        returns (uint256);\n\n    function getUserFatherIDs(uint256 userID)\n        external\n        view\n        returns (uint256[7] memory fathers);\n\n    function getUserFatherActiveInfo(uint256 userID)\n        external\n        view\n        returns (\n            uint256[7] memory fathers,\n            uint256[7] memory roundID,\n            uint256[7] memory lastActive,\n            address[7] memory addrs\n        );\n\n    function getUserFatherAddrs(uint256 userID)\n        external\n        view\n        returns (address[7] memory fathers);\n\n    function setGlobalBlocks(uint256[3] calldata blocks) external;\n\n    function getGlobalNodeCount(uint256 roundID)\n        external\n        view\n        returns (uint256[2] memory nodeCount);\n\n    function getToken() external view returns (address);\n\n    function setToken(address token) external;\n\n    function getPlatformAddress() external view returns (address payable);\n\n    function setPlatformAddress(address payable platformAddress) external;\n\n    function getIDByAddr(address addr) external view returns (uint256);\n\n    function getAddrByID(uint256 id) external view returns (address);\n\n    function setUserAddr(uint256 id, address addr) external;\n\n    function getIDByInviteCode(bytes32 inviteCode)\n        external\n        view\n        returns (uint256);\n\n    function getInviteCodeByID(uint256 id) external view returns (bytes32);\n\n    function setUserInviteCode(uint256 id, bytes32 inviteCode) external;\n\n    function issueUserID(address addr) external returns (uint256);\n\n    function issueEventIndex() external returns (uint256);\n\n    function setUser(\n        uint256 userID,\n        bool[2] calldata userBoolArry,\n        uint256[21] calldata userUint256Array\n    ) external;\n\n    function deactivateUser(uint256 id) external;\n\n    function getRound(uint256 roundID)\n        external\n        view\n        returns (uint256[4] memory roundUint256Vars);\n\n    function setRound(uint256 roundID, uint256[4] calldata roundUint256Vars)\n        external;\n\n    function setE2U(uint256 e2u) external;\n\n    function setT2U(uint256 t2u) external;\n\n    function setRoundLimit(uint256[] calldata roundID, uint256[] calldata limit)\n        external;\n}\n"
    },
    "localhost/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "localhost/IGlobalLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IGlobalLogic {\n    function checkUserAlive(\n        uint256 userID,\n        uint256 roundID,\n        uint256 lastActiveBlock,\n        address userAddr\n    ) external returns (bool);\n\n    function checkDeactiveReferrals(uint256 userID) external;\n\n    function generateInviteCode(uint256 id) external view returns (bytes32);\n\n    function internalSplitPool() external;\n}\n"
    },
    "localhost/ILast100Logic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface ILast100Logic {\n    function checkUserAvailable(address payable from)\n        external\n        returns (uint256);\n\n    function internalExchange() external;\n}\n"
    },
    "localhost/IMaster.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IMaster {\n    function isOwner(address _addr) external view returns (bool);\n\n    function payableOwner() external view returns (address payable);\n\n    function isInternal(address _addr) external view returns (bool);\n\n    function getLatestAddress(bytes2 _contractName)\n        external\n        view\n        returns (address contractAddress);\n}\n"
    },
    "localhost/IUpgradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./IMaster.sol\";\nimport \"./Address.sol\";\n\nabstract contract IUpgradable {\n    IMaster public master;\n\n    modifier onlyInternal {\n        assert(master.isInternal(msg.sender));\n        _;\n    }\n\n    modifier onlyOwner {\n        assert(master.isOwner(msg.sender));\n        _;\n    }\n\n    modifier onlyMaster {\n        assert(address(master) == msg.sender);\n        _;\n    }\n\n    /**\n     * @dev IUpgradable Interface to update dependent contract address\n     */\n    function changeDependentContractAddress() public virtual;\n\n    /**\n     * @dev change master address\n     * @param addr is the new address\n     */\n    function changeMasterAddress(address addr) public {\n        assert(Address.isContract(addr));\n        assert(address(master) == address(0) || address(master) == msg.sender);\n        master = IMaster(addr);\n    }\n}\n"
    },
    "localhost/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "localhost/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function per(uint256 a, uint256 base, uint256 percent) internal pure returns (uint256) {\n        return div(mul(a,percent),base);\n    }\n}\n"
    }
  }
}