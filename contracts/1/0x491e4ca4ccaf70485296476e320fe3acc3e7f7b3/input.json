{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Messaging.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\ncontract Messaging {\r\n    uint256 public threadCount = 1;\r\n\r\n    mapping(uint256 => Thread) public threads;\r\n    mapping(uint256 => Message[]) public messages;\r\n    uint256 public messagesIndex = 0;\r\n    mapping(address => string) private pubEncKeys; // mapping of address to public encryption key https://docs.metamask.io/guide/rpc-api.html#eth-getencryptionpublickey\r\n\r\n\r\n    struct Thread {\r\n        uint256 thread_id;\r\n        address receiver;\r\n        string receiver_key;\r\n        address sender;\r\n        string sender_key;\r\n        bool encrypted;\r\n    }\r\n\r\n    struct Message {\r\n        address receiver;\r\n        string uri;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    event MessageSent (\r\n        address receiver,\r\n        string uri,\r\n        uint256 timestamp,\r\n        address sender,\r\n        uint256 thread_id\r\n    );\r\n\r\n\r\n    event ThreadCreated (\r\n        address receiver,\r\n        address sender,\r\n        uint256 thread_id,\r\n        uint256 timestamp,\r\n        string _sender_key,\r\n        string _receiver_key,\r\n        bool _encrypted\r\n    );\r\n\r\n\r\n    function getPubEncKeys(address receiver) public view returns(string memory sender_key, string memory receiver_key) {\r\n\r\n        // require(msg.sender != receiver, \"Sender can't be receiver\");\r\n        require(bytes(pubEncKeys[msg.sender]).length != 0, \"Sender isn't registered on Dakiya\");\r\n\r\n        if (bytes(pubEncKeys[msg.sender]).length != 0) {\r\n            sender_key = pubEncKeys[msg.sender];\r\n        }\r\n        if (bytes(pubEncKeys[receiver]).length != 0) {\r\n            receiver_key = pubEncKeys[receiver];\r\n        }\r\n        return (sender_key, receiver_key);\r\n    }\r\n\r\n    function checkUserRegistration() public view returns(bool) {\r\n        return bytes(pubEncKeys[msg.sender]).length != 0;\r\n    }\r\n\r\n    function setPubEncKey(string memory encKey) public {\r\n        pubEncKeys[msg.sender] = encKey;\r\n    }\r\n\r\n    function newThread(\r\n        address _receiver,\r\n        string memory _sender_key,\r\n        string memory _receiver_key,\r\n        bool encrypted\r\n    ) internal returns (uint256) {\r\n        threadCount++;\r\n\r\n        threads[threadCount] = Thread(\r\n            threadCount,\r\n            _receiver,\r\n            _receiver_key,\r\n            msg.sender,\r\n            _sender_key,\r\n            encrypted\r\n        );\r\n\r\n        return threadCount;\r\n    }\r\n\r\n    function sendMessage(\r\n        uint256 _thread_id,\r\n        string memory _uri,\r\n        address _receiver,\r\n        string memory _sender_key,\r\n        string memory _receiver_key,\r\n        bool encrypted\r\n    ) public {\r\n        if (_thread_id == 0) {\r\n            uint256 new_thread_id = newThread(\r\n                _receiver,\r\n                _sender_key,\r\n                _receiver_key,\r\n                encrypted\r\n            );\r\n\r\n            messages[new_thread_id].push(\r\n                Message(_receiver, _uri, block.timestamp)\r\n            );\r\n\r\n            emit ThreadCreated(\r\n                _receiver,\r\n                msg.sender,\r\n                new_thread_id,\r\n                block.timestamp,\r\n                _sender_key,\r\n                _receiver_key,\r\n                encrypted\r\n            );\r\n            emit MessageSent(_receiver, _uri, block.timestamp, msg.sender, new_thread_id);\r\n        } else {\r\n            Thread storage thread = threads[_thread_id];\r\n\r\n            require(\r\n                msg.sender == thread.receiver || msg.sender == thread.sender,\r\n                \"Only the receiver & sender can reply to the messages.\"\r\n            );\r\n\r\n            messages[thread.thread_id].push(\r\n                Message(_receiver, _uri, block.timestamp)\r\n            );\r\n\r\n            emit MessageSent(_receiver, _uri, block.timestamp, msg.sender, _thread_id);\r\n        }\r\n    }\r\n}"
    }
  }
}