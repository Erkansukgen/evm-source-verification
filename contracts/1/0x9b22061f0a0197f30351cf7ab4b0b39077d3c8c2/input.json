{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/CakeBandit/CakeBandit.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20 {\r\n\r\n    //function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    //function transfer(address recipient, uint256 amount) external returns (bool);\r\n    //function allowance(address owner, address spender) external view returns (uint256);\r\n    //function approve(address spender, uint256 amount) external returns (bool);\r\n    //function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    //event Transfer(address indexed from, address indexed to, uint256 value);\r\n    //event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n//interface IUniswapV2Factory {\r\n//    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n//    function feeTo() external view returns (address);\r\n//    function feeToSetter() external view returns (address);\r\n\r\n//    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n//    function allPairs(uint) external view returns (address pair);\r\n//    function allPairsLength() external view returns (uint);\r\n\r\n//    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n//    function setFeeTo(address) external;\r\n//    function setFeeToSetter(address) external;\r\n//}\r\n\r\n//interface IUniswapV2Pair {\r\n//    event Approval(address indexed owner, address indexed spender, uint value);\r\n//    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n//    function name() external pure returns (string memory);\r\n//    function symbol() external pure returns (string memory);\r\n//    function decimals() external pure returns (uint8);\r\n//    function totalSupply() external view returns (uint);\r\n//    function balanceOf(address owner) external view returns (uint);\r\n//    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n//    function approve(address spender, uint value) external returns (bool);\r\n//    function transfer(address to, uint value) external returns (bool);\r\n//    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n//    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n//    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n//    function nonces(address owner) external view returns (uint);\r\n\r\n//    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n//    event Mint(address indexed sender, uint amount0, uint amount1);\r\n//    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n//    event Swap(\r\n//        address indexed sender,\r\n//        uint amount0In,\r\n//        uint amount1In,\r\n//        uint amount0Out,\r\n//        uint amount1Out,\r\n//        address indexed to\r\n//    );\r\n//    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n//    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n//    function factory() external view returns (address);\r\n//    function token0() external view returns (address);\r\n//    function token1() external view returns (address);\r\n//    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n//    function price0CumulativeLast() external view returns (uint);\r\n//    function price1CumulativeLast() external view returns (uint);\r\n//    function kLast() external view returns (uint);\r\n\r\n//    function mint(address to) external returns (uint liquidity);\r\n//    function burn(address to) external returns (uint amount0, uint amount1);\r\n//    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n//    function skim(address to) external;\r\n//    function sync() external;\r\n\r\n//    function initialize(address, address) external;\r\n//}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    \r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n//this is our 'bank' that will hold our tokens\r\ncontract TheVault {\r\n    \r\n    address immutable _owner;\r\n    mapping (address => bool) private _allowedToWithDraw;\r\n    mapping (address => bool) private _allowedRouters;\r\n    address immutable _ethAddress;\r\n    \r\n    constructor() {\r\n        //don't let any other blockchain user easily copy our binary code and redeploy it for themself - set fixed address here\r\n        require(msg.sender == address(0x61F4E1612B77250aeF155BBed296827932B43E58), \"1\");\r\n        \r\n        //add the wallets that are allowed to withdraw from the vault here\r\n        _allowedToWithDraw[address(0x062B4d645325d5B85b68152834ebB4a87D1a0eD9)] = true; //prod\r\n        //_allowedToWithDraw[address(0x61F4E1612B77250aeF155BBed296827932B43E58)] = true; //uat\r\n        \r\n        _owner = msg.sender;\r\n        \r\n        //PROD CHAINS\r\n        _ethAddress = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); //ethereum\r\n        //_ethAddress = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c); //binance smart blockchain\r\n        \r\n        //TEST CHAINS\r\n        //_ethAddress = address(0xc778417E063141139Fce010982780140Aa0cD5Ab); //ropsten\r\n        //_ethAddress = address(0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd); //binance testnet\r\n        \r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"A\");\r\n        _;\r\n    }\r\n    \r\n    //add a router address to whitelist \r\n    function AddAllowedRouter(address routerAddress) external {\r\n        require(_allowedToWithDraw[msg.sender] == true, \"B\");\r\n        _allowedRouters[routerAddress] = true;\r\n    }\r\n    \r\n    //remove a router address from whitelist\r\n    function DelAllowedRouter(address routerAddress) external {\r\n        require(_allowedToWithDraw[msg.sender] == true, \"C\");\r\n        _allowedRouters[routerAddress] = false;\r\n    }\r\n    \r\n    //to withdraw ETH from the Vault\r\n    function WithDrawETH(uint256 amount) external {\r\n        require(_allowedToWithDraw[msg.sender] == true, \"D\");\r\n        require(address(this).balance >= amount, \"E\");\r\n        \r\n        //send the amount\r\n        payable(msg.sender).call\r\n        {\r\n            value : amount\r\n        }\r\n        ('');\r\n    }\r\n    \r\n    //to withdraw Tokens from the Va\r\n    \r\n    //there should be enough token balance to send for the withdrawal\r\n    function WithDrawTokens(address tokenAddress, uint256 amount) external {\r\n        \r\n        require(_allowedToWithDraw[msg.sender] == true, \"F\");\r\n        \r\n        //there should be enough token balance to send for the withdrawal\r\n        require(IERC20(tokenAddress).balanceOf(address(this)) >= amount, \"G\"); \r\n        \r\n        bytes memory params = abi.encodeWithSignature(\"transfer(address,uint256)\", msg.sender, amount);\r\n        (bool success, ) = tokenAddress\r\n            .call\r\n            (params);\r\n        //require successful\r\n        require(success, \"U\");\r\n        \r\n        //NOTE: NOT DOING THIS WAY AS USDT WITHDRAWALS FAIL. (NON STANDARD ERC20 IMPLEMENTATION)\r\n        //transfer the amount\r\n        //IERC20(tokenAddress).transfer(msg.sender, amount);\r\n    }\r\n    \r\n    //check that contract has balance to do the swap\r\n    function CheckBalances(address token1, address token2) external view returns (uint256, uint256) {\r\n        \r\n        uint256 balance1;\r\n        uint256 balance2;\r\n        \r\n        if (token1 == _ethAddress){\r\n            balance1 = address(this).balance;\r\n        }\r\n        else {\r\n            balance1 = IERC20(token1).balanceOf(address(this));\r\n        }\r\n        if (token2 == _ethAddress){\r\n            balance2 = address(this).balance;\r\n        }\r\n        else {\r\n            balance2 = IERC20(token2).balanceOf(address(this));\r\n        }\r\n        return (balance1, balance2);\r\n    }\r\n    \r\n    //creates CakeBandit Contract & Runs it\r\n    function RunCB(address leg1Exchange, address leg2Exchange, address leg1SendToken, address leg1ReceiveToken, uint256 leg1ReceiveExactAmount, uint256 leg1MaxSendAmount, uint256 leg2MinReceiveAmount, uint blockDeadline) external payable onlyOwner() {\r\n        \r\n        //Call leg 1 swap.\r\n        PerformLeg1Swap(leg1Exchange, leg1SendToken, leg1ReceiveToken, leg1ReceiveExactAmount, leg1MaxSendAmount, blockDeadline);\r\n        \r\n        //Call leg 2 swap.\r\n        PerformLeg2Swap(leg2Exchange, leg1SendToken, leg1ReceiveToken, leg1ReceiveExactAmount, leg2MinReceiveAmount, blockDeadline);\r\n        \r\n    }\r\n    \r\n    function PerformLeg1Swap(address leg1Exchange, address leg1SendToken, address leg1ReceiveToken, uint256 leg1ReceiveExactAmount, uint256 leg1MaxSendAmount, uint blockDeadline) public payable onlyOwner() {\r\n        \r\n        //if our reliance on external RPC calls means contract is called late, we don't want to proceed\r\n        require(block.timestamp <= blockDeadline, \"H\");\r\n        require(_allowedRouters[leg1Exchange] == true, \"I\");\r\n        \r\n        IUniswapV2Router02 _router1 = IUniswapV2Router02(leg1Exchange);\r\n        \r\n        //routing pathway\r\n        address[] memory path = new address[](2);\r\n        path[0] = leg1SendToken;\r\n        path[1] = leg1ReceiveToken;\r\n        \r\n        //approve router to spend our tokens up to max amount\r\n        if (leg1SendToken != _router1.WETH()){\r\n            bytes memory params = abi.encodeWithSignature(\"approve(address,uint256)\", leg1Exchange, leg1MaxSendAmount);\r\n            (bool success, ) = leg1SendToken\r\n                .call\r\n                (params);\r\n            //require successful\r\n            require(success, \"J\");\r\n        }\r\n        \r\n        //perform leg 1 swap\r\n        //note: as tokens are used here we must manually send any residual back to tokenResidualAddress\r\n        if (leg1ReceiveToken == _router1.WETH())\r\n        {\r\n            //approve router to spend our tokens up to max amount\r\n            //require(IERC20(leg1SendToken).approve(leg1Exchange, leg1MaxSendAmount), \"J\");\r\n            //NOTE: ABOVE COMMENTED OUT DUE TO USDT BEING NON COMPLIENT WITH ERC20. USING .call INSTEAD above at J\r\n            \r\n            //send and receive in uniswap interface are from uniswap's perspective\r\n            uint256 balanceBeforeSwap = address(this).balance;\r\n            \r\n            _router1.swapTokensForExactETH(\r\n                    leg1ReceiveExactAmount, //amount ETH out exact - i.e. from uniswap to us\r\n                    leg1MaxSendAmount, //amount tokens in max - i.e. from us to uniswap\r\n                    path,\r\n                    address(this), //we will receive the swap result here\r\n                    blockDeadline //deadline is current block\r\n            );\r\n            \r\n            //make sure we received the required ETH (received from swapTokensForExactETH\r\n            require(address(this).balance - balanceBeforeSwap >= leg1ReceiveExactAmount, \"K\");\r\n        }\r\n        else if (leg1SendToken == _router1.WETH())\r\n        {\r\n            //require(address(this).balance >= leg1MaxSendAmount, \"9\"); //don't really need this here. can save some $ on contract deployment without it\r\n            \r\n            uint256 tokenBalanceBeforeSwap = IERC20(leg1ReceiveToken).balanceOf(address(this));\r\n            \r\n            //send and receive in uniswap interface are from uniswap's perspective\r\n            _router1.swapETHForExactTokens{ value: leg1MaxSendAmount }(\r\n                    leg1ReceiveExactAmount, //amount tokens out exact - i.e. from uniswap to us\r\n                    path,\r\n                    address(this), //we will receive the swap result into leg2SwapContract in preparation for our next swap\r\n                    blockDeadline //deadline is current block\r\n            );\r\n            //make sure we received the required tokens (received from swapETHForExactTokens)\r\n            require(IERC20(leg1ReceiveToken).balanceOf(address(this)) - tokenBalanceBeforeSwap >= leg1ReceiveExactAmount, \"L\");\r\n        }\r\n        else\r\n        {\r\n            //approve router to spend our tokens up to max amount\r\n            //require(IERC20(leg1SendToken).approve(leg1Exchange, leg1MaxSendAmount), \"M\");\r\n            //NOTE: ABOVE COMMENTED OUT DUE TO USDT BEING NON COMPLIENT WITH ERC20. USING .call INSTEAD above at J\r\n            \r\n            uint256 tokenBalanceBeforeSwap = IERC20(leg1ReceiveToken).balanceOf(address(this));\r\n            \r\n            //send and receive in uniswap interface are from uniswap's perspective\r\n            _router1.swapTokensForExactTokens(\r\n                    leg1ReceiveExactAmount, //amount tokens out exact - i.e. from uniswap to us\r\n                    leg1MaxSendAmount, //amount tokens in max - i.e. from us to uniswap\r\n                    path,\r\n                    address(this), //we will receive the swap result into leg2SwapContract in preparation for our next swap\r\n                    blockDeadline //deadline is current block\r\n            );\r\n            //make sure we received the required tokens (received from swapTokensForExactTokens)\r\n            require(IERC20(leg1ReceiveToken).balanceOf(address(this)) - tokenBalanceBeforeSwap >= leg1ReceiveExactAmount, \"N\");\r\n        }\r\n        \r\n    }\r\n    \r\n    function PerformLeg2Swap(address leg2Exchange, address leg1SendToken, address leg1ReceiveToken, uint256 leg1ReceiveExactAmount, uint256 leg2MinReceiveAmount, uint blockDeadline) public payable onlyOwner() {\r\n        \r\n        require(_allowedRouters[leg2Exchange] == true, \"O\");\r\n        \r\n        IUniswapV2Router02 _router2 = IUniswapV2Router02(leg2Exchange);\r\n        //IERC20 erc20Leg1ReceiveToken = IERC20(leg1ReceiveToken);\r\n        address[] memory path = new address[](2);\r\n        path[0] = leg1ReceiveToken; //what we received in leg 1 we send out on leg 2\r\n        path[1] = leg1SendToken; //what we sent out in leg 1 we get back in leg 2\r\n        \r\n        //approve router to spend our tokens up to max amount\r\n        if (leg1ReceiveToken != _router2.WETH()){\r\n            bytes memory params = abi.encodeWithSignature(\"approve(address,uint256)\", leg2Exchange, leg1ReceiveExactAmount);\r\n            (bool success, ) = leg1ReceiveToken\r\n                .call\r\n                (params);\r\n            //require successful\r\n            require(success, \"Q\");\r\n        }\r\n        \r\n        //perform leg 2 swap\r\n        if (leg1ReceiveToken == _router2.WETH()) //we are receiving ETH in leg 1, so we should swap exact ETH for tokens in leg 2\r\n        {\r\n            uint256 tokenBalanceBeforeSwap = IERC20(leg1SendToken).balanceOf(address(this));\r\n            \r\n            //send and receive in uniswap interface are from uniswap's perspective\r\n            _router2.swapExactETHForTokens{\r\n                value: leg1ReceiveExactAmount\r\n            }(\r\n                leg2MinReceiveAmount, //amount tokens out min - i.e. from uniswap to us\r\n                path,\r\n                address(this), //we will receive the swap result here\r\n                blockDeadline //deadline is current block\r\n            );\r\n            //make sure we receive correct amount of tokens from swapExactETHForTokens (possibly some tokens have burns that would try to fuck us)\r\n            require(IERC20(leg1SendToken).balanceOf(address(this)) - tokenBalanceBeforeSwap >= leg2MinReceiveAmount, \"P\");\r\n        }\r\n        else if (leg1SendToken == _router2.WETH()) //we spent ETH in leg 1, so we should get ETH back in leg 2 from our tokens received in leg 1\r\n        {\r\n            //approve router to spend our tokens up to max amount\r\n            //require(erc20Leg1ReceiveToken.approve(leg2Exchange, leg1ReceiveExactAmount), \"Q\");\r\n            //NOTE: ABOVE COMMENTED OUT DUE TO USDT BEING NON COMPLIENT WITH ERC20. USING .call INSTEAD above at Q\r\n            \r\n            uint256 balanceBeforeSwap = address(this).balance;\r\n            \r\n            //send and receive in uniswap interface are from uniswap's perspective\r\n            _router2.swapExactTokensForETH(\r\n                leg1ReceiveExactAmount, //amount tokens in exact - i.e. from us to uniswap\r\n                leg2MinReceiveAmount, //amount ETH out min - i.e. from uniswap to us\r\n                path,\r\n                address(this), //receive swap results here\r\n                blockDeadline //deadline is current block\r\n            );\r\n            \r\n            //make sure we received the required ETH (received from swapTokensForExactETH\r\n            require(address(this).balance - balanceBeforeSwap >= leg2MinReceiveAmount, \"R\");\r\n        }\r\n        else //we spent tokens in leg1, and receiving tokens in leg 2\r\n        {\r\n            //approve router to spend our tokens up to max amount\r\n            //require(erc20Leg1ReceiveToken.approve(leg2Exchange, leg1ReceiveExactAmount), \"S\");\r\n            //NOTE: ABOVE COMMENTED OUT DUE TO USDT BEING NON COMPLIENT WITH ERC20. USING .call INSTEAD above at Q\r\n            \r\n            uint256 tokenBalanceBeforeSwap = IERC20(leg1SendToken).balanceOf(address(this));\r\n            \r\n            //send and receive in uniswap interface are from uniswap's perspective\r\n            _router2.swapExactTokensForTokens(\r\n                leg1ReceiveExactAmount, //amount tokens in exact - i.e. from us to uniswap\r\n                leg2MinReceiveAmount, //amount tokens out min - i.e. from uniswap to us\r\n                path,\r\n                address(this), //we will receive the swap result to here\r\n                blockDeadline //deadline is current block\r\n            );\r\n            //make sure we receive correct amount of tokens from swapExactTokensForTokens (possibly some tokens have burns that would try to fuck us)\r\n            require(IERC20(leg1SendToken).balanceOf(address(this)) - tokenBalanceBeforeSwap >= leg2MinReceiveAmount, \"T\");\r\n        }\r\n        \r\n    }\r\n    \r\n    //addresses that are allowed to withdraw can also destruct the vault (this is a terrible idea if the vault currently owns any tokens as selfdestruct only transfers ETH and not tokens)\r\n    //function destroyMe() external {\r\n    //    require(_allowedToWithDraw[_msgSender()] == true, \"Denied.\");\r\n    //    //if we want to get rid of traces of our contract and have all ETH balance sent back to owner\r\n    //    selfdestruct(payable(_msgSender()));\r\n    //}\r\n    \r\n    //to recieve ETH\r\n    receive() external payable {}\r\n    \r\n}\r\n"}}}