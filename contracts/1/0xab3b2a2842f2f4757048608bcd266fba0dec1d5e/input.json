{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/NEW.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-01-20\n*/\n\npragma solidity 0.5.11;\n\n\ncontract NEW {\n\n    address public _owner;\n\n      //Structure to store the user related data\n      struct UserStruct {\n        bool isExist;\n        uint id;\n        uint referrerIDMatrix1;\n        uint referrerIDMatrix2;\n        address[] referralMatrix1;\n        address[] referralMatrix2;\n        uint referralCounter;\n        mapping(uint => uint) levelExpiredMatrix1;\n        mapping(uint => uint) levelExpiredMatrix2; \n    }\n\n    //A person can have maximum 2 branches\n    uint constant private REFERRER_1_LEVEL_LIMIT = 2;\n    //period of a particular level\n    uint constant private PERIOD_LENGTH = 60 days;\n    //person where the new user will be joined\n    uint public availablePersonID;\n    //Addresses of the Team   \n    address [] public shareHolders;\n    //cost of each level\n    mapping(uint => uint) public LEVEL_PRICE;\n\n    //data of each user from the address\n    mapping (address => UserStruct) public users;\n    //user address by their id\n    mapping (uint => address) public userList;\n    //to track latest user ID\n    uint public currUserID = 0;\n\n    event regLevelEvent(address indexed _user, address indexed _referrer, uint _time);\n    event buyLevelEvent(address indexed _user, uint _level, uint _time, uint _matrix);\n    event prolongateLevelEvent(address indexed _user, uint _level, uint _time);\n    event getMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, uint _matrix);\n    event lostMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time, uint _matrix);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() public {\n        _owner = msg.sender;\n\n        LEVEL_PRICE[1] = 0.05 ether;\n        LEVEL_PRICE[2] = 0.1 ether;\n        LEVEL_PRICE[3] = 0.3 ether;\n        LEVEL_PRICE[4] = 1.25 ether;\n        LEVEL_PRICE[5] = 5 ether;\n        LEVEL_PRICE[6] = 10 ether;\n        \n        availablePersonID = 1;\n\n    }\n\n    /**\n     * @dev allows only the user to run the function\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"only Owner\");\n        _;\n    }\n\n    function () external payable {\n      \n        uint level;\n\n        //check the level on the basis of amount sent\n        if(msg.value == LEVEL_PRICE[1]) level = 1;\n        else if(msg.value == LEVEL_PRICE[2]) level = 2;\n        else if(msg.value == LEVEL_PRICE[3]) level = 3;\n        else if(msg.value == LEVEL_PRICE[4]) level = 4;\n        else if(msg.value == LEVEL_PRICE[5]) level = 5;\n        else if(msg.value == LEVEL_PRICE[6]) level = 6;\n        \n        else revert('Incorrect Value send, please check');\n\n        //if user has already registered previously\n        if(users[msg.sender].isExist) \n            buyLevelMatrix1(level);\n\n        else if(level == 1) {\n            uint refId = 0;\n            address referrer = bytesToAddress(msg.data);\n\n            if(users[referrer].isExist) refId = users[referrer].id;\n            else revert('Incorrect referrer id');\n\n            regUser(refId);\n        }\n        else revert('Please buy first level for 0.05 ETH and then proceed');\n    }\n\n    /**\n        * @dev function to register the user after the pre registration\n        * @param _referrerID id of the referrer\n    */\n    function regUser(uint _referrerID) public payable {\n\n        require(!users[msg.sender].isExist, 'User exist');\n        require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referrer Id');\n        require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\n        \n\n        uint _referrerIDMatrix1;\n        uint _referrerIDMatrix2 = _referrerID;\n\n        _referrerIDMatrix1 = findAvailablePersonMatrix1();\n\n        if(users[userList[_referrerIDMatrix2]].referralMatrix2.length >= REFERRER_1_LEVEL_LIMIT) \n            _referrerIDMatrix2 = users[findAvailablePersonMatrix2(userList[_referrerIDMatrix2])].id;\n        \n\n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist: true,\n            id: currUserID,\n            referrerIDMatrix1: _referrerIDMatrix1,\n            referrerIDMatrix2: _referrerIDMatrix2,\n            referralCounter: 0,\n            referralMatrix1: new address[](0),\n            referralMatrix2: new address[](0)\n        });\n\n        users[msg.sender] = userStruct;\n        userList[currUserID] = msg.sender;\n\n        \n        users[msg.sender].levelExpiredMatrix1[1] = now + PERIOD_LENGTH;\n\n        users[userList[_referrerIDMatrix1]].referralMatrix1.push(msg.sender);\n        users[userList[_referrerIDMatrix2]].referralMatrix2.push(msg.sender);\n\n        payForLevelMatrix1(1,msg.sender);\n\n        //increase the referrer counter of the referrer\n        users[userList[_referrerID]].referralCounter++;\n\n        emit regLevelEvent(msg.sender, userList[_referrerID], now);\n    }\n\n    /**\n        * @dev function to register the user in the pre registration\n    */\n    function preRegAdmins(address [] memory _adminAddress) public onlyOwner{\n\n        require(currUserID <= 100, \"No more admins can be registered\");\n\n        UserStruct memory userStruct;\n\n        for(uint i = 0; i < _adminAddress.length; i++){\n\n            require(!users[_adminAddress[i]].isExist, 'One of the users exist');\n            currUserID++;\n\n            if(currUserID == 1){\n                userStruct = UserStruct({\n                isExist: true,\n                id: currUserID,\n                referrerIDMatrix1: 1,\n                referrerIDMatrix2: 1,\n                referralCounter: 2,\n                referralMatrix1: new address[](0),\n                referralMatrix2: new address[](0)\n        });\n\n            users[_adminAddress[i]] = userStruct;\n            userList[currUserID] = _adminAddress[i];\n\n            for(uint j = 1; j <= 6; j++) {\n                users[_adminAddress[i]].levelExpiredMatrix1[j] = 66666666666;\n                users[_adminAddress[i]].levelExpiredMatrix2[j] = 66666666666;\n            }\n            \n        }\n            else {\n                    uint _referrerIDMatrix1;\n                    uint _referrerIDMatrix2 = 1;\n\n                    _referrerIDMatrix1 = findAvailablePersonMatrix1();\n\n                    if(users[userList[_referrerIDMatrix2]].referralMatrix2.length >= REFERRER_1_LEVEL_LIMIT) \n                        _referrerIDMatrix2 = users[findAvailablePersonMatrix2(userList[_referrerIDMatrix2])].id;\n\n                                       \n                    userStruct = UserStruct({\n                        isExist: true,\n                        id: currUserID,\n                        referrerIDMatrix1: _referrerIDMatrix1,\n                        referrerIDMatrix2: _referrerIDMatrix2,\n                        referralCounter: 2,\n                        referralMatrix1: new address[](0),\n                        referralMatrix2: new address[](0)\n                    });\n\n                    users[_adminAddress[i]] = userStruct;\n                    userList[currUserID] = _adminAddress[i];\n\n                    for(uint j = 1; j <= 6; j++) {\n                        users[_adminAddress[i]].levelExpiredMatrix1[j] = 66666666666;\n                        users[_adminAddress[i]].levelExpiredMatrix2[j] = 66666666666;\n                    }\n\n                    users[userList[_referrerIDMatrix1]].referralMatrix1.push(_adminAddress[i]);\n                    users[userList[_referrerIDMatrix2]].referralMatrix2.push(_adminAddress[i]);\n\n                }\n    }\n}\n\n    function addShareHolder(address [] memory _shareHolderAddress) public onlyOwner returns(address[] memory){\n\n        for(uint i=0; i < _shareHolderAddress.length; i++){\n\n            if(shareHolders.length < 20) {\n                shareHolders.push(_shareHolderAddress[i]);\n            }\n        }\n        return shareHolders;\n    }\n\n    function removeShareHolder(address  _shareHolderAddress) public onlyOwner returns(address[] memory){\n\n        for(uint i=0; i < shareHolders.length; i++){\n            if(shareHolders[i] == _shareHolderAddress) {\n                shareHolders[i] = shareHolders[shareHolders.length-1];\n                delete shareHolders[shareHolders.length-1];\n                shareHolders.length--;\n            }\n        }\n        return shareHolders;\n\n    }\n\n    /**\n        * @dev function to find the next available person in the complete binary tree\n        * @return id of the available person in the tree.\n    */\n    function findAvailablePersonMatrix1() internal returns(uint){\n       \n        uint _referrerID;\n        uint _referralLength = users[userList[availablePersonID]].referralMatrix1.length;\n        \n         if(_referralLength == REFERRER_1_LEVEL_LIMIT) {       \n             availablePersonID++;\n             _referrerID = availablePersonID;\n        }\n        else if( _referralLength == 1) {\n            _referrerID = availablePersonID;\n            availablePersonID++;            \n        }\n        else{\n             _referrerID = availablePersonID;\n        }\n\n        return _referrerID;\n    }\n\n    function findAvailablePersonMatrix2(address _user) public view returns(address) {\n        if(users[_user].referralMatrix2.length < REFERRER_1_LEVEL_LIMIT) return _user;\n\n        address[] memory referrals = new address[](1022);\n        referrals[0] = users[_user].referralMatrix2[0];\n        referrals[1] = users[_user].referralMatrix2[1];\n\n        address freeReferrer;\n        bool noFreeReferrer = true;\n\n        for(uint i = 0; i < 1022; i++) {\n            if(users[referrals[i]].referralMatrix2.length == REFERRER_1_LEVEL_LIMIT) {\n                if(i < 510) {\n                    referrals[(i+1)*2] = users[referrals[i]].referralMatrix2[0];\n                    referrals[(i+1)*2+1] = users[referrals[i]].referralMatrix2[1];\n                }\n            }\n            else {\n                noFreeReferrer = false;\n                freeReferrer = referrals[i];\n                break;\n            }\n        }\n\n        require(!noFreeReferrer, 'No Free Referrer');\n\n        return freeReferrer;\n    }\n\n   \n\n    /**\n        * @dev function to buy the level for Company forced matrix\n        * @param _level level which a user wants to buy\n    */\n    function buyLevelMatrix1(uint _level) public payable {\n\n        require(users[msg.sender].isExist, 'User not exist'); \n        require(_level > 0 && _level <= 6, 'Incorrect level');\n\n        if(_level == 1) {\n            require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\n\n            if(users[msg.sender].levelExpiredMatrix1[1] > now)             \n                users[msg.sender].levelExpiredMatrix1[1] += PERIOD_LENGTH;\n                            \n            else \n                users[msg.sender].levelExpiredMatrix1[1] = now + PERIOD_LENGTH;\n            \n        }\n        else {\n            require(msg.value == LEVEL_PRICE[_level], 'Incorrect Value');\n\n            for(uint l =_level - 1; l > 0; l--) require(users[msg.sender].levelExpiredMatrix1[l] >= now, 'Buy the previous level');\n\n            if(users[msg.sender].levelExpiredMatrix1[_level] == 0 || now > users[msg.sender].levelExpiredMatrix1[_level])\n                users[msg.sender].levelExpiredMatrix1[_level] = now + PERIOD_LENGTH;\n            else users[msg.sender].levelExpiredMatrix1[_level] += PERIOD_LENGTH;\n        }\n\n        payForLevelMatrix1(_level, msg.sender);\n\n        emit buyLevelEvent(msg.sender, _level, now, 1);\n    }\n\n    /**\n        * @dev function to buy the level for Team matrix\n        * @param _level level which a user wants to buy\n    */\n    function buyLevelMatrix2(uint _level) public payable {\n        \n        require(users[msg.sender].isExist, 'User not exist'); \n        require(users[msg.sender].referralCounter >= 2, 'Need atleast 2 direct referrals to activate Team Matrix');\n        require(_level > 0 && _level <= 6, 'Incorrect level');\n\n        if(_level == 1) {\n            require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\n\n            if(users[msg.sender].levelExpiredMatrix2[1] > now)               \n                users[msg.sender].levelExpiredMatrix2[1] += PERIOD_LENGTH;\n                            \n            else \n                users[msg.sender].levelExpiredMatrix2[1] = now + PERIOD_LENGTH;\n            \n       }\n        else {\n            require(msg.value == LEVEL_PRICE[_level], 'Incorrect Value');\n\n            for(uint l =_level - 1; l > 0; l--) require(users[msg.sender].levelExpiredMatrix2[l] >= now, 'Buy the previous level');\n\n            if(users[msg.sender].levelExpiredMatrix2[_level] == 0 || now > users[msg.sender].levelExpiredMatrix2[_level]) \n                users[msg.sender].levelExpiredMatrix2[_level] = now + PERIOD_LENGTH;\n            \n            else users[msg.sender].levelExpiredMatrix2[_level] += PERIOD_LENGTH;\n        }\n\n        payForLevelMatrix2(_level, msg.sender);\n\n        emit buyLevelEvent(msg.sender, _level, now, 2);\n    }\n\n    function payForLevelMatrix1(uint _level, address _user) internal {\n        address actualReferer;\n        address tempReferer1;\n        address tempReferer2;\n        uint userID;\n\n        if(_level == 1) {\n            actualReferer = userList[users[_user].referrerIDMatrix1];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 2) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix1];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 3) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\n            actualReferer = userList[users[tempReferer2].referrerIDMatrix1];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 4) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix1];\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix1];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 5) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix1];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\n            actualReferer = userList[users[tempReferer2].referrerIDMatrix1];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 6) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix1];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix1];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix1];\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix1];\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix1];\n            userID = users[actualReferer].id;\n        }\n\n        if(!users[actualReferer].isExist) actualReferer = userList[1];\n\n        bool sent = false;\n        \n        if(userID > 0 && userID <= 63) {\n           for(uint i=0; i < shareHolders.length; i++) {\n                address(uint160(shareHolders[i])).transfer(LEVEL_PRICE[_level]/(shareHolders.length));\n                emit getMoneyForLevelEvent(shareHolders[i], msg.sender, _level, now, 1);\n            }\n            if(address(this).balance > 0)\n                address(uint160(userList[1])).transfer(address(this).balance);\n          }\n        \n        else{\n          if(users[actualReferer].levelExpiredMatrix1[_level] >= now && users[actualReferer].referralCounter >= 2) {\n              sent = address(uint160(actualReferer)).send(LEVEL_PRICE[_level]);\n                if (sent) {\n                        emit getMoneyForLevelEvent(actualReferer, msg.sender, _level, now, 1);\n                    }\n                }\n            if(!sent) {\n              emit lostMoneyForLevelEvent(actualReferer, msg.sender, _level, now, 1);\n                payForLevelMatrix1(_level, actualReferer);\n             }\n\n        }\n            \n    }\n\n    function payForLevelMatrix2(uint _level, address _user) internal {\n        address actualReferer;\n        address tempReferer1;\n        address tempReferer2;\n        uint userID;\n\n        if(_level == 1) {\n            actualReferer = userList[users[_user].referrerIDMatrix2];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 2) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix2];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 3) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\n            actualReferer = userList[users[tempReferer2].referrerIDMatrix2];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 4) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix2];\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix2];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 5) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix2];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\n            actualReferer = userList[users[tempReferer2].referrerIDMatrix2];\n            userID = users[actualReferer].id;\n        }\n        else if(_level == 6) {\n            tempReferer1 = userList[users[_user].referrerIDMatrix2];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix2];\n            tempReferer2 = userList[users[tempReferer1].referrerIDMatrix2];\n            tempReferer1 = userList[users[tempReferer2].referrerIDMatrix2];\n            actualReferer = userList[users[tempReferer1].referrerIDMatrix2];\n            userID = users[actualReferer].id;\n        }\n\n        if(!users[actualReferer].isExist) actualReferer = userList[1];\n\n        bool sent = false;\n        \n        if(userID > 0 && userID <= 63) {\n           for(uint i=0; i < shareHolders.length; i++) {\n                address(uint160(shareHolders[i])).transfer(LEVEL_PRICE[_level]/(shareHolders.length));\n                emit getMoneyForLevelEvent(shareHolders[i], msg.sender, _level, now, 2);\n            }\n            if(address(this).balance > 0)\n                address(uint160(userList[1])).transfer(address(this).balance);\n          }\n        \n        else{\n          if(users[actualReferer].levelExpiredMatrix2[_level] >= now) {\n              sent = address(uint160(actualReferer)).send(LEVEL_PRICE[_level]);\n                if (sent) {\n                        emit getMoneyForLevelEvent(actualReferer, msg.sender, _level, now, 2);\n                    }\n                }\n            if(!sent) {\n              emit lostMoneyForLevelEvent(actualReferer, msg.sender, _level, now, 2);\n                payForLevelMatrix2(_level, actualReferer);\n             }\n\n        }\n            \n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n     /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Read only function to see the 2 children of a node in Company forced matrix\n     * @return 2 branches\n     */\n    function viewUserReferralMatrix1(address _user) public view returns(address[] memory) {\n        return users[_user].referralMatrix1;\n    }\n\n    /**\n     * @dev Read only function to see the 2 children of a node in Team Matrix\n     * @return 2 branches\n     */\n    function viewUserReferralMatrix2(address _user) public view returns(address[] memory) {\n        return users[_user].referralMatrix2;\n    }\n    \n    /**\n     * @dev Read only function to see the expiration time of a particular level in Company forced Matrix\n     * @return unix timestamp\n     */\n    function viewUserLevelExpiredMatrix1(address _user, uint _level) public view returns(uint256) {\n        return users[_user].levelExpiredMatrix1[_level];\n    }\n\n    /**\n     * @dev Read only function to see the expiration time of a particular level in Team Matrix\n     * @return unix timestamp\n     */\n    function viewUserLevelExpiredMatrix2(address _user, uint _level) public view returns(uint256) {\n        return users[_user].levelExpiredMatrix2[_level];\n    }\n\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n}"
    }
  }
}