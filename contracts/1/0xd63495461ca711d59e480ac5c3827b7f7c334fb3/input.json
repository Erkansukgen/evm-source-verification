{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/PoolPortal.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ninterface ITokensTypeStorage {\n  function isRegistred(address _address) external view returns(bool);\n\n  function getType(address _address) external view returns(bytes32);\n\n  function isPermittedAddress(address _address) external view returns(bool);\n\n  function owner() external view returns(address);\n\n  function addNewTokenType(address _token, string calldata _type) external;\n\n  function setTokenTypeAsOwner(address _token, string calldata _type) external;\n}\ninterface UniswapFactoryInterface {\n    // Create Exchange\n    function createExchange(address token) external returns (address exchange);\n    // Get Exchange and Token Info\n    function getExchange(address token) external view returns (address exchange);\n    function getToken(address exchange) external view returns (address token);\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\n    // Never use\n    function initializeFactory(address template) external;\n}\ninterface UniswapExchangeInterface {\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\n\n    // ERC20 comaptibility for liquidity tokens\n    function name() external view returns(bytes32);\n    function symbol() external view returns(bytes32);\n    function decimals() external view returns(uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    // Never use\n    function setup(address token_addr) external;\n}\ninterface IBancorFormula {\n    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) external view returns (uint256);\n    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) external view returns (uint256);\n    function calculateCrossReserveReturn(uint256 _fromReserveBalance, uint32 _fromReserveRatio, uint256 _toReserveBalance, uint32 _toReserveRatio, uint256 _amount) external view returns (uint256);\n    function calculateFundCost(uint256 _supply, uint256 _reserveBalance, uint32 _totalRatio, uint256 _amount) external view returns (uint256);\n    function calculateLiquidateReturn(uint256 _supply, uint256 _reserveBalance, uint32 _totalRatio, uint256 _amount) external view returns (uint256);\n}\ninterface IGetBancorAddressFromRegistry {\n  function getBancorContractAddresByName(string calldata _name) external view returns (address result);\n}\ninterface IGetRatioForBancorAssets {\n  function getRatio(address _from, address _to, uint256 _amount) external view returns(uint256 result);\n}\n\n\ninterface BancorConverterInterface {\n  function connectorTokens(uint index) external view returns(IERC20);\n  function fund(uint256 _amount) external;\n  function liquidate(uint256 _amount) external;\n  function getConnectorBalance(IERC20 _connectorToken) external view returns (uint256);\n}\n\n\n/*\n* This contract allow buy/sell pool for Bancor and Uniswap assets\n* and provide ratio and addition info for pool assets\n*/\n\n\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n\n\ninterface SmartTokenInterface is IERC20 {\n  function disableTransfers(bool _disable) external;\n  function issue(address _to, uint256 _amount) external;\n  function destroy(address _from, uint256 _amount) external;\n  function owner() external view returns (address);\n}\n\n\n\n\n\n\n\n\n\ncontract PoolPortal {\n  using SafeMath for uint256;\n\n  IGetRatioForBancorAssets public bancorRatio;\n  IGetBancorAddressFromRegistry public bancorRegistry;\n  UniswapFactoryInterface public uniswapFactory;\n\n  address public BancorEtherToken;\n\n  // CoTrader platform recognize ETH by this address\n  IERC20 constant private ETH_TOKEN_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n  // Enum\n  // NOTE: You can add a new type at the end, but do not change this order\n  enum PortalType { Bancor, Uniswap }\n\n  // events\n  event BuyPool(address poolToken, uint256 amount, address trader);\n  event SellPool(address poolToken, uint256 amount, address trader);\n\n  // Contract for handle tokens types\n  ITokensTypeStorage public tokensTypes;\n\n  /**\n  * @dev contructor\n  *\n  * @param _bancorRegistryWrapper  address of GetBancorAddressFromRegistry\n  * @param _bancorRatio            address of GetRatioForBancorAssets\n  * @param _bancorEtherToken       address of Bancor ETH wrapper\n  * @param _uniswapFactory         address of Uniswap factory contract\n  * @param _tokensTypes            address of the ITokensTypeStorage\n  */\n  constructor(\n    address _bancorRegistryWrapper,\n    address _bancorRatio,\n    address _bancorEtherToken,\n    address _uniswapFactory,\n    address _tokensTypes\n\n  )\n  public\n  {\n    bancorRegistry = IGetBancorAddressFromRegistry(_bancorRegistryWrapper);\n    bancorRatio = IGetRatioForBancorAssets(_bancorRatio);\n    BancorEtherToken = _bancorEtherToken;\n    uniswapFactory = UniswapFactoryInterface(_uniswapFactory);\n    tokensTypes = ITokensTypeStorage(_tokensTypes);\n  }\n\n\n  /**\n  * @dev buy Bancor or Uniswap pool\n  *\n  * @param _amount     amount of pool token\n  * @param _type       pool type\n  * @param _poolToken  pool token address\n  */\n  function buyPool\n  (\n    uint256 _amount,\n    uint _type,\n    IERC20 _poolToken\n  )\n  external\n  payable\n  {\n    if(_type == uint(PortalType.Bancor)){\n      buyBancorPool(_poolToken, _amount);\n    }\n    else if (_type == uint(PortalType.Uniswap)){\n      require(_amount == msg.value, \"Not enough ETH\");\n      buyUniswapPool(address(_poolToken), _amount);\n    }\n    else{\n      // unknown portal type\n      revert();\n    }\n\n    emit BuyPool(address(_poolToken), _amount, msg.sender);\n  }\n\n\n  /**\n  * @dev helper for buy pool in Bancor network\n  *\n  * @param _poolToken        address of bancor converter\n  * @param _amount           amount of bancor relay\n  */\n  function buyBancorPool(IERC20 _poolToken, uint256 _amount) private {\n    // get Bancor converter\n    address converterAddress = getBacorConverterAddressByRelay(address(_poolToken));\n    // calculate connectors amount for buy certain pool amount\n    (uint256 bancorAmount,\n     uint256 connectorAmount) = getBancorConnectorsAmountByRelayAmount(_amount, _poolToken);\n    // get converter as contract\n    BancorConverterInterface converter = BancorConverterInterface(converterAddress);\n    // approve bancor and coonector amount to converter\n    // get connectors\n    (IERC20 bancorConnector,\n    IERC20 ercConnector) = getBancorConnectorsByRelay(address(_poolToken));\n    // reset approve (some ERC20 not allow do new approve if already approved)\n    bancorConnector.approve(converterAddress, 0);\n    ercConnector.approve(converterAddress, 0);\n    // transfer from fund and approve to converter\n    _transferFromSenderAndApproveTo(bancorConnector, bancorAmount, converterAddress);\n    _transferFromSenderAndApproveTo(ercConnector, connectorAmount, converterAddress);\n    // buy relay from converter\n    converter.fund(_amount);\n\n    require(_amount > 0, \"BNT pool recieved amount can not be zerro\");\n\n    // transfer relay back to smart fund\n    _poolToken.transfer(msg.sender, _amount);\n\n    // transfer connectors back if a small amount remains\n    uint256 bancorRemains = bancorConnector.balanceOf(address(this));\n    if(bancorRemains > 0)\n       bancorConnector.transfer(msg.sender, bancorRemains);\n\n    uint256 ercRemains = ercConnector.balanceOf(address(this));\n    if(ercRemains > 0)\n        ercConnector.transfer(msg.sender, ercRemains);\n\n    setTokenType(address(_poolToken), \"BANCOR_ASSET\");\n  }\n\n\n  /**\n  * @dev helper for buy pool in Uniswap network\n  *\n  * @param _poolToken        address of Uniswap exchange\n  * @param _ethAmount        ETH amount (in wei)\n  */\n  function buyUniswapPool(address _poolToken, uint256 _ethAmount)\n  private\n  returns(uint256 poolAmount)\n  {\n    // get token address\n    address tokenAddress = uniswapFactory.getToken(_poolToken);\n    // check if such a pool exist\n    if(tokenAddress != address(0x0000000000000000000000000000000000000000)){\n      // get tokens amd approve to exchange\n      uint256 erc20Amount = getUniswapTokenAmountByETH(tokenAddress, _ethAmount);\n      _transferFromSenderAndApproveTo(IERC20(tokenAddress), erc20Amount, _poolToken);\n      // get exchange contract\n      UniswapExchangeInterface exchange = UniswapExchangeInterface(_poolToken);\n      // set deadline\n      uint256 deadline = now + 15 minutes;\n      // buy pool\n      poolAmount = exchange.addLiquidity.value(_ethAmount)(\n        1,\n        erc20Amount,\n        deadline);\n      // reset approve (some ERC20 not allow do new approve if already approved)\n      IERC20(tokenAddress).approve(_poolToken, 0);\n\n      require(poolAmount > 0, \"UNI pool recieved amount can not be zerro\");\n\n      // transfer pool token back to smart fund\n      IERC20(_poolToken).transfer(msg.sender, poolAmount);\n      // transfer ERC20 remains\n      uint256 remainsERC = IERC20(tokenAddress).balanceOf(address(this));\n      if(remainsERC > 0)\n          IERC20(tokenAddress).transfer(msg.sender, remainsERC);\n\n      setTokenType(_poolToken, \"UNISWAP_POOL\");\n    }else{\n      // throw if such pool not Exist in Uniswap network\n      revert();\n    }\n  }\n\n  /**\n  * @dev return token amount by ETH input ratio\n  *\n  * @param _token     address of ERC20 token\n  * @param _amount    ETH amount (in wei)\n  */\n  function getUniswapTokenAmountByETH(address _token, uint256 _amount)\n    public\n    view\n    returns(uint256)\n  {\n    UniswapExchangeInterface exchange = UniswapExchangeInterface(\n      uniswapFactory.getExchange(_token));\n    return exchange.getTokenToEthOutputPrice(_amount);\n  }\n\n\n  /**\n  * @dev sell Bancor or Uniswap pool\n  *\n  * @param _amount     amount of pool token\n  * @param _type       pool type\n  * @param _poolToken  pool token address\n  */\n  function sellPool\n  (\n    uint256 _amount,\n    uint _type,\n    IERC20 _poolToken\n  )\n  external\n  payable\n  {\n    if(_type == uint(PortalType.Bancor)){\n      sellPoolViaBancor(_poolToken, _amount);\n    }\n    else if (_type == uint(PortalType.Uniswap)){\n      sellPoolViaUniswap(_poolToken, _amount);\n    }\n    else{\n      // unknown portal type\n      revert();\n    }\n\n    emit SellPool(address(_poolToken), _amount, msg.sender);\n  }\n\n  /**\n  * @dev helper for sell pool in Bancor network\n  *\n  * @param _poolToken        address of bancor relay\n  * @param _amount           amount of bancor relay\n  */\n  function sellPoolViaBancor(IERC20 _poolToken, uint256 _amount) private {\n    // transfer pool from fund\n    _poolToken.transferFrom(msg.sender, address(this), _amount);\n    // get Bancor Converter address\n    address converterAddress = getBacorConverterAddressByRelay(address(_poolToken));\n    // liquidate relay\n    BancorConverterInterface(converterAddress).liquidate(_amount);\n    // get connectors\n    (IERC20 bancorConnector,\n    IERC20 ercConnector) = getBancorConnectorsByRelay(address(_poolToken));\n    // transfer connectors back to fund\n    bancorConnector.transfer(msg.sender, bancorConnector.balanceOf(address(this)));\n    ercConnector.transfer(msg.sender, ercConnector.balanceOf(address(this)));\n  }\n\n\n  /**\n  * @dev helper for sell pool in Uniswap network\n  *\n  * @param _poolToken        address of uniswap exchane\n  * @param _amount           amount of uniswap pool\n  */\n  function sellPoolViaUniswap(IERC20 _poolToken, uint256 _amount) private {\n    address tokenAddress = uniswapFactory.getToken(address(_poolToken));\n    // check if such a pool exist\n    if(tokenAddress != address(0x0000000000000000000000000000000000000000)){\n      UniswapExchangeInterface exchange = UniswapExchangeInterface(address(_poolToken));\n      // approve pool token\n      _transferFromSenderAndApproveTo(IERC20(_poolToken), _amount, address(_poolToken));\n      // get min returns\n      (uint256 minEthAmount,\n        uint256 minErcAmount) = getUniswapConnectorsAmountByPoolAmount(\n          _amount,\n          address(_poolToken));\n      // set deadline\n      uint256 deadline = now + 15 minutes;\n      // liquidate\n      (uint256 eth_amount,\n       uint256 token_amount) = exchange.removeLiquidity(\n         _amount,\n         minEthAmount,\n         minErcAmount,\n         deadline);\n      // transfer assets back to smart fund\n      msg.sender.transfer(eth_amount);\n      IERC20(tokenAddress).transfer(msg.sender, token_amount);\n    }else{\n      revert();\n    }\n  }\n\n  /**\n  * @dev helper for get bancor converter by bancor relay addrses\n  *\n  * @param _relay       address of bancor relay\n  */\n  function getBacorConverterAddressByRelay(address _relay)\n    public\n    view\n    returns(address converter)\n  {\n    converter = SmartTokenInterface(_relay).owner();\n  }\n\n\n  /**\n  * @dev helper for get Bancor ERC20 connectors addresses\n  *\n  * @param _relay       address of bancor relay\n  */\n  function getBancorConnectorsByRelay(address _relay)\n    public\n    view\n    returns(\n    IERC20 BNTConnector,\n    IERC20 ERCConnector\n    )\n  {\n    address converterAddress = getBacorConverterAddressByRelay(_relay);\n    BancorConverterInterface converter = BancorConverterInterface(converterAddress);\n    BNTConnector = converter.connectorTokens(0);\n    ERCConnector = converter.connectorTokens(1);\n  }\n\n\n  /**\n  * @dev return ERC20 address from Uniswap exchange address\n  *\n  * @param _exchange       address of uniswap exchane\n  */\n  function getTokenByUniswapExchange(address _exchange)\n    external\n    view\n    returns(address)\n  {\n    return uniswapFactory.getToken(_exchange);\n  }\n\n\n  /**\n  * @dev helper for get amounts for both Uniswap connectors for input amount of pool\n  *\n  * @param _amount         relay amount\n  * @param _exchange       address of uniswap exchane\n  */\n  function getUniswapConnectorsAmountByPoolAmount(\n    uint256 _amount,\n    address _exchange\n  )\n    public\n    view\n    returns(uint256 ethAmount, uint256 ercAmount)\n  {\n    IERC20 token = IERC20(uniswapFactory.getToken(_exchange));\n    // total_liquidity exchange.totalSupply\n    uint256 totalLiquidity = UniswapExchangeInterface(_exchange).totalSupply();\n    // ethAmount = amount * exchane.eth.balance / total_liquidity\n    ethAmount = _amount.mul(_exchange.balance).div(totalLiquidity);\n    // ercAmount = amount * token.balanceOf(exchane) / total_liquidity\n    ercAmount = _amount.mul(token.balanceOf(_exchange)).div(totalLiquidity);\n  }\n\n\n  /**\n  * @dev helper for get amount for both Bancor connectors for input amount of pool\n  *\n  * @param _amount      relay amount\n  * @param _relay       address of bancor relay\n  */\n  function getBancorConnectorsAmountByRelayAmount\n  (\n    uint256 _amount,\n    IERC20 _relay\n  )\n    public\n    view\n    returns(uint256 bancorAmount, uint256 connectorAmount)\n  {\n    // get converter contract\n    BancorConverterInterface converter = BancorConverterInterface(\n      SmartTokenInterface(address(_relay)).owner());\n    // calculate BNT and second connector amount\n    // get connectors\n    IERC20 bancorConnector = converter.connectorTokens(0);\n    IERC20 ercConnector = converter.connectorTokens(1);\n    // get connectors balance\n    uint256 bntBalance = converter.getConnectorBalance(bancorConnector);\n    uint256 ercBalance = converter.getConnectorBalance(ercConnector);\n    // get bancor formula contract\n    IBancorFormula bancorFormula = IBancorFormula(\n      bancorRegistry.getBancorContractAddresByName(\"BancorFormula\"));\n    // calculate input\n    bancorAmount = bancorFormula.calculateFundCost(\n      _relay.totalSupply(),\n      bntBalance,\n      1000000,\n       _amount);\n    connectorAmount = bancorFormula.calculateFundCost(\n      _relay.totalSupply(),\n      ercBalance,\n      1000000,\n       _amount);\n  }\n\n\n  /**\n  * @dev helper for get ratio between assets in bancor newtork\n  *\n  * @param _from      token or relay address\n  * @param _to        token or relay address\n  * @param _amount    amount from\n  */\n  function getBancorRatio(address _from, address _to, uint256 _amount)\n  external\n  view\n  returns(uint256)\n  {\n    // Change ETH to Bancor ETH wrapper\n    address fromAddress = IERC20(_from) == ETH_TOKEN_ADDRESS ? BancorEtherToken : _from;\n    address toAddress = IERC20(_to) == ETH_TOKEN_ADDRESS ? BancorEtherToken : _to;\n    // return Bancor ratio\n    return bancorRatio.getRatio(fromAddress, toAddress, _amount);\n  }\n\n\n  /**\n  * @dev Transfers tokens to this contract and approves them to another address\n  *\n  * @param _source          Token to transfer and approve\n  * @param _sourceAmount    The amount to transfer and approve (in _source token)\n  * @param _to              Address to approve to\n  */\n  function _transferFromSenderAndApproveTo(IERC20 _source, uint256 _sourceAmount, address _to) private {\n    require(_source.transferFrom(msg.sender, address(this), _sourceAmount));\n\n    _source.approve(_to, _sourceAmount);\n  }\n\n  // Pool portal can mark each pool token as UNISWAP or BANCOR\n  function setTokenType(address _token, string memory _type) private {\n    // no need add type, if token alredy registred\n    if(tokensTypes.isRegistred(_token))\n      return;\n\n    tokensTypes.addNewTokenType(_token,  _type);\n  }\n\n  // fallback payable function to receive ether from other contract addresses\n  fallback() external payable {}\n}\n"
    }
  }
}