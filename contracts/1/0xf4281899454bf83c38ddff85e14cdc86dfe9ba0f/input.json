{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "interface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n\n\tfunction totalSupply() external view returns (uint);\n\tfunction balanceOf(address tokenOwner) external view returns (uint balance);\n\tfunction allowance(address tokenOwner, address spender) external view returns (uint remaining);\n\tfunction transfer(address to, uint tokens) external; //returns (bool success);\n\tfunction approve(address spender, uint tokens) external; //returns (bool success);\n\tfunction transferFrom(address from, address to, uint tokens) external; //returns (bool success);\n\tfunction symbol() external view returns (string memory);\n\tfunction name() external view returns (string memory);\n\tfunction decimals() external view returns (uint8);\n\tevent Transfer(address indexed from, address indexed to, uint tokens);\n\tevent Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n\n} \n\ninterface IWETH is IERC20 {\n\n\tfunction deposit() external payable;\n\tfunction withdraw(uint wad) external;\n\n}\n\ninterface ITickLens {\n\t\n\tstruct PopulatedTick {\n\t\tint24 tick;\n\t\tint128 liquidityNet;\n\t\tuint128 liquidityGross;\n\t}\n\n\tfunction getPopulatedTicksInWord(address pool, int16 tickBitmapIndex)\n\t\texternal view\n\treturns (PopulatedTick[] memory populatedTicks);\n}\n\ninterface IV2Pool {\n    //interface IUniswapV2Pair\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n\ninterface IV3Pool {\n\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n    function liquidity() external view returns (uint128);\n    function tickSpacing() external view returns (int24);\n}\n\n"
    },
    "multiscanner.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.7.0 <0.9.0;\npragma abicoder v2;\n\nimport 'interface.sol';\n\ncontract MultiScanner {\n\n\tstruct SinglePool {\n\t\taddress pool;\n\t\taddress tickLensAddress;\n\t\tuint256 nTickGroups;\n\t}\n\n\tfunction getTickList(address tickLensAddress, address poolAddress, int24 tick, uint256 nTickGroups)\n\t\tpublic view \n\t\treturns(ITickLens.PopulatedTick[] memory tickList)\n\t{\n\n\t\tITickLens tickLens = ITickLens(tickLensAddress);\n\t\tIV3Pool pool = IV3Pool(poolAddress);\n\t\tint256 tickSpacing = int256(pool.tickSpacing());\n\t\tint256 word = tick / (tickSpacing*2**8);\n\n\t\tint256 startWord = word - int(nTickGroups);\n\t\tif (startWord < -32768) {\n\t\t\tstartWord = -32768;\n\t\t}\n\t\tint256 endWord = word + int(nTickGroups);\n\t\tif (endWord > 32767) {\n\t\t\tendWord = 32767;\n\t\t}\n\n\t\tITickLens.PopulatedTick[][] memory tickWords = new ITickLens.PopulatedTick[][](uint(endWord-startWord)+1);\n\t\tuint256 tickCounter = 0;\n\n\t\tfor (int256 i=startWord; i<=endWord; i++) {\n\t\t\tITickLens.PopulatedTick[] memory tickWord = tickLens.getPopulatedTicksInWord(poolAddress, int16(i));\n\t\t\ttickWords[uint(i-startWord)] = tickWord;\n\t\t\ttickCounter += tickWord.length;\n\t\t}\n\t\t\n\t\ttickList = new ITickLens.PopulatedTick[](tickCounter);\n\t\ttickCounter = 0;\n\t\tfor (uint256 i=0; i<tickWords.length; i++) {\n\t\t\tfor (uint256 j=1; j<=tickWords[i].length; j++) {\n\t\t\t\ttickList[tickCounter] = tickWords[i][tickWords[i].length - j];\n\t\t\t\ttickCounter++;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfunction scan(SinglePool[] memory pools)\n\t\tpublic view\n\t\treturns (bytes[] memory)\n\t{\n\n\t\tbytes[] memory results = new bytes[](pools.length);\n\n\t\tfor (uint256 i = 0; i < pools.length; i++) {\n\n\t\t\tif (pools[i].tickLensAddress == address(0x0)) {\n\n\t\t\t\tIV2Pool pool = IV2Pool(pools[i].pool);\n\t\t\t\t(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pool.getReserves();\n\t\t\t\tresults[i] = abi.encode(reserve0, reserve1, blockTimestampLast);\n\n\t\t\t} else {\n\n\t\t\t\tIV3Pool pool = IV3Pool(pools[i].pool);\n\t\t\t\t(uint160 sqrtPriceX96, int24 tick,,,,,) = pool.slot0();\n\t\t\t\tuint128 liquidity = pool.liquidity();\n\t\t\t\tITickLens.PopulatedTick[] memory ticks = getTickList(pools[i].tickLensAddress, pools[i].pool, tick, pools[i].nTickGroups);\n\t\t\t\tresults[i] = abi.encode(sqrtPriceX96, tick, liquidity, ticks);\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n}"
    }
  }
}