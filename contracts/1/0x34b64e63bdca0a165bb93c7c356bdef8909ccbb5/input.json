{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/HEXme.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.8;\n\n/*\n *\tHEXme.io contract - Get +20% bonus HEX on your ETH to HEX transforms!\n *\n *      _   _  _______   __                 _\n *     | | | ||  ___\\ \\ / /                (_)\n *     | |_| || |__  \\ V / _ __ ___   ___   _  ___\n *     |  _  ||  __| /   \\| '_ ` _ \\ / _ \\ | |/ _ \\\n *     | | | || |___/ /^\\ \\ | | | | |  __/_| | (_) |\n *     \\_| |_/\\____/\\/   \\/_| |_| |_|\\___(_)_|\\___/\n *\n *\n *  HEXme.io is truly & solely built, as a service, on top of the original HEX contract!\n *  That means it only uses HEX original function calls and simply wraps HEX as a service layer.\n *\n *  It enhances the HEX ecosystem and doesn't split it!\n *  Thus we DO NOT use an own obsolete token!\n *  DO NOT trade any token which is not HEX itself, if you want to use the HEX ecosystem,\n *  unless you clearly understand the risk of the actions you are taking!\n *\n *  Verify over trust!\n *\n *  READ COMPLETELY & CAREFULLY BEFORE YOU USE THIS CONTRACT!\n *  THERE IS NO ONE ELSE IN CHARGE OF YOUR ACTIONS THAN YOURSELF!\n *\n *  DISCLAIMER:\n *\n *  Use at your own risk. Verify the code you want to execute.\n *  You are solely responsible for your decisions.\n *  Don't consider things as financial advice, unless they're labeled as such.\n *  Be responsible, take only reasonable risks.\n *  DYOR! - Do your own research!\n *\n *  The HEX code, which HEXme is building on top of, cannot be changed.\n *  The HEXme code cannot be changed either.\n *  Nobody is in charge of any of these contracts!\n *\n *  The HEXme contract uses the original HEX contract at the given address:\n *      0x2b591e99afe9f32eaa6214f7b7629768c40eeb39\n *\n *  The HEXme contracts address is:\n *\n *\n *  However HEXme does have very little configuration abilities, which only can be executed by the so called ORIGIN_ADDR.\n *  Those configuration functions use the onlyOrigin modifier.\n *  They neither give the ORIGIN_ADDR or any other entity any power to switch off any functionalities of the HEXme contract,\n *  nor give they the ORIGIN_ADDR or any other entity the power to control any users funds at any given time and state.\n *\n *  HEXme has no off switch. Anyone can run the code at any given time and state.\n *\n *  HEXme offers its users the ability to enter ETH to a HEX AA Lobby and to receive, not just +10% bonus HEX, as they would\n *  do with any casual referral link on the original go.HEX.com page, but +20% bonus on top of the basic HEX/ETH ratio\n *  of any given lobbyDay.\n *  That means HEXme users get the best deal for their bucket than at any other given place,\n *  if they wanna transform ETH into HEX, using HEXs AA lobby system.\n *\n *  HEXme also offers an internal referral system, which pays the referring address at maximum of 6%\n *  of the referred users originally transformed HEX. Those 6% are subtracted from the marginShares,\n *  which the ORIGIN_ADDR would receive otherwise. The user will always get its userShares, which are initially set\n *  to 120% and cannot be reduced, whether it refers another address or not.\n *\n *  The referral system therefore is self sustainable and doesn't promise any returns that doesn't actually exist\n *  in the HEX smart contract. This means any funds can be payed out at any given time, when the user simply exits its\n *  open HEX LobbyDay via HEXme.\n *\n *  HOW TO USE:\n *\n *      - enterLobby()\n *          - Call this payable method with at least minimumEntryAmount of wei, which is defined in globals,\n *            to enter a Lobby via HEXme and to reserve your +20% bonus from the given days basic HEX/ETH ratio.\n *          - The minimumEntryAmount initially is set to 0.025 ETH and can only be between 0.01 ETH & 0.05 ETH.\n *      - enterLobbyWithReferrer(address referrer)\n *          - Equally as enterLobby() with the possibility to note a referrer address, which will receive another +6%\n *            bonus on top of the users +20%.\n *      - exitLobby(uint256 lobbyDay)\n *          - Exits the given lobbyDay, if the user (the sending address) has entered any ETH in that day, didn't exit\n *            it yet and the given lobbyDay already has closed.\n *          - The user will receive its userShares HEX (initially set to 120%, can't be reduced) of the basic ratio,\n *            of the given lobbyDays ratio.\n *          - If any referral address was noted by the user at any previous lobbyDay entry, via enterLobbyWithReferrer()\n *            now this referral address also receives its marginShares percentage of the basic HEX/ETH ratio on top.\n *      - exitLobbyOnBehalf(address userAddress, uint256 lobbyDay)\n *          - From HEXs day 345 on, also other incentivized users, which describes a users referrer or the ORIGIN_ADDR,\n *            can exit a lobbyDay on behalf of the user, to be able to receive their marginShares HEX before\n *            HEXs BIG_PAY_DAY, which is the contract day 352.\n *          - Before day 345 only the user itself, who entered a lobby day is able to exit it, once it has closed.\n *\n *  FURTHER INFORMATION:\n *\n *  What happens if someone sends ETH to HEXme:\n *      - If anyone sends ETH directly to HEXme, it will automatically be forwarded to the enterLobby() method and\n *        therefore will behave exactly as if the sender would had called the enterLobby() directly with the sent ETH amount.\n *        This means the user will be able to exit the lobbyDay at which he sent the ETH to HEXme, once it has closed.\n *        Simply by using the exitLobby(uint256 lobbyDay) method.\n *\n *  The so called configuration abilities solely break down to:\n *      - changeMinimumEntryAmount()\n *          - in the range from 0.01 ETH to 0.05 ETH. #noexpectation\n *      - raiseUserShares()\n *          - userShares only can go up. At maximum to 30% bonus.\n *          - This in return would reduce the marginShares.\n *          - It might be used to assure market competitiveness and stay attractive for HEXmes users.\n *          - Do not expect of this ever happening. #noexpectation\n *      - moveExitLobbyPointer()\n *          - This could be called to gas optimize HEXmes internal state behaviour for the users.\n *          - It doesn't affect the ability for any user to use HEXme at any given time, at any given state.\n *      - flushExceedingHEX()\n *          - If HEX externally got send to HEXme, whether on purpose or on accident,\n *            this method gives the ORIGIN_ADDR the ability to flush those externally added funds to itself.\n *          - It also assures, that HEXme always has covered its required HEX liquidity, needed to serve all users exits,\n *            who ever entered any lobbyDay via HEXme.\n *          - It solely flushes exceeding HEX on the contract, to the ORIGIN_ADDR, which weren't minted by any users entry.\n *          - The ORIGIN_ADDR can do whatever it does with the exceeding HEX, if it ever was to receive any.\n *          - It might be possible, that if sent accidentally, the ORIGIN_ADDR could also decide to send those funds\n *            back to the address, the HEX originated from. #noexpectation\n *      - flushERC20()\n *          - If any other ERC20 than HEX (determined by the HEX contracts address) might land on that contract,\n *            the ORIGIN_ADDR is free to flush those tokens to itself and to do whatever it does with those assets.\n *            #noexpectation\n *\n *  Another publicly callable method:\n *      - exitContractLobbyDay(uint256 lobbyDay, uint40 count)\n *          - This method simply internally exits a HEXme contracts LobbyDay from the original HEX contract,\n *            to provide a higher instant liquidity and therefore to lower the gas fees for users\n *            to exit their HEXme entries.\n *          - It doesn't change any behaviour of the contract and can be called by anyone who wants to optimize\n *            the HEXmes users gas costs.\n *            #noexpectation\n *\n *  HAVE NO EXPECTATIONS:\n *\n *  DO NOT HAVE ANY EXPECTATIONS FROM ANYONE REGARDING HEX/HEXME/ETHEREUM OR ANY OTHER ENTITY!\n *  IF YOU DECIDE TO USE THOSE OPEN SOURCE, PUBLICLY ACCESSIBLE SYSTEMS, IT IS SOLELY ON YOU TO KNOW WHAT YOU ARE DOING.\n *  THERE IS NO ONE TO CALL FOR HELP, IF YOU USE THOSE TRULY DECENTRALIZED SYSTEMS WRONGLY.\n *  YOU ARE FULLY AND SOLELY RESPONSIBLE FOR YOUR ACTIONS.\n *  TAKE CARE! AND ENJOY THE DECENTRALIZED WORLD OF TODAY!\n *\n *  BEST REGARDS,\n *  HEXme.io\n *\n */\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SM: ADD OVF\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SM: SUB OVF\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SM: MUL OVF\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SM: DIV/0\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SM: MOD 0\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/*\n *\tHEX interface of required functionalities\n */\n\ninterface IHEX {\n\n    struct DailyDataStore {\n        uint72 dayPayoutTotal;\n        uint72 dayStakeSharesTotal;\n        uint56 dayUnclaimedSatoshisTotal;\n    }\n\n    function currentDay() external view returns (uint256);\n\n    function globalInfo() external view returns (uint256[13] memory);\n\n    function dailyData(uint256 lobbyDay) external view returns\n        (uint72 dayPayoutTotal, uint72 dayStakeSharesTotal, uint56 dayUnclaimedSatoshisTotal);\n\n    struct XfLobbyEntryStore {\n        uint96 rawAmount;\n        address referrerAddr;\n    }\n\n    struct XfLobbyQueueStore {\n        uint40 headIndex;\n        uint40 tailIndex;\n        mapping(uint256 => XfLobbyEntryStore) entries;\n    }\n\n    function xfLobby(uint256 lobbyDay) external view returns (uint256 rawAmount);\n\n    function xfLobbyMembers(uint256 i, address _XfLobbyQueueStore) external view returns\n        (uint40 headIndex, uint40 tailIndex, uint96 rawAmount, address referrerAddr);\n\n    function xfLobbyEnter(address referrerAddr) external payable;\n\n    function xfLobbyExit(uint256 enterDay, uint256 count) external;\n\n    function dailyDataUpdate(uint256 beforeDay) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// HEXme contract code:\n// We strongly suggest you, to verify the code you are executing!\n\ncontract HEXme {\n\n    // SAFEMATH:\n\n    using SafeMath for uint256;\n    using SafeMath for uint40;\n\n    // CONSTANTS - HEX specific:\n\n    uint256 private constant HEARTS_PER_HEX = 10 ** uint256(8);\n    uint256 private constant HEARTS_PER_SATOSHI = HEARTS_PER_HEX / 1e8 * 1e4;\n    uint256 private constant WAAS_LOBBY_SEED_HEARTS = 1e9 * HEARTS_PER_HEX;\n\n    uint256 private constant CLAIM_PHASE_START_DAY = 1;\n    uint256 private constant CLAIM_PHASE_DAYS = 50 * 7;\n    uint256 private constant CLAIM_PHASE_END_DAY = CLAIM_PHASE_START_DAY + CLAIM_PHASE_DAYS;\n    uint256 private constant BIG_PAY_DAY = CLAIM_PHASE_END_DAY + 1;\n\n    // STATE VARIABLES - HEXme specific:\n\n    // HEX CONTRACT:\n    IHEX public constant HEX = IHEX(0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39);\n\n    // ORIGIN ADDRESS:\n    address public constant ORIGIN_ADDR = 0x63Cbc7d47dfFE12C2B57AD37b8458944ad4121Ee;\n\n    // SHARES:\n\n    uint256 constant private totalShares = 1320;\n    // 1000‰ representing the AAs basic ETH/HEX ratio\n    uint256 constant public basicShares = 1000;\n    // 1200‰ representing the users 200‰ bonus shares - 2x of the normal referee bonus\n    // it might increase if a higher competitiveness is desired for HEXme - 1300‰ hard cap - no expectations\n    uint256 public userShares = 1200;\n    // 60‰ representing the split in half margin shares, that go equally to the origin & the referrer (if exists)\n    // it might decrease counter accordingly to a possible user share increase - 10‰ min cap - no expectations\n    uint256 public marginShares = 60;\n\n    // GLOBALS:\n\n    struct GlobalsStore {\n        uint256 initDay;\n        uint256 exitLobbyPointer;\n        uint256 minimumEntryAmount;\n        uint256 totalContractsExitedHEX;\n        uint256 totalUsersExitedHEX;\n    }\n\n    GlobalsStore public globals;\n\n    struct HEXmeLobbyEntryQueueStore {\n        uint40 headIndex;\n        uint40 tailIndex;\n    }\n\n    // MAPPINGS:\n\n    // Day --> HEXme Lobby ETH amount\n    mapping(uint256 => uint256) public HEXmeLobbyETHperDay;\n    // Day --> HEXme Lobby HEX amount\n    mapping(uint256 => uint256) public HEXmeLobbyHEXperDay;\n    // Day --> HEXme Lobby ETH amount per entry\n    mapping(uint256 => uint256[]) public HEXmeLobbyETHperDayEntries;\n    // Address --> Day --> HEXme Users Lobby ETH amount\n    mapping(address => mapping(uint256 => uint256)) public HEXmeUsersLobbyETHperDay;\n    // Day --> LobbyQueueStore\n    mapping(uint256 => HEXmeLobbyEntryQueueStore) public HEXmeLobbyEntryQueue;\n\n    // user --> referrer\n    mapping(address => address) private referredForever;\n    // referee --> day since referral exists\n    mapping(address => uint256) private referredSince;\n\n    // EVENTS:\n\n    event EnteredLobby(uint256 lobbyDay, address indexed user, address indexed referrer, uint256 enteredETH);\n    event ExitedLobby(uint256 lobbyDay, address indexed user, address indexed referrer, uint256 usersHEX, uint256 referrersHEX, uint256 exitedETH);\n    event ExitedOnBehalf(uint256 lobbyDay, address indexed user, address indexed sender);\n    event NewReferral(address indexed referrer, address referee, uint256 currentDay);\n\n    event ContractFullyExitedLobbyDay(uint256 lobbyDay, uint256 currentDay);\n    event MovedExitLobbyPointer(uint256 from, uint256 to, uint256 currentDay);\n    event ChangedMinimumEntryAmount(uint256 from, uint256 to, uint256 currentDay);\n    event RaisedUserShares(uint256 userShares, uint256 marginShares, uint256 currentDay);\n    event FlushedExceedingHEX(uint256 exceedingHEX, uint256 currentDay);\n\n    // ONLY ORIGIN MODIFIER:\n\n    modifier onlyOrigin {\n        require(msg.sender == ORIGIN_ADDR, \"HEXme: only ORIGIN_ADDR\");\n        _;\n    }\n\n    constructor() public payable {\n        uint256 initBufferEntryAmount = 1000000000000000;\n        require(msg.value == initBufferEntryAmount);\n\n        globals.minimumEntryAmount = initBufferEntryAmount;\n        globals.initDay = HEX.currentDay();\n        globals.exitLobbyPointer = globals.initDay;\n\n        _enterLobby(address(0));\n\n        globals.minimumEntryAmount = 25000000000000000;\n    }\n\n    receive() external payable {\n        _enterLobby(ORIGIN_ADDR);\n    }\n\n    function enterLobby() external payable {\n        _enterLobby(address(0));\n    }\n\n    function enterLobbyWithReferrer(address referrer) external payable {\n        _enterLobby(referrer);\n    }\n\n    function _enterLobby(address referrer) private {\n        require(msg.value >= globals.minimumEntryAmount, \"HEXme: below minimumEntryAmount\");\n\n        HEX.xfLobbyEnter{value : msg.value}(address(this));\n\n        uint256 currentDay = HEX.currentDay();\n\n        _updateReferrer(referrer, currentDay);\n\n        HEXmeLobbyETHperDay[currentDay] += msg.value;\n        HEXmeUsersLobbyETHperDay[msg.sender][currentDay] += msg.value;\n        HEXmeLobbyETHperDayEntries[currentDay].push(msg.value);\n        HEXmeLobbyEntryQueue[currentDay].tailIndex++;\n\n        emit EnteredLobby(currentDay, msg.sender, referredForever[msg.sender], msg.value);\n    }\n\n    function _updateReferrer(address referrer, uint256 currentDay) private {\n        if (referrer != address(0) && referrer != msg.sender && !_isReferred(msg.sender)) {\n            referredForever[msg.sender] = referrer;\n            referredSince[msg.sender] = currentDay;\n            emit NewReferral(referrer, msg.sender, currentDay);\n        }\n    }\n\n    function _isReferred(address userAddress) private view returns (bool){\n        return (referredForever[userAddress] != address(0));\n    }\n\n    function exitLobby(uint256 lobbyDay) external {\n        uint256 currentDay = HEX.currentDay();\n        _exitLobby(msg.sender, lobbyDay, currentDay);\n    }\n\n    function exitLobbyOnBehalf(address userAddress, uint256 lobbyDay) external {\n        uint256 currentDay = HEX.currentDay();\n        require(\n            msg.sender == userAddress ||\n            (\n                (currentDay > CLAIM_PHASE_END_DAY.sub(7)) &&\n                (\n                    msg.sender == ORIGIN_ADDR ||\n                    (msg.sender == referredForever[userAddress] && lobbyDay >= referredSince[userAddress])\n                )\n            ),\n            \"HEXme: Only for incentivized users, from day 345 on\"\n        );\n        _exitLobby(userAddress, lobbyDay, currentDay);\n    }\n\n    function _exitLobby(address userAddress, uint256 lobbyDay, uint256 currentDay) private {\n        uint256 ETHtoExit = HEXmeUsersLobbyETHperDay[userAddress][lobbyDay];\n\n        require(lobbyDay < currentDay, \"HEXme: Day not complete\");\n        require(ETHtoExit > 0, \"HEXme: No entry from this user, this day\");\n\n        uint256 HEXtoExit = _getUsersHEXtoExit(userAddress, lobbyDay);\n        delete HEXmeUsersLobbyETHperDay[userAddress][lobbyDay];\n        globals.totalUsersExitedHEX += HEXtoExit;\n\n        _exitTillLiquidity(HEXtoExit, currentDay);\n        _payoutHEX(userAddress, HEXtoExit, ETHtoExit, lobbyDay);\n    }\n\n    function _getUsersHEXtoExit(address userAddress, uint256 lobbyDay) private returns (uint256 HEXtoExit){\n        _updateHEXmeLobbyHEXperDay(lobbyDay);\n        return ((HEXmeUsersLobbyETHperDay[userAddress][lobbyDay]\n            .mul(HEXmeLobbyHEXperDay[lobbyDay])).div(HEXmeLobbyETHperDay[lobbyDay]));\n    }\n\n    function _updateHEXmeLobbyHEXperDay(uint256 lobbyDay) private {\n        if (HEXmeLobbyHEXperDay[lobbyDay] == 0) {\n            uint256 HEXinLobby = _getHEXinLobby(lobbyDay);\n            if (HEXinLobby == 0) {\n                HEX.dailyDataUpdate(lobbyDay + 1);\n                HEXinLobby = _getHEXinLobby(lobbyDay);\n            }\n            uint256 basicHEXperDay =\n                (HEXinLobby.mul(HEXmeLobbyETHperDay[lobbyDay])).div(HEX.xfLobby(lobbyDay));\n                HEXmeLobbyHEXperDay[lobbyDay] = (basicHEXperDay.mul(totalShares)).div(basicShares);\n        }\n    }\n\n    function _getHEXinLobby(uint256 lobbyDay) private view returns (uint256 HEXinLobby){\n        if (lobbyDay >= 1) {\n            (,,uint256 dayUnclaimedSatoshisTotal) = HEX.dailyData(lobbyDay);\n            if (lobbyDay == HEX.currentDay()) {\n                dayUnclaimedSatoshisTotal = HEX.globalInfo()[7];\n            }\n            return dayUnclaimedSatoshisTotal * HEARTS_PER_SATOSHI / CLAIM_PHASE_DAYS;\n        } else {\n            // poor branch is never gonna see the daylight ;)\n            return WAAS_LOBBY_SEED_HEARTS;\n        }\n    }\n\n    function _exitTillLiquidity(uint256 liquidity, uint256 currentDay) private {\n        uint256 cachedExitLobbyPointer = globals.exitLobbyPointer;\n        uint40 cachedHeadIndex = HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex;\n\n        uint256 startIndex = HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex;\n        uint256 startLiquidity = HEX.balanceOf(address(this));\n        uint256 currentLiquidity = startLiquidity;\n\n        while (currentLiquidity < liquidity) {\n            if (cachedHeadIndex < HEXmeLobbyEntryQueue[cachedExitLobbyPointer].tailIndex) {\n                uint256 addedLiquidity =\n                    (HEXmeLobbyETHperDayEntries[cachedExitLobbyPointer][cachedHeadIndex]\n                    .mul(HEXmeLobbyHEXperDay[cachedExitLobbyPointer])).div(HEXmeLobbyETHperDay[cachedExitLobbyPointer]);\n\n                currentLiquidity = currentLiquidity.add(addedLiquidity);\n                cachedHeadIndex++;\n            } else {\n                if (cachedHeadIndex.sub(startIndex) > 0) {\n                    HEX.xfLobbyExit(cachedExitLobbyPointer, cachedHeadIndex.sub(startIndex));\n\n                    if (cachedHeadIndex == HEXmeLobbyEntryQueue[cachedExitLobbyPointer].tailIndex)\n                        emit ContractFullyExitedLobbyDay(cachedExitLobbyPointer, currentDay);\n                }\n\n                if(cachedHeadIndex != HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex)\n                    HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex = cachedHeadIndex;\n\n                cachedExitLobbyPointer++;\n\n                if (cachedExitLobbyPointer >= currentDay || cachedExitLobbyPointer >= CLAIM_PHASE_END_DAY)\n                    cachedExitLobbyPointer = globals.initDay;\n\n                cachedHeadIndex = HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex;\n                startIndex = cachedHeadIndex;\n            }\n        }\n\n        if (cachedHeadIndex.sub(startIndex) > 0) {\n            HEX.xfLobbyExit(cachedExitLobbyPointer, cachedHeadIndex.sub(startIndex));\n\n            if (cachedHeadIndex == HEXmeLobbyEntryQueue[cachedExitLobbyPointer].tailIndex)\n                emit ContractFullyExitedLobbyDay(cachedExitLobbyPointer, currentDay);\n        }\n\n        globals.totalContractsExitedHEX = globals.totalContractsExitedHEX.add(\n            HEX.balanceOf(address(this)).sub(startLiquidity));\n\n        if (HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex != cachedHeadIndex)\n            HEXmeLobbyEntryQueue[cachedExitLobbyPointer].headIndex = cachedHeadIndex;\n\n        if (globals.exitLobbyPointer != cachedExitLobbyPointer)\n            globals.exitLobbyPointer = cachedExitLobbyPointer;\n    }\n\n    function _payoutHEX(address userAddress, uint256 HEXtoExit, uint256 exitedETH, uint256 lobbyDay) private {\n        uint256 usersHEX = (HEXtoExit.mul(userShares)).div(totalShares);\n        uint256 marginHEX = HEXtoExit.sub(usersHEX);\n        uint256 referrersHEX = (_isReferred(userAddress) && lobbyDay >= referredSince[userAddress]) ?\n            (marginHEX.mul(marginShares)).div(totalShares.sub(userShares)) : 0;\n        uint256 originsHEX = marginHEX.sub(referrersHEX);\n\n        if (originsHEX > 0)\n            HEX.transfer(address(ORIGIN_ADDR), originsHEX);\n\n        if (referrersHEX > 0)\n            HEX.transfer(address(referredForever[userAddress]), referrersHEX);\n\n        if (usersHEX > 0)\n            HEX.transfer(userAddress, usersHEX);\n\n        emit ExitedLobby(lobbyDay, userAddress, referredForever[userAddress], usersHEX, referrersHEX, exitedETH);\n\n        if (msg.sender != userAddress)\n            emit ExitedOnBehalf(lobbyDay, userAddress, msg.sender);\n    }\n\n    function exitContractLobbyDay(uint256 lobbyDay, uint40 count) external {\n        uint256 startLiquidity = HEX.balanceOf(address(this));\n\n        HEX.xfLobbyExit(lobbyDay, count);\n\n        globals.totalContractsExitedHEX = globals.totalContractsExitedHEX.add(\n            HEX.balanceOf(address(this)).sub(startLiquidity));\n\n        if (count > 0)\n            HEXmeLobbyEntryQueue[lobbyDay].headIndex += count;\n        else\n            HEXmeLobbyEntryQueue[lobbyDay].headIndex = HEXmeLobbyEntryQueue[lobbyDay].tailIndex;\n\n        if (HEXmeLobbyEntryQueue[lobbyDay].headIndex == HEXmeLobbyEntryQueue[lobbyDay].tailIndex)\n            emit ContractFullyExitedLobbyDay(lobbyDay, HEX.currentDay());\n    }\n\n    function changeMinimumEntryAmount(uint256 newMinimumEntryAmount) external onlyOrigin {\n        require(10000000000000000 <= newMinimumEntryAmount && newMinimumEntryAmount <= 50000000000000000, \"HEXme: INV VAL\");\n\n        emit ChangedMinimumEntryAmount(globals.minimumEntryAmount, newMinimumEntryAmount, HEX.currentDay());\n\n        globals.minimumEntryAmount = newMinimumEntryAmount;\n    }\n\n    function raiseUserShares(uint256 newUserSharesInPerMill) external onlyOrigin {\n        require(newUserSharesInPerMill.add(20) <= totalShares, \"HEXme: 1300 CAP\");\n        require(newUserSharesInPerMill > userShares, \"HEXme: INCREASE\");\n\n        marginShares = (totalShares.sub(newUserSharesInPerMill)).div(2);\n        userShares = totalShares.sub(marginShares.mul(2));\n\n        emit RaisedUserShares(userShares, marginShares, HEX.currentDay());\n    }\n\n    function moveExitLobbyPointer(uint256 newLobbyPointerDay) external onlyOrigin {\n        require(newLobbyPointerDay >= globals.initDay && newLobbyPointerDay < HEX.currentDay(), \"HEXme: INV VAL\");\n\n        emit MovedExitLobbyPointer(globals.exitLobbyPointer, newLobbyPointerDay, HEX.currentDay());\n\n        globals.exitLobbyPointer = newLobbyPointerDay;\n    }\n\n    function flushExceedingHEX() external onlyOrigin {\n        uint256 currentLiquidity = HEX.balanceOf(address(this));\n        uint256 reservedLiquidity = globals.totalContractsExitedHEX.sub(globals.totalUsersExitedHEX);\n        uint256 exceedingLiquidity = (currentLiquidity.sub(reservedLiquidity)).sub(HEARTS_PER_HEX);\n\n        require(exceedingLiquidity > 0, \"HEXme: 0 Exceeding\");\n\n        HEX.transfer(ORIGIN_ADDR, exceedingLiquidity);\n        emit FlushedExceedingHEX(exceedingLiquidity, HEX.currentDay());\n    }\n\n    function flushERC20(IERC20 _token) external onlyOrigin {\n        require(_token.balanceOf(address(this)) > 0, \"HEXme: 0 BAL\");\n        require(address(_token) != address(HEX), \"HEXme: !HEX\");\n        _token.transfer(ORIGIN_ADDR, _token.balanceOf(address(this)));\n    }\n\n    // EXTERNAL VIEW HELPERS:\n\n    function getCurrentDay() external view returns (uint256) {\n        return HEX.currentDay();\n    }\n\n    function getHEXinLobby(uint256 lobbyDay) external view returns (uint256){\n        return _getHEXinLobby(lobbyDay);\n    }\n\n    function getHistoricLobby(bool getHEXInsteadETH) external view returns (uint256[] memory){\n        uint256 tillDay = HEX.currentDay();\n        tillDay = (tillDay <= CLAIM_PHASE_END_DAY) ? tillDay : CLAIM_PHASE_END_DAY;\n        uint256[] memory historicLobby = new uint256[](tillDay + 1);\n        for (uint256 i = 0; i <= tillDay; i++) {\n            if (getHEXInsteadETH)\n                historicLobby[i] = _getHEXinLobby(i);\n            else\n                historicLobby[i] = HEX.xfLobby(i);\n        }\n        return historicLobby;\n    }\n}"}}}