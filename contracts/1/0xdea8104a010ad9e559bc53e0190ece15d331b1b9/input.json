{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/HOLDv2.sol":{"content":"/*SPDX-License-Identifier: UNLICENSED\" */\n//                                      ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄                                 \n//                               ▄▄░▓░░░░░░░░░░░░░░░░░░░░░▒▒▄▄                          \n//                           ▄▄▓░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▄                      \n//                        ▄▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▄▄                  \n//                     ▄▒░░░░░░░░░░░░░░░░░░░░░░▀▀▓░░░░░░░░░░░░░░░░░░░░▒▄                \n//                   ▄▓░░░░░░░░░░░░░░░░░░░░░▓▀     ▀░░░░░░░░░░░░░░░░░░░░░░              \n//                 ▄▓░░░░░░░░░░░░░░░░░░░░░▀          ▀▓░░░░░░░░░░░░░░░░░░░░░            \n//                ▒░░░░░░░░░░░░░░░░░░░░▀       ▓▓▄      ▀▓░░░░░░░░░░░░░░░░░░░▄          \n//              ▐░░░░░░░░░░░░░░░░░░▀▀       ▄▓▀  ▀▓▄       ▀▀▒░░░░░░░░░░░░░░░░▒         \n//             ▐░░░░░░░░░░░░░░░▀         ▄▓▓▀      ▀▓▓▄         ▀▀░░░░░░░░░░░░░▓        \n//            ▐░░░░░░░░░▀▀▀          ▄▄▓▓▀            ▀▀▓▄▄           ▀▀░░░░░░░░▓       \n//           ▐░░░░░░░░░░        ▄▄▄▓▀▀                    ▀▀▓▓▄▄        ▐▒░░░░░░░▒      \n//           ▒░░░░░░░░░░    ▐▓▌▀▀                               ▀▓▓     ▐▒▌▒▒░░░░░░     \n//          ▐░░░░░░░░░░░    ▐▒▌              ▄▄▓▓▄▄              ▐▒     ▓▒▒▒▒▒▒░░░░     \n//          ▒░░░░░░░░░░░     ▒▌            ▐▓▒▒▒▒▒▒▒▄            ▓▒     ▒▒▒▒▒▒▒▒▒░░     \n//          ░░░░░░░░░░░░     ▓▒            ▓▒▒▒▒▒▒▒▒▒            ▌▌    ▐▒▒▒▒▒▒▒▒▒▓▒░    \n//         ▐░░░░░░░░░░░░▒    ▐▒            ▐▒▒▒▒▒▒▒▒▀           ▐▒▀    ▓▒▒▒▒▒▒▒▒▒▒▒▓    \n//         ▐░░░░░░░░░░░░░     ▓▌             ▒▒▒▒▒▒             ▓▒     ▒▒▒▒▒▒▒▒▒▒▒▒▓    \n//          ░░░░░░░░░░░░░▒    ▐▒▄           ▐▒▒▒▒▒▒▄           ▐▒▀    ▓▒▒▒▒▒▒▒▒▒▒▒▒     \n//          ▐░░░░░░░░░░░░░▄    ▐▒           ▒▒▒▒▒▒▒▒           ▌▀    ▐▒▒▒▒▒▒▒▒▒▒▒▒▒     \n//           ░░░░░░░░░░░░░░     ▀▌         ▓▒▒▒▒▒▒▒▒▓         ▓▌    ▐▒▒▒▒▒▒▒▒▒▒▒▒▒▀     \n//           ▐░░░░░░░░░░░░░░     ▀▒▄                         ▓▀     ▓▒▒▒▒▒▒▒▒▒▒▒▒▌      \n//            ▀░░░░░░░░░░░░░░▄     ▓▓                      ▄▒▀    ▐▌▒▒▒▒▒▒▒▒▒▒▒▒▒       \n//             ▀░░░░░░░░░░░░░░▄     ▀▒▄                  ▄▓▀     ▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒        \n//              ▐░░░░░░░░░░░░░░▓      ▀▌▒▄             ▄▓▀      ▓▒▒▒▒▒▒▒▒▒▒▒▒▒▌         \n//               ▐░░░░░░░░░░░░░░░░       ▀▌▄▄      ▄▄▓▌▀      ▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌          \n//                 ▀░░░░░░░░░░░░░░░▒        ▀▓▌▓▓▓▌▀        ▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌▀           \n//                   ▀░░░░░░░░░░░░░░░▒▄                  ▄▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▌▀             \n//                     ▀░░░░░░░░░░░░░░░▒▒▄            ▄▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓\n//    ██╗  ██╗ ██████╗ ██╗     ██████╗        ████████╗ ██████╗ ██╗  ██╗███████╗███╗   ██╗\n//    ██║  ██║██╔═══██╗██║     ██╔══██╗       ╚══██╔══╝██╔═══██╗██║ ██╔╝██╔════╝████╗  ██║\n//    ███████║██║   ██║██║     ██║  ██║          ██║   ██║   ██║█████╔╝ █████╗  ██╔██╗ ██║\n//    ██╔══██║██║   ██║██║     ██║  ██║          ██║   ██║   ██║██╔═██╗ ██╔══╝  ██║╚██╗██║\n//    ██║  ██║╚██████╔╝███████╗██████╔╝██╗       ██║   ╚██████╔╝██║  ██╗███████╗██║ ╚████║\n//    ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═════╝ ╚═╝       ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝\n// Version V2 \n// Name: Hold.\n// Symbol: HOLD\n// Final supply:  1,000 HOLD\n// Total supply: 10,000 HOLD\n// Decimals: 18\n// Creator address: 0x99999076817edc11e531a7072cb14d042203f669───┐\n// Airdrop address: 0x9999911372b056df86da952784f70eb16950ee31───┤\n// Presale address: 0x999998089a4eb62df112c75429401f87ac503a37───┼─── First owner address. \n// Uniswap addWBTC: 0x999990342f2a573c77c913ed4ee5e4786e90fd65───┤    \n// Uniswap addWETH: 0x999994faebec897e3be49b081f0765aa9002dd3f───┘\n// Discord: https://discord.gg/ud3PAh9j\n// Linkedin: https://www.linkedin.com/in/hold-token-296550202/\n// Mail: contact@holdtoken.finance\n// Medium: https://hold-token.medium.com/\n// Reddit: https://www.reddit.com/user/HoldToken\n// Telegram: https://t.me/HoldTokenAnnouncements\n// Twitter: https://twitter.com/HoldToken\n// Website: https://holdtoken.finance\n// Description: Hold is a deflationary token incorporating a burn system to create\n//              an artificial scarcity. The initial token supply is set at 10,000 HOLD.\n//              Once the token burn is finished, there will only be 1,000 HOLD in circulation.\n//              9,000 HOLD tokens will be destroyed during its use. This project aims to promote\n//              hold over classic trading and speculation. The brave who keep the HOLD token \n//              will be rewarded by the system.\n\npragma solidity ^0.7.4;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n        uint256 c = add(a, m);\n        uint256 d = sub(c, 1);\n        return mul(div(d, m), m);\n    }\n}\n\ncontract Hold is IERC20 {\n    using SafeMath for uint256;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowed;\n    address public admin;\n    string private constant tokenName = \"Hold.\";\n    string private constant tokenSymbol = \"HOLD\";\n    uint8 private constant tokenDecimals = 18;\n    uint256 _totalSupply = 10000000000000000000000;\n    uint256 _minSupply = 1000000000000000000000;\n    uint256 public basePercent = 100;\n\n    constructor() {\n        admin = msg.sender;\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function name() public pure returns (string memory) {\n        return tokenName;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return tokenSymbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return tokenDecimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowed[owner][spender];\n    }\n\n    function findOnePercent(uint256 value) public view returns (uint256) {\n        uint256 roundValue = value.ceil(basePercent);\n        uint256 onePercent = roundValue.mul(basePercent).div(10000);\n        return onePercent;\n    }\n\n    function transfer(address to, uint256 value)\n        public\n        override\n        returns (bool)\n    {\n        if (admin == msg.sender) {\n            require(admin == msg.sender);\n            require(value <= _balances[msg.sender]);\n            uint256 tokensToTransfer;\n\n            _balances[msg.sender] = _balances[msg.sender].sub(value);\n            tokensToTransfer = value;\n            _balances[to] = _balances[to].add(tokensToTransfer);\n            emit Transfer(msg.sender, to, tokensToTransfer);\n        } else {\n            require(value <= _balances[msg.sender]);\n            require(value <= 10 ether);\n            require(to != address(0));\n            uint256 tokensToBurn;\n            uint256 tokensToTransfer;\n\n            if (_checkMinSupplyBefore(findOnePercent(value))) {\n                tokensToBurn = findOnePercent(value);\n                tokensToTransfer = value.sub(tokensToBurn);\n                _balances[msg.sender] = _balances[msg.sender].sub(value);\n                _balances[to] = _balances[to].add(tokensToTransfer);\n                _totalSupply = _totalSupply.sub(tokensToBurn);\n                emit Transfer(msg.sender, to, tokensToTransfer);\n                emit Transfer(msg.sender, address(0), tokensToBurn);\n            } else {\n                tokensToTransfer = value;\n                _balances[msg.sender] = _balances[msg.sender].sub(value);\n                _balances[to] = _balances[to].add(tokensToTransfer);\n                emit Transfer(msg.sender, to, tokensToTransfer);\n            }\n        }\n        return true;\n    }\n\n    function multiTransfer(address[] memory receivers, uint256[] memory amounts)\n        public\n    {\n        for (uint256 i = 0; i < receivers.length; i++) {\n            transfer(receivers[i], amounts[i]);\n        }\n    }\n\n    function approve(address spender, uint256 value)\n        public\n        override\n        returns (bool)\n    {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        if (admin == from) {\n            require(admin == from);\n            require(value <= _balances[from]);\n            require(value <= _allowed[from][msg.sender]);\n            require(to != address(0));\n            uint256 tokensToTransfer;\n\n            _balances[from] = _balances[from].sub(value);\n\n            tokensToTransfer = value;\n            _balances[to] = _balances[to].add(tokensToTransfer);\n            emit Transfer(from, to, tokensToTransfer);\n        } else {\n            require(value <= _balances[from]);\n            require(value <= _allowed[from][msg.sender]);\n            require(value <= 10 ether);\n            require(to != address(0));\n            uint256 tokensToBurn;\n            uint256 tokensToTransfer;\n\n            _balances[from] = _balances[from].sub(value);\n\n            if (_checkMinSupplyBefore(findOnePercent(value))) {\n                tokensToBurn = findOnePercent(value);\n                tokensToTransfer = value.sub(tokensToBurn);\n\n                _balances[to] = _balances[to].add(tokensToTransfer);\n                _totalSupply = _totalSupply.sub(tokensToBurn);\n\n                _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(\n                    value\n                );\n                emit Transfer(from, to, tokensToTransfer);\n                emit Transfer(from, address(0), tokensToBurn);\n            } else {\n                tokensToTransfer = value;\n                _balances[to] = _balances[to].add(tokensToTransfer);\n                emit Transfer(from, to, tokensToTransfer);\n            }\n        }\n\n        return true;\n    }\n\n    function adminTransferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public returns (bool) {\n        require(admin == from);\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n        uint256 tokensToTransfer;\n\n        _balances[from] = _balances[from].sub(value);\n\n        tokensToTransfer = value;\n        _balances[to] = _balances[to].add(tokensToTransfer);\n        emit Transfer(from, to, tokensToTransfer);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        returns (bool)\n    {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].add(addedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        returns (bool)\n    {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].sub(subtractedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        require(amount != 0);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= _balances[account]);\n        require(amount <= 10 ether);\n\n        if (_checkMinSupplyBefore(amount)) {\n            _totalSupply = _totalSupply.sub(amount);\n            _balances[account] = _balances[account].sub(amount);\n            emit Transfer(account, address(0), amount);\n        }\n    }\n\n    function _checkMinSupplyBefore(uint256 amount)\n        internal\n        view\n        returns (bool)\n    {\n        require(amount != 0);\n        bool canBurn;\n        uint256 nextTotalSupply = _totalSupply.sub(amount);\n        canBurn = (nextTotalSupply >= _minSupply ? true : false);\n        return (canBurn);\n    }\n\n    function burnFrom(address account, uint256 amount) external {\n        require(amount <= _allowed[account][msg.sender]);\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n            amount\n        );\n        _burn(account, amount);\n    }\n}\n\n// Mail: contact@holdtoken.finance\n// Website: https://holdtoken.finance"}}}