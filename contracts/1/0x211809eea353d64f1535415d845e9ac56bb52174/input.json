{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/TribClaimRopsten.sol":{"content":"pragma solidity >=0.5.0 <0.7.0;\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\nimport \"https://github.com/Contribute-Defi/contracts/blob/master/contracts/interfaces/IContribute.sol\";\n\n\ninterface ISavingsManager {\n\n    function collectAndDistributeInterest(address _mAsset) external;\n    function lastCollection(address _mAsset) external view returns(uint256);\n\n}\n\ncontract TribClaim {\n\n\n       address payable public owner;\n       address public savingsManager;\n       address constant contribute  = 0x0DdfE92234b9DCA2de799736bBBa1D2F25CFC3b8;\n       address constant musd  = 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5;\n       address constant trib = 0xe09216F1d343Dd39D6Aa732a08036fee48555Af0;\n\n       constructor(address _savingsManager) public {\n            owner = msg.sender;\n            savingsManager = _savingsManager;\n        }\n        modifier onlyOwner(){\n            require(msg.sender == owner,\"You are not the owner\");\n            _;\n        }\n\n\n        function changeOwner(address payable _owner) external onlyOwner\n        {\n            owner = _owner;\n        }\n\n        function changeSavingsManager(address _savingsManager) external onlyOwner\n        {\n            savingsManager = _savingsManager;\n\n        }\n\n\n        function getTokenBalance(address _token) public view returns(uint)\n        {\n            return IERC20(_token).balanceOf(address(this));\n        }\n\n        function getToken(address _token,address payable _recipient) external onlyOwner {\n            uint withdrawAmount = getTokenBalance(_token);\n            IERC20(_token).transfer(_recipient,withdrawAmount);\n\n        }\n\n        function getEtherBalance() public view returns(uint)\n        {\n            return address(this).balance;\n        }\n\n        function getEther(address payable _recipient) external onlyOwner{\n            _recipient.transfer(address(this).balance);\n        }\n\n       // approve for transaction via contribute smart contract .\n\n        function approve() external onlyOwner\n        {\n            IERC20(trib).approve(contribute, 100000 ether);\n        }\n\n        function collect(uint _lastCollection, uint256 _min) external onlyOwner {\n\n            // get last collection time from mUSD savingsManager contract and match it with this one.\n            // This is to deal with front running bots\n\n            require(ISavingsManager(savingsManager).lastCollection(musd) == _lastCollection ,\"Unsuccessful\");\n\n            // Collect and distribute interest.\n            ISavingsManager(savingsManager).collectAndDistributeInterest(musd);\n\n            claim(_min);\n\n        }\n\n        function claim(uint256 _min) public onlyOwner\n        {\n            // claim interest\n            require(IContribute(contribute).getInterest() > _min ,\"Low\");\n            IContribute(contribute).claimInterest();\n        }\n\n        receive() external payable {\n\n        }\n\n\n        function destroySmartContract() public onlyOwner\n        {\n            selfdestruct(owner);\n        }\n}\n\n"},"https://github.com/Contribute-Defi/contracts/blob/master/contracts/interfaces/IContribute.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0 <0.7.0;\n\n/**\n * This interface is only to facilitate\n * interacting with the contract in remix.ethereum.org\n * after it has been deployed to a testnet or mainnet.\n *\n * Just copy/paste the interface in Remix and deploy\n * at contract address.\n */\n\ninterface IContribute {\n  function TAX() external view returns (uint256);\n\n  function DIVIDER() external view returns (uint256);\n\n  function GME() external view returns (bool);\n\n  function token() external view returns (address);\n\n  function genesis() external view returns (address);\n\n  function genesisAveragePrice() external view returns (uint256);\n\n  function genesisReserve() external view returns (uint256);\n\n  function totalInterestClaimed() external view returns (uint256);\n\n  function totalReserve() external view returns (uint256);\n\n  function reserve() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function genesisInvest(uint256) external;\n\n  function concludeGME() external;\n\n  function invest(uint256) external;\n\n  function sell(uint256) external;\n\n  function claimInterest() external;\n\n  function totalClaimRequired() external view returns (uint256);\n\n  function claimRequired(uint256) external view returns (uint256);\n\n  function totalContributed() external view returns (uint256);\n\n  function getInterest() external view returns (uint256);\n\n  function getTotalSupply() external view returns (uint256);\n\n  function getBurnedTokensAmount() external view returns (uint256);\n\n  function getCurrentTokenPrice() external view returns (uint256);\n\n  function getReserveToTokensTaxed(uint256) external view returns (uint256);\n\n  function getTokensToReserveTaxed(uint256) external view returns (uint256);\n\n  function getReserveToTokens(uint256) external view returns (uint256);\n\n  function getTokensToReserve(uint256) external view returns (uint256);\n}\n"},"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"}}}