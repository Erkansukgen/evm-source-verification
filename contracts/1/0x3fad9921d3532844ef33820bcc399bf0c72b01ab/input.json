{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/interfaces/v3pool.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface v3pool {\n  function swap(address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data) external payable returns (int256 amount0, int256 amount1);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function fee() external view returns (uint24);\n\n}\n"},"contracts/lib/PoolAddress.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        //require(key.token0 < key.token1);\n        pool = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        bytes32(0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54)\n                    )\n                )\n            )\n        );\n    }\n}\n"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n  \n}"},"contracts/mevarb_bytes_op_v5.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/v3pool.sol';\nimport './lib/SafeMath.sol';\nimport './lib/PoolAddress.sol';\n// import './lib/CusByteslib.sol';\n\n\ninterface IWETH {\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n}\n\n\n\ninterface v3quoter{\n  function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n}\n\n\ninterface v2pool{\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n\ncontract mevbytearbv5 {\n    using SafeMath for uint;\n\n    \n    address payable public owner;\n    \n    // uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    // uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    // bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n    \n    // ropsten\n    /*\n    address wethaddr = address(0xc778417E063141139Fce010982780140Aa0cD5Ab);\n    IWETH private constant WETH = IWETH(address(0xc778417E063141139Fce010982780140Aa0cD5Ab));\n    */\n    \n    // goerli\n    \n    /*\n    address wethaddr = address(0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6);\n    IWETH private constant WETH = IWETH(address(0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6));\n    */\n    \n    // main net\n    \n    // address wethaddr = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IWETH private constant WETH = IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    \n    \n    // address factory = address(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n    address quoter_addr = address(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n    \n    \n    \n    v3quoter quoter = v3quoter(quoter_addr);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n\n\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n    function withdrawethall() external onlyowner {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n    // util functions to operate on bytes\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }  \n\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n \n \n    \n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n\n    struct SwapInfo {\n        uint256 cur; // point to the current swap pool, plus one after every swap\n        bytes swapdata;\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        /// require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported\n        (uint256 local_cur, bytes memory swapdata) = abi.decode(_data, (uint256, bytes));\n        \n        bool zeroForOne;\n\n        uint256 poolnum = toUint8(swapdata, 0) >> 4;\n\n        // uint24 fee = toUint16(swapdata, 19 + 33 * poolnum + 2 * local_cur);\n\n        \n        // reuse v3num to store the token index\n        uint256 v3num = toUint8(swapdata, 19 + 33 * local_cur) & 0xf;\n        uint256 token_in_index;\n        uint256 token_out_index;\n        address receiver;\n        \n        v3num = toUint8(swapdata, 0) >> 2 & 0x3;\n        \n        \n        // verify caller to make it safe\n        receiver = PoolAddress.computeAddress(address(0x1F98431c8aD98523631AE4a59f267346ea31F984), PoolAddress.getPoolKey(v3pool(msg.sender).token0(), v3pool(msg.sender).token1(), v3pool(msg.sender).fee()));\n        require(msg.sender == receiver);\n\n        \n        // if last v3 swap, send weth to the first pool\n        // and do all the v2 swaps\n        if(local_cur + 1 == v3num){\n            // reuse the token_in_index to store the amountin\n            token_in_index = toUint96(swapdata, 1) >> 24 & 0xffffffffffffffffff;\n            // reuse token_out_index to store the first pool's rc index\n            token_out_index = toUint8(swapdata, 0) & 0x3;\n            // use receiver to store the first pool addr\n            receiver = toAddress(swapdata, 32 + 33 * token_out_index);\n            \n            _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), receiver, token_in_index);\n            \n            // do the v2 swaps\n            if(v3num == poolnum){\n                return;\n            }else{\n                // the pools after data.cur is all v2 pools\n                for(uint i = local_cur + 1; i < poolnum; i++){\n                    // reuse the token_in_index to store the rc index of v2 pool info\n                    token_in_index = toUint8(swapdata, 19 + 33 * i) >> 4;\n                    \n\n                    if(token_in_index == poolnum){\n                        receiver = address(this);\n                    }else{\n                        receiver = toAddress(swapdata, 32 + 33 * token_in_index);\n                    }                 \n            \n                    // reuse the token_in_index to store the amountout\n                    token_in_index = toUint128(swapdata, 20 + 33 * i) >> 32 & 0xffffffffffffffffffffffff;\n                    \n                    if(toUint8(swapdata, 19 + 33 * i) & 0x3 == 1){\n                        v2pool(toAddress(swapdata, 32 + 33 * i)).swap(0, token_in_index, receiver, new bytes(0));\n                    }else{\n                        v2pool(toAddress(swapdata, 32 + 33 * i)).swap(token_in_index, 0, receiver, new bytes(0));\n                    }\n                }\n            }\n            \n            return;\n\n        }\n        \n        // not the last v3 swap, so swap v3 again\n        local_cur = local_cur + 1;\n        // data.cur = local_cur;\n        // reuse token_in_index to store the rc index + zeroForOne\n        token_in_index = toUint8(swapdata, 19 + 33 * local_cur);\n        token_out_index = token_in_index >> 6; // this is the rc index\n        token_in_index = token_in_index >> 5 & 0x1; // this is zeroForOne\n        zeroForOne = token_in_index == 1;\n        bytes memory callbackdata = abi.encode(local_cur, swapdata);  \n\n        if(token_out_index == poolnum){\n            receiver = address(this);\n        }else{\n            receiver = toAddress(swapdata, 32 + 33 * token_out_index);\n        }\n\n        address addr_p = toAddress(swapdata, 32 + 33 * local_cur);\n        \n        // reuse v3 num to store the amountin\n        v3num = toUint128(swapdata, 20 + 33 * local_cur) >> 32 & 0xffffffffffffffffffffffff;\n        \n        // this one can't be the one with weth out\n        v3pool(addr_p).swap(receiver, zeroForOne, int256(v3num), \n                       zeroForOne ? 4295128739 + 1 : 1461446703485210103287273052203988822378723970342 - 1, callbackdata);   \n\n    }\n\n\n\n    function arbswapnfour(bytes32[4] calldata info) external payable{\n\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }        \n        \n        require(msg.sender == address(0x777777218f0E4dD543D31732c1e2fDD8617ed0D0), \"fuck\");\n\n        \n        bytes memory swapdata = abi.encodePacked(info[0],info[1],info[2],info[3]);\n        bool zeroForOne = (toUint8(swapdata, 19) >> 5 & 0x1) == 1;\n        uint256 rc_index = toUint8(swapdata, 19) >> 6;\n        address pool_addr = toAddress(swapdata, 32);        \n        address receiver;\n        uint256 poolnum = toUint8(swapdata,0) >> 4;\n        \n        \n        if(rc_index == poolnum){\n            receiver = address(this);\n        }else{\n            receiver = toAddress(swapdata, 32 + 33 * rc_index);\n        }        \n        \n        bytes memory callbackdata = abi.encode(0, swapdata);\n        // amountin occupys 12 bytes\n        int256 firstsend = int256(toUint128(swapdata, 20) >> 32 & 0xffffffffffffffffffffffff);\n        (int256 amount0, int256 amount1) = v3pool(pool_addr).swap(receiver, zeroForOne, firstsend, zeroForOne ? 4295128739 + 1 : 1461446703485210103287273052203988822378723970342 - 1, callbackdata);\n\n        // reuse zeroForOne to check whether we need to check the amoutout\n        bool checkout = toUint8(swapdata, 19) >> 4 & 0x1 == 1;\n        if (checkout) {\n            if(zeroForOne){\n                require(uint256(-amount1) >= toUint96(swapdata, 10) >> 24 & 0xffffffffffffffffff, \"shit\");\n            }else{\n                require(uint256(-amount0) >= toUint96(swapdata, 10) >> 24 & 0xffffffffffffffffff, \"shit\");\n            }\n        }\n\n    }\n\n\n\n    function arbswapnthree(bytes32[3] calldata info) external payable{\n\n        // check the blknum to avoid the uncle blk pack\n        if(block.number > msg.value){\n            return;\n        }        \n        \n        require(msg.sender == address(0x777777218f0E4dD543D31732c1e2fDD8617ed0D0), \"fuck\");\n        \n        \n        bytes memory swapdata = abi.encodePacked(info[0],info[1],info[2]);\n        bool zeroForOne = (toUint8(swapdata, 19) >> 5 & 0x1) == 1;\n        uint256 rc_index = toUint8(swapdata, 19) >> 6;\n        address pool_addr = toAddress(swapdata, 32);        \n        address receiver;\n        uint256 poolnum = toUint8(swapdata,0) >> 4;\n        \n        \n        if(rc_index == poolnum){\n            receiver = address(this);\n        }else{\n            receiver = toAddress(swapdata, 32 + 33 * rc_index);\n        }        \n        \n        bytes memory callbackdata = abi.encode(0, swapdata);\n        // amountin occupys 12 bytes\n        int256 firstsend = int256(toUint128(swapdata, 20) >> 32 & 0xffffffffffffffffffffffff);\n        (int256 amount0, int256 amount1) = v3pool(pool_addr).swap(receiver, zeroForOne, firstsend, zeroForOne ? 4295128739 + 1 : 1461446703485210103287273052203988822378723970342 - 1, callbackdata);\n\n        // reuse zeroForOne to check whether we need to check the amoutout\n        bool checkout = toUint8(swapdata, 19) >> 4 & 0x1 == 1;\n        if (checkout) {\n            if(zeroForOne){\n                require(uint256(-amount1) >= toUint96(swapdata, 10) >> 24 & 0xffffffffffffffffff, \"shit\");\n            }else{\n                require(uint256(-amount0) >= toUint96(swapdata, 10) >> 24 & 0xffffffffffffffffff, \"shit\");\n            }\n        }\n\n    }\n\n\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    } \n\n\n    // the first flag indicts whether the token transferred to the pool is the token0\n    function v2out(address pool, bool first, uint256 amountIn) private returns (uint256 amountOut){\n        bytes memory returnData;\n        (, returnData) = pool.staticcall(abi.encodeWithSelector(0x0902f1ac));\n        (uint reserve0,uint reserve1, ) = abi.decode(returnData, (uint,uint,uint)); // getreserve\n        \n        (uint reserveInput, uint reserveOutput) = (first) ? (reserve0, reserve1) : (reserve1, reserve0);\n        \n        amountOut = getAmountOut(amountIn, reserveInput, reserveOutput);\n        \n        return(amountOut);\n    }\n    \n    \n    function v3out(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn) private returns (uint256 amountOut) {\n        amountOut = quoter.quoteExactInputSingle(tokenIn, tokenOut, fee, amountIn, 0);\n    }\n    \n    // simulate a swap and returns the exact output amount through trace_call\n    function simulateoutput(uint256 amountin,  address[] memory pools, address[] memory tokens, uint256[] memory flags) public returns(uint256[] memory amounts){\n \n        amounts = new uint256[](pools.length);\n        // loop all the pools and do the swap\n        for(uint i = 0; i < flags.length; i++){\n            // the pool going to swap is v2 pool\n            if((flags[i] >> 128) == 0){\n                amountin = v2out(pools[i], tokens[i] < tokens[i+1], amountin);\n                amounts[i] = amountin;\n            } else{\n                amountin = v3out(tokens[i], tokens[i+1], uint24(flags[i] & 0x00ffffffffffffffffffffffffffffffff), amountin);\n                amounts[i] = amountin;\n            } \n   \n        }\n        \n        \n    }\n\n\n    \n\n}"}}}