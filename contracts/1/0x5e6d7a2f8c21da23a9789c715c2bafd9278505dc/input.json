{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/UtrinToken.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-11-05\n*/\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.4;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n}\n\ninterface ItokenRecipient { \n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external returns (bool); \n}\n\ninterface IstakeContract { \n    function createStake(address _wallet, uint8 _timeFrame, uint256 _value) external returns (bool); \n}\n\ninterface IERC20Token {\n    function totalSupply() external view returns (uint256 supply);\n    function transfer(address _to, uint256 _value) external  returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n\ncontract Ownable {\n\n    address private owner;\n    address private priceManager;\n    \n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    modifier onlyPriceManager() {\n        require(msg.sender == priceManager, \"Caller is not priceManager\");\n        _;\n    }\n    \n    \n\n    constructor() {\n        owner = msg.sender; \n        emit OwnerSet(address(0), owner);\n    }\n\n\n    function changeOwner(address newOwner) public onlyOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n    \n    function setPriceManager (address newPriceManager) public onlyOwner {\n        priceManager = newPriceManager;\n    }\n\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}\n\ncontract StandardToken is IERC20Token {\n    \n    using SafeMath for uint256;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public _totalSupply;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n    function totalSupply() override public view returns (uint256 supply) {\n        return _totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) override virtual public returns (bool success) {\n        require(_to != address(0x0), \"Use burn function instead\");                               // Prevent transfer to 0x0 address. Use burn() instead\n\t\trequire(_value >= 0, \"Invalid amount\"); \n\t\trequire(balances[msg.sender] >= _value, \"Not enough balance\");\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) override virtual public returns (bool success) {\n        require(_to != address(0x0), \"Use burn function instead\");                               // Prevent transfer to 0x0 address. Use burn() instead\n\t\trequire(_value >= 0, \"Invalid amount\"); \n\t\trequire(balances[_from] >= _value, \"Not enough balance\");\n\t\trequire(allowed[_from][msg.sender] >= _value, \"You need to increase allowance\");\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) override public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) override public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) override public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n    \n}\n\ncontract UTRINToken is Ownable, StandardToken {\n\n    using SafeMath for uint256;\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    uint256 public subscriptionPrice;\n    address public stakeContract;\n    address public crowdSaleContract;\n    address public preSaleContract;\n    address public dividendPool;\n    uint256 public soldTokensUnlockTime;\n    mapping (address => uint256) frozenBalances;\n    mapping (address => uint256) timelock;\n    \n    event Burn(address indexed from, uint256 value);\n    event StakeContractSet(address indexed contractAddress);\n\n    \n    constructor() {\n        name = \"Universal Trade Interface\";\n        decimals = 18;\n        symbol = \"UTRIN\";\n        \n        crowdSaleContract = 0x1eB807fA2ec2aEDE1736Fd0c5300e462CFafF2d9;\t\t\t  \n\t \tpreSaleContract =   0x09f9A8a61f9f634a93A52B7d358a651fc1127B2E;\t\n\t \t\n        address teamWallet = 0x41dA08f916Fc534C25FB3B388a0859b9e4A42ADa;          \n        address legalAndLiquidity = 0x298843E6C4Cedd1Eae5327A39847F0A170D32D26;\n        address developmentFund = 0x0e70bB808E549147E3073937f13eCdc08E5d5775; \n        dividendPool = 0xd1c16226FF031Fcd961221aD25c6a43B4FB96d7E;\n        \n        balances[teamWallet] = 1500000 ether;                                           \n        emit Transfer(address(0x0), teamWallet, (1500000 ether));                       \n        \n        balances[legalAndLiquidity] = 1000000 ether;                                           \n        emit Transfer(address(0x0), legalAndLiquidity, (1000000 ether));\n        \n        balances[developmentFund] = 1500000 ether;                                    \n        emit Transfer(address(0x0), developmentFund, (1500000 ether));     \n\n        balances[preSaleContract] = 1000000 ether;                                    \n        emit Transfer(address(0x0), address(preSaleContract), (1000000 ether));       \n        \n        balances[crowdSaleContract] = 4000000 ether;                                    \n        emit Transfer(address(0x0), address(crowdSaleContract), (4000000 ether));       \n\n        _totalSupply = 9000000 ether;\n\n    }\n    \n    function frozenBalanceOf(address _owner) public view returns (uint256 balance) {\n        return frozenBalances[_owner];\n    }\n\n    function unlockTimeOf(address _owner) public view returns (uint256 time) {\n        return timelock[_owner];\n    }\n    \n    function transfer(address _to, uint256 _value) override public  returns (bool success) {\n        require(txAllowed(msg.sender, _value), \"Tokens are still frozen\");\n        return super.transfer(_to, _value);\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) { ///??\n        require(txAllowed(msg.sender, _value), \"Crowdsale tokens are still frozen\");\n        return super.transferFrom(_from, _to, _value);\n    }\n    \n    function setStakeContract(address _contractAddress) onlyOwner public {\n        stakeContract = _contractAddress;\n        emit StakeContractSet(_contractAddress);\n    }\n    \n    function setDividenPool(address _DividenPool) onlyOwner public {\n        dividendPool = _DividenPool;\n    }\n    \n        // Tokens sold by crowdsale contract will be frozen ultil crowdsale ends\n    function txAllowed(address sender, uint256 amount) private returns (bool isAllowed) {\n        if (timelock[sender] > block.timestamp) {\n            return isBalanceFree(sender, amount);\n        } else {\n            if (frozenBalances[sender] > 0) frozenBalances[sender] = 0;\n            return true;\n        }\n        \n    }\n    \n    function isBalanceFree(address sender, uint256 amount) private view returns (bool isfree) {\n        if (amount <= (balances[sender] - frozenBalances[sender])) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    function burn(uint256 _value) public onlyOwner returns (bool success) {\n        require(balances[msg.sender] >= _value, \"Not enough balance\");\n\t\trequire(_value >= 0, \"Invalid amount\"); \n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        _totalSupply = _totalSupply.sub(_value);\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function approveStake(uint8 _timeFrame, uint256 _value) public returns (bool success) {\n        require(stakeContract != address(0x0));\n        allowed[msg.sender][stakeContract] = _value;\n        emit Approval(msg.sender, stakeContract, _value);\n        IstakeContract recipient = IstakeContract(stakeContract);\n        require(recipient.createStake(msg.sender, _timeFrame, _value));\n        return true;\n    }\n    \n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        ItokenRecipient recipient = ItokenRecipient(_spender);\n        require(recipient.receiveApproval(msg.sender, _value, address(this), _extraData));\n        return true;\n    }\n   \n    function tokensSoldCrowdSale(address buyer, uint256 amount) public returns (bool success) {\n        require(msg.sender == crowdSaleContract, \"Error with tokensSoldCrowdSale function.\");\n        frozenBalances[buyer] += amount;\n        if (timelock[buyer] == 0 ) timelock[buyer] = soldTokensUnlockTime;\n        return super.transfer(buyer, amount);\n    }\n    \n    function tokensSoldPreSale(address buyer, uint256 amount) public returns (bool success) {\n        require(msg.sender == preSaleContract, \"Error with tokensSoldPreSale function.\");\n        frozenBalances[buyer] += amount;\n        if (timelock[buyer] == 0 ) timelock[buyer] = soldTokensUnlockTime;\n        return super.transfer(buyer, amount);\n    }\n    \n\tfunction setPrice(uint256 newPrice) public onlyPriceManager {\n\t\tsubscriptionPrice = newPrice;\n\t}\n\n\tfunction redeemTokens(uint256 amount) public{\n\t    require(amount > subscriptionPrice, \"Insufficient Utrin tokens sent to cover your fee!\");\n\t\t    address account = msg.sender;        \t\n\n        \tbalances[account] = balances[account].sub(amount);\n        \temit Transfer(account, dividendPool, amount);\n\t}\n\t\n\t\n\n\n    \n\n}\n"
    }
  }
}