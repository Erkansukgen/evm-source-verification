{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/IERC20.sol":{"content":"pragma solidity ^0.6.0;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}"},"browser/IUniswapExchange.sol":{"content":"pragma solidity >=0.4.22 <0.7.0;\n\n\ninterface IUniswapExchange {\n    // Protocol Functions\n    function tokenAddress() external view returns (address);\n\n    function factoryAddress() external view returns (address);\n\n    // ERC20 Functions (Keep track of liquidity providers)\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function allowance(address _owner, address _spender)\n        external\n        view\n        returns (uint256);\n\n    // Pricing functions\n    function getEthToTokenInputPrice(uint256 eth_sold)\n        external\n        view\n        returns (uint256);\n\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\n        external\n        view\n        returns (uint256);\n\n    function getTokenToEthInputPrice(uint256 tokens_sold)\n        external\n        view\n        returns (uint256);\n\n    function getTokenToEthOutputPrice(uint256 eth_bought)\n        external\n        view\n        returns (uint256);\n\n    // Add Liquidity\n    function setup(address token_addr) external;\n\n    function addLiquidity(\n        uint256 min_liquidity,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline)\n        external\n        returns (uint256);\n\n    //Eth/Token Swap\n    //Sell all ETH\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)\n        external\n        payable\n        returns (uint256);\n\n    function ethToTokenTransferInput(\n        uint256 min_tokens,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256);\n\n    //Sell some ETH and get refund\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)\n        external\n        payable\n        returns (uint256);\n\n    function ethToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256);\n\n    //Token/Eth Swap\n    //Sell all tokens\n    function tokenToEthSwapInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function tokenToEthTransferInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256);\n\n    //Sell some tokens and get refund\n    function tokenToEthSwapOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function tokenToEthTransferOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256);\n\n    //Token/Token Swap\n    function tokenToTokenSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address token_addr\n    ) external returns (uint256);\n\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256);\n\n    function tokenToTokenSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address token_addr\n    ) external returns (uint256);\n\n    function tokenToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256);\n\n    //Token/Exchange Swap\n    function tokenToExchangeSwapInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address exchange_addr\n    ) external returns (uint256);\n\n    function tokenToExchangeTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    ) external returns (uint256);\n\n    function tokenToExchangeSwapOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address exchange_addr\n    ) external returns (uint256);\n\n    function tokenToExchangeTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address exchange_addr\n    ) external returns (uint256);\n}"},"browser/UniswapProxy.sol":{"content":"\npragma solidity >=0.4.22 <0.7.0;\n\nimport \"./IUniswapExchange.sol\";\nimport \"./IERC20.sol\";\n\ncontract UniswapProxy {\n    address public owner;\n    mapping(address => bool) public triggerAddresses;           //Bot Trigger Addresses\n\n   \n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev OTC Provider. Gives right to fee withdrawal.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized\");\n        _;\n    }\n\n    /**\n     * @dev Authorized Purchase Trigger addresses for mempool bot.\n     */\n    modifier onlyTrigger() {\n        require(msg.sender == owner || triggerAddresses[msg.sender], \"Unauthorized\");\n        _;\n    }\n\n \n    /**\n     * @dev Add Trigger address.\n     */\n    function setTriggerAddress(address _address, bool _authorized)\n        public\n        onlyOwner\n    {\n        triggerAddresses[_address] = _authorized;\n    }\n\n    function approveExchange(address _exchange, uint256 _amount) public onlyOwner {\n        IUniswapExchange exchange = IUniswapExchange(_exchange);\n        IERC20 token = IERC20(exchange.tokenAddress());\n        token.approve(_exchange, _amount);\n    }\n\n\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline, address _exchange)\n        external\n        onlyTrigger\n        returns (uint256) {\n        require(deadline > block.timestamp, 'Overdue.');\n            \n        IUniswapExchange exchange = IUniswapExchange(_exchange);\n        uint256 eth_balance = address(this).balance;\n        require(eth_balance > 0, 'eth_balance = 0 !');\n        \n        uint256 tokens_bought = exchange.getEthToTokenInputPrice(eth_balance);\n        require(tokens_bought >= min_tokens, 'tokens_bought < min_tokens !');\n        \n        return exchange.ethToTokenSwapInput.value(eth_balance)(tokens_bought, deadline);\n    }\n        \n\n    //Sell some ETH and get refund\n    function ethToTokenSwapOutput(\n        uint256 tokens_bought, \n        uint256 deadline, \n        address _exchange)\n        external\n        onlyTrigger\n        returns (uint256) {\n        require(deadline > block.timestamp, 'Overdue.');\n            \n        IUniswapExchange exchange = IUniswapExchange(_exchange);\n        uint256 eth_balance = address(this).balance;\n        require(eth_balance > 0, 'eth_balance = 0 !');\n\n        uint256 eth_sold = exchange.getEthToTokenOutputPrice(tokens_bought);\n        require(eth_sold <= eth_balance, 'eth_sold > eth_balance !');\n        \n        return exchange.ethToTokenSwapOutput.value(eth_sold)(tokens_bought, deadline);\n    }\n\n    //Token/Eth Swap\n    //Sell all tokens\n    function tokenToEthSwapInput(\n        uint256 min_eth,\n        uint256 deadline, \n        address _exchange\n    ) \n    external \n    onlyTrigger \n    returns (uint256) {\n        require(deadline > block.timestamp, 'Overdue.');\n        \n        IUniswapExchange exchange = IUniswapExchange(_exchange);\n        IERC20 token = IERC20(exchange.tokenAddress());\n        uint256 token_balance = token.balanceOf(address(this));\n        require(token_balance > 0, 'token_balance = 0 !');\n\n        uint256 eth_bought = exchange.getTokenToEthInputPrice(token_balance);\n        require(eth_bought >= min_eth, 'eth_bought < min_eth !');\n        \n        return exchange.tokenToEthSwapInput(token_balance, eth_bought, deadline);\n    }\n\n\n    //Sell some tokens and get refund\n    function tokenToEthSwapOutput(\n        uint256 eth_bought,\n        uint256 deadline, \n        address _exchange\n    ) external onlyTrigger returns (uint256) {\n        require(deadline > block.timestamp, 'Overdue.');\n        \n        IUniswapExchange exchange = IUniswapExchange(_exchange);\n        IERC20 token = IERC20(exchange.tokenAddress());\n        uint256 token_balance = token.balanceOf(address(this));\n        require(token_balance > 0, 'token_balance = 0 !');\n        \n        uint256 tokens_sold = exchange.getTokenToEthOutputPrice(eth_bought);\n        require(tokens_sold <= token_balance, 'tokens_sold > token_balance !');\n\n\n        return exchange.tokenToEthSwapOutput(eth_bought, tokens_sold, deadline);\n    }\n    \n\n     /**\n     * @dev Withdraw ether.\n     */\n    receive() external payable {}\n    fallback() external payable {}\n    /**\n     * @dev Withdraw tokens.\n     */\n    function withdrawTokens(address _token) public onlyOwner {\n        IERC20 token = IERC20(_token);\n        uint256 token_balance = token.balanceOf(address(this));\n        require(token_balance > 0, 'token_balance = 0 !');\n        \n        token.transfer(msg.sender, token_balance);\n    }\n\n\n    /**\n     * @dev Withdraw ether.\n     */\n    function withdrawEther() public onlyOwner {\n        uint256 eth_balance = address(this).balance;\n        require(eth_balance > 0, 'eth_balance = 0 !');\n        \n        payable(msg.sender).transfer(eth_balance);\n    }\n    \n    function tokenBalance(address _token) public view returns (uint256) {\n        IERC20 token = IERC20(_token);\n        uint256 token_balance = token.balanceOf(address(this));\n        return token_balance;\n    }\n    \n    function etherBalance() public view returns (uint256) {\n        uint256 eth_balance = address(this).balance;\n        return eth_balance;\n    }\n\n}"}}}