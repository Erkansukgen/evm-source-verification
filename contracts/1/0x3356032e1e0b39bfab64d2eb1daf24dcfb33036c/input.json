{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "bridgeETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function mint(address to, uint256 value) external returns (bool);\n    function burn(address from, uint256 value) external returns (bool);\n}\n\ncontract BridgeEth {\n    address public admin;\n    IERC20 public token;\n\n    struct Balance {\n        uint256 tokens;\n        uint256 gas;\n    }\n\n    mapping(address => mapping(uint => bool)) public processedNonces;\n    mapping (address => Balance) public accounts;\n    \n    mapping(address => uint) public nextNonce;\n\n    uint256 public _basefees = 50000000000000000;\n    enum Step { Burn, Mint }\n    event Deposit(\n        address from,\n        uint256 amount,\n        uint date,\n        uint nonce,\n        bytes signature,\n        Step indexed step\n    );\n    event Mint(\n        address to,\n        uint256 amount,\n        uint date,\n        uint nonce,\n        bytes signature,\n        Step indexed step,\n        uint256 gas\n    );\n    event Withdraw(\n        address from,\n        uint256 amount\n    );\n\n    constructor () {\n        admin = 0xEd708471D98D8F005DA0c7F83CBB5d628E7ec27B;\n        token = IERC20(0x9cF77be84214beb066F26a4ea1c38ddcc2AFbcf7);\n    }\n\n    function setToken (address _token ) external {\n        require(msg.sender == admin, \"only admin\");\n        token = IERC20(_token);\n    }\n\n    function setAdmin (address _admin ) external {\n        require(msg.sender == admin, \"only admin\");\n        admin = _admin;\n    }\n\n    function setFees (uint256 _fees ) external {\n        require(msg.sender == admin, \"only admin\");\n        _basefees = _fees;\n    }\n\n\n    function deposit(address from, uint256 amount, uint nonce, bytes calldata signature) external {\n        require(processedNonces[msg.sender][nonce] == false, 'transfer already processed');\n        processedNonces[msg.sender][nonce] = true;\n        token.transferFrom(msg.sender, address(this), amount);\n        nextNonce[msg.sender] = nonce + 1;\n\n        emit Deposit(\n            from,\n            amount,\n            block.timestamp,\n            nonce,\n            signature,\n            Step.Burn\n        );\n    }\n\n    function calculateBurnFee(uint256 _amount) private pure returns (uint256) {\n        return _amount*(5)/(10**3);\n\n    }\n\n    fallback () external payable {\n    }\n\n    receive () external payable {\n    }\n\n    function withdraw( ) external payable {\n        // require(amount > 0 , \"invalid amount: 0\");\n        require(accounts[msg.sender].tokens > 0, \"invalid amount\");\n        require(msg.value >= accounts[msg.sender].gas, \"insufficient fees\");\n        payable(admin).transfer(msg.value);\n\n        bool succ = token.transfer(msg.sender, accounts[msg.sender].tokens);\n        require(succ, \"tokens not minted\");\n\n        accounts[msg.sender].tokens = 0;\n        accounts[msg.sender].gas = 0;\n\n        emit Withdraw(msg.sender, accounts[msg.sender].tokens);\n    }\n\n    function mint(\n        address to, \n        uint256 amount, \n        uint nonce,\n        bytes calldata signature\n    ) external {\n        uint256 startGas = gasleft();\n        require(msg.sender == admin, \"only admin\");\n        bytes32 message = prefixed(keccak256(abi.encodePacked(to, amount, nonce )));\n        require(recoverSigner(message, signature) == to , 'wrong signature');\n        require(processedNonces[to][nonce] == false, 'transfer already processed');\n        processedNonces[to][nonce] = true;\n        nextNonce[to] = nonce + 1;\n        uint256 _burn = calculateBurnFee(amount);\n        amount = amount - _burn;\n        accounts[to].tokens += amount;\n        \n        uint256 gasUsed = (startGas - gasleft()) * tx.gasprice*2;\n        gasUsed = gasUsed > _basefees ? gasUsed : _basefees;\n        accounts[to].gas += gasUsed;\n        emit Mint(\n            to,\n            amount,\n            block.timestamp,\n            nonce,\n            signature,\n            Step.Mint,\n            gasUsed\n        );\n    }\n\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\n        '\\x19Ethereum Signed Message:\\n32', \n        hash\n        ));\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    \n        (v, r, s) = splitSignature(sig);\n    \n        return ecrecover(message, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (uint8, bytes32, bytes32)\n    {\n        require(sig.length == 65);\n    \n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    \n        assembly {\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n    \n        return (v, r, s);\n    }\n}"
    }
  }
}