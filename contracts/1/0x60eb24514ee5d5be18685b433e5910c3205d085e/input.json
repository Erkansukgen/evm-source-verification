{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/pirate/Entity.sol": {
      "content": "pragma solidity >0.5.10;\n\nimport \"./safemath.sol\";\n\nlibrary Entity {\n\n    using SafeMath for uint256;\n    enum ActionType{PoolReg, PoolUpdate, PoolClaim, PoolExit, UserRecharge, UserRefund, SysSetting, MinerJoin, MinerChanged, MinerRetire}\n\n    struct VersionManager {\n        uint versionOfPoolData;\n        uint versionOfMinerData;\n        uint versionOfUserData;\n        uint versionOfSysSetting;\n    }\n\n    struct SystemSetting{\n        uint MBytesPerToken;\n        uint Duration;\n        uint MinPoolGuarantee;\n        uint MinMinerGuarantee;\n    }\n\n    struct UserDetails {\n        uint nonce;\n        uint tokenBalance;\n        uint remindPacket;\n        uint expiration;\n        uint epoch;\n        uint claimedAmount;\n        uint claimedMicNonce;\n    }\n\n    struct MinerPool{\n        uint ID;\n        address mainAddr;\n        address payerAddr;\n        uint GTN;\n        bytes   shortName;\n        bytes   email;\n        bytes   url;\n    }\n\n    struct Miner{\n        uint ID;\n        address payer;\n        address poolAddr;\n        bytes32 subAddr;\n        uint GTN;\n        bytes2 zone;\n    }\n\n    function upgradeVer(VersionManager storage self, ActionType at) internal{\n\n        if (at == ActionType.PoolReg || at == ActionType.PoolUpdate || at == ActionType.PoolExit){\n\n            self.versionOfPoolData ++;\n\n        }else if (at == ActionType.PoolClaim || at == ActionType.UserRefund\n        || at == ActionType.UserRecharge){\n\n            self.versionOfUserData ++;\n\n        }else if (at == ActionType.SysSetting){\n\n            self.versionOfSysSetting ++;\n\n        }else if (at == ActionType.MinerJoin || at == ActionType.MinerChanged\n        || at == ActionType.MinerRetire){\n\n            self.versionOfMinerData ++;\n\n        }\n    }\n\n    function updateChannel(UserDetails storage self, uint tn, uint packs, uint d) internal {\n        self.nonce += 1;\n        self.tokenBalance = self.tokenBalance.add(tn);\n        self.remindPacket = self.remindPacket.add(packs);\n        self.expiration = now + d;\n    }\n\n    function claim(UserDetails storage self, uint amount, uint tn, uint micNonce) internal{\n        self.nonce += 1;\n        self.remindPacket = self.remindPacket.sub(amount);\n        self.tokenBalance = self.tokenBalance.sub(tn);\n        self.epoch += 1;\n        self.claimedAmount = amount;\n        self.claimedMicNonce = micNonce;\n    }\n\n    function updateBasic(MinerPool storage self, bytes memory name,\n        bytes memory email, bytes memory url) internal {\n\n        if (name.length != 0){\n            self.shortName = name;\n        }\n\n        if (email.length != 0){\n            self.email = email;\n        }\n\n        if (url.length != 0){\n            self.url = url;\n        }\n    }\n}\n"
    },
    "browser/pirate/IERC20.sol": {
      "content": "pragma solidity >=0.4.24;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}"
    },
    "browser/pirate/MicroPaySystem.sol": {
      "content": "pragma solidity >=0.5.11;\n\nimport \"./owned.sol\";\nimport \"./safemath.sol\";\nimport \"./IERC20.sol\";\nimport \"./Entity.sol\";\n\ncontract PacketMarket is owned{\n\n    event PoolRegister(\n        address indexed pool,\n        uint256 gtn);\n\n    event PoolDestroy(\n        address indexed pool,\n        uint256 time);\n\n    event PoolClaim(\n        address indexed pool,\n        address indexed user,\n        uint256 packet,\n        uint256 tonken,\n        uint256 micrNonce,\n        uint256 claimNonce);\n\n    event UserRecharge(\n        address indexed from,\n        address indexed to,\n        uint256 tokens,\n        uint256 packets);\n\n    event UserRefund(\n        address indexed user,\n        address indexed pool,\n        uint256 tokens,\n        uint256 packets);\n\n    using SafeMath for uint256;\n    using Entity for Entity.UserDetails;\n    using Entity for Entity.MinerPool;\n    using Entity for Entity.VersionManager;\n    using Entity for Entity.SystemSetting;\n    /******************\n    * system settings\n    ******************/\n\n    IERC20 public token;\n    uint public decimal = 18;\n    address[] public PoolsIndex;\n    Entity.VersionManager public vm =  Entity.VersionManager(0,0,0,1);\n    Entity.SystemSetting public setting;\n\n\n    mapping(address=>address[]) public poolsUsedByUser;\n    mapping(address=>address[]) public usersUnderPool;\n    mapping(address=>bytes32[]) public minersUnderPool;\n    mapping(address=>Entity.MinerPool) public PoolData;\n    mapping(bytes32=>Entity.Miner) public MinerData;\n    mapping(address=>mapping(address=>Entity.UserDetails)) public UserData;\n\n    constructor(address ta, uint d) public{\n        require(ta != address(0) && d > 0);\n\n        token = IERC20(ta);\n        decimal = d;\n\n        setting.MBytesPerToken = 1000;\n        setting.Duration = 30 days;\n        setting.MinPoolGuarantee = 102400 * (10 ** decimal);\n        setting.MinMinerGuarantee = 50000 * (10 ** decimal);\n    }\n\n    function emergency() public onlyOwner{\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    function changeSetting(uint price, uint duration, uint pGTN, uint mGTN) public onlyOwner{\n        bool changed = false;\n        if (price != 0){\n            changed = true;\n            setting.MBytesPerToken = price;\n        }\n        if (duration != 0){\n            changed = true;\n            setting.Duration = duration * 1 days;\n        }\n        if (pGTN != 0){\n            changed = true;\n            setting.MinPoolGuarantee = pGTN * (10 ** decimal);\n        }\n        if (mGTN != 0){\n            changed = true;\n            setting.MinMinerGuarantee = mGTN * (10 ** decimal);\n        }\n\n        if (changed){\n            vm.upgradeVer(Entity.ActionType.SysSetting);\n        }\n    }\n\n    function TokenBalance(address userAddress) public view returns (uint, uint, uint){\n        return (token.balanceOf(userAddress), userAddress.balance, token.allowance(userAddress, address(this)));\n    }\n\n    /******************\n    * pool action\n    ******************/\n    function RegPool(uint tokenNo, address poolAddr, bytes memory name, bytes memory email, bytes memory url) public{\n        require(PoolData[poolAddr].mainAddr == address(0));\n        require(tokenNo >= setting.MinPoolGuarantee);\n\n        token.transferFrom(msg.sender, address(this), tokenNo);\n\n        Entity.MinerPool memory pool = Entity.MinerPool(PoolsIndex.length, poolAddr, msg.sender, tokenNo, name, email, url);\n        PoolsIndex.push(pool.mainAddr);\n\n        PoolData[pool.mainAddr] = pool;\n        vm.upgradeVer(Entity.ActionType.PoolReg);\n        emit PoolRegister(poolAddr, tokenNo);\n    }\n\n    function DestroyPool(address poolAddr) public{\n        Entity.MinerPool memory pool = PoolData[poolAddr];\n        require(pool.payerAddr == msg.sender);\n\n        delete PoolsIndex[pool.ID];\n        delete PoolData[poolAddr];\n\n        token.transfer(msg.sender, pool.GTN);\n\n        vm.upgradeVer(Entity.ActionType.PoolExit);\n        emit PoolDestroy(poolAddr, now);\n    }\n\n    function Pools() public view returns (address[] memory) {\n        return PoolsIndex;\n    }\n\n    function usersOfPool(address pool) public view returns(address[] memory){\n        return usersUnderPool[pool];\n    }\n\n    function ChangeBasicInfo(address mainAddr, bytes memory name, bytes memory email, bytes memory url) public{\n        Entity.MinerPool storage pool = PoolData[mainAddr];\n        require(pool.mainAddr == msg.sender || pool.payerAddr == msg.sender);\n        pool.updateBasic(name, email, url);\n        vm.upgradeVer(Entity.ActionType.PoolUpdate);\n    }\n\n    bytes32 public CurMsgHash;\n    address public RecoveredAddr;\n    function TestClaimSig(address contractAddr, address tokenAddr, address user, address pool, uint amount, uint micNonce, uint cn, bytes memory signature) public{\n        bytes32 message = keccak256(abi.encode(contractAddr, tokenAddr, user, pool, amount, micNonce, cn));\n        CurMsgHash = prefixed(message);\n        RecoveredAddr = recoverSigner(CurMsgHash, signature);\n    }\n\n    function Claim(address user, address pool, uint credit, uint amount, uint micNonce, uint cn, bytes memory signature) public{\n        uint total = amount + credit;\n        require(total > 0);\n        require(PoolData[pool].mainAddr == msg.sender || PoolData[pool].payerAddr == msg.sender);\n\n        Entity.UserDetails storage ud = UserData[user][pool];\n        require(ud.nonce > 0);\n        require(ud.epoch == cn);\n        require(ud.claimedMicNonce < micNonce);\n\n        bytes32 message = keccak256(abi.encode(this, token, user, pool, credit, amount, micNonce, cn));\n        bytes32 msgHash = prefixed(message);\n        require(recoverSigner(msgHash, signature) == user);\n\n        uint tn = total.mul(1 szabo).div(setting.MBytesPerToken);\n        if (tn > ud.tokenBalance){\n            tn = ud.tokenBalance;\n        }\n        token.transfer(msg.sender, tn);\n        ud.expiration = now + setting.Duration;\n        ud.claim(total, tn , micNonce);\n\n        vm.upgradeVer(Entity.ActionType.PoolClaim);\n        emit PoolClaim(pool, user, total, tn, micNonce, cn);\n    }\n\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n    function recoverSigner(bytes32 message, bytes memory sig) internal pure  returns (address) {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n        return ecrecover(message, v, r, s);\n    }\n    /// signature methods.\n    function splitSignature(bytes memory sig) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n        require(sig.length == 65);\n        assembly {\n        // first 32 bytes, after the length prefix.\n            r := mload(add(sig, 32))\n        // second 32 bytes.\n            s := mload(add(sig, 64))\n        // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(sig, 96)))\n        }\n        return (v, r, s);\n    }\n\n    /******************\n    * user action\n    ******************/\n    function BuyPacket(address user, uint tokenNo, address poolAddr) public{\n\n        require(PoolData[poolAddr].mainAddr != address(0));\n\n        token.transferFrom(msg.sender, address(this), tokenNo);\n\n        uint newPackets = tokenNo.div(1 szabo).mul(setting.MBytesPerToken);\n\n        Entity.UserDetails storage ch = UserData[user][poolAddr];\n        if (ch.nonce == 0){\n            poolsUsedByUser[user].push(poolAddr);\n            usersUnderPool[poolAddr].push(user);\n        }\n\n        ch.updateChannel(tokenNo, newPackets, setting.Duration);\n        vm.upgradeVer(Entity.ActionType.UserRecharge);\n        emit UserRecharge(user, poolAddr, tokenNo, newPackets);\n    }\n\n    function AllMyPools(address userAddress) public view returns (address[] memory){\n        return poolsUsedByUser[userAddress];\n    }\n\n    /******************\n    * miner action\n    ******************/\n    function JoinPool(address pool, uint tokenNo,  bytes32 subAddr, bytes2 zone) public{\n        require(tokenNo >= setting.MinMinerGuarantee);\n        require(MinerData[subAddr].payer == address(0));\n\n        token.transferFrom(msg.sender, address(this), tokenNo);\n        Entity.Miner memory miner = Entity.Miner(minersUnderPool[pool].length, msg.sender, pool, subAddr, tokenNo, zone);\n\n        minersUnderPool[pool].push(subAddr);\n        MinerData[subAddr] = miner;\n        vm.upgradeVer(Entity.ActionType.MinerJoin);\n    }\n\n    function ChangePool(address from, address to, bytes32 subAddr) public{\n        Entity.Miner storage miner = MinerData[subAddr];\n        require(miner.payer == msg.sender);\n        require(from != to);\n\n        delete minersUnderPool[from][miner.ID];\n        miner.ID = minersUnderPool[to].length;\n        miner.poolAddr = to;\n        minersUnderPool[to].push(subAddr);\n        vm.upgradeVer(Entity.ActionType.MinerChanged);\n    }\n\n    function RetireFromPool(bytes32 subAddr) public{\n        Entity.Miner memory miner = MinerData[subAddr];\n        require(miner.payer == msg.sender);\n\n        delete minersUnderPool[miner.poolAddr][miner.ID];\n        delete MinerData[subAddr];\n\n        token.transfer(msg.sender, miner.GTN);\n        vm.upgradeVer(Entity.ActionType.MinerRetire);\n    }\n\n    function AllMinersOfPool(address pool) public view returns(bytes32[] memory) {\n        return minersUnderPool[pool];\n    }\n\n    //[start, end)\n    function PartOfMiners(address pool, uint start, uint end) public view returns(bytes32[] memory) {\n        require(end > start);\n        uint length = minersUnderPool[pool].length;\n        if (end > length){\n            end = length;\n        }\n        bytes32[] memory tmp = new bytes32[](end - start);\n        for (uint i = start; i < end; i++){\n            tmp[i -start] = minersUnderPool[pool][i];\n        }\n\n        return tmp;\n    }\n\n    function MinerNoOfPool(address pool)public view returns (uint){\n        return minersUnderPool[pool].length;\n    }\n}"
    },
    "browser/pirate/owned.sol": {
      "content": "pragma solidity >=0.4.21;\n\ncontract owned {\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}"
    },
    "browser/pirate/safemath.sol": {
      "content": "pragma solidity >=0.4.24;\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}"
    }
  }
}