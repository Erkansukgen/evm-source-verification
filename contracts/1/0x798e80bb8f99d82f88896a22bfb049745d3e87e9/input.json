{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Multisend.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-09-14\n*/\n\npragma solidity >=0.6.0 <0.7.0;\n\ninterface Token {\n  function transfer(address to, uint256 value) external returns (bool);\n  function balanceOf(address owner) external view returns (uint256 balance);\n}\n\ncontract Ownable {\n    address public _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () public {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract MultiSend is Ownable {\n\n    Token token;\n\n    event TokenActivated(address tokenAddress, uint256 value);\n    event TransferredToken(address indexed to, uint256 value);\n    event FailedTransfer(address indexed to, uint256 value);\n\n    modifier whenDropIsActive() {\n        require(isActive());\n        _;\n    }\n\n    constructor () public {\n        \n    }\n    \n    \n    \n    function isActive() public view returns (bool) {\n        return (address(token) != address(0)) && (tokensAvailable() > 0);\n    }\n    \n    function tokensAvailable() public view returns (uint256) {\n        if (address(token) == address(0)) {\n            return 0;\n        }\n        return token.balanceOf(address(this));\n    }\n    \n    \n    \n    function sendTokens(address[] calldata dests, uint256[] calldata values) external whenDropIsActive onlyOwner {\n        for (uint256 i = 0; i < dests.length; i++) {\n            sendInternally(dests[i], values[i]);\n        }\n    }\n    \n    function sendBackRest() public whenDropIsActive onlyOwner {\n        uint256 balance = tokensAvailable();\n        if(balance > 0) {\n            token.transfer(_owner, balance);\n        }\n    }\n    \n    \n    \n    function setToken(address _tokenAddress) public onlyOwner {\n        //sendBackRest();\n        token = Token(_tokenAddress);\n        emit TokenActivated(_tokenAddress, tokensAvailable());\n    }\n\n    \n    function destroy(address payable owner) public onlyOwner {\n        uint256 balance = tokensAvailable();\n        require(balance > 0, \"balance is zero\");\n        token.transfer(owner, balance);\n        selfdestruct(owner);\n    }\n\n    \n\n\n    function sendInternally(address recipient, uint256 tokensToSend) internal {\n        if (recipient == address(0)) return;\n\n        if (tokensAvailable() >= tokensToSend) {\n            token.transfer(recipient, tokensToSend);\n            emit TransferredToken(recipient, tokensToSend);\n        } else {\n            emit FailedTransfer(recipient, tokensToSend);\n        }\n    }\n}"
    }
  }
}