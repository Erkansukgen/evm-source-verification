{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":99999},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"KashiHelper.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2021-03-14\n*/\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a <= uint128(-1), \"BoringMath: uint128 Overflow\");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a <= uint64(-1), \"BoringMath: uint64 Overflow\");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a <= uint32(-1), \"BoringMath: uint32 Overflow\");\n        c = uint32(a);\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.1.0\n// License-Identifier: MIT\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = elastic.mul(total.base) / total.elastic;\n            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\n                base = base.add(1);\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = base.mul(total.elastic) / total.base;\n            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\n                elastic = elastic.add(1);\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return total;\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.1.0\n// License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.1.0\n// License-Identifier: MIT\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}\n\n// File @sushiswap/bentobox-sdk/contracts/IBatchFlashBorrower.sol@v1.0.0\n// License-Identifier: MIT\n\ninterface IBatchFlashBorrower {\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}\n\n// File @sushiswap/bentobox-sdk/contracts/IFlashBorrower.sol@v1.0.0\n// License-Identifier: MIT\n\ninterface IFlashBorrower {\n    function onFlashLoan(\n        address sender,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external;\n}\n\n// File @sushiswap/bentobox-sdk/contracts/IStrategy.sol@v1.0.0\n// License-Identifier: MIT\n\ninterface IStrategy {\n    // Send the assets to the Strategy and call skim to invest them\n    function skim(uint256 amount) external;\n\n    // Harvest any profits made converted to the asset and pass them to the caller\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    // Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n    // The actualAmount should be very close to the amount. The difference should NOT be used to report a loss. That's what harvest is for.\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    // Withdraw all assets in the safest way possible. This shouldn't fail.\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.0\n// License-Identifier: MIT\n\ninterface IBentoBoxV1 {\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event LogFlashLoan(address indexed borrower, address indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\n    event LogRegisterProtocol(address indexed protocol);\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\n    event LogStrategyDivest(address indexed token, uint256 amount);\n    event LogStrategyInvest(address indexed token, uint256 amount);\n    event LogStrategyLoss(address indexed token, uint256 amount);\n    event LogStrategyProfit(address indexed token, uint256 amount);\n    event LogStrategyQueued(address indexed token, address indexed strategy);\n    event LogStrategySet(address indexed token, address indexed strategy);\n    event LogStrategyTargetPercentage(address indexed token, uint256 targetPercentage);\n    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 share);\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\n    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function balanceOf(IERC20, address) external view returns (uint256);\n\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\n\n    function batchFlashLoan(\n        IBatchFlashBorrower borrower,\n        address[] calldata receivers,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function claimOwnership() external;\n\n    function deploy(\n        address masterContract,\n        bytes calldata data,\n        bool useCreate2\n    ) external payable;\n\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function flashLoan(\n        IFlashBorrower borrower,\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function harvest(\n        IERC20 token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n\n    function masterContractApproved(address, address) external view returns (bool);\n\n    function masterContractOf(address) external view returns (address);\n\n    function nonces(address) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function pendingStrategy(IERC20) external view returns (IStrategy);\n\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function registerProtocol() external;\n\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\n\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\n\n    function strategy(IERC20) external view returns (IStrategy);\n\n    function strategyData(IERC20)\n        external\n        view\n        returns (\n            uint64 strategyStartDate,\n            uint64 targetPercentage,\n            uint128 balance\n        );\n\n    function toAmount(\n        IERC20 token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    function toShare(\n        IERC20 token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    function totals(IERC20) external view returns (uint128 elastic, uint128 base);\n\n    function transfer(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    function transferMultiple(\n        IERC20 token,\n        address from,\n        address[] calldata tos,\n        uint256[] calldata shares\n    ) external;\n\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) external;\n\n    function whitelistMasterContract(address masterContract, bool approved) external;\n\n    function whitelistedMasterContracts(address) external view returns (bool);\n\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n\n// File contracts/interfaces/IOracle.sol\n// License-Identifier: MIT\n\ninterface IOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(bytes calldata data) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(bytes calldata data) external view returns (bool success, uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(bytes calldata data) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n    /// For example:\n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return (string) A human readable name about this oracle.\n    function name(bytes calldata data) external view returns (string memory);\n}\nstruct AccrueInfo {\n    uint64 interestPerSecond;\n    uint64 lastAccrued;\n    uint128 feesEarnedFraction;\n}\n\ninterface IKashiPair {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function accrue() external;\n    function accrueInfo() external view returns (AccrueInfo memory info);\n    function addAsset(address to, bool skim, uint256 share) external returns (uint256 fraction);\n    function addCollateral(address to, bool skim, uint256 share) external;\n    function allowance(address, address) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function asset() external view returns (IERC20);\n    function balanceOf(address) external view returns (uint256);\n    function bentoBox() external view returns (IBentoBoxV1);\n    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);\n    function claimOwnership() external;\n    function collateral() external view returns (IERC20);\n    function cook(uint8[] calldata actions, uint256[] calldata values, bytes[] calldata datas) external payable returns (uint256 value1, uint256 value2);\n    function decimals() external view returns (uint8);\n    function exchangeRate() external view returns (uint256);\n    function feeTo() external view returns (address);\n    function getInitData(IERC20 collateral_, IERC20 asset_, address oracle_, bytes calldata oracleData_) external pure returns (bytes memory data);\n    function init(bytes calldata data) external payable;\n    function isSolvent(address user, bool open) external view returns (bool);\n    function liquidate(address[] calldata users, uint256[] calldata borrowParts, address to, address swapper, bool open) external;\n    function masterContract() external view returns (address);\n    function name() external view returns (string memory);\n    function nonces(address) external view returns (uint256);\n    function oracle() external view returns (IOracle);\n    function oracleData() external view returns (bytes memory);\n    function owner() external view returns (address);\n    function pendingOwner() external view returns (address);\n    function permit(address owner_, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function removeAsset(address to, uint256 fraction) external returns (uint256 share);\n    function removeCollateral(address to, uint256 share) external;\n    function repay(address to, bool skim, uint256 part) external returns (uint256 amount);\n    function setFeeTo(address newFeeTo) external;\n    function setSwapper(address swapper, bool enable) external;\n    function swappers(address) external view returns (bool);\n    function symbol() external view returns (string memory);\n    function totalAsset() external view returns (Rebase memory total);\n    function totalBorrow() external view returns (Rebase memory total);\n    function totalCollateralShare() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function transferOwnership(address newOwner, bool direct, bool renounce) external;\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\n    function userBorrowPart(address) external view returns (uint256);\n    function userCollateralShare(address) external view returns (uint256);\n    function withdrawFees() external;\n}\n\n/// @dev This contract provides useful helper functions for `KashiPair`.\ncontract KashiPairHelper {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    uint256 public constant APY_PRECISION = 1e8;\n    uint256 private constant PROTOCOL_FEE_LEFTOVER = 90000; // 100% - 10%\n    uint256 private constant PROTOCOL_FEE_DIVISOR = 1e5;\n\n    /// @dev Helper function to calculate the collateral shares that are needed for `borrowPart`,\n    /// taking the current exchange rate into account.\n    function getCollateralSharesForBorrowPart(IKashiPair kashiPair, uint256 borrowPart) public view returns (uint256) {\n        // Taken from KashiPair\n        uint256 EXCHANGE_RATE_PRECISION = 1e18;\n        uint256 LIQUIDATION_MULTIPLIER = 112000; // add 12%\n        uint256 LIQUIDATION_MULTIPLIER_PRECISION = 1e5;\n\n        Rebase memory totalBorrow = kashiPair.totalBorrow();\n        uint256 borrowAmount = totalBorrow.toElastic(borrowPart, false);\n\n        return\n            kashiPair.bentoBox().toShare(\n                kashiPair.collateral(),\n                borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(kashiPair.exchangeRate()) /\n                    (LIQUIDATION_MULTIPLIER_PRECISION * EXCHANGE_RATE_PRECISION),\n                false\n            );\n    }\n\n    struct KashiPairInfo {\n        IERC20 collateral;\n        string collateralSymbol;\n        uint8 collateralDecimals;\n        IERC20 asset;\n        string assetSymbol;\n        uint8 assetDecimals;\n        IOracle oracle;\n        bytes oracleData;\n    }\n\n    function getPairs(IKashiPair[] calldata addresses) public view returns (KashiPairInfo[] memory) {\n        KashiPairInfo[] memory pairs = new KashiPairInfo[](addresses.length);\n        for (uint256 i = 0; i < addresses.length; i++) {\n            pairs[i].collateral = addresses[i].collateral();\n            pairs[i].collateralSymbol = IERC20(addresses[i].collateral()).safeSymbol();\n            pairs[i].collateralDecimals = IERC20(addresses[i].collateral()).safeDecimals();\n            pairs[i].asset = addresses[i].asset();\n            pairs[i].assetSymbol = IERC20(addresses[i].asset()).safeSymbol();\n            pairs[i].assetDecimals = IERC20(addresses[i].asset()).safeDecimals();\n            pairs[i].oracle = addresses[i].oracle();\n            pairs[i].oracleData = addresses[i].oracleData();\n        }\n        return pairs;\n    }\n\n    struct PairPollInfo {\n        uint256 suppliedPairCount;\n        uint256 borrowPairCount;\n    }\n\n    struct PairPoll {\n        uint256 totalCollateralAmount;\n        uint256 userCollateralAmount;\n        uint256 totalAssetAmount;\n        uint256 userAssetAmount;\n        uint256 totalBorrowAmount;\n        uint256 userBorrowAmount;\n        uint256 currentExchangeRate;\n        uint256 oracleExchangeRate;\n        AccrueInfo accrueInfo;\n        uint256 assetAPR;\n        uint256 borrowAPR;\n    }\n\n    function pollPairs(address who, IKashiPair[] calldata addresses) public view returns (PairPollInfo memory, PairPoll[] memory) {\n        PairPollInfo memory info;\n        PairPoll[] memory pairs = new PairPoll[](addresses.length);\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            IBentoBoxV1 bentoBox = IBentoBoxV1(addresses[i].bentoBox());\n            {\n                pairs[i].totalCollateralAmount = bentoBox.toAmount(addresses[i].collateral(), addresses[i].totalCollateralShare(), false);\n                pairs[i].userCollateralAmount = bentoBox.toAmount(addresses[i].collateral(), addresses[i].userCollateralShare(who), false);\n            }\n            {\n                Rebase memory totalAsset;\n                {\n                    totalAsset = addresses[i].totalAsset();\n                    pairs[i].totalAssetAmount = bentoBox.toAmount(addresses[i].asset(), totalAsset.elastic, false);\n                }\n                pairs[i].userAssetAmount = bentoBox.toAmount(addresses[i].asset(), totalAsset.toElastic(addresses[i].balanceOf(who), false), false);\n                if(pairs[i].userAssetAmount > 0) {\n                    info.suppliedPairCount += 1;\n                }\n            }\n            {\n                {\n                    pairs[i].currentExchangeRate = addresses[i].exchangeRate();\n                    (, pairs[i].oracleExchangeRate) = addresses[i].oracle().peek(addresses[i].oracleData());\n                    pairs[i].accrueInfo = addresses[i].accrueInfo();\n                }\n                Rebase memory totalBorrow = addresses[i].totalBorrow();\n                pairs[i].totalBorrowAmount = totalBorrow.elastic;\n                pairs[i].userBorrowAmount = totalBorrow.toElastic(addresses[i].userBorrowPart(who), false);\n                if(pairs[i].userBorrowAmount > 0) {\n                    info.borrowPairCount += 1;\n                }\n            }\n            {\n                uint256 _totalBorrowAmount = pairs[i].totalBorrowAmount == 0 ? 1 : pairs[i].totalBorrowAmount; \n                uint256 yearlyInterest = _totalBorrowAmount.mul(pairs[i].accrueInfo.interestPerSecond).mul(365 days);\n                pairs[i].assetAPR = yearlyInterest.mul(APY_PRECISION).mul(PROTOCOL_FEE_LEFTOVER) / _totalBorrowAmount.add(pairs[i].totalAssetAmount).mul(PROTOCOL_FEE_DIVISOR).mul(1e18);\n                pairs[i].borrowAPR = yearlyInterest.mul(APY_PRECISION) / _totalBorrowAmount.mul(1e18);\n            }\n        }\n\n        return (info, pairs);\n\n    }\n\n}"}}}