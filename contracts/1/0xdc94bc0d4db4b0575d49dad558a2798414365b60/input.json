{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/betaliq.sol": {
      "content": "pragma solidity >=0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './lib/SafeMath.sol';\r\n\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH{\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\ninterface v2pool{\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface betabank{\r\n    function liquidate(\r\n        address _owner,\r\n        uint _pid,\r\n        uint _amount\r\n      ) external;\r\n}\r\n\r\n\r\n\r\ncontract betaliqsimp {\r\n    using SafeMath for uint;\r\n    \r\n    address payable public owner;\r\n    \r\n\r\n    \r\n\r\n    constructor() public {\r\n        owner = payable(msg.sender);\r\n\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, owner, amount);\r\n    }\r\n    \r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n\r\n\r\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\r\n    \r\n        (address borrower, uint256 pid, uint256 amount, uint256 repayamount)  = abi.decode(_data, (address, uint256, uint256, uint256));\r\n\r\n\r\n        // liquidate the target\r\n        betabank(address(0x972a785b390D05123497169a04c72dE652493BE1)).liquidate(borrower, pid, amount);\r\n\r\n\r\n\r\n        // payback token\r\n        _safeTransfer(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2), msg.sender, repayamount);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    function v2swap(address pool, uint256 outamout, bool flag, address borrower, uint256 pid) private{\r\n\r\n        if(flag){\r\n\r\n            bytes memory returnData;\r\n            (, returnData) = address(pool).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n            (uint r0, uint r1, ) = abi.decode(returnData, (uint,uint,uint)); \r\n\r\n            uint256 repayamount = getAmountIn(outamout, r0, r1);\r\n\r\n            bytes memory data = abi.encode(borrower, pid, outamout, repayamount);\r\n            v2pool(address(pool)).swap(0, outamout, address(this), data);\r\n        }else{\r\n\r\n            bytes memory returnData;\r\n            (, returnData) = address(pool).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n            (uint r0, uint r1, ) = abi.decode(returnData, (uint,uint,uint)); \r\n\r\n            uint256 repayamount = getAmountIn(outamout, r1, r0);\r\n\r\n            bytes memory data = abi.encode(borrower, pid, outamout, repayamount);\r\n            v2pool(address(pool)).swap(outamout, 0, address(this), data);\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    // rn sell all on v2, sellpath combines of flag(1 byte) + addr(20 bytes)\r\n\r\n    function betafinanceliq(address pool, uint256 outamout, bool flag, address borrower, uint256 pid, address undertoken, address btoken, uint256 percent) public returns(uint256) {\r\n\r\n        uint256 gasstart = gasleft();\r\n\r\n        IERC20(address(undertoken)).approve(btoken, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n\r\n        v2swap(pool, outamout, flag, borrower, pid);\r\n\r\n        /*\r\n        if(flag){\r\n\r\n            bytes memory returnData;\r\n            (, returnData) = address(pool).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n            (uint r0, uint r1, ) = abi.decode(returnData, (uint,uint,uint)); \r\n\r\n            uint256 repayamount = getAmountIn(outamout, r0, r1);\r\n\r\n            bytes memory data = abi.encode(borrower, pid, outamout, repayamount);\r\n            v2pool(address(pool)).swap(0, outamout, address(this), data);\r\n        }else{\r\n\r\n            bytes memory returnData;\r\n            (, returnData) = address(pool).staticcall(abi.encodeWithSelector(0x0902f1ac));\r\n            (uint r0, uint r1, ) = abi.decode(returnData, (uint,uint,uint)); \r\n\r\n            uint256 repayamount = getAmountIn(outamout, r1, r0);\r\n\r\n            bytes memory data = abi.encode(borrower, pid, outamout, repayamount);\r\n            v2pool(address(pool)).swap(outamout, 0, address(this), data);\r\n        }\r\n        */\r\n\r\n        {\r\n            uint256 benefit = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\r\n\r\n            IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(benefit);\r\n\r\n            block.coinbase.transfer(benefit * percent / 100);\r\n\r\n            require(address(this).balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n\r\n            benefit = address(this).balance;\r\n\r\n            payable(msg.sender).transfer(address(this).balance);\r\n\r\n            return(benefit);\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    /*\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    } \r\n    */\r\n\r\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "pragma solidity >=0.6.6;\n\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n        return c;\n    }\n\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n        return c;\n    }\n\n}"
    }
  }
}