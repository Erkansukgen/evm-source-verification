{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ChiGasSaver.sol":{"content":"pragma solidity ^0.7.5;\n\nabstract contract IFreeFromUpTo {\n    function freeFromUpTo(address from, uint256 value) virtual external returns(uint256 freed);\n}\n\ncontract ChiGasSaver {\n\n    modifier saveGas(address payable sponsor) {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n\n        IFreeFromUpTo chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n        chi.freeFromUpTo(sponsor, (gasSpent + 14154) / 41947);\n    }\n}\n"},"browser/FlashSwap3.sol":{"content":"pragma solidity 0.7.5;\n\nimport './UniswapFlashSwapper.sol';\nimport './UniswapV2Interfaces.sol';\nimport './ChiGasSaver.sol';\n\ncontract FlashSwap is UniswapFlashSwapper, ChiGasSaver {\n    \n    address payable private owner;\n\n    address internal constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    \n    IUniswapV2Router01 constant uniswapV2Router01 = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS); // Same for all networks\n\n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    // DAI   0x6B175474E89094C44Da98b954EedeAC495271d0F Mainnet\n    // WETH  0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 Mainnet\n    // USDC  0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 Mainnet\n    \n    // DAI   0xFf795577d9AC8bD7D90Ee22b6C1703490b6512FD Kovan\n    // WETH  0xd0A1E359811322d97991E03f863a0C30C2cF029C Kovan\n    constructor(address _DAI, address _WETH) public UniswapFlashSwapper(_DAI, _WETH) {\n        owner = msg.sender;\n    }\n    \n    function withdraw(address _asset) external isOwner {\n        IERC20 TOKEN = IERC20(_asset);\n        require(TOKEN.transfer(owner, TOKEN.balanceOf(address(this))), 'transferFrom failed.');\n    }\n\n    // @notice Call this function to make a flash swap\n    function flashSwap(address _asset, uint256 _amount, address[] calldata _path) external saveGas(msg.sender) isOwner {\n\n        uint256[] memory out = uniswapV2Router01.getAmountsOut(_amount, _path);\n        //require(out[out.length-1] > _amount, 'U1'); // unprofitable\n        \n        uint fee = ((_amount * 3) / 997) + 1;\n        uint amountToRepay = _amount + fee;\n        require(out[out.length-1] > amountToRepay, 'U1'); // unprofitable\n        \n        \n        \n        //bytes memory _userData = abi.encode(path);\n        \n        // Start the flash swap\n        // This will borrow _amount of the requested _tokenBorrow token for this contract and then\n        // run the `execute` function below\n        startSwap(_asset, _amount, _path);\n    }\n\n    // @notice This is where your custom logic goes\n    // @dev When this code executes, this contract will hold _amount of _tokenBorrow\n    function execute(address _asset, uint _amount, address[] memory _path) internal override {\n        //require(true == false, \"exec 1\");\n        \n        // do whatever you want here\n        // <insert arbitrage, liquidation, CDP collateral swap, etc>\n        // be sure this contract is holding at least _amountToRepay of the _tokenPay tokens before this function finishes executing\n        // DO NOT pay back the flash loan in this function -- that will be handled for you automatically\n        \n        //address[] memory path = abi.decode(_userData, (address[]));\n        //require(true == false, \"exec 2\");\n        \n        IERC20 TOKEN = IERC20(_asset);\n        //require(true == false, \"exec 3\");\n        //require(DAI.transferFrom(owner(), address(this), amount), 'transferFrom failed.');\n        require(TOKEN.approve(UNISWAP_ROUTER_ADDRESS, _amount), 'approve failed.');\n        //require(true == false, \"exec 4\");\n        \n        uint deadline = block.timestamp + 120;\n        \n        uniswapV2Router01.swapExactTokensForTokens(_amount, _amount, _path, address(this), deadline);\n        //uniswapV2Router02.swapExactTokensForTokensSupportingFeeOnTransferTokens(_amount, _amount, _path, address(this), deadline);\n        //require(true == false, \"exec 5\");\n    }\n\n}"},"browser/UniswapFlashSwapper.sol":{"content":"pragma solidity 0.7.5;\n\nimport \"./UniswapV2Interfaces.sol\";\n\n\nabstract contract UniswapFlashSwapper {\n\n    //enum SwapType {SimpleLoan, SimpleSwap, TriangularSwap}\n\n    // CONSTANTS\n    //address constant ETH = address(0);\n\n    // ACCESS CONTROL\n    // Only the `permissionedPairAddress` may call the `uniswapV2Call` function\n    address private permissionedPairAddress;// = address(1);\n\n    // DEFAULT TOKENS\n    address WETH;\n    address DAI;\n    IUniswapV2Factory constant uniswapV2Factory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f); // same for all networks\n\n    constructor(address _DAI, address _WETH) {\n        WETH = _WETH;\n        DAI = _DAI;\n        permissionedPairAddress = uniswapV2Factory.getPair(WETH, DAI); // is it cheaper to compute this locally?\n    }\n\n    // Fallback must be payable\n    //function() external payable {}\n    receive() external payable {}\n\n    // @notice Flash-borrows _amount of _tokenBorrow from a Uniswap V2 pair and repays using _tokenPay\n    // @param _tokenBorrow The address of the token you want to flash-borrow, use 0x0 for ETH\n    // @param _amount The amount of _tokenBorrow you will borrow\n    // @param _tokenPay The address of the token you want to use to payback the flash-borrow, use 0x0 for ETH\n    // @param _userData Data that will be passed to the `execute` function for the user\n    // @dev Depending on your use case, you may want to add access controls to this function\n    //function startSwap(address _tokenBorrow, uint256 _amount, address _tokenPay, bytes memory _userData) internal {\n        \n        //simpleFlashLoan(_tokenBorrow, _amount, _userData);\n        \n        /*\n        bool isBorrowingEth;\n        bool isPayingEth;\n        address tokenBorrow = _tokenBorrow;\n        address tokenPay = _tokenPay;\n\n        if (tokenBorrow == ETH) {\n            isBorrowingEth = true;\n            tokenBorrow = WETH; // we'll borrow WETH from UniswapV2 but then unwrap it for the user\n        }\n        if (tokenPay == ETH) {\n            isPayingEth = true;\n            tokenPay = WETH; // we'll wrap the user's ETH before sending it back to UniswapV2\n        }\n\n        if (tokenBorrow == tokenPay) {\n            simpleFlashLoan(tokenBorrow, _amount, isBorrowingEth, isPayingEth, _userData);\n            return;\n        } else if (tokenBorrow == WETH || tokenPay == WETH) {\n            simpleFlashSwap(tokenBorrow, _amount, tokenPay, isBorrowingEth, isPayingEth, _userData);\n            return;\n        } else {\n            traingularFlashSwap(tokenBorrow, _amount, tokenPay, _userData);\n            return;\n        }\n        */\n\n    //}\n\n\n    // @notice Function is called by the Uniswap V2 pair's `swap` function\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external {\n        // access control\n        require(msg.sender == permissionedPairAddress, \"only permissioned UniswapV2 pair can call\");\n        require(_sender == address(this), \"only this contract may initiate\");\n\n        // decode data\n        (\n            //SwapType _swapType,\n            address _asset,\n            uint _amount,\n            //bool _isBorrowingEth,\n            //bool _isPayingEth,\n            //bytes memory _triangleData,\n            //bytes memory _userData\n            address[] memory _path\n        ) = abi.decode(_data, (address, uint, address[]));\n\n        simpleFlashLoanExecute(_asset, _amount, msg.sender, _path);\n        return;\n        \n        /*\n        if (_swapType == SwapType.SimpleLoan) {\n            simpleFlashLoanExecute(_tokenBorrow, _amount, msg.sender, _isBorrowingEth, _isPayingEth, _userData);\n            return;\n        } else if (_swapType == SwapType.SimpleSwap) {\n            simpleFlashSwapExecute(_tokenBorrow, _amount, _tokenPay, msg.sender, _isBorrowingEth, _isPayingEth, _userData);\n            return;\n        } else {\n            traingularFlashSwapExecute(_tokenBorrow, _amount, _tokenPay, _triangleData, _userData);\n        }\n        */\n\n        // NOOP to silence compiler \"unused parameter\" warning\n        if (false) {\n            _amount0;\n            _amount1;\n        }\n    }\n\n    // @notice This function is used when the user repays with the same token they borrowed\n    // @dev This initiates the flash borrow. See `simpleFlashLoanExecute` for the code that executes after the borrow.\n    function startSwap(address _asset, uint256 _amount, address[] calldata _path) internal {\n        address tokenOther = _asset == WETH ? DAI : WETH;\n        //permissionedPairAddress = uniswapV2Factory.getPair(_tokenBorrow, tokenOther); // is it cheaper to compute this locally?\n        address pairAddress = permissionedPairAddress; // gas efficiency\n        require(pairAddress != address(0), \"Requested _token is not available.\");\n        address token0 = IUniswapV2Pair(pairAddress).token0();\n        address token1 = IUniswapV2Pair(pairAddress).token1();\n        uint amount0Out = _asset == token0 ? _amount : 0;\n        uint amount1Out = _asset == token1 ? _amount : 0;\n        bytes memory data = abi.encode(\n            _asset,\n            _amount,\n            _path\n        ); // note _tokenBorrow == _tokenPay\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), data);\n    }\n\n    // @notice This is the code that is executed after `simpleFlashLoan` initiated the flash-borrow\n    // @dev When this code executes, this contract will hold the flash-borrowed _amount of _tokenBorrow\n    function simpleFlashLoanExecute(\n        address _asset,\n        uint _amount,\n        address _pairAddress,\n        address[] memory _path\n    ) private {\n        // unwrap WETH if necessary\n        //if (_isBorrowingEth) {\n        //    IWETH(WETH).withdraw(_amount);\n        //}\n\n        // compute amount of tokens that need to be paid back\n        \n        \n        //address tokenBorrowed = _isBorrowingEth ? ETH : _tokenBorrow;\n        //address tokenToRepay = _isPayingEth ? ETH : _tokenBorrow;\n\n        // do whatever the user wants\n        execute(_asset, _amount, _path);\n\n        // payback the loan\n        // wrap the ETH if necessary\n        //if (_isPayingEth) {\n        //    IWETH(WETH).deposit.value(amountToRepay)();\n        //}\n        uint fee = ((_amount * 3) / 997) + 1;\n        uint amountToRepay = _amount + fee;\n        IERC20(_asset).transfer(_pairAddress, amountToRepay);\n    }\n\n    /*\n    // @notice This function is used when either the _tokenBorrow or _tokenPay is WETH or ETH\n    // @dev Since ~all tokens trade against WETH (if they trade at all), we can use a single UniswapV2 pair to\n    //     flash-borrow and repay with the requested tokens.\n    // @dev This initiates the flash borrow. See `simpleFlashSwapExecute` for the code that executes after the borrow.\n    function simpleFlashSwap(\n        address _tokenBorrow,\n        uint _amount,\n        address _tokenPay,\n        bool _isBorrowingEth,\n        bool _isPayingEth,\n        bytes memory _userData\n    ) private {\n        permissionedPairAddress = uniswapV2Factory.getPair(_tokenBorrow, _tokenPay); // is it cheaper to compute this locally?\n        address pairAddress = permissionedPairAddress; // gas efficiency\n        require(pairAddress != address(0), \"Requested pair is not available.\");\n        address token0 = IUniswapV2Pair(pairAddress).token0();\n        address token1 = IUniswapV2Pair(pairAddress).token1();\n        uint amount0Out = _tokenBorrow == token0 ? _amount : 0;\n        uint amount1Out = _tokenBorrow == token1 ? _amount : 0;\n        bytes memory data = abi.encode(\n            SwapType.SimpleSwap,\n            _tokenBorrow,\n            _amount,\n            _tokenPay,\n            _isBorrowingEth,\n            _isPayingEth,\n            bytes(\"\"),\n            _userData\n        );\n        IUniswapV2Pair(pairAddress).swap(amount0Out, amount1Out, address(this), data);\n    }\n\n    // @notice This is the code that is executed after `simpleFlashSwap` initiated the flash-borrow\n    // @dev When this code executes, this contract will hold the flash-borrowed _amount of _tokenBorrow\n    function simpleFlashSwapExecute(\n        address _tokenBorrow,\n        uint _amount,\n        address _tokenPay,\n        address _pairAddress,\n        bool _isBorrowingEth,\n        bool _isPayingEth,\n        bytes memory _userData\n    ) private {\n        // unwrap WETH if necessary\n        if (_isBorrowingEth) {\n            IWETH(WETH).withdraw(_amount);\n        }\n\n        // compute the amount of _tokenPay that needs to be repaid\n        address pairAddress = permissionedPairAddress; // gas efficiency\n        uint pairBalanceTokenBorrow = IERC20(_tokenBorrow).balanceOf(pairAddress);\n        uint pairBalanceTokenPay = IERC20(_tokenPay).balanceOf(pairAddress);\n        uint amountToRepay = ((1000 * pairBalanceTokenPay * _amount) / (997 * pairBalanceTokenBorrow)) + 1;\n\n        // get the orignal tokens the user requested\n        address tokenBorrowed = _isBorrowingEth ? ETH : _tokenBorrow;\n        address tokenToRepay = _isPayingEth ? ETH : _tokenPay;\n\n        // do whatever the user wants\n        execute(tokenBorrowed, _amount, tokenToRepay, amountToRepay, _userData);\n\n        // payback loan\n        // wrap ETH if necessary\n        if (_isPayingEth) {\n            IWETH(WETH).deposit.value(amountToRepay)();\n        }\n        IERC20(_tokenPay).transfer(_pairAddress, amountToRepay);\n    }\n\n    // @notice This function is used when neither the _tokenBorrow nor the _tokenPay is WETH\n    // @dev Since it is unlikely that the _tokenBorrow/_tokenPay pair has more liquidaity than the _tokenBorrow/WETH and\n    //     _tokenPay/WETH pairs, we do a triangular swap here. That is, we flash borrow WETH from the _tokenPay/WETH pair,\n    //     Then we swap that borrowed WETH for the desired _tokenBorrow via the _tokenBorrow/WETH pair. And finally,\n    //     we pay back the original flash-borrow using _tokenPay.\n    // @dev This initiates the flash borrow. See `traingularFlashSwapExecute` for the code that executes after the borrow.\n    function traingularFlashSwap(address _tokenBorrow, uint _amount, address _tokenPay, bytes memory _userData) private {\n        address borrowPairAddress = uniswapV2Factory.getPair(_tokenBorrow, WETH); // is it cheaper to compute this locally?\n        require(borrowPairAddress != address(0), \"Requested borrow token is not available.\");\n\n        permissionedPairAddress = uniswapV2Factory.getPair(_tokenPay, WETH); // is it cheaper to compute this locally?\n        address payPairAddress = permissionedPairAddress; // gas efficiency\n        require(payPairAddress != address(0), \"Requested pay token is not available.\");\n\n        // STEP 1: Compute how much WETH will be needed to get _amount of _tokenBorrow out of the _tokenBorrow/WETH pool\n        uint pairBalanceTokenBorrowBefore = IERC20(_tokenBorrow).balanceOf(borrowPairAddress);\n        require(pairBalanceTokenBorrowBefore >= _amount, \"_amount is too big\");\n        uint pairBalanceTokenBorrowAfter = pairBalanceTokenBorrowBefore - _amount;\n        uint pairBalanceWeth = IERC20(WETH).balanceOf(borrowPairAddress);\n        uint amountOfWeth = ((1000 * pairBalanceWeth * _amount) / (997 * pairBalanceTokenBorrowAfter)) + 1;\n\n        // using a helper function here to avoid \"stack too deep\" :(\n        traingularFlashSwapHelper(_tokenBorrow, _amount, _tokenPay, borrowPairAddress, payPairAddress, amountOfWeth, _userData);\n    }\n\n    // @notice Helper function for `traingularFlashSwap` to avoid `stack too deep` errors\n    function traingularFlashSwapHelper(\n        address _tokenBorrow,\n        uint _amount,\n        address _tokenPay,\n        address _borrowPairAddress,\n        address _payPairAddress,\n        uint _amountOfWeth,\n        bytes memory _userData\n    ) private returns (uint) {\n        // Step 2: Flash-borrow _amountOfWeth WETH from the _tokenPay/WETH pool\n        address token0 = IUniswapV2Pair(_payPairAddress).token0();\n        address token1 = IUniswapV2Pair(_payPairAddress).token1();\n        uint amount0Out = WETH == token0 ? _amountOfWeth : 0;\n        uint amount1Out = WETH == token1 ? _amountOfWeth : 0;\n        bytes memory triangleData = abi.encode(_borrowPairAddress, _amountOfWeth);\n        bytes memory data = abi.encode(SwapType.TriangularSwap, _tokenBorrow, _amount, _tokenPay, false, false, triangleData, _userData);\n        // initiate the flash swap from UniswapV2\n        IUniswapV2Pair(_payPairAddress).swap(amount0Out, amount1Out, address(this), data);\n    }\n\n    // @notice This is the code that is executed after `traingularFlashSwap` initiated the flash-borrow\n    // @dev When this code executes, this contract will hold the amount of WETH we need in order to get _amount\n    //     _tokenBorrow from the _tokenBorrow/WETH pair.\n    function traingularFlashSwapExecute(\n        address _tokenBorrow,\n        uint _amount,\n        address _tokenPay,\n        bytes memory _triangleData,\n        bytes memory _userData\n    ) private {\n        // decode _triangleData\n        (address _borrowPairAddress, uint _amountOfWeth) = abi.decode(_triangleData, (address, uint));\n\n        // Step 3: Using a normal swap, trade that WETH for _tokenBorrow\n        address token0 = IUniswapV2Pair(_borrowPairAddress).token0();\n        address token1 = IUniswapV2Pair(_borrowPairAddress).token1();\n        uint amount0Out = _tokenBorrow == token0 ? _amount : 0;\n        uint amount1Out = _tokenBorrow == token1 ? _amount : 0;\n        IERC20(WETH).transfer(_borrowPairAddress, _amountOfWeth); // send our flash-borrowed WETH to the pair\n        IUniswapV2Pair(_borrowPairAddress).swap(amount0Out, amount1Out, address(this), bytes(\"\"));\n\n        // compute the amount of _tokenPay that needs to be repaid\n        address payPairAddress = permissionedPairAddress; // gas efficiency\n        uint pairBalanceWETH = IERC20(WETH).balanceOf(payPairAddress);\n        uint pairBalanceTokenPay = IERC20(_tokenPay).balanceOf(payPairAddress);\n        uint amountToRepay = ((1000 * pairBalanceTokenPay * _amountOfWeth) / (997 * pairBalanceWETH)) + 1;\n\n        // Step 4: Do whatever the user wants (arb, liqudiation, etc)\n        execute(_tokenBorrow, _amount, _tokenPay, amountToRepay, _userData);\n\n        // Step 5: Pay back the flash-borrow to the _tokenPay/WETH pool\n        IERC20(_tokenPay).transfer(payPairAddress, amountToRepay);\n    }\n    */\n\n\n    // @notice This is where the user's custom logic goes\n    // @dev When this function executes, this contract will hold _amount of _tokenBorrow\n    // @dev It is important that, by the end of the execution of this function, this contract holds the necessary\n    //     amount of the original _tokenPay needed to pay back the flash-loan.\n    // @dev Paying back the flash-loan happens automatically by the calling function -- do not pay back the loan in this function\n    // @dev If you entered `0x0` for _tokenPay when you called `flashSwap`, then make sure this contract hols _amount ETH before this\n    //     finishes executing\n    // @dev User will override this function on the inheriting contract\n    function execute(address _asset, uint _amount, address[] memory _path) virtual internal;\n\n}\n"},"browser/UniswapV2Interfaces.sol":{"content":"pragma solidity 0.7.5;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n  function allPairs(uint) external view returns (address pair);\n  function allPairsLength() external view returns (uint);\n  function feeTo() external view returns (address);\n  function feeToSetter() external view returns (address);\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n  function name() external pure returns (string memory);\n  function symbol() external pure returns (string memory);\n  function decimals() external pure returns (uint8);\n  function totalSupply() external view returns (uint);\n  function balanceOf(address owner) external view returns (uint);\n  function allowance(address owner, address spender) external view returns (uint);\n  function approve(address spender, uint value) external returns (bool);\n  function transfer(address to, uint value) external returns (bool);\n  function transferFrom(address from, address to, uint value) external returns (bool);\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n  function nonces(address owner) external view returns (uint);\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n  event Mint(address indexed sender, uint amount0, uint amount1);\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n  event Swap(\n      address indexed sender,\n      uint amount0In,\n      uint amount1In,\n      uint amount0Out,\n      uint amount1Out,\n      address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\n  function factory() external view returns (address);\n  function token0() external view returns (address);\n  function token1() external view returns (address);\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n  function price0CumulativeLast() external view returns (uint);\n  function price1CumulativeLast() external view returns (uint);\n  function kLast() external view returns (uint);\n  function mint(address to) external returns (uint liquidity);\n  function burn(address to) external returns (uint amount0, uint amount1);\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n  function skim(address to) external;\n  function sync() external;\n}\n\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function name() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IWETH {\n    function withdraw(uint) external;\n    function deposit() external payable;\n}\n"}}}