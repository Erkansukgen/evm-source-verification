{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"NftOwner.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev LEEDO NFT Ownership Proxy\r\n *\r\n *  _              ______      \r\n * | |             |  _  \\     \r\n * | |     ___  ___| | | |___  \r\n * | |    / _ \\/ _ \\ | | / _ \\ \r\n * | |___|  __/  __/ |/ / (_) |\r\n * \\_____/\\___|\\___|___/ \\___/ \r\n * LEEDO Project\r\n */\r\n\r\ninterface INft {\r\n\r\n    function ownerOf(uint tokenId) external view returns (address owner);\r\n    function tokensOf(address account) external view returns (uint[] memory);\r\n    function balanceOf(address account) external view returns (uint256); \r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n    \r\n}\r\n\r\ninterface ILeedoERC20 {\r\n    function claims(uint _season, uint _tokenId) external view returns (bool);\r\n    function claimBlocksRequired() external view returns (uint);\r\n    function season() external view returns (uint);\r\n}\r\n\r\ninterface ILeedoNftVault {\r\n    function ownerOf(uint tokenId) external view returns (address owner);\r\n    function lastBlocks(address addr) external view returns (uint black);\r\n    function tokensOf(address _account) external view returns (uint[] memory);\r\n}\r\n\r\n\r\ncontract NftOwner {\r\n    \r\n    address public nftAddr;\r\n    address public nftVaultAddr;\r\n    address public erc20Addr;\r\n    \r\n\r\n    constructor(address _nftAddr, address _nftVaultAddr, address _erc20Addr) {\r\n        nftAddr = _nftAddr;\r\n        nftVaultAddr = _nftVaultAddr;\r\n        erc20Addr = _erc20Addr;\r\n    }\r\n    \r\n    function ownerOf(uint _tokenId) external view returns (address) {\r\n        INft NFT = INft(nftAddr);\r\n        if (NFT.ownerOf(_tokenId) == nftVaultAddr) {\r\n            INft Vault = INft(nftVaultAddr);\r\n            return Vault.ownerOf(_tokenId);\r\n        } else {\r\n            return NFT.ownerOf(_tokenId);\r\n        }\r\n    }\r\n\r\n    function tokensOf(address _account, bool staked) external view returns (uint[] memory) {\r\n        if(staked) {\r\n            return INft(nftVaultAddr).tokensOf(_account);\r\n        } else {\r\n            INft nft = INft(nftAddr);\r\n            uint count = nft.balanceOf(_account);\r\n            uint[] memory tokenIds = new uint256[] (count);\r\n            for(uint i=0; i < count; i++) {\r\n                tokenIds[i] = nft.tokenOfOwnerByIndex(_account, i);\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n\r\n    function getUnclaims(address _addr) external view returns (uint[] memory) {\r\n        ILeedoNftVault vault = ILeedoNftVault(nftVaultAddr);\r\n        ILeedoERC20 erc20 = ILeedoERC20(erc20Addr);\r\n        //require(vault.lastBlocks(_addr) + erc20.claimBlocksRequired() < block.number, 'ERC20: does not meet claimBlockRequired');\r\n        uint[] memory sTokens = vault.tokensOf(_addr);\r\n        for(uint i=0; i<sTokens.length; i++) {\r\n            if (erc20.claims(erc20.season(), sTokens[i])) {\r\n                delete sTokens[i];\r\n            }\r\n        }\r\n        return sTokens;\r\n    }\r\n}"}}}