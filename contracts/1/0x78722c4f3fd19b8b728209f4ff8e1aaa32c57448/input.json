{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Slipper_cutback.sol":{"content":" // SPDX-License-Identifier: UNLICENCED\n\npragma solidity ^0.7.5;\n\ninterface ERC20 {\n    function balanceOf(address _owner) external view returns (uint256 balance);\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n}\n\n\n\ncontract MrSlipper {\n    \n    receive() external payable {}\n    \n    function withdrawToken(address token) public {\n        uint balance = ERC20(token).balanceOf(address(this));\n        ERC20(token).transfer(msg.sender, balance);\n    }\n    \n    function withdrawETH(uint amt) public {\n        msg.sender.transfer(amt);\n    }\n    \n    uint[] public venues;\n    mapping(uint => address) public venue_selector;\n    \n    // Trading functions ---------------------\n    \n    function trade(uint amount_in, address token_in, address token_out, uint venue) public {\n        address ven = venue_selector[venue];\n        ven.delegatecall(abi.encodeWithSignature(\"execute(uint256,address,address)\", amount_in, token_in, token_out));\n    }\n    \n    function two_leg(uint amount_in, address token_in, address intermediate_token, uint venue1, uint venue2, bool debug) public {\n        uint start = ERC20(token_in).balanceOf(address(this));\n        \n        trade(amount_in, token_in, intermediate_token, venue1);\n        trade(ERC20(intermediate_token).balanceOf(address(this)), intermediate_token, token_in, venue2);\n        \n        if (!debug){\n            require(ERC20(token_in).balanceOf(address(this)) > start, \"Trade not profitable\");\n        }\n    }\n    \n    function three_leg(uint amount_in, address token_in, address intermediate_token1, address intermediate_token2, uint venue1, uint venue2, uint venue3, bool debug) public {\n        uint start = ERC20(token_in).balanceOf(address(this));\n        \n        trade(amount_in, token_in, intermediate_token1, venue1);\n        trade(ERC20(intermediate_token1).balanceOf(address(this)), intermediate_token1, intermediate_token2, venue2);\n        trade(ERC20(intermediate_token2).balanceOf(address(this)), intermediate_token2, token_in, venue3);\n        \n        if (!debug){\n            require(ERC20(token_in).balanceOf(address(this)) > start, \"Trade not profitable\");\n        }\n    }\n    \n    // Venue functions ---------------------\n\n    function addVenueWrapper(uint index, address address_) public {\n        ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).approve(address_, 1e77);\n        ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F).approve(address_, 1e77);\n        // Assign each venue a unique index. Indices can be overwritten. \n        venue_selector[index] = address_;\n        venues.push(index);\n    }\n    \n    \n\n}\n\n\n\n\n\n"}}}