{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DSA_test/oasis.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface OasisInterface {\n    function getMinSell(TokenInterface pay_gem) external view returns (uint);\n    function getBuyAmount(address dest, address src, uint srcAmt) external view returns(uint);\n\tfunction getPayAmount(address src, address dest, uint destAmt) external view returns (uint);\n\tfunction sellAllAmount(\n        address src,\n        uint srcAmt,\n        address dest,\n        uint minDest\n    ) external returns (uint destAmt);\n\tfunction buyAllAmount(\n        address dest,\n        uint destAmt,\n        address src,\n        uint maxSrc\n    ) external returns (uint srcAmt);\n\n    function getBestOffer(TokenInterface sell_gem, TokenInterface buy_gem) external view returns(uint);\n}\n\ninterface TokenInterface {\n    function allowance(address, address) external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n    function decimals() external view returns (uint);\n    function approve(address, uint) external;\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    function deposit() external payable;\n    function withdraw(uint) external;\n}\n\ninterface AccountInterface {\n    function isAuth(address _user) external view returns (bool);\n}\n\ninterface MemoryInterface {\n    function getUint(uint _id) external returns (uint _num);\n    function setUint(uint _id, uint _val) external;\n}\n\ninterface EventInterface {\n    function emitEvent(uint _connectorType, uint _connectorID, bytes32 _eventCode, bytes calldata _eventData) external;\n}\n\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n}\n\n\ncontract Helpers is DSMath {\n    /**\n     * @dev Return ethereum address\n     */\n    function getAddressETH() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\n    }\n\n    /**\n     * @dev Return Memory Variable Address\n     */\n    function getMemoryAddr() internal pure returns (address) {\n        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\n    }\n\n    /**\n     * @dev Return InstaEvent Address.\n     */\n    function getEventAddr() internal pure returns (address) {\n        return 0x2af7ea6Cb911035f3eb1ED895Cb6692C39ecbA97; // InstaEvent Address\n    }\n\n    /**\n     * @dev Get Uint value from InstaMemory Contract.\n    */\n    function getUint(uint getId, uint val) internal returns (uint returnVal) {\n        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\n    }\n\n    /**\n     * @dev Set Uint value in InstaMemory Contract.\n    */\n    function setUint(uint setId, uint val) internal {\n        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\n    }\n\n    /**\n     * @dev Connector Details\n    */\n    function connectorID() public pure returns(uint _type, uint _id) {\n        (_type, _id) = (1, 11);\n    }\n}\n\n\ncontract OasisHelpers is Helpers {\n    /**\n     * @dev Return WETH address\n     */\n    function getAddressWETH() internal pure returns (address) {\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    }\n\n    /**\n     * @dev Return Oasis Address\n     */\n    function getOasisAddr() internal pure returns (address) {\n        return 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n    }\n\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = (_amt / 10 ** (18 - _dec));\n    }\n\n    function changeEthAddress(address buy, address sell) internal pure returns(TokenInterface _buy, TokenInterface _sell){\n        _buy = buy == getAddressETH() ? TokenInterface(getAddressWETH()) : TokenInterface(buy);\n        _sell = sell == getAddressETH() ? TokenInterface(getAddressWETH()) : TokenInterface(sell);\n    }\n\n    function convertEthToWeth(TokenInterface token, uint amount) internal {\n        if(address(token) == getAddressWETH()) token.deposit.value(amount)();\n    }\n\n    function convertWethToEth(TokenInterface token, uint amount) internal {\n       if(address(token) == getAddressWETH()) {\n            token.approve(getAddressWETH(), amount);\n            token.withdraw(amount);\n        }\n    }\n    \n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = mul(_amt, 10 ** (18 - _dec));\n    }\n}\n\n\ncontract OasisResolver is OasisHelpers {\n    event LogBuy(\n        address indexed buyToken,\n        address indexed sellToken,\n        uint256 buyAmt,\n        uint256 sellAmt,\n        uint256 getId,\n        uint256 setId\n    );\n\n    event LogSell(\n        address indexed buyToken,\n        address indexed sellToken,\n        uint256 buyAmt,\n        uint256 sellAmt,\n        uint256 getId,\n        uint256 setId\n    );\n\n    /**\n     * @dev Buy ETH/ERC20_Token.\n     * @param buyAddr buying token address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param sellAddr selling token amount.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param buyAmt buying token amount.\n     * @param unitAmt unit amount of sellAmt/buyAmt with slippage.\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\n    */\n    function buy(\n        address buyAddr,\n        address sellAddr,\n        uint buyAmt,\n        uint unitAmt,\n        uint getId,\n        uint setId\n    ) external payable {\n        uint _buyAmt = buyAmt;\n        (TokenInterface _buyAddr, TokenInterface _sellAddr) = changeEthAddress(buyAddr, sellAddr);\n\n        uint _buyAmt18 = convertTo18(_buyAddr.decimals(), _buyAmt);\n        uint _slippageAmt = convert18ToDec(_sellAddr.decimals(), wmul(unitAmt, _buyAmt18));\n\n        \n        OasisInterface oasisContract = OasisInterface(getOasisAddr());\n\n        require(oasisContract.getBestOffer(_sellAddr, _buyAddr) != 0, \"no-offer\");\n        require(oasisContract.getMinSell(_sellAddr) <= _slippageAmt, \"less-than-min-pay-amt\");\n\n        uint _expectedAmt = oasisContract.getPayAmount(address(_sellAddr), address(_buyAddr), _buyAmt);\n        require(_slippageAmt >= _expectedAmt, \"Too much slippage\");\n\n        convertEthToWeth(_sellAddr, _expectedAmt);\n        _sellAddr.approve(getOasisAddr(), _expectedAmt);\n        _sellAddr.transferFrom(msg.sender, address(this), _expectedAmt);\n        uint _sellAmt = oasisContract.buyAllAmount(\n            address(_buyAddr),\n            _buyAmt,\n            address(_sellAddr),\n            _slippageAmt\n        );\n\n        convertWethToEth(_buyAddr, _buyAmt);\n\n        emit LogBuy(buyAddr, sellAddr, _buyAmt, _sellAmt, getId, setId);\n    }\n\n    /**\n     * @dev Sell ETH/ERC20_Token.\n     * @param buyAddr buying token address.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param sellAddr selling token amount.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param sellAmt selling token amount.\n     * @param unitAmt unit amount of buyAmt/sellAmt with slippage.\n     * @param getId Get token amount at this ID from `InstaMemory` Contract.\n     * @param setId Set token amount at this ID in `InstaMemory` Contract.\n    */\n    function sell(\n        address buyAddr,\n        address sellAddr,\n        uint sellAmt,\n        uint unitAmt,\n        uint getId,\n        uint setId\n    ) external payable {\n        uint _sellAmt = (sellAmt);\n        (TokenInterface _buyAddr, TokenInterface _sellAddr) = changeEthAddress(buyAddr, sellAddr);\n\n        if (_sellAmt == uint(-1)) {\n            _sellAmt = sellAddr == getAddressETH() ? address(this).balance : _sellAddr.balanceOf(address(this));\n        }\n\n        uint _sellAmt18 = convertTo18(_sellAddr.decimals(), _sellAmt);\n        uint _slippageAmt = convert18ToDec(_buyAddr.decimals(), wmul(unitAmt, _sellAmt18));\n\n        OasisInterface oasisContract = OasisInterface(getOasisAddr());\n\n        require(oasisContract.getBestOffer(_sellAddr, _buyAddr) != 0, \"no-offer\");\n        require(oasisContract.getMinSell(_sellAddr) <= _sellAmt, \"less-than-min-pay-amt\");\n\n        uint _expectedAmt = oasisContract.getBuyAmount(address(_buyAddr), address(_sellAddr), _sellAmt);\n        require(_slippageAmt <= _expectedAmt, \"Too much slippage\");\n\n        convertEthToWeth(_sellAddr, _sellAmt);\n        _sellAddr.approve(getOasisAddr(), _sellAmt);\n        _sellAddr.transferFrom(msg.sender, address(this), _sellAmt);\n        uint _buyAmt = oasisContract.sellAllAmount(\n            address(_sellAddr),\n            _sellAmt,\n            address(_buyAddr),\n           _slippageAmt\n        );\n\n        convertWethToEth(_buyAddr, _buyAmt);\n\n\n        emit LogSell(buyAddr, sellAddr, _buyAmt, _sellAmt, getId, setId);\n    }\n}\n\n\ncontract ConnectOasis is OasisResolver {\n    string public name = \"Oasis-v1.1\";\n}"}}}