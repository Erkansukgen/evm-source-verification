{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/gists/8a173a65099261582a652ba18b7d96c1/APIConsumer.sol":{"content":"pragma solidity ^0.6.0;\r\n\r\nimport \"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/ChainlinkClient.sol\";\r\n\r\n// SPDX-License-Identifier: No License\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    \r\n\r\n    struct Set {\r\n       \r\n        bytes32[] _values;\r\n \r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n \r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n             \r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n             \r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n          \r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n             set._values[toDeleteIndex] = lastvalue;\r\n             set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            set._values.pop();\r\n\r\n              delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    \r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n     \r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   \r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    \r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n \r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n   \r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    \r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n   \r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n \r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n \r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    \r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n   \r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n     \r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n     \r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   \r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n \r\n  \r\n\r\ninterface Token {\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function transfer(address, uint) external returns (bool);\r\n}\r\n\r\ncontract PRDZprediction is ChainlinkClient {\r\n    using SafeMath for uint;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n     address public owner;\r\n    \r\n    uint256 public volume;\r\n    bytes32 public lastRequest ;\r\n    \r\n    \r\n    \r\n    address private oracle;\r\n    bytes32 private jobId;\r\n    uint256 private fee;\r\n    \r\n    \r\n\r\n    /*\r\n    participanta[i] = [\r\n        1 => amount staked,\r\n        2 => result time,\r\n        3 => prediction time,\r\n        4 => value predicted at,\r\n        5 => value result,\r\n        6 => market type 1 => Half-hour , 2 => hour , 3 => daily\r\n        7 => prediction type  0 => Down, 1 => up ,\r\n        8 => result , 0 => Pending , 2 => Lost, 1 => Won, 3 => Withdrawn\r\n        9 => Exists      \r\n    ]\r\n    */\r\n\r\n    // PRDZ token contract address\r\n    address public constant tokenAddress = 0x4e085036A1b732cBe4FfB1C12ddfDd87E7C3664d;\r\n    address public constant lossPool = 0x639d0AFE157Fbb367084fc4b5c887725112148F9; \r\n  \r\n    \r\n    // mapping(address => uint[]) internal participants;\r\n    \r\n    struct Prediction {\r\n        address user;\r\n        uint betAmount;\r\n        uint resultTime;\r\n        uint betTime;\r\n        uint256 valuePredictedAt;\r\n        uint valueResult;\r\n        uint marketType;\r\n        uint predictionType;\r\n        uint result;       \r\n        bool exists;\r\n    }\r\n    \r\n\r\n    mapping(bytes32 => Prediction)  predictions;\r\n    \r\n    mapping(uint => uint)  predictValue;\r\n    mapping(bytes32 => bytes32)  tempResultArray;\r\n    \r\n    \r\n    mapping (address => uint) public totalEarnedTokens;\r\n    mapping (address => uint) public totalClaimedTokens;\r\n    mapping (address => uint) public totalAvailableRewards;\r\n    mapping (address => uint) public totalPoints;\r\n    mapping (address => uint) public totalStaked;\r\n\r\n    \r\n    \r\n     \r\n    mapping (uint => uint) public resultValue;\r\n\r\n    uint public totalClaimedRewards = 0;\r\n    uint public payoutPercentage = 6500 ;\r\n    uint public expresultime = 24 hours;\r\n    uint public maximumToken = 5e18 ; \r\n    uint public minimumToken = 1e17 ; \r\n    \r\n    uint public scorePrdzEq = 50 ;\r\n    uint public contractBalance = 0;\r\n\r\n    bytes32[] public matches;\r\n    bytes32[] public pendingMatches;\r\n    \r\n\r\n\r\n     \r\n    constructor() public {\r\n        setPublicChainlinkToken();\r\n        oracle = 0xF5a3d443FccD7eE567000E43B23b0e98d96445CE;\r\n\t    jobId = \"35167569e99342f28bb651f71ce9ab32\";\r\n        fee = 0.1 * 10 ** 18; // 0.1 LINK\r\n        owner = msg.sender;\r\n\r\n    }\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  event PredictionMade(address indexed user, bytes32 matchid);\r\n  event PointsEarned(address indexed user, uint indexed time ,  uint score);\r\n  \r\n  event RewardsTransferred(address indexed user, uint amount);\r\n  event ResultDeclared(address indexed user, bytes32 matchID);\r\n    \r\n \r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n \r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n    \r\n     \r\n    function append(string memory a, string memory b, string memory c, string memory d) internal pure returns (string memory) {\r\n\r\n            return string(abi.encodePacked(a, b, c, d));\r\n\r\n    }\r\n    \r\n    function prepareUrl(uint resultTime) public pure returns (string memory) \r\n    {\r\n       string memory url = append('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&startTime=' ,  uint2str(resultTime*1000) , '&endTime=' ,  uint2str(resultTime*1000));\r\n       return url ;\r\n    }\r\n\r\n    \r\n    function getCurrentPrice() internal returns (bytes32 requestId) \r\n    {\r\n        Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.ratefulfill.selector);\r\n\r\n        // Set the URL to perform the GET request on\r\n        request.add(\"get\", 'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT');\r\n        \r\n\r\n        request.add(\"path\", \"price\");\r\n        \r\n        // Multiply the result by 1000000000000000000 to remove decimals\r\n        int timesAmount = 10**18;\r\n        request.addInt(\"times\", timesAmount);\r\n        \r\n        // Sends the request\r\n        return sendChainlinkRequestTo(oracle, request, fee);\r\n    }\r\n\r\n\r\n    \r\n    function checkresultData(uint256 resultTime) internal returns (bytes32 requestId) \r\n    {\r\n        Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);\r\n        string memory url = append('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&startTime=' , uint2str(resultTime*1000) , '&endTime=' ,  uint2str(resultTime*1000));\r\n        \r\n        // Set the URL to perform the GET request on\r\n        request.add(\"get\", url);\r\n         \r\n\r\n        request.add(\"path\", \"0.1\");\r\n        \r\n        // Multiply the result by 1000000000000000000 to remove decimals\r\n        int timesAmount = 10**18;\r\n        request.addInt(\"times\", timesAmount);\r\n        \r\n        // Sends the request\r\n        return sendChainlinkRequestTo(oracle, request, fee);\r\n    }\r\n\r\n    \r\n    /**\r\n     * Receive the response in the form of uint256\r\n     */ \r\n    function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId)\r\n    {\r\n        bytes32 singlematch = tempResultArray[_requestId] ;\r\n        declareresult(_volume , singlematch);\r\n         \r\n    }\r\n    \r\n     function ratefulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId)\r\n    {\r\n        volume = _volume;\r\n        lastRequest = _requestId;\r\n        Prediction storage eachparticipant = predictions[_requestId];\r\n         if(eachparticipant.valuePredictedAt  == 0  ){\r\n                eachparticipant.valuePredictedAt = _volume ;        \r\n         }\r\n    }\r\n    \r\n    \r\n  \r\n    \r\n   function getallmatches() view public  returns (bytes32[] memory){\r\n       return matches;\r\n   }\r\n    \r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n    if (_i == 0) {\r\n        return \"0\";\r\n    }\r\n    uint j = _i;\r\n    uint len;\r\n    while (j != 0) {\r\n        len++;\r\n        j /= 10;\r\n    }\r\n    bytes memory bstr = new bytes(len);\r\n    uint k = len - 1;\r\n    while (_i != 0) {\r\n        bstr[k--] = byte(uint8(48 + _i % 10));\r\n        _i /= 10;\r\n    }\r\n    return string(bstr);\r\n}\r\n\r\n    function predict(uint amountToPredict, uint resultTime, uint predictionType , uint marketType) public returns (uint)  {\r\n        require(amountToPredict >= minimumToken && amountToPredict <= maximumToken, \"Cannot predict with Tokens lower than minimum token or higher than maximum tokens\");\r\n        require(resultTime > now, \"Cannot predict at the time of result\");\r\n        require(Token(tokenAddress).transferFrom(msg.sender, address(this), amountToPredict), \"Insufficient Token Allowance\");\r\n        \r\n        \r\n        bytes32 matchID = getCurrentPrice();\r\n\r\n        require(predictions[matchID].exists !=  true  , \"Match already Exists\" );\r\n\r\n        Prediction storage newprediction = predictions[matchID];\r\n        newprediction.user =  msg.sender;\r\n        newprediction.betAmount =  amountToPredict; \r\n        newprediction.resultTime =  resultTime ;\r\n        newprediction.betTime =  now; \r\n        newprediction.valuePredictedAt =  0 ;\r\n        newprediction.valueResult =  0 ;\r\n        newprediction.marketType =  marketType ;\r\n        \r\n        newprediction.predictionType =  predictionType ;\r\n        newprediction.result =  0 ;\r\n        newprediction.exists =  true ;\r\n         \r\n        matches.push(matchID) ;\r\n        pendingMatches.push(matchID) ;\r\n         \r\n\r\n        totalPoints[msg.sender] = totalPoints[msg.sender].add(amountToPredict.mul(scorePrdzEq).div(1e18));\r\n        emit PointsEarned(msg.sender, now , amountToPredict.mul(scorePrdzEq).div(1e18));\r\n\r\n        totalStaked[msg.sender] =  totalStaked[msg.sender].add(amountToPredict) ;\r\n        emit PredictionMade(msg.sender, matchID);\r\n\r\n\r\n\r\n    }\r\n    \r\n    function declareresult(uint curMarketValue , bytes32 matchID  ) internal  returns (bool)   {\r\n\r\n\r\n                Prediction storage eachparticipant = predictions[matchID];\r\n\r\n                    if(eachparticipant.resultTime <= now && eachparticipant.result == 0 ){\r\n\r\n                        /* When User Predicted Up && Result is Up */\r\n                            if(eachparticipant.valuePredictedAt  < curMarketValue && eachparticipant.predictionType  == 1  ){\r\n                                eachparticipant.result  = 1 ;\r\n                                eachparticipant.valueResult  = curMarketValue ;\r\n                                uint reward = eachparticipant.betAmount.mul(payoutPercentage).div(1e4);\r\n                                totalEarnedTokens[eachparticipant.user] = totalEarnedTokens[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\r\n                                \r\n                                totalAvailableRewards[eachparticipant.user] = totalAvailableRewards[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\r\n                            }\r\n\r\n                        /* When User Predicted Up && Result is Down */\r\n                            if(eachparticipant.valuePredictedAt  > curMarketValue && eachparticipant.predictionType  == 1  ){\r\n                                eachparticipant.result  = 2 ;\r\n                                eachparticipant.valueResult  = curMarketValue ;\r\n                                Token(tokenAddress).transfer(lossPool, eachparticipant.betAmount);\r\n\r\n                            }\r\n\r\n                        /* When User Predicted Down && Result is Up */\r\n                            if(eachparticipant.valuePredictedAt  < curMarketValue && eachparticipant.predictionType  == 0  ){\r\n                                eachparticipant.result  = 2 ;\r\n                                eachparticipant.valueResult  = curMarketValue ;\r\n                                Token(tokenAddress).transfer(lossPool, eachparticipant.betAmount);\r\n\r\n                            }\r\n\r\n                        /* When User Predicted Down && Result is Down */\r\n                            if(eachparticipant.valuePredictedAt  > curMarketValue && eachparticipant.predictionType  == 0  ){\r\n                                eachparticipant.result  = 1 ;\r\n                                eachparticipant.valueResult  = curMarketValue ;\r\n                                uint reward = eachparticipant.betAmount.mul(payoutPercentage).div(1e4);\r\n                                totalEarnedTokens[eachparticipant.user] = totalEarnedTokens[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\r\n                                totalAvailableRewards[eachparticipant.user] = totalAvailableRewards[eachparticipant.user].add(eachparticipant.betAmount).add(reward);\r\n\r\n\r\n                            }\r\n\r\n            emit ResultDeclared(msg.sender, matchID);\r\n\r\n                   \r\n            }\r\n             \r\n           \r\n            return true ;\r\n\r\n        }\r\n\r\n\r\n        function getmatchBasic(bytes32  _matchID ) view public returns (address , uint , uint , uint   ) {\r\n                    return (predictions[_matchID].user , predictions[_matchID].betAmount , predictions[_matchID].resultTime , predictions[_matchID].betTime  );\r\n        }\r\n\r\n        function getmatchAdv(bytes32  _matchID ) view public returns ( uint , uint , uint , uint , uint  , bool  ) {\r\n                    return ( predictions[_matchID].marketType, predictions[_matchID].valuePredictedAt, predictions[_matchID].valueResult, predictions[_matchID].predictionType , predictions[_matchID].result  , predictions[_matchID].exists );\r\n        }\r\n\r\n        \r\n        \r\n    function executeResultDeclaration() \r\n        public \r\n         \r\n        returns (bool) {\r\n         \r\n        \r\n        uint length = pendingMatches.length  ; \r\n\r\n        uint startIndex = 0 ;\r\n        \r\n        \r\n        \r\n        for (uint i = startIndex; i < length; i++ ) {\r\n            bytes32 singlematch = pendingMatches[i];\r\n            if(predictions[singlematch].result == 0 && predictions[singlematch].valuePredictedAt > 0 &&  predictions[singlematch].resultTime < now){\r\n                bytes32 _req = checkresultData(predictions[singlematch].resultTime) ;\r\n                    tempResultArray[_req] =  singlematch ;\r\n            }\r\n            \r\n        }\r\n        \r\n         return true ;\r\n    }\r\n\r\n\r\n    function withdrawNotExecutedResult(bytes32  _matchID) \r\n        public \r\n         \r\n        returns (bool) {\r\n         \r\n        if(predictions[_matchID].result == 0 && predictions[_matchID].user == msg.sender && now.sub(predictions[_matchID].resultTime) > expresultime){\r\n             Prediction storage eachparticipant = predictions[_matchID];\r\n             eachparticipant.result =  3 ;\r\n            Token(tokenAddress).transfer(predictions[_matchID].user, predictions[_matchID].betAmount);\r\n        }\r\n        \r\n         return true ;\r\n    }\r\n\r\n  function addContractBalance(uint amount) public {\r\n        require(Token(tokenAddress).transferFrom(msg.sender, address(this), amount), \"Cannot add balance!\");\r\n        contractBalance = contractBalance.add(amount);\r\n    }\r\n\r\n      function updateMaximum(uint  amount) \r\n        public \r\n         onlyOwner\r\n        returns (bool) {\r\n         maximumToken = amount;\r\n        \r\n         return true ;\r\n    }\r\n\r\n     function updateMinimum(uint  amount) \r\n        public \r\n         onlyOwner\r\n        returns (bool) {\r\n         minimumToken = amount;\r\n        \r\n         return true ;\r\n    }\r\n\r\n    \r\n\r\n    function updatePayout(uint  percentage) \r\n        public \r\n         onlyOwner\r\n        returns (bool) {\r\n         payoutPercentage = percentage;\r\n        \r\n         return true ;\r\n    }\r\n\r\nfunction updateScoreEq(uint  prdzeq) \r\n        public \r\n         onlyOwner\r\n        returns (bool) {\r\n         scorePrdzEq = prdzeq;\r\n        \r\n         return true ;\r\n    }\r\n\r\n\r\n\r\n \r\n\r\n\r\n    function updateAccount(address account) private {\r\n        uint pendingDivs = totalAvailableRewards[account];\r\n        if (pendingDivs > 0 && contractBalance > 0) {\r\n            require(Token(tokenAddress).transfer(account, pendingDivs), \"Could not transfer tokens.\");\r\n            totalClaimedTokens[account] = totalClaimedTokens[account].add(pendingDivs);\r\n            contractBalance = contractBalance.sub(pendingDivs);\r\n            totalAvailableRewards[account] = 0 ;\r\n            totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\r\n            emit RewardsTransferred(account, pendingDivs);\r\n        }\r\n      \r\n          \r\n    }\r\n    \r\n         \r\n    function claimDivs() public {\r\n        updateAccount(msg.sender);\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n   \r\n}"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/Chainlink.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport { CBORChainlink } from \"./vendor/CBORChainlink.sol\";\nimport { BufferChainlink } from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param _id The Job Specification ID\n   * @param _callbackAddress The callback address\n   * @param _callbackFunction The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 _id,\n    address _callbackAddress,\n    bytes4 _callbackFunction\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = _id;\n    self.callbackAddress = _callbackAddress;\n    self.callbackFunctionId = _callbackFunction;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param _data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory _data)\n    internal pure\n  {\n    BufferChainlink.init(self.buf, _data.length);\n    BufferChainlink.append(self.buf, _data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _value The string value to add\n   */\n  function add(Request memory self, string memory _key, string memory _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeString(_value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _value The bytes value to add\n   */\n  function addBytes(Request memory self, string memory _key, bytes memory _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeBytes(_value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _value The int256 value to add\n   */\n  function addInt(Request memory self, string memory _key, int256 _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeInt(_value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _value The uint256 value to add\n   */\n  function addUint(Request memory self, string memory _key, uint256 _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeUInt(_value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _values The array of string values to add\n   */\n  function addStringArray(Request memory self, string memory _key, string[] memory _values)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < _values.length; i++) {\n      self.buf.encodeString(_values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/ChainlinkClient.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport { ENSResolver as ENSResolver_Chainlink } from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\ncontract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 constant internal LINK = 10**18;\n  uint256 constant private AMOUNT_OVERRIDE = 0;\n  address constant private SENDER_OVERRIDE = address(0);\n  uint256 constant private ARGS_VERSION = 1;\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private ens;\n  bytes32 private ensNode;\n  LinkTokenInterface private link;\n  ChainlinkRequestInterface private oracle;\n  uint256 private requestCount = 1;\n  mapping(bytes32 => address) private pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param _specId The Job Specification ID that the request will be created for\n   * @param _callbackAddress The callback address that the response will be sent to\n   * @param _callbackFunctionSignature The callback function signature to use for the callback address\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 _specId,\n    address _callbackAddress,\n    bytes4 _callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param _req The initialized Chainlink Request\n   * @param _payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory _req, uint256 _payment)\n    internal\n    returns (bytes32)\n  {\n    return sendChainlinkRequestTo(address(oracle), _req, _payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param _oracle The address of the oracle for the request\n   * @param _req The initialized Chainlink Request\n   * @param _payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(address _oracle, Chainlink.Request memory _req, uint256 _payment)\n    internal\n    returns (bytes32 requestId)\n  {\n    requestId = keccak256(abi.encodePacked(this, requestCount));\n    _req.nonce = requestCount;\n    pendingRequests[requestId] = _oracle;\n    emit ChainlinkRequested(requestId);\n    require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), \"unable to transferAndCall to oracle\");\n    requestCount += 1;\n\n    return requestId;\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param _requestId The request ID\n   * @param _payment The amount of LINK sent for the request\n   * @param _callbackFunc The callback function specified for the request\n   * @param _expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    bytes4 _callbackFunc,\n    uint256 _expiration\n  )\n    internal\n  {\n    ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]);\n    delete pendingRequests[_requestId];\n    emit ChainlinkCancelled(_requestId);\n    requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration);\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param _oracle The address of the oracle contract\n   */\n  function setChainlinkOracle(address _oracle) internal {\n    oracle = ChainlinkRequestInterface(_oracle);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param _link The address of the LINK token contract\n   */\n  function setChainlinkToken(address _link) internal {\n    link = LinkTokenInterface(_link);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress()\n    internal\n    view\n    returns (address)\n  {\n    return address(link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress()\n    internal\n    view\n    returns (address)\n  {\n    return address(oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param _oracle The address of the oracle contract that will fulfill the request\n   * @param _requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address _oracle, bytes32 _requestId)\n    internal\n    notPendingRequest(_requestId)\n  {\n    pendingRequests[_requestId] = _oracle;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param _ens The address of the ENS contract\n   * @param _node The ENS node hash\n   */\n  function useChainlinkWithENS(address _ens, bytes32 _node)\n    internal\n  {\n    ens = ENSInterface(_ens);\n    ensNode = _node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS()\n    internal\n  {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Encodes the request to be sent to the oracle contract\n   * @dev The Chainlink node expects values to be in order for the request to be picked up. Order of types\n   * will be validated in the oracle contract.\n   * @param _req The initialized Chainlink Request\n   * @return The bytes payload for the `transferAndCall` method\n   */\n  function encodeRequest(Chainlink.Request memory _req)\n    private\n    view\n    returns (bytes memory)\n  {\n    return abi.encodeWithSelector(\n      oracle.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      _req.id,\n      _req.callbackAddress,\n      _req.callbackFunctionId,\n      _req.nonce,\n      ARGS_VERSION,\n      _req.buf.buf);\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param _requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 _requestId)\n    internal\n    recordChainlinkFulfillment(_requestId)\n    // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param _requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 _requestId) {\n    require(msg.sender == pendingRequests[_requestId],\n            \"Source must be the oracle of the request\");\n    delete pendingRequests[_requestId];\n    emit ChainlinkFulfilled(_requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param _requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 _requestId) {\n    require(pendingRequests[_requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/interfaces/ChainlinkRequestInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/interfaces/ENSInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface ENSInterface {\n\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n\n  function setSubnodeOwner(bytes32 node, bytes32 label, address _owner) external;\n  function setResolver(bytes32 node, address _resolver) external;\n  function setOwner(bytes32 node, address _owner) external;\n  function setTTL(bytes32 node, uint64 _ttl) external;\n  function owner(bytes32 node) external view returns (address);\n  function resolver(bytes32 node) external view returns (address);\n  function ttl(bytes32 node) external view returns (uint64);\n\n}\n"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/interfaces/LinkTokenInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/interfaces/PointerInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/vendor/BufferChainlink.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for writing to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary BufferChainlink {\n  /**\n  * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n  *      a capacity. The capacity may be longer than the current value, in\n  *      which case it can be extended without the need to allocate more memory.\n  */\n  struct buffer {\n    bytes buf;\n    uint capacity;\n  }\n\n  /**\n  * @dev Initializes a buffer with an initial capacity.\n  * @param buf The buffer to initialize.\n  * @param capacity The number of bytes of space to allocate the buffer.\n  * @return The buffer, for chaining.\n  */\n  function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n  * @dev Initializes a new buffer from an existing bytes object.\n  *      Changes to the buffer may mutate the original value.\n  * @param b The bytes object to initialize the buffer with.\n  * @return A new buffer.\n  */\n  function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint a, uint b) private pure returns(uint) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n  * @dev Sets buffer length to 0.\n  * @param buf The buffer to truncate.\n  * @return The original buffer, for chaining..\n  */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n  * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The start offset to write to.\n  * @param data The data to append.\n  * @param len The number of bytes to copy.\n  * @return The original buffer, for chaining.\n  */\n  function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint dest;\n    uint src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    uint mask = 256 ** (32 - len) - 1;\n    assembly {\n      let srcpart := and(mload(src), not(mask))\n      let destpart := and(mload(dest), mask)\n      mstore(dest, or(destpart, srcpart))\n    }\n\n    return buf;\n  }\n\n  /**\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @param len The number of bytes to copy.\n  * @return The original buffer, for chaining.\n  */\n  function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n  * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n  *      capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The offset to write the byte at.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n  * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n  *      capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n  * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n  *      exceed the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The offset to write at.\n  * @param data The data to append.\n  * @param len The number of bytes to write (left-aligned).\n  * @return The original buffer, for chaining.\n  */\n  function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint mask = 256 ** len - 1;\n    // Right-align data\n    data = data >> (8 * (32 - len));\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + sizeof(buffer length) + off + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n  * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n  *      capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The offset to write at.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n  * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @return The original buffer, for chhaining.\n  */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n  * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n  * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The offset to write at.\n  * @param data The data to append.\n  * @param len The number of bytes to write (right-aligned).\n  * @return The original buffer, for chaining.\n  */\n  function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint mask = 256 ** len - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n    * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n    * exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer.\n    */\n  function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/vendor/CBORChainlink.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.19 < 0.7.0;\n\nimport { BufferChainlink } from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n    using BufferChainlink for BufferChainlink.buffer;\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    function encodeType(BufferChainlink.buffer memory buf, uint8 major, uint value) private pure {\n        if(value <= 23) {\n            buf.appendUint8(uint8((major << 5) | value));\n        } else if(value <= 0xFF) {\n            buf.appendUint8(uint8((major << 5) | 24));\n            buf.appendInt(value, 1);\n        } else if(value <= 0xFFFF) {\n            buf.appendUint8(uint8((major << 5) | 25));\n            buf.appendInt(value, 2);\n        } else if(value <= 0xFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 26));\n            buf.appendInt(value, 4);\n        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n            buf.appendUint8(uint8((major << 5) | 27));\n            buf.appendInt(value, 8);\n        }\n    }\n\n    function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n        buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n        encodeType(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n        if(value < -0x10000000000000000) {\n            encodeSignedBigNum(buf, value);\n        } else if(value > 0xFFFFFFFFFFFFFFFF) {\n            encodeBigNum(buf, value);\n        } else if(value >= 0) {\n            encodeType(buf, MAJOR_TYPE_INT, uint(value));\n        } else {\n            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n        }\n    }\n\n    function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n        buf.append(value);\n    }\n\n    function encodeBigNum(BufferChainlink.buffer memory buf, int value) internal pure {\n      buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n      encodeBytes(buf, abi.encode(uint(value)));\n    }\n\n    function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n      buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n      encodeBytes(buf, abi.encode(uint(-1 - input)));\n    }\n\n    function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n        buf.append(bytes(value));\n    }\n\n    function startArray(BufferChainlink.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n    }\n\n    function startMap(BufferChainlink.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n    }\n\n    function endSequence(BufferChainlink.buffer memory buf) internal pure {\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n    }\n}\n"},"https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/evm-contracts/src/v0.6/vendor/ENSResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"}}}