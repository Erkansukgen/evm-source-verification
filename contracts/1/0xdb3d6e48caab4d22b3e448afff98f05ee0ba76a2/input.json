{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/gme.sol":{"content":"pragma solidity 0.7.4;\r\n\r\ncontract Token {\r\n\r\n    function balanceOf(address _owner) virtual public returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) virtual public returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) virtual public returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) virtual public view returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n\r\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) override view public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) override public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) override view public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public circulatingSupply;\r\n}\r\n\r\ncontract GME is StandardToken {\r\n    /* Public variables of the token */\r\n\r\n    string public name;                     // GAME-STOP\r\n    uint256 public decimals;                // 18 decimals\r\n    string public symbol;                   // GME\r\n    address payable private owner;          // Contract creator\r\n    uint public totalSupply;                // 60 million tokens possible to be mined, 1.5 million premined for Uniswap\r\n    uint public minimum_contribution;       // Require that at least 0.001 ETH is sent, 0.001 ETH = 1 tick\r\n    uint256 public starting_giveaway;       // Start by giving away 100 GME\r\n    uint256 public halving_tick;            // Halvings occur every 300,000 \"ticks\" (mining events)\r\n    uint256 public halving_number;          // Number of halvings that have occured (starts at 0)\r\n    uint256 public giveaway_count;          // Number of ticks (mining events) that have occured\r\n \r\n    \r\n    // \"Mining\" function\r\n    receive() external payable {\r\n        // Only 32 halvings can occur.\r\n        require(halving_number < 33);\r\n        \r\n        // Only transfer if you send 0.001 ETH or more\r\n        require(msg.value >= minimum_contribution);\r\n        \r\n        // Increment ticks (mining events) in 0.001 ETH increments\r\n        uint256 eth_multiplier = uint(msg.value / minimum_contribution);\r\n        \r\n        \r\n        // Transfer half the ETH to the owner (for exchange listing fees)\r\n        owner.transfer(msg.value / 2);\r\n        \r\n        // If a halving event occurs...\r\n        if(uint(giveaway_count / halving_tick) < uint((giveaway_count + eth_multiplier) / halving_tick)) triggerHalving(eth_multiplier);\r\n        \r\n        // Increment the number of giveaways\r\n        giveaway_count += eth_multiplier;\r\n\r\n        // Calculate the next giveaway amount\r\n        uint256 giveaway_value = (starting_giveaway * ((10**decimals) / (2**halving_number))) * eth_multiplier;\r\n\r\n        // \"Mine\" ZUCC to the sender and increment the circulating supply\r\n        balances[msg.sender] += giveaway_value;\r\n        circulatingSupply += giveaway_value;\r\n        emit Transfer(address(0), msg.sender, giveaway_value);\r\n    }\r\n    \r\n    // Trigger a halving\r\n    function triggerHalving(uint _eth_multiplier) private {\r\n        // Set the halving number (how many halvings have occurred)\r\n        halving_number = uint((giveaway_count + _eth_multiplier) / halving_tick);\r\n        \r\n        // EMIT ETH to the winning miner\r\n        msg.sender.transfer(address(this).balance);\r\n        \r\n    }\r\n\r\n    function calculateReward(uint _sentETH) public view returns (uint256 reward) {\r\n        // Increment ticks (mining events) in 0.001 ETH increments\r\n        uint256 eth_multiplier = uint(_sentETH / minimum_contribution);\r\n        uint256 _halving_number;\r\n        \r\n        // If a halving event occurs...\r\n        if(uint(giveaway_count / halving_tick) < uint((giveaway_count + eth_multiplier) / halving_tick)) _halving_number = uint((giveaway_count + eth_multiplier) / halving_tick);\r\n        \r\n\r\n        // Calculate the next giveaway amount\r\n        return (starting_giveaway * ((10**decimals) / (2**_halving_number))) * eth_multiplier;\r\n    }\r\n\r\n    constructor() {\r\n        totalSupply             = 61500000000000000000000000;       // TOTAL POSSIBLE TOKENS\r\n        minimum_contribution    = 1000000000000000;\r\n        balances[msg.sender]    = 1500000000000000000000000;        // SEND OWNER PREMINE\r\n        circulatingSupply       = 0;\r\n        name                    = \"GAME-STOP\";\r\n        decimals                = 18;\r\n        symbol                  = \"GME\";\r\n        starting_giveaway       = 100;\r\n        owner                   = msg.sender;\r\n        giveaway_count          = 0;\r\n        halving_tick            = 300000;\r\n        halving_number          = 0;\r\n    }\r\n    \r\n}\r\n"}}}