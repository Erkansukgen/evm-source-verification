{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/contracts/DF9T.sol":{"content":"/**\n * @title DF9 Tickets\n * @author @marvin\n * @dev This contract is the first iteration of DF9 market\n */\n\npragma solidity >=0.4.25 <0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./Libraries/math/SafeMath.sol\";\nimport \"./Libraries/utils/Ownable.sol\";\nimport \"./Libraries/utils/Address.sol\";\nimport \"./Libraries/tokens/ERC1155.sol\";\nimport \"./Libraries/tokens/IERC20.sol\";\nimport \"./Libraries/math/BigDiv.sol\";\nimport \"./IMarket.sol\";\nimport \"./Libraries/utils/DateTime.sol\";\nimport \"./Libraries/tokens/SafeERC20.sol\";\n\ninterface DF9 {\n    function redeem(address account, uint256 level, uint256 id, uint256 dividend, bool mintable) external;\n    function syn(address account, uint256[] memory ids, uint256 level) external;\n}\n\ncontract DF9T is ERC1155, IMarket, Ownable, DateTime {\n    using SafeMath for uint256;\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    function genCardID(uint256 prefix) internal view returns (uint256) {\n        // id: (bet + date or level + date)\n        uint256 year = getYear(block.timestamp);\n        uint256 month = getMonth(block.timestamp).mul(100);\n        uint256 day = getDay(block.timestamp);\n        uint256 date = year.mul(1e4).add(month).add(day);\n        return prefix.mul(1e8).add(date);\n    }\n\n    function decodeCardID(uint256 id) internal pure returns (uint256) {\n        // eg: decode id 12345678920201120 to bet 123456789\n        return id.sub(id.mod(1e8)).div(1e8);\n    }\n\n    event MarketSettled(uint256 report, uint256[] payout);\n    event MarketStatusChanged(MarketStatus statusValue);\n\n    event NewBetsGenerated(address indexed account, address indexed token, uint256[] ids, uint256 timestamp, string partner);\n\n    /**\n     * MARKET CONSTANTS\n     */\n\n    /// @dev Global denominator e.g., 1.000% = 1000 & need to be devided by 100000\n    uint256 private constant GLOBAL_DENOMINATOR = 100000;\n\n    /// @dev The factory address that deployed this contract\n    address private factory;\n\n    /// @dev True once initialized through initialize()\n    bool private initialized;\n\n    /// @dev Decimals for option tokens\n    uint8 public decimals = 18;\n\n    ///@dev Market contents (Registered when market is created)\n    bytes32 public hashID;\n    uint256 public startTime;\n    uint256 public endTime;\n    uint256 public reportTime;\n    address public oracle;\n    address public devAddr;\n\n    DF9 public df9;\n    IERC20 public usdt;\n    uint256 public ticketPrice;\n    uint256 public round;\n    uint256 public jackpot;\n    // 5 divs\n    uint256[5] private divs;\n    \n    uint256 private counter;\n\n    enum Tokens {C1, C2, C3, C4, C5, C6, C7, C8, C9}\n\n    struct Bet {\n        uint256 id;\n        Tokens[] tokens;\n        string cardType;\n        uint256 round;\n        uint256 time;\n        address parentToken;\n        string partner;\n    }\n\n    struct UserInfo {\n        Bet[] bets;\n    }\n\n    mapping(address => UserInfo) private userInfo;\n    \n    function getUserInfo(address account) view public returns(UserInfo memory) {\n        return userInfo[account];\n    }\n\n    /**\n     * MARKET STATES MANAGEMENT\n     */\n\n    ///@dev Market status transition management\n    enum MarketStatus {BeforeTrading, Trading, Reporting, Finalized}\n    MarketStatus public marketStatus;\n\n    ///@dev a modifier checks the current market status\n    modifier atMarketStatus(MarketStatus _marketStatus) {\n        require(marketStatus == _marketStatus, \"Not correct marketStatus\");\n        _;\n    }\n\n    ///@dev a modifier manages market transitions\n    modifier marketStatusTransitions() {\n        if (marketStatus == MarketStatus.BeforeTrading && block.timestamp >= startTime) {\n            _nextMarketStatus();\n        }\n        if (marketStatus == MarketStatus.Trading && block.timestamp >= endTime) {\n            _nextMarketStatus();\n        }\n        _;\n    }\n\n    constructor() public {}\n\n    /**\n     * @dev Validate market\n     * This function validates the argument set for initialization.\n     * Can be called before contract deployments.\n     * question = the thesis of the prediction market\n     * conditions[0] = startTime\n     * conditions[1] = endTime\n     * conditions[2] = reportTime\n     * conditions[3] = ticketPrice\n     * conditions[4] = round\n     * references[0] = ERC20 token used as the collateral\n     * references[1] = oracle address settles the market\n     * references[2] = redeemed token\n     */\n    function validate(\n        string memory _settings,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public override view returns (bool) {\n        require(bytes(_settings).length > 10);\n        // require(\n        //     _conditions[1].sub(_conditions[0]) > 1 days &&\n        //         _conditions[1].sub(now) > 1 days &&\n        //         _conditions[2] >= _conditions[1]\n        // );\n        require(_conditions[3] > 0);\n        require(_references[0] != address(0) && _references[1] != address(0) && _references[2] != address(0));\n\n        return true;\n    }\n\n    /**\n     * @dev Initialize market\n     * This function registers market conditions.\n     * arguments are verified by the 'validate' function.\n     */\n    function initialize(\n        string memory _settings,\n        uint256[] memory _conditions,\n        address[] memory _references,\n        string memory metadataBaseURI\n    ) public override returns (bool) {\n        require(\n            validate(\n                _settings,\n                _conditions,\n                _references\n            )\n        );\n\n        require(initialized == false);\n        \n        initialized = true;\n        startTime = _conditions[0];\n        endTime = _conditions[1];\n        reportTime = _conditions[2];\n        ticketPrice = _conditions[3];\n        round = _conditions[4];\n        usdt = IERC20(_references[0]);\n        oracle = _references[1];\n        df9 = DF9(_references[2]);\n        devAddr = _references[3];\n        factory = msg.sender;\n        \n        _setBaseMetadataURI(metadataBaseURI);\n\n        hashID = keccak256(\n            abi.encodePacked(\n                _settings,\n                _conditions,\n                _references\n            )\n        );\n\n        marketStatus = MarketStatus.BeforeTrading;\n        return true;\n    }\n    \n    function setBaseTokenURI(string memory uri) public onlyOwner {\n        _setBaseMetadataURI(uri);\n    }\n\n    function baseTokenURI() internal view returns (string memory) {\n        return baseMetadataURI;\n    }\n    \n    function toString(bytes memory data) public pure returns(string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n    \n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint i = 0; i < data.length; i++) {\n            str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];\n            str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {\n        return string(abi.encodePacked(\n            baseTokenURI(),\n            toString(abi.encodePacked(address(this))),\n            \"/\",\n            _uint2str(_tokenId),\n            \".json\"\n        ));\n    }\n    \n    function placeBets(\n        address account,\n        uint256[] memory bets,\n        uint256 betAmount,\n        string memory _partner\n    ) public   \n     marketStatusTransitions\n     atMarketStatus(MarketStatus.Trading)\n     returns (bool)\n      {\n        require(account != address(0), \"Transfer from the zero address\");\n        require(bets.length > 0, \"Can't place zero bets\");\n        require(betAmount == bets.length.mul(ticketPrice), \"Wrong bet amount\");\n        usdt.safeTransferFrom(\n            address(msg.sender),\n            address(df9),\n            betAmount.mul(90).div(100)\n        );\n        usdt.safeTransferFrom(\n            address(msg.sender),\n            address(devAddr),\n            betAmount.mul(10).div(100)\n        );\n        uint256[] memory ids = new uint256[](bets.length);\n        for (uint256 index = 0; index < bets.length; index++) {\n            require(bytes(_uint2str(bets[index])).length == 9, \"Invalid bet\");\n            \n            uint256 id = genCardID(bets[index]);\n            ids[index] = id;\n            \n            Tokens[] memory tokens = new Tokens[](9);\n            uint256 rem = bets[index];\n            \n            for (uint256 t = 9; t > 0; t--) {\n                if (t > 1) {\n                    uint256 c = rem.sub(rem.mod(10**(t - 1))).div(10**(t-1));\n                    require((c > 0 && c < 10), \"Invalid token index\");\n                    rem = rem.sub(c.mul(10**(t - 1)));\n                    tokens[9 - t] = Tokens(c - 1);\n                } else {\n                    tokens[9 - t] = Tokens(rem - 1);\n                }\n            }\n\n            userInfo[account].bets.push(\n                Bet({\n                    id: id,\n                    tokens: tokens,\n                    cardType: \"DF9T\",\n                    round: round,\n                    time: block.timestamp,\n                    parentToken: address(this),\n                    partner: _partner\n                })\n            );\n            _mint(account, id, 1, \"\");\n        }\n\n        emit NewBetsGenerated(account, address(this), ids, block.timestamp, _partner);\n        return true;\n    }\n\n    function redeem(address account) public atMarketStatus(MarketStatus.Finalized) returns (bool)\n    {\n        require(\n            account != address(0),\n            \"Transfer from the zero address\"\n        );\n        require(userInfo[account].bets.length > 0, \"DF9T: INSUFFICIENT_AMOUNT_OF_BETS\");\n        require(\n            msg.sender == account ||\n                _operatorApprovals[account][msg.sender],\n                \"NOT_ELIGIBLE_TO_REDEEM\"\n        );\n        \n        for (uint256 index = 0; index < userInfo[account].bets.length; index++) {\n            uint256 currentId = userInfo[account].bets[index].id;\n            require(\n                balanceOf(account, currentId) >= 1,\n                \"INSUFFICIENT_AMOUNT\"\n            );\n            _burn(account, currentId, 1);\n            uint256 jRem = jackpot;\n            uint256 rem = decodeCardID(currentId);\n            uint256 level = 9;\n            /// @dev calculate the the prize level\n            for (uint256 t = 9; t > 0; t--) {\n                if (t > 1) {\n                    uint256 c = rem.sub(rem.mod(10**(t - 1))).div(10**(t-1));\n                    uint256 j = jRem.sub(jRem.mod(10**(t - 1))).div(10**(t-1));\n                    require((c > 0 && c < 10), \"Invalid token index\");\n                    rem = rem.sub(c.mul(10**(t - 1)));\n                    jRem = jRem.sub(j.mul(10**(t - 1)));\n                    if (j == c) level = level.sub(1);\n                } else if (rem == jRem) {\n                    level = level.sub(1);\n                }\n            }            \n\n            uint256 dividend = 0;\n            /// @dev calculate and payout usdt\n            if (level < 6) {\n                // level 0 2 3 4 5 => divs[4 ~ 0], reverse level\n                if (level == 0) {\n                    dividend = divs[4 - level];\n                } else {\n                    dividend = divs[5 - level];\n                }\n                level = 5 - level;\n            } else {\n                // no dividend, set 6~8 level to 0\n                level = 0;\n            }\n            \n            uint256 id = genCardID(level);\n            /// @dev mint DF9\n            df9.redeem(account, level, id, dividend, true);\n        }\n        delete userInfo[account].bets;\n        return true;\n    }\n\n    function pendingDividends(address account) public view returns (uint256) {\n        uint256 dividends = 0;\n        if (marketStatus == MarketStatus.Finalized) {\n            require(userInfo[account].bets.length > 0, \"DF9T: INSUFFICIENT_AMOUNT_OF_BETS\");\n            for (uint8 index = 0; index < userInfo[account].bets.length; index++) {\n                uint256 currentId = userInfo[account].bets[index].id;\n                require(\n                    balanceOf(account, currentId) >= 1,\n                    \"INSUFFICIENT_AMOUNT\"\n                );\n                uint256 jRem = jackpot;\n                uint256 rem = decodeCardID(currentId);\n                uint256 level = 9;\n                for (uint256 t = 9; t > 0; t--) {\n                    if (t > 1) {\n                        uint256 c = rem.sub(rem.mod(10**(t - 1))).div(10**(t-1));\n                        uint256 j = jRem.sub(jRem.mod(10**(t - 1))).div(10**(t-1));\n                        require((c > 0 && c < 10), \"Invalid token index\");\n                        rem = rem.sub(c.mul(10**(t - 1)));\n                        jRem = jRem.sub(j.mul(10**(t - 1)));\n                        if (j == c) level = level.sub(1);\n                    } else if (rem == jRem) {\n                        level = level.sub(1);\n                    }\n                }\n                if (level < 6) {\n                    if (level == 0) {\n                        dividends = dividends.add(divs[4 - level]);\n                    } else {\n                        dividends = dividends.add(divs[5 - level]);\n                    }\n                }\n            }\n        }\n        return dividends;\n    }\n    \n    \n\n    /**\n     * @dev Settle\n     * Registered oracle settles market by reporting payout shares.\n     * _priceList.length should be 5, means 5 level dividends per bet of prize pool\n     */\n    function settle(uint256 _jackpot, uint256[] memory _priceList)\n        external\n        marketStatusTransitions\n        atMarketStatus(MarketStatus.Reporting)\n    {\n        require(msg.sender == oracle, \"UNAUTHORIZED_ORACLE\");\n        \n        jackpot = _jackpot;\n        \n        uint256 usdtBal = usdt.balanceOf(address(df9));\n        uint256 prizePool = usdtBal.div(2);\n\n        for (uint j = 0; j < 5; j++) {\n            divs[j] = BigDiv.bigDiv2x1(\n                prizePool,\n                _priceList[j],\n                100);\n        }\n\n        _nextMarketStatus();\n        \n        emit MarketSettled(jackpot, _priceList);\n    }\n\n    /**\n     * @dev a function to check the factory address\n     */\n    function creator() public override view returns (address) {\n        return factory;\n    }\n\n    /**\n     * @dev Validate market question and outcome lists\n     */\n    function validateHash(\n        string memory _settings,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public override view returns (bool) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                _settings,\n                _conditions,\n                _references\n            )\n        );\n        return (hash == hashID);\n    }\n    \n    function updateMarketStatus() public marketStatusTransitions returns (bool) {\n        return true;\n    }\n\n    function _nextMarketStatus() internal {\n        marketStatus = MarketStatus(uint256(marketStatus) + 1);\n        emit MarketStatusChanged(marketStatus);\n    }\n    \n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override {\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || _operatorApprovals[from][msg.sender] == true,\n            \"ERC1155: need operator approval for 3rd party transfers.\"\n        );\n        require(balanceOf(from, id) >= 1, \"DF9: INSUFFICIENT_AMOUNT\");\n        _safeTransferFrom(from, to, id, value, data);\n        // update userInfo\n        for(uint i = 0; i < value; i++) {\n            for(uint j = 0; j < userInfo[from].bets.length; j++) {\n                if (userInfo[from].bets[j].id == id) {\n                    userInfo[to].bets.push(userInfo[from].bets[j]);\n                    delete userInfo[from].bets[j];\n                    break;\n                }\n            }\n        }\n    }\n    \n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override {\n        require(\n            ids.length == values.length,\n            \"ERC1155: IDs and values must have same lengths\"\n        );\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || _operatorApprovals[from][msg.sender] == true,\n            \"ERC1155: need operator approval for 3rd party transfers.\"\n        );\n        \n        _safeBatchTransferFrom(from, to, ids, values, data);\n        // update userInfo\n        for(uint index = 0; index < ids.length; index++) {\n            // delete from userInfo\n            for(uint i = 0; i < values[index]; i++) {\n                for(uint j = 0; j < userInfo[from].bets.length; j++) {\n                    if (userInfo[from].bets[j].id == ids[index]) {\n                        userInfo[to].bets.push(userInfo[from].bets[j]);\n                        delete userInfo[from].bets[j];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n"},"localhost/contracts/IMarket.sol":{"content":"/**\n * @title IMarket\n * @author @Marvin\n * @dev This contract defines interface for all market models\n */\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nabstract contract IMarket  {\n    /**\n     * @dev Check whether the conditonse are correct for the contract.\n     */\n    function validate(\n        string memory _settings,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public virtual view returns (bool);\n\n    /**\n     * @dev Define constructor functions for the proxy.\n     */\n    function initialize(\n        string memory _settings,\n        uint256[] memory _conditions,\n        address[] memory _references,\n        string memory metadataBaseURI\n    ) public virtual returns (bool);\n\n    /**\n     * @dev Check the creator's address\n     */\n    function creator() external virtual view returns (address);\n\n    /**\n     * @dev Check whethere the market conditions are correct.\n     */\n    function validateHash(\n        string memory _settings,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public virtual view returns (bool);\n}\n"},"localhost/contracts/Libraries/math/BigDiv.sol":{"content":"pragma solidity >=0.4.25 <0.7.0;\n\nimport \"./SafeMath.sol\";\n\n/**\n * @title Reduces the size of terms before multiplication, to avoid an overflow, and then\n * restores the proper size after division.\n * @notice This effectively allows us to overflow values in the numerator and/or denominator\n * of a fraction, so long as the end result does not overflow as well.\n * @dev Results may be off by 1 + 0.000001% for 2x1 calls and 2 + 0.00001% for 2x2 calls.\n * Do not use if your contract expects very small result values to be accurate.\n */\nlibrary BigDiv {\n    using SafeMath for uint256;\n\n    ///@dev @notice The max possible value\n    uint256 private constant MAX_UINT = 2**256 - 1;\n\n    ///@dev @notice When multiplying 2 terms <= this value the result won't overflow\n    uint256 private constant MAX_BEFORE_SQUARE = 2**128 - 1;\n\n    ///@dev @notice The max error target is off by 1 plus up to 0.000001% error\n    /// for bigDiv2x1 and that `* 2` for bigDiv2x2\n    uint256 private constant MAX_ERROR = 100000000;\n\n    ///@dev @notice A larger error threshold to use when multiple rounding errors may apply\n    uint256 private constant MAX_ERROR_BEFORE_DIV = MAX_ERROR * 2;\n\n    /**\n     * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\n     * @param _numA the first numerator term\n     * @param _numB the second numerator term\n     * @param _den the denominator\n     * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\n     */\n    function bigDiv2x1(\n        uint256 _numA,\n        uint256 _numB,\n        uint256 _den\n    ) internal pure returns (uint256) {\n        if (_numA == 0 || _numB == 0) {\n            // would div by 0 or underflow if we don't special case 0\n            return 0;\n        }\n\n        uint256 value;\n\n        if (MAX_UINT / _numA >= _numB) {\n            // a*b does not overflow, return exact math\n            value = _numA * _numB;\n            value /= _den;\n            return value;\n        }\n\n        // Sort numerators\n        uint256 numMax = _numB;\n        uint256 numMin = _numA;\n        if (_numA > _numB) {\n            numMax = _numA;\n            numMin = _numB;\n        }\n\n        value = numMax / _den;\n        if (value > MAX_ERROR) {\n            // _den is small enough to be MAX_ERROR or better w/o a factor\n            value = value.mul(numMin);\n            return value;\n        }\n\n        // formula = ((a / f) * b) / (d / f)\n        // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\n        uint256 factor = numMin - 1;\n        factor /= MAX_BEFORE_SQUARE;\n        factor += 1;\n        uint256 temp = numMax - 1;\n        temp /= MAX_BEFORE_SQUARE;\n        temp += 1;\n        if (MAX_UINT / factor >= temp) {\n            factor *= temp;\n            value = numMax / factor;\n            if (value > MAX_ERROR_BEFORE_DIV) {\n                value = value.mul(numMin);\n                temp = _den - 1;\n                temp /= factor;\n                temp = temp.add(1);\n                value /= temp;\n                return value;\n            }\n        }\n\n        // formula: (a / (d / f)) * (b / f)\n        // factor: b / sqrt(MAX)\n        factor = numMin - 1;\n        factor /= MAX_BEFORE_SQUARE;\n        factor += 1;\n        value = numMin / factor;\n        temp = _den - 1;\n        temp /= factor;\n        temp += 1;\n        temp = numMax / temp;\n        value = value.mul(temp);\n        return value;\n    }\n}\n"},"localhost/contracts/Libraries/math/SafeMath.sol":{"content":"pragma solidity >=0.4.25 <0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"localhost/contracts/Libraries/tokens/ERC1155.sol":{"content":"/**\n * @title Standard ERC1155 token\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n */\n\npragma solidity ^0.6.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155TokenReceiver.sol\";\nimport \"./ERC165.sol\";\nimport \"./ERC1155Metadata.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../utils/Address.sol\";\n\ncontract ERC1155 is ERC165, ERC1155Metadata, IERC1155 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to owner balances\n    mapping(uint256 => mapping(address => uint256)) internal _balances;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n    constructor() public {\n        _registerInterface(\n            ERC1155(0).safeTransferFrom.selector ^\n                ERC1155(0).safeBatchTransferFrom.selector ^\n                ERC1155(0).balanceOf.selector ^\n                ERC1155(0).balanceOfBatch.selector ^\n                ERC1155(0).setApprovalForAll.selector ^\n                ERC1155(0).isApprovedForAll.selector\n        );\n    }\n\n    /**\n        @dev Get the specified address' balance for token with specified ID.\n        @param owner The address of the token holder\n        @param id ID of the token\n        @return The owner's balance of the token type requested\n     */\n    function balanceOf(address owner, uint256 id)\n        public\n        override\n        view\n        returns (uint256)\n    {\n        require(\n            owner != address(0),\n            \"ERC1155: balance query for the zero address\"\n        );\n        return _balances[id][owner];\n    }\n\n    /**\n        @dev Get the balance of multiple account/token pairs\n        @param owners The addresses of the token holders\n        @param ids IDs of the tokens\n        @return Balances for each owner and token id pair\n     */\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\n        public\n        override\n        view\n        returns (uint256[] memory)\n    {\n        require(\n            owners.length == ids.length,\n            \"ERC1155: owners and IDs must have same lengths\"\n        );\n\n        uint256[] memory batchBalances = new uint256[](owners.length);\n\n        for (uint256 i = 0; i < owners.length; ++i) {\n            require(\n                owners[i] != address(0),\n                \"ERC1155: some address in batch balance query is zero\"\n            );\n            batchBalances[i] = _balances[ids[i]][owners[i]];\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address operator, bool approved)\n        external\n        override\n    {\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n        @notice Queries the approval status of an operator for a given owner.\n        @param owner     The owner of the Tokens\n        @param operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address owner, address operator)\n        external\n        override\n        view\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n        @dev Transfers `value` amount of an `id` from the `from` address to the `to` address specified.\n        Caller must be approved to manage the tokens being transferred out of the `from` account.\n        If `to` is a smart contract, will call `onERC1155Received` on `to` and act appropriately.\n        @param from Source address\n        @param to Target address\n        @param id ID of the token type\n        @param value Transfer amount\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external virtual override {\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || _operatorApprovals[from][msg.sender] == true,\n            \"ERC1155: need operator approval for 3rd party transfers.\"\n        );\n\n        _safeTransferFrom(from, to, id, value, data);\n    }\n\n    /**\n        @dev Transfers `values` amount(s) of `ids` from the `from` address to the\n        `to` address specified. Caller must be approved to manage the tokens being\n        transferred out of the `from` account. If `to` is a smart contract, will\n        call `onERC1155BatchReceived` on `to` and act appropriately.\n        @param from Source address\n        @param to Target address\n        @param ids IDs of each token type\n        @param values Transfer amounts per token type\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external virtual override {\n        require(\n            ids.length == values.length,\n            \"ERC1155: IDs and values must have same lengths\"\n        );\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || _operatorApprovals[from][msg.sender] == true,\n            \"ERC1155: need operator approval for 3rd party transfers.\"\n        );\n\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }\n\n    /**\n        @dev Internal function for \"safeTransferFrom\"\n        @param from Source address\n        @param to Target address\n        @param id ID of the token type\n        @param value Transfer amount\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        _balances[id][from] = _balances[id][from].sub(value);\n        _balances[id][to] = value.add(_balances[id][to]);\n\n        emit TransferSingle(msg.sender, from, to, id, value);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);\n    }\n\n    /**\n        @dev Internal function for \"safeBatchTransferFrom\"\n        @param from Source address\n        @param to Target address\n        @param ids IDs of each token type\n        @param values Transfer amounts per token type\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n\n            _balances[id][from] = _balances[id][from].sub(value);\n            _balances[id][to] = value.add(_balances[id][to]);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, values);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            from,\n            to,\n            ids,\n            values,\n            data\n        );\n    }\n\n    /**\n     * @dev Internal function to mint an amount of a token with the given ID\n     * @param to The address that will own the minted token\n     * @param id ID of the token to be minted\n     * @param value Amount of the token to be minted\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _balances[id][to] = value.add(_balances[id][to]);\n        emit TransferSingle(msg.sender, address(0), to, id, value);\n\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            to,\n            id,\n            value,\n            data\n        );\n    }\n\n    /**\n     * @dev Internal function to batch mint amounts of tokens with the given IDs\n     * @param to The address that will own the minted token\n     * @param ids IDs of the tokens to be minted\n     * @param values Amounts of the tokens to be minted\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n     */\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        require(to != address(0), \"ERC1155: batch mint to the zero address\");\n        require(\n            ids.length == values.length,\n            \"ERC1155: IDs and values must have same lengths\"\n        );\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = values[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, values);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            to,\n            ids,\n            values,\n            data\n        );\n    }\n\n    /**\n     * @dev Internal function to burn an amount of a token with the given ID\n     * @param owner Account which owns the token to be burnt\n     * @param id ID of the token to be burnt\n     * @param value Amount of the token to be burnt\n     */\n    function _burn(\n        address owner,\n        uint256 id,\n        uint256 value\n    ) internal {\n        _balances[id][owner] = _balances[id][owner].sub(value);\n        emit TransferSingle(msg.sender, owner, address(0), id, value);\n    }\n\n    /**\n     * @dev Internal function to batch burn an amounts of tokens with the given IDs\n     * @param owner Account which owns the token to be burnt\n     * @param ids IDs of the tokens to be burnt\n     * @param values Amounts of the tokens to be burnt\n     */\n    function _batchBurn(\n        address owner,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal {\n        require(\n            ids.length == values.length,\n            \"ERC1155: IDs and values must have same lengths\"\n        );\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][owner] = _balances[ids[i]][owner].sub(values[i]);\n        }\n\n        emit TransferBatch(msg.sender, owner, address(0), ids, values);\n    }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.isContract()) {\n            try IERC1155TokenReceiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\n                if (response != IERC1155TokenReceiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) internal {\n        if (to.isContract()) {\n            try IERC1155TokenReceiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (bytes4 response) {\n                if (response != IERC1155TokenReceiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n}\n"},"localhost/contracts/Libraries/tokens/ERC1155Metadata.sol":{"content":"/**\n * @notice Contract that handles metadata related methods.\n * @dev Methods assume a deterministic generation of URI based on token IDs.\n *      Methods also assume that URI uses hex representation of token IDs.\n */\npragma solidity ^0.6.0;\n\nimport \"./IERC1155Metadata.sol\";\n\ncontract ERC1155Metadata is IERC1155Metadata {\n\n  // URI's default URI prefix\n  string internal baseMetadataURI;\n  event URI(string _uri, uint256 indexed _id);\n\n\n  /***********************************|\n  |     Metadata Public Function s    |\n  |__________________________________*/\n\n  /**\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n   * @dev URIs are defined in RFC 3986.\n   *      URIs are assumed to be deterministically generated based on token ID\n   *      Token IDs are assumed to be represented in their hex format in URIs\n   * @return URI string\n   */\n  function uri(uint256 _id) public override view returns (string memory) {\n    return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), \".json\"));\n  }\n\n\n  /***********************************|\n  |    Metadata Internal Functions    |\n  |__________________________________*/\n\n  /**\n   * @notice Will emit default URI log event for corresponding token _id\n   * @param _tokenIDs Array of IDs of tokens to log default URI\n   */\n  function _logURIs(uint256[] memory _tokenIDs) internal {\n    string memory baseURL = baseMetadataURI;\n    string memory tokenURI;\n\n    for (uint256 i = 0; i < _tokenIDs.length; i++) {\n      tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), \".json\"));\n      emit URI(tokenURI, _tokenIDs[i]);\n    }\n  }\n\n  /**\n   * @notice Will emit a specific URI log event for corresponding token\n   * @param _tokenIDs IDs of the token corresponding to the _uris logged\n   * @param _URIs    The URIs of the specified _tokenIDs\n   */\n  function _logURIs(uint256[] memory _tokenIDs, string[] memory _URIs) internal {\n    require(_tokenIDs.length == _URIs.length, \"ERC1155Metadata#_logURIs: INVALID_ARRAYS_LENGTH\");\n    for (uint256 i = 0; i < _tokenIDs.length; i++) {\n      emit URI(_URIs[i], _tokenIDs[i]);\n    }\n  }\n\n  /**\n   * @notice Will update the base URL of token's URI\n   * @param _newBaseMetadataURI New base URL of token's URI\n   */\n  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\n    baseMetadataURI = _newBaseMetadataURI;\n  }\n\n\n  /***********************************|\n  |    Utility Internal Functions     |\n  |__________________________________*/\n\n  /**\n   * @notice Convert uint256 to string\n   * @param _i Unsigned integer to convert to string\n   */\n  function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n\n    uint256 j = _i;\n    uint256 ii = _i;\n    uint256 len;\n\n    // Get number of bytes\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n\n    bytes memory bstr = new bytes(len);\n    uint256 k = len - 1;\n\n    // Get each individual ASCII\n    while (ii != 0) {\n      bstr[k--] = byte(uint8(48 + ii % 10));\n      ii /= 10;\n    }\n\n    // Convert to string\n    return string(bstr);\n  }\n\n}"},"localhost/contracts/Libraries/tokens/ERC165.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the `IERC165` interface.\n *\n * Contracts may inherit from this and call `_registerInterface` to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor() internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See `IERC165.supportsInterface`.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        override\n        view\n        returns (bool)\n    {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See `IERC165.supportsInterface`.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"},"localhost/contracts/Libraries/tokens/IERC1155.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n    @title ERC-1155 Multi Token Standard basic interface\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n */\n\nimport \"./IERC165.sol\";\nimport \"./IERC1155Metadata.sol\";\n\nabstract contract IERC1155 is IERC165, IERC1155Metadata {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    event URI(string value, uint256 indexed id);\n\n    function balanceOf(address owner, uint256 id)\n        public\n        virtual\n        view\n        returns (uint256);\n\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\n        public\n        virtual\n        view\n        returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved)\n        external\n        virtual;\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        virtual\n        view\n        returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external virtual;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external virtual;\n}\n"},"localhost/contracts/Libraries/tokens/IERC1155Metadata.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n    @title ERC-1155 Multi Token Metadata Interface\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n*/\n\ninterface IERC1155Metadata {\n\n  event URI(string _uri, uint256 indexed _id);\n  /**\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n   * @dev URIs are defined in RFC 3986.\n   *      URIs are assumed to be deterministically generated based on token ID\n   *      Token IDs are assumed to be represented in their hex format in URIs\n   * @return URI string\n   */\n  function uri(uint256 _id) external view returns (string memory);\n}"},"localhost/contracts/Libraries/tokens/IERC1155TokenReceiver.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n    @title ERC-1155 Multi Token Receiver Interface\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n*/\nimport \"./IERC165.sol\";\n\nabstract contract IERC1155TokenReceiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external virtual returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external virtual returns (bytes4);\n}\n"},"localhost/contracts/Libraries/tokens/IERC165.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others (`ERC165Checker`).\n *\n * For an implementation, see `ERC165`.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"localhost/contracts/Libraries/tokens/IERC20.sol":{"content":"pragma solidity >=0.4.25 <0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"localhost/contracts/Libraries/tokens/SafeERC20.sol":{"content":"pragma solidity >=0.4.25 <0.7.0;\n\nimport \"./IERC20.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"localhost/contracts/Libraries/utils/Address.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * > It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n"},"localhost/contracts/Libraries/utils/DateTime.sol":{"content":"pragma solidity ^0.6.0;\n\ncontract DateTime {\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    \n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    \n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n}"},"localhost/contracts/Libraries/utils/Ownable.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"}}}