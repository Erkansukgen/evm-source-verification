{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/MFS.sol": {
      "content": "pragma solidity ^0.6.6;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     * 返回存在的令牌数量。\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     * 返回`account`拥有的令牌数量。\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     * 将“数量”令牌从呼叫者的帐户移至“收件人”。\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     * 返回一个布尔值，该值指示操作是否成功。\r\n     * Emits a {Transfer} event.\r\n     * 发出{Transfer}事件。\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n    external\r\n    returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     * 返回将允许`spender`通过{transferFrom}代表`owner`使用的令牌剩余数量。默认为零。\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     * 调用{approve}或{transferFrom}时，此值会更改。\r\n     */\r\n    function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     * 将“金额”设置为对调用者令牌的“ spender”配额。\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     * 返回一个布尔值，该值指示操作是否成功。\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     * 发出{Approval}事件\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     * 使用配额机制将“数量”令牌从“发件人”移动到“收件人”。然后从通话者的津贴中扣除“金额”。\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     * 返回一个布尔值，该值指示操作是否成功。\r\n     * Emits a {Transfer} event.\r\n     * 发出{Transfer}事件。\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     * 当“值”令牌从一个帐户（“从”）移动到另一个帐户（“至”）时发出。\r\n     * Note that `value` may be zero.\r\n     * 请注意，“值”可能为零。\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     * 当通过调用{approve}设置“ spender”对“ owner”的许可时发出。 “价值”是新的免税额。\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract MFS is Owned {\r\n    //存款事件 传入(用户地址,存款数量,存款时间)\r\n    event BANK_SAVINGS(address indexed userAddress, uint quantity, uint blockTime);\r\n    //兑换事件 传入(用户地址,存款数量,兑换数量,兑换时间)\r\n    event EXCHANGE(address indexed userAddress, uint quantity, uint exchangeCount, uint blockTime);\r\n\r\n\r\n    //防溢出计算\r\n    using SafeMath for uint;\r\n    //mfs地址(存入代币地址)\r\n    IERC20 private mfsToken;\r\n    //vcmfs地址(兑换出代币地址)\r\n    IERC20 private vcmfsToken;\r\n    //mfs总数\r\n    uint private mfsCount;\r\n    //vcmfs总数\r\n    uint private vcmfsCount;\r\n    //存入上限\r\n    uint private upper_Limit;\r\n    //兑换率(3mfs:1vcmfs)\r\n    uint private exchange;\r\n    //判断\r\n    bool private res;\r\n\r\n    //是否超过上限\r\n    modifier counter{\r\n        require(mfsCount <= upper_Limit, 'MFS:Over limit');\r\n        _;\r\n    }\r\n\r\n    constructor(address mfsAddress, address vcmfsAddress) public {\r\n        //初始化mfs地址\r\n        mfsToken = IERC20(mfsAddress);\r\n        //初始化vcmfs地址\r\n        vcmfsToken = IERC20(vcmfsAddress);\r\n        //初始mfs总数\r\n        mfsCount = 0;\r\n        //初始vcmfs总数\r\n        vcmfsCount = 0;\r\n        //初始可存入上限 6000*1e18\r\n        upper_Limit = 6000000001200000000000;\r\n        //初始兑换率 3\r\n        exchange = 3000000000000000000;\r\n        //交易是否成功初始为false\r\n        res = false;\r\n    }\r\n\r\n    /*\r\n    存款\r\n    传入 数量\r\n    返回 是否成功\r\n    */\r\n    function deposit(uint mfsQuantity) public counter returns (bool){\r\n        (uint _value,uint _vcmfs) =  calculation(mfsQuantity);\r\n        require((((mfsQuantity.mul(10)).div(exchange.div(1e18))).div(10))<_vcmfs,\"MFS:Incoming MFS is greater than VCMFS balance\");\r\n        res = false;\r\n        res = mfsToken.transferFrom(msg.sender, address(this), mfsQuantity);\r\n        if (res == false) {\r\n            revert();\r\n        }\r\n        mfsCount = mfsCount.add(mfsQuantity);\r\n        emit BANK_SAVINGS(msg.sender, mfsQuantity, block.timestamp);\r\n        reward(mfsQuantity,_value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    奖励给用户\r\n    传入 奖励数量\r\n    */\r\n    function reward(uint mfsQuantity, uint vcmfsQuantity) private returns (bool){\r\n        res = false;\r\n        res = vcmfsToken.transfer(msg.sender, vcmfsQuantity);\r\n        if (res == false) {\r\n            revert();\r\n        }\r\n        vcmfsCount = vcmfsCount.sub(vcmfsQuantity);\r\n        emit EXCHANGE(msg.sender, mfsQuantity, vcmfsQuantity, block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    计算\r\n    传入 数量\r\n    返回 可换出数量\r\n    */\r\n    function calculation(uint _quantity) private view returns (uint value,uint _vcmfs){\r\n        value = (_quantity.mul(10)).div(exchange.div(1e18));\r\n        return (value.div(10),vcmfsCount);\r\n    }\r\n\r\n\r\n    /*------------------------- 设置类 -----------------------------*/\r\n    /*\r\n    转入vcmfs\r\n    传入 数量\r\n    返回 转入是否成功\r\n    */\r\n    function depositVcmfs(uint quantity) public onlyOwner returns (bool){\r\n        res = false;\r\n        res = vcmfsToken.transferFrom(msg.sender, address(this), quantity);\r\n        if (res == false) {\r\n            revert();\r\n        }\r\n        vcmfsCount = vcmfsCount.add(quantity);\r\n        return true;\r\n    }\r\n    /*\r\n    取出ERC20\r\n    传入 数量\r\n    返回 取出是否成功\r\n    */\r\n    function takeoutMfs(address tokens,uint quantity) public onlyOwner returns (bool){\r\n        res = false;\r\n        res = IERC20(tokens).transfer(msg.sender, quantity);\r\n        if (res == false) {\r\n            revert();\r\n        }\r\n        mfsCount = mfsCount.sub(quantity);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    修改存入代币地址\r\n    传入 新代币地址\r\n    */\r\n    function setMfsTokenAddr(address mfsTokenAddr, address vcmfsTokenAddr) public onlyOwner {\r\n        mfsToken = IERC20(mfsTokenAddr);\r\n        vcmfsToken = IERC20(vcmfsTokenAddr);\r\n    }\r\n    /*\r\n    修改上限\r\n    传入 十进制数量\r\n    */\r\n    function setUpperLimit(uint quantity) public onlyOwner {\r\n        upper_Limit = quantity.mul(1e18);\r\n    }\r\n\r\n    /*\r\n    修改兑换率\r\n    传入 十进制兑换率\r\n    */\r\n    function setExchange(uint _exchange) public onlyOwner {\r\n        exchange = _exchange.mul(1e18);\r\n\r\n    }\r\n\r\n    /*------------------------- 查看类 -----------------------------*/\r\n    /*\r\n    查看\r\n    返回\r\n    mfs地址(存入代币地址)\r\n    vcmfs地址(兑换出代币地址)\r\n    mfs总数\r\n    vcmfs总数\r\n    存入上限\r\n    兑换率(3mfs:1vcmfs)\r\n    */\r\n    function getGameInfo() public  view  returns (address, address, uint, uint, uint, uint){\r\n        return(\r\n        address(mfsToken),\r\n        address(vcmfsToken),\r\n        mfsCount,\r\n        vcmfsCount,\r\n        upper_Limit,\r\n        exchange);\r\n    }\r\n}"
    }
  }
}