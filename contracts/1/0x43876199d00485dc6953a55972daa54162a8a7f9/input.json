{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/inflationsweeper.sol":{"content":"pragma solidity =0.6.6;\npragma experimental ABIEncoderV2;\n\nimport './lib/SafeMath.sol';\n\n\n\ninterface v2pool{\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\n\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n}\n\n\ncontract inflatesweeper{\n    using SafeMath for uint;\n\n    \n    address payable public owner;\n\n\n\n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    \n    modifier onlyowner{\n        require(msg.sender == owner);\n        _;\n    }\n\n\n\n    receive() external payable {}\n\n\n    function deposit() payable external{\n    }\n\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\n    }\n    \n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\n        _safeTransfer(tokenaddr, owner, amount);\n    }\n    \n    function withdrawtokenall(address tokenaddr) external onlyowner{\n        _safeTransfer(tokenaddr, owner, IERC20(tokenaddr).balanceOf(address(this)));\n    }\n    \n    function withdrawethall() external onlyowner {\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function withdrawethamount(uint amount) external onlyowner {\n        msg.sender.transfer(amount);\n    }\n\n\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    } \n\n\n\n\n    function v2swap(address pool, bool first, uint256 amountin) private returns(uint256 amountOut){\n        (uint112 r1, uint112 r2, ) = v2pool(pool).getReserves();\n        \n        if(first){\n            amountOut = getAmountOut(amountin, r1, r2);\n            v2pool(pool).swap(0, amountOut, address(this), new bytes(0));\n        }else{\n            amountOut = getAmountOut(amountin, r2, r1);\n            v2pool(pool).swap(amountOut, 0, address(this), new bytes(0));\n        }\n    \n    }\n\n\n\n\n    function sweepv2pools(address pool, address[] calldata tokens, address[] calldata pools, uint256 amount, bool first) external payable returns(uint256 benefit){\n        \n        if(block.number > msg.value){\n            revert(\"shit\");\n        }  \n        \n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n\n        if(first){\n            v2pool(pool).swap(0, amount, address(this), new bytes(0));          \n        }else{\n            v2pool(pool).swap(amount, 0, address(this), new bytes(0)); \n        }\n\n        uint256 balance_before;\n        uint256 token_balance;\n        uint256 amountin;\n        \n        for(uint i=0; i < pools.length; i++){\n            token_balance = IERC20(tokens[i]).balanceOf(address(this));\n            balance_before = IERC20(tokens[i]).balanceOf(pools[i]);\n            \n            _safeTransfer(tokens[i], pools[i], token_balance);\n            \n            first = tokens[i] < tokens[i+1];\n            \n            v2swap(pools[i], first, IERC20(tokens[i]).balanceOf(pools[i]) - balance_before);\n        }\n\n        token_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        require(token_balance > weth_balance, \"fuck\");\n        \n        benefit = token_balance - weth_balance;\n        \n     \n        \n    }\n\n    function sweepv2poolsmem(address pool, address[] calldata tokens, address[] calldata pools, uint256 minbalance, uint256 amountin, bool first) external returns(uint256 benefit){\n        require(IERC20(tokens[0]).balanceOf(pool) >= minbalance, \"shit\");\n\n        uint256 weth_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n\n        if(first){\n            v2pool(pool).swap(0, amountin, address(this), new bytes(0));          \n        }else{\n            v2pool(pool).swap(amountin, 0, address(this), new bytes(0)); \n        }\n        \n        uint256 balance_before;\n        uint256 token_balance;\n        //uint256 amountin;\n        // bool first;\n\n        \n        for(uint i=0; i < pools.length; i++){\n            token_balance = IERC20(tokens[i]).balanceOf(address(this));\n            balance_before = IERC20(tokens[i]).balanceOf(pools[i]);\n            \n            _safeTransfer(tokens[i], pools[i], token_balance);\n            \n            first = tokens[i] < tokens[i+1];\n            \n            v2swap(pools[i], first, IERC20(tokens[i]).balanceOf(pools[i]) - balance_before);\n        }\n\n        token_balance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(address(this));\n        \n        require(token_balance > weth_balance, \"fuck\");\n        \n        benefit = token_balance - weth_balance;\n        \n     \n        \n    }\n    \n    \n    function detectskimpools(address[] memory pools) public view returns(address[] memory){\n        uint112 r0;\n        uint112 r1;\n        address t0;\n        address t1;\n        uint256 d1;\n        uint256 d2;\n        \n        \n        address[] memory detect = new address[](pools.length);\n        \n        for(uint256 i=0; i < pools.length; i++){\n            (r0, r1, ) = v2pool(pools[i]).getReserves();\n            t0 = v2pool(pools[i]).token0();\n            t1 = v2pool(pools[i]).token1();\n            \n            d1 = IERC20(t0).balanceOf(pools[i]) - r0;\n            d2 = IERC20(t1).balanceOf(pools[i]) - r1;\n            \n            if(d1 > 0 || d2 > 0){\n                detect[i] = pools[i];\n            }\n            \n        }\n        \n        return(detect);\n    }\n    \n    \n    \n    \n}"},"contracts/lib/SafeMath.sol":{"content":"pragma solidity =0.6.6;\n\nlibrary SafeMath {\n\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n  \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }  \n \n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  \n}"}}}