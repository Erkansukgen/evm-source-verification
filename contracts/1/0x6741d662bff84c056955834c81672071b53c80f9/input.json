{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/SmartsSale.sol":{"content":"// File: @openzeppelin/contracts/math/SafeMath.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ncontract ReentrancyGuard {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// File: @openzeppelin/contracts/GSN/Context.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/Smarts.sol\n\npragma solidity 0.6.4;\n\n\n\n\n\ncontract Smarts is Ownable, IERC20 {\n\n\tusing SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _addressesWithFee;\n    address public _feescollector;\n    uint256 public _fee;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    bool public releasedForTransfer;\n\n\tevent Issue(address recepient, uint amount);\n\n    constructor () public {\n        _name = \"Smarts Finance\";\n        _symbol = \"SMAT\";\n        _decimals = 18;\n        _feescollector = msg.sender;\n        _fee = 50;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function setFee(uint256 amount) external onlyOwner() {\n        _fee = amount;\n    }\n\n    function changeFeeCollector(address addr) external onlyOwner() {\n        _feescollector = addr;\n    }\n\n    function addAddressForFee(address addr) external onlyOwner() {\n        _addressesWithFee[addr] = true;\n    }\n\n    function removeAddressForFee(address addr) external onlyOwner() {\n        _addressesWithFee[addr] = false;\n    }\n\n    function release() public onlyOwner() {\n        releasedForTransfer = true;\n    }\n\n    function issue(address _recepient, uint256 _amount) public onlyOwner() {\n        require(!releasedForTransfer, \"SMATS: Not released for transfer!\");\n        _balances[_recepient] = _balances[_recepient].add(_amount);\n        _totalSupply = _totalSupply.add(_amount);\n        emit Issue(_recepient, _amount);\n        emit Transfer(address(0), _recepient, _amount);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n\t\trequire(releasedForTransfer, \"SMATS: Not released for transfer!\");\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n\t\trequire(releasedForTransfer, \"SMATS: Not released for transfer!\");\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n\t/**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n\n        if (_addressesWithFee[sender] || _addressesWithFee[recipient]) {\n\n            uint256 feeamount = amount.mul(_fee).div(10000);\n            uint256 remamount = amount.sub(feeamount);\n            _balances[_feescollector] = _balances[_feescollector].add(feeamount);\n            _balances[recipient] = _balances[recipient].add(remamount);\n\n            emit Transfer(sender, _feescollector, feeamount);\n            emit Transfer(sender, recipient, remamount);\n        } else {\n\n            _balances[recipient] = _balances[recipient].add(amount);\n            emit Transfer(sender, recipient, amount);\n        }\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n// File: contracts/Sale.sol\n\npragma solidity 0.6.4;\n\n\n\n\n\ncontract Sale is ReentrancyGuard, Ownable {\n    using SafeMath for uint256;\n\n    // Crowdsale participants\n    mapping(address => uint256) participants;\n\n    // SMATS per ETH price\n    uint256 buyPrice;\n    uint256 minimalGoal;\n    uint256 hardCap;\n\n    Smarts crowdsaleToken;\n\n    uint256 tokenUnit = (10 ** 18);\n\n    event SellToken(address recepient, uint tokensSold, uint value);\n\n    address payable fundingAddress;\n    uint256 startTimestamp;\n    uint256 endTimestamp;\n    bool started;\n    bool stopped;\n    uint256 totalCollected;\n    uint256 totalSold;\n\n\n    /**\n    Max Supply - 1,000,000 SMATS\n    Token Sale \n    70,000 for Presale      (1ETH = 130 SMATS)  (7692307692307692 wei) (0,07692307692307692 eth)\n    */\n\n    constructor(\n        Smarts _token\n    ) public {\n        minimalGoal = 1000000000000000000;\n        hardCap = 700000000000000000000;\n        buyPrice = 7692307692307692;\n        crowdsaleToken = _token;\n    }\n\n    // returns address of the erc20 smarts token\n    function getToken()\n    public\n    view\n    returns(address)\n    {\n        return address(crowdsaleToken);\n    }\n\n    // transfers crowdsale token from mintable to transferrable state\n    function releaseTokens()\n    external\n    onlyOwner()             // manager is CrowdsaleController instance\n    hasntStopped()            // crowdsale wasn't cancelled\n    whenCrowdsaleSuccessful() // crowdsale was successful\n    {\n        crowdsaleToken.release();\n        crowdsaleToken.transferOwnership(owner());\n    }\n\n    receive() external payable {\n        require(msg.value >= 200000000000000000, \"Min 0.2 eth\");\n        require(msg.value <= 20000000000000000000, \"Max 20 eth\");\n        sellTokens(msg.sender, msg.value);\n    }\n\n    // sels the project's token to buyers\n    function sellTokens(address payable _recepient, uint256 _value) internal\n        nonReentrant\n        hasBeenStarted()     // crowdsale started\n        hasntStopped()       // wasn't cancelled by owner\n        whenCrowdsaleAlive() // in active state\n    {\n        uint256 newTotalCollected = totalCollected.add(_value);\n\n        if (hardCap < newTotalCollected) {\n            // don't sell anything above the hard cap\n            uint256 refund = newTotalCollected.sub(hardCap);\n            uint256 diff = _value.sub(refund);\n\n            // send the ETH part which exceeds the hard cap back to the buyer\n            _recepient.transfer(refund);\n            _value = diff;\n            newTotalCollected = totalCollected.add(_value);\n        }\n\n        // token amount as per price\n        uint256 tokensSold = (_value).div(buyPrice).mul(tokenUnit);\n\n\n        // create new tokens for this buyer\n        crowdsaleToken.issue(_recepient, tokensSold);\n\n        emit SellToken(_recepient, tokensSold, _value);\n\n        // remember the buyer so he/she/it may refund its ETH if crowdsale failed\n        participants[_recepient] = participants[_recepient].add(_value);\n\n        // update total ETH collected\n        totalCollected = totalCollected.add(_value);\n\n        // update total tokens sold\n        totalSold = totalSold.add(tokensSold);\n    }\n\n    // project's owner withdraws ETH funds to the funding address upon successful crowdsale\n    function withdraw(\n        uint256 _amount // can be done partially\n    )\n    external\n    nonReentrant\n    onlyOwner() // project's owner\n    hasntStopped()  // crowdsale wasn't cancelled\n    whenCrowdsaleSuccessful() // crowdsale completed successfully\n    {\n        require(_amount <= address(this).balance, \"Not enough funds\");\n        fundingAddress.transfer(_amount);\n    }\n\n    // backers refund their ETH if the crowdsale was cancelled or has failed\n    function refund()\n    external\n    nonReentrant\n    {\n        // either cancelled or failed\n        require(stopped || isFailed(), \"Not cancelled or failed\");\n\n        uint256 amount = participants[msg.sender];\n\n        // prevent from doing it twice\n        require(amount > 0, \"Only once\");\n        participants[msg.sender] = 0;\n\n        msg.sender.transfer(amount);\n    }\n\n  // cancels crowdsale\n  function stop() public onlyOwner() hasntStopped()  {\n    // we can stop only not started and not completed crowdsale\n    if (started) {\n      require(!isFailed());\n      require(!isSuccessful());\n    }\n    stopped = true;\n  }\n\n  // called by CrowdsaleController to setup start and end time of crowdfunding process\n  // as well as funding address (where to transfer ETH upon successful crowdsale)\n  function start(\n    uint256 _startTimestamp,\n    uint256 _endTimestamp,\n    address payable _fundingAddress\n  )\n    public\n    onlyOwner()   // manager is CrowdsaleController instance\n    hasntStarted()  // not yet started\n    hasntStopped()  // crowdsale wasn't cancelled\n  {\n    require(_fundingAddress != address(0));\n\n    // range must be sane\n    require(_endTimestamp > _startTimestamp);\n\n    startTimestamp = _startTimestamp;\n    endTimestamp = _endTimestamp;\n    fundingAddress = _fundingAddress;\n\n    // now crowdsale is considered started, even if the current time is before startTimestamp\n    started = true;\n  }\n\n  // must return true if crowdsale is over, but it failed\n  function isFailed()\n    public\n    view\n    returns(bool)\n  {\n    return (\n      // it was started\n      started &&\n\n      // crowdsale period has finished\n      block.timestamp >= endTimestamp &&\n\n      // but collected ETH is below the required minimum\n      totalCollected < minimalGoal\n    );\n  }\n\n  // must return true if crowdsale is active (i.e. the token can be bought)\n  function isActive()\n    public\n    view\n    returns(bool)\n  {\n    return (\n      // it was started\n      started &&\n\n      // hard cap wasn't reached yet\n      totalCollected < hardCap &&\n\n      // and current time is within the crowdfunding period\n      block.timestamp >= startTimestamp &&\n      block.timestamp < endTimestamp\n    );\n  }\n\n  // must return true if crowdsale completed successfully\n  function isSuccessful()\n    public\n    view\n    returns(bool)\n  {\n    return (\n      // either the hard cap is collected\n      totalCollected >= hardCap ||\n\n      // ...or the crowdfunding period is over, but the minimum has been reached\n      (block.timestamp >= endTimestamp && totalCollected >= minimalGoal)\n    );\n  }\n\n  modifier whenCrowdsaleAlive() {\n    require(isActive());\n    _;\n  }\n\n  modifier whenCrowdsaleFailed() {\n    require(isFailed());\n    _;\n  }\n\n  modifier whenCrowdsaleSuccessful() {\n    require(isSuccessful());\n    _;\n  }\n\n  modifier hasntStopped() {\n    require(!stopped);\n    _;\n  }\n\n  modifier hasBeenStopped() {\n    require(stopped);\n    _;\n  }\n\n  modifier hasntStarted() {\n    require(!started);\n    _;\n  }\n\n  modifier hasBeenStarted() {\n    require(started);\n    _;\n  }\n}\n"}}}