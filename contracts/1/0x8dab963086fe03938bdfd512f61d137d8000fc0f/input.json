{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/LoanHealthChecker.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.7;\n\ninterface IERC20Like {\n    function balanceOf(address account_) external view returns (uint256 balance_);\n}\n\ninterface IMapleLoanLike {\n    function claimableFunds() external view returns (uint256 claimableFunds_);\n    function collateral() external view returns (uint256 collateral_);\n    function collateralAsset() external view returns (address collateralAsset_);\n    function collateralRequired() external view returns (uint256 collateralRequired_);\n    function drawableFunds() external view returns (uint256 drawableFunds_);\n    function fundsAsset() external view returns (address fundsAsset_);\n    function principal() external view returns (uint256 principal_);\n    function principalRequested() external view returns (uint256 principalRequested_);\n    function paymentInterval() external view returns (uint256 paymentInterval_);\n    function paymentsRemaining() external view returns (uint256 paymentsRemaining_);\n}\n\ninterface IMapleGlobalsLike {\n    function investorFee() external view returns (uint256 investorFee_);\n    function treasuryFee() external view returns (uint256 treasuryFee_);\n}\n\n\ncontract LoanHealthChecker {\n\n    address public globals;\n\n    constructor(address globals_) {\n        globals = globals_;\n    }\n\n    function checkLoanAccounting(address loan_)\n        external view\n        returns (\n            uint256 collateralAssetBalance_,\n            uint256 fundsAssetBalance_,\n            uint256 collateral_,\n            uint256 claimableFunds_,\n            uint256 drawableFunds_,\n            bool    collateralAssetSafe_,\n            bool    fundsAssetSafe_\n        )\n    {\n        IMapleLoanLike loan            = IMapleLoanLike(loan_);\n        IERC20Like     collateralAsset = IERC20Like(loan.collateralAsset());\n        IERC20Like     fundsAsset      = IERC20Like(loan.fundsAsset());\n\n        collateralAssetBalance_ = collateralAsset.balanceOf(loan_);\n        fundsAssetBalance_      = fundsAsset.balanceOf(loan_);\n\n        collateral_     = loan.collateral();\n        claimableFunds_ = loan.claimableFunds();\n        drawableFunds_  = loan.drawableFunds();\n\n        if (address(collateralAsset) != address(fundsAsset)) {\n            collateralAssetSafe_ = collateralAssetBalance_ >= collateral_;\n            fundsAssetSafe_      = fundsAssetBalance_      >= (claimableFunds_ + drawableFunds_);\n        } else {\n            collateralAssetSafe_ = fundsAssetSafe_ = fundsAssetBalance_ >= (collateral_ + claimableFunds_ + drawableFunds_);\n        }\n    }\n\n    function isCollateralMaintained(address loan_)\n        external view\n        returns (\n            uint256 collateral_,\n            uint256 principal_,\n            uint256 drawableFunds_,\n            uint256 principalRequested_,\n            uint256 collateralRequired_,\n            bool    collateralMaintained_\n        )\n    {\n        IMapleLoanLike loan = IMapleLoanLike(loan_);\n\n        collateral_         = loan.collateral();\n        principal_          = loan.principal();\n        drawableFunds_      = loan.drawableFunds();\n        principalRequested_ = loan.principalRequested();\n        collateralRequired_ = loan.collateralRequired();\n\n        uint256 paymentInterval   = loan.paymentInterval();\n        uint256 paymentsRemaining = loan.paymentsRemaining();\n\n        // Transfer the annualized treasury fee, if any, to the Maple treasury, and decrement drawable funds.\n        uint256 treasuryFee = (principalRequested_ * IMapleGlobalsLike(globals).treasuryFee() * paymentInterval * paymentsRemaining) / uint256(365 days * 10_000);\n\n        // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.\n        uint256 delegateFee = (principalRequested_ * IMapleGlobalsLike(globals).investorFee() * paymentInterval * paymentsRemaining) / uint256(365 days * 10_000);\n\n        // Where (collateral / outstandingPrincipal) should be greater or equal to (collateralRequired / principalRequested).\n        // NOTE: principalRequested_ cannot be 0, which is reasonable, since it means this was never a loan.\n        if(principal_ == drawableFunds_ + treasuryFee + delegateFee) {\n            collateralMaintained_ = true;\n        } else {\n            uint256 currentCollateralRequired =\n                principal_ <= drawableFunds_ ?\n                    uint256(0) :\n                    (collateralRequired_ * (principal_ - drawableFunds_)) / principalRequested_;\n\n            collateralMaintained_ = collateral_ >= currentCollateralRequired;\n        }\n    }\n\n}"
    }
  }
}