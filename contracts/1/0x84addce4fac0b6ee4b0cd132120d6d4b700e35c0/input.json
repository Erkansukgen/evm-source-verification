{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"merkleTree.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface ManagerLike {\n    function ilks(uint) external view returns (bytes32);\n    function owns(uint) external view returns (address);\n    function urns(uint) external view returns (address);\n    function vat() external view returns (address);\n}\n\ninterface CdpsLike {\n    function getCdpsAsc(address, address) external view returns (uint[] memory, address[] memory, bytes32[] memory);\n}\n\ninterface VatLike {\n    function ilks(bytes32) external view returns (uint, uint, uint, uint, uint);\n    function dai(address) external view returns (uint);\n    function urns(bytes32, address) external view returns (uint, uint);\n    function gem(bytes32, address) external view returns (uint);\n    function debt() external view returns (uint);\n    function Line() external view returns (uint);\n}\n\ninterface JugLike {\n    function ilks(bytes32) external view returns (uint, uint);\n    function base() external view returns (uint);\n}\n\ninterface PotLike {\n    function dsr() external view returns (uint);\n    function pie(address) external view returns (uint);\n    function chi() external view returns (uint);\n}\n\ninterface SpotLike {\n    function ilks(bytes32) external view returns (PipLike, uint);\n}\n\ninterface PipLike {\n    function peek() external view returns (bytes32, bool);\n}\n\ninterface InstaMcdAddress {\n    function manager() external view returns (address);\n    function vat() external view returns (address);\n    function jug() external view returns (address);\n    function spot() external view returns (address);\n    function pot() external view returns (address);\n    function getCdps() external view returns (address);\n}\n\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        z = x - y <= x ? x - y : 0;\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n}\n\n\ncontract Helpers is DSMath {\n    /**\n     * @dev get MakerDAO MCD Address contract\n     */\n    function getMcdAddresses() public pure returns (address) {\n        return 0xF23196DF1C440345DE07feFbe556a5eF0dcD29F0;\n    }\n\n    struct VaultData {\n        uint id;\n        address owner;\n        string colType;\n        uint collateral;\n        uint art;\n        uint debt;\n        uint liquidatedCol;\n        uint borrowRate;\n        uint colPrice;\n        uint liquidationRatio;\n        address vaultAddress;\n    }\n\n    struct ColInfo {\n        uint borrowRate;\n        uint price;\n        uint liquidationRatio;\n        uint vaultDebtCelling;\n        uint vaultDebtFloor;\n        uint vaultTotalDebt;\n        uint totalDebtCelling;\n        uint TotalDebt;\n    }\n\n    /**\n     * @dev Convert String to bytes32.\n    */\n    function stringToBytes32(string memory str) internal pure returns (bytes32 result) {\n        require(bytes(str).length != 0, \"String-Empty\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            result := mload(add(str, 32))\n        }\n    }\n\n    /**\n     * @dev Convert bytes32 to String.\n    */\n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {\n        bytes32  _temp;\n        uint count;\n        for (uint256 i; i < 32; i++) {\n            _temp = _bytes32[i];\n            if( _temp != bytes32(0)) {\n                count += 1;\n            }\n        }\n        bytes memory bytesArray = new bytes(count);\n        for (uint256 i; i < count; i++) {\n                bytesArray[i] = (_bytes32[i]);\n        }\n        return (string(bytesArray));\n    }\n\n\n    function getFee(bytes32 ilk) internal view returns (uint fee) {\n        address jug = InstaMcdAddress(getMcdAddresses()).jug();\n        (uint duty,) = JugLike(jug).ilks(ilk);\n        uint base = JugLike(jug).base();\n        fee = add(duty, base);\n    }\n\n    function getColPrice(bytes32 ilk) internal view returns (uint price) {\n        address spot = InstaMcdAddress(getMcdAddresses()).spot();\n        address vat = InstaMcdAddress(getMcdAddresses()).vat();\n        (, uint mat) = SpotLike(spot).ilks(ilk);\n        (,,uint spotPrice,,) = VatLike(vat).ilks(ilk);\n        price = rmul(mat, spotPrice);\n    }\n\n    function getColRatio(bytes32 ilk) internal view returns (uint ratio) {\n        address spot = InstaMcdAddress(getMcdAddresses()).spot();\n        (, ratio) = SpotLike(spot).ilks(ilk);\n    }\n\n    function getDebtFloorAndCeiling(bytes32 ilk) internal view returns (uint, uint, uint, uint, uint) {\n        address vat = InstaMcdAddress(getMcdAddresses()).vat();\n        (uint totalArt,uint rate,, uint vaultDebtCellingRad, uint vaultDebtFloor) = VatLike(vat).ilks(ilk);\n        uint vaultDebtCelling = vaultDebtCellingRad / 10 ** 45;\n        uint vaultTotalDebt = rmul(totalArt, rate);\n\n        uint totalDebtCelling = VatLike(vat).Line();\n        uint totalDebt = VatLike(vat).debt();\n        return (\n            vaultDebtCelling,\n            vaultTotalDebt,\n            vaultDebtFloor,\n            totalDebtCelling,\n            totalDebt\n        );\n    }\n}\n\n\ncontract VaultResolver is Helpers {\n     function getVaults(address owner) external view returns (VaultData[] memory) {\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\n        address cdpManger = InstaMcdAddress(getMcdAddresses()).getCdps();\n\n        (uint[] memory ids, address[] memory urns, bytes32[] memory ilks) = CdpsLike(cdpManger).getCdpsAsc(manager, owner);\n        VaultData[] memory vaults = new VaultData[](ids.length);\n\n        for (uint i = 0; i < ids.length; i++) {\n            (uint ink, uint art) = VatLike(ManagerLike(manager).vat()).urns(ilks[i], urns[i]);\n            (,uint rate, uint priceMargin,,) = VatLike(ManagerLike(manager).vat()).ilks(ilks[i]);\n            uint mat = getColRatio(ilks[i]);\n\n            vaults[i] = VaultData(\n                ids[i],\n                owner,\n                bytes32ToString(ilks[i]),\n                ink,\n                art,\n                rmul(art,rate),\n                VatLike(ManagerLike(manager).vat()).gem(ilks[i], urns[i]),\n                getFee(ilks[i]),\n                rmul(priceMargin, mat),\n                mat,\n                urns[i]\n            );\n        }\n        return vaults;\n    }\n\n    function getVaultById(uint id) external view returns (VaultData memory) {\n        address manager = InstaMcdAddress(getMcdAddresses()).manager();\n        address urn = ManagerLike(manager).urns(id);\n        bytes32 ilk = ManagerLike(manager).ilks(id);\n\n        (uint ink, uint art) = VatLike(ManagerLike(manager).vat()).urns(ilk, urn);\n        (,uint rate, uint priceMargin,,) = VatLike(ManagerLike(manager).vat()).ilks(ilk);\n\n        uint mat = getColRatio(ilk);\n\n        uint feeRate = getFee(ilk);\n        VaultData memory vault = VaultData(\n            id,\n            ManagerLike(manager).owns(id),\n            bytes32ToString(ilk),\n            ink,\n            art,\n            rmul(art,rate),\n            VatLike(ManagerLike(manager).vat()).gem(ilk, urn),\n            feeRate,\n            rmul(priceMargin, mat),\n            mat,\n            urn\n        );\n        return vault;\n    }\n\n    function getColInfo(string[] memory name) public view returns (ColInfo[] memory) {\n        ColInfo[] memory colInfo = new ColInfo[](name.length);\n\n        for (uint i = 0; i < name.length; i++) {\n            bytes32 ilk = stringToBytes32(name[i]);\n            (\n                uint256 vaultDebtCelling,\n                uint256 vaultDebtFloor,\n                uint256 vaultTotalDebt,\n                uint256 totalDebtCelling,\n                uint256 totalDebt\n            ) = getDebtFloorAndCeiling(ilk);\n\n            colInfo[i] = ColInfo(\n                getFee(ilk),\n                getColPrice(ilk),\n                getColRatio(ilk),\n                vaultDebtCelling,\n                vaultDebtFloor,\n                vaultTotalDebt,\n                totalDebtCelling,\n                totalDebt\n            );\n        }\n        return colInfo;\n    }\n\n}\n\n\ncontract DSRResolver is VaultResolver {\n    function getDsrRate() public view returns (uint dsr) {\n        address pot = InstaMcdAddress(getMcdAddresses()).pot();\n        dsr = PotLike(pot).dsr();\n    }\n\n    function getDaiPosition(address owner) external view returns (uint amt, uint dsr) {\n        address pot = InstaMcdAddress(getMcdAddresses()).pot();\n        uint chi = PotLike(pot).chi();\n        uint pie = PotLike(pot).pie(owner);\n        amt = rmul(pie,chi);\n        dsr = getDsrRate();\n    }\n}\n\n\ncontract InstaMakerResolver is DSRResolver {\n    string public constant name = \"Maker-Resolver-v1.4\";\n}"}}}