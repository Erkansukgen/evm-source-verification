{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"openzeppelin@0.6/contracts/math/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"},"src/FullMath.sol":{"content":"// SPDX-License-Identifier: CC-BY-4.0\npragma solidity >=0.6.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\n        return fullDiv(l, h, d);\n    }\n}\n"},"src/TollClaim2.0.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\nimport \"../openzeppelin@0.6/contracts/math/SafeMath.sol\";\nimport \"./FullMath.sol\";\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function renounceMinter() external;\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function mint(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    \n}\n\n/**\n * @title TollCrowdSale\n * @dev This is an example of a fully fledged crowdsale.\n * The way to add new features to a base crowdsale is by multiple inheritance.\n * In this example we are providing following extensions:\n * CappedCrowdsale - sets a max boundary for raised funds\n * RefundableCrowdsale - set a min goal to be reached and returns funds if it's not met\n * MintedCrowdsale - assumes the token can be minted by the crowdsale, which does so\n * when receiving purchases.\n *\n * After adding multiple features it's good practice to run integration tests\n * to ensure that subcontracts works together as intended.\n */\ncontract TollClaim  {\n    using SafeMath for uint256;\n    uint256 public unclaimed = 1000000 ether;\n    uint256 public totalClaims;\n    IERC20  public TOLL;\n    address public oracle = 0xF9D2DCe379a4184fC57Ea84467AfEdc92F2D5298;\n    mapping(uint256 => bool) public usedNonces;\n    struct User {\n        uint256 claim;\n        uint256 bal;\n        uint256 withdraw;\n        uint256 refAmount;\n        uint256 lastTime;\n        address refAddress;\n        \n    }\n    mapping(address => User) public users;\n    event CLAIMED(address indexed user, address indexed refAddress, uint256 amount,  uint256 time);\n    event WITHDRAWAL(address indexed user, uint256 amount, uint256 time);\n    event PAYOUT(address indexed refAddress, address indexed user, uint256 amount, uint256 time);\n    \n    constructor(IERC20 _token) {\n        TOLL = _token;\n    }\n    \n    //mint reward tokens after getting the mint Role\n    // Role will be renounced after call. so any other call will fail!\n    function start() public {\n        TOLL.mint(address(this), 1000000 ether);\n        TOLL.renounceMinter();\n    }\n\n\n    \n    function claim(\n        uint256 amount,\n        uint256 nonce,\n        bytes memory sig,\n        address ref // referral\n    ) public {\n        User storage _user =  users[msg.sender];\n        // solium-disable-next-line security/no-block-members */\n        require(unclaimed >= amount, \"Ended\");\n        require(!usedNonces[nonce], \"Used Nonce\");\n        require(_user.claim == 0, \"Already Claimed\");\n        require(TOLL.transferFrom(msg.sender, address(this),amount ), \"Invalid Toll Balance at Claim Time\");\n        bytes32 message = addPrefix(keccak256(abi.encodePacked(msg.sender, amount, nonce, address(this))));\n        address signedBy = whoSigned(message, sig);\n        require(signedBy == oracle, \"Invalid signature\");\n        uint256 earned = 0;\n        if (ref != address(0)) {\n            _user.refAddress = ref;\n            earned = onePercent(amount).mul(20); \n        }\n        usedNonces[nonce] = true;\n        _user.claim = amount;\n        _user.lastTime = block.timestamp;\n        _user.bal = amount*2;\n        _user.withdraw =  _user.bal.div(120); // daily amount for 120 days\n        totalClaims = totalClaims.add(amount);\n        unclaimed = unclaimed.sub(amount.add(earned));\n        emit CLAIMED(msg.sender, ref, amount, block.timestamp);\n    }\n    \n\n    function withdraw() public {\n        User storage _user =  users[msg.sender];\n        require(_user.bal > 0, \"unAvailable\");\n        require ( block.timestamp > _user.lastTime.add(1 days),\"Once Daily\");\n        uint256 amount = getAvailable(msg.sender);\n        _user.bal = _user.bal - amount;\n        _user.lastTime = block.timestamp;\n        if(_user.refAddress != address(0)){\n            uint256 refAmount = onePercent(amount).mul(20);\n            emit PAYOUT(_user.refAddress, msg.sender, refAmount, block.timestamp);\n            TOLL.transfer(_user.refAddress, refAmount);\n        }\n        emit WITHDRAWAL(msg.sender, amount, block.timestamp);\n        TOLL.transfer(msg.sender, amount);\n    }\n    \n    \n    function getAvailable(address user) public view returns (uint256 amount){\n        User memory _user =  users[user];\n        uint256 time =  block.timestamp.sub(_user.lastTime);\n        uint256 _claim =  _user.claim.mul(2);\n        amount = FullMath.mulDiv(time, _claim, 120 days);\n    }\n\n\n    //https://ethereum.stackexchange.com/questions/71928/percentage-calculation\n    function onePercent(uint256 _tokens) private pure returns (uint256) {\n        uint256 roundValue = ceil(_tokens, 100);\n        uint256 onePercentofTokens = roundValue.mul(100).div(100 * 10**uint256(2));\n        return onePercentofTokens;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n        uint256 c = a.add(m);\n        uint256 d = c.sub(1);\n        uint256 e = d.div(m);\n        return e.mul(m);\n    }\n\n\n\n    // Some fancy Signature Legwork\n    function decodeSignature(bytes memory sig)\n        internal\n        pure\n        returns (\n            uint8,\n            bytes32,\n            bytes32\n        )\n    {\n        require(sig.length == 65, \"Invalid SIgnature\");\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        // solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        return (v, r, s);\n    }\n\n    function whoSigned(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        (v, r, s) = decodeSignature(sig);\n        return ecrecover(message, v, r, s);\n    }\n\n    function addPrefix(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n\n\n}\n"}}}