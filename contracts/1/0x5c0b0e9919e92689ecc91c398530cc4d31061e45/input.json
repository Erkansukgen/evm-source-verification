{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BundleExecutor.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.7;\n\npragma experimental ABIEncoderV2;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\ninterface IERC721 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    \n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n}\n\ncontract MultiMinter is IERC721Receiver {\n    address private immutable owner;\n    address[] private queue;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    receive() external payable {}\n    \n    function prepareMint(address[] memory _recipients, uint256[] memory _amounts) external onlyOwner {\n        require(\n            _recipients.length == _amounts.length,\n            \"malformed\"\n        );\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            for (uint256 j = 0; j < _amounts[i]; j++) {\n                queue.push(_recipients[i]);\n            }\n        }\n    }\n    \n    function onERC721Received(address, address, uint256 _tokenId, bytes calldata) external override returns (bytes4) {\n        address recipient = queue[queue.length - 1];\n        queue.pop();\n        IERC721(msg.sender).safeTransferFrom(address(this), recipient, _tokenId);\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function multicall(address[] memory _targets, bytes[] memory _payloads, uint256[] memory _values) external onlyOwner payable {\n        require(\n            _targets.length == _payloads.length && _targets.length == _values.length,\n            \"malformed\"\n        );\n        for (uint256 i = 0; i < _targets.length; i++) {\n            (bool _success,) = _targets[i].call{value: _values[i]}(_payloads[i]);\n            require(_success);\n        }\n    }\n\n    function call(address payable _to, uint256 _value, bytes calldata _data) external onlyOwner payable returns (bytes memory) {\n        require(_to != address(0));\n        (bool _success, bytes memory _result) = _to.call{value: _value}(_data);\n        require(_success);\n        return _result;\n    }\n}\n"}}}