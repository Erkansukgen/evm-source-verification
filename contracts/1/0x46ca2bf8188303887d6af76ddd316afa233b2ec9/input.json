{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/tests/4_Ballot_test.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-11-05\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.10;\n\ninterface ERC20 {\n    function balanceOf(address account) external returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n// Adventure Awaits: find all 4 clues, solve the puzzle and claim the reward\n// #0xPoland #0xPolandHeist\ncontract Puzzle {\n    uint256 constant BLOCKS_TO_WAIT = 10;\n\n    bytes32 public hash;\n    address public winner;\n    mapping(address => bytes32) public commits;\n    mapping(address => uint256) public commitBlock;\n\n    constructor(bytes32 _hash) public payable {\n        hash = _hash;\n    }\n\n    function commit(bytes32 _hash) public {\n        commits[msg.sender] = _hash;\n        commitBlock[msg.sender] = block.number;\n    }\n\n    function reveal(string memory _solution) public {\n        bytes32 solutionHash = keccak256(abi.encodePacked(_solution));\n        bytes32 solutionDoubleHash = keccak256(abi.encodePacked(solutionHash));\n        bytes32 commitHash = keccak256(abi.encodePacked(msg.sender, solutionHash));\n        require(winner == address(0), 'Already won');\n        require(block.number > commitBlock[msg.sender] + BLOCKS_TO_WAIT, 'No front-running');\n        require(solutionDoubleHash == hash, 'Invalid solution');\n        require(commitHash == commits[msg.sender], 'Did not commit');\n        winner = msg.sender;\n    }\n\n    function withdraw() public {\n        require(msg.sender == winner, 'Not a winner');\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function withdrawToken(ERC20 token) public {\n        require(msg.sender == winner, 'Not a winner');\n        token.transfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n}"
    }
  }
}