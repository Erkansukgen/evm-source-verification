{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/WaltToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.6;\n\ncontract WaltContract {\n    address public minter;\n    string public constant name = \"Walt\";\n    string public constant symbol = \"WEM\";\n    uint8 public constant decimals = 18;  \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Burn(address indexed burner, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n    mapping(address => uint256) balances;\n    mapping(address => mapping (address => uint256)) allowed;\n    mapping (address => bool) public frozenAccount;\n    uint256 totalSupply_;\n    using SafeMath for uint256;\n   constructor(uint256 total) public {  \n    totalSupply_ = total;\n    balances[msg.sender] = totalSupply_;\n    minter = msg.sender;\n    }  \n    modifier onlyOwner {\n        require(msg.sender == minter);\n        _;\n    }\n    function transferOwnership(address newOwner) onlyOwner public {\n        minter = newOwner;\n    }\n    function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n    }\n    function balanceOf(address tokenOwner) public view returns (uint) {\n        return balances[tokenOwner];\n    }\n    function approve(address delegate, uint numTokens) public returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n       emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n    function allowance(address owner, address delegate) public view returns (uint) {\n        return allowed[owner][delegate];\n    }\n    function transfer(address receiver, uint256 amount) public virtual returns (bool) {\n         _transfer(msg.sender, receiver, amount);\n        return true;\n    }\n      function _transfer(address sender, address receiver, uint256 amount) internal virtual {\n        require(sender == msg.sender, \"ERC20: transfer not from sender\");\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(receiver != address(0), \"ERC20: transfer to the zero address\");\n        _beforeTokenTransfer(sender, receiver, amount);\n        balances[sender] = balances[sender].sub(amount);\n        balances[receiver] = balances[receiver].add(amount);\n        emit Transfer(sender, receiver, amount);\n    }\n    function mint(address receiver, uint amount) public {\n      require(msg.sender == minter);\n      totalSupply_ += amount;\n      balances[receiver] += amount;\n      emit Transfer(msg.sender, receiver, amount);\n    }\n    function burn(uint256 amount) external {\n      _burn(msg.sender, amount);\n    }\n    function _burn(address account, uint256 amount) internal {\n      require(amount != 0);\n      require(amount <= balances[account]);\n      totalSupply_ = totalSupply_.sub(amount);\n      balances[account] = balances[account].sub(amount);\n      emit Transfer(account, address(0), amount);\n    }\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\nlibrary SafeMath { \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      assert(b <= a);\n      return a - b;\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n    }\n}"}}}