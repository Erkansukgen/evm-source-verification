{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 3999999999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/sniper_contract_buy.sol": {
      "content": "pragma solidity ^0.6.6;\n\n//<SPDX-License-Identifier: MIT\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\n}\n\ninterface IFactory {\n    function INIT_CODE_PAIR_HASH() external pure returns(bytes32);\n}\n\ninterface IBEP20 {\n    \n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\n\ninterface IPair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function token0() external pure returns(address);\n\n}\n\ninterface IRouter {\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n}\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {require((z = x + y) >= x, 'ds-math-add-overflow');}\n    function sub(uint x, uint y) internal pure returns (uint z) {require((z = x - y) <= x, 'ds-math-sub-underflow');}\n    function mul(uint x, uint y) internal pure returns (uint z) {require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');}\n}\n\nlibrary PairLibrary {\n    using SafeMath for uint;\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'ZERO_ADDRESS');\n    }\n    \n    function pairFor(address factory, bytes32 INIT_CODE_PAIR_HASH, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(hex'ff',factory,keccak256(abi.encodePacked(token0, token1)),INIT_CODE_PAIR_HASH))));\n    }\n    \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint fee_num, uint fee_den) internal pure returns (uint amountOut) {\n        uint amountInWithFee = amountIn.mul(fee_num);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(fee_den).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n    \n}\n\ncontract ContractBot {\n    \n    using SafeMath for uint;\n    \n    address owner;\n    mapping(address => bool) public allowed;\n    \n    constructor () public {\n        \n        owner = msg.sender;\n        allowed[owner] = true;\n        \n    }\n    \n    modifier OwnerCheck(address _address) {\n        require(_address == owner, \"Locked!\");\n        _;\n    }\n    \n    modifier AllowedCheck(address _address) {\n        require(allowed[_address] == true, \"Not allowed!\");\n        _;\n    }\n    \n    function changeOwner(address _newOwner) external OwnerCheck(msg.sender) {\n        owner = _newOwner;\n    }\n    \n    function getPair(address _factory, bytes32 _INIT_CODE_PAIR_HASH, address _tokenA, address _tokenB) public pure returns (address pairadd) {\n        pairadd = PairLibrary.pairFor(_factory, _INIT_CODE_PAIR_HASH, _tokenA, _tokenB);\n    }\n    \n    function isAllowed(address _member) external view returns(bool) {\n        return (allowed[_member]);\n    }\n    \n    function approveAddress(address _member) external OwnerCheck(msg.sender) returns (bool) {\n        allowed[_member] = true;\n        return true;\n    }\n    \n    function bulkApprove(address[] memory _members) external OwnerCheck(msg.sender) returns (bool) {\n        for(uint i = 0; i < _members.length; i++) {\n            allowed[_members[i]] = true;\n        }\n        \n        return true;\n    }\n    \n    function removeAddress(address _member) external OwnerCheck(msg.sender) returns (bool) {\n        allowed[_member] = false;\n        return true;\n    }\n    \n    function bulkRemove(address[] memory _members) external OwnerCheck(msg.sender) returns (bool) {\n        for(uint i = 0; i < _members.length; i++) {\n            allowed[_members[i]] = false;    \n        }\n        \n        return true;\n    }\n    \n    function directSwapBuyOnly(address _router, address _pair, address[] memory _path, uint256 _amountMin, address _to) external payable AllowedCheck(msg.sender) returns(bool success) {\n    \n        IPair LP = IPair(_pair);\n        \n        IWETH(_path[0]).deposit{value : msg.value}();\n        IWETH(_path[0]).transfer(address(LP), msg.value);\n        \n        \n        uint amountOut;\n        (uint reserve0, uint reserve1,) = LP.getReserves();\n        address token0 = LP.token0();\n        \n        (reserve0, reserve1) = _path[0] == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n\n        amountOut = IRouter(_router).getAmountsOut(msg.value, _path)[1];\n        \n        if (_amountMin != 0) { require(amountOut >= _amountMin, \"ERR : SLIPPAGE\"); }\n\n        (uint amount0Out, uint amount1Out) = _path[0] == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        LP.swap(amount0Out, amount1Out, _to, new bytes(0));\n        success = true;\n    }\n    \n    function directSwapBuyAndSell(address _router, address _pair, address[] memory _path, uint256 _amount, uint256 _amountMin, address _to) external AllowedCheck(msg.sender) returns(bool success) {\n    \n        IPair LP = IPair(_pair);\n        IWETH(_path[0]).transferFrom(msg.sender, address(LP), _amount);\n        \n        uint amountOut;\n        (uint reserve0, uint reserve1,) = LP.getReserves();\n        address token0 = LP.token0();\n        \n        (reserve0, reserve1) = _path[0] == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        amountOut = IRouter(_router).getAmountOut(IBEP20(_path[0]).balanceOf(address(LP)).sub(reserve0), reserve0, reserve1);\n        \n        if (_amountMin != 0) { require(amountOut >= _amountMin, \"ERR : SLIPPAGE\"); }\n\n        (uint amount0Out, uint amount1Out) = _path[0] == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        LP.swap(amount0Out, amount1Out, _to, new bytes(0));\n        success = true;\n    }\n    \n    receive() external payable { }\n    \n    function withdraw() external OwnerCheck(msg.sender) {\n        payable(owner).transfer(address(this).balance);\n    }\n    \n}"
    }
  }
}