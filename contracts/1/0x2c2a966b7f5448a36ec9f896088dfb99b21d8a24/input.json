{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"},"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"},"@openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2Upgradeable {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint256(_data));\n    }\n}\n"},"contracts/LootBox.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\n/// @title Allows anyone to \"loot\" an address\n/// @author Brendan Asselstine\n/// @notice A LootBox allows anyone to withdraw all tokens or execute calls on behalf of the contract.\n/// @dev This contract is intended to be counterfactually instantiated via CREATE2.\ncontract LootBox {\n\n  /// @notice A structure to define arbitrary contract calls\n  struct Call {\n    address to;\n    uint256 value;\n    bytes data;\n  }\n\n  /// @notice A structure to define ERC721 transfer contents\n  struct WithdrawERC721 {\n    IERC721Upgradeable token;\n    uint256[] tokenIds;\n  }\n\n  /// @notice A structure to define ERC1155 transfer contents\n  struct WithdrawERC1155 {\n    IERC1155Upgradeable token;\n    uint256[] ids;\n    uint256[] amounts;\n    bytes data;\n  }\n\n  /// @notice Emitted when an ERC20 token is withdrawn\n  event WithdrewERC20(address indexed token, uint256 amount);\n\n  /// @notice Emitted when an ERC721 token is withdrawn\n  event WithdrewERC721(address indexed token, uint256[] tokenIds);\n\n  /// @notice Emitted when an ERC1155 token is withdrawn\n  event WithdrewERC1155(address indexed token, uint256[] ids, uint256[] amounts, bytes data);\n\n  /// @notice Emitted when the contract transfer ether\n  event TransferredEther(address indexed to, uint256 amount);\n\n  address private _owner;\n\n  function initialize () public {\n    require(_owner == address(0), \"LootBox/already-init\");\n    _owner = msg.sender;\n  }\n\n  /// @notice Executes calls on behalf of this contract.\n  /// @param calls The array of calls to be executed.\n  /// @return An array of the return values for each of the calls\n  function executeCalls(Call[] calldata calls) external onlyOwner returns (bytes[] memory) {\n    bytes[] memory response = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);\n    }\n    return response;\n  }\n\n  /// @notice Transfers ether held by the contract to another account\n  /// @param to The account to transfer Ether to\n  /// @param amount The amount of Ether to transfer\n  function _transferEther(address payable to, uint256 amount) internal {\n    to.transfer(amount);\n\n    emit TransferredEther(to, amount);\n  }\n\n  /// @notice Transfers tokens to another account\n  /// @param erc20 Array of ERC20 token addresses whose entire balance should be transferred\n  /// @param erc721 Array of WithdrawERC721 structs whose tokens should be transferred\n  /// @param erc1155 Array of WithdrawERC1155 structs whose tokens should be transferred\n  /// @param to The address receiving all tokens\n  function plunder(\n    IERC20Upgradeable[] memory erc20,\n    WithdrawERC721[] memory erc721,\n    WithdrawERC1155[] memory erc1155,\n    address payable to\n  ) external onlyOwner {\n    require(to != address(0), \"LootBox/non-zero-to\");\n    _withdrawERC20(erc20, to);\n    _withdrawERC721(erc721, to);\n    _withdrawERC1155(erc1155, to);\n    _transferEther(to, address(this).balance);\n  }\n\n  /// @notice Destroys this contract using `selfdestruct`\n  /// @param to The address to send remaining Ether to\n  function destroy(address payable to) external onlyOwner {\n    delete _owner;\n    selfdestruct(to);\n  }\n\n  /// @notice Executes a call to another contract\n  /// @param to The address to call\n  /// @param value The Ether to pass along with the call\n  /// @param data The call data\n  /// @return The return data from the call\n  function _executeCall(address to, uint256 value, bytes memory data) internal returns (bytes memory) {\n    (bool succeeded, bytes memory returnValue) = to.call{value: value}(data);\n    require(succeeded, string(returnValue));\n    return returnValue;\n  }\n\n  /// @notice Transfers the entire balance of ERC20s to an account\n  /// @param tokens An array of ERC20 tokens to transfer out.  The balance of each will be transferred.\n  /// @param to The recipient of the transfers\n  function _withdrawERC20(IERC20Upgradeable[] memory tokens, address to) internal {\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint256 balance = tokens[i].balanceOf(address(this));\n      tokens[i].transfer(to, balance);\n\n      emit WithdrewERC20(address(tokens[i]), balance);\n    }\n  }\n\n  /// @notice Transfers ERC721 tokens to an account\n  /// @param withdrawals An array of WithdrawERC721 structs that each include the ERC721 token to transfer and the corresponding token ids.\n  /// @param to The recipient of the transfers\n  function _withdrawERC721(WithdrawERC721[] memory withdrawals, address to) internal {\n    for (uint256 i = 0; i < withdrawals.length; i++) {\n      for (uint256 tokenIndex = 0; tokenIndex < withdrawals[i].tokenIds.length; tokenIndex++) {\n        withdrawals[i].token.transferFrom(address(this), to, withdrawals[i].tokenIds[tokenIndex]);\n      }\n\n      emit WithdrewERC721(address(withdrawals[i].token), withdrawals[i].tokenIds);\n    }\n  }\n\n  /// @notice Transfers ERC1155 tokens to an account\n  /// @param withdrawals An array of WithdrawERC1155 structs that each include the ERC1155 to transfer and it's corresponding token ids and amounts.\n  /// @param to The recipient of the transfers\n  function _withdrawERC1155(WithdrawERC1155[] memory withdrawals, address to) internal {\n    for (uint256 i = 0; i < withdrawals.length; i++) {\n      withdrawals[i].token.safeBatchTransferFrom(address(this), to, withdrawals[i].ids, withdrawals[i].amounts, withdrawals[i].data);\n\n      emit WithdrewERC1155(address(withdrawals[i].token), withdrawals[i].ids, withdrawals[i].amounts, withdrawals[i].data);\n    }\n  }\n\n  modifier onlyOwner {\n    require(msg.sender == _owner, \"LootBox/only-owner\");\n    _;\n  }\n}\n"},"contracts/LootBoxController.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol\";\n\nimport \"./external/pooltogether/MinimalProxyLibrary.sol\";\nimport \"./LootBox.sol\";\n\n/// @title Allows users to plunder an address associated with an ERC721\n/// @author Brendan Asselstine\n/// @notice Counterfactually instantiates a \"Loot Box\" at an address unique to an ERC721 token.  The address for an ERC721 token can be computed and later\n/// plundered by transferring token balances to the ERC721 owner.\ncontract LootBoxController {\n\n  /// @notice The instance to which all proxies will point\n  LootBox public lootBoxInstance;\n\n  bytes internal lootBoxBytecode;\n\n  /// @notice Emitted when a Loot Box is plundered\n  event Plundered(address indexed erc721, uint256 indexed tokenId, address indexed operator);\n\n  /// @notice Emitted when a Loot Box is executed\n  event Executed(address indexed erc721, uint256 indexed tokenId, address indexed operator);\n\n  /// @notice Constructs a new controller.\n  /// @dev Creates a new LootBox instance and an associated minimal proxy.\n  constructor () public {\n    lootBoxInstance = new LootBox();\n    lootBoxInstance.initialize();\n    lootBoxBytecode = MinimalProxyLibrary.minimalProxy(address(lootBoxInstance));\n  }\n\n  /// @notice Computes the Loot Box address for a given ERC721 token.\n  /// @dev The contract will not exist yet, so the Loot Box address will have no code.\n  /// @param erc721 The address of the ERC721\n  /// @param tokenId The ERC721 token id\n  /// @return The address of the Loot Box.\n  function computeAddress(address erc721, uint256 tokenId) external view returns (address) {\n    return Create2Upgradeable.computeAddress(_salt(erc721, tokenId), keccak256(lootBoxBytecode));\n  }\n\n  /// @notice Allows anyone to transfer all given tokens in a Loot Box to the associated ERC721 owner.\n  /// @dev A Loot Box contract will be counterfactually created, tokens transferred to the ERC721 owner, then destroyed.\n  /// @param erc721 The address of the ERC721\n  /// @param tokenId The ERC721 token id\n  /// @param erc20s An array of ERC20 tokens whose entire balance should be transferred\n  /// @param erc721s An array of structs defining ERC721 tokens that should be transferred\n  /// @param erc1155s An array of struct defining ERC1155 tokens that should be transferred\n  function plunder(\n    address erc721,\n    uint256 tokenId,\n    IERC20Upgradeable[] calldata erc20s,\n    LootBox.WithdrawERC721[] calldata erc721s,\n    LootBox.WithdrawERC1155[] calldata erc1155s\n  ) external {\n    address payable owner = payable(IERC721Upgradeable(erc721).ownerOf(tokenId));\n    LootBox lootBox = _createLootBox(erc721, tokenId);\n    lootBox.plunder(erc20s, erc721s, erc1155s, owner);\n    lootBox.destroy(owner);\n\n    emit Plundered(erc721, tokenId, msg.sender);\n  }\n\n  /// @notice Allows the owner of an ERC721 to execute abitrary calls on behalf of the associated Loot Box.\n  /// @dev The Loot Box will be counterfactually created, calls executed, then the contract destroyed.\n  /// @param erc721 The ERC721 address\n  /// @param tokenId The ERC721 token id\n  /// @param calls The array of call structs that define that target, amount of ether, and data.\n  /// @return The array of call return values.\n  function executeCalls(\n    address erc721,\n    uint256 tokenId,\n    LootBox.Call[] calldata calls\n  ) external returns (bytes[] memory) {\n    address payable owner = payable(IERC721Upgradeable(erc721).ownerOf(tokenId));\n    require(msg.sender == owner, \"LootBoxController/only-owner\");\n    LootBox lootBox = _createLootBox(erc721, tokenId);\n    bytes[] memory result = lootBox.executeCalls(calls);\n    lootBox.destroy(owner);\n\n    emit Executed(erc721, tokenId, msg.sender);\n\n    return result;\n  }\n\n  /// @notice Creates a Loot Box for the given ERC721 token.\n  /// @param erc721 The ERC721 address\n  /// @param tokenId The ERC721 token id\n  /// @return The address of the newly created LootBox.\n  function _createLootBox(address erc721, uint256 tokenId) internal returns (LootBox) {\n    LootBox lootBox = LootBox(Create2Upgradeable.deploy(0, _salt(erc721, tokenId), lootBoxBytecode));\n    lootBox.initialize();\n    return lootBox;\n  }\n\n  /// @notice Computes the CREATE2 salt for the given ERC721 token.\n  /// @param erc721 The ERC721 address\n  /// @param tokenId The ERC721 token id\n  /// @return A bytes32 value that is unique to that ERC721 token.\n  function _salt(address erc721, uint256 tokenId) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(erc721, tokenId));\n  }\n}\n"},"contracts/external/pooltogether/MinimalProxyLibrary.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.7.0;\n\n// solium-disable security/no-inline-assembly\nlibrary MinimalProxyLibrary {\n  function minimalProxy(address _logic) internal pure returns (bytes memory clone) {\n    // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n    bytes20 targetBytes = bytes20(_logic);\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let size := 0x37\n      // allocate output byte array - this could also be done without assembly\n      // by using clone = new bytes(size)\n      clone := mload(0x40)\n      // new \"memory end\" including padding\n      mstore(0x40, add(clone, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n      // store length in memory\n      mstore(clone, size)\n      mstore(add(clone, 0x20), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x34), targetBytes)\n      mstore(add(clone, 0x48), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n    }\n  }\n}\n"}}}