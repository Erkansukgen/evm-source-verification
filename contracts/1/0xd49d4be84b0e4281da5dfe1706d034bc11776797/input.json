{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/picontract/interface/IBalancer.sol": {
      "content": "pragma solidity ^0.7.0;\n\ninterface IBalancer {\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n\n    function getNormalizedWeight(address token) external view returns (uint);\n\n    function getBalance(address token) external view returns (uint);\n\n    function getSwapFee() external view returns (uint);\n\n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    ) external pure returns (uint tokenAmountOut);\n    \n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n}"
    },
    "localhost/picontract/interface/IEntrance.sol": {
      "content": "pragma solidity ^0.7.0;\n\ninterface IEntrance {\n    function calcSwapEthToPiptInputs(\n        uint256 _ethValue,\n        address[] memory _tokens,\n        uint256 _slippage\n    ) external view returns (\n      uint256[] memory tokensInPipt,\n      uint256[] memory ethInUniswap,\n      uint256 poolOut\n    );\n    \n    function calcSwapPiptToEthInputs(\n        uint256 _poolAmountIn, \n        address[] memory _tokens\n    ) external view returns (\n      uint256[] memory tokensOutPipt,\n      uint256[] memory ethOutUniswap,\n      uint256 totalEthOut,\n      uint256 poolAmountFee\n    );\n    \n    function swapEthToPipt(uint256 _slippage) external payable;\n    function swapPiptToEth(uint256 _poolAmountIn) external;\n    \n    function defaultSlippage() external view returns (uint256);\n    \n    function pipt() external view returns (address);\n}"
    },
    "localhost/picontract/interface/IFreeFromUpTo.sol": {
      "content": "pragma solidity ^0.7.0;\n\ninterface IFreeFromUpTo {\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n}"
    },
    "localhost/picontract/interface/IPi.sol": {
      "content": "pragma solidity ^0.7.0;\n\ninterface IPi {\n    function getFinalTokens() external view returns (address[] memory tokens);\n    \n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}"
    },
    "localhost/picontract/interface/IToken.sol": {
      "content": "pragma solidity ^0.7.0;\n\ninterface IToken {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}"
    },
    "localhost/picontract/interface/IWETH.sol": {
      "content": "pragma solidity ^0.7.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n    function balanceOf(address account) external view returns (uint256);\n}"
    },
    "localhost/picontract/picontract.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"./interface/IToken.sol\";\nimport \"./interface/IEntrance.sol\";\nimport \"./interface/IBalancer.sol\";\nimport \"./interface/IWETH.sol\";\nimport \"./interface/IPi.sol\";\nimport \"./interface/IFreeFromUpTo.sol\";\n\ncontract PiTrading {\n    constructor() payable {\n        _trader[msg.sender] = true;\n        _owner = msg.sender;\n    }\n    \n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n    mapping (address => bool) private _trader;\n    address payable _owner;\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IWETH wethContract = IWETH(weth);\n    \n    modifier discountCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        chi.freeFromUpTo(address(this), (gasSpent + 14154) / 41130);\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"onlyOwner: msg.sender not owner\");\n        _;\n    }\n    \n    modifier onlyTrader() {\n        require(_trader[msg.sender], \"onlyTrader: msg.sender not trader\");\n        _;\n    }\n\n    function setTrader(address newTrader) public onlyOwner {\n        _trader[newTrader] = true;\n    }\n    \n    receive() external payable {}\n    \n    function approve(address[] calldata tokens, address spender, uint256 amount) public onlyOwner {\n        for(uint256 i = 0; i < tokens.length; i++) {\n            IToken ercToken = IToken(tokens[i]);\n            ercToken.approve(spender, amount);\n        }\n    }\n\n    function transfer(address token, address spender, uint256 amount) public onlyOwner {\n        IToken ercToken = IToken(token);\n        ercToken.transfer(spender, amount);\n    }\n\n    function withdrawETH() public onlyOwner {\n        if(address(this).balance != 0) {\n            _owner.transfer(address(this).balance);\n        }\n    }\n    \n    function piToBalancerGasOn(\n        address _entrance,\n        address _balancer,\n        uint256 _minAmountOut\n    ) public payable discountCHI onlyTrader {\n        piToBalancer(_entrance, _balancer, _minAmountOut);\n    }\n    \n    function balancerToPiGasOn(\n        address _entrance,\n        address _balancer,\n        uint256 _minAmountOut\n    ) public payable discountCHI onlyTrader {\n        balancerToPi(_entrance, _balancer, _minAmountOut);\n    }\n\n    // _pi 是指 pi token 的合约\n    // _entrance 指 pi token 的铸币合约\n    // _balancer 是 pi token/weth 合约的地址\n    // _minAmountOut 是最后最少需要获得多少 weth \n    function piToBalancer(\n        address _entrance,\n        address _balancer,\n        uint256 _minAmountOut\n    ) public payable onlyTrader {\n        uint256 maxPrice = 1000000000000000000000000000;\n        uint256 ethIn = (msg.value % (1 ether)) * 100;\n        \n        // check balancer profit first to avoid useless gas costing\n        IEntrance entrance = IEntrance(_entrance);\n        address _pi = entrance.pipt();\n        IPi pi = IPi(_pi);\n        (, , uint256 piOut) = entrance.calcSwapEthToPiptInputs(ethIn, pi.getFinalTokens(), entrance.defaultSlippage());\n        \n        IBalancer balancer = IBalancer(_balancer);\n        uint256 ethAmountOut = balancer.calcOutGivenIn(\n            balancer.getBalance(_pi),\n            balancer.getNormalizedWeight(_pi),\n            balancer.getBalance(weth),\n            balancer.getNormalizedWeight(weth),\n            piOut,\n            balancer.getSwapFee()\n        );\n        \n        require(ethAmountOut >= _minAmountOut, \"limit out\");\n\n        // from contract to pi entrance, get pi token\n        entrance.swapEthToPipt{value: ethIn}(entrance.defaultSlippage());\n        uint256 piAmount = pi.balanceOf(address(this));\n\n        // sell defi token at balancer to get weth\n        balancer.swapExactAmountIn(_pi, piAmount, weth, _minAmountOut, maxPrice);\n        \n        wethContract.withdraw(wethContract.balanceOf(address(this)));\n        require(address(this).balance >= ethIn, \"ethOut must > ethIn\");\n        msg.sender.transfer(msg.value);\n    }\n\n    // _pi 是指 pi token 的合约\n    // _entrance 指 pi token 的铸币合约\n    // _balancer 是 pi token/weth 合约的地址\n    // _minAmountOut 是最后最少需要获得多少 weth \n    function balancerToPi(\n        address _entrance,\n        address _balancer,\n        uint256 _minAmountOut\n    ) public payable onlyTrader {\n        uint256 ethIn = (msg.value % (1 ether)) * 100;\n        uint256 maxPrice = 1000000000000000000000000000;\n        \n        IEntrance entrance = IEntrance(_entrance);\n        address _pi = entrance.pipt();\n        IPi pi = IPi(_pi);\n        \n        IBalancer balancer = IBalancer(_balancer);\n        uint256 piAmountOut = balancer.calcOutGivenIn(\n            balancer.getBalance(weth),\n            balancer.getNormalizedWeight(weth),\n            balancer.getBalance(_pi),\n            balancer.getNormalizedWeight(_pi),\n            ethIn,\n            balancer.getSwapFee()\n        );\n        \n        (, , uint256 ethAmountOut, ) = entrance.calcSwapPiptToEthInputs(piAmountOut, pi.getFinalTokens());\n        require(ethAmountOut >= _minAmountOut, \"limit out\");\n        \n        wethContract.deposit{value: msg.value}();\n        \n        // buy token at balancer\n        balancer.swapExactAmountOut(weth, ethIn, _pi, piAmountOut, maxPrice); \n\n        // exit the pie pool\n        uint256 piAmount = pi.balanceOf(address(this));\n        entrance.swapPiptToEth(piAmount);\n        \n        wethContract.withdraw(wethContract.balanceOf(address(this)));\n        \n        // check result \n        require(address(this).balance >= ethIn, \"ethOut must > ethIn\");\n        msg.sender.transfer(msg.value);\n    }\n    \n    function sd() public onlyOwner {\n        selfdestruct(msg.sender);\n    }\n}"
    }
  }
}