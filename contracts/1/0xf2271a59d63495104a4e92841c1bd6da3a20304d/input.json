{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/CarbonEmissions.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./Token.sol\";\nimport \"./Owner.sol\";\nimport \"./libraries/DateTimeLibrary.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./libraries/Rat.sol\";\n\ncontract CarbonEmissions is Token {\n    \n    using SafeMath for uint256;\n    \n    struct _CarbonEmissions {\n        uint256 year;\n        uint256 month;\n        uint256 upperLimit;\n        uint256 margin;\n        uint256 distributionSupply;\n    }\n    \n    struct _Indicator {\n        string desc;\n        uint256 value;\n    }\n\n    _CarbonEmissions[] public carbonEmissionsSequence;\n    \n    uint256 constant DefaultMonthlyCarbonEmissions = 10000000;\n    \n    uint256 totalDistributionSupply;\n    \n    uint256 totalIncreaseUpperLimit;\n    \n    uint256 nextMonthIncreaseUpperLimit;\n    \n    mapping (uint256 => mapping (uint256 => _Indicator[])) indicators;\n    \n    mapping (uint256 => mapping (uint256 => uint256)) indicatorsTotalValue;\n    \n    mapping (uint256 => mapping (uint256 => _CarbonEmissions)) carbonEmissionsList;\n    \n    mapping (uint256 => mapping (uint256 => mapping(address => uint256))) recordList;\n    \n    mapping (uint256 => mapping (uint256 => mapping (address => bool))) currentMonthDistributionPerson;\n    \n    mapping (uint256 => mapping (uint256 => uint256)) currentMonthDistributionPersonNum;\n    \n    event AdditionalIssuance(address add, uint256 value);\n    \n    function distribution() public isNotOwner {\n        (uint256 year, uint256 month, uint256 day) = DateTimeLibrary.timestampToDate(block.timestamp); day;\n\n        // init _CarbonEmissions\n        _CarbonEmissions memory carbonEmissions = carbonEmissionsList[year][month];\n        if (carbonEmissions.year != year) {\n            carbonEmissionsList[year][month] = _CarbonEmissions({year: year, month: month, upperLimit: DefaultMonthlyCarbonEmissions + indicatorsTotalValue[year][month], margin: DefaultMonthlyCarbonEmissions + indicatorsTotalValue[year][month], distributionSupply: 0});\n        }\n        carbonEmissions = carbonEmissionsList[year][month];\n        \n        require(carbonEmissions.margin > 0, \"Insufficient carbon emissions margin this month.\");\n        require(currentMonthDistributionPerson[year][month][msg.sender] == false, \"Already distribution this month, please come back next month\");\n        \n        // Generate random numbers\n        uint256 random;\n        while (random > carbonEmissions.margin || random == 0) {\n            random = rand(carbonEmissions.upperLimit.rat(Rat._Rat({molecular: 1, denominator: 1000})));\n            if (random == 0) random = 1;\n        }\n        \n        // Record distribution address\n        if (isRecord[msg.sender] == false) {\n            isRecord[msg.sender] = true;\n            addressIndices.push(msg.sender);\n        }\n        \n        // Every address is distributed once a month\n        currentMonthDistributionPerson[year][month][msg.sender] = true;\n        currentMonthDistributionPersonNum[year][month] += 1;\n        recordList[year][month][msg.sender] = random;\n        \n        carbonEmissions.margin -= random;\n        carbonEmissions.distributionSupply += random;\n        totalDistributionSupply = totalDistributionSupply.add(random);\n        balances[msg.sender] = balances[msg.sender].add(random * (10 ** 18));\n        carbonEmissionsList[year][month] = carbonEmissions;\n    }\n    \n    function rand(uint256 _length) internal view returns(uint256) {\n        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));\n        return random%_length;\n    }\n    \n    function increaseUpperLimit(uint256 _value, string memory _desc) public isOwner {\n        uint256 nextMonth = DateTimeLibrary.addMonths(block.timestamp, 1);\n        (uint256 year, uint256 month, uint256 day) = DateTimeLibrary.timestampToDate(nextMonth); day;\n        indicators[year][month].push(_Indicator({desc: _desc, value: _value}));\n        indicatorsTotalValue[year][month] += _value;\n        totalIncreaseUpperLimit += _value;\n    }\n    \n    function getIndicators(uint256 _time) public view returns (_Indicator[] memory) {\n        (uint256 year, uint256 month, uint256 day) = DateTimeLibrary.timestampToDate(_time); day;\n        return indicators[year][month];\n    }\n    \n    function getTotalMargin() public view returns (uint256) {\n        return (totalSupply / (10 ** 18)) + totalIncreaseUpperLimit - totalDistributionSupply;\n    }\n    \n    function additionalIssuance(uint256 _value) public isOwner returns (bool) {\n        for (uint256 i = 0; i < addressIndices.length; i++) {\n            uint256 value = _value.rat(Rat._Rat({molecular: balances[addressIndices[i]], denominator: totalDistributionSupply}));\n            balances[addressIndices[i]] = balances[addressIndices[i]].add(value);\n            emit AdditionalIssuance(addressIndices[i], value);\n        }\n        totalDistributionSupply += _value;\n        return true;\n    }\n    \n    function getDistributionSupply(uint256 _time, address _owner) public view returns (uint256) {\n         (uint256 year, uint256 month, uint256 day) = DateTimeLibrary.timestampToDate(_time); day;\n         return recordList[year][month][_owner];\n    }\n    \n    function getTotalDistributionSupply() public view returns (uint256) {\n        return totalDistributionSupply;\n    }\n    \n    function getDistributionInfo(uint _time) public view returns (_CarbonEmissions memory) {\n        (uint256 year, uint256 month, uint256 day) = DateTimeLibrary.timestampToDate(_time); day;\n        return  carbonEmissionsList[year][month];\n    }\n    \n    function getIsDistribution(address _owner) public view returns (bool) {\n        (uint256 year, uint256 month, uint256 day) = DateTimeLibrary.timestampToDate(block.timestamp); day;\n        return currentMonthDistributionPerson[year][month][_owner];\n    }\n    \n    function getCurrentMonthDistributionPersonNum() public view returns (uint256) {\n        (uint256 year, uint256 month, uint256 day) = DateTimeLibrary.timestampToDate(block.timestamp); day;\n        return currentMonthDistributionPersonNum[year][month];\n    }\n}\n"
    },
    "contracts/Mie.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./Token.sol\";\nimport \"./CarbonEmissions.sol\";\n\ncontract Mie is Token, CarbonEmissions {\n    \n    constructor() {\n        name = \"MIE\";\n        symbol = \"MIE\";\n        decimals = 18;\n        totalSupply = 20 * (10 ** 9) * (10 ** 18);\n        \n        balances[msg.sender] = 13 * (10 ** 9) * (10 ** 18);\n    }\n}\n"
    },
    "contracts/Owner.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Owner\n * @dev Set & change owner\n */\ncontract Owner {\n\n    address private owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use 'require' to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    modifier isNotOwner() {\n        require(msg.sender != owner, \"Caller is owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() {\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}\n"
    },
    "contracts/Pledger.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./Owner.sol\";\n\ncontract Pledger is Owner {\n    \n    address private pledger;\n    \n    event PledgerSet(address oldPledger, address newPledger);\n    \n    modifier isPledger() {\n        require(msg.sender == pledger, \"Caller is not pledger\");\n        _;\n    }\n    \n    function changePledger(address _newPledger) public isOwner returns (bool) {\n        emit PledgerSet(pledger, _newPledger);\n        pledger = _newPledger;\n        return true;\n    }\n    \n    function getPledger() external view returns (address) {\n        return pledger;\n    }\n}\n"
    },
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./Owner.sol\";\nimport \"./Pledger.sol\";\nimport \"./extensions/IToken.sol\";\nimport \"./libraries/SafeMath.sol\";\n\ncontract Token is IToken, Owner, Pledger {\n    \n    using SafeMath for uint256;\n    \n    uint constant DefaultTokenConversionRate = 1000;\n    \n    string public name;\n    \n    string public symbol;\n    \n    uint8 public decimals;\n    \n    uint256 public totalSupply;\n    \n    address[] addressIndices;\n    \n    mapping (address => bool) isRecord;\n    \n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n    \n    event AdditionalIssuance(uint256 value);\n    \n    modifier isAdequateSupply(uint256 value) {\n        require(value * DefaultTokenConversionRate >= totalSupply , \"Insufficient total supply.\");\n        _;\n    }\n    \n    /**\n     * @dev Gets the balance of the _owner address.\n     */\n    function balanceOf(address _owner) override public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n    function allowance(address _owner, address _spender) override public view returns (uint256) {\n        return _allowed[_owner][_spender];\n    }\n    \n    function transfer(address _to, uint256 _value) override public returns (bool success) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n        \n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        \n        // Record transfer address\n        if (isRecord[_to] == false) {\n            isRecord[_to] = true;\n            addressIndices.push(_to);\n        }\n        \n        emit Transfer(msg.sender, _to, _value);\n        \n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) override public returns (bool) {\n        require(_spender != address(0));\n        \n        _allowed[msg.sender][_spender] = _value;\n        \n        emit Approval(msg.sender, _spender, _value);\n        \n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool) {\n        require(_value <= balances[_from]);\n        require(_value <= _allowed[_from][msg.sender]);\n        require(_to != address(0));\n        \n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n        \n        // Record transfer address\n        if (isRecord[_to] == false) {\n            isRecord[_to] = true;\n            addressIndices.push(_to);\n        }\n        \n        emit Transfer(_from, _to, _value);\n        \n        return true;\n    }\n    \n    function additionalTotalSupply(uint256 _value) public isOwner returns (bool) {\n        totalSupply += _value;\n        \n        emit AdditionalIssuance(_value);\n        \n        return true;\n    }\n    \n    function changeBalance(address _owner, uint256 _value) public isPledger returns (bool) {\n        balances[_owner] = _value;\n        return true;\n    }\n    \n    function changeTotalSupply(uint256 _value) public isPledger returns (bool) {\n        totalSupply = _value;\n        return true;\n    }\n}\n"
    },
    "contracts/extensions/IToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IToken {\n    \n    // /**\n    //  * @dev Returns the name of the token.\n    //  */\n    // function name() external view returns (string memory);\n\n    // /**\n    //  * @dev Returns the symbol of the token.\n    //  */\n    // function symbol() external view returns (string memory);\n\n    // /**\n    //  * @dev Returns the decimals places of the token.\n    //  */\n    // function decimals() external view returns (uint8);\n    \n    // /**\n    //  * @dev Returns the total token supply.\n    //  */\n    // function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the account balance of another account with address _owner.\n     */ \n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\n     */ \n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /**\n     * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. \n     * The function SHOULD throw if the message caller's account balance does not have enough tokens to spend.\n     */ \n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /**\n     * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. \n     * If this function is called again it overwrites the current allowance with _value.\n     */\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    /**\n     * Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"
    },
    "contracts/libraries/DateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary DateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"
    },
    "contracts/libraries/Rat.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @title Rat\n */\nlibrary Rat {\n    \n    // Default denominator\n    uint constant DefaultDenominator = 100;\n    \n    // Express floating point by way of numerator and denominator\n    struct _Rat {\n        uint256 molecular;\n        uint256 denominator;\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"./Rat.sol\";\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n  \n  /**\n   * @dev Integer multiplied by floating point.\n   */\n  function rat(uint256 a, Rat._Rat memory b) internal pure returns (uint256) {\n      return div(mul(a, b.molecular), b.denominator);\n  }\n}\n"
    }
  }
}