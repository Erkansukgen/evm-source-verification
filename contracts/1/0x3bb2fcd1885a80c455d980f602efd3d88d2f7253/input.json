{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ADCION.sol":{"content":"pragma solidity >=0.5.0 <0.7.0;\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n\n\ncontract Coin {\n    using SafeMath for uint;\n   \n    string public constant name       = \"hdsbtc\";\n    string public constant symbol     = \"HDS\";\n    uint32 public constant decimals   = 6;\n    uint256 public  _totalSupply  =   2100000000;\n    \n    mapping(address => uint256) balances;\n\tmapping(address => mapping (address => uint256)) internal allowed;\n\tmapping(address => bool) public frozenAccount;\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    // 事件，用来通知客户端代币被消费\n    event Burn(address indexed from, uint256 value);\n    \n    // Constructor code is only run when the contract\n    // is created\n    constructor(\n        uint256 initialSupply,\n        address add_ad\n    ) public {\n        _totalSupply = initialSupply * 10 ** uint256(decimals);  \n        balances[add_ad] = _totalSupply;                \n        emit Transfer(msg.sender, add_ad, _totalSupply);\n    }\n    \n    function totalSupply() public view returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\t\tif(!frozenAccount[msg.sender]){\n\t\t    balances[msg.sender] = balances[msg.sender].sub(_value);\n\t\t    balances[_to] = balances[_to].add(_value);\n\t\t    emit Transfer(msg.sender, _to, _value);\n\t\t    return true;\n\t\t}else{\n\t\t    return false;\n\t\t}\n\t\t\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\t\tif(!frozenAccount[_from]){\n\t\t    balances[_from] = balances[_from].sub(_value);\n\t\t    balances[_to] = balances[_to].add(_value);\n\t\t    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\t    emit Transfer(_from, _to, _value);\n\t\t    return true;\n\t\t}else{\n\t\t    return false;\n\t\t}\n\t\t\n\t}\n\t\n\tfunction multiTransfer(address[] memory destinations, uint256[] memory tokens) public returns (bool) {\n\t    require(destinations.length > 0);\n        require(destinations.length < 128);\n\t\t\n\t\tuint8 i = 0;\n\t\tfor (i = 0; i < destinations.length; i++){\n            if(!frozenAccount[msg.sender]){\n                require(destinations[i] != address(0));\n                require(tokens[i] <= balances[msg.sender]);\n    \t\t    balances[msg.sender] = balances[msg.sender].sub(tokens[i]);\n    \t\t    balances[destinations[i]] = balances[destinations[i]].add(tokens[i]);\n    \t\t    emit Transfer(msg.sender, destinations[i], tokens[i]);\n    \t\t}\n        }\n        return true;\n\t}\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n    \n}"}}}