{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "WickedStaking.sol": {
      "content": "// Sources flattened with hardhat v2.6.4 https://hardhat.org\n\n// File @openzeppelin/contracts/utils/Context.sol@v4.3.2\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.2\n\n\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n\n// File contracts/WickedStaking.sol\n\n\npragma solidity ^0.8.0;\n\nabstract contract TWC {\n    function ownerOf(uint256 tokenId) public view virtual returns (address);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256);\n\n    function balanceOf(address owner) external view virtual returns (uint256 balance);\n\n    function setApprovalForAll(address operator, bool _approved) external virtual;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual;\n}\n\nabstract contract TWS {\n    function ownerOf(uint256 tokenId) public view virtual returns (address);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256);\n\n    function balanceOf(address owner) external view virtual returns (uint256 balance);\n\n    function setApprovalForAll(address operator, bool _approved) external virtual;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external virtual;\n}\n\nabstract contract WickedCraniumsComic {\n    function ownerOf(uint256 tokenId) external view virtual returns (address);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view virtual returns (uint256);\n\n    function balanceOf(address owner) external view virtual returns (uint256 balance);\n\n    function safeMint(address to) public virtual;\n}\n\nabstract contract WickedCraniumsXHaylos {\n    function ownerOf(uint256 tokenId) external view virtual returns (address);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view virtual returns (uint256);\n\n    function balanceOf(address owner) external view virtual returns (uint256 balance);\n\n    function safeMint(address to) public virtual;\n}\n\ncontract WickedStaking is Ownable {\n    TWC private twc = TWC(0x85f740958906b317de6ed79663012859067E745B);\n    TWS private tws = TWS(0x45d8f7Db9b437efbc74BA6a945A81AaF62dcedA7);\n    WickedCraniumsComic private comic = WickedCraniumsComic(0xA932DaC13BED512aaa12975f7aD892afB120022f);\n    WickedCraniumsXHaylos private haylos = WickedCraniumsXHaylos(0xB8bD00aA3a8fa212E0654c7382c1c7936c9728e6);\n\n    mapping(address => uint256) private pagesUnredeemed;\n    mapping(address => uint256[]) private addressToCraniumsStaked;\n    mapping(address => uint256[]) private addressToStallionsStaked;\n    mapping(address => uint256) private unstakedIndex;\n\n    bool public isStakingActive = false;\n    bool public areComicPagesRedeemable = false;\n    bool public isUnstakingActive = false;\n\n    constructor() {}\n\n    function flipStakingState() public onlyOwner {\n        isStakingActive = !isStakingActive;\n    }\n\n    function flipComicRedeemableState() public onlyOwner {\n        areComicPagesRedeemable = !areComicPagesRedeemable;\n    }\n\n    function flipUnstakingState() public onlyOwner {\n        isUnstakingActive = !isUnstakingActive;\n    }\n\n    function stake(uint256[] memory craniumIds, uint256[] memory stallionIds) public {\n        require(isStakingActive, \"stake: staking must be active\");\n        require(craniumIds.length == stallionIds.length, \"stake: Total number of Craniums staked must match the total number of Stallions staked.\");\n        require(craniumIds.length >= 1, \"stake: 1 or more {Cranium, Stallion} pairs must be staked.\");\n\n        for (uint256 i = 0; i < craniumIds.length; i++) {\n            require(twc.ownerOf(craniumIds[i]) == msg.sender, \"stake: msg.sender must be the owner of all Craniums staked.\");\n        }\n\n        for (uint256 i = 0; i < stallionIds.length; i++) {\n            require(tws.ownerOf(stallionIds[i]) == msg.sender, \"stake: msg.sender must be the owner of all Stallions staked.\");\n        }\n\n        // twc.setApprovalForAll(address(this), true);\n        // tws.setApprovalForAll(address(this), true);\n\n        for (uint256 i = 0; i < craniumIds.length; i++) {\n            twc.transferFrom(msg.sender, address(this), craniumIds[i]);\n        }\n\n        for (uint256 i = 0; i < stallionIds.length; i++) {\n            tws.transferFrom(msg.sender, address(this), stallionIds[i]);\n        }\n\n        for (uint256 i = 0; i < craniumIds.length; i++) {\n            haylos.safeMint(msg.sender);\n        }\n\n        pagesUnredeemed[msg.sender] += craniumIds.length;\n\n        for (uint256 i = 0; i < craniumIds.length; i++) {\n            addressToCraniumsStaked[msg.sender].push(craniumIds[i]);\n            addressToStallionsStaked[msg.sender].push(stallionIds[i]);\n        }\n    }\n\n    function redeemComicPages(uint256 pagesToRedeem) public {\n        require(areComicPagesRedeemable, \"redeeming comic pages is not active\");\n        require(pagesToRedeem > 0, \"redeemComicPages: Can only request to redeem > 0 pages\");\n        require(pagesToRedeem <= pagesUnredeemed[msg.sender], \"redeemComicPages: pages to redeem must be <= pages unredeemed for this address\");\n\n        for (uint256 i = 0; i < pagesToRedeem; i++) {\n            comic.safeMint(msg.sender);\n        }\n\n        pagesUnredeemed[msg.sender] -= pagesToRedeem;\n    }\n\n    function redeemAllComicPages() public {\n        require(areComicPagesRedeemable, \"redeeming comic pages is not active\");\n        require(pagesUnredeemed[msg.sender] > 0, \"redeemAllComicPages: pages unredeemed for this address should be > 0\");\n\n        uint256 pagesToRedeem = pagesUnredeemed[msg.sender];\n\n        for (uint256 i = 0; i < pagesToRedeem; i++) {\n            comic.safeMint(msg.sender);\n        }\n\n        pagesUnredeemed[msg.sender] -= pagesToRedeem;\n    }\n\n    function unstakeAll() public {\n        require(isUnstakingActive, \"unstaking is not active\");\n        require(addressToCraniumsStaked[msg.sender].length > 0, \"unstakeAll: craniums staked for this address should be > 0\");\n        require(unstakedIndex[msg.sender] < addressToCraniumsStaked[msg.sender].length, \"unstakeAll: unstake index must be less than total staked\");\n\n        uint256[] memory craniumsToUnstake = addressToCraniumsStaked[msg.sender];\n        uint256[] memory stallionsToUnstake = addressToStallionsStaked[msg.sender];\n\n        for (uint256 i = unstakedIndex[msg.sender]; i < craniumsToUnstake.length; i++) {\n            twc.transferFrom(address(this), msg.sender, craniumsToUnstake[i]);\n            tws.transferFrom(address(this), msg.sender, stallionsToUnstake[i]);\n        }\n\n        unstakedIndex[msg.sender] += craniumsToUnstake.length;\n    }\n\n    function unstakeSome(uint256 totalToUnstake) public {\n        require(isUnstakingActive, \"unstaking is not active\");\n        require(totalToUnstake > 0, \"cannot unstake 0 or less pairs\");\n        require(\n            totalToUnstake <= addressToCraniumsStaked[msg.sender].length - unstakedIndex[msg.sender],\n            \"unstakeSome: totalToUnstake <= total staked - unstakedIndex\"\n        );\n\n        uint256[] memory craniumsStaked = addressToCraniumsStaked[msg.sender];\n        uint256[] memory stallionsStaked = addressToStallionsStaked[msg.sender];\n\n        for (uint256 i = unstakedIndex[msg.sender]; i < unstakedIndex[msg.sender] + totalToUnstake; i++) {\n            twc.transferFrom(address(this), msg.sender, craniumsStaked[i]);\n            tws.transferFrom(address(this), msg.sender, stallionsStaked[i]);\n        }\n\n        unstakedIndex[msg.sender] += totalToUnstake;\n    }\n}"
    }
  }
}