{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/IERC20.sol":{"content":"pragma solidity ^0.6.1;\r\n\r\ninterface ERC20TokenInterface {\r\n    function totalSupply() external view returns (uint);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint256);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}"},"browser/erctoken.sol":{"content":"pragma solidity ^0.6.1;\r\n\r\nimport {ERC20TokenInterface} from './IERC20.sol';\r\n\r\ncontract ERC20 is ERC20TokenInterface{\r\n    string internal tName;\r\n    string internal tSymbol;\r\n    uint256 internal tTotalSupply;\r\n    uint256 internal  tdecimals;\r\n    address public owner;\r\n    uint256 internal maxSupply;\r\n    uint internal percentage; \r\n    // uint256 public updateSupply;\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allownce;\r\n    \r\n    event test(string);\r\n\r\n    constructor(string memory _tokenName,string memory _symbol,uint256 _totalSupply,uint256 _decimals, uint256 _MaxSupply, uint _percentageGrowth)public{\r\n        tName = _tokenName;\r\n        tSymbol = _symbol;\r\n        balances[msg.sender] += _totalSupply;\r\n        tTotalSupply = _totalSupply;\r\n        tdecimals = _decimals;\r\n        owner = msg.sender;\r\n        maxSupply = _MaxSupply;\r\n        percentage = _percentageGrowth;\r\n    }\r\n    \r\n    function name() override public view returns(string memory) { return tName;}\r\n    function symbol() override public view returns(string memory) { return tSymbol;}\r\n    function totalSupply()override  public view returns(uint256) { return tTotalSupply;}\r\n    function decimals() override public view returns(uint256) { return tdecimals;}\r\n\r\n    function balanceOf(address tokenOwner) override public view returns(uint256){ return balances[tokenOwner]; }\r\n\r\n    function transfer(address to, uint token) override public  returns(bool success){\r\n        require(balances[msg.sender] >= token, \"you should have some token\");\r\n        uint local_supply = tTotalSupply * percentage;\r\n        uint supply = local_supply /100;\r\n        balances[msg.sender] -= token;\r\n        balances[to] += token;\r\n        emit Transfer(msg.sender,to,token);\r\n        \r\n        if(balances[owner] <= maxSupply){\r\n            // updateSupply = balances[owner] + supply;\r\n            if(tTotalSupply >= maxSupply) {\r\n               return true;\r\n            }\r\n            balances[owner] += supply;\r\n            tTotalSupply += supply;\r\n            emit test(\"from tramsfer function\");\r\n        }\r\n        return true;\r\n    }\r\n    function approve(address spender, uint tokens) override public returns(bool success) {\r\n        require((tokens == 0) || (allownce[msg.sender][spender] == 0));\r\n        allownce[msg.sender][spender] += tokens;\r\n        emit Approval(msg.sender, spender,tokens);\r\n        return true;\r\n\r\n    }\r\n    function allowance(address _owner, address spender) override public view returns(uint){\r\n        return allownce[_owner][spender];\r\n    }\r\n    function transferFrom(address from, address to, uint tokens) override public returns(bool success) {\r\n        require(balances[from] >= tokens);\r\n        require(allownce[from][msg.sender] >= tokens);\r\n        uint local_supply = tTotalSupply * percentage;\r\n        uint supply = local_supply /100;\r\n        balances[from] -= tokens;\r\n        balances[to] += tokens;\r\n        allownce[from][msg.sender] -= tokens;\r\n        emit Transfer(from,to,tokens);\r\n        \r\n        if(balances[owner] <= maxSupply){\r\n            // updateSupply = balances[owner] + supply;\r\n            if(tTotalSupply >= maxSupply) {\r\n               return true;\r\n            }\r\n            balances[owner] += supply;\r\n            tTotalSupply += supply;\r\n            emit test(\"from tramsfer function\");\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n}"}}}