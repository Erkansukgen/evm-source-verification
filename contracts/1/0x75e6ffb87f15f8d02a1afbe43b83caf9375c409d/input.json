{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/DegenBridge.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-10-01\n*/\n\n// SPDX-License-Identifier: No License (None)\npragma solidity ^0.8.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(),\"Not Owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0),\"Zero address not allowed\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IGatewayVault {\n    function vaultTransfer(address token, address recipient, uint256 amount) external returns (bool);\n    function vaultApprove(address token, address spender, uint256 amount) external returns (bool);\n}\n\ninterface IDegen {\n    enum OrderType {EthForTokens, TokensForEth, TokensForTokens}\n    function callbackCrossExchange(OrderType orderType, address[] memory path, uint256 assetInOffered, address user, uint256 dexId, uint256[] memory distribution, uint256 deadline)\n    external returns(bool);\n}\n\ninterface IBEP20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function mint(address to, uint256 amount) external returns (bool);\n    function burnFrom(address account, uint256 amount) external returns(bool);\n}\n\ncontract DegenBridge is Ownable {\n    \n    address public USDT = address(0);\n\n    uint256 _nonce = 0;\n    mapping(uint256 => bool) public nonceProcessed;\n    \n    mapping(uint256 => IDegen.OrderType) private _orderType;\n\n    address public system;  // system address may change fee amount\n    bool public paused;\n    address public gatewayVault; // GatewayVault contract\n    address public degenContract;\n    \n    event SwapRequest(\n        address indexed tokenA, \n        address indexed tokenB, \n        address indexed user, \n        uint256 amount,\n        uint256 crossOrderType, \n        uint256 nonce,\n        uint256 dexId,\n        uint256[] distribution,\n        uint256 deadline\n    );\n\n    // event ClaimRequest(address indexed tokenA, address indexed tokenB, address indexed user, uint256 amount);\n    event ClaimApprove(\n        address indexed tokenA, \n        address indexed tokenB, \n        address indexed user, \n        uint256 amount, \n        uint256 crossOrderType,\n        uint256 dexId,\n        uint256[] distribution,\n        uint256 deadline\n    );\n\n    modifier notPaused() {\n        require(!paused,\"Swap paused\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the system.\n    */\n    modifier onlySystem() {\n        require(msg.sender == system || owner() == msg.sender,\"Caller is not the system\");\n        _;\n    }\n\n    constructor (address _system, address _gatewayVault, address _usdt) {\n        system = _system;\n        gatewayVault = _gatewayVault;\n        USDT = _usdt;\n        _orderType[0] = IDegen.OrderType.TokensForTokens;\n        _orderType[1] = IDegen.OrderType.TokensForEth;\n        _orderType[2] = IDegen.OrderType.TokensForTokens;\n        _orderType[3] = IDegen.OrderType.TokensForEth;\n    }\n\n\n    function setDegenContract(address _degenContract) external onlyOwner returns(bool) {\n        degenContract = _degenContract;\n        return true;\n    }\n\n    function setGatewayVault(address _gatewayVault) external onlyOwner returns(bool) {\n        gatewayVault = _gatewayVault;\n        return true;\n    }\n\n    function setSystem(address _system) external onlyOwner returns(bool) {\n        system = _system;\n        return true;\n    }\n    \n    function setUSDT(address _usdt) external onlyOwner returns(bool) {\n        USDT = _usdt;\n        return true;\n    }\n    \n    function setPause(bool pause) external onlyOwner returns(bool) {\n        paused = pause;\n        return true;\n    }\n\n    function getTransactionStatus(uint256 nonce) external view returns (bool){\n      return nonceProcessed[nonce];\n    }\n\n\n    //user should approve tokens transfer before calling this function.\n    // for local swap (tokens on the same chain): pair = address(1) when TokenA = JNTR, and address(2) when TokenB = JNTR\n    function swap(address tokenA, address tokenB, uint256 amount, address user, uint256 crossOrderType, uint256 dexId, uint256[] memory distribution, uint256 deadline) \n    external payable notPaused returns (bool) {\n        require(msg.sender == degenContract, \"Only Degen\");\n        require(amount != 0, \"Zero amount\");\n        require(gatewayVault != address(0), \"No vault address\");\n        require(deadline >= block.timestamp, \"EXPIRED: Deadline for bridge transaction already passed.\");\n        IBEP20(tokenA).transferFrom(msg.sender, gatewayVault, amount);\n        _nonce = _nonce+1;\n        emit SwapRequest(tokenA, tokenB, user, amount, crossOrderType, _nonce, dexId, distribution, deadline);\n        return true;\n    }\n\n   \n    function claimTokenBehalf(address[] memory path, address user, uint256 amount, uint256 crossOrderType, uint256 nonce, uint256 dexId, uint256[] memory distribution, uint256 deadline)\n    external onlySystem notPaused returns (bool) {\n        require(!nonceProcessed[nonce], \"Exchange already processed\");\n        \n        _claim(path, user, amount, crossOrderType, dexId, distribution, deadline);\n        nonceProcessed[nonce] = true;\n        return true;\n    }\n\n\n    function _claim (address[] memory path, address user, uint256 amount, uint256 crossOrderType, uint256 dexId, uint256[] memory distribution, uint256 deadline) \n    internal returns(bool) {\n        require(deadline >= block.timestamp, \"EXPIRED: Deadline for claim transaction already passed.\");\n        if(path[path.length-1] == USDT) {\n            IGatewayVault(gatewayVault).vaultTransfer(USDT, user, amount); \n        } \n        else {\n            IGatewayVault(gatewayVault).vaultTransfer(USDT, degenContract, amount); \n            IDegen(degenContract).callbackCrossExchange(_orderType[crossOrderType], path, amount, user, dexId, distribution, deadline);\n        }\n        emit ClaimApprove(path[0], path[path.length-1], user, amount, crossOrderType, dexId, distribution, deadline);\n        // emit ClaimRequest(tokenA, tokenB, user,amount);\n        return true;\n    }\n}"
    }
  }
}