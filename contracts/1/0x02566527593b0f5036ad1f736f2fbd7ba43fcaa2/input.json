{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"sonm_swap.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IERC20Old {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external;\n    function transferFrom(address sender, address recipient, uint256 amount) external;\n}\n\ninterface IERC20New {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenSwaper {\n    using SafeMath for uint256;\n\n    address public newTokenAddr = 0x46d0DAc0926fa16707042CAdC23F1EB4141fe86B;\n    address public oldTokenAddr = 0x983F6d60db79ea8cA4eB9968C6aFf8cfA04B3c63;\n    address public newApprover;\n    address public oldApprover;\n    address public owner;\n    \n    uint256 public toNewDeadline;\n    uint256 public toOldDeadline;\n    uint256 public toNewRate;\n\n    constructor(\n        address _newApprover,\n        address _oldApprover,\n        uint256 _toNewDeadline,\n        uint256 _toOldDeadline,\n        uint256 _toNewRate\n    ) \n        public \n    {\n        newApprover = _newApprover;\n        oldApprover = _oldApprover;\n        toNewDeadline = _toNewDeadline;\n        toOldDeadline = _toOldDeadline;\n        toNewRate = _toNewRate;\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n\n    function SwapToNew(uint256 _amount) external {\n        require(block.number <= toNewDeadline, \"toNew: ended\");\n        IERC20Old(oldTokenAddr).transferFrom(msg.sender, address(this), _amount);\n        uint256 newAmount = _amount.div(toNewRate);\n        uint256 newBal = IERC20New(newTokenAddr).balanceOf(address(this));\n        if(newBal >= newAmount){\n            IERC20New(newTokenAddr).transfer(msg.sender, newAmount);\n        }else{\n            IERC20New(newTokenAddr).transferFrom(newApprover, msg.sender, newAmount);\n        }\n    }\n\n    function SwapToOld(uint256 _amount) external {\n        require(block.number <= toOldDeadline, \"toOld: ended\");\n        IERC20New(newTokenAddr).transferFrom(msg.sender, address(this), _amount);\n        uint256 oldAmount = _amount.mul(toNewRate);\n        uint256 oldBal = IERC20Old(oldTokenAddr).balanceOf(address(this));\n        if(oldBal >= oldAmount){\n            IERC20Old(oldTokenAddr).transfer(msg.sender, oldAmount);\n        }else{\n            IERC20Old(oldTokenAddr).transferFrom(oldApprover, msg.sender, oldAmount);\n        }\n    }\n\n    function withdraw(address _token, uint256 _amount) external onlyOwner {\n        if(_token == oldTokenAddr){\n            IERC20Old(_token).transfer(msg.sender, _amount);\n        }else{\n            IERC20New(_token).transfer(msg.sender, _amount);\n        }\n    }\n\n    function setToOldDeadline(uint256 _toOldDeadline) external onlyOwner {\n        toOldDeadline = _toOldDeadline;\n    }\n\n    function setToNewDeadline(uint256 _toNewDeadline) external onlyOwner {\n        toNewDeadline = _toNewDeadline;\n    }\n\n    function setOldApprover(address _oldApprover) external onlyOwner {\n        oldApprover = _oldApprover;\n    }\n\n    function setNewApprover(address _newApprover) external onlyOwner {\n        newApprover = _newApprover;\n    }\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        return c;\n    }\n\n}"}}}