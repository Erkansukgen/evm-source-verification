{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Spotter.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2019-11-14\n*/\n\n// hevm: flattened sources of /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/spot.sol\npragma solidity =0.5.12;\n\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/lib.sol\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.5.12; */\n\ncontract LibNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  usr,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: selector, caller, arg1 and arg2\n            let mark := msize                         // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 caller,                              // msg.sender\n                 calldataload(4),                     // arg1\n                 calldataload(36)                     // arg2\n                )\n        }\n    }\n}\n\n////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/spot.sol\n/// spot.sol -- Spotter\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.5.12; */\n\n/* import \"./lib.sol\"; */\n\ncontract VatLike {\n    function file(bytes32, bytes32, uint) external;\n}\n\ncontract PipLike {\n    function peek() external returns (bytes32, bool);\n}\n\ncontract Spotter is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address guy) external note auth { wards[guy] = 1;  }\n    function deny(address guy) external note auth { wards[guy] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Spotter/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Ilk {\n        PipLike pip;\n        uint256 mat;\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    VatLike public vat;\n    uint256 public par; // ref per dai\n\n    uint256 public live;\n\n    // --- Events ---\n    event Poke(\n      bytes32 ilk,\n      bytes32 val,\n      uint256 spot\n    );\n\n    // --- Init ---\n    constructor(address vat_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n        par = ONE;\n        live = 1;\n    }\n\n    // --- Math ---\n    uint constant ONE = 10 ** 27;\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = mul(x, ONE) / y;\n    }\n\n    // --- Administration ---\n    function file(bytes32 ilk, bytes32 what, address pip_) external note auth {\n        require(live == 1, \"Spotter/not-live\");\n        if (what == \"pip\") ilks[ilk].pip = PipLike(pip_);\n        else revert(\"Spotter/file-unrecognized-param\");\n    }\n    function file(bytes32 what, uint data) external note auth {\n        require(live == 1, \"Spotter/not-live\");\n        if (what == \"par\") par = data;\n        else revert(\"Spotter/file-unrecognized-param\");\n    }\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\n        require(live == 1, \"Spotter/not-live\");\n        if (what == \"mat\") ilks[ilk].mat = data;\n        else revert(\"Spotter/file-unrecognized-param\");\n    }\n\n    // --- Update value ---\n    function poke(bytes32 ilk) external {\n        (bytes32 val, bool has) = ilks[ilk].pip.peek();\n        uint256 spot = has ? rdiv(rdiv(mul(uint(val), 10 ** 9), par), ilks[ilk].mat) : 0;\n        vat.file(ilk, \"spot\", spot);\n        emit Poke(ilk, val, spot);\n    }\n\n    function cage() external note auth {\n        live = 0;\n    }\n}\n"
    }
  }
}