{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Untitled.sol":{"content":"pragma solidity >=0.6.0 <0.7.0;\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\n\ninterface ERC20Token {\n\n    /**\n     * @notice send `_value` token to `_to` from `msg.sender`\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return success Whether the transfer was successful or not\n     */\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /**\n     * @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @param _value The amount of tokens to be approved for transfer\n     * @return success Whether the approval was successful or not\n     */\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /**\n     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return success Whether the transfer was successful or not\n     */\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /**\n     * @param _owner The address from which the balance will be retrieved\n     * @return balance The balance\n     */\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /**\n     * @param _owner The address of the account owning tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @return remaining Amount of remaining tokens allowed to spent\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    /**\n     * @notice return total supply of tokens\n     */\n    function totalSupply() external view returns (uint256 supply);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract ReentrancyGuard {\n\n    bool internal reentranceLock = false;\n\n    /**\n     * @dev Use this modifier on functions susceptible to reentrancy attacks\n     */\n    modifier reentrancyGuard() {\n        require(!reentranceLock, \"Reentrant call detected!\");\n        reentranceLock = true; // No no no, you naughty naughty!\n        _;\n        reentranceLock = false;\n    }\n}\npragma experimental ABIEncoderV2;\n\n\n\n\n\n/**\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\n * @notice interface for StickerMarket\n */\ninterface StickerMarket {\n\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n    event MarketState(State state);\n    event RegisterFee(uint256 value);\n    event BurnRate(uint256 value);\n\n    enum State { Invalid, Open, BuyOnly, Controlled, Closed }\n\n    function state() external view returns(State);\n    function snt() external view returns (address);\n    function stickerPack() external view returns (address);\n    function stickerType() external view returns (address);\n\n    /**\n     * @dev Mints NFT StickerPack in `_destination` account, and Transfers SNT using user allowance\n     * emit NonfungibleToken.Transfer(`address(0)`, `_destination`, `tokenId`)\n     * @notice buy a pack from market pack owner, including a StickerPack's token in `_destination` account with same metadata of `_packId`\n     * @param _packId id of market pack\n     * @param _destination owner of token being brought\n     * @param _price agreed price\n     * @return tokenId generated StickerPack token\n     */\n    function buyToken(\n        uint256 _packId,\n        address _destination,\n        uint256 _price\n    )\n        external\n        returns (uint256 tokenId);\n\n    /**\n     * @dev emits StickerMarket.Register(`packId`, `_urlHash`, `_price`, `_contenthash`)\n     * @notice Registers to sell a sticker pack\n     * @param _price cost in wei to users minting this pack\n     * @param _donate value between 0-10000 representing percentage of `_price` that is donated to StickerMarket at every buy\n     * @param _category listing category\n     * @param _owner address of the beneficiary of buys\n     * @param _contenthash EIP1577 pack contenthash for listings\n     * @param _fee Fee msg.sender agrees to pay for this registration\n     * @return packId Market position of Sticker Pack data.\n     */\n    function registerPack(\n        uint256 _price,\n        uint256 _donate,\n        bytes4[] calldata _category,\n        address _owner,\n        bytes calldata _contenthash,\n        uint256 _fee\n    )\n        external\n        returns(uint256 packId);\n\n}\n\n\n\n/**\n * @dev ERC-721 non-fungible token standard. \n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n */\ninterface ERC721\n{\n\n  /**\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n   * transfer, the approved address for that NFT (if any) is reset to none.\n   */\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed value\n  );\n\n  /**\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n   * address indicates there is no approved address. When a Transfer event emits, this also\n   * indicates that the approved address for that NFT (if any) is reset to none.\n   */\n  event Approval(\n    address indexed _owner,\n    address indexed _approved,\n    uint256 indexed _tokenId\n  );\n\n  /**\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n   * all NFTs of the owner.\n   */\n  event ApprovalForAll(\n    address indexed _owner,\n    address indexed _operator,\n    bool _approved\n  );\n\n  /**\n   * @dev Transfers the ownership of an NFT from one address to another address.\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n   * `onERC721Received` on `_to` and throws if the return value is not \n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   * @param _data Additional data with no specified format, sent in call to `_to`.\n   */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  )\n    external;\n\n  /**\n   * @dev Transfers the ownership of an NFT from one address to another address.\n   * @notice This works identically to the other function with an extra data parameter, except this\n   * function just sets data to \"\"\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external;\n\n  /**\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n   * address. Throws if `_tokenId` is not a valid NFT.\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n   * they mayb be permanently lost.\n   * @param _from The current owner of the NFT.\n   * @param _to The new owner.\n   * @param _tokenId The NFT to transfer.\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    external;\n\n  /**\n   * @dev Set or reaffirm the approved address for an NFT.\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n   * the current NFT owner, or an authorized operator of the current owner.\n   * @param _approved The new approved NFT controller.\n   * @param _tokenId The NFT to approve.\n   */\n  function approve(\n    address _approved,\n    uint256 _tokenId\n  )\n    external;\n\n  /**\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n   * @notice The contract MUST allow multiple operators per owner.\n   * @param _operator Address to add to the set of authorized operators.\n   * @param _approved True if the operators is approved, false to revoke approval.\n   */\n  function setApprovalForAll(\n    address _operator,\n    bool _approved\n  )\n    external;\n\n  /**\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n   * considered invalid, and this function throws for queries about the zero address.\n   * @param _owner Address for whom to query the balance.\n   * @return Balance of _owner.\n   */\n  function balanceOf(\n    address _owner\n  )\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n   * invalid, and queries about them do throw.\n   * @param _tokenId The identifier for an NFT.\n   * @return Address of _tokenId owner.\n   */\n  function ownerOf(\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (address);\n    \n  /**\n   * @dev Get the approved address for a single NFT.\n   * @notice Throws if `_tokenId` is not a valid NFT.\n   * @param _tokenId The NFT to find the approved address for.\n   * @return Address that _tokenId is approved for. \n   */\n  function getApproved(\n    uint256 _tokenId\n  )\n    external\n    view\n    returns (address);\n\n  /**\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n   * @param _owner The address that owns the NFTs.\n   * @param _operator The address that acts on behalf of the owner.\n   * @return True if approved for all, false otherwise.\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    external\n    view\n    returns (bool);\n\n}\n\n\n\n/**\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n */\ninterface ERC721Enumerable\n{\n\n  /**\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\n   * assigned and queryable owner not equal to the zero address.\n   * @return Total supply of NFTs.\n   */\n  function totalSupply()\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\n   * @param _index A counter less than `totalSupply()`.\n   * @return Token id.\n   */\n  function tokenByIndex(\n    uint256 _index\n  )\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\n   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\n   * representing invalid NFTs.\n   * @param _owner An address where we are interested in NFTs owned by them.\n   * @param _index A counter less than `balanceOf(_owner)`.\n   * @return Token id.\n   */\n  function tokenOfOwnerByIndex(\n    address _owner,\n    uint256 _index\n  )\n    external\n    view\n    returns (uint256);\n\n}\n\n\n/**\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\n * @notice interface for StickerType\n */\n/* interface */ abstract contract StickerType is ERC721, ERC721Enumerable { // Interfaces can't inherit\n\n    /**\n     * @notice controller can generate packs at will\n     * @param _price cost in wei to users minting with _urlHash metadata\n     * @param _donate optional amount of `_price` that is donated to StickerMarket at every buy\n     * @param _category listing category\n     * @param _owner address of the beneficiary of buys\n     * @param _contenthash EIP1577 pack contenthash for listings\n     * @return packId Market position of Sticker Pack data.\n     */\n    function generatePack(\n        uint256 _price,\n        uint256 _donate,\n        bytes4[] calldata _category,\n        address _owner,\n        bytes calldata _contenthash\n    )\n        external\n        virtual\n        returns(uint256 packId);\n\n    /**\n     * @notice removes all market data about a marketed pack, can only be called by market controller\n     * @param _packId position to be deleted\n     * @param _limit limit of categories to cleanup\n     */\n    function purgePack(uint256 _packId, uint256 _limit)\n        external\n        virtual;\n\n    /**\n     * @notice changes contenthash of `_packId`, can only be called by controller\n     * @param _packId which market position is being altered\n     * @param _contenthash new contenthash\n     */\n    function setPackContenthash(uint256 _packId, bytes calldata _contenthash)\n        external\n        virtual;\n\n    /**\n     * @notice This method can be used by the controller to extract mistakenly\n     *  sent tokens to this contract.\n     * @param _token The address of the token contract that you want to recover\n     *  set to 0 in case you want to extract ether.\n     */\n    function claimTokens(address _token)\n        external\n        virtual;\n\n    /**\n     * @notice changes price of `_packId`, can only be called when market is open\n     * @param _packId pack id changing price settings\n     * @param _price cost in wei to users minting this pack\n     * @param _donate value between 0-10000 representing percentage of `_price` that is donated to StickerMarket at every buy\n     */\n    function setPackPrice(uint256 _packId, uint256 _price, uint256 _donate)\n        external\n        virtual;\n\n    /**\n     * @notice add caregory in `_packId`, can only be called when market is open\n     * @param _packId pack adding category\n     * @param _category category to list\n     */\n    function addPackCategory(uint256 _packId, bytes4 _category)\n        external\n        virtual;\n\n    /**\n     * @notice remove caregory in `_packId`, can only be called when market is open\n     * @param _packId pack removing category\n     * @param _category category to unlist\n     */\n    function removePackCategory(uint256 _packId, bytes4 _category)\n        external\n        virtual;\n\n    /**\n     * @notice Changes if pack is enabled for sell\n     * @param _packId position edit\n     * @param _mintable true to enable sell\n     */\n    function setPackState(uint256 _packId, bool _mintable)\n        external\n        virtual;\n\n    /**\n     * @notice read available market ids in a category (might be slow)\n     * @param _category listing category\n     * @return availableIds array of market id registered\n     */\n    function getAvailablePacks(bytes4 _category)\n        external\n        virtual\n        view\n        returns (uint256[] memory availableIds);\n\n    /**\n     * @notice count total packs in a category\n     * @param _category listing category\n     * @return size total number of packs in category\n     */\n    function getCategoryLength(bytes4 _category)\n        external\n        virtual\n        view\n        returns (uint256 size);\n\n    /**\n     * @notice read a packId in the category list at a specific index\n     * @param _category listing category\n     * @param _index index\n     * @return packId on index\n     */\n    function getCategoryPack(bytes4 _category, uint256 _index)\n        external\n        virtual\n        view\n        returns (uint256 packId);\n\n    /**\n     * @notice returns all data from pack in market\n     * @param _packId pack id being queried\n     * @return category list of categories registered to this packType\n     * @return owner authorship holder\n     * @return mintable new pack can be generated (rare tool)\n     * @return timestamp registration timestamp\n     * @return price current price\n     * @return contenthash EIP1577 encoded hash\n     */\n    function getPackData(uint256 _packId)\n        external\n        virtual\n        view\n        returns (\n            bytes4[] memory category,\n            address owner,\n            bool mintable,\n            uint256 timestamp,\n            uint256 price,\n            bytes memory contenthash\n        );\n\n    /**\n     * @notice returns all data from pack in market\n     * @param _packId pack id being queried\n     * @return category list of categories registered to this packType\n     * @return timestamp registration timestamp\n     * @return contenthash EIP1577 encoded hash\n     */\n    function getPackSummary(uint256 _packId)\n        external\n        virtual\n        view\n        returns (\n            bytes4[] memory category,\n            uint256 timestamp,\n            bytes memory contenthash\n        );\n\n    /**\n     * @notice returns payment data for migrated contract\n     * @param _packId pack id being queried\n     * @return owner authorship holder\n     * @return mintable new pack can be generated (rare tool)\n     * @return price current price\n     * @return donate informational value between 0-10000 representing percentage of `price` that is donated to StickerMarket at every buy\n     */\n    function getPaymentData(uint256 _packId)\n        external\n        virtual\n        view\n        returns (\n            address owner,\n            bool mintable,\n            uint256 price,\n            uint256 donate\n        );\n   \n}\n\n\n\n\n/**\n * @title SafeERC20\n * @dev Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\n * and https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n */\ncontract SafeTransfer {\n    \n    function _safeTransfer(ERC20Token token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function _safeTransferFrom(ERC20Token token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n    \n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(ERC20Token token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(_isContract(address(token)), \"SafeTransfer: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeTransfer: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeTransfer: ERC20 operation did not succeed\");\n        }\n    }\n\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function _isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n}\n\n\n\n\n\n\n\n/**\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH)\n * @notice Owner's backdoor withdrawal logic, used for code reuse.\n */\ncontract TokenWithdrawer is SafeTransfer {\n    /**\n     * @dev Withdraw all balance of each `_tokens` into `_destination`.\n     * @param _tokens address of ERC20 token, or zero for withdrawing ETH.\n     * @param _destination receiver of token\n     */\n    function withdrawTokens(\n        address[] memory _tokens,\n        address payable _destination\n    )\n        internal\n    {\n        uint len = _tokens.length;\n        for(uint i = 0; i < len; i++){\n            withdrawToken(_tokens[i], _destination);\n        }\n    }\n\n    /**\n     * @dev Withdraw all balance of `_token` into `_destination`.\n     * @param _token address of ERC20 token, or zero for withdrawing ETH.\n     * @param _destination receiver of token\n     */\n    function withdrawToken(address _token, address payable _destination)\n        internal\n    {\n        uint256 balance;\n        if (_token == address(0)) {\n            balance = address(this).balance;\n            (bool success, ) = _destination.call.value(balance)(\"\");\n            require(success, \"Transfer failed\");\n        } else {\n            ERC20Token token = ERC20Token(_token);\n            balance = token.balanceOf(address(this));\n            _safeTransfer(token, _destination, balance);\n        }\n    }\n}\n\n\n/// @title Starterpack Distributor\n/// @notice Attempts to deliver 1 and only 1 starterpack containing ETH, ERC20 Tokens and NFT Stickerpacks to an eligible recipient\n/// @dev The contract assumes Signer has verified an In-App Purchase Receipt\ncontract SimplifiedDistributor is SafeTransfer, ReentrancyGuard, TokenWithdrawer {\n    address payable public owner;  // Contract deployer can modify parameters\n    address public signer; // Signer can only distribute Starterpacks\n\n    // Defines the Starterpack parameters\n    struct Pack {\n        uint256 ethAmount; // The Amount of ETH to transfer to the recipient\n        address[] tokens; // Array of ERC20 Contract Addresses\n        uint256[] tokenAmounts; // Array of ERC20 amounts corresponding to cells in tokens[]\n    }\n\n    Pack public defaultPack;\n\n    ERC20Token public sntToken;\n\n    bool public pause = true;\n    \n    event RequireApproval(address attribution);\n    \n    mapping(address => uint) public pendingAttributionCnt;\n    mapping(address => uint) public attributionCnt;\n    \n    struct Attribution {\n        bool enabled;\n        uint256 ethAmount; // The Amount of ETH to transfer to the referrer\n        address[] tokens; // Array of ERC20 Contract Addresses\n        uint256[] tokenAmounts; // Array of ERC20 amounts corresponding to cells in tokens[]\n        uint limit;\n    }\n    \n    mapping(address => Attribution) defaultAttributionSettings;\n    mapping(address => Attribution) promoAttributionSettings;\n\n    // Modifiers --------------------------------------------------------------------------------------------\n\n    // Functions only Owner can call\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Unauthorized\");\n        _;\n    }\n\n    // Logic ------------------------------------------------------------------------------------------------\n\n    /// @notice Check if an address is eligible for a starterpack\n    /// @dev will return false if a transaction of distributePack for _recipient has been successfully executed\n    ///      RETURNING TRUE BECAUSE ELIGIBILITY WILL BE HANDLED BY THE BACKEND\n    /// @param _recipient The address to be checked for eligibility\n    function eligible(address _recipient) public view returns (bool){\n        return true;\n    }\n\n    /// @notice Get the starter pack configuration\n    /// @return stickerMarket address Stickermarket contract address\n    /// @return ethAmount uint256 ETH amount in wei that will be sent to a recipient\n    /// @return tokens address[] List of tokens that will be sent to a recipient\n    /// @return tokenAmounts uint[] Amount of tokens that will be sent to a recipient\n    /// @return stickerPackIds uint[] List of sticker packs to send to a recipient\n    function getDefaultPack() external view returns(address stickerMarket, uint256 ethAmount, address[] memory tokens, uint[] memory tokenAmounts, uint[] memory stickerPackIds) {\n        ethAmount = defaultPack.ethAmount;\n        tokens = defaultPack.tokens;\n        tokenAmounts = defaultPack.tokenAmounts;\n    }\n\n    /// @notice Get the promo pack configuration\n    /// @return stickerMarket address Stickermarket contract address\n    /// @return ethAmount uint256 ETH amount in wei that will be sent to a recipient\n    /// @return tokens address[] List of tokens that will be sent to a recipient\n    /// @return tokenAmounts uint[] Amount of tokens that will be sent to a recipient\n    /// @return stickerPackIds uint[] List of sticker packs to send to a recipient\n    /// @return available uint number of promo packs available\n    function getPromoPack() external view returns(address stickerMarket, uint256 ethAmount, address[] memory tokens, uint[] memory tokenAmounts, uint[] memory stickerPackIds, uint256 available) {\n        // Removed the promo pack functionality, so returning default values (to not affect the ABI)\n    }\n\n    event Distributed(address indexed recipient, address indexed attribution);\n\n    /// @notice Distributes a starterpack to an eligible address. Either a promo pack or a default will be distributed depending on availability\n    /// @dev Can only be called by signer, assumes signer has validated an IAP receipt, owner can block calling by pausing.\n    /// @param _recipient A payable address that is sent a starterpack after being checked for eligibility\n    /// @param _attribution A payable address who referred the starterpack purchaser \n    function distributePack(address payable _recipient, address payable _attribution) external reentrancyGuard {\n        require(!pause, \"Paused\");\n        require(msg.sender == signer, \"Unauthorized\");\n        require(_recipient != _attribution, \"Recipient should be different from Attribution address\");\n\n        Pack memory pack = defaultPack;\n\n        // Transfer Tokens\n        // Iterate over tokens[] and transfer the an amount corresponding to the i cell in tokenAmounts[]\n        for (uint256 i = 0; i < pack.tokens.length; i++) {\n            ERC20Token token = ERC20Token(pack.tokens[i]);\n            uint256 amount = pack.tokenAmounts[i];\n            require(token.transfer(_recipient, amount), \"ERC20 operation did not succeed\");\n        }\n\n        // Transfer ETH\n        // .transfer bad post Istanbul fork :|\n        (bool success, ) = _recipient.call.value(pack.ethAmount)(\"\");\n        require(success, \"ETH Transfer failed\");\n\n        emit Distributed(_recipient, _attribution);\n\n        if (_attribution == address(0)) return;\n        \n        pendingAttributionCnt[_attribution] += 1;\n    }\n\n    function withdrawAttributions() external {\n        require(!pause, \"Paused\");\n        \n        uint pendingAttributions = pendingAttributionCnt[msg.sender];\n        uint attributionsPaid = attributionCnt[msg.sender];\n\n        if (pendingAttributions == 0) return;\n\n        Attribution memory attr = defaultAttributionSettings[msg.sender];\n        if (!attr.enabled) {\n           attr = defaultAttributionSettings[address(0)];\n        }\n\n        uint totalETHToPay;\n        uint totalSNTToPay;\n        uint attributionsToPay;\n        if((attributionsPaid + pendingAttributions) > attr.limit){\n            emit RequireApproval(msg.sender);\n            if(attributionsPaid < attr.limit){\n                attributionsToPay = attr.limit - attributionsPaid;\n            } else {\n                attributionsToPay = 0;\n            }\n            attributionsPaid += attributionsToPay;\n            pendingAttributions -= attributionsToPay;\n        } else {\n            attributionsToPay = pendingAttributions;\n            attributionsPaid += attributionsToPay;\n            pendingAttributions = 0;\n        }\n\n        totalETHToPay += attributionsToPay * attr.ethAmount;\n\n        for (uint256 i = 0; i < attr.tokens.length; i++) {\n            if(attr.tokens[i] == address(sntToken)){\n                totalSNTToPay += attributionsToPay * attr.tokenAmounts[i];\n            } else {\n                ERC20Token token = ERC20Token(attr.tokens[i]);\n                uint256 amount = attributionsToPay * attr.tokenAmounts[i];\n                _safeTransfer(token, msg.sender, amount);\n            }\n        }\n\n        pendingAttributionCnt[msg.sender] = pendingAttributions;\n        attributionCnt[msg.sender] = attributionsPaid;\n\n        if (totalETHToPay != 0){\n            \n            (bool success, ) = msg.sender.call.value(totalETHToPay)(\"\");\n            require(success, \"ETH Transfer failed\");\n        }\n\n        if (totalSNTToPay != 0){\n            ERC20Token token = ERC20Token(sntToken);\n            _safeTransfer(token, msg.sender, totalSNTToPay);\n        }\n    }\n    \n\n    /// @notice Get rewards for specific referrer\n    /// @param _account The address to obtain the attribution config\n    /// @param _isPromo Indicates if the configuration for a promo should be returned or not\n    /// @return ethAmount Amount of ETH in wei\n    /// @return tokenLen Number of tokens configured as part of the reward\n    /// @return maxThreshold If isPromo == true: Number of promo bonuses still available for that address else: Max number of attributions to pay before requiring approval\n    /// @return attribCount Number of referrals\n    function getReferralReward(address _account, bool _isPromo) public view returns (uint ethAmount, uint tokenLen, uint maxThreshold, uint attribCount) {\n        require(_isPromo != true);\n        Attribution memory attr = defaultAttributionSettings[_account];\n        if (!attr.enabled) {\n            attr = defaultAttributionSettings[address(0)];\n        }\n        \n        ethAmount = attr.ethAmount;\n        maxThreshold = attr.limit;\n        attribCount = attributionCnt[_account];\n        tokenLen = attr.tokens.length;\n    }\n\n    /// @notice Get token rewards for specific address\n    /// @param _account The address to obtain the attribution's token config\n    /// @param _isPromo Indicates if the configuration for a promo should be returned or not\n    /// @param _idx Index of token array in the attribution used to obtain the token config\n    /// @return token ERC20 contract address\n    /// @return tokenAmount Amount of token configured in the attribution\n    function getReferralRewardTokens(address _account, bool _isPromo, uint _idx) public view returns (address token, uint tokenAmount) {\n        require(_isPromo != true);\n        Attribution memory attr = defaultAttributionSettings[_account];\n        if (!attr.enabled) {\n            attr = defaultAttributionSettings[address(0)];\n        }\n        \n        token = attr.tokens[_idx];\n        tokenAmount = attr.tokenAmounts[_idx];\n    }\n    \n    fallback() external payable  {\n     // ...\n    }\n    \n    // Admin ------------------------------------------------------------------------------------------------\n\n    /// @notice Allows the Owner to allow or prohibit Signer from calling distributePack().\n    /// @dev setPause must be called before Signer can call distributePack()\n    function setPause(bool _pause) external onlyOwner {\n        pause = _pause;\n    }\n\n    /// @notice Set a starter pack configuration\n    /// @dev The Owner can change the default starterpack contents\n    /// @param _newPack starter pack configuration\n    function changeStarterPack(Pack memory _newPack) public onlyOwner {\n        require(_newPack.tokens.length == _newPack.tokenAmounts.length, \"Mismatch with Tokens & Amounts\");\n\n        for (uint256 i = 0; i < _newPack.tokens.length; i++) {\n            require(_newPack.tokenAmounts[i] > 0, \"Amounts must be non-zero\");\n        }\n\n        defaultPack = _newPack;\n    }\n\n    /// @notice Safety function allowing the owner to immediately pause starterpack distribution and withdraw all balances in the the contract\n    function withdraw(address[] calldata _tokens) external onlyOwner {\n        pause = true;\n        withdrawTokens(_tokens, owner);\n    }\n\n    /// @notice Changes the Signer of the contract\n    /// @param _newSigner The new Signer of the contract\n    function changeSigner(address _newSigner) public onlyOwner {\n        require(_newSigner != address(0), \"zero_address not allowed\");\n        signer = _newSigner;\n    }\n\n    /// @notice Changes the owner of the contract\n    /// @param _newOwner The new owner of the contract\n    function changeOwner(address payable _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"zero_address not allowed\");\n        owner = _newOwner;\n    }\n    \n    /// @notice Set default/custom payout and threshold for referrals\n    /// @param _isPromo indicates if this attribution config is a promo or default config\n    /// @param _ethAmount Payout for referrals\n    /// @param _thresholds Max number of referrals allowed beforee requiring approval\n    /// @param _assignedTo Use a valid address here to set custom settings. To set the default payout and threshold, use address(0);\n    function setPayoutAndThreshold(\n        bool _isPromo,\n        uint256 _ethAmount,\n        address[] calldata _tokens,\n        uint256[] calldata _tokenAmounts,\n        uint256[] calldata _thresholds,\n        address[] calldata _assignedTo\n    ) external onlyOwner {\n        require(_isPromo != true);\n\n        require(_thresholds.length == _assignedTo.length, \"Array length mismatch\");\n        require(_tokens.length == _tokenAmounts.length, \"Array length mismatch\");\n        \n        for (uint256 i = 0; i < _thresholds.length; i++) {\n            bool enabled = _assignedTo[i] != address(0);\n            \n            Attribution memory attr = Attribution({\n                enabled: enabled,\n                ethAmount: _ethAmount,\n                limit: _thresholds[i],\n                tokens: _tokens,\n                tokenAmounts: _tokenAmounts\n            });\n            \n            defaultAttributionSettings[_assignedTo[i]] = attr;\n        }\n    }\n    \n    /// @notice Remove attribution configuration for addresses\n    /// @param _assignedTo Array of addresses with an attribution configured\n    /// @param _isPromo Indicates if the configuration to delete is the promo or default\n    function removePayoutAndThreshold(address[] calldata _assignedTo, bool _isPromo) external onlyOwner {\n        for (uint256 i = 0; i < _assignedTo.length; i++) {\n            delete defaultAttributionSettings[_assignedTo[i]];\n        }\n    }\n\n    /// @notice Set SNT address\n    function setSntToken(address _sntToken) external onlyOwner {\n        sntToken = ERC20Token(_sntToken);\n    }\n\n    /// @param _signer allows the contract deployer(owner) to define the signer on construction\n    /// @param _sntToken SNT token address\n    constructor(address _signer, address _sntToken) public {\n        require(_signer != address(0), \"zero_address not allowed\");\n        owner = msg.sender;\n        signer = _signer;\n        sntToken = ERC20Token(_sntToken);\n    }\n}"}}}