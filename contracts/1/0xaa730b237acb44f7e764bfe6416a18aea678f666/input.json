{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/arb.sol": {
      "content": "pragma solidity ^0.6.7;\n\ninterface ERC20 {\n  function approve(address spender, uint256 amount) external returns (bool);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n\n  event Transfer(address from, address to, uint256 value);\n  event Approval(address owner, address spender, uint256 value);\n}\n\ninterface OneInch {\n  function swap(ERC20 fromToken, ERC20 toToken, uint256 amount, uint256 minReturn, uint256[] calldata distribution, uint256 disableFlags) external payable;\n  function getExpectedReturn(ERC20 fromToken, ERC20 toToken, uint256 amount, uint256 parts, uint256 disableFlags) external view returns(uint256 returnAmount, uint256[] memory distribution);\n}\n\n// interface GST2 {\n//   function freeUpTo(uint256 value) external returns (uint256 freed);\n// }\n\ninterface AaveProvider {\n  function getLendingPool() external view returns (address);\n  function getLendingPoolCore() external view returns (address payable);\n}\n\ninterface AaveLendingPool {\n  function flashLoan(address receiver, address reserve, uint256 amount, bytes calldata params) external;\n}\n\ncontract Arb {\n  // address constant GST2_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n  address constant ONE_INCH_CONTRACT = 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\n  address constant AAVE_PROVIDER = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n\n  address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n  address constant BAT = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\n  // address constant REP  = 0x1985365e9f78359a9B6AD760e32412f4a445E862;\n  // address constant SAI  = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n  // address constant ZRX  = 0xE41d2489571d322189246DaFA5ebDe1F4699F498;\n  // address constant SNX  = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n  // address constant MKR  = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n  // address constant NMR  = 0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671;\n  // address constant KNC  = 0xdd974D5C2e2928deA5F71b9825b8b646686BD200;\n  // address constant PAX  = 0x8E870D67F660D95d5be530380D0eC0bd388289E1;\n  address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n  // address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n  // address constant SETH = 0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb;\n  // address constant LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\n  // address constant TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;\n  // address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n  // address constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;\n  // address constant SUSD = 0x57Ab1E02fEE23774580C119740129eAC7081e9D3;\n\n  // event LogInt(uint256 key, uint val);\n  // event LogAddr(uint256 key, address val);\n  // event EtherReceived();\n\n  address payable private owner;\n  uint256[] private buyDistribution;\n  uint256[] private sellDistribution;\n  address private toAsset;\n\n  constructor() public {\n    owner = msg.sender;\n    ERC20(DAI).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(BAT).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n    ERC20(USDC).approve(ONE_INCH_CONTRACT, 100000000000000000000000000000);\n  }\n\n  // function withdrawToken(address _asset) public {\n  //   uint256 assetBalance = ERC20(_asset).balanceOf(address(this));\n\n  //   if(assetBalance > 0) {\n  //     ERC20(_asset).transfer(owner, assetBalance);\n  //   }\n  // }\n\n  // function withdrawEth() public {\n  //   owner.transfer(address(this).balance);\n  // }\n\n  function selfBalanceInternal(address _asset) private view returns(uint256) {\n    if(_asset == ETH_ADDRESS) {\n      return address(this).balance;\n    } else {\n      return ERC20(_asset).balanceOf(address(this));\n    }\n  }\n\n  function returnAaveFundsInternal(address _reserve, uint256 _amount, uint256 _fee) private {\n    uint256 returnBalanceWithFee = _amount + _fee;\n    address aaveCore = AaveProvider(AAVE_PROVIDER).getLendingPoolCore();\n\n    if(_reserve == ETH_ADDRESS) {\n      aaveCore.call { value: returnBalanceWithFee }(\"\");\n    } else {\n      ERC20(_reserve).transfer(aaveCore, returnBalanceWithFee);\n    }\n  }\n\n  // function buySellReturnInternal(address _from_asset, address _to_asset, uint256 _input_amount) private view returns(uint256) {\n  //   (uint256 toAssetSaleAmount,) = OneInch(ONE_INCH_CONTRACT).getExpectedReturn(ERC20(_from_asset), ERC20(_to_asset), _input_amount, 4, 0);\n  //   (uint256 expectedReturnAmount,) = OneInch(ONE_INCH_CONTRACT).getExpectedReturn(ERC20(_to_asset), ERC20(_from_asset), toAssetSaleAmount, 4, 0);\n\n  //   return expectedReturnAmount;\n  // }\n\n  // function buySellReturn(address _from_asset, address _to_asset, uint256 _input_amount) public view returns(uint256) {\n  //   return buySellReturnInternal(_from_asset, _to_asset, _input_amount);\n  // }\n\n  function clearTempVars() private {\n    delete buyDistribution;\n    delete sellDistribution;\n    delete toAsset;\n  }\n\n  // Aave callback, called from flashLoan from Aave\n  function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes memory _params) public {\n    OneInch(ONE_INCH_CONTRACT).swap(ERC20(_reserve), ERC20(toAsset), _amount, 0, buyDistribution, 0);\n    uint256 soldAmount = selfBalanceInternal(toAsset);\n    OneInch(ONE_INCH_CONTRACT).swap(ERC20(toAsset), ERC20(_reserve), soldAmount, 0, sellDistribution, 0);\n\n    returnAaveFundsInternal(_reserve, _amount, _fee);\n    // GST2(GST2_ADDRESS).freeUpTo(29);\n  }\n\n  // Called by our bot\n  function swap(address _from_asset, address _to_asset, uint256[] memory _buy_distribution, uint256[] memory _sell_distribution, uint256 _input_amount, uint _max_block) public {\n    require(msg.sender == owner);\n    require(block.number <= _max_block);\n\n    buyDistribution = _buy_distribution;\n    sellDistribution = _sell_distribution;\n    toAsset = _to_asset;\n\n    address aavePool = AaveProvider(AAVE_PROVIDER).getLendingPool();\n    AaveLendingPool(aavePool).flashLoan(address(this), _from_asset, _input_amount, \"\");\n\n    clearTempVars();\n  }\n}\n"
    }
  }
}