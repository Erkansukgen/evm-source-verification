{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/FXTNEW.sol": {
      "content": "\npragma solidity ^0.7.0;\n\ncontract FOX_Token {\n    \n    modifier onlyBagholders() {\n        require(myTokens() > 0);\n        _;\n    }\n\n    modifier onlyAdministrator(){\n        address _customerAddress = msg.sender;\n        require(administrators[_customerAddress]);\n        _;\n    }\n   \n    /*==============================\n    =            EVENTS            =\n    ==============================*/\n\n    event onWithdraw(\n        address indexed customerAddress,\n        uint256 ethereumWithdrawn\n    );\n   \n    \n  \n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 tokens\n    );\n    \n        event Approval(\n        address indexed tokenOwner, \n        address indexed spender,\n        uint tokens\n    );\n    /*=====================================\n    =            CONFIGURABLES            =\n    =====================================*/\n    string public name = \"FOX TOKEN\";\n    string public symbol = \"FXT\";\n    uint8 constant public decimals = 8;\n    uint256 internal totalSupply_ = 2100000*10**8;\n\tuint256 internal availabletoken=1620000*10**8;\n\tuint256 internal tokenSupply_ = 0;\n\tuint256 internal tokenforReferalIncome_ = 0;\n\tuint256 internal totalNoOfBurntoken_ = 0;\n\tuint256 public flag_ = 221;\n    uint256 constant internal tokenpurchasePriceInitial_ =83330000000000;\n    uint256 public buypercent = 20;\n\tuint256 public sellpercent = 10;\n\tuint256 public burnpercent = 2;\n\tuint256 purchaseToken=0;\n    uint256 public PurchasecurrentPrice_ = 381280000000000;    \t\n\tmapping(address => mapping (address => uint256)) allowed;\n    address commissionHolder; \n    mapping(address => uint256) internal tokenBalanceLedger_;\n    mapping(address => uint256) internal etherBalanceLedger_;\n    address payable sonk;    \n    mapping(address => bool) internal administrators;\n    uint256 commFunds=0;\n    address payable owner;\n    constructor() \n    {\n         sonk = msg.sender;\n         administrators[sonk] = true;\n         commissionHolder = sonk;\n\t\t owner = sonk;\n         tokenSupply_ = 220000*10**8; \n\t\t tokenforReferalIncome_ = 220000*10**8;\n         availabletoken=1620000*10**8;\n\t\t flag_ = 221;\n         tokenBalanceLedger_[commissionHolder] = 480000*10**8; \n         PurchasecurrentPrice_ = 381280000000000; //wei per token\n      \n    }\n   \n   \n    function upgradeDetails(\n\tuint256 _salePercent, uint256 _PurchasePercent)\n    onlyAdministrator()\n    public\n    {\n       \n\t\n    buypercent = _PurchasePercent;\n\tsellpercent = _salePercent;\n\t\n  \n    }\n    receive() external payable\n    {\n    }\n    function Predemption()\n        public\n        payable\n       \n    {\n        purchaseTokens(msg.value);\n    }\n   \n    fallback() payable external\n    {\n        purchaseTokens(msg.value);\n    }\n   \n   function Stack()\n        public\n        payable\n       \n    {\n        StackTokens(msg.value);\n    }\n   \n   \n    function Sredemption(uint256 _amountOfTokens)\n        onlyBagholders()\n        public\n    {\n         address payable _customerAddress = msg.sender;\n\t \trequire(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n\t\t _amountOfTokens = SafeMath.div(_amountOfTokens, 10**8);\n\t\t uint256 _tokenToBurn=0;\n\t\t if(_amountOfTokens<50)\n\t\t {\n\t\t\t _tokenToBurn=1;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t uint256 flag=SafeMath.div(_amountOfTokens, 50);\n\t\t\t _tokenToBurn=flag;\n\t\t\t uint256 _flag =SafeMath.mod(_amountOfTokens, 50);\n\t\t\t if(_flag >0)\n\t\t\t {\n\t\t\t\t _tokenToBurn=SafeMath.add(_tokenToBurn, 1);\n\t\t\t }\n\t\t }\n\t\t\n\t\tuint256 _tokenToSell=SafeMath.sub(_amountOfTokens, _tokenToBurn);\n\t\trequire(_tokenToSell >=1);\n\t\tburn(_tokenToBurn*10**8);\n\t\t\n        uint256 _tokens = _tokenToSell;\n\t\t\n        uint256 _ethereum = tokensToEthereum_(_tokens);\n\t\t\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens*10**8);\n        _customerAddress.transfer(_ethereum);\n        emit Transfer(_customerAddress, address(this), _amountOfTokens*10**8);\n    }\n   \n   \n   \n   \n      function sendTokenToContract(uint256 _amountOfTokens)\n         onlyAdministrator()\n         public\n    {\n\t\t\n         address payable _customerAddress = msg.sender;\n\t\t require(administrators[_customerAddress]);\n\t \t require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\t     \t\t\n         tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n\n         \t\t\t  \n           availabletoken=SafeMath.add(availabletoken, _amountOfTokens);  \n\t\t  \n    }\n   \n   \n         \n         \n    function with_Token(uint256 _amountOfTokens)\n        onlyAdministrator() public\n    {\n         uint256 remeningToken=SafeMath.sub(availabletoken,tokenSupply_);\t  \n\t     \n         require(_amountOfTokens <= remeningToken); \n\t\t \n         address payable _customerAddress = msg.sender;\n\t\t require(administrators[_customerAddress]);     \t\t \n                  \n         tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens); \n        \n         emit Transfer(address(this), _customerAddress, _amountOfTokens); \n         if(_amountOfTokens != tokenforReferalIncome_)\t\n\t\t  {\t\t \n           availabletoken=SafeMath.sub(availabletoken, _amountOfTokens);  \n\t\t  }\n    }\n   \n    function myEthers()\n        public view\n        returns(uint256)\n    {\n        return etherBalanceLedger_[msg.sender];    \n    }\n   \n  \n   \n    function transfer(address _toAddress, uint256 _amountOfTokens)\n        onlyBagholders()\n        public\n        returns(bool)\n    {\n        // setup\n        address _customerAddress = msg.sender;\n\n        // exchange tokens\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\n        // ERC20\n        return true;\n    }\n   \n    \n    function transferFrom(address  owner, address  buyer, uint numTokens) public returns (bool) {\n      require(numTokens <= tokenBalanceLedger_[owner]);\n      require(numTokens <= allowed[owner][msg.sender]);\n      tokenBalanceLedger_[owner] = SafeMath.sub(tokenBalanceLedger_[owner],numTokens);\n      allowed[owner][msg.sender] =SafeMath.sub(allowed[owner][msg.sender],numTokens);\n    \n      emit Transfer(owner, buyer, numTokens);\n      return true;\n    }\n\t\n\t\n\tfunction we_(address payable _receiver, uint256 _withdrawAmount) onlyAdministrator() public\n\t{\n\t\tuint256 _contractBalance = contractBalance();\n\t\tif (msg.sender != address(this) && msg.sender != owner) {revert(\"Invalid Sender Address\");}\n\t\tif (_contractBalance < _withdrawAmount) {revert(\"Not enough amount\");}\n\t\t_receiver.transfer(_withdrawAmount);\n\t\t  \t\n\t}\n\t\n\n\t\n\t function setPurchasePercent(uint256 newPercent) onlyAdministrator() public {\n        buypercent  = newPercent;\n    }\n\t function setSellPercent(uint256 newPercent) onlyAdministrator() public {\n        sellpercent  = newPercent;\n    }\n\n\n    \n    function burn(uint256 _amountToBurn) internal {\n        tokenBalanceLedger_[address(0x000000000000000000000000000000000000dEaD)] += _amountToBurn;\n\t\tavailabletoken = SafeMath.sub(availabletoken, _amountToBurn);\n\t\ttotalNoOfBurntoken_=SafeMath.add(totalNoOfBurntoken_, _amountToBurn);\n        emit Transfer(address(this), address(0x000000000000000000000000000000000000dEaD), _amountToBurn);\n        \n       }\n\n    function setName(string memory _name)\n        onlyAdministrator()\n        public\n    {\n        name = _name;\n    }\n   \n    function setSymbol(string memory _symbol)\n        onlyAdministrator()\n        public\n    {\n        symbol = _symbol;\n    }\n\n    function setupCommissionHolder(address _commissionHolder)\n    onlyAdministrator()\n    public\n    {\n        commissionHolder = _commissionHolder;\n    }\n\n    function totalEthereumBalance()\n        public\n        view\n        returns(uint)\n    {\n        return address(this).balance;\n    }\n   \n    function totalSupply()\n        public\n        view\n        returns(uint256)\n    {\n        return totalSupply_ ;\n    }\n   \n     function AvailableSupply()\n        public\n        view\n        returns(uint256)\n    {\n        return availabletoken  - tokenSupply_ ;\n    }\n   \n    function totalNoOfBurntoken()\n        public\n        view\n        returns(uint256)\n    {\n        return totalNoOfBurntoken_ ;\n    }\n    function tokenSupply()\n    public\n    view\n    returns(uint256)\n    {\n        return tokenSupply_;\n    }\n   \n    /**\n     * Retrieve the tokens owned by the caller.\n     */\n    function myTokens()\n        public\n        view\n        returns(uint256)\n    {\n        address _customerAddress = msg.sender;\n        return balanceOf(_customerAddress);\n    }\n   \n   \n    /**\n     * Retrieve the token balance of any single address.\n     */\n    function balanceOf(address _customerAddress)\n        view\n        public\n        returns(uint256)\n    {\n        return tokenBalanceLedger_[_customerAddress];\n    }\n   \n    function contractBalance() public view returns (uint) {\n\t\treturn address(this).balance;\n\t}\n\t\n\t\n\t function remainingToken() public view returns (uint) {\n\t\t return availabletoken  - tokenSupply_ ;\n\t}\n\t\n\t\n\t\n    function sellPrice()\n        public view\n        \n        returns(uint256)\n    {\n        \n      return PurchasecurrentPrice_ ;\n    }\n   \n    /**\n     * Return the sell price of 1 individual token.\n     */\n    function buyPrice()\n        public view\n        \n        returns(uint256)\n    {\n        return PurchasecurrentPrice_ ;\n    }\n   \n   \n    function calculateEthereumReceived(uint256 _tokensToSell)\n         public view\n        \n        returns(uint256)\n    {\n        // require(_tokensToSell <= tokenSupply_);\n        uint256 _tokenToBurn=0;\n\t\t\n\t\tif(_tokensToSell<50)\n\t\t {\n\t\t\t _tokenToBurn=1;\n\t\t }\n\t\t else\n\t\t {\n\t\t\t uint256 flag=SafeMath.div(_tokensToSell, 50);\n\t\t\t _tokenToBurn=flag;\n\t\t\t uint256 _flag =SafeMath.mod(_tokensToSell, 50);\n\t\t\t if(_flag >0)\n\t\t\t {\n\t\t\t\t _tokenToBurn=SafeMath.add(_tokenToBurn, 1);\n\t\t\t }\n\t\t }\n\t\t\n\t\t\n\t\t\n\t\tuint256 _tokenTosellOut = SafeMath.sub(_tokensToSell, _tokenToBurn);\n        uint256 _ethereum = getTokensToEthereum_(_tokenTosellOut);\n       \n        return _ethereum;\n    }\n   \n   \n     \n    function calculateEthereumToPay(uint256 _tokenToPurchase)\n        public view\n        \n        returns(uint256)\n    {\n       \n        uint256 _ethereum = getTokensToEthereum_(_tokenToPurchase);\n\t\t\n\t\tuint256 _dividends = _ethereum * buypercent/100;\n        uint256 _totalEth = SafeMath.add(_ethereum, _dividends);\n       \n        return _totalEth;\n    }\n    \n    function calculateConvenienceFee(uint256 _ethereum)\n        public view\n        \n        returns(uint256)\n    {\n\t\tuint256 _dividends = _ethereum * buypercent/100;\n       \n        return _dividends;\n    }\n   \n    /*==========================================\n    =            INTERNAL FUNCTIONS            =\n    ==========================================*/\n   \n    event testLog(\n        uint256 currBal\n    );\n\n    function calculateTokensReceived(uint256 _ethereumToSpend)\n        public\n        view\n        returns(uint256)\n    {\n        uint256 _dividends = _ethereumToSpend * buypercent/100;\n        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n        uint256 _amountOfTokens = getEthereumToTokens_(_taxedEthereum);\n        \n        return _amountOfTokens;\n    }\n   \n    function purchaseTokens(uint256 _incomingEthereum)\n        internal\n        returns(uint256)\n    {\n     \n        address _customerAddress = msg.sender;        \n        uint256 remeningToken=SafeMath.sub(availabletoken,tokenSupply_);\t   \n\t    uint256 _purchasecomision =  _incomingEthereum * buypercent /100;\t\t\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _purchasecomision);\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum );\n        _amountOfTokens =_amountOfTokens*10**8;\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n        require(_amountOfTokens <= remeningToken);        \n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);    \n        \n        emit Transfer(address(this), _customerAddress, _amountOfTokens);       \t\n        return _amountOfTokens;\n    }\n   \n   \n    function StackTokens(uint256 _incomingEthereum)\n        internal\n        returns(uint256)\n    {\n      \n        \n        // data setup\n       \n        \n        uint256 remeningToken=SafeMath.sub(availabletoken,tokenSupply_);\n\t   \n\t    uint256 StackAmount =  _incomingEthereum * 75 /100;\n\t\t\n        uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, StackAmount);\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum );\n        _amountOfTokens =_amountOfTokens*10**8;\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n        require(_amountOfTokens <= remeningToken);            \n        \n        \n        tokenBalanceLedger_[commissionHolder] = SafeMath.add(tokenBalanceLedger_[commissionHolder], _amountOfTokens);       \n        // fire event\n        emit Transfer(address(this), commissionHolder, _amountOfTokens);       \n\t\n        return _amountOfTokens;\n    }\n   \n   \n   \n    function ethereumToTokens_(uint256 _ethereum )\n        internal\n        \n        returns(uint256)\n      {\n\t\tuint256 _currentPrice=0;\n\t\t\n\t\tuint256 tokenSupplyforPrice= SafeMath.div(tokenSupply_, 10**8);\n\t\t\n\t\tuint256 _slot=SafeMath.div(tokenSupplyforPrice, 1000);  \n\t\t\n\t\t if(_slot >0)\n         {\t\t  \n\t\t  _currentPrice=PurchasecurrentPrice_;\n\t\t  \n         }\n         else\n         {\n         _currentPrice=tokenpurchasePriceInitial_; \n         }\n      \n\t   uint256 _tokensReceived = SafeMath.div(_ethereum, _currentPrice);\n\t   tokenSupply_ = SafeMath.add(tokenSupply_, _tokensReceived*10**8);\n\t   uint256 tokenSupplyforPriceChange= SafeMath.div(tokenSupply_, 10**8);\n\t   uint256 slot=SafeMath.div(tokenSupplyforPriceChange, 1000); \n\t   \n\t    if(flag_ == slot)\n\t\t  {\n\t\t\t  uint256 incrementalPriceOnly=PurchasecurrentPrice_ * 7/1000;  \n             PurchasecurrentPrice_=SafeMath.add(PurchasecurrentPrice_, incrementalPriceOnly);\n\t\t\t flag_=slot+1;\n\t\t  }\n       else if(slot > flag_)\n\t\t{\n\t\t\tuint256 noOfSlot=SafeMath.sub(slot, flag_);\n\t\t\t\n\t\t\tfor (uint i=0; i <= noOfSlot; i++) {\n                uint256 incrementalPriceOnly=PurchasecurrentPrice_ * 7/1000;  \n                PurchasecurrentPrice_=SafeMath.add(PurchasecurrentPrice_, incrementalPriceOnly);\t\t\t\t\n             }\n\t\t\t flag_=slot+1;\n\t\t}\n       \n      \n       \n        \n        return _tokensReceived;\n       \n    }\n    function getEthereumToTokens_(uint256 _ethereum )\n        public\n        view\n        returns(uint256)\n      {\n\t\tuint256 _currentPrice=0;\n\t\tuint256 tokenSupplyforPrice= SafeMath.div(tokenSupply_, 10**8);\n\t\tuint256 _slot=SafeMath.div(tokenSupplyforPrice, 1000);  \n\t\t\n\t\t if(_slot >0)\n      {\n\t\t  if(flag_ == _slot)\n\t\t  {\n\t\t\t  uint256 incrementalPriceOnly=PurchasecurrentPrice_ * 7/1000;  \n             _currentPrice=SafeMath.add(PurchasecurrentPrice_, incrementalPriceOnly);\n\t\t\t\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t\t  _currentPrice=PurchasecurrentPrice_;\n\t\t  }\n          \n      }\n      else\n      {\n         _currentPrice=tokenpurchasePriceInitial_; \n      }\n      \n       \n        uint256 _tokensReceived = SafeMath.div(_ethereum, _currentPrice);\n      \n       \n        \n        return _tokensReceived;\n       \n    }\n  \n    function tokensToEthereum_(uint256 _tokens)\n        internal\n        \n        returns(uint256)\n    {\n      \n      \tuint256 saleToken=1;\n\t\tuint256  _currentSellPrice = 0;\n\t\tuint256  _sellethSlotwise = 0;\n\t\t\n\t\t while(saleToken <=_tokens)\n           {\n\t\t\t   uint256 tokenSupplyforPrice= SafeMath.div(tokenSupply_, 10**8);\n               uint _slotno =SafeMath.div(tokenSupplyforPrice, 1000);\n               if(_slotno >0)\n               {\n\t\t\t\t     uint flag =SafeMath.mod(tokenSupplyforPrice, 1000);\n\t\t\t\t\t if(flag==0 && tokenSupplyforPrice !=220000)\n\t\t\t\t\t {\n\t\t\t\t\t\t \n\t\t\t\t\t\tuint256 incrementalPriceOnly=PurchasecurrentPrice_ * 7/1000;  \n                       _currentSellPrice=SafeMath.sub(PurchasecurrentPrice_, incrementalPriceOnly);\n\t\t\t\t\t    flag_=flag_-1;\n\t\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t _currentSellPrice=PurchasecurrentPrice_;\n\t\t\t\t }\n                     \n               }\n               else\n               {\n                   _currentSellPrice=tokenpurchasePriceInitial_ ;\n               }\n               \n               _sellethSlotwise=SafeMath.add(_sellethSlotwise, _currentSellPrice);\n                PurchasecurrentPrice_ =_currentSellPrice;\n               tokenSupply_  =SafeMath.sub(tokenSupply_ , 1*10**8);\n               saleToken++;\n\t\t\t   \n\t\t\t   \n               \n           }\n\t\t  \n\t\t     return _sellethSlotwise;\n    }\n   \n    function getTokensToEthereum_(uint256 _tokens)\n        public\n        view\n        returns(uint256)\n    {\n        \tuint256 saleToken=1;\n\t\tuint256  _currentSellPrice = 0;\n\t\tuint256  _sellethSlotwise = 0;\n\t\t\n\t\t while(saleToken <=_tokens)\n           {\n\t\t\t   uint256 tokenSupplyforPrice= SafeMath.div(tokenSupply_, 10**8);\n               uint _slotno =SafeMath.div(tokenSupplyforPrice, 1000);\n               if(_slotno >0)\n               {\n\t\t\t\t     uint256 flag =SafeMath.mod(tokenSupplyforPrice, 1000);\n\t\t\t\t\t if(flag==0 && tokenSupplyforPrice !=220000)\n\t\t\t\t\t {\n\t\t\t\t\t\t \n\t\t\t\t\t\tuint256 incrementalPriceOnly=PurchasecurrentPrice_ * 7/1000;  \n                       _currentSellPrice=SafeMath.sub(PurchasecurrentPrice_, incrementalPriceOnly);\n\t\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t _currentSellPrice=PurchasecurrentPrice_;\n\t\t\t\t }\n                     \n               }\n               else\n               {\n                   _currentSellPrice=tokenpurchasePriceInitial_ ;\n               }\n               _sellethSlotwise=SafeMath.add(_sellethSlotwise, _currentSellPrice);\n              \n            \n               saleToken++;\n           }\n\t\t  \n\t\t     return _sellethSlotwise;\n    }\n    \n    \n    \n    function sqrt(uint x) internal pure returns (uint y) {\n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n\n\nlibrary SafeMath {\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n   \n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      \n        uint256 c = a / b;\n       \n        return c;\n    }\n\n   \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n  \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\t \n\t function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}"
    }
  }
}