{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "browser/referral.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./SafeMath.sol\";\nimport \"./token.sol\";\n\ncontract Referral {\n    using SafeMath for uint256;\n\n    //user structure\n    struct UserStruct {\n        bool isExist;\n        //unique id\n        uint256 id;\n        //person who referred unique id\n        uint256 referrerID;\n        //user current level\n        uint256 currentLevel;\n        //total eraning for user\n        uint256 totalEarningEth;\n        //persons referred\n        address[] referral;\n        //time for every level\n        uint256 levelExpiresAt;\n    }\n    \n    //owner who deploys contracts\n    address public owner;\n    //address to tarnsfer eth/2\n    address payable public ownerAddress1;\n    //address to tarnsfer eth/2\n    address payable public ownerAddress2;\n    //unique id for every user\n    uint256 public last_uid = 0;\n    //time limit for each level\n    uint256 public PERIOD_LENGTH = 60 days;\n    //no of users in each level\n    uint256 REFERRALS_LIMIT = 5;\n    //maximum level from 0 to 7\n    uint256 MAX_LEVEL = 7;\n\n    //token variable\n    Ethrim public ETRM;\n\n    //to up for each level\n    mapping(uint256 => uint256) public LEVEL_PRICE;\n    //incentive for every level\n    mapping(uint256 => uint256) public INCENTIVE_LEVEL_PRICE;\n    //map user by their unique trust wallet address\n    mapping(address => UserStruct) public users;\n    //users trust wallet address corresponding to unique id\n    mapping(uint256 => address) public userAddresses;\n\n    //check if user not registered previously\n    modifier userRegistered() {\n        require(users[msg.sender].isExist == true, \"User is not registered\");\n        _;\n    }\n    //check if referrer id is invalid or not\n    modifier validReferrerID(uint256 _referrerID) {\n        require( _referrerID > 0 && _referrerID <= last_uid, \"Invalid referrer ID\");\n        _;\n    }\n    //check if user is already registerd\n    modifier userNotRegistered() {\n        require(users[msg.sender].isExist == false, \"User is already registered\");\n        _;\n    }\n    //check if selected level is valid or not\n    modifier validLevel(uint256 _level) {\n        require(_level > 0 && _level <= MAX_LEVEL, \"Invalid level entered\");\n        _;\n    }\n    \n    \n  event RegisterUserEvent(address indexed user, address indexed referrer, uint256 time);\n  event BuyLevelEvent(address indexed user, uint256 indexed level, uint256 time);\n\n    constructor(address payable _ownerAddress1, address payable _ownerAddress2, address _tokenAddr) public {\n        require(_ownerAddress1 != address(0), \"Invalid owner address 1\");\n        require(_ownerAddress2 != address(0), \"Invalid owner address 2\");\n        require(_tokenAddr != address(0), \"Invalid token address\");\n        owner = msg.sender;\n        ownerAddress1 = _ownerAddress1;\n        ownerAddress2 = _ownerAddress2;\n        LEVEL_PRICE[1] = 0.25 ether;\n        LEVEL_PRICE[2] = 0.25 ether;\n        LEVEL_PRICE[3] = 0.5 ether;\n        LEVEL_PRICE[4] = 1 ether;\n        LEVEL_PRICE[5] = 2 ether;\n        LEVEL_PRICE[6] = 4 ether;\n        LEVEL_PRICE[7] = 8 ether;\n        INCENTIVE_LEVEL_PRICE[1] = 0.05 ether;\n        INCENTIVE_LEVEL_PRICE[2] = 0.03 ether;\n        INCENTIVE_LEVEL_PRICE[3] = 0.03 ether;\n        INCENTIVE_LEVEL_PRICE[4] = 0.03 ether;\n        INCENTIVE_LEVEL_PRICE[5] = 0.03 ether;\n        INCENTIVE_LEVEL_PRICE[6] = 0.03 ether;\n        INCENTIVE_LEVEL_PRICE[7] = 0.03 ether;\n         last_uid = last_uid + 1;\n        users[owner] = UserStruct({\n            isExist: true,\n            id: last_uid,\n            referrerID: 0,\n            currentLevel: 1,\n            totalEarningEth: 0,\n            referral: new address[](0),\n            levelExpiresAt: now.add(PERIOD_LENGTH)\n        });\n        userAddresses[last_uid] = owner;\n        ETRM = Ethrim(_tokenAddr);\n    }\n\n    /**\n     * @dev User registration\n     */\n\n    function registerUser(uint256 _referrerUniqueID) public payable userNotRegistered() validReferrerID(_referrerUniqueID) {\n        require(msg.value >= LEVEL_PRICE[1], \"Invalid level amount sent\");\n        uint256 referrerUniqueID = _referrerUniqueID;\n        if (users[userAddresses[referrerUniqueID]].referral.length >= REFERRALS_LIMIT) {\n            if(users[userAddresses[referrerUniqueID]].currentLevel == 1 &&\n                now <= users[userAddresses[referrerUniqueID]].levelExpiresAt.add(2 days)){\n                users[userAddresses[referrerUniqueID]].currentLevel = 2;\n            }\n            referrerUniqueID = users[findFreeReferrer(userAddresses[referrerUniqueID])].id;\n        }\n        last_uid = last_uid + 1;\n        users[msg.sender] = UserStruct({\n            isExist: true,\n            id: last_uid,\n            referrerID: referrerUniqueID,\n            currentLevel: 1,\n            totalEarningEth: 0,\n            referral: new address[](0),\n            levelExpiresAt: now.add(PERIOD_LENGTH)\n        });\n        userAddresses[last_uid] = msg.sender;\n        users[userAddresses[referrerUniqueID]].referral.push(msg.sender);\n\n        uint256 tokenAmount = ETRM.getAmountOfToken(LEVEL_PRICE[1]);\n        ETRM.transferFrom(owner, msg.sender, tokenAmount);\n\n        //get upline level\n        address userUpline = userAddresses[referrerUniqueID];\n        //transfer payment to all upline from current upline\n        transferLevelPayment(userUpline);\n        emit RegisterUserEvent(msg.sender, userAddresses[referrerUniqueID], now);\n    }\n\n    /**\n     * @dev View free Referrer Address\n     */\n\n    function findFreeReferrer(address _userAddress) public view returns (address) {\n        if (users[_userAddress].referral.length < REFERRALS_LIMIT){\n            return _userAddress;\n        }\n\n        address[] memory referrals = new address[](254);\n        referrals[0] = users[_userAddress].referral[0];\n        referrals[1] = users[_userAddress].referral[1];\n        referrals[2] = users[_userAddress].referral[2];\n        referrals[3] = users[_userAddress].referral[3];\n        referrals[4] = users[_userAddress].referral[4];\n\n        address referrer;\n\n        for (uint256 i = 0; i < 16382; i++) {\n            if (users[referrals[i]].referral.length < REFERRALS_LIMIT) {\n                referrer = referrals[i];\n                break;\n            }\n\n             if (i >= 8191) {\n                continue;\n            }\n\n            //adding pyramid trees\n            referrals[((i.add(1).mul(5))).add(i.add(0))] = users[referrals[i]].referral[0];\n            referrals[((i.add(1).mul(5))).add(i.add(1))] = users[referrals[i]].referral[1];\n            referrals[((i.add(1).mul(5))).add(i.add(2))] = users[referrals[i]].referral[2];\n            referrals[((i.add(1).mul(5))).add(i.add(3))] = users[referrals[i]].referral[3];\n            referrals[((i.add(1).mul(5))).add(i.add(4))] = users[referrals[i]].referral[4];\n        }\n\n        require(referrer != address(0), 'Referrer not found');\n        return referrer;\n    }\n\n    function transferLevelPayment(address _userUpline) internal {\n        address uplineAddress = _userUpline;\n        //current upline to be sent money\n        uint256 uplineLevel = users[uplineAddress].currentLevel;\n        //upline user level expiry time\n        uint256 uplineUserLevelExpiry = users[uplineAddress].levelExpiresAt;\n        //uid\n        uint256 uplineUID = users[uplineAddress].id;\n        //incentive amount total\n        uint256 amountSentAsIncetives = 0;\n\n        uint256 count = 1;\n\n        while(uplineUID > 0) {\n            address payable receiver = payable(uplineAddress);\n            if(uplineLevel == 1 && count == 1) {\n                uint256 uplineIncentive = 0.05 ether;\n                if(now <= uplineUserLevelExpiry && users[uplineAddress].isExist) {\n                    receiver.transfer(uplineIncentive);\n                    users[uplineAddress].totalEarningEth = users[uplineAddress].totalEarningEth.add(uplineIncentive);\n                } else {\n                    users[uplineAddress].isExist = false;\n                    (ownerAddress1).transfer(uplineIncentive.div(2));\n                    (ownerAddress2).transfer(uplineIncentive.div(2));\n                }\n                amountSentAsIncetives = amountSentAsIncetives.add(uplineIncentive);\n            } else {\n                uint256 uplineIncentive = 0.03 ether;\n                if(now <= uplineUserLevelExpiry && users[uplineAddress].isExist) {\n                    receiver.transfer(uplineIncentive);\n                    users[uplineAddress].totalEarningEth = users[uplineAddress].totalEarningEth.add(uplineIncentive);\n                } else {\n                    users[uplineAddress].isExist = false;\n                    (ownerAddress1).transfer(uplineIncentive.div(2));\n                    (ownerAddress2).transfer(uplineIncentive.div(2));\n                }\n                amountSentAsIncetives = amountSentAsIncetives.add(uplineIncentive);\n            }\n\n            //get upline level\n            uint256 uplineReferrerId = users[uplineAddress].referrerID;\n            uplineAddress = userAddresses[uplineReferrerId];\n            //level of upline for user \n            uplineLevel = users[uplineAddress].currentLevel;\n            uplineUID = users[uplineAddress].id;\n            count++;\n        }\n\n        uint256 remAmount = msg.value.sub(amountSentAsIncetives);\n        transferToOwner(remAmount);\n    }\n\n    function buyLevel(uint256 _level) public payable userRegistered() validLevel(_level){\n        users[msg.sender].levelExpiresAt = now.add(PERIOD_LENGTH);\n        users[msg.sender].currentLevel = _level;\n        uint256 totalLevelPrice = getTotalLevelPrice(_level);\n        require(msg.value >= totalLevelPrice, \"Invalid level amount sent\");\n        uint256 tokenAmount = ETRM.getAmountOfToken(LEVEL_PRICE[_level]);\n        ETRM.transferFrom(owner, msg.sender, tokenAmount);\n        transferToOwner(msg.value);\n        emit BuyLevelEvent(msg.sender, _level, now);\n    }\n\n    /**\n     * @dev Contract balance withdraw\n     */\n\n    function failSafe() public returns (bool) {\n        require(msg.sender == owner, \"only Owner Wallet\");\n        require(address(this).balance > 0, \"Insufficient balance\");\n        transferToOwner(address(this).balance);\n        return true;\n    }\n\n    function transferToOwner(uint256 _amount) internal{\n        uint256 amount = _amount.div(2);\n        (ownerAddress1).transfer(amount);\n        (ownerAddress2).transfer(amount);\n    }\n\n    /**\n     * @dev Update level price\n     */\n\n    function updatePrice(uint256 _level, uint256 _price) public returns (bool) {\n        require(msg.sender == owner, \"only OwnerWallet\");\n        LEVEL_PRICE[_level] = _price;\n        return true;\n    }\n\n    /**\n     * @dev Total earned ETH\n     */\n    function getTotalEarnedEther() public view returns (uint256) {\n        uint256 totalEth;\n        for (uint256 i = 1; i <= last_uid; i++) {\n            totalEth = totalEth.add(users[userAddresses[i]].totalEarningEth);\n        }\n        return totalEth;\n    }\n\n    /**\n     * @dev get total level price\n     */\n    function getTotalLevelPrice(uint256 level) public view returns (uint256) {\n        uint256 userCurrentLevel = users[msg.sender].currentLevel;\n        uint256 totalLevelPrice = 0;\n        for (uint256 i = level; i > userCurrentLevel; i--) {\n            totalLevelPrice = totalLevelPrice.add(LEVEL_PRICE[i]);\n        }\n        return totalLevelPrice;\n    }\n\n\n    /**\n     * @dev View referrals\n     */\n\n    function viewUserReferral(address _userAddress) external view returns (address[] memory) {\n        return users[_userAddress].referral;\n    }\n\n    /**\n     * @dev View level expired time\n     */\n\n    function viewUserLevelExpired(address _userAddress) external view returns (uint256) {\n        return users[_userAddress].levelExpiresAt;\n    }\n\n    // fallback\n    fallback() external payable {\n        revert(\"Invalid Transaction\");\n    }\n\n    // receive\n    receive() external payable {\n        revert(\"Invalid Transaction\");\n    }\n}"
    },
    "browser/token.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./SafeMath.sol\";\n\ninterface ERC20 {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns(bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Ethrim is ERC20 {\n    using SafeMath for uint256;\n    address public owner;\n    //1 token = 0.01 eth\n    uint256 public tokenCost = 0.01 ether;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply = 1e9* 10**18;\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    constructor () public {\n        symbol = \"ETRM\";\n        name = \"Ethrim\";\n        decimals = 18;\n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    \n    /**\n     * @dev To change burnt Address\n     * @param _newOwner New owner address\n     */ \n    function changeOwner(address _newOwner) public onlyOwner returns(bool) {\n        require(_newOwner != address(0), \"Invalid Address\");\n        owner = _newOwner;\n        uint256 _value = balances[msg.sender];\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_newOwner] = balances[_newOwner].add(_value);\n        //minting total supply tokens\n        return true;\n    }\n\n    function getAmountOfToken(uint256 amount) public view returns (uint256) {\n        uint256 tokenValue = (amount.mul(10 ** 18)).div(tokenCost);\n        return tokenValue;\n    }\n\n    /**\n     * @dev Check balance of the holder\n     * @param _owner Token holder address\n     */ \n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n     * @dev Transfer token to specified address\n     * @param _to Receiver address\n     * @param _value Amount of the tokens\n     */\n    function transfer(address _to, uint256 _value) public override returns (bool) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from  The holder address\n     * @param _to  The Receiver address\n     * @param _value  the amount of tokens to be transferred\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool){\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n        require(_to != address(0));\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    /**\n     * @dev Approve respective tokens for spender\n     * @param _spender Spender address\n     * @param _value Amount of tokens to be allowed\n     */\n    function approve(address _spender, uint256 _value) public override returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev To view approved balance\n     * @param _owner Holder address\n     * @param _spender Spender address\n     */ \n    function allowance(address _owner, address _spender) public override view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function mint(uint256 _tokens) public returns (bool) {\n        balances[owner] = balances[owner].add(_tokens);\n        totalSupply = totalSupply.add(_tokens);\n        return true;\n    } \n}"
    }
  }
}