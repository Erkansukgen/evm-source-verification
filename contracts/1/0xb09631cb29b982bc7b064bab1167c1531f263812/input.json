{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/ExhibitionConsumer.sol":{"content":"// SPDX-License-Identifier: Not specified\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./interfaces/IUniftyGovernanceConsumer.sol\";\r\nimport \"./interfaces/IUniftyGovernance.sol\";\r\nimport \"./interfaces/IUntPriceOracle.sol\";\r\nimport \"./interfaces/IExhibition.sol\";\r\nimport \"./interfaces/IERC20Simple.sol\";\r\nimport \"./utils/Initializable.sol\";\r\nimport \"./utils/Lockable.sol\";\r\n\r\ncontract ExhibitionConsumer is IUniftyGovernanceConsumer, Initializable, Lockable {\r\n\r\n    IUniftyGovernance public gov;\r\n    IUntPriceOracle public priceOracle;\r\n    address public owner;\r\n    address public exhibition;\r\n    address public untAddress;\r\n    address public nifAddress;\r\n    bool public pausing;\r\n    bool public withdrawOnPause;\r\n    uint256 public exhibitionDuration;\r\n    uint256 public allocationDuration;\r\n    uint256 public override allocationEnd;\r\n    uint256 public exhibitionStart;\r\n    uint256 public override exhibitionEnd;\r\n    uint256 public untRate;\r\n    uint256 public untRateExhibitionController;\r\n    uint256 public controllerVestingDuration;\r\n    uint256 public collectedUnt;\r\n    uint256 public lastCollectionUpdate;\r\n    uint256 public lastCollectionBlock;\r\n    uint256 public optionExerciseDuration;\r\n    uint256 public paidToController;\r\n    uint256 public override graceTime;\r\n    uint256 public version;\r\n    uint256[] public priceProviders;\r\n    string public uriPeer;\r\n    string public consumerName;\r\n    string public consumerDscription;\r\n    mapping(address => uint256) public accountDebt;\r\n    mapping(address => uint256) public accountReserved;\r\n    mapping(address => uint256) public accountPrevAmount;\r\n    \r\n    event Reserved(address indexed user, uint256 untReserved);\r\n\r\n    /**\r\n     * Consumers must hold a reference to the governance.\r\n     * The constructor is the best place to set it up.\r\n     *\r\n     * */\r\n\r\n    function initialize(\r\n        string memory _name,\r\n        string memory _description,\r\n        string memory _peerUri,\r\n        uint256 _graceTime,\r\n        uint256 _untRateStakers,\r\n        uint256 _untRateExhibitionController,\r\n        uint256[] memory _priceProviders,\r\n        uint256 _version,\r\n        address _owner\r\n    ) \r\n    public \r\n    initializer \r\n    {\r\n        require(_owner != address(0), \"Owner must be valid address.\");\r\n        \r\n        gov = IUniftyGovernance(0xfEB5B2E41b0578013FE713F4D153ed96b9320b72);\r\n        priceOracle = IUntPriceOracle(0x79da5be12AC0d9306579deeBc0A8c8dF2A335E9E);\r\n        untAddress = 0xB11A9a955C4DaFaFB20a9bA7d57CDd9269D0E9ce;\r\n        nifAddress = 0xb93370D549A4351FA52b3f99Eb5c252506e5a21e;\r\n        exhibitionDuration = 600; //86400*30;\r\n        allocationDuration = 300; // 86400*3;\r\n        controllerVestingDuration = 300; //86400*30*6;\r\n        optionExerciseDuration = 12000;//86400*30;\r\n        version = _version;\r\n        // untrate: 1000000000000000000\r\n        // untrateExhibitionController: 1000000000000000000\r\n        \r\n        consumerName = _name;\r\n        consumerDscription = _description;\r\n        uriPeer = _peerUri;\r\n        graceTime = _graceTime;\r\n        untRate = _untRateStakers;\r\n        untRateExhibitionController = _untRateExhibitionController;\r\n        priceProviders = _priceProviders;\r\n        owner = _owner;\r\n        Lockable.initialize();\r\n    }\r\n\r\n    /**\r\n     * ############################\r\n     * #\r\n     * # INTERFACE IMPLEMENTATIONS\r\n     * #\r\n     * ########################################\r\n     * */\r\n\r\n    /**\r\n    * Withdraws UNT solely for artists. No options involved here.\r\n    *\r\n    * */\r\n    function withdraw() override external lock returns(uint256){\r\n\r\n        require(!pausing || ( pausing && withdrawOnPause ), \"withdraw: pausing, sorry.\");\r\n        require(exhibition != address(0), \"withdraw: access denied.\");\r\n        require(!isOptionWithdraw(msg.sender), \"withdraw: please try optionWithdraw().\");\r\n        require(msg.sender == IExhibition(exhibition).controller(), \"withdraw: not the exhibition controller.\");\r\n        require(block.timestamp > exhibitionEnd + graceTime, \"withdraw: you are withdrawing too early.\");\r\n\r\n        uint256 balance = ( ( exhibitionEnd - allocationEnd ) * untRateExhibitionController ) - paidToController;\r\n        uint256 _earned = ( ( ( ( block.timestamp - exhibitionEnd ) * 10**18 ) / controllerVestingDuration ) * balance ) / 10**18;\r\n        \r\n        if(_earned > balance){\r\n            \r\n            _earned = balance;\r\n        }\r\n        \r\n        paidToController += _earned;\r\n        \r\n        uint256 paid = payout(msg.sender, _earned);\r\n\r\n        return paid;\r\n    }\r\n    \r\n    /**\r\n    * Withdraws UNT solely for exhibition collectors or stakers. Both have the option to \r\n    * get discounted UNT based on the price set in the unt price oracle.\r\n    *\r\n    * */\r\n    function optionWithdraw(uint256 _amountUnt) override external payable lock returns(uint256){\r\n        \r\n        require(!pausing || ( pausing && withdrawOnPause ), \"optionWithdraw: pausing, sorry.\");\r\n        require(exhibition != address(0), \"optionWithdraw: exhibition not set, access denied.\");\r\n        require(isOptionWithdraw(msg.sender), \"optionWithdraw: not allowed to perform an option withdraw.\");\r\n        require(block.timestamp < exhibitionEnd + optionExerciseDuration, \"optionWithdraw: option exercise window closed.\");\r\n        require(_amountUnt > 0, \"optionWithdraw: amount of unt must be larger than 0.\");\r\n\r\n        if(msg.sender == IExhibition(exhibition).controller()){\r\n            uint256 endTime = block.timestamp;\r\n\r\n            if(endTime > exhibitionEnd){\r\n\r\n                endTime = exhibitionEnd;\r\n            }\r\n\r\n            uint256 _earned = ( ( endTime - allocationEnd ) * untRateExhibitionController ) - paidToController;\r\n            require(_earned >= _amountUnt, \"optionWithdraw: requested more unt than available.\");\r\n            paidToController += _amountUnt;\r\n            \r\n        } else {\r\n\r\n            (IUniftyGovernanceConsumer con,address peer,,,) = gov.accountInfo(msg.sender);\r\n            require(con == this && peer != address(0) && peer == exhibition, \"optionWithdraw: access denied.\");\r\n\r\n            collectUnt();\r\n            uint256 _earned = ( accountReserved[msg.sender] + ( ( collectedUnt * accountPrevAmount[msg.sender] ) / 10**18 ) ) - accountDebt[msg.sender];\r\n            require(_earned >= _amountUnt, \"optionWithdraw: requested more unt than available.\");\r\n            accountDebt[msg.sender] += _amountUnt;\r\n        }\r\n    \r\n        uint256 paid = payout(msg.sender, _amountUnt);\r\n\r\n        (,uint256 ethPrice,,) = priceOracle.getUntPrices();\r\n        uint256 price = (_amountUnt * ethPrice * 10**8) / 10**18;\r\n        \r\n        require(msg.value >= price, \"optionWithdraw: insufficient eth sent.\");\r\n        \r\n        payable(IExhibition(exhibition).uniftyFeeAddress()).transfer(price);\r\n\r\n        return paid;\r\n    }\r\n    \r\n    function isOptionWithdraw(address _account) override public view returns(bool){\r\n        \r\n        return !( IExhibition(exhibition).isArtistExhibition() && _account == IExhibition(exhibition).controller() );\r\n    }\r\n\r\n    function payout(address _to, uint256 _amount) internal returns(uint256) {\r\n        \r\n        require(_amount != 0, \"payout: nothing to pay out.\");\r\n\r\n        gov.mintUnt(_amount);\r\n\r\n        IERC20Simple(untAddress).transfer(_to, _amount);\r\n        \r\n        emit Withdrawn(_to, _amount);\r\n        \r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n    * Must return the account's _current_ UNT earnings (as of current blockchain state).\r\n    *\r\n    * Used in the frontend.\r\n    * */\r\n    function earned(address _account) override external view returns(uint256){\r\n\r\n        if(_account == IExhibition(exhibition).controller()){\r\n            \r\n            uint256 endTime = block.timestamp;\r\n\r\n            if (endTime < allocationEnd ) {\r\n                return 0;\r\n            }\r\n            \r\n            if(endTime > exhibitionEnd){\r\n                \r\n                endTime = exhibitionEnd;\r\n            }\r\n            \r\n            return ( ( endTime - allocationEnd ) * untRateExhibitionController ) - paidToController;\r\n        }\r\n\r\n        (IUniftyGovernanceConsumer con,address peer,,,) = gov.accountInfo(_account);\r\n\r\n        if(con != this || peer != exhibition || exhibition == address(0)){\r\n\r\n            return 0;\r\n        }\r\n\r\n        return ( accountReserved[_account] + ( ( collectedUnt * accountPrevAmount[_account] ) / 10**18 ) ) - accountDebt[_account];\r\n    }\r\n\r\n    /**\r\n     * Same as earned() except adding a live component that may be inaccurate due to not yet occurred state-changes.\r\n     *\r\n     * If unsure how to implement, call and return earned() inside.\r\n     *\r\n     * Used in the frontend.\r\n     * */\r\n    function earnedLive(address _account) override external view returns(uint256){\r\n\r\n        if(_account == IExhibition(exhibition).controller()){\r\n            \r\n            uint256 endTime = block.timestamp;\r\n\r\n            if (endTime < allocationEnd ) {\r\n                return 0;\r\n            }\r\n            \r\n            if(endTime > exhibitionEnd){\r\n                \r\n                endTime = exhibitionEnd;\r\n            }\r\n            \r\n            return ( ( endTime - allocationEnd ) * untRateExhibitionController ) - paidToController;\r\n        }\r\n\r\n        (IUniftyGovernanceConsumer con,address peer,,,) = gov.accountInfo(_account);\r\n\r\n        if(con != this || peer != exhibition || exhibition == address(0)){\r\n\r\n            return 0;\r\n        }\r\n\r\n        uint256 coll = collectedUnt;\r\n\r\n        uint256 alloc = gov.consumerPeerNifAllocation(this, exhibition);\r\n\r\n        if (block.number > lastCollectionBlock && alloc != 0) {\r\n\r\n            coll += ( accumulatedUnt() * 10**18 ) / alloc;\r\n        }\r\n\r\n        return ( accountReserved[_account] + ( ( coll * accountPrevAmount[_account] ) / 10**18 ) ) - accountDebt[_account];\r\n    }\r\n\r\n    function accumulatedUnt() public view returns(uint256){\r\n\r\n        uint256 _lastCollectionUpdate = lastCollectionUpdate;\r\n\r\n        if(_lastCollectionUpdate == 0 || _lastCollectionUpdate >= exhibitionEnd || block.timestamp < allocationEnd){\r\n\r\n            return 0;\r\n        }\r\n\r\n        if(_lastCollectionUpdate < allocationEnd){\r\n\r\n            _lastCollectionUpdate = allocationEnd;\r\n        }\r\n\r\n        if(_lastCollectionUpdate > block.timestamp){\r\n\r\n            return 0;\r\n        }\r\n\r\n        if(block.timestamp >= exhibitionEnd){\r\n\r\n            return ( exhibitionEnd - _lastCollectionUpdate ) * untRate;\r\n        }\r\n\r\n        return ( ( block.timestamp - _lastCollectionUpdate ) * untRate );\r\n    }\r\n\r\n    /**\r\n     * Collect the current UNT based on real-time nif allocations\r\n     * \r\n     * */\r\n    function collectUnt() internal{\r\n\r\n        uint256 alloc = gov.consumerPeerNifAllocation(this, exhibition);\r\n\r\n        if(alloc != 0){\r\n\r\n            collectedUnt += ( accumulatedUnt() * 10**18 ) / alloc;\r\n        }\r\n\r\n        lastCollectionUpdate = block.timestamp;\r\n        lastCollectionBlock = block.number;\r\n    }\r\n    \r\n    /**\r\n     * Override of collectUnt() being used to allow calculations based on previous allocations\r\n     */\r\n    function collectUnt(uint256 nifAllocation) internal{\r\n\r\n        if(nifAllocation != 0){\r\n\r\n            collectedUnt += ( accumulatedUnt() * 10**18 ) / nifAllocation;\r\n        }\r\n\r\n        lastCollectionUpdate = block.timestamp;\r\n        lastCollectionBlock = block.number;\r\n    }\r\n    \r\n    /**\r\n     * _peer parameter to apply the AP info for.\r\n     * \r\n     * Frontend function to help displaying apr/apy and similar strategies.\r\n     *\r\n     * The first index of the returned tuple should return \"r\" if APR or \"y\" if APY.\r\n     * \r\n     * The second index of the returned tuple should return the actual APR/Y value for the consumer.\r\n     * 18 decimals precision required.\r\n     *\r\n     * The 2nd uint256[] array should return a list of proposed services for price discovery on the client-side.\r\n     *\r\n     * 0 = uni-v2 unt/eth\r\n     * 1 = uni-v2 unt/usdt\r\n     * 2 = uni-v2 unt/usdc\r\n     * 3 = uni-v3 unt/eth\r\n     * 4 = uni-v3 unt/usdt\r\n     * 5 = uni-v3 unt/usdc\r\n     * 6 = kucoin unt/usdt\r\n     * 7 = binance unt/usdt\r\n     *\r\n     * The rate and list should be udpatable/extendible through an admin function due to possible updates on the client-side.\r\n     * (e.g. adding more exchanges)\r\n     *\r\n     * */\r\n    function apInfo(address _peer) override external view returns(string memory, uint256, uint256[] memory){\r\n\r\n        if( _peer != exhibition || exhibition == address(0) ){\r\n\r\n            uint256[] memory n;\r\n            return (\"\",0,n);\r\n        }\r\n\r\n        return (\"r\", untRate * 86400 * 365, priceProviders);\r\n    }\r\n\r\n    /**\r\n     * Peer whitelist required to be implemented.\r\n     * If no peers should be used, this can have an empty implementation.\r\n     *\r\n     * Example would be to vote for farms in the governance being included.\r\n     * Accepted peers can then be added to the consumer's internal whitelist and get further benefits like UNT.\r\n     *\r\n     * Must contain a check if the caller has been the governance.\r\n     *\r\n     * Must return a string holding the name of the peer (being used for client display).\r\n     * */\r\n    function whitelistPeer(address _peer) override external lock{\r\n\r\n        require(IUniftyGovernance(msg.sender) == gov, \"whitelistPeer: access denied.\");\r\n        require(exhibition != _peer, \"whitelistPeer: peer exists already.\");\r\n\r\n        exhibition = _peer;\r\n        \r\n        // exhibitionDuration is equal to the actual exhibition duration\r\n        exhibitionStart = block.timestamp;\r\n        exhibitionEnd = exhibitionStart + exhibitionDuration;\r\n        allocationEnd = exhibitionStart + allocationDuration;\r\n    }\r\n\r\n    /**\r\n     * Peer whitelist removal required to be implemented.\r\n     * If no peers should be used, this can have an empty implementation.\r\n     *\r\n     * Example would be to vote for farms in the governance being removed and exluded.\r\n     *\r\n     * Must contain a check if the caller has been the governance.\r\n     *\r\n     * */\r\n    function removePeerFromWhitelist(address _peer) override external lock{\r\n\r\n        require(IUniftyGovernance(msg.sender) == gov, \"removePeerFromWhitelist: access denied.\");\r\n        require(_peer == exhibition, \"removePeerFromWhitelist: peer not whitelisted.\");\r\n\r\n        exhibition = address(0);\r\n    }\r\n\r\n    /**\r\n     * Called by the governance to signal an allocation event.\r\n     *\r\n     * The implementation must limit calls to the governance and should\r\n     * give the consumer a chance to handle allocations (like timestamp updates)\r\n     *\r\n     * Returns true if the allocation has been accepted, false if not.\r\n     * */\r\n    function allocate(address _account, uint256 prevAllocation, address _peer) override external lock returns(bool){\r\n\r\n        require(IUniftyGovernance(msg.sender) == gov, \"allocate: access denied.\");\r\n        require(_peer == exhibition && exhibition != address(0), \"allocate: invalid peer.\");\r\n        require(_account != IExhibition(exhibition).controller(), \"allocate: exbibition controller is not allowed to allocate.\");\r\n\r\n        (,,,,uint256 amount) = gov.accountInfo(_account);\r\n\r\n        if(block.timestamp > allocationEnd || pausing){\r\n\r\n            return false;\r\n        }\r\n\r\n        accountPrevAmount[_account] = amount;\r\n\r\n        collectUnt();\r\n        accountDebt[_account] = ( collectedUnt * amount ) / 10**18;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Called by the governance upon staking if the allocation for a user and a peer changes.\r\n     * The consumer has then the ability to check what has been changed and act accordingly.\r\n     *\r\n     * Must contain a check if the caller has been the governance.\r\n     * */\r\n    function allocationUpdate(address _account, uint256 prevAmount, uint256 prevAllocation, address _peer) override external lock returns(bool, uint256){\r\n\r\n        require(IUniftyGovernance(msg.sender) == gov, \"allocationUpdate: access denied.\");\r\n        require(_peer == exhibition && exhibition != address(0), \"allocationUpdate: invalid peer.\");\r\n\r\n        if(accountPrevAmount[_account] == 0){\r\n\r\n            return (true, 0);\r\n        }\r\n\r\n        (,,,,uint256 amount) = gov.accountInfo(_account);\r\n\r\n        if(amount > accountPrevAmount[_account] && block.timestamp >= allocationEnd){\r\n\r\n            return (false, 0);\r\n        }\r\n\r\n        collectUnt(prevAllocation);\r\n        \r\n        uint256 _earned = ( ( collectedUnt * accountPrevAmount[_account] ) / 10**18 ) - accountDebt[_account];\r\n\r\n        accountDebt[_account] = ( collectedUnt * amount ) / 10**18;\r\n        \r\n        accountPrevAmount[_account] = amount;\r\n        \r\n        accountReserved[_account] += _earned;\r\n\r\n        emit Reserved(_account, _earned);\r\n\r\n        return (true, _earned);\r\n\r\n    }\r\n\r\n    /**\r\n     * Called by the governance to signal an dellocation event.\r\n     *\r\n     * The implementation must limit calls to the governance and should\r\n     * give the consumer a chance to handle allocations (like timestamp updates)\r\n     *\r\n     * */\r\n    function dellocate(address _account, uint256 prevAllocation, address _peer) override external lock returns(uint256){\r\n\r\n        require(IUniftyGovernance(msg.sender) == gov, \"dellocate: access denied.\");\r\n        require(_peer == exhibition && exhibition != address(0), \"dellocate: invalid peer.\");\r\n\r\n        if(accountPrevAmount[_account] == 0){\r\n\r\n            return 0;\r\n        }\r\n\r\n        collectUnt(prevAllocation);\r\n        \r\n        uint256 _earned = ( ( collectedUnt * accountPrevAmount[_account] ) / 10**18 ) - accountDebt[_account];\r\n        accountDebt[_account] = 0;\r\n        accountPrevAmount[_account] = 0;\r\n        \r\n        accountReserved[_account] += _earned;\r\n\r\n        emit Reserved(_account, _earned);\r\n        \r\n        return _earned;\r\n    }\r\n\r\n    /**\r\n     * Must return the time in seconds that is left until the allocation\r\n     * of a user to the peer he is allocating to expires.\r\n     *\r\n     * */\r\n    function timeToUnfreeze(address _account) override external view returns(uint256){\r\n\r\n        (,,,,uint256 amount) = gov.accountInfo(_account);\r\n\r\n        if(amount != 0 && block.timestamp >= allocationEnd && exhibitionEnd > block.timestamp){\r\n\r\n            return exhibitionEnd - block.timestamp;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Called by the governance to determine if allocated stakes of an account in the governance should stay frozen.\r\n     * If this returns true, the governance won't release NIF upon unstaking.\r\n     *\r\n     * */\r\n    function frozen(address _account) override public view returns(bool){\r\n\r\n        (,,,,uint256 amount) = gov.accountInfo(_account);\r\n\r\n        if(amount != 0 && block.timestamp >= allocationEnd && block.timestamp < exhibitionEnd){\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The name of this consumer must be requestable.\r\n     *\r\n     * This information is supposed to be used in clients.\r\n     *\r\n     * */\r\n    function name() override view external returns(string memory){\r\n\r\n        return consumerName;\r\n    }\r\n\r\n    /**\r\n     * The description for this consumer must be requestable.\r\n     *\r\n     * This information is supposed to be used in clients.\r\n     *\r\n     * */\r\n    function description() override view external returns(string memory){\r\n\r\n        return consumerDscription;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns true if the peer is whitelisted, otherwise false.\r\n     *\r\n     * */\r\n    function peerWhitelisted(address _peer) override view external returns(bool){\r\n\r\n        return _peer == exhibition && exhibition != address(0);\r\n    }\r\n\r\n    /**\r\n     * Should return a URI, pointing to a json file in the format:\r\n     *\r\n     * {\r\n     *   name : '',\r\n     *   description : '',\r\n     *   external_link : '',\r\n     * }\r\n     *\r\n     * Can throw an error if the peer is not whitelisted or return an empty string if there is no further information.\r\n     * Since this is supposed to be called by clients, those have to catch errors and handle empty return values themselves.\r\n     *\r\n     * */\r\n    function peerUri(address _peer) override external view returns(string memory){\r\n\r\n        return _peer == exhibition && exhibition != address(0) ? uriPeer : \"\";\r\n    }\r\n\r\n    /**\r\n     * If there are any nif caps per peer, this function should return those.\r\n     * \r\n     * */\r\n    function peerNifCap(address _peer) override external view returns(uint256){\r\n        \r\n        return 0;\r\n    }\r\n    \r\n    /**\r\n     * In case we want to move to a new governance\r\n     *\r\n     * */\r\n    function setGovernance(IUniftyGovernance _gov) external lock{\r\n\r\n        require(owner == msg.sender, \"setGovernance: not the owner.\");\r\n        require(address(_gov) != address(0), \"setGovernance: cannot move to the null address.\");\r\n\r\n        exhibition = address(0);\r\n        \r\n        gov = _gov;\r\n    }\r\n\r\n    function setPeerUri(string calldata _uri) external lock{\r\n\r\n        require(owner == msg.sender, \"setPeerUri: not the owner.\");\r\n\r\n        uriPeer = _uri;\r\n    }\r\n\r\n    function setGraceTime(uint256 _graceTime) external lock{\r\n\r\n        require(owner == msg.sender, \"setGraceTime: not the owner.\");\r\n\r\n        graceTime = _graceTime;\r\n    }\r\n    \r\n    function setPausing(bool _pausing, bool _withdrawOnPause) external lock{\r\n\r\n        require(owner == msg.sender, \"setPausing: not the owner.\");\r\n\r\n        pausing = _pausing;\r\n        withdrawOnPause = _withdrawOnPause;\r\n    }\r\n\r\n\r\n    function setPriceProviders(uint256[] calldata _priceProviders) external lock{\r\n\r\n        require(owner == msg.sender, \"setUntRateAndPriceProviders: not the owner.\");\r\n\r\n        priceProviders = _priceProviders;\r\n    }\r\n\r\n    function setDurations(\r\n        uint256 _exhibitionDuration, \r\n        uint256 _allocationDuration,  \r\n        uint256 _controllerVestingDuration, \r\n        uint256 _optionExerciseDuration) external lock{\r\n\r\n        require(owner == msg.sender, \"setDurations: not the owner.\");\r\n\r\n        exhibitionDuration = _exhibitionDuration;\r\n        allocationDuration = _allocationDuration;\r\n        controllerVestingDuration = _controllerVestingDuration;\r\n        optionExerciseDuration = _optionExerciseDuration;\r\n    }\r\n    \r\n    function setNameAndDescription(string calldata _name, string calldata _description) external lock{\r\n\r\n        require(owner == msg.sender, \"setNameAndDescription: not the owner.\");\r\n\r\n        consumerName = _name;\r\n        consumerDscription = _description;\r\n    }\r\n    \r\n    function setPriceOracle(IUntPriceOracle _priceOracle) external lock{\r\n        \r\n        require(owner == msg.sender, \"setUntPriceOracle: not the owner.\");\r\n        \r\n        priceOracle = _priceOracle;\r\n    }\r\n\r\n    function setRates(uint256 _untRateStakers, uint256 _untRateExhibitionController) external lock{\r\n        \r\n        require(owner == msg.sender, \"setRates: not the owner.\");\r\n        \r\n        untRate = _untRateStakers;\r\n        untRateExhibitionController = _untRateExhibitionController;\r\n    }\r\n    \r\n    function continueExhibition() external lock{\r\n        \r\n        require(owner == msg.sender, \"continueExhibition: not the owner.\");\r\n        \r\n        exhibitionEnd = block.timestamp + exhibitionDuration;\r\n        allocationEnd = block.timestamp + allocationDuration;\r\n        collectUnt();\r\n    }\r\n    \r\n    function optionsRelease() external lock{\r\n        \r\n        require(owner == msg.sender, \"optionRelease: not the owner.\");\r\n        require(block.timestamp >= exhibitionEnd + optionExerciseDuration, \"optionsRelease: options not releasable yet.\");\r\n        \r\n        uint256 grantLeft = gov.earnedUnt(this);\r\n        \r\n        if(!isOptionWithdraw(IExhibition(exhibition).controller())){\r\n            grantLeft -= ( ( exhibitionEnd - allocationEnd ) * untRateExhibitionController ) - paidToController;\r\n        }\r\n        \r\n        gov.mintUnt(grantLeft);\r\n\r\n        IERC20Simple(untAddress).transfer(IExhibition(exhibition).uniftyFeeAddress(), grantLeft);\r\n    }\r\n    \r\n    function emergencyRelease(uint256 _amount) external lock{\r\n        \r\n        require(owner == msg.sender, \"emergencyRelease: not the owner.\");\r\n        \r\n        gov.mintUnt(_amount);\r\n\r\n        IERC20Simple(untAddress).transfer(IExhibition(exhibition).uniftyFeeAddress(), _amount);\r\n    }\r\n    \r\n    function transferOwnership(address _newOwner) external lock{\r\n\r\n        require(owner == msg.sender, \"transferOwnership: not the owner.\");\r\n\r\n        owner = _newOwner;\r\n    }\r\n}"},"contracts/interfaces/IERC20Simple.sol":{"content":"// SPDX-License-Identifier: Not specified\npragma solidity ^0.8.7;\n\n/**\n * @dev Simple Interface with a subset of the ERC20 standard as defined in the EIP needed by the DAO (and not more).\n */\ninterface IERC20Simple {\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}"},"contracts/interfaces/IExhibition.sol":{"content":"// SPDX-License-Identifier: Not specified\npragma solidity ^0.8.7;\n\ninterface IExhibition{\n\n    function isArtistExhibition() external view returns(bool);\n    function controller() external view returns(address);\n    function uniftyFeeAddress() external view returns(address);\n}"},"contracts/interfaces/IUniftyGovernance.sol":{"content":"// SPDX-License-Identifier: Not specified\npragma solidity ^0.8.7;\n\nimport \"./IUniftyGovernanceConsumer.sol\";\n\ninterface IUniftyGovernance{\n\n    /**\n     * Returns the current epoch number.\n     * */\n    function epoch() external returns(uint256);\n\n    /**\n     * Returns the overall grantable $UNT left in the governance contract.\n     * */\n    function grantableUnt() external returns(uint256);\n\n    /**\n     * Can only be called by a registered consumer and _amount cannot exceed the granted $UNT\n     * as per current emission rate.\n     * */\n    function mintUnt(uint256 _amount) external;\n\n    /**\n     * Returns the account info for the given \n     * _account parameters:\n     * \n     * ( \n     *  IUniftyGovernanceConsumer consumer,\n     *  address peer,  \n     *  uint256 allocationTime,\n     *  uint256 unstakableFrom,\n     *  uint256 amount\n     * )\n     * */\n    function accountInfo(address _account) external view returns(IUniftyGovernanceConsumer, address, uint256, uint256, uint256);\n\n    /**\n     * Returns the consumer info for the given _consumer.\n     * \n     * (\n     *  uint256 grantStartTime,\n     *  uint256 grantRateSeconds,\n     *  uint256 grantSizeUnt,\n     *  address[] peers\n     * )\n     * \n     * */\n    function consumerInfo(IUniftyGovernanceConsumer _consumer) external view returns(uint256, uint256, uint256, address[] calldata);\n\n    /**\n     * Returns the amount of accounts allocating to the given _peer of _consumer.\n     * */\n    function nifAllocationLength(IUniftyGovernanceConsumer _consumer, address _peer) external view returns(uint256);\n\n    /**\n     * Returns the currently available $UNT for the given _consumer.\n     * */\n    function earnedUnt(IUniftyGovernanceConsumer _consumer) external view returns(uint256);\n\n    /**\n     * Returns true if the governance is pausing. And fals if not.\n     * It is recommended but not mandatory to take this into account in your own implemenation.\n     * */\n    function isPausing() external view returns(bool);\n\n    /**\n     * The amount of $NIF being allocated to the given _peer of _consumer.\n     * */\n    function consumerPeerNifAllocation(IUniftyGovernanceConsumer _consumer, address _peer) external view returns(uint256);\n}\n"},"contracts/interfaces/IUniftyGovernanceConsumer.sol":{"content":"// SPDX-License-Identifier: Not specified\npragma solidity ^0.8.7;\n\n/**\n * Mandatory interface for a UniftyGovernanceConsumer.\n * \n * */\ninterface IUniftyGovernanceConsumer{\n\n    /**\n     * Must be emitted in withdraw() function.\n     * \n     * */\n    event Withdrawn(address indexed user, uint256 untEarned);\n\n    /**\n     * The name of this consumer must be requestable.\n     * \n     * This information is supposed to be used in clients.\n     * \n     * */\n    function name() external view returns(string calldata);\n\n    /**\n     * The description for this consumer must be requestable.\n     * \n     * This information is supposed to be used in clients.\n     * \n     * */\n    function description() external view returns(string calldata);\n\n    /**\n     * Peer whitelist required to be implemented.\n     * If no peers should be used, this can have an empty implementation.\n     * \n     * Example would be to vote for farms in the governance being included.\n     * Accepted peers can then be added to the consumer's internal whitelist and get further benefits like UNT.\n     * \n     * Must contain a check if the caller has been the governance.\n     * \n     * */\n    function whitelistPeer(address _peer) external;\n\n    /**\n     * Peer whitelist removal required to be implemented.\n     * If no peers should be used, this can have an empty implementation.\n     * \n     * Example would be to vote for farms in the governance being removed and exluded.\n     * \n     * Must contain a check if the caller has been the governance.\n     * \n     * */\n    function removePeerFromWhitelist(address _peer) external;\n\n    /**\n     * Called by the governance to signal an allocation event.\n     * \n     * The implementation must limit calls to the governance and should\n     * give the consumer a chance to handle allocations (like timestamp updates)\n     * \n     * Returns true if the allocation has been accepted, false if not.\n     * \n     * Must contain a check if the caller has been the governance.\n     * */\n    function allocate(address _account, uint256 prevAllocation, address _peer) external returns(bool);\n\n    /**\n     * Called by the governance upon staking if the allocation for a user and a peer changes.\n     * The consumer has then the ability to check what has been changed and act accordingly.\n     *\n     * Must contain a check if the caller has been the governance.\n     * */\n    function allocationUpdate(address _account, uint256 prevAmount, uint256 prevAllocation, address _peer) external returns(bool, uint256);\n\n    /**\n     * Called by the governance to signal an dellocation event.\n     * \n     * The implementation must limit calls to the governance and should\n     * give the consumer a chance to handle allocations (like timestamp updates)\n     * \n     * This functions is also called by the governance before it calls allocate.\n     * This must be akten into account to avoid side-effects.\n     * */\n    function dellocate(address _account, uint256 prevAllocation, address _peer) external returns(uint256);\n\n    /**\n     * Called by the governance to determine if allocated stakes of an account in the governance should stay frozen.\n     * If this returns true, the governance won't release NIF upon unstaking.\n     * \n     * */\n    function frozen(address _account) external view returns(bool);\n\n    /**\n     * Returns true if the peer is whitelisted, otherwise false.\n     * \n     * */\n    function peerWhitelisted(address _peer) external view returns(bool);\n\n    /**\n     * Should return a URI, pointing to a json file in the format:\n     * \n     * {\n     *   name : '',\n     *   description : '',\n     *   external_link : '',\n     * }\n     * \n     * Can throw an error if the peer is not whitelisted or return an empty string if there is no further information.\n     * Since this is supposed to be called by clients, those have to catch errors and handle empty return values themselves.\n     * \n     * */\n    function peerUri(address _peer) external view returns(string calldata);\n\n    /**\n     * Must return the time in seconds that is left until the allocation \n     * of a user to the peer he is allocating to expires.\n     * \n     * */\n    function timeToUnfreeze(address _account) external view returns(uint256);\n\n    function exhibitionEnd() external view returns(uint256);\n\n    function allocationEnd() external view returns(uint256);\n\n    function graceTime() external view returns(uint256);\n\n    /**\n     * _peer parameter to apply the AP info for.\n     * \n     * Frontend function to help displaying apr/apy and similar strategies.\n     *\n     * The first index of the returned tuple should return \"r\" if APR or \"y\" if APY.\n     * \n     * The second index of the returned tuple should return the actual APR/Y value for the consumer.\n     * 18 decimals precision required.\n     *\n     * The 2nd uint256[] array should return a list of proposed services for price discovery on the client-side.\n     *\n     * 0 = uni-v2 unt/eth\n     * 1 = uni-v2 unt/usdt\n     * 2 = uni-v2 unt/usdc\n     * 3 = uni-v3 unt/eth\n     * 4 = uni-v3 unt/usdt\n     * 5 = uni-v3 unt/usdc\n     * 6 = kucoin unt/usdt\n     * 7 = binance unt/usdt\n     *\n     * The rate and list should be udpatable/extendible through an admin function due to possible updates on the client-side.\n     * (e.g. adding more exchanges)\n     *\n     * */\n    function apInfo(address _peer) external view returns(string memory, uint256, uint256[] memory);\n\n    /**\n     * Withdraws UNT rewards for accounts that stake in the governance and allocated their funds to this consumer and peer.\n     * \n     * Must return the amount of withdrawn UNT.\n     * \n     * */\n    function withdraw() external returns(uint256);\n\n    /**\n     *  Withdraws UNT but only if a certain amount of ether has been sent.\n     *  This may enable discounted pricing on UNT based on staking efforts.\n     * \n     *  withdraw() should be rejecting free UNT withdrawals if this is implemented.\n     * \n     *  If this isn't used, it is recommended to send back accidentally paid ether (similar to fallback payable functions)\n     * */\n    function optionWithdraw(uint256 _amountUnt) external payable returns(uint256);\n\n    /**\n     * Should return if the given account is supposed to use optionWithdraw() or not.\n     * \n     * If it returns true, the account must call optionWithdraw() and pay to receive UNT.\n     * If it returns false, the account must call withdraw() to receive earned UNT.\n     * */\n    function isOptionWithdraw(address _account) external returns(bool);\n\n    /**\n     * Must return the account's _current_ UNT earnings (as of current blockchain state).\n     * \n     * Used in the frontend.\n     * */\n    function earned(address _account) external view returns(uint256);\n\n    /**\n     * Same as earned() except adding a live component that may be inaccurate due to not yet occurred state-changes.\n     * \n     * If unsure how to implement, call and return earned() inside.\n     * \n     * Used in the frontend.\n     * */\n    function earnedLive(address _account) external view returns(uint256);\n\n    /**\n     * If there are any nif caps per peer, this function should return those.\n     * \n     * */\n    function peerNifCap(address _peer) external view returns(uint256);\n}"},"contracts/interfaces/IUntPriceOracle.sol":{"content":"// SPDX-License-Identifier: Not specified\npragma solidity ^0.8.7;\n\ninterface IUntPriceOracle{\n\n    function setUntPrices(uint256 _nif, uint256 _eth, uint256 _usdt, uint256 _usdc) external;\n\n    /**\n     * returns (uint256 _nif, uint256 _eth, uint256 _usdt, uint256 _usdc)\n     * */\n    function getUntPrices() external view returns(uint256, uint256, uint256, uint256);\n}"},"contracts/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: Not specified\npragma solidity ^0.8.7;\n\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}"},"contracts/utils/Lockable.sol":{"content":"// SPDX-License-Identifier: Not specified\npragma solidity ^0.8.4;\n\nimport \"./Initializable.sol\";\n\nabstract contract Lockable is Initializable {\n    /* ################################\n    #\n    # RE-ENTRANCY GUARD\n    #\n    ######################################## */\n\n    // re-entrancy protection\n    uint256 public unlocked = 1;\n\n    function initialize() public initializer {\n        unlocked = 1;\n    }\n\n    modifier lock() {\n        require(unlocked == 1, 'Exhibition Consumer: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n}"}}}