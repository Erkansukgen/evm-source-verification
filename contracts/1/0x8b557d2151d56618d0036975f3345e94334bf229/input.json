{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/presale.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.6.0;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n *\n*/\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function ceil(uint a, uint m) internal pure returns (uint r) {\n    return (a + m - 1) / m * m;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// ----------------------------------------------------------------------------\ninterface IToken {\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n}\n\ncontract TokenPresale {\n    \n    using SafeMath for uint256;\n    \n    address constant public tokenAddress =  0x0c9943b4200bcA7738edDc93D7e229cDe1353e5A; // Address of the token to be distributed\n    address payable public fundAddress =  0xf80FEBc1317d97ABbD4EA649B587556F5dd67Dd6; \n    address public _owner; \n    \n    mapping(address => uint256) entries; // Mapped wallet to ETH presale entry\n\n    uint256 public presaleRatePerEth = 20000; // Tokens per 1 ETH\n    uint256 public presaleMaxLimit = 3 * 1 ether; // Max 3 ETH presale limit\n    uint256 public presaleEndUnix = 1607180400; // Presale end UNIX \n    \n    bool public isPaused = false; \n    \n    \n    modifier _onlyActivePresale{\n        require(block.timestamp <= presaleEndUnix && !isPaused, \"Presale is inactive.\");\n        _;\n    }\n    \n   modifier _onlyOwner{\n        require(msg.sender == _owner, \"msg.sender != owner\");\n        _;\n    }\n    \n    constructor() public {\n        _owner = msg.sender;\n    }\n    \n    function setDuration(uint256 _presaleEndUnix) external _onlyOwner {\n        presaleEndUnix = _presaleEndUnix;\n    }\n    \n\n    function setFundAddress(address payable _fundAddress) external _onlyOwner {\n        fundAddress = _fundAddress;\n    }\n    \n    function setPresalePause(bool _pausedPresale) external _onlyOwner {\n        isPaused = _pausedPresale;\n    }\n    \n    function buyTokens() public payable _onlyActivePresale {\n        require(msg.value <= presaleMaxLimit,\"Presale amount can not exceed the presale limit.\");\n        \n        uint256 newEntry = entries[msg.sender].add(msg.value);\n        \n        require(newEntry <= presaleMaxLimit,\"This entry is surpassing the presale max limit. Try a lower entry if your wallet hasn't reached it.\");\n        \n        entries[msg.sender] = entries[msg.sender].add(msg.value); // Add the entry with the wallet previous entry amount\n        \n        uint256 tokens = calculateTokenAmount(msg.value / 1 gwei);\n        \n        require(IToken(tokenAddress).transferFrom(fundAddress, msg.sender, tokens), \"Insufficient fund token balance. Try a lower amount.\");\n     \n        fundAddress.transfer(msg.value); \n    }\n    \n\n    function calculateTokenAmount(uint256 amount) private view returns(uint256){\n        return (amount.mul(presaleRatePerEth));\n    }\n    \n    \n   receive() external payable {\n        buyTokens();\n    }\n}"}}}