{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/asset.sol":{"content":"pragma solidity ^0.6.6;\n\ninterface ERC20 {\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n}\n\ninterface IWeth {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n\nlibrary LibBytes {\n\n    using LibBytes for bytes;\n    \n    function readBytes32(bytes memory b, uint256 index) internal pure returns (bytes32 result)\n    {\n        require(b.length >= index + 32,\"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\");\n        \n        index += 32;\n        \n        // Read the bytes32 from array memory\n        assembly {\n            result := mload(add(b, index))\n        }\n        return result;\n    }\n    \n}\n\ncontract PermissionGroups{\n    \n    address public admin;\n    address public pendingAdmin;\n    mapping(address=>bool) public operatorAllowed;\n    address[] internal operatorsGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n    \n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"onlyAdmin\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operatorAllowed[msg.sender],\"onlyOperator\");\n        _;\n    }\n    \n    function transferAdmin(address newAdmin) external onlyAdmin {\n        require(newAdmin != address(0),\"newAdmin == address(0)\");\n        pendingAdmin = newAdmin;\n    }\n\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender,\"pendingAdmin != msg.sender\");\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) external onlyAdmin {\n        require(!operatorAllowed[newOperator],\"duplicated newOperator\"); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE,\"operatorsGroup.length >= MAX_GROUP_SIZE.\");\n\n        emit OperatorAdded(newOperator, true);\n        operatorAllowed[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) external onlyAdmin {\n        require(operatorAllowed[operator],\"operator is not in the operatorsGroup.\");\n        operatorAllowed[operator] = false;\n\n        for (uint i = 0; i < operatorsGroup.length; i++) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.pop();\n                emit OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n    \n    function getOperators() external view returns(address[] memory) {\n        return operatorsGroup;\n    }\n\n}\n\ncontract AssetManager is PermissionGroups{\n    \n    address public withdrawer;\n    address public wethAddress;\n    mapping(address => bool) public withdrawToAllowed;\n    address[] internal withdrawToGroup;\n    \n    receive() external payable{}\n    fallback() external payable{}\n    \n    modifier onlyWithdrawer() {\n        require(msg.sender == withdrawer,\"onlyWithdrawer\");\n        _;\n    }\n    \n    function setWithdrawer(address _newWithdrawer) external onlyAdmin{\n        withdrawer = _newWithdrawer;\n    }\n\n    event WithdrawToAdded(address withdrawTo, bool isAdd);\n    \n    function addWithdrawToGroup(address[] calldata _addingWithdrawToGroup) external onlyAdmin {\n        for (uint i=0; i < _addingWithdrawToGroup.length; i++) {\n            addWithdrawTo(_addingWithdrawToGroup[i]);\n        }\n    }\n    \n    function addWithdrawTo(address _addingWithdrawTo) private {\n        require(_addingWithdrawTo != address(0),\"_addingWithdrawTo == address(0)\");\n        \n        if(!withdrawToAllowed[_addingWithdrawTo]) { // prevent duplicates.\n            require(withdrawToGroup.length < MAX_GROUP_SIZE,\"withdrawToGroup.length >= MAX_GROUP_SIZE\");\n            emit WithdrawToAdded(_addingWithdrawTo, true);\n            withdrawToAllowed[_addingWithdrawTo] = true;\n            withdrawToGroup.push(_addingWithdrawTo);\n        }\n    }\n\n    function removeWithdrawToGroup(address[] calldata _removingWithdrawToGroup) external onlyAdmin {\n        for (uint i=0; i < _removingWithdrawToGroup.length; i++){\n            removeWithdrawTo(_removingWithdrawToGroup[i]);\n        }\n    }\n    \n    function removeWithdrawTo(address _removingWithdrawTo) private {\n        if(withdrawToAllowed[_removingWithdrawTo]) {\n            withdrawToAllowed[_removingWithdrawTo] = false;\n            for (uint i = 0; i < withdrawToGroup.length; i++) {\n                if (withdrawToGroup[i] == _removingWithdrawTo) {\n                    withdrawToGroup[i] = withdrawToGroup[withdrawToGroup.length - 1];\n                    withdrawToGroup.pop();\n                    emit WithdrawToAdded(_removingWithdrawTo, false);\n                    break;\n                }\n            }\n        }\n    }\n    \n    function getWithdrawToGroup() external view returns(address[] memory) {\n        return withdrawToGroup;\n    }\n    \n    function setWethAddress(address _wethAdress) external onlyAdmin {\n        require(_wethAdress != address(0),\"_wethAdress == address(0)\");\n        wethAddress = _wethAdress;\n    }\n    \n    function withdrawEth(address payable _to, uint _value) external onlyWithdrawer{\n        require(withdrawToAllowed[_to],\"withdrawToAllowed[_to] == false\");\n        _to.transfer(_value);\n    }\n    \n    function withdrawWethByEth(address _to, uint _value) external onlyWithdrawer{\n        require(wethAddress != address(0),\"wethAddress == address(0)\");\n        IWeth(wethAddress).deposit{value:_value}();\n        withdrawToken(wethAddress,_to,_value);\n    }\n    \n    function withdrawToken(address _token, address _to, uint _value) public onlyWithdrawer{\n        require(withdrawToAllowed[_to],\"withdrawToAllowed[_to] == false\");\n        (bool success,bytes memory _data) = _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector,_to,_value));\n        require(success,\"ERC20(_token).transfer failed.\");\n        if(_data.length > 0){\n            require(abi.decode(_data,(bool)),\"ERC20(_token).transfer return data is false.\");\n        }\n    }\n    \n}\n\ncontract TradeAsset is AssetManager{\n    \n    uint256 internal constant MAX_UINT = 2**256 - 1;\n    mapping(address=>bool) internal spenderApproved;\n    address[] internal spendersGroup;\n    mapping(address=>address[]) internal spenderTokensGroup;\n    mapping(address=>mapping(address=>bool)) public tokenSpenderApproved;\n    \n    mapping(address=>bool) public callToAllowed;  // set the whitelist when invoke bridgeCall\n    address[] internal callToGroup;\n\n    function approveTokensSpender(address[] calldata _tokens, address _spender) external onlyAdmin{\n        require(_tokens.length>=1,\"_tokens.length<1\");\n        for(uint i=0; i<_tokens.length; i++){\n            approveTokenSpender(_tokens[i],_spender);\n        }\n    }\n    \n    function disapproveTokensSpender(address[] calldata _tokens, address _spender) external onlyWithdrawer{\n        require(_tokens.length>=1,\"_tokens.length<1\");\n        for(uint i=0; i<_tokens.length; i++){\n            disApproveTokenSpender(_tokens[i],_spender);\n        }\n    }\n    \n    function approveTokenSpender(address _token, address _spender) private{\n        doDisApprove(_token,_spender);\n        doApprove(_token,_spender);\n        \n        if(!tokenSpenderApproved[_token][_spender]){\n            tokenSpenderApproved[_token][_spender] = true;\n            spenderTokensGroup[_spender].push(_token);\n        }\n        if(!spenderApproved[_spender]){\n            spenderApproved[_spender] = true;\n            spendersGroup.push(_spender);\n        }\n    }\n    \n    function disApproveTokenSpender(address _token, address _spender) private{\n        doDisApprove(_token,_spender);\n        \n        if(tokenSpenderApproved[_token][_spender]){\n            tokenSpenderApproved[_token][_spender] = false;\n            address[] storage _tokensGroup = spenderTokensGroup[_spender];\n            for (uint j = 0; j < _tokensGroup.length; j++) {\n                if (_tokensGroup[j] == _token) {\n                    _tokensGroup[j] = _tokensGroup[_tokensGroup.length - 1];\n                    _tokensGroup.pop();\n                    break;\n                }\n            }\n        }\n    }\n    \n    function doApprove(address _token, address _spender) private{\n        (bool success,bytes memory _data) = _token.call(abi.encodeWithSelector(ERC20(_token).approve.selector,_spender,MAX_UINT));\n        require(success,\"approve: ERC20(_token).approve failed.\");\n        if(_data.length > 0){\n            require(abi.decode(_data,(bool)),\"approve: ERC20(_token).approve return data is false.\");\n        }\n    }\n    \n    function doDisApprove(address _token, address _spender) private{\n        (bool success,bytes memory _data) = _token.call(abi.encodeWithSelector(ERC20(_token).approve.selector,_spender,0));\n        require(success,\"disApprove: ERC20(_token).approve failed.\");\n        if(_data.length > 0){\n            require(abi.decode(_data,(bool)),\"disApprove: ERC20(_token).approve return data is false.\");\n        }\n    }\n\n    function getSpendersGroup() external view returns (address[] memory){\n        return spendersGroup;\n    }\n    \n    function getSpenderTokensGroup(address _spender) external view returns (address[] memory){\n        return spenderTokensGroup[_spender];\n    }\n    \n    function addCallTo(address _newCallTo) external onlyAdmin {\n        require(!callToAllowed[_newCallTo],\"duplicated _newCallTo\"); // prevent duplicates.\n       \n        callToAllowed[_newCallTo] = true;\n        callToGroup.push(_newCallTo);\n    }\n\n    function removeCallTo (address _callTo) external onlyWithdrawer {\n        require(callToAllowed[_callTo],\"_callTo is not in the callToGroup.\");\n        callToAllowed[_callTo] = false;\n\n        for (uint i = 0; i < callToGroup.length; i++) {\n            if (callToGroup[i] == _callTo) {\n                callToGroup[i] = callToGroup[callToGroup.length - 1];\n                callToGroup.pop();\n                break;\n            }\n        }\n    }\n    \n    function getCallToGroup() external view returns(address[] memory) {\n        return callToGroup;\n    }\n    \n    function bridgeCall(address _to, uint _value, bytes calldata _payload) external onlyOperator returns (bool,bytes memory){\n        require(callToAllowed[_to],\"_to is not in the callToGroup.\");\n        return _to.call{value:_value}(_payload);\n    }\n    \n}\n\ncontract UniversalAsset is TradeAsset{\n    \n    using LibBytes for bytes;\n    \n    // Magic bytes to be returned by `Wallet` signature type validators.\n    // bytes4(keccak256(\"isValidWalletSignature(bytes32,address,bytes)\"))\n    bytes4 private constant WALLET_MAGIC_VALUE = 0xb0671381;\n    \n    address public signer;\n    function setSigner(address _signer) external onlyAdmin{\n        signer = _signer;\n    }\n    \n    function isValidSignature(bytes32 orderHash, bytes memory signature) public view returns (bytes4) {\n        uint8 v = uint8(signature[0]);\n        bytes32 r = signature.readBytes32(1);\n        bytes32 s = signature.readBytes32(33);\n        \n        require(signer!=address(0),\"signer==address(0)\");\n        require(\n            signer == ecrecover(\n                keccak256(abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n50\", \"StartMyCheck\", orderHash, \"ToWork\"\n                )), v, r, s),\n            \"INVALID_SIGNATURE\"\n        );\n        \n        return WALLET_MAGIC_VALUE;\n    }\n    \n}\n\n"}}}