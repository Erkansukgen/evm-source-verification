{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/Arb2HunterNew.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.6;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./LibGlobal.sol\";\r\n// import \"./DexUniswap.sol\";\r\n// import \"./DexKyber.sol\";\r\n// import \"./DexBancor.sol\";\r\nimport \"./DexUniswapV2.sol\";\r\nimport \"./DexSushiswap.sol\";\r\n// import \"./DexBpt.sol\";\r\nimport \"./Contracts.sol\";\r\nimport \"./LibRealProfit.sol\";\r\nimport \"./LibArb.sol\";\r\n\r\n// deployed at\r\n// not allow any state variable !!!\r\ncontract Arb2HunterNew is Contracts {\r\n    // // -------------------------------------- kyber-uniswap --------------------------------------\r\n    // uint256 constant MASK_FUNC_KYBER_UNISWAP =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000003;\r\n    // uint256 constant MASK_REVERSE_KYBER_UNISWAP =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000004; // 1 getConversionRate, 0 getRate\r\n    // uint256 constant MASK_DECIMAL_KYBER_UNISWAP =\r\n    //     0x00000000000000000000000000000000000000000000000000000000000000F8; // 5 bits\r\n    // uint256 constant MASK_REFUND_KYBER_UNISWAP =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000100; // 1 for enable refund\r\n    // uint256 constant MASK_AMOUNT_KYBER_UNISWAP =\r\n    //     ~(MASK_REFUND_KYBER_UNISWAP |\r\n    //         MASK_DECIMAL_KYBER_UNISWAP |\r\n    //         MASK_REVERSE_KYBER_UNISWAP |\r\n    //         MASK_FUNC_KYBER_UNISWAP);\r\n\r\n    // uint256 constant KYBER_TO_UNISWAP = 1;\r\n    // uint256 constant UNISWAP_TO_KYBER = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // exchange        uniswap exchange\r\n    // reverse         contract to get rate IKyberReverse.getConversionRate or IConversionRates.getRate\r\n    // param           (eth amount|refund|tokenDecimal|reverse type|func) pack\r\n    // kyberHint\r\n    // */\r\n    // function arbTradeX1KyberUniswap(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     address reserve,\r\n    //     UniswapExchangeInterface exchange,\r\n    //     uint256 param,\r\n    //     bytes calldata kyberHint\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_KYBER), DEX_UNISWAP];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_KYBER_UNISWAP) >> 9;\r\n    //     uint256 func = (param & MASK_FUNC_KYBER_UNISWAP);\r\n\r\n    //     arbParam.receipt = address(this);\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_KYBER_UNISWAP) > 0;\r\n\r\n    //     arbParam.reserve = reserve;\r\n    //     arbParam.isReserveContract = (param & MASK_REVERSE_KYBER_UNISWAP) > 0;\r\n    //     arbParam.tokenDecimal = (param & MASK_DECIMAL_KYBER_UNISWAP) >> 3;\r\n    //     arbParam.kyberHint = kyberHint;\r\n    //     arbParam.exchange = exchange;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             func,\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- kyber-uniswapV2 --------------------------------------\r\n    // uint256 constant MASK_FUNC_KYBER_UNISWAP_V2 =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000003;\r\n    // uint256 constant MASK_RESERVE_KYBER_UNISWAP_V2 =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000004; // 1 getConversionRate, 0 getRate\r\n    // uint256 constant MASK_DECIMAL_KYBER_UNISWAP_V2 =\r\n    //     0x00000000000000000000000000000000000000000000000000000000000000F8; // 5 bits\r\n    // uint256 constant MASK_REFUND_KYBER_UNISWAP_V2 =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000100;\r\n    // uint256 constant MASK_AMOUNT_KYBER_UNISWAP_V2 =\r\n    //     ~(MASK_REFUND_KYBER_UNISWAP_V2 |\r\n    //         MASK_DECIMAL_KYBER_UNISWAP_V2 |\r\n    //         MASK_RESERVE_KYBER_UNISWAP_V2 |\r\n    //         MASK_FUNC_KYBER_UNISWAP_V2);\r\n\r\n    // uint256 constant KYBER_TO_UNISWAP_V2 = 1;\r\n    // uint256 constant UNISWAP_V2_TO_KYBER = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // reverse         contract to get rate IKyberReverse.getConversionRate or IConversionRates.getRate\r\n    // pairExchange    uniswap v2 exchange\r\n    // param           (eth amount|refund|tokenDecimal|reverse type|func) pack\r\n    // kyberHint\r\n    // */\r\n    // function arbTradeX1KyberUniswapV2(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     address reserve,\r\n    //     IUniswapV2Pair pairExchange,\r\n    //     uint256 param,\r\n    //     bytes calldata kyberHint\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_KYBER), DEX_UNISWAP_V2];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_KYBER_UNISWAP_V2) >> 9;\r\n    //     uint256 func = (param & MASK_FUNC_KYBER_UNISWAP_V2);\r\n\r\n    //     if (func == KYBER_TO_UNISWAP_V2) {\r\n    //         arbParam.receipt = address(pairExchange);\r\n    //     } else {\r\n    //         arbParam.receipt = address(this);\r\n    //     }\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_KYBER_UNISWAP_V2) > 0;\r\n\r\n    //     arbParam.reserve = reserve;\r\n    //     arbParam.isReserveContract =\r\n    //         (param & MASK_RESERVE_KYBER_UNISWAP_V2) > 0;\r\n    //     arbParam.tokenDecimal = (param & MASK_DECIMAL_KYBER_UNISWAP_V2) >> 3;\r\n    //     arbParam.kyberHint = kyberHint;\r\n    //     arbParam.pairExchange = pairExchange;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             func,\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- bancor-uniswap --------------------------------------\r\n    // uint256 constant MASK_FUNC_BANCOR_UNISWAP =\r\n    //     0x000000000000000000000000000000000000000000000000000000000000000F;\r\n    // uint256 constant MASK_REFUND_BANCOR_UNISWAP =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000010;\r\n    // uint256 constant MASK_AMOUNT_BANCOR_UNISWAP =\r\n    //     ~(MASK_REFUND_BANCOR_UNISWAP | MASK_FUNC_BANCOR_UNISWAP);\r\n\r\n    // uint256 constant BANCOR_TO_UNISWAP = 1;\r\n    // uint256 constant UNISWAP_TO_BANCOR = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // exchange        uniswap exchange contract address for the token\r\n    // thePath[]       the path/reversePath for bancor conversion\r\n    // bancorNetwork   the bancorNetwork address\r\n    // param           (eth amount|refund|func)packed\r\n    // */\r\n    // function arbTradeX1BancorUniswap(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     UniswapExchangeInterface exchange,\r\n    //     address[] calldata thePath,\r\n    //     IBancorNetwork bancorNetwork,\r\n    //     uint256 param\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_BANCOR), DEX_UNISWAP];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_BANCOR_UNISWAP) >> 5;\r\n    //     uint256 func = param & MASK_FUNC_BANCOR_UNISWAP;\r\n\r\n    //     arbParam.receipt = address(this);\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_BANCOR_UNISWAP) > 0;\r\n\r\n    //     arbParam.thePath = thePath;\r\n    //     arbParam.bancorNetwork = bancorNetwork;\r\n    //     arbParam.exchange = exchange;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             func,\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- bancor-uniswapV2 --------------------------------------\r\n    // uint256 constant MASK_FUNC_BANCOR_UNISWAP_V2 =\r\n    //     0x000000000000000000000000000000000000000000000000000000000000000F;\r\n    // uint256 constant MASK_REFUND_BANCOR_UNISWAP_V2 =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000010;\r\n    // uint256 constant MASK_AMOUNT_BANCOR_UNISWAP_V2 =\r\n    //     ~(MASK_REFUND_BANCOR_UNISWAP_V2 | MASK_FUNC_BANCOR_UNISWAP_V2);\r\n\r\n    // uint256 constant BANCOR_TO_UNISWAP_V2 = 1;\r\n    // uint256 constant UNISWAP_V2_TO_BANCOR = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // pairExchange    uniswap v2 exchange\r\n    // thePath[]       the path/reversePath for bancor conversion\r\n    // bancorNetwork   the bancorNetwork address\r\n    // param           (eth amount|refund|func)packed\r\n    // */\r\n    // function arbTradeX1BancorUniswapV2(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     IUniswapV2Pair pairExchange,\r\n    //     address[] calldata thePath,\r\n    //     IBancorNetwork bancorNetwork,\r\n    //     uint256 param\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_BANCOR), DEX_UNISWAP_V2];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_BANCOR_UNISWAP_V2) >> 5;\r\n    //     uint256 func = (param & MASK_FUNC_BANCOR_UNISWAP_V2);\r\n\r\n    //     if (func == BANCOR_TO_UNISWAP_V2) {\r\n    //         arbParam.receipt = address(pairExchange);\r\n    //     } else {\r\n    //         arbParam.receipt = address(this);\r\n    //     }\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_BANCOR_UNISWAP_V2) > 0;\r\n\r\n    //     arbParam.thePath = thePath;\r\n    //     arbParam.bancorNetwork = bancorNetwork;\r\n    //     arbParam.pairExchange = pairExchange;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             func,\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- bancor-kyber --------------------------------------\r\n    // uint256 constant MASK_FUNC_BANCOR_KYBER =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000003;\r\n    // uint256 constant MASK_REVERSE_BANCOR_KYBER =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000004; // 1 getConversionRate, 0 getRate\r\n    // uint256 constant MASK_DECIMAL_BANCOR_KYBER =\r\n    //     0x00000000000000000000000000000000000000000000000000000000000000F8; // 5 bits\r\n    // uint256 constant MASK_REFUND_BANCOR_KYBER =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000100;\r\n    // uint256 constant MASK_AMOUNT_BANCOR_KYBER =\r\n    //     ~(MASK_REFUND_BANCOR_KYBER |\r\n    //         MASK_DECIMAL_BANCOR_KYBER |\r\n    //         MASK_REVERSE_BANCOR_KYBER |\r\n    //         MASK_FUNC_BANCOR_KYBER);\r\n\r\n    // uint256 constant BANCOR_TO_KYBER = 1;\r\n    // uint256 constant KYBER_TO_BANCOR = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // reverse         contract to get rate IKyberReverse.getConversionRate or IConversionRates.getRate\r\n    // thePath[]       the path/reversePath for bancor conversion\r\n    // bancorNetwork   the bancorNetwork address\r\n    // param           (eth amount|refund|tokenDecimal|reverse type|func) pack\r\n    // kyberHint\r\n    // */\r\n    // function arbTradeX1BancorKyber(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     address reserve,\r\n    //     address[] calldata thePath,\r\n    //     IBancorNetwork bancorNetwork,\r\n    //     uint256 param,\r\n    //     bytes calldata kyberHint\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_BANCOR), DEX_KYBER];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     // uint256 amount = (param & MASK_AMOUNT_BANCOR_KYBER) >> 9;\r\n    //     // uint256 func = (param & MASK_FUNC_BANCOR_KYBER);\r\n\r\n    //     arbParam.receipt = address(this);\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_BANCOR_KYBER) > 0;\r\n\r\n    //     arbParam.thePath = thePath;\r\n    //     arbParam.bancorNetwork = bancorNetwork;\r\n    //     arbParam.reserve = reserve;\r\n    //     arbParam.isReserveContract = (param & MASK_REVERSE_BANCOR_KYBER) > 0;\r\n    //     arbParam.tokenDecimal = (param & MASK_DECIMAL_BANCOR_KYBER) >> 3;\r\n    //     arbParam.kyberHint = kyberHint;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             (param & MASK_AMOUNT_BANCOR_KYBER) >> 9, //amount\r\n    //             (param & MASK_FUNC_BANCOR_KYBER), // func\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- uniswap-uniswapV2 --------------------------------------\r\n    // uint256 constant MASK_FUNC_UNISWAP_UNISWAP_V2 =\r\n    //     0x000000000000000000000000000000000000000000000000000000000000000F;\r\n    // uint256 constant MASK_REFUND_UNISWAP_UNISWAP_V2 =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000010;\r\n    // uint256 constant MASK_AMOUNT_UNISWAP_UNISWAP_V2 =\r\n    //     ~(MASK_REFUND_UNISWAP_UNISWAP_V2 | MASK_FUNC_UNISWAP_UNISWAP_V2);\r\n\r\n    // uint256 constant UNISWAP_TO_UNISWAP_V2 = 1;\r\n    // uint256 constant UNISWAP_V2_TO_UNISWAP = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // exchange        uniswap exchange\r\n    // pairExchange    uniswap v2 exchange\r\n    // param           (eth amount|refund|func) pack\r\n    // */\r\n    // function arbTradeX1UniswapUniswapV2(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     UniswapExchangeInterface exchange,\r\n    //     IUniswapV2Pair pairExchange,\r\n    //     uint256 param\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_UNISWAP), DEX_UNISWAP_V2];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_UNISWAP_UNISWAP_V2) >> 5;\r\n    //     uint256 func = (param & MASK_FUNC_UNISWAP_UNISWAP_V2);\r\n\r\n    //     if (func == UNISWAP_TO_UNISWAP_V2) {\r\n    //         arbParam.receipt = address(pairExchange);\r\n    //     } else {\r\n    //         arbParam.receipt = address(this);\r\n    //     }\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_UNISWAP_UNISWAP_V2) > 0;\r\n\r\n    //     arbParam.exchange = exchange;\r\n    //     arbParam.pairExchange = pairExchange;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             func,\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- kyber-bpt --------------------------------------\r\n    // uint256 constant MASK_FUNC_KYBER_BPT =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000003;\r\n    // uint256 constant MASK_REVERSE_KYBER_BPT =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000004; // 1 getConversionRate, 0 getRate\r\n    // uint256 constant MASK_DECIMAL_KYBER_BPT =\r\n    //     0x00000000000000000000000000000000000000000000000000000000000000F8; // 5 bits\r\n    // uint256 constant MASK_REFUND_KYBER_BPT =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000100; // 1 for enable refund\r\n    // uint256 constant MASK_AMOUNT_KYBER_BPT =\r\n    //     ~(MASK_REFUND_KYBER_BPT |\r\n    //         MASK_DECIMAL_KYBER_BPT |\r\n    //         MASK_REVERSE_KYBER_BPT |\r\n    //         MASK_FUNC_KYBER_BPT);\r\n\r\n    // uint256 constant KYBER_TO_BPT = 1;\r\n    // uint256 constant BPT_TO_KYBER = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // reverse         contract to get rate IKyberReverse.getConversionRate or IConversionRates.getRate\r\n    // pool            BPool\r\n    // param           (eth amount|refund|tokenDecimal|reverse type|func) pack\r\n    // kyberHint\r\n    // poolWeightParam BPool (wethWeight|tokenWeight|swapFee) packed\r\n    // */\r\n    // function arbTradeX1KyberBpt(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     address reserve,\r\n    //     IBPool thePool,\r\n    //     uint256 param,\r\n    //     bytes calldata kyberHint,\r\n    //     uint256 poolWeightParam\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_KYBER), DEX_BPT];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_KYBER_BPT) >> 9;\r\n    //     // uint256 func = (param & MASK_FUNC_KYBER_BPT); // avoid stack too deep\r\n\r\n    //     arbParam.receipt = address(this);\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_KYBER_BPT) > 0;\r\n\r\n    //     arbParam.reserve = reserve;\r\n    //     arbParam.isReserveContract = (param & MASK_REVERSE_KYBER_BPT) > 0;\r\n    //     arbParam.tokenDecimal = (param & MASK_DECIMAL_KYBER_BPT) >> 3;\r\n    //     arbParam.kyberHint = kyberHint;\r\n\r\n    //     arbParam.thePool = thePool;\r\n    //     arbParam.poolWeightParam = poolWeightParam;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             (param & MASK_FUNC_KYBER_BPT), // func\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- uniswap-bpt --------------------------------------\r\n    // uint256 constant MASK_FUNC_UNISWAP_BPT =\r\n    //     0x000000000000000000000000000000000000000000000000000000000000000F;\r\n    // uint256 constant MASK_REFUND_UNISWAP_BPT =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000010;\r\n    // uint256 constant MASK_AMOUNT_UNISWAP_BPT =\r\n    //     ~(MASK_REFUND_UNISWAP_BPT | MASK_FUNC_UNISWAP_BPT);\r\n\r\n    // uint256 constant UNISWAP_TO_BPT = 1;\r\n    // uint256 constant BPT_TO_UNISWAP = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // exchange        uniswap exchange\r\n    // pool            BPool\r\n    // param           (eth amount|refund|func) pack\r\n    // poolWeightParam BPool (wethWeight|tokenWeight|swapFee) packed\r\n    // */\r\n    // function arbTradeX1UniswapBpt(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     UniswapExchangeInterface exchange,\r\n    //     IBPool thePool,\r\n    //     uint256 param,\r\n    //     uint256 poolWeightParam\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_UNISWAP), DEX_BPT];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_UNISWAP_BPT) >> 5;\r\n    //     uint256 func = (param & MASK_FUNC_UNISWAP_BPT);\r\n\r\n    //     arbParam.receipt = address(this);\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_UNISWAP_BPT) > 0;\r\n\r\n    //     arbParam.exchange = exchange;\r\n\r\n    //     arbParam.thePool = thePool;\r\n    //     arbParam.poolWeightParam = poolWeightParam;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             func,\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- bancor-bpt --------------------------------------\r\n    // uint256 constant MASK_FUNC_BANCOR_BPT =\r\n    //     0x000000000000000000000000000000000000000000000000000000000000000F;\r\n    // uint256 constant MASK_REFUND_BANCOR_BPT =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000010;\r\n    // uint256 constant MASK_AMOUNT_BANCOR_BPT =\r\n    //     ~(MASK_REFUND_BANCOR_BPT | MASK_FUNC_BANCOR_BPT);\r\n\r\n    // uint256 constant BANCOR_TO_BPT = 1;\r\n    // uint256 constant BPT_TO_BANCOR = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // thePath         the path/reversePath for bancor conversion\r\n    // bancorNetwork   the bancorNetwork address\r\n    // pool            BPool\r\n    // param           (eth amount|refund|func) pack\r\n    // poolWeightParam BPool (wethWeight|tokenWeight|swapFee) packed\r\n    // */\r\n    // function arbTradeX1BancorBpt(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     address[] calldata thePath,\r\n    //     IBancorNetwork bancorNetwork,\r\n    //     IBPool thePool,\r\n    //     uint256 param,\r\n    //     uint256 poolWeightParam\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_BANCOR), DEX_BPT];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_BANCOR_BPT) >> 5;\r\n    //     // uint256 func = (param & MASK_FUNC_BANCOR_BPT); // avoid stack too deep\r\n\r\n    //     arbParam.receipt = address(this);\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_BANCOR_BPT) > 0;\r\n\r\n    //     arbParam.thePath = thePath;\r\n    //     arbParam.bancorNetwork = bancorNetwork;\r\n\r\n    //     arbParam.thePool = thePool;\r\n    //     arbParam.poolWeightParam = poolWeightParam;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             (param & MASK_FUNC_BANCOR_BPT), // func\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // // -------------------------------------- uniswapV2-bpt --------------------------------------\r\n    // uint256 constant MASK_FUNC_UNISWAP_V2_BPT =\r\n    //     0x000000000000000000000000000000000000000000000000000000000000000F;\r\n    // uint256 constant MASK_REFUND_UNISWAP_V2_BPT =\r\n    //     0x0000000000000000000000000000000000000000000000000000000000000010;\r\n    // uint256 constant MASK_AMOUNT_UNISWAP_V2_BPT =\r\n    //     ~(MASK_REFUND_UNISWAP_V2_BPT | MASK_FUNC_UNISWAP_V2_BPT);\r\n\r\n    // uint256 constant UNISWAP_V2_TO_BPT = 1;\r\n    // uint256 constant BPT_TO_UNISWAP_V2 = 2;\r\n\r\n    // /**\r\n    // opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    // token           Erc20 token for trade\r\n    // IUniswapV2Pair  pairExchange,\r\n    // pool            BPool\r\n    // param           (eth amount|refund|func) pack\r\n    // poolWeightParam BPool (wethWeight|tokenWeight|swapFee) packed\r\n    // */\r\n    // function arbTradeX1UniswapV2Bpt(\r\n    //     uint256 opBalanceAndtargetXor,\r\n    //     IERC20 token,\r\n    //     IUniswapV2Pair pairExchange,\r\n    //     IBPool thePool,\r\n    //     uint256 param,\r\n    //     uint256 poolWeightParam\r\n    // ) external returns (address) {\r\n    //     (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n    //     if (!ready) return OWNER;\r\n\r\n    //     Dex[2] memory dexPair = [Dex(DEX_UNISWAP_V2), DEX_BPT];\r\n\r\n    //     LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n    //     uint256 amount = (param & MASK_AMOUNT_UNISWAP_V2_BPT) >> 5;\r\n    //     uint256 func = (param & MASK_FUNC_UNISWAP_V2_BPT);\r\n\r\n    //     if (func == UNISWAP_V2_TO_BPT) {\r\n    //         arbParam.receipt = address(this);\r\n    //     } else {\r\n    //         arbParam.receipt = address(pairExchange);\r\n    //     }\r\n\r\n    //     arbParam.refund = (param & MASK_REFUND_UNISWAP_V2_BPT) > 0;\r\n\r\n    //     arbParam.pairExchange = pairExchange;\r\n\r\n    //     arbParam.thePool = thePool;\r\n    //     arbParam.poolWeightParam = poolWeightParam;\r\n\r\n    //     return\r\n    //         LibArb.arbWithStateCheck(\r\n    //             tId,\r\n    //             opBalanceAndtargetXor,\r\n    //             token,\r\n    //             amount,\r\n    //             func,\r\n    //             arbParam,\r\n    //             dexPair\r\n    //         );\r\n    // }\r\n\r\n    // -------------------------------------- uniswapV2-sushiswap --------------------------------------\r\n    uint256 constant MASK_FUNC_UNISWAP_V2_SUSHISWAP =\r\n        0x000000000000000000000000000000000000000000000000000000000000000F;\r\n    uint256 constant MASK_REFUND_UNISWAP_V2_SUSHISWAP =\r\n        0x0000000000000000000000000000000000000000000000000000000000000010;\r\n    uint256 constant MASK_AMOUNT_UNISWAP_V2_SUSHISWAP =\r\n        ~(MASK_REFUND_UNISWAP_V2_SUSHISWAP | MASK_FUNC_UNISWAP_V2_SUSHISWAP);\r\n\r\n    uint256 constant UNISWAP_V2_TO_SUSHISWAP = 1;\r\n    uint256 constant SUSHISWAP_TO_UNISWAP_V2 = 2;\r\n\r\n    /**\r\n    opBalanceAndtargetXor   (check state op|target balance| target address) pack xor OWNER\r\n    token           Erc20 token for trade\r\n    pairExchangeU    uniswap v2 exchange\r\n    pairExchangeS    sushiswap exchange`\r\n    param           (eth amount|refund|func) pack\r\n    */\r\n    function arbTradeX1UniswapV2Sushiswap(\r\n        uint256 opBalanceAndtargetXor,\r\n        IERC20 token,\r\n        IUniswapV2Pair pairExchangeU,\r\n        ISushiswapPair pairExchangeS,\r\n        uint256 param\r\n    ) external returns (address) {\r\n        (bool ready, bytes32 tId) = LibArb.checkState(opBalanceAndtargetXor);\r\n        if (!ready) return OWNER;\r\n\r\n        Dex[2] memory dexPair = [Dex(DEX_UNISWAP_V2), DEX_SUSHISWAP];\r\n\r\n        LibGlobal.ArbParameterExtra memory arbParam;\r\n\r\n        uint256 amount = (param & MASK_AMOUNT_UNISWAP_V2_SUSHISWAP) >> 5;\r\n        uint256 func = (param & MASK_FUNC_UNISWAP_V2_SUSHISWAP);\r\n\r\n        if (func == UNISWAP_V2_TO_SUSHISWAP) {\r\n            arbParam.receipt = address(pairExchangeS);\r\n        } else {\r\n            arbParam.receipt = address(pairExchangeU);\r\n        }\r\n\r\n        arbParam.refund = (param & MASK_REFUND_UNISWAP_V2_SUSHISWAP) > 0;\r\n\r\n        arbParam.pairExchangeU = pairExchangeU;\r\n        arbParam.pairExchangeS = pairExchangeS;\r\n\r\n        return\r\n            LibArb.arbWithStateCheck(\r\n                tId,\r\n                opBalanceAndtargetXor,\r\n                token,\r\n                amount,\r\n                func,\r\n                arbParam,\r\n                dexPair\r\n            );\r\n    }\r\n}\r\n"
    },
    "browser/Contracts.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./LibGlobal.sol\";\r\n// import \"./DexUniswap.sol\";\r\n// import \"./DexKyber.sol\";\r\n// import \"./DexBancor.sol\";\r\nimport \"./DexUniswapV2.sol\";\r\n// import \"./DexBpt.sol\";\r\n// import \"./DexOasis.sol\";\r\n// import \"./DexCurve.sol\";\r\nimport \"./DexSushiswap.sol\";\r\n\r\ncontract Contracts {\r\n    // !!!!!!!!!!!!!!!!!!!! all must be constant, no state allow !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n\r\n    // ----------------------------------------- public -----------------------------------------\r\n    address constant OWNER = 0xb3E20b057CBF2c0D9d099baC6772aF0c948C6ADe;\r\n\r\n    // DexUniswap constant DEX_UNISWAP =\r\n    //     DexUniswap(0xE8eeE3d7f849cBC26E942fF2a78D420b34139103);\r\n    DexUniswapV2 constant DEX_UNISWAP_V2 =\r\n        DexUniswapV2(0x03960F7014FB623668CE0EB1870563C94E536559);\r\n    // DexOasis constant DEX_OASIS =\r\n    //     DexOasis(0x23E1DB8C6503fBca0bF3e0b83EB32943E9B82eD8);\r\n    // DexBpt constant DEX_BPT =\r\n    //     DexBpt(0x5c830620eacA3176C74B5935A5daecD1094cd6a5);\r\n    // DexBancor constant DEX_BANCOR =\r\n    //     DexBancor(0x73677bE42a0ee9c1c2a2388e6F8d96443D710C5d);\r\n    // DexKyber constant DEX_KYBER =\r\n    //     DexKyber(0x9a5921D128d9408F45dF42fe08501b95BB4e6A8e);\r\n    // DexCurve constant DEX_CURVE =\r\n    //     DexCurve(0xa4c8d6e51d117a847d47dbAa32d3d1Be80669bd8);\r\n    DexSushiswap constant DEX_SUSHISWAP =\r\n        DexSushiswap(0x5A5A2180ECC071f7a089dED0176400110fb779db);\r\n\r\n    // // must in order\r\n    // Dex[7] constant ALL_DEX = [\r\n    //     Dex(DEX_UNISWAP),\r\n    //     DEX_UNISWAP_V2,\r\n    //     DEX_OASIS,\r\n    //     DEX_BPT,\r\n    //     DEX_BANCOR,\r\n    //     DEX_KYBER,\r\n    //     DEX_SUSHISWAP\r\n    // ];\r\n}\r\n"
    },
    "browser/Dex.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./LibGlobal.sol\";\r\n\r\n// not allow any state variable !!!\r\nabstract contract Dex {\r\n    IERC20 constant WETH_TOKEN =\r\n        IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n    function tradeEthToTokenFast(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable virtual returns (uint256 tokenAmount);\r\n\r\n    function tradeTokenToEthFast(\r\n        IERC20 token,\r\n        uint256 tokenAmount0,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable virtual;\r\n\r\n    function tradeEthToTokenTest(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory result\r\n    ) public payable virtual;\r\n\r\n    function tradeTokenToEthTest(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory result\r\n    ) public payable virtual;\r\n\r\n    function ethToTokenReturnFast(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable virtual returns (uint256 tokenAmount);\r\n\r\n    function ethToTokenReturnTest(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ProfitParameterExtra memory param\r\n    )\r\n        public\r\n        payable\r\n        virtual\r\n        returns (\r\n            uint256 tokenAmount,\r\n            LibGlobal.ProfitResultExtra memory profitResultExtra\r\n        );\r\n\r\n    function tokenToEthReturnFast(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable virtual returns (uint256 ethAmount);\r\n\r\n    function tokenToEthReturnTest(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory profitResultExtra\r\n    )\r\n        public\r\n        payable\r\n        virtual\r\n        returns (uint256 ethAmount, LibGlobal.ProfitResultExtra memory);\r\n\r\n    function tradeTokenToTokenFast(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount0,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        bytes memory data\r\n    ) public payable virtual returns (uint256 tokenAmountOut) {\r\n        fromToken;\r\n        toToken;\r\n        tokenAmount0;\r\n        arbParam;\r\n        data;\r\n\r\n        tokenAmountOut;\r\n\r\n        require(false, \"Not implemented\");\r\n    }\r\n\r\n    function tradeTokenToTokenTest(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory profitResultExtraMid\r\n    ) public payable virtual {\r\n        fromToken;\r\n        toToken;\r\n        tokenAmount;\r\n        param;\r\n        profitResultExtraMid;\r\n\r\n        require(false, \"Not implemented\");\r\n    }\r\n\r\n    function tokenToTokenReturnFast(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        bytes memory data\r\n    ) public payable virtual returns (uint256) {\r\n        fromToken;\r\n        toToken;\r\n        tokenAmount;\r\n        arbParam;\r\n        data;\r\n\r\n        require(false, \"Not implemented\");\r\n        return 0;\r\n    }\r\n\r\n    function tokenToTokenReturnTest(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param\r\n    )\r\n        public\r\n        payable\r\n        virtual\r\n        returns (\r\n            uint256 tokenAmount2,\r\n            LibGlobal.ProfitResultExtra memory profitResultExtraMid\r\n        )\r\n    {\r\n        fromToken;\r\n        toToken;\r\n        tokenAmount;\r\n        param;\r\n\r\n        tokenAmount2;\r\n        profitResultExtraMid;\r\n\r\n        require(false, \"Not implemented\");\r\n    }\r\n}\r\n"
    },
    "browser/DexSushiswap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./LibSafeERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./ISushiswapFactory.sol\";\r\nimport \"./ISushiswapPair.sol\";\r\nimport \"./SushiswapLibrary.sol\";\r\nimport \"./LibGlobal.sol\";\r\nimport \"./Dex.sol\";\r\n\r\n// deployed at\r\n// not allow any state variable !!!\r\ncontract DexSushiswap is Dex {\r\n    using SafeMath for uint256;\r\n    using LibSafeERC20 for IERC20;\r\n\r\n    ISushiswapFactory constant SUSHISWAP_FACTORY =\r\n        ISushiswapFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\r\n\r\n    function tradeEthToTokenFast(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable override returns (uint256 tokenAmount) {\r\n        tokenAmount = sushiswapTradeEthToToken(\r\n            token,\r\n            amount,\r\n            param.pairExchangeS,\r\n            param.receipt\r\n        );\r\n    }\r\n\r\n    function sushiswapTradeEthToToken(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        ISushiswapPair pairExchange,\r\n        address receipt\r\n    ) private returns (uint256 tokenAmount) {\r\n        LibGlobal.buyWeth(amount);\r\n\r\n        WETH_TOKEN.transfer(address(pairExchange), amount);\r\n\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n        tokenAmount = sushiswapEthToTokenReturn2(\r\n            pairExchange,\r\n            amount,\r\n            tokenIsToken0\r\n        );\r\n        uint256 amount0Out = tokenIsToken0 ? tokenAmount : 0;\r\n        uint256 amount1Out = tokenIsToken0 ? 0 : tokenAmount;\r\n        pairExchange.swap(amount0Out, amount1Out, receipt, new bytes(0));\r\n    }\r\n\r\n    function tradeTokenToEthFast(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable override {\r\n        tokenAmount;\r\n        sushiswapTradeTokenToEth(token, param.pairExchangeS);\r\n    }\r\n\r\n    function sushiswapTradeTokenToEth(IERC20 token, ISushiswapPair pairExchange)\r\n        private\r\n    {\r\n        // require transfer token to pairExchange first\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n\r\n        uint256 reserveIn = tokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = tokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        uint256 tokenAmount =\r\n            token.balanceOf(address(pairExchange)) - reserveIn;\r\n\r\n        uint256 ethAmount = getAmountOut(tokenAmount, reserveIn, reserveOut);\r\n\r\n        uint256 amount0Out = tokenIsToken0 ? 0 : ethAmount;\r\n        uint256 amount1Out = tokenIsToken0 ? ethAmount : 0;\r\n        pairExchange.swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n\r\n        LibGlobal.sellWeth(ethAmount);\r\n    }\r\n\r\n    function tradeEthToTokenTest(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory result\r\n    ) public payable override {\r\n        param;\r\n        result;\r\n\r\n        LibGlobal.buyWeth(amount);\r\n        address pairExchange = calcPairExchange(token);\r\n        WETH_TOKEN.transfer(pairExchange, amount);\r\n\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n        uint256 amountOut =\r\n            sushiswapEthToTokenReturn2(\r\n                ISushiswapPair(pairExchange),\r\n                amount,\r\n                tokenIsToken0\r\n            );\r\n        uint256 amount0Out = tokenIsToken0 ? amountOut : 0;\r\n        uint256 amount1Out = tokenIsToken0 ? 0 : amountOut;\r\n        ISushiswapPair(pairExchange).swap(\r\n            amount0Out,\r\n            amount1Out,\r\n            address(this),\r\n            new bytes(0)\r\n        );\r\n    }\r\n\r\n    function tradeTokenToEthTest(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory result\r\n    ) public payable override {\r\n        param;\r\n        result;\r\n        address pairExchange = calcPairExchange(token);\r\n        token.safeTransfer(address(pairExchange), tokenAmount);\r\n\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n\r\n        uint256 ethAmount =\r\n            sushiswapTokenToEthReturn(\r\n                token,\r\n                ISushiswapPair(pairExchange),\r\n                tokenIsToken0\r\n            );\r\n\r\n        uint256 amount0Out = tokenIsToken0 ? 0 : ethAmount;\r\n        uint256 amount1Out = tokenIsToken0 ? ethAmount : 0;\r\n        ISushiswapPair(pairExchange).swap(\r\n            amount0Out,\r\n            amount1Out,\r\n            address(this),\r\n            new bytes(0)\r\n        );\r\n\r\n        LibGlobal.sellWeth(ethAmount);\r\n    }\r\n\r\n    function sushiswapTokenToEthReturn(\r\n        IERC20 token,\r\n        ISushiswapPair pairExchange,\r\n        bool tokenIsToken0\r\n    ) private view returns (uint256 ethAmount) {\r\n        // WARNING!!! require transfer token to pairExchange first, use to calc before real trade\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n\r\n        uint256 reserveIn = tokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = tokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        uint256 tokenAmount =\r\n            token.balanceOf(address(pairExchange)).sub(reserveIn);\r\n\r\n        ethAmount = SushiswapLibrary.getAmountOut(\r\n            tokenAmount,\r\n            reserveIn,\r\n            reserveOut\r\n        );\r\n    }\r\n\r\n    function ethToTokenReturnFast(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable override returns (uint256 tokenAmount) {\r\n        tokenAmount = sushiswapEthToTokenReturn2(\r\n            param.pairExchangeS,\r\n            amount,\r\n            token < WETH_TOKEN\r\n        );\r\n    }\r\n\r\n    function sushiswapEthToTokenReturn2(\r\n        ISushiswapPair pairExchange,\r\n        uint256 amount,\r\n        bool tokenIsToken0\r\n    ) private view returns (uint256 tokenAmount) {\r\n        tokenAmount = getReturn(pairExchange, amount, !tokenIsToken0);\r\n    }\r\n\r\n    function sushiswapEthToTokenReturn(\r\n        ISushiswapPair pairExchange,\r\n        uint256 amount,\r\n        bool tokenIsToken0\r\n    ) private view returns (uint256) {\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n        if (reserve0 == 0 || reserve1 == 0) return 0;\r\n\r\n        uint256 reserveIn = tokenIsToken0 ? reserve1 : reserve0;\r\n        uint256 reserveOut = tokenIsToken0 ? reserve0 : reserve1;\r\n\r\n        return SushiswapLibrary.getAmountOut(amount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function sushiswapEthToTokenReturn(\r\n        IERC20 token,\r\n        ISushiswapPair pairExchange,\r\n        uint256 amount\r\n    ) private view returns (uint256) {\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n        return sushiswapEthToTokenReturn(pairExchange, amount, tokenIsToken0);\r\n    }\r\n\r\n    function ethToTokenReturnTest(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ProfitParameterExtra memory param\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns (\r\n            uint256 tokenAmount,\r\n            LibGlobal.ProfitResultExtra memory profitResultExtra\r\n        )\r\n    {\r\n        param;\r\n        ISushiswapPair pairExchange = getPairExchange(token);\r\n        if (pairExchange == ISushiswapPair(0x0)) return (0, profitResultExtra);\r\n        profitResultExtra.pairExchangeS = pairExchange;\r\n\r\n        tokenAmount = sushiswapEthToTokenReturn(token, pairExchange, amount);\r\n    }\r\n\r\n    function tokenToEthReturnFast(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable override returns (uint256 ethAmount) {\r\n        token;\r\n        if (tokenAmount == 0) return 0;\r\n        ethAmount = getReturn(\r\n            param.pairExchangeS,\r\n            tokenAmount,\r\n            token < WETH_TOKEN\r\n        );\r\n    }\r\n\r\n    function sushiswapTokenToEthReturn(\r\n        ISushiswapPair pairExchange,\r\n        uint256 tokenAmount,\r\n        bool tokenIsToken0\r\n    ) private view returns (uint256) {\r\n        if (tokenAmount == 0) return 0;\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n        if (reserve0 == 0 || reserve1 == 0) return 0;\r\n\r\n        uint256 reserveIn = tokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = tokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        return\r\n            SushiswapLibrary.getAmountOut(tokenAmount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function sushiswapTokenToEthReturn(\r\n        IERC20 token,\r\n        ISushiswapPair pairExchange,\r\n        uint256 tokenAmount\r\n    ) private view returns (uint256) {\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n        return\r\n            sushiswapTokenToEthReturn(pairExchange, tokenAmount, tokenIsToken0);\r\n    }\r\n\r\n    function tokenToEthReturnTest(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory profitResultExtra\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns (uint256 ethAmount, LibGlobal.ProfitResultExtra memory)\r\n    {\r\n        param;\r\n        ISushiswapPair pairExchange = getPairExchange(token);\r\n        if (pairExchange == ISushiswapPair(0x0)) return (0, profitResultExtra);\r\n        profitResultExtra.pairExchangeS = pairExchange;\r\n\r\n        ethAmount = sushiswapTokenToEthReturn(token, pairExchange, tokenAmount);\r\n\r\n        return (ethAmount, profitResultExtra);\r\n    }\r\n\r\n    function tradeTokenToTokenFast(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount0,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        bytes memory data\r\n    ) public payable override returns (uint256) {\r\n        arbParam;\r\n        tokenAmount0;\r\n\r\n        ISushiswapPair pairExchange = abi.decode(data, (ISushiswapPair));\r\n        bool fromTokenIsToken0 = fromToken < toToken;\r\n\r\n        // fromToken had been transfered to pairExchange\r\n        uint256 amountOut =\r\n            sushiswapTokenToTokenReturnTransferAdvance(\r\n                fromToken,\r\n                pairExchange,\r\n                fromTokenIsToken0\r\n            );\r\n\r\n        uint256 amount0Out = fromTokenIsToken0 ? 0 : amountOut;\r\n        uint256 amount1Out = fromTokenIsToken0 ? amountOut : 0;\r\n        pairExchange.swap(\r\n            amount0Out,\r\n            amount1Out,\r\n            arbParam.receipt,\r\n            new bytes(0)\r\n        );\r\n\r\n        return amountOut;\r\n    }\r\n\r\n    function tradeTokenToTokenTest(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory profitResultExtraMid\r\n    ) public payable override {\r\n        param;\r\n        profitResultExtraMid;\r\n\r\n        ISushiswapPair pairExchange = calcPairExchange(fromToken, toToken);\r\n        fromToken.safeTransfer(address(pairExchange), tokenAmount);\r\n\r\n        bool fromTokenIsToken0 = fromToken < toToken;\r\n\r\n        uint256 amountOut =\r\n            sushiswapTokenToTokenReturnTransferAdvance(\r\n                fromToken,\r\n                pairExchange,\r\n                fromTokenIsToken0\r\n            );\r\n\r\n        uint256 amount0Out = fromTokenIsToken0 ? 0 : amountOut;\r\n        uint256 amount1Out = fromTokenIsToken0 ? amountOut : 0;\r\n        pairExchange.swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    function tokenToTokenReturnFast(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        bytes memory data\r\n    ) public payable override returns (uint256) {\r\n        arbParam;\r\n\r\n        ISushiswapPair pairExchange = abi.decode(data, (ISushiswapPair));\r\n        return\r\n            sushiswapTokenToTokenReturn(\r\n                pairExchange,\r\n                tokenAmount,\r\n                fromToken < toToken\r\n            );\r\n    }\r\n\r\n    function tokenToTokenReturnTest(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns (\r\n            uint256,\r\n            LibGlobal.ProfitResultExtra memory profitResultExtraMid\r\n        )\r\n    {\r\n        param;\r\n\r\n        ISushiswapPair pairExchange =\r\n            ISushiswapPair(\r\n                SUSHISWAP_FACTORY.getPair(address(fromToken), address(toToken))\r\n            );\r\n        if (pairExchange == ISushiswapPair(0x0))\r\n            return (0, profitResultExtraMid);\r\n        profitResultExtraMid.pairExchangeS = pairExchange;\r\n\r\n        return (\r\n            sushiswapTokenToTokenReturn(\r\n                pairExchange,\r\n                tokenAmount,\r\n                fromToken < toToken\r\n            ),\r\n            profitResultExtraMid\r\n        );\r\n    }\r\n\r\n    function sushiswapTokenToTokenReturnTransferAdvance(\r\n        IERC20 fromToken,\r\n        ISushiswapPair pairExchange,\r\n        bool fromTokenIsToken0\r\n    ) private view returns (uint256) {\r\n        // WARNING!!! require transfer token to pairExchange first, use to calc before trade\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n\r\n        uint256 reserveIn = fromTokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = fromTokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        uint256 tokenAmount =\r\n            fromToken.balanceOf(address(pairExchange)).sub(reserveIn);\r\n\r\n        return\r\n            SushiswapLibrary.getAmountOut(tokenAmount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function sushiswapTokenToTokenReturn(\r\n        ISushiswapPair pairExchange,\r\n        uint256 tokenAmount,\r\n        bool fromTokenIsToken0\r\n    ) private view returns (uint256) {\r\n        if (tokenAmount == 0) return 0;\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n        if (reserve0 == 0 || reserve1 == 0) return 0;\r\n\r\n        uint256 reserveIn = fromTokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = fromTokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        return\r\n            SushiswapLibrary.getAmountOut(tokenAmount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getPairExchange(IERC20 token)\r\n        private\r\n        view\r\n        returns (ISushiswapPair pairExchange)\r\n    {\r\n        pairExchange = ISushiswapPair(\r\n            SUSHISWAP_FACTORY.getPair(address(WETH_TOKEN), address(token))\r\n        );\r\n    }\r\n\r\n    function calcPairExchange(IERC20 token)\r\n        private\r\n        pure\r\n        returns (address pairExchange)\r\n    {\r\n        pairExchange = SushiswapLibrary.pairFor(\r\n            address(SUSHISWAP_FACTORY),\r\n            address(token),\r\n            address(WETH_TOKEN)\r\n        );\r\n    }\r\n\r\n    function calcPairExchange(IERC20 token1, IERC20 token2)\r\n        private\r\n        pure\r\n        returns (ISushiswapPair pairExchange)\r\n    {\r\n        pairExchange = ISushiswapPair(\r\n            SushiswapLibrary.pairFor(\r\n                address(SUSHISWAP_FACTORY),\r\n                address(token1),\r\n                address(token2)\r\n            )\r\n        );\r\n    }\r\n\r\n    function getReserves(IERC20 token)\r\n        private\r\n        view\r\n        returns (uint256 tokenReserve, uint256 wethReserve)\r\n    {\r\n        (tokenReserve, wethReserve) = getReserves(token, WETH_TOKEN);\r\n    }\r\n\r\n    function getReserves(IERC20 tokenA, IERC20 tokenB)\r\n        private\r\n        view\r\n        returns (uint256 reserveA, uint256 reserveB)\r\n    {\r\n        (reserveA, reserveB) = SushiswapLibrary.getReserves(\r\n            address(SUSHISWAP_FACTORY),\r\n            address(tokenA),\r\n            address(tokenB)\r\n        );\r\n    }\r\n\r\n    function getReturn(\r\n        ISushiswapPair pairExchange,\r\n        uint256 inputAmount,\r\n        bool isToken0ToToken1\r\n    ) private view returns (uint256) {\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n        uint256 inputReserve = isToken0ToToken1 ? reserve0 : reserve1;\r\n        uint256 outputReserve = isToken0ToToken1 ? reserve1 : reserve0;\r\n        return getAmountOut(inputAmount, inputReserve, outputReserve);\r\n    }\r\n\r\n    function getAmountOut(\r\n        uint256 inputAmount,\r\n        uint256 inputReserve,\r\n        uint256 outputReserve\r\n    ) private pure returns (uint256) {\r\n        uint256 inputAmountWithFee = inputAmount * 997;\r\n        uint256 numerator = inputAmountWithFee * outputReserve;\r\n        uint256 denominator = (inputReserve * 1000) + inputAmountWithFee;\r\n\r\n        return numerator / denominator;\r\n    }\r\n}\r\n"
    },
    "browser/DexUniswapV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./LibSafeERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./IUniswapV2Factory.sol\";\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./UniswapV2Library.sol\";\r\nimport \"./LibGlobal.sol\";\r\nimport \"./Dex.sol\";\r\n\r\n// deployed at 0x03960F7014FB623668CE0EB1870563C94E536559\r\n// not allow any state variable !!!\r\ncontract DexUniswapV2 is Dex {\r\n    using SafeMath for uint256;\r\n    using LibSafeERC20 for IERC20;\r\n\r\n    IUniswapV2Factory constant UNISWAP_V2_FACTORY =\r\n        IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n\r\n    function tradeEthToTokenFast(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable override returns (uint256 tokenAmount) {\r\n        tokenAmount = uniswapV2TradeEthToToken(\r\n            token,\r\n            amount,\r\n            param.pairExchangeU,\r\n            param.receipt\r\n        );\r\n    }\r\n\r\n    function uniswapV2TradeEthToTokenQuick(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        IUniswapV2Pair pairExchange\r\n    ) public returns (uint256 tokenAmount) {\r\n        tokenAmount = uniswapV2TradeEthToToken(\r\n            token,\r\n            amount,\r\n            pairExchange,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    function uniswapV2TradeEthToTokenFront(\r\n        uint256 amount,\r\n        IUniswapV2Pair pairExchange,\r\n        bool tokenIsToken0,\r\n        uint256 reserve0,\r\n        uint256 reserve1\r\n    ) public returns (uint256 tokenAmount) {\r\n        LibGlobal.buyWeth(amount);\r\n\r\n        WETH_TOKEN.transfer(address(pairExchange), amount);\r\n\r\n        uint256 inputReserve = tokenIsToken0 ? reserve1 : reserve0;\r\n        uint256 outputReserve = tokenIsToken0 ? reserve0 : reserve1;\r\n        tokenAmount = getAmountOut(amount, inputReserve, outputReserve);\r\n\r\n        uint256 amount0Out = tokenIsToken0 ? tokenAmount : 0;\r\n        uint256 amount1Out = tokenIsToken0 ? 0 : tokenAmount;\r\n        pairExchange.swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    function uniswapV2TradeEthToToken(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        IUniswapV2Pair pairExchange,\r\n        address receipt\r\n    ) private returns (uint256 tokenAmount) {\r\n        LibGlobal.buyWeth(amount);\r\n\r\n        WETH_TOKEN.transfer(address(pairExchange), amount);\r\n\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n        tokenAmount = uniswapV2EthToTokenReturn2(\r\n            pairExchange,\r\n            amount,\r\n            tokenIsToken0\r\n        );\r\n        uint256 amount0Out = tokenIsToken0 ? tokenAmount : 0;\r\n        uint256 amount1Out = tokenIsToken0 ? 0 : tokenAmount;\r\n        pairExchange.swap(amount0Out, amount1Out, receipt, new bytes(0));\r\n    }\r\n\r\n    function tradeTokenToEthFast(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable override {\r\n        tokenAmount;\r\n        uniswapV2TradeTokenToEth(token, param.pairExchangeU);\r\n    }\r\n\r\n    function uniswapV2TradeTokenToEthFront(\r\n        IERC20 token,\r\n        IUniswapV2Pair pairExchange\r\n    ) public {\r\n        uniswapV2TradeTokenToEth(token, pairExchange);\r\n    }\r\n\r\n    function uniswapV2TradeTokenToEthQuick(\r\n        IERC20 token,\r\n        IUniswapV2Pair pairExchange\r\n    ) public {\r\n        uniswapV2TradeTokenToEth(token, pairExchange);\r\n    }\r\n\r\n    function uniswapV2TradeTokenToEth(IERC20 token, IUniswapV2Pair pairExchange)\r\n        private\r\n    {\r\n        // require transfer token to pairExchange first\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n\r\n        uint256 reserveIn = tokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = tokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        uint256 tokenAmount =\r\n            token.balanceOf(address(pairExchange)) - reserveIn;\r\n\r\n        uint256 ethAmount = getAmountOut(tokenAmount, reserveIn, reserveOut);\r\n\r\n        uint256 amount0Out = tokenIsToken0 ? 0 : ethAmount;\r\n        uint256 amount1Out = tokenIsToken0 ? ethAmount : 0;\r\n        pairExchange.swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n\r\n        LibGlobal.sellWeth(ethAmount);\r\n    }\r\n\r\n    function tradeEthToTokenTest(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory result\r\n    ) public payable override {\r\n        param;\r\n        result;\r\n\r\n        LibGlobal.buyWeth(amount);\r\n        address pairExchange = calcPairExchange(token);\r\n        WETH_TOKEN.transfer(pairExchange, amount);\r\n\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n        uint256 amountOut =\r\n            uniswapV2EthToTokenReturn2(\r\n                IUniswapV2Pair(pairExchange),\r\n                amount,\r\n                tokenIsToken0\r\n            );\r\n        uint256 amount0Out = tokenIsToken0 ? amountOut : 0;\r\n        uint256 amount1Out = tokenIsToken0 ? 0 : amountOut;\r\n        IUniswapV2Pair(pairExchange).swap(\r\n            amount0Out,\r\n            amount1Out,\r\n            address(this),\r\n            new bytes(0)\r\n        );\r\n    }\r\n\r\n    function tradeTokenToEthTest(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory result\r\n    ) public payable override {\r\n        param;\r\n        result;\r\n        address pairExchange = calcPairExchange(token);\r\n        token.safeTransfer(address(pairExchange), tokenAmount);\r\n\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n\r\n        uint256 ethAmount =\r\n            uniswapV2TokenToEthReturn(\r\n                token,\r\n                IUniswapV2Pair(pairExchange),\r\n                tokenIsToken0\r\n            );\r\n\r\n        uint256 amount0Out = tokenIsToken0 ? 0 : ethAmount;\r\n        uint256 amount1Out = tokenIsToken0 ? ethAmount : 0;\r\n        IUniswapV2Pair(pairExchange).swap(\r\n            amount0Out,\r\n            amount1Out,\r\n            address(this),\r\n            new bytes(0)\r\n        );\r\n\r\n        LibGlobal.sellWeth(ethAmount);\r\n    }\r\n\r\n    function uniswapV2TokenToEthReturn(\r\n        IERC20 token,\r\n        IUniswapV2Pair pairExchange,\r\n        bool tokenIsToken0\r\n    ) private view returns (uint256 ethAmount) {\r\n        // WARNING!!! require transfer token to pairExchange first, use to calc before real trade\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n\r\n        uint256 reserveIn = tokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = tokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        uint256 tokenAmount =\r\n            token.balanceOf(address(pairExchange)).sub(reserveIn);\r\n\r\n        ethAmount = UniswapV2Library.getAmountOut(\r\n            tokenAmount,\r\n            reserveIn,\r\n            reserveOut\r\n        );\r\n    }\r\n\r\n    function ethToTokenReturnFast(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable override returns (uint256 tokenAmount) {\r\n        tokenAmount = uniswapV2EthToTokenReturn2(\r\n            param.pairExchangeU,\r\n            amount,\r\n            token < WETH_TOKEN\r\n        );\r\n    }\r\n\r\n    function uniswapV2EthToTokenReturnQuick(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        IUniswapV2Pair pairExchange\r\n    ) public view returns (uint256 tokenAmount) {\r\n        tokenAmount = uniswapV2EthToTokenReturn(\r\n            pairExchange,\r\n            amount,\r\n            token < WETH_TOKEN\r\n        );\r\n    }\r\n\r\n    function uniswapV2EthToTokenReturn2(\r\n        IUniswapV2Pair pairExchange,\r\n        uint256 amount,\r\n        bool tokenIsToken0\r\n    ) private view returns (uint256 tokenAmount) {\r\n        tokenAmount = getReturn(pairExchange, amount, !tokenIsToken0);\r\n    }\r\n\r\n    function uniswapV2EthToTokenReturn(\r\n        IUniswapV2Pair pairExchange,\r\n        uint256 amount,\r\n        bool tokenIsToken0\r\n    ) private view returns (uint256) {\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n        if (reserve0 == 0 || reserve1 == 0) return 0;\r\n\r\n        uint256 reserveIn = tokenIsToken0 ? reserve1 : reserve0;\r\n        uint256 reserveOut = tokenIsToken0 ? reserve0 : reserve1;\r\n\r\n        return UniswapV2Library.getAmountOut(amount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function uniswapV2EthToTokenReturn(\r\n        IERC20 token,\r\n        IUniswapV2Pair pairExchange,\r\n        uint256 amount\r\n    ) private view returns (uint256) {\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n        return uniswapV2EthToTokenReturn(pairExchange, amount, tokenIsToken0);\r\n    }\r\n\r\n    function ethToTokenReturnTest(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ProfitParameterExtra memory param\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns (\r\n            uint256 tokenAmount,\r\n            LibGlobal.ProfitResultExtra memory profitResultExtra\r\n        )\r\n    {\r\n        param;\r\n        IUniswapV2Pair pairExchange = getPairExchange(token);\r\n        if (pairExchange == IUniswapV2Pair(0x0)) return (0, profitResultExtra);\r\n        profitResultExtra.pairExchangeU = pairExchange;\r\n\r\n        tokenAmount = uniswapV2EthToTokenReturn(token, pairExchange, amount);\r\n    }\r\n\r\n    function tokenToEthReturnFast(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) public payable override returns (uint256 ethAmount) {\r\n        token;\r\n        if (tokenAmount == 0) return 0;\r\n        ethAmount = getReturn(\r\n            param.pairExchangeU,\r\n            tokenAmount,\r\n            token < WETH_TOKEN\r\n        );\r\n    }\r\n\r\n    function uniswapV2TokenToEthReturn(\r\n        IUniswapV2Pair pairExchange,\r\n        uint256 tokenAmount,\r\n        bool tokenIsToken0\r\n    ) private view returns (uint256) {\r\n        if (tokenAmount == 0) return 0;\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n        if (reserve0 == 0 || reserve1 == 0) return 0;\r\n\r\n        uint256 reserveIn = tokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = tokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        return\r\n            UniswapV2Library.getAmountOut(tokenAmount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function uniswapV2TokenToEthReturnQuick(\r\n        IERC20 token,\r\n        IUniswapV2Pair pairExchange,\r\n        uint256 tokenAmount\r\n    ) public view returns (uint256 ethAmount) {\r\n        ethAmount = uniswapV2TokenToEthReturn(\r\n            pairExchange,\r\n            tokenAmount,\r\n            token < WETH_TOKEN\r\n        );\r\n    }\r\n\r\n    function uniswapV2TokenToEthReturn(\r\n        IERC20 token,\r\n        IUniswapV2Pair pairExchange,\r\n        uint256 tokenAmount\r\n    ) private view returns (uint256) {\r\n        bool tokenIsToken0 = token < WETH_TOKEN;\r\n        return\r\n            uniswapV2TokenToEthReturn(pairExchange, tokenAmount, tokenIsToken0);\r\n    }\r\n\r\n    function tokenToEthReturnTest(\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory profitResultExtra\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns (uint256 ethAmount, LibGlobal.ProfitResultExtra memory)\r\n    {\r\n        param;\r\n        IUniswapV2Pair pairExchange = getPairExchange(token);\r\n        if (pairExchange == IUniswapV2Pair(0x0)) return (0, profitResultExtra);\r\n        profitResultExtra.pairExchangeU = pairExchange;\r\n\r\n        ethAmount = uniswapV2TokenToEthReturn(token, pairExchange, tokenAmount);\r\n\r\n        return (ethAmount, profitResultExtra);\r\n    }\r\n\r\n    function tradeTokenToTokenFast(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount0,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        bytes memory data\r\n    ) public payable override returns (uint256) {\r\n        arbParam;\r\n        tokenAmount0;\r\n\r\n        IUniswapV2Pair pairExchange = abi.decode(data, (IUniswapV2Pair));\r\n        bool fromTokenIsToken0 = fromToken < toToken;\r\n\r\n        // fromToken had been transfered to pairExchange\r\n        uint256 amountOut =\r\n            uniswapV2TokenToTokenReturnTransferAdvance(\r\n                fromToken,\r\n                pairExchange,\r\n                fromTokenIsToken0\r\n            );\r\n\r\n        uint256 amount0Out = fromTokenIsToken0 ? 0 : amountOut;\r\n        uint256 amount1Out = fromTokenIsToken0 ? amountOut : 0;\r\n        pairExchange.swap(\r\n            amount0Out,\r\n            amount1Out,\r\n            arbParam.receipt,\r\n            new bytes(0)\r\n        );\r\n\r\n        return amountOut;\r\n    }\r\n\r\n    function tradeTokenToTokenTest(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory profitResultExtraMid\r\n    ) public payable override {\r\n        param;\r\n        profitResultExtraMid;\r\n\r\n        IUniswapV2Pair pairExchange = calcPairExchange(fromToken, toToken);\r\n        fromToken.safeTransfer(address(pairExchange), tokenAmount);\r\n\r\n        bool fromTokenIsToken0 = fromToken < toToken;\r\n\r\n        uint256 amountOut =\r\n            uniswapV2TokenToTokenReturnTransferAdvance(\r\n                fromToken,\r\n                pairExchange,\r\n                fromTokenIsToken0\r\n            );\r\n\r\n        uint256 amount0Out = fromTokenIsToken0 ? 0 : amountOut;\r\n        uint256 amount1Out = fromTokenIsToken0 ? amountOut : 0;\r\n        pairExchange.swap(amount0Out, amount1Out, address(this), new bytes(0));\r\n    }\r\n\r\n    function tokenToTokenReturnFast(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        bytes memory data\r\n    ) public payable override returns (uint256) {\r\n        arbParam;\r\n\r\n        IUniswapV2Pair pairExchange = abi.decode(data, (IUniswapV2Pair));\r\n        return\r\n            uniswapV2TokenToTokenReturn(\r\n                pairExchange,\r\n                tokenAmount,\r\n                fromToken < toToken\r\n            );\r\n    }\r\n\r\n    function tokenToTokenReturnTest(\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param\r\n    )\r\n        public\r\n        payable\r\n        override\r\n        returns (\r\n            uint256,\r\n            LibGlobal.ProfitResultExtra memory profitResultExtraMid\r\n        )\r\n    {\r\n        param;\r\n\r\n        IUniswapV2Pair pairExchange =\r\n            IUniswapV2Pair(\r\n                UNISWAP_V2_FACTORY.getPair(address(fromToken), address(toToken))\r\n            );\r\n        if (pairExchange == IUniswapV2Pair(0x0))\r\n            return (0, profitResultExtraMid);\r\n        profitResultExtraMid.pairExchangeU = pairExchange;\r\n\r\n        return (\r\n            uniswapV2TokenToTokenReturn(\r\n                pairExchange,\r\n                tokenAmount,\r\n                fromToken < toToken\r\n            ),\r\n            profitResultExtraMid\r\n        );\r\n    }\r\n\r\n    function uniswapV2TokenToTokenReturnTransferAdvance(\r\n        IERC20 fromToken,\r\n        IUniswapV2Pair pairExchange,\r\n        bool fromTokenIsToken0\r\n    ) private view returns (uint256) {\r\n        // WARNING!!! require transfer token to pairExchange first, use to calc before trade\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n\r\n        uint256 reserveIn = fromTokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = fromTokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        uint256 tokenAmount =\r\n            fromToken.balanceOf(address(pairExchange)).sub(reserveIn);\r\n\r\n        return\r\n            UniswapV2Library.getAmountOut(tokenAmount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function uniswapV2TokenToTokenReturn(\r\n        IUniswapV2Pair pairExchange,\r\n        uint256 tokenAmount,\r\n        bool fromTokenIsToken0\r\n    ) private view returns (uint256) {\r\n        if (tokenAmount == 0) return 0;\r\n\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n        if (reserve0 == 0 || reserve1 == 0) return 0;\r\n\r\n        uint256 reserveIn = fromTokenIsToken0 ? reserve0 : reserve1;\r\n        uint256 reserveOut = fromTokenIsToken0 ? reserve1 : reserve0;\r\n\r\n        return\r\n            UniswapV2Library.getAmountOut(tokenAmount, reserveIn, reserveOut);\r\n    }\r\n\r\n    function getPairExchange(IERC20 token)\r\n        private\r\n        view\r\n        returns (IUniswapV2Pair pairExchange)\r\n    {\r\n        pairExchange = IUniswapV2Pair(\r\n            UNISWAP_V2_FACTORY.getPair(address(WETH_TOKEN), address(token))\r\n        );\r\n    }\r\n\r\n    function calcPairExchange(IERC20 token)\r\n        private\r\n        pure\r\n        returns (address pairExchange)\r\n    {\r\n        pairExchange = UniswapV2Library.pairFor(\r\n            address(UNISWAP_V2_FACTORY),\r\n            address(token),\r\n            address(WETH_TOKEN)\r\n        );\r\n    }\r\n\r\n    function calcPairExchange(IERC20 token1, IERC20 token2)\r\n        private\r\n        pure\r\n        returns (IUniswapV2Pair pairExchange)\r\n    {\r\n        pairExchange = IUniswapV2Pair(\r\n            UniswapV2Library.pairFor(\r\n                address(UNISWAP_V2_FACTORY),\r\n                address(token1),\r\n                address(token2)\r\n            )\r\n        );\r\n    }\r\n\r\n    function getReserves(IERC20 token)\r\n        private\r\n        view\r\n        returns (uint256 tokenReserve, uint256 wethReserve)\r\n    {\r\n        (tokenReserve, wethReserve) = getReserves(token, WETH_TOKEN);\r\n    }\r\n\r\n    function getReserves(IERC20 tokenA, IERC20 tokenB)\r\n        private\r\n        view\r\n        returns (uint256 reserveA, uint256 reserveB)\r\n    {\r\n        (reserveA, reserveB) = UniswapV2Library.getReserves(\r\n            address(UNISWAP_V2_FACTORY),\r\n            address(tokenA),\r\n            address(tokenB)\r\n        );\r\n    }\r\n\r\n    function getReturn(\r\n        IUniswapV2Pair pairExchange,\r\n        uint256 inputAmount,\r\n        bool isToken0ToToken1\r\n    ) private view returns (uint256) {\r\n        (uint256 reserve0, uint256 reserve1, ) = pairExchange.getReserves();\r\n        uint256 inputReserve = isToken0ToToken1 ? reserve0 : reserve1;\r\n        uint256 outputReserve = isToken0ToToken1 ? reserve1 : reserve0;\r\n        return getAmountOut(inputAmount, inputReserve, outputReserve);\r\n    }\r\n\r\n    function getAmountOut(\r\n        uint256 inputAmount,\r\n        uint256 inputReserve,\r\n        uint256 outputReserve\r\n    ) private pure returns (uint256) {\r\n        uint256 inputAmountWithFee = inputAmount * 997;\r\n        uint256 numerator = inputAmountWithFee * outputReserve;\r\n        uint256 denominator = (inputReserve * 1000) + inputAmountWithFee;\r\n\r\n        return numerator / denominator;\r\n    }\r\n}\r\n"
    },
    "browser/IArb3Storage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IArb3Storage {\r\n    function getStateX(bytes32 tId) external returns (uint256);\r\n\r\n    function setStateX(bytes32 tId, uint256 state) external;\r\n}\r\n"
    },
    "browser/IBPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IBPool {\r\n    function getCurrentTokens() external view returns (address[] memory tokens);\r\n\r\n    function isFinalized() external view returns (bool);\r\n\r\n    function isPublicSwap() external view returns (bool);\r\n\r\n    function getBalance(IERC20 token) external view returns (uint256);\r\n\r\n    function getDenormalizedWeight(IERC20 token)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function getSwapFee() external view returns (uint256);\r\n\r\n    function swapExactAmountIn(\r\n        IERC20 tokenIn,\r\n        uint256 tokenAmountIn,\r\n        IERC20 tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\r\n}\r\n"
    },
    "browser/IBancorNetwork.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IBancorNetwork {\r\n    function convert2(\r\n        address[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external payable returns (uint256);\r\n\r\n    function convertFor2(\r\n        address[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _for,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external payable returns (uint256);\r\n\r\n    function claimAndConvert2(\r\n        address[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external returns (uint256);\r\n\r\n    function getReturnByPath(address[] calldata _path, uint256 _amount)\r\n        external\r\n        view\r\n        returns (uint256, uint256);\r\n\r\n    function rateByPath(address[] calldata _path, uint256 _amount)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function convertByPath(\r\n        address[] calldata _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _beneficiary,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external payable returns (uint256);\r\n}\r\n"
    },
    "browser/IBancorRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IBancorRegistry {\r\n    function addressOf(bytes32 _contractName) external view returns (address);\r\n}\r\n"
    },
    "browser/IChiToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IChiToken {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function mint(uint256 value) external;\r\n\r\n    // Warning!!! will revert if token.balanceOf(msg.sender) < value\r\n    function free(uint256 value) external returns (uint256);\r\n\r\n    // Warning!!! will revert if token.balanceOf(msg.sender) < value\r\n    function freeFrom(address from, uint256 value) external returns (uint256);\r\n}\r\n"
    },
    "browser/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface ICurvePool {\r\n    function coins(int128 i) external view returns (address);\r\n\r\n    function underlying_coins(int128 i) external view returns (address);\r\n\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function get_dy_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external;\r\n\r\n    function exchange_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external;\r\n}\r\n"
    },
    "browser/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n"
    },
    "browser/IGasToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IGasToken {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    // Mints `value` new sub-tokens (e.g. cents, pennies, ...) by creating `value`\r\n    // new child contracts. The minted tokens are owned by the caller of this\r\n    // function.\r\n    function mint(uint256 value) external;\r\n\r\n    // Frees `value` sub-tokens (e.g. cents, pennies, ...) belonging to the\r\n    // caller of this function by destroying `value` child contracts, which\r\n    // will trigger a partial gas refund.\r\n    // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas\r\n    // when calling this function. For details, see the comment above `destroyChildren`.\r\n    function free(uint256 value) external returns (bool success);\r\n\r\n    // Frees `value` sub-tokens owned by address `from`. Requires that `msg.sender`\r\n    // has been approved by `from`.\r\n    // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas\r\n    // when calling this function. For details, see the comment above `destroyChildren`.\r\n    function freeFrom(address from, uint256 value)\r\n        external\r\n        returns (bool success);\r\n}\r\n"
    },
    "browser/ISushiswapFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface ISushiswapFactory {\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n}\r\n"
    },
    "browser/ISushiswapPair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface ISushiswapPair {\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n"
    },
    "browser/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    /*\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint256\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n    */\r\n\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n}\r\n"
    },
    "browser/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    /*\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n    */\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    /*\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n    */\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n"
    },
    "browser/IWeth.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IWETH9 {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n"
    },
    "browser/LibArb.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IArb3Storage.sol\";\r\nimport \"./LibDexBancor.sol\";\r\nimport \"./LibGlobal.sol\";\r\nimport \"./LibRealProfit.sol\";\r\nimport \"./LibRealTrade.sol\";\r\n\r\nlibrary LibArb {\r\n    address constant OWNER = 0xb3E20b057CBF2c0D9d099baC6772aF0c948C6ADe;\r\n\r\n    uint256 constant MASK_CHECK_STATE_OP = 0xF000000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant CHECK_STATE_OP_WRITE_STATE_UNTIL_NO_PROFIT = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant CHECK_STATE_OP_WRITE_STATE_WHENEVER = 0x1000000000000000000000000000000000000000000000000000000000000000;\r\n    uint256 constant CHECK_STATE_OP_NO_STATE = 0x2000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    IArb3Storage constant MY_STORAGE = IArb3Storage(\r\n        0x2D8E7BDCBE0311e27628a9daA6359DEd42FE11Aa\r\n    );\r\n\r\n    function getTId() private pure returns (bytes32) {\r\n        return keccak256(msg.data);\r\n    }\r\n\r\n    /**\r\n    for multi sender tx, check target balance and prevent repeatedly check profit\r\n    */\r\n    function checkState(uint256 opBalanceAndtargetXor)\r\n        internal\r\n        returns (bool ready, bytes32 tId)\r\n    {\r\n        if (\r\n            (opBalanceAndtargetXor & MASK_CHECK_STATE_OP) ==\r\n            CHECK_STATE_OP_NO_STATE\r\n        ) return (true, tId);\r\n\r\n        tId = getTId();\r\n        uint256 state = readState(tId);\r\n        uint256 balanceAndtarget = (opBalanceAndtargetXor ^\r\n            uint256(uint160(OWNER))) & (~MASK_CHECK_STATE_OP);\r\n\r\n        // tId collision, state is 1 hour (250 block) ago\r\n        if (state == 0 || state < block.number - 250) {\r\n            // no state information or target not mined\r\n            ready = testTarget(balanceAndtarget);\r\n            return (ready, tId);\r\n        }\r\n\r\n        return (false, tId);\r\n    }\r\n\r\n    function arbWithStateCheck(\r\n        bytes32 tId,\r\n        uint256 opBalanceAndtargetXor,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        uint256 func,\r\n        LibGlobal.ArbParameterExtra memory param,\r\n        Dex[2] memory dexPair\r\n    ) internal returns (address) {\r\n        address r = arb(token, amount, func, param, dexPair);\r\n        uint256 op = (opBalanceAndtargetXor & MASK_CHECK_STATE_OP);\r\n        if (op == CHECK_STATE_OP_NO_STATE) return r;\r\n\r\n        if (r == OWNER || op == CHECK_STATE_OP_WRITE_STATE_WHENEVER) {\r\n            updateState(tId);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function arb(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        uint256 func,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        Dex[2] memory dexPair\r\n    ) private returns (address) {\r\n        uint256 gasStart = gasleft();\r\n\r\n        (, uint256 ethAmount) = LibRealProfit.realProfit(\r\n            token,\r\n            amount,\r\n            func,\r\n            arbParam,\r\n            dexPair\r\n        );\r\n\r\n        if (ethAmount <= amount) return OWNER;\r\n\r\n        uint256 b0 = address(this).balance;\r\n\r\n        LibRealTrade.realTrade(token, amount, func, arbParam, dexPair);\r\n\r\n        require(address(this).balance > b0, \"exception\");\r\n\r\n        if (arbParam.refund) LibGlobal.refundChi(gasStart);\r\n\r\n        return msg.sender;\r\n    }\r\n\r\n    function testTarget(uint256 balanceAndtarget) private view returns (bool) {\r\n        address target = address(uint160(balanceAndtarget));\r\n        uint256 balance = (balanceAndtarget) >> 160;\r\n\r\n        return (target.balance != balance);\r\n    }\r\n\r\n    function readState(bytes32 tId) private returns (uint256) {\r\n        return MY_STORAGE.getStateX(tId);\r\n    }\r\n\r\n    function writeState(bytes32 tId, uint256 state) private {\r\n        MY_STORAGE.setStateX(tId, state);\r\n    }\r\n\r\n    function updateState(bytes32 tId) internal {\r\n        writeState(tId, block.number);\r\n    }\r\n}\r\n"
    },
    "browser/LibDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./LibGlobal.sol\";\r\nimport \"./Dex.sol\";\r\n\r\nlibrary LibDelegate {\r\n    function delegateEthToTokenReturnTest(\r\n        Dex dex,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ProfitParameterExtra memory param\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 tokenAmount,\r\n            LibGlobal.ProfitResultExtra memory profitResultExtra\r\n        )\r\n    {\r\n        (bool success, bytes memory result) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.ethToTokenReturnTest.selector,\r\n                token,\r\n                amount,\r\n                param\r\n            )\r\n        );\r\n        require(success);\r\n\r\n        (tokenAmount, profitResultExtra) = abi.decode(\r\n            result,\r\n            (uint256, LibGlobal.ProfitResultExtra)\r\n        );\r\n    }\r\n\r\n    function delegateTokenToEthReturnTest(\r\n        Dex dex,\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory profitResultExtra\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 ethAmount,\r\n            LibGlobal.ProfitResultExtra memory ProfitResultExtra2\r\n        )\r\n    {\r\n        (bool success, bytes memory result) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tokenToEthReturnTest.selector,\r\n                token,\r\n                tokenAmount,\r\n                param,\r\n                profitResultExtra\r\n            )\r\n        );\r\n        require(success);\r\n\r\n        (ethAmount, ProfitResultExtra2) = abi.decode(\r\n            result,\r\n            (uint256, LibGlobal.ProfitResultExtra)\r\n        );\r\n    }\r\n\r\n    function delegateTradeEthToTokenTest(\r\n        Dex dex,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory result\r\n    ) internal {\r\n        (bool success, ) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tradeEthToTokenTest.selector,\r\n                token,\r\n                amount,\r\n                param,\r\n                result\r\n            )\r\n        );\r\n        require(success);\r\n    }\r\n\r\n    function delegateTradeTokenToEthTest(\r\n        Dex dex,\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory result\r\n    ) internal {\r\n        (bool success, ) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tradeTokenToEthTest.selector,\r\n                token,\r\n                tokenAmount,\r\n                param,\r\n                result\r\n            )\r\n        );\r\n        require(success);\r\n    }\r\n\r\n    function delegateEthToTokenReturnFast(\r\n        Dex dex,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) internal returns (uint256 tokenAmount) {\r\n        (bool success, bytes memory result) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.ethToTokenReturnFast.selector,\r\n                token,\r\n                amount,\r\n                param\r\n            )\r\n        );\r\n        require(success);\r\n\r\n        (tokenAmount) = abi.decode(result, (uint256));\r\n    }\r\n\r\n    function delegateTokenToEthReturnFast(\r\n        Dex dex,\r\n        IERC20 token,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) internal returns (uint256 ethAmount) {\r\n        (bool success, bytes memory result) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tokenToEthReturnFast.selector,\r\n                token,\r\n                tokenAmount,\r\n                param\r\n            )\r\n        );\r\n        require(success);\r\n\r\n        (ethAmount) = abi.decode(result, (uint256));\r\n    }\r\n\r\n    function delegateTradeEthToTokenFast(\r\n        Dex dex,\r\n        IERC20 token,\r\n        uint256 amount,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) internal returns (uint256 tokenAmount) {\r\n        (bool success, bytes memory result) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tradeEthToTokenFast.selector,\r\n                token,\r\n                amount,\r\n                param\r\n            )\r\n        );\r\n        require(success);\r\n\r\n        (tokenAmount) = abi.decode(result, (uint256));\r\n    }\r\n\r\n    function delegateTradeTokenToEthFast(\r\n        Dex dex,\r\n        IERC20 token,\r\n        uint256 tokenAmount0,\r\n        LibGlobal.ArbParameterExtra memory param\r\n    ) internal {\r\n        (bool success, ) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tradeTokenToEthFast.selector,\r\n                token,\r\n                tokenAmount0,\r\n                param\r\n            )\r\n        );\r\n        require(success);\r\n    }\r\n\r\n    function delegateTokenToTokenReturnTest(\r\n        Dex dex,\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 tokenAmount2,\r\n            LibGlobal.ProfitResultExtra memory profitResultExtraMid\r\n        )\r\n    {\r\n        (bool success, bytes memory result) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tokenToTokenReturnTest.selector,\r\n                fromToken,\r\n                toToken,\r\n                tokenAmount,\r\n                param\r\n            )\r\n        );\r\n        require(success);\r\n\r\n        (tokenAmount2, profitResultExtraMid) = abi.decode(\r\n            result,\r\n            (uint256, LibGlobal.ProfitResultExtra)\r\n        );\r\n    }\r\n\r\n    function delegateTradeTokenToTokenTest(\r\n        Dex dex,\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ProfitParameterExtra memory param,\r\n        LibGlobal.ProfitResultExtra memory profitResultExtraMid\r\n    ) internal {\r\n        (bool success, ) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tradeTokenToTokenTest.selector,\r\n                fromToken,\r\n                toToken,\r\n                tokenAmount,\r\n                param,\r\n                profitResultExtraMid\r\n            )\r\n        );\r\n        require(success);\r\n    }\r\n\r\n    function delegateTokenToTokenReturnFast(\r\n        Dex dex,\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        bytes memory data\r\n    ) internal returns (uint256 tokenAmountOut) {\r\n        (bool success, bytes memory result) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tokenToTokenReturnFast.selector,\r\n                fromToken,\r\n                toToken,\r\n                tokenAmount,\r\n                arbParam,\r\n                data\r\n            )\r\n        );\r\n        require(success);\r\n\r\n        (tokenAmountOut) = abi.decode(result, (uint256));\r\n    }\r\n\r\n    function delegateTradeTokenToTokenFast(\r\n        Dex dex,\r\n        IERC20 fromToken,\r\n        IERC20 toToken,\r\n        uint256 tokenAmount0,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        bytes memory data\r\n    ) internal returns (uint256 tokenAmountOut) {\r\n        (bool success, bytes memory result) = address(dex).delegatecall(\r\n            abi.encodeWithSelector(\r\n                dex.tradeTokenToTokenFast.selector,\r\n                fromToken,\r\n                toToken,\r\n                tokenAmount0,\r\n                arbParam,\r\n                data\r\n            )\r\n        );\r\n        require(success);\r\n\r\n        (tokenAmountOut) = abi.decode(result, (uint256));\r\n    }\r\n}\r\n"
    },
    "browser/LibDexBancor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./IBancorNetwork.sol\";\r\nimport \"./IBancorRegistry.sol\";\r\n\r\nlibrary LibDexBancor {\r\n    function getReversePath(address[] memory path)\r\n        internal\r\n        pure\r\n        returns (address[] memory)\r\n    {\r\n        uint256 arraySize = path.length;\r\n        address[] memory pathReverse = new address[](arraySize);\r\n        if (arraySize == 0) return pathReverse;\r\n\r\n        for (uint256 i = 0; i <= arraySize / 2; i++) {\r\n            pathReverse[i] = path[arraySize - 1 - i];\r\n            pathReverse[arraySize - 1 - i] = path[i];\r\n        }\r\n\r\n        return pathReverse;\r\n    }\r\n}\r\n"
    },
    "browser/LibGlobal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./NIERC20.sol\";\r\nimport \"./IWeth.sol\";\r\nimport \"./UniswapExchangeInterface.sol\";\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./IBancorNetwork.sol\";\r\nimport \"./IBPool.sol\";\r\nimport \"./ICurvePool.sol\";\r\nimport \"./ISushiswapPair.sol\";\r\nimport \"./IGasToken.sol\";\r\nimport \"./IChiToken.sol\";\r\n\r\nlibrary LibGlobal {\r\n    // for seek profit result\r\n    struct ProfitResultExtra {\r\n        UniswapExchangeInterface exchange;\r\n        IUniswapV2Pair pairExchangeU;\r\n        address reserve;\r\n        bytes kyberHint;\r\n        IBancorNetwork bancorNetwork;\r\n        ISushiswapPair pairExchangeS;\r\n        // for bpt\r\n        uint256 wethWeight;\r\n        uint256 tokenWeight;\r\n        uint256 swapFee;\r\n        // for bpt t2t, todo optimize with above\r\n        uint256 tokenWeightIn;\r\n        uint256 tokenWeightOut;\r\n    }\r\n\r\n    // only for seek profit input from tester contract\r\n    struct ProfitParameterExtra {\r\n        // for bancor\r\n        address[] path;\r\n        address[] reversePath;\r\n        // for bpt\r\n        IBPool pool;\r\n        IBPool reversePool;\r\n        // for t2t\r\n        uint256 testHint;\r\n        address[] token1Path;\r\n        address[] token2Path;\r\n        IBPool token1Pool;\r\n        IBPool token2Pool;\r\n        IBPool t2tPool;\r\n        // for curve t2t\r\n        ICurvePool curvePool;\r\n    }\r\n\r\n    // for real trade\r\n    struct ArbParameterExtra {\r\n        address receipt;\r\n        bool refund;\r\n        // for non t2t\r\n        address reserve;\r\n        bool isReserveContract;\r\n        uint256 tokenDecimal;\r\n        bytes kyberHint;\r\n        UniswapExchangeInterface exchange;\r\n        IUniswapV2Pair pairExchangeU;\r\n        // for Bancor\r\n        IBancorNetwork bancorNetwork;\r\n        address[] thePath;\r\n        // for BPool\r\n        IBPool thePool;\r\n        uint256 poolWeightParam;\r\n        // for sushiswap\r\n        ISushiswapPair pairExchangeS;\r\n        // for t2t\r\n        uint256 hint;\r\n    }\r\n\r\n    /**\r\n    only use in test\r\n    */\r\n    struct TestInfo {\r\n        uint256 startAmount;\r\n        uint256 stepRatio; // ratio = stepRatio / 100\r\n        uint256 maxAmount;\r\n        uint256 func;\r\n        uint256 inAmount;\r\n        uint256 outAmount;\r\n        ProfitResultExtra profitResultExtra;\r\n        // for t2t\r\n        uint256 hint;\r\n        ProfitResultExtra profitResultExtraIn;\r\n        ProfitResultExtra profitResultExtraMid;\r\n        ProfitResultExtra profitResultExtraOut;\r\n    }\r\n\r\n    IERC20 constant WETH_TOKEN =\r\n        IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    IGasToken constant GST2 =\r\n        IGasToken(0x0000000000b3F879cb30FE243b4Dfee438691c04);\r\n    IChiToken constant CHI =\r\n        IChiToken(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    uint256 constant ALLOWANCE = ~uint256(0);\r\n\r\n    function tokenBalance(IERC20 token, address owner)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return token.balanceOf(owner);\r\n    }\r\n\r\n    function buyWeth(uint256 value) internal {\r\n        IWETH9(address(WETH_TOKEN)).deposit{value: value}();\r\n    }\r\n\r\n    function sellWeth(uint256 value) internal {\r\n        IWETH9(address(WETH_TOKEN)).withdraw(value);\r\n    }\r\n\r\n    function ensureAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 a = token.allowance(address(this), spender);\r\n\r\n        if (a >= value) return;\r\n\r\n        if (a != 0) {\r\n            NIERC20(address(token)).approve(spender, 0);\r\n        }\r\n\r\n        NIERC20(address(token)).approve(spender, ALLOWANCE);\r\n    }\r\n\r\n    function refund(uint256 gasStart) internal {\r\n        uint256 gasLeft = gasleft();\r\n        uint256 gasSpent = 21000 + gasStart - gasLeft + 16 * msg.data.length;\r\n        uint256 value = (gasSpent + 14154) / 41130;\r\n\r\n        if (value > 0) GST2.free(value);\r\n    }\r\n\r\n    function refundChi(uint256 gasStart) internal {\r\n        uint256 gasLeft = gasleft();\r\n        uint256 gasSpent = 21000 + gasStart - gasLeft + 16 * msg.data.length;\r\n        uint256 value = (gasSpent + 14154) / 41947;\r\n\r\n        if (value > 0) {\r\n            // must first check balanceOf chi token\r\n            uint256 b = CHI.balanceOf(address(this));\r\n            if (b >= value) CHI.free(value);\r\n        }\r\n    }\r\n}\r\n"
    },
    "browser/LibRealProfit.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./LibGlobal.sol\";\r\nimport \"./Dex.sol\";\r\nimport \"./LibDelegate.sol\";\r\n\r\nlibrary LibRealProfit {\r\n    using LibDelegate for Dex;\r\n\r\n    function realProfit(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        uint256 func,\r\n        LibGlobal.ArbParameterExtra memory arbParam,\r\n        Dex[2] memory dexPair\r\n    ) internal returns (uint256 tokenAmount, uint256 ethAmount) {\r\n        uint256 index = func == 1 ? 0 : 1;\r\n        tokenAmount = dexPair[index].delegateEthToTokenReturnFast(\r\n            token,\r\n            amount,\r\n            arbParam\r\n        );\r\n\r\n        ethAmount = dexPair[1 - index].delegateTokenToEthReturnFast(\r\n            token,\r\n            tokenAmount,\r\n            arbParam\r\n        );\r\n    }\r\n}\r\n"
    },
    "browser/LibRealTrade.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./LibGlobal.sol\";\r\nimport \"./Dex.sol\";\r\nimport \"./LibDelegate.sol\";\r\n\r\nlibrary LibRealTrade {\r\n    using LibDelegate for Dex;\r\n\r\n    function realTrade(\r\n        IERC20 token,\r\n        uint256 amount,\r\n        uint256 func,\r\n        LibGlobal.ArbParameterExtra memory param,\r\n        Dex[2] memory dexPair\r\n    ) internal {\r\n        uint256 index = func == 1 ? 0 : 1;\r\n\r\n        uint256 tokenAmount = dexPair[index].delegateTradeEthToTokenFast(\r\n            token,\r\n            amount,\r\n            param\r\n        );\r\n\r\n        dexPair[1 - index].delegateTradeTokenToEthFast(\r\n            token,\r\n            tokenAmount,\r\n            param\r\n        );\r\n    }\r\n}\r\n"
    },
    "browser/LibSafeERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\nlibrary LibSafeERC20 {\r\n    bytes4 constant TRANSFER_SELECTOR = bytes4(\r\n        keccak256(bytes(\"transfer(address,uint256)\"))\r\n    );\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(TRANSFER_SELECTOR, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TRANSFER_FAILED\"\r\n        );\r\n    }\r\n}\r\n"
    },
    "browser/NIERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-20\r\n */\r\ninterface NIERC20 {\r\n    function transfer(address to, uint256 value) external;\r\n\r\n    function approve(address spender, uint256 value) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n"
    },
    "browser/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n"
    },
    "browser/SushiswapLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./ISushiswapPair.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nlibrary SushiswapLibrary {\r\n    using SafeMath for uint256;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB)\r\n        internal\r\n        pure\r\n        returns (address token0, address token1)\r\n    {\r\n        require(tokenA != tokenB, \"SushiswapLibrary: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        require(token0 != address(0), \"SushiswapLibrary: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hex\"ff\",\r\n                        factory,\r\n                        keccak256(abi.encodePacked(token0, token1)),\r\n                        hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) =\r\n            ISushiswapPair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0\r\n            ? (reserve0, reserve1)\r\n            : (reserve1, reserve0);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"SushiswapLibrary: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"SushiswapLibrary: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n}\r\n"
    },
    "browser/UniswapExchangeInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface UniswapExchangeInterface {\r\n    // Address of ERC20 token sold on this exchange\r\n    function tokenAddress() external view returns (address token);\r\n\r\n    // Address of Uniswap Factory\r\n    function factoryAddress() external view returns (address factory);\r\n\r\n    /*\r\n    // Provide Liquidity\r\n    function addLiquidity(\r\n        uint256 min_liquidity,\r\n        uint256 max_tokens,\r\n        uint256 deadline\r\n    ) external payable returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256 min_eth,\r\n        uint256 min_tokens,\r\n        uint256 deadline\r\n    ) external returns (uint256, uint256);\r\n    */\r\n\r\n    // Get Prices\r\n    function getEthToTokenInputPrice(uint256 eth_sold)\r\n        external\r\n        view\r\n        returns (uint256 tokens_bought);\r\n\r\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\r\n        external\r\n        view\r\n        returns (uint256 eth_sold);\r\n\r\n    function getTokenToEthInputPrice(uint256 tokens_sold)\r\n        external\r\n        view\r\n        returns (uint256 eth_bought);\r\n\r\n    function getTokenToEthOutputPrice(uint256 eth_bought)\r\n        external\r\n        view\r\n        returns (uint256 tokens_sold);\r\n\r\n    // Trade ETH to ERC20\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256 tokens_bought);\r\n\r\n    function ethToTokenTransferInput(\r\n        uint256 min_tokens,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external payable returns (uint256 tokens_bought);\r\n\r\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256 eth_sold);\r\n\r\n    function ethToTokenTransferOutput(\r\n        uint256 tokens_bought,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external payable returns (uint256 eth_sold);\r\n\r\n    // Trade ERC20 to ETH\r\n    function tokenToEthSwapInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_eth,\r\n        uint256 deadline\r\n    ) external returns (uint256 eth_bought);\r\n\r\n    function tokenToEthTransferInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external returns (uint256 eth_bought);\r\n\r\n    function tokenToEthSwapOutput(\r\n        uint256 eth_bought,\r\n        uint256 max_tokens,\r\n        uint256 deadline\r\n    ) external returns (uint256 tokens_sold);\r\n\r\n    function tokenToEthTransferOutput(\r\n        uint256 eth_bought,\r\n        uint256 max_tokens,\r\n        uint256 deadline,\r\n        address recipient\r\n    ) external returns (uint256 tokens_sold);\r\n\r\n    /*\r\n    // Trade ERC20 to ERC20\r\n    function tokenToTokenSwapInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens_bought,\r\n        uint256 min_eth_bought,\r\n        uint256 deadline,\r\n        address token_addr\r\n    ) external returns (uint256 tokens_bought);\r\n\r\n    function tokenToTokenTransferInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens_bought,\r\n        uint256 min_eth_bought,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address token_addr\r\n    ) external returns (uint256 tokens_bought);\r\n\r\n    function tokenToTokenSwapOutput(\r\n        uint256 tokens_bought,\r\n        uint256 max_tokens_sold,\r\n        uint256 max_eth_sold,\r\n        uint256 deadline,\r\n        address token_addr\r\n    ) external returns (uint256 tokens_sold);\r\n\r\n    function tokenToTokenTransferOutput(\r\n        uint256 tokens_bought,\r\n        uint256 max_tokens_sold,\r\n        uint256 max_eth_sold,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address token_addr\r\n    ) external returns (uint256 tokens_sold);\r\n\r\n    // Trade ERC20 to Custom Pool\r\n    function tokenToExchangeSwapInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens_bought,\r\n        uint256 min_eth_bought,\r\n        uint256 deadline,\r\n        address exchange_addr\r\n    ) external returns (uint256 tokens_bought);\r\n\r\n    function tokenToExchangeTransferInput(\r\n        uint256 tokens_sold,\r\n        uint256 min_tokens_bought,\r\n        uint256 min_eth_bought,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address exchange_addr\r\n    ) external returns (uint256 tokens_bought);\r\n\r\n    function tokenToExchangeSwapOutput(\r\n        uint256 tokens_bought,\r\n        uint256 max_tokens_sold,\r\n        uint256 max_eth_sold,\r\n        uint256 deadline,\r\n        address exchange_addr\r\n    ) external returns (uint256 tokens_sold);\r\n\r\n    function tokenToExchangeTransferOutput(\r\n        uint256 tokens_bought,\r\n        uint256 max_tokens_sold,\r\n        uint256 max_eth_sold,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address exchange_addr\r\n    ) external returns (uint256 tokens_sold);\r\n\r\n    // ERC20 comaptibility for liquidity tokens\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public decimals;\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    // Never use\r\n    function setup(address token_addr) external;\r\n    */\r\n}\r\n"
    },
    "browser/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity >=0.7.0;\r\n\r\nimport \"./IUniswapV2Pair.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint256;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB)\r\n        internal\r\n        pure\r\n        returns (address token0, address token1)\r\n    {\r\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        hex\"ff\",\r\n                        factory,\r\n                        keccak256(abi.encodePacked(token0, token1)),\r\n                        hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(\r\n        address factory,\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\r\n            pairFor(factory, tokenA, tokenB)\r\n        )\r\n            .getReserves();\r\n        (reserveA, reserveB) = tokenA == token0\r\n            ? (reserve0, reserve1)\r\n            : (reserve1, reserve0);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint256 amountInWithFee = amountIn.mul(997);\r\n        uint256 numerator = amountInWithFee.mul(reserveOut);\r\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n}\r\n"
    }
  }
}