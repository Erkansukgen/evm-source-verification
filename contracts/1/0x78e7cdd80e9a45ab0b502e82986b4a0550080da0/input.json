{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/KeyMap.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @title KeyMap\n * This contracts maps addresses to public keys.\n * Public keys for Secp256k1 are always 64 bytes.\n * To save gas, this contract stores them as an array of two bytes32 words.\n */\ncontract KeyMap {\n  mapping(address => bytes32[2]) private mappedKeys;\n\n  /**\n   * @dev mapKey\n   * Calculates the address for a public key, then saves the mapping from address to public key.\n   * @notice This overload reduces the calldata cost of submission.\n   * @param slice0 - first 32 bytes of the public key\n   * @param slice1 - second 32 bytes of the public key\n   * @return _address - calculated address\n   */\n  function mapKey(bytes32 slice0, bytes32 slice1) external returns(address _address) {\n    assembly {\n      let ptr := mload(0x40)\n      calldatacopy(ptr, 0x04, 0x40)\n      let mask := 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\n      _address := and(mask, keccak256(ptr, 0x40))\n      calldatacopy(ptr, calldatasize(), 0x40)\n    }\n    mappedKeys[_address][0] = slice0;\n    mappedKeys[_address][1] = slice1;\n  }\n\n  /**\n   * @dev mapKey\n   * Calculates the address for a public key, then saves the mapping from address to public key.\n   * @notice This overload is somewhat simpler to use, but has a higher calldata cost.\n   * @param _pubKey - ABI encoded 64 byte public key\n   * @return _address - calculated address\n   */\n  function mapKey(bytes calldata _pubKey) external returns(address _address) {\n    require(_pubKey.length == 64, \"Invalid public key.\");\n    bytes32[2] memory pubKey;\n    assembly {\n      calldatacopy(pubKey, 0x44, 0x40)\n      let mask := 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\n      _address := and(mask, keccak256(pubKey, 0x40))\n    }\n    mappedKeys[_address][0] = pubKey[0];\n    mappedKeys[_address][1] = pubKey[1];\n  }\n\n  /**\n   * @dev getKey\n   * Retrieves the public key for the given address.\n   * @notice Throws an error if the key is not registered.\n   * @param _address - address to query\n   * @return pubKey - ABI encoded public key retrieved from storage\n   */\n  function getKey(address _address) public view returns (bytes memory pubKey) {\n    pubKey = new bytes(64);\n    bytes32[2] memory key = mappedKeys[_address];\n    require(key[0] != bytes32(0), \"Key not mapped.\");\n    assembly {\n      mstore(add(pubKey, 32), mload(key))\n      mstore(add(pubKey, 64), mload(add(key, 32)))\n    }\n  }\n}"
    }
  }
}