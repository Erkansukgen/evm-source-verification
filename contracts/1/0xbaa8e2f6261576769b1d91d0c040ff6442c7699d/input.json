{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/trinity.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2020-12-15\n*/\n\n// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n\nabstract contract ERC20 {\n    function balanceOf(address account) external view virtual returns (uint256);\n    function transfer(address recipient, uint256 amount) external virtual returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual returns (bool);\n}\n\ncontract Timlock is Context {\n    using SafeMath for uint256;\n    \n    mapping (address => mapping (address => LockedInfo)) private lockedMap;\n    \n    struct LockedInfo {\n        uint256 lockedAmount;\n        uint256 lockedHours;\n        uint256 startTimestamp;\n    }\n\n    // Events\n    event Locked(address locker, address tokenAddress, uint256 lockAmount, uint256 lockHours);\n    event Unlocked(address unlocker, address tokenAddress, uint256 unlockAmount);\n    \n    constructor () public {\n    }\n    \n    function lock(address tokenAddress, uint256 lockAmount, uint256 lockHours) external returns (bool) {\n        uint256 tokenBalance = ERC20(tokenAddress).balanceOf(_msgSender());\n        uint256 prevLockedAmount = ERC20(tokenAddress).balanceOf(address(this));\n        require( lockAmount <= tokenBalance, 'Lock: the lock amount exceeds the balance' );\n        require(\n                ERC20(tokenAddress).transferFrom(_msgSender(), address(this), lockAmount),\n                'Lock failed'\n        );\n        \n        uint256 currentLockedAmount = ERC20(tokenAddress).balanceOf(address(this));\n        \n        lockedMap[_msgSender()][tokenAddress].lockedAmount = lockedMap[_msgSender()][tokenAddress].lockedAmount.add(currentLockedAmount.sub(prevLockedAmount));\n        lockedMap[_msgSender()][tokenAddress].lockedHours = lockHours;\n        lockedMap[_msgSender()][tokenAddress].startTimestamp = now;\n        \n        emit Locked(_msgSender(), tokenAddress, lockedMap[_msgSender()][tokenAddress].lockedAmount, lockHours);\n    }\n    \n    function unlock(address tokenAddress) external returns (bool) {\n        uint256 currentTimestamp = now;\n        uint256 unlockableTimestamp = lockedMap[_msgSender()][tokenAddress].startTimestamp.add(lockedMap[_msgSender()][tokenAddress].lockedHours.mul(uint256(3600)));\n        require(unlockableTimestamp <= currentTimestamp, 'Unlock: you could not unlock now.');\n        \n        require(\n            ERC20(tokenAddress).transfer(_msgSender(), lockedMap[_msgSender()][tokenAddress].lockedAmount),\n            'Unlock failed'\n        );\n        \n        lockedMap[_msgSender()][tokenAddress].lockedAmount = 0;\n        lockedMap[_msgSender()][tokenAddress].startTimestamp = 0;\n        emit Unlocked(_msgSender(), tokenAddress, lockedMap[_msgSender()][tokenAddress].lockedAmount);\n    }\n    \n    function unlockableTimestamp(address tokenAddress) external view returns (uint256) {\n        if(lockedMap[_msgSender()][tokenAddress].startTimestamp > 0)\n            return lockedMap[_msgSender()][tokenAddress].startTimestamp.add(lockedMap[_msgSender()][tokenAddress].lockedHours.mul(uint256(3600)));\n        return 0;\n    }\n    \n    function lockedAmount(address tokenAddress) external view returns (uint256) {\n        return lockedMap[_msgSender()][tokenAddress].lockedAmount;\n    }\n    \n}"}}}