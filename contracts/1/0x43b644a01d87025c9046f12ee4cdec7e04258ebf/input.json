{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/ricardian.sol":{"content":"/*\r\n██████╗ ██╗ ██████╗ █████╗ ██████╗ ██████╗ ██╗ █████╗ ███╗   ██╗\r\n██╔══██╗██║██╔════╝██╔══██╗██╔══██╗██╔══██╗██║██╔══██╗████╗  ██║\r\n██████╔╝██║██║     ███████║██████╔╝██║  ██║██║███████║██╔██╗ ██║\r\n██╔══██╗██║██║     ██╔══██║██╔══██╗██║  ██║██║██╔══██║██║╚██╗██║\r\n██║  ██║██║╚██████╗██║  ██║██║  ██║██████╔╝██║██║  ██║██║ ╚████║\r\n╚═╝  ╚═╝╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝\r\n██╗     ██╗      ██████╗                                        \r\n██║     ██║     ██╔════╝                                        \r\n██║     ██║     ██║                                             \r\n██║     ██║     ██║                                             \r\n███████╗███████╗╚██████╗                                        \r\n╚══════╝╚══════╝ ╚═════╝*/\r\n/// Presented by LexDAO LLC\r\n/// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.1;\r\n\r\ncontract RicardianLLC {\r\n    address payable public governance;\r\n    uint256 public totalSupply;\r\n    string public commonURI;\r\n    string public masterOperatingAgreement;\r\n    string constant public name = \"Ricardian LLC, Series\";\r\n    string constant public symbol = \"LLC\";\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(uint256 => address) public getApproved;\r\n    mapping(uint256 => address) public ownerOf;\r\n    mapping(uint256 => string) public tokenDetails;\r\n    mapping(uint256 => string) public tokenURI;\r\n    mapping(uint256 => Sale) public sale;\r\n    mapping(bytes4 => bool) public supportsInterface; // eip-165 \r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n    \r\n    event Approval(address indexed approver, address indexed spender, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed approver, address indexed operator, bool approved);\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event UpdateTokenDetails(uint256 indexed tokenId, string details);\r\n    event SetSale(address indexed buyer, uint256 indexed price, uint256 indexed tokenId);\r\n    event GovTribute(address indexed caller, uint256 indexed amount, string details);\r\n    event GovUpdateSettings(address indexed governance, string commonURI, string masterOperatingAgreement);\r\n    event GovUpdateTokenURI(uint256 indexed tokenId, string tokenURI);\r\n    \r\n    struct Sale {\r\n        address buyer;\r\n        uint256 price;\r\n    }\r\n    \r\n    constructor(address payable _governance, string memory _commonURI, string memory _masterOperatingAgreement) {\r\n        governance = _governance; \r\n        commonURI = _commonURI;\r\n        masterOperatingAgreement = _masterOperatingAgreement; \r\n        supportsInterface[0x80ac58cd] = true; // ERC721 \r\n        supportsInterface[0x5b5e139f] = true; // METADATA\r\n    }\r\n    \r\n    /****************\r\n    PRIVATE FUNCTIONS\r\n    ****************/\r\n    function _mint(address to) private { \r\n        totalSupply++;\r\n        uint256 tokenId = totalSupply;\r\n        balanceOf[to]++;\r\n        ownerOf[tokenId] = to;\r\n        tokenURI[tokenId] = commonURI;\r\n        emit Transfer(address(0), to, tokenId); \r\n    }\r\n    \r\n    function _transfer(address from, address to, uint256 tokenId) private {\r\n        require(from == ownerOf[tokenId], \"!owner\");\r\n        balanceOf[from]--; \r\n        balanceOf[to]++; \r\n        getApproved[tokenId] = address(0); // reset spender approval\r\n        ownerOf[tokenId] = to; \r\n        sale[tokenId].buyer = address(0); // reset buyer address\r\n        sale[tokenId].price = 0; // reset sale price\r\n        emit Transfer(from, to, tokenId); \r\n    }\r\n    \r\n    /***************\r\n    PUBLIC FUNCTIONS\r\n    ***************/\r\n    // **********\r\n    // TOKEN MINT\r\n    // **********\r\n    receive() external payable {\r\n        _mint(msg.sender); \r\n    }\r\n    \r\n    function mintLLC(address to) external payable {\r\n        _mint(to);\r\n    }\r\n    \r\n    function mintLLCbatch(address[] calldata to) external payable {\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            _mint(to[i]); \r\n        }\r\n    }\r\n    \r\n    // **********\r\n    // TOKEN MGMT\r\n    // **********\r\n    function approve(address spender, uint256 tokenId) external {\r\n        address owner = ownerOf[tokenId];\r\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"!owner/operator\");\r\n        getApproved[tokenId] = spender;\r\n        emit Approval(msg.sender, spender, tokenId); \r\n    }\r\n    \r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n    \r\n    function transfer(address to, uint256 tokenId) external returns (bool) { // erc20-formatted transfer\r\n        _transfer(msg.sender, to, tokenId);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint256 tokenId) external {\r\n        require(msg.sender == from || getApproved[tokenId] == msg.sender || isApprovedForAll[from][msg.sender], \"!owner/spender/operator\");\r\n        _transfer(from, to, tokenId);\r\n    }\r\n    \r\n    function transferFromBatch(address[] calldata from, address[] calldata to, uint256[] calldata tokenId) external {\r\n        require(from.length == to.length && to.length == tokenId.length, \"!from/to/tokenId\");\r\n        for (uint256 i = 0; i < from.length; i++) {\r\n            require(msg.sender == from[i] || getApproved[tokenId[i]] == msg.sender || isApprovedForAll[from[i]][msg.sender], \"!owner/spender/operator\");\r\n            _transfer(from[i], to[i], tokenId[i]);\r\n        }\r\n    }\r\n    \r\n    function updateTokenDetails(uint256 tokenId, string calldata details) external {\r\n        require(msg.sender == ownerOf[tokenId], \"!owner\");\r\n        tokenDetails[tokenId] = details;\r\n        emit UpdateTokenDetails(tokenId, details);\r\n    }\r\n    \r\n    // **********\r\n    // TOKEN SALE\r\n    // **********\r\n    function purchase(uint256 tokenId) external payable {\r\n        if (sale[tokenId].buyer != address(0)) { // if buyer is preset, require caller match\r\n            require(msg.sender == sale[tokenId].buyer, \"!buyer\");\r\n        }\r\n        uint256 price = sale[tokenId].price;\r\n        require(price > 0, \"!forSale\"); // token price must be non-zero to be considered 'for sale'\r\n        require(msg.value == price, \"!price\");\r\n        address owner = ownerOf[tokenId];\r\n        (bool success, ) = owner.call{value: msg.value}(\"\");\r\n        require(success, \"!ethCall\");\r\n        balanceOf[owner]--; \r\n        balanceOf[msg.sender]++; \r\n        getApproved[tokenId] = address(0); // reset spender approval\r\n        ownerOf[tokenId] = msg.sender;\r\n        sale[tokenId].buyer = address(0); // reset buyer address\r\n        sale[tokenId].price = 0; // reset sale price\r\n        emit Transfer(owner, msg.sender, tokenId); \r\n    }\r\n    \r\n    function setSale(address buyer, uint256 price, uint256 tokenId) external {\r\n        require(msg.sender == ownerOf[tokenId], \"!owner\");\r\n        sale[tokenId].buyer = buyer; // set buyer address\r\n        sale[tokenId].price = price; // set sale price\r\n        emit SetSale(buyer, price, tokenId);\r\n    }\r\n    \r\n    /*******************\r\n    GOVERNANCE FUNCTIONS\r\n    *******************/\r\n    modifier onlyGovernance {\r\n        require(msg.sender == governance, \"!governance\");\r\n        _;\r\n    }\r\n\r\n    function govTransferFrom(address from, address to, uint256 tokenId) external onlyGovernance {\r\n        _transfer(from, to, tokenId);\r\n    }\r\n    \r\n    function govTransferFromBatch(address[] calldata from, address[] calldata to, uint256[] calldata tokenId) external onlyGovernance {\r\n        require(from.length == to.length && to.length == tokenId.length, \"!from/to/tokenId\");\r\n        for (uint256 i = 0; i < from.length; i++) {\r\n            _transfer(from[i], to[i], tokenId[i]);\r\n        }\r\n    }\r\n    \r\n    function govTribute(string calldata details) external payable {\r\n        emit GovTribute(msg.sender, msg.value, details);\r\n    }\r\n    \r\n    function govUpdateSettings(address payable _governance, string calldata _commonURI, string calldata _masterOperatingAgreement) external onlyGovernance {\r\n        governance = _governance;\r\n        commonURI = _commonURI;\r\n        masterOperatingAgreement = _masterOperatingAgreement;\r\n        emit GovUpdateSettings(_governance, _commonURI, _masterOperatingAgreement);\r\n    }\r\n    \r\n    function govUpdateTokenURI(uint256 tokenId, string calldata _tokenURI) external onlyGovernance {\r\n        require(tokenId <= totalSupply, \"!exist\");\r\n        tokenURI[tokenId] = _tokenURI;\r\n        emit GovUpdateTokenURI(tokenId, _tokenURI);\r\n    }\r\n    \r\n    function govUpdateTokenURIbatch(uint256[] calldata tokenId, string[] calldata _tokenURI) external onlyGovernance {\r\n        require(tokenId.length == _tokenURI.length, \"!tokenId/_tokenURI\");\r\n        for (uint256 i = 0; i < tokenId.length; i++) {\r\n            require(tokenId[i] <= totalSupply, \"!exist\");\r\n            tokenURI[tokenId[i]] = _tokenURI[i];\r\n            emit GovUpdateTokenURI(tokenId[i], _tokenURI[i]);\r\n        }\r\n    }\r\n    \r\n    function govWithdrawETH() external onlyGovernance {\r\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\r\n        require(success, \"!ethCall\");\r\n    }\r\n}"}}}