{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/SendToMany3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Splitter {\n    // state\n    address owner;\n    address[] private partners;\n    uint256[] partnersWeight;\n\n    // Splitter constructs the contract and saves the owner of the contract\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // partnerAdd adds a new partner to the list\n    // It saves the partner address and the weight of the partner\n    function partnerAdd(address partner, uint256 weight) public onlyOwner  {\n        require(partnerExists(partner) == false);\n\n        partners.push(partner);\n        partnersWeight.push(weight);\n    }\n\n    // partnerExists returns true if a partner exists in the list, false otherwise\n    function partnerExists(address partner) public view returns (bool) {\n        for (uint256 i = 0; i < partners.length; i++) {\n            if (partner == partners[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // partnerWeight returns the weight of the partner if it is found in the list\n    function partnerWeight(address partner) public view returns (uint256) {\n        for (uint256 i = 0; i < partners.length; i++) {\n            if (partner == partners[i]) {\n                return uint256(partnersWeight[i]);\n            }\n        }\n\n        return uint256(0);\n    }\n\n    // partnersRemove removes all partners\n    function partnersRemove() public onlyOwner {\n        delete partners;\n        delete partnersWeight;\n    }\n\n    // fallback function is called when receiving funds\n    // and it splits the funds to the partners according to the allocated weights\n    //\n    // Weight is used like this\n    // == Example 1:\n    // Different partners\n    // partner A has weight 10\n    // partner B has weight 20\n    //\n    // Contract receives 3 ETH\n    // partner A receives 10 / ( 10 + 20 ) * 3 ETH = 1 ETH\n    // partner B receives 20 / ( 10 + 20 ) * 3 ETH = 2 ETH\n    //\n    // == Example 2:\n    // Equal partners\n    // partner A has weight 500\n    // partner B has weight 500\n    //\n    // Contract receives 10 ETH\n    // partner A receives 500 / ( 500 + 500 ) * 10 ETH = 5 ETH\n    // partner B receives 500 / ( 500 + 500 ) * 10 ETH = 5 ETH\n    receive () external payable {\n        uint256 sum;\n        for (uint256 i = 0; i < partners.length; i++) {\n            sum = sum + partnersWeight[i];\n        }\n        emit Sum(sum);\n\n        for (uint256 i = 0; i < partners.length; i++) {\n            address payable dst = payable(partners[i]);\n            uint256 value = msg.value * partnersWeight[i] / sum;\n            dst.transfer(value);\n\n            emit SplitValue(dst, partnersWeight[i], value);\n        }\n    }\n\n    // onlyOwne modifier checks if the originator of the transaction is the owner\n    modifier onlyOwner() {\n        bool allowed = false;\n\n        if (msg.sender == owner) {\n            allowed = true;\n        }\n        require(allowed);\n        _;\n    }\n\n    event SplitValue(address receiver, uint256 weight, uint256 amount);\n    event Sum(uint256 sum);\n    event SplitValueReceived(uint256 amount);\n}\n"
    }
  }
}