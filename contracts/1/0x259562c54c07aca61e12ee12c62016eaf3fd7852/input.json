{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Nokon.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.7.4;\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n    //    event Transfer(address indexed from, address indexed to, uint256 value);\n    //    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract Nokon is IERC20 {\n\n    string public constant name = \"Nokon\";\n    string public constant symbol = \"NKO\";\n    uint8 public constant decimals = 8;\n\n\n    event Bought(uint256 amountz);\n    event Sold(uint256 amount);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    mapping(address => bool) public authorizedAddress;\n\n    address authAddress = parseAddr('0x44F6827aa307F4d7FAeb64Be47543647B3a871dB');\n    uint256 totalSupply_ = 1200000000000000000;\n    bool presell = true;\n    uint256 ethRateFix = 10000000000;\n\n    using SafeMath for uint256;\n\n    constructor() {\n\n        balances[msg.sender] = totalSupply_;\n        balances[address(this)] = totalSupply_;\n        balances[authAddress] = totalSupply_;\n\n        authorizedAddress[msg.sender] = true;\n        authorizedAddress[authAddress] = true;\n    }\n\n    function parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i = 2; i < 2 + 2 * 20; i += 2) {\n            iaddr *= 256;\n            b1 = uint160(uint8(tmp[i]));\n            b2 = uint160(uint8(tmp[i + 1]));\n            if ((b1 >= 97) && (b1 <= 102)) {\n                b1 -= 87;\n            } else if ((b1 >= 65) && (b1 <= 70)) {\n                b1 -= 55;\n            } else if ((b1 >= 48) && (b1 <= 57)) {\n                b1 -= 48;\n            }\n            if ((b2 >= 97) && (b2 <= 102)) {\n                b2 -= 87;\n            } else if ((b2 >= 65) && (b2 <= 70)) {\n                b2 -= 55;\n            } else if ((b2 >= 48) && (b2 <= 57)) {\n                b2 -= 48;\n            }\n            iaddr += (b1 * 16 + b2);\n        }\n        return address(iaddr);\n    }\n\n    function toAsciiString(address x) internal view returns (string memory) {\n        bytes memory s = new bytes(40);\n        for (uint i = 0; i < 20; i++) {\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n            bytes1 hi = bytes1(uint8(b) / 16);\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n            s[2 * i] = char(hi);\n            s[2 * i + 1] = char(lo);\n        }\n        return string(s);\n    }\n\n    function char(bytes1 b) internal view returns (bytes1 c) {\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n        else return bytes1(uint8(b) + 0x57);\n    }\n\n    function recover(bytes32 hash, bytes memory signature)\n    internal\n    pure\n    returns (address)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (signature.length != 65) {\n            return (address(0));\n        }\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            // solium-disable-next-line arg-overflow\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n\n    function calculateRate() private returns (uint256){\n        uint256 balance = balanceOf(address(this));\n        if (balance > 100000000000000000)\n            return 666666;\n        if (balance > 50000000000000000)\n            return 333333;\n        return 250000;\n    }\n\n    function totalSupply() public override view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function getRate() public returns (uint256) {\n        return calculateRate();\n    }\n\n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override returns (bool)\n    {\n        require(numTokens <= balances[msg.sender], \"transfer error\");\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {\n        require(numTokens <= balances[owner]);\n        require(numTokens <= allowed[owner][msg.sender]);\n\n        balances[owner] = balances[owner].sub(numTokens);\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n        balances[buyer] = balances[buyer].add(numTokens);\n        emit Transfer(owner, buyer, numTokens);\n        return true;\n    }\n\n    receive() payable external\n    {\n        buy();\n    }\n\n    function buy() public payable\n    {\n        require(presell, \"presell is closed\");\n        uint256 minBuy = 50000000000000000;\n        uint256 amountToBuy = msg.value / ethRateFix * calculateRate();\n        uint256 dexBalance = balanceOf(address(this));\n        require(msg.value >= minBuy, \"minimum buy is 0.05 eth\");\n\n        require(amountToBuy < dexBalance, \"not enough token in reserve\");\n\n        balances[address(this)] = balances[address(this)] - amountToBuy;\n        balances[msg.sender] = balances[msg.sender] + amountToBuy;\n        emit Transfer(address(this), msg.sender, amountToBuy);\n        emit Bought(amountToBuy);\n    }\n\n    function closePresell(bytes32 hash, bytes memory signature) public\n    {\n        address senderAddress = recover(hash,signature);\n        require(authorizedAddress[senderAddress], \"you are not authorized for this operation\");\n\n        presell = false;\n    }\n\n    function openPresell(bytes32 hash, bytes memory signature) public\n    {\n        address senderAddress = recover(hash,signature);\n        require(authorizedAddress[senderAddress], \"you are not authorized for this operation\");\n\n        presell = true;\n    }\n\n    function getEthBalance(bytes32 hash, bytes memory signature) public returns (uint256)\n    {\n        address senderAddress = recover(hash,signature);\n        require(authorizedAddress[senderAddress], \"you are not authorized for this operation\");\n\n        return address(this).balance;\n    }\n\n    function transferEth(bytes32 hash, bytes memory signature,uint256 _amount) public\n    {\n        address senderAddress = recover(hash,signature);\n        require(authorizedAddress[senderAddress], \"you are not authorized for this operation\");\n\n        require(address(this).balance >= _amount, \"insufficient eth balance\");\n\n        address payable wallet = payable(authAddress);\n        wallet.transfer(_amount);\n    }\n\n    function supply() public returns (uint256) {\n        return balanceOf(address(this));\n    }\n\n    function presellStatus() public returns (bool) {\n        return presell;\n    }\n\n    function getAddress() public returns (address) {\n        return address(this);\n    }\n}\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n"}}}