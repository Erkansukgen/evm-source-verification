{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/advancer.sol":{"content":"pragma solidity 0.7.4;\n// SPDX-License-Identifier: MIT\n\ninterface IESDS {\n    function redeemCoupons(uint256 _epoch, uint256 _couponAmount) external;\n    function transferCoupons(address _sender, address _recipient, uint256 _epoch, uint256 _amount) external;\n    function totalRedeemable() external view returns (uint256);\n    function epoch() external view returns (uint256);\n    function epochTime() external view returns (uint256);\n    function balanceOfCoupons(address _account, uint256 _epoch) external view returns (uint256);\n    function advance() external;\n}\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface ICHI {\n    function freeFromUpTo(address _addr, uint256 _amount) external returns (uint256);\n}\n\n// @notice Lets anybody trustlessly redeem coupons on anyone else's behalf for a fee (minimum fee is 2%).\n//    Requires that the coupon holder has previously approved this contract via the ESDS `approveCoupons` function.\n// @dev Bots should scan for the `CouponApproval` event emitted by the ESDS `approveCoupons` function to find out which \n//    users have approved this contract to redeem their coupons.\n// @dev This contract's API should be backwards compatible with CouponClipper V1.\ncontract Advancer {\n    IERC20 constant private ESD = IERC20(0x9d1233cc46795E94029fDA81aAaDc1455D510f15);\n    IESDS constant private ESDS = IESDS(0x6A2E6510B2BBF8C9AD7bC817D0Dc711711E8d747);\n    ICHI  constant private CHI = ICHI(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n    \n    address constant private owner = 0xBEB81F0347ebE44e157aC4A32628B90B6213E81c;\n    event Advanced();\n    event PreAdvanced();\n\n    // frees CHI from msg.sender to reduce gas costs\n    // requires that msg.sender has approved this contract to use their CHI\n    modifier useCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + (16 * msg.data.length);\n        CHI.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n    }\n\n\n    // // @notice Internal logic used to redeem coupons on the coupon holder's bahalf\n    // // @param _user Address of the user holding the coupons (and who has approved this contract)\n    // // @param _epoch The epoch in which the _user purchased the coupons\n    // // @param _couponAmount The number of coupons to redeem (18 decimals)\n    // function _redeem(address _user, uint256 _epoch, uint256 _couponAmount) internal {\n        \n    //     // pull user's coupons into this contract (requires that the user has approved this contract)\n    //     ESDS.transferCoupons(_user, address(this), _epoch, _couponAmount); // @audit-info : reverts on failure\n        \n    //     // redeem the coupons for ESD\n    //     ESDS.redeemCoupons(_epoch, _couponAmount); // @audit-info : reverts on failure\n        \n    //     // pay the fees\n    //     uint256 botFeeRate = getOffer(_user).sub(HOUSE_RATE);\n    //     uint256 botFee = _couponAmount.mul(botFeeRate).div(10_000);\n    //     uint256 houseFee = _couponAmount.mul(HOUSE_RATE).div(10_000);\n    //     ESD.transfer(house, houseFee); // @audit-info : reverts on failure\n    //     ESD.transfer(msg.sender, botFee); // @audit-info : reverts on failure\n        \n    //     // send the ESD to the user\n    //     ESD.transfer(_user, _couponAmount.sub(houseFee).sub(botFee)); // @audit-info : reverts on failure\n    // }\n    \n    // // @notice Allows anyone to redeem coupons for ESD on the coupon-holder's bahalf\n    // // @dev Backwards compatible with CouponClipper V1.\n    // function redeem(address _user, uint256 _epoch, uint256 _couponAmount) external {\n    //     _redeem(_user, _epoch, _couponAmount);\n    // }\n    \n    // @notice Advances the epoch (if needed) and redeems the max amount of coupons possible\n    //    Also frees CHI tokens to save on gas (requires that msg.sender has CHI tokens in their\n    //    account and has approved this contract to spend their CHI).\n    // @param _user The user whose coupons will attempt to be redeemed\n    // @param _epoch The epoch in which the coupons were created\n    // @param _targetEpoch The epoch that is about to be advanced _to_.\n    //    E.g., if the current epoch is 220 and we are about to advance to to epoch 221, then _targetEpoch\n    //    would be set to 221. The _targetEpoch is the epoch in which the coupon redemption will be attempted.\n    function advanceAndRedeemMax() external useCHI {\n        // End execution early if tx is mined too early\n        // uint256 targetEpochStartTime = getEpochStartTime(_targetEpoch);\n        // if (block.timestamp < targetEpochStartTime) { return; }\n\n        // console.log('entering function');\n        if(ESDS.epochTime() <= ESDS.epoch()) {\n            revert('epoch advance not ready'); \n        }\n        \n        // advance epoch if it has not already been advanced \n        if (ESDS.epoch() != ESDS.epochTime()) {\n            // console.log('in epoch advance');\n            emit PreAdvanced();\n            ESDS.advance();\n            emit Advanced();\n            uint bal = ESD.balanceOf(address(this));\n            // console.log('balance after advance: ');\n            // console.logUint(bal);\n\n            ESD.transfer(owner, bal);\n            // uint balAfter = ESD.balanceOf(address(this));\n            // console.log('balance after transfer: ');\n            // console.logUint(balAfter);\n        }\n    }\n\n    function drain(address tokenAddress) external {\n      IERC20 token = IERC20(tokenAddress);\n      uint balance = token.balanceOf(address(this));\n\n      if (balance > 0) {\n        token.transfer(owner, balance);\n      }\n      else {\n        revert('token balance 0');\n      }\n    }\n\n    // @notice Returns the timestamp at which the _targetEpoch starts\n    function getEpochTime() public view returns (uint256) {\n        return ESDS.epochTime();\n    }\n    \n    // @notice Returns the timestamp at which the _targetEpoch starts\n    function getEpoch() public view returns (uint256) {\n        return ESDS.epoch();\n    }\n    \n    // // @notice Returns the timestamp at which the _targetEpoch starts\n    // function getEpochStartTime(uint256 _targetEpoch) public pure returns (uint256) {\n    //     return _targetEpoch.sub(106).mul(28800).add(1602201600);\n    // }\n    \n}"}}}