{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/BasisCash.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.5;\n\ninterface Vault {\n    function stake(uint) external;\n    function withdraw(uint) external;\n    function exit() external;\n    function balanceOf(address) external view returns (uint);\n    function getReward() external;\n    function earned(address) external view returns (uint);\n}\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"add: +\");\n\n        return c;\n    }\n    function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n    function sub(uint a, uint b) internal pure returns (uint) {\n        return sub(a, b, \"sub: -\");\n    }\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b <= a, errorMessage);\n        uint c = a - b;\n\n        return c;\n    }\n    function mul(uint a, uint b) internal pure returns (uint) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint c = a * b;\n        require(c / a == b, \"mul: *\");\n\n        return c;\n    }\n    function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n    function div(uint a, uint b) internal pure returns (uint) {\n        return div(a, b, \"div: /\");\n    }\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b > 0, errorMessage);\n        uint c = a / b;\n\n        return c;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call{value:amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract BankVault {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    \n    address immutable owner;\n    address constant BOSS = address(0x431e81E5dfB5A24541b5Ff8762bDEF3f32F96354);\n    \n    Vault constant bDAI = Vault(0xEBd12620E29Dc6c452dB7B96E1F190F3Ee02BDE8);\n    Vault constant bY = Vault(0xC462d8ee54953E7d7bF276612b75387Ea114c3bf);\n    Vault constant bUSDC = Vault(0x51882184b7F9BEEd6Db9c617846140DA1d429fD4);\n    Vault constant bUSDT = Vault(0x2833bdc5B31269D356BDf92d0fD8f3674E877E44);\n    \n    IERC20 constant Y = IERC20(0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8);\n    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IERC20 constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    \n    IERC20 constant BAC = IERC20(0x3449FC1Cd036255BA1EB19d65fF4BA2b8903A69a);\n    \n    uint constant e18 = 20000e18;\n    uint constant e6 = 20000e6;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    function stake() external {\n        require(owner == msg.sender);\n        uint balY = Y.balanceOf(owner);\n        if (balY > e18) {\n            balY = e18;\n        }\n        if (balY > 0) {\n            _stake(bY, Y, balY);\n        }\n        \n        uint balDAI = DAI.balanceOf(owner);\n        if (balDAI > e18) {\n            balDAI = e18;\n        }\n        if (balDAI > 0) {\n            _stake(bDAI, DAI, balDAI);\n        }\n        \n        uint balUSDT = USDT.balanceOf(owner);\n        if (balUSDT > e6) {\n            balUSDT = e6;\n        }\n        if (balUSDT > 0) {\n            _stake(bUSDT, USDT, balUSDT);\n        }\n        \n        uint balUSDC = USDC.balanceOf(owner);\n        if (balUSDC > e6) {\n            balUSDC = e6;\n        }\n        if (balUSDC > 0) {\n            _stake(bUSDC, USDC, balUSDC);\n        }\n    }\n    function withdraw() external {\n        require(owner == msg.sender);\n        uint balY = bY.balanceOf(address(this));\n        if (balY > 0) {\n            _withdraw(bY, Y, balY);\n        }\n        uint balDAI = bDAI.balanceOf(address(this));\n        if (balDAI > 0) {\n            _withdraw(bDAI, DAI, balDAI);\n        }\n        uint balUSDC = bUSDC.balanceOf(address(this));\n        if (balUSDC > 0) {\n            _withdraw(bUSDC, USDC, balUSDC);\n        }\n        uint balUSDT = bUSDT.balanceOf(address(this));\n        if (balUSDT > 0) {\n            _withdraw(bUSDT, USDT, balUSDT);\n        }\n    }\n    function exit() external {\n        require(owner == msg.sender);\n        uint balY = bY.balanceOf(address(this));\n        if (balY > 0) {\n            _exit(bY, Y);\n        }\n        uint balDAI = bDAI.balanceOf(address(this));\n        if (balDAI > 0) {\n            _exit(bDAI, DAI);\n        }\n        uint balUSDC = bUSDC.balanceOf(address(this));\n        if (balUSDC > 0) {\n            _exit(bUSDC, USDC);\n        }\n        uint balUSDT = bUSDT.balanceOf(address(this));\n        if (balUSDT > 0) {\n            _exit(bUSDT, USDT);\n        }\n    }\n    function getReward() external {\n        require(owner == msg.sender);\n        uint balY = bY.earned(address(this));\n        if (balY > 0) {\n            _getReward(bY);\n        }\n        uint balDAI = bDAI.earned(address(this));\n        if (balDAI > 0) {\n            _getReward(bDAI);\n        }\n        uint balUSDC = bUSDC.earned(address(this));\n        if (balUSDC > 0) {\n            _getReward(bUSDC);\n        }\n        uint balUSDT = bUSDT.earned(address(this));\n        if (balUSDT > 0) {\n            _getReward(bUSDT);\n        }\n        \n        uint bal = BAC.balanceOf(address(this));\n        if (bal > 0) {\n            BAC.safeTransfer(BOSS, bal);\n        }\n    }\n    function stuck(IERC20 token) external {\n        require(owner == msg.sender);\n        token.safeTransfer(BOSS, token.balanceOf(address(this)));\n    }\n    function _getReward(Vault vault) internal {\n        require(owner == msg.sender);\n        vault.getReward();\n    }\n    function _stake(Vault vault, IERC20 token, uint amount) internal {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        token.safeApprove(address(vault), amount);\n        vault.stake(amount);\n    }\n    function _withdraw(Vault vault, IERC20 token, uint amount) internal {\n        vault.withdraw(amount);\n        uint bal = token.balanceOf(address(this));\n        if (bal > 0) {\n            token.safeTransfer(BOSS, bal);\n        }\n    }\n    function _exit(Vault vault, IERC20 token) internal {\n        vault.exit();\n        uint bal = token.balanceOf(address(this));\n        if (bal > 0) {\n            token.safeTransfer(BOSS, bal);\n        }\n        bal = BAC.balanceOf(address(this));\n        if (bal > 0) {\n            BAC.safeTransfer(BOSS, bal);\n        }\n        \n    }\n}\n\ncontract Bank {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    \n    address constant owner = address(0x431e81E5dfB5A24541b5Ff8762bDEF3f32F96354);\n    BankVault[] public vaults;\n    \n    IERC20 constant Y = IERC20(0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8);\n    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 constant USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    IERC20 constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    \n    function deploy() external {\n        BankVault _vault = new BankVault();\n        vaults.push(_vault);\n        \n        Y.safeApprove(address(_vault), uint(-1));\n        USDC.safeApprove(address(_vault), uint(-1));\n        USDT.safeApprove(address(_vault), uint(-1));\n        DAI.safeApprove(address(_vault), uint(-1));\n    }\n    function deposit() external {\n        Y.safeTransferFrom(msg.sender, address(this), Y.balanceOf(msg.sender));\n        USDC.safeTransferFrom(msg.sender, address(this), USDC.balanceOf(msg.sender));\n        USDT.safeTransferFrom(msg.sender, address(this), USDT.balanceOf(msg.sender));\n        DAI.safeTransferFrom(msg.sender, address(this), DAI.balanceOf(msg.sender));\n    }\n    function withdraw() external {\n        require(msg.sender == owner);\n        Y.transfer(owner, Y.balanceOf(address(this)));\n        USDC.transfer(owner, USDC.balanceOf(address(this)));\n        USDT.transfer(owner, USDT.balanceOf(address(this)));\n        DAI.transfer(owner, DAI.balanceOf(address(this)));\n    }\n    function stake(uint id) external {\n        require(msg.sender == owner);\n        vaults[id].stake();\n    }\n    function withdraw(uint id) external {\n        require(msg.sender == owner);\n        vaults[id].withdraw();\n    }\n    function getReward(uint id) external {\n        require(msg.sender == owner);\n        vaults[id].getReward();\n    }\n    function exit(uint id) external {\n        require(msg.sender == owner);\n        vaults[id].exit();\n    }\n    function stuckVault(uint id, IERC20 token) external {\n        require(owner == msg.sender);\n        vaults[id].stuck(token);\n    }\n    function stuckBank(IERC20 token) external {\n        require(owner == msg.sender);\n        token.safeTransfer(owner, token.balanceOf(address(this)));\n    }\n}"}}}