{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Coin.sol":{"content":"// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\ncontract Coin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"Coin/account-not-authorized\");\n        _;\n    }\n\n    modifier canChangeData() {\n        require(changeData == 1, \"Coin/cannot-change-namings\");\n        _;\n    }\n\n    // --- ERC20 Data ---\n    string  public name;\n    string  public symbol;\n    string  public version = \"1\";\n\n    uint8   public constant decimals = 18;\n\n    uint256 public chainId;\n    uint256 public totalSupply;\n    uint256 public changeData;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint)                      public nonces;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event Approval(address indexed src, address indexed guy, uint amount);\n    event Transfer(address indexed src, address indexed dst, uint amount);\n    event ModifyParameters(bytes32 parameter, uint data);\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 chainId_\n      ) public {\n        authorizedAccounts[msg.sender] = 1;\n        name          = name_;\n        symbol        = symbol_;\n        changeData    = 1;\n        chainId       = chainId_;\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            chainId_,\n            address(this)\n        ));\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"changeData\", 1);\n    }\n\n    // --- Administration ---\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized canChangeData {\n        if (parameter == \"changeData\") {\n          changeData = data;\n        }\n        else revert(\"Coin/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Naming ---\n    function setName(string calldata name_) external isAuthorized canChangeData {\n        name             = name_;\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            chainId,\n            address(this)\n        ));\n    }\n    function setSymbol(string calldata symbol_) external isAuthorized canChangeData {\n        symbol = symbol_;\n    }\n\n    // --- Token ---\n    function transfer(address dst, uint amount) external returns (bool) {\n        return transferFrom(msg.sender, dst, amount);\n    }\n    function transferFrom(address src, address dst, uint amount)\n        public returns (bool)\n    {\n        require(balanceOf[src] >= amount, \"Coin/insufficient-balance\");\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= amount, \"Coin/insufficient-allowance\");\n            allowance[src][msg.sender] = subtract(allowance[src][msg.sender], amount);\n        }\n        balanceOf[src] = subtract(balanceOf[src], amount);\n        balanceOf[dst] = addition(balanceOf[dst], amount);\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n    function mint(address usr, uint amount) external isAuthorized {\n        balanceOf[usr] = addition(balanceOf[usr], amount);\n        totalSupply    = addition(totalSupply, amount);\n        emit Transfer(address(0), usr, amount);\n    }\n    function burn(address usr, uint amount) external {\n        require(balanceOf[usr] >= amount, \"Coin/insufficient-balance\");\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\n            require(allowance[usr][msg.sender] >= amount, \"Coin/insufficient-allowance\");\n            allowance[usr][msg.sender] = subtract(allowance[usr][msg.sender], amount);\n        }\n        balanceOf[usr] = subtract(balanceOf[usr], amount);\n        totalSupply    = subtract(totalSupply, amount);\n        emit Transfer(usr, address(0), amount);\n    }\n    function approve(address usr, uint amount) external returns (bool) {\n        allowance[msg.sender][usr] = amount;\n        emit Approval(msg.sender, usr, amount);\n        return true;\n    }\n\n    // --- Alias ---\n    function push(address usr, uint amount) external {\n        transferFrom(msg.sender, usr, amount);\n    }\n    function pull(address usr, uint amount) external {\n        transferFrom(usr, msg.sender, amount);\n    }\n    function move(address src, address dst, uint amount) external {\n        transferFrom(src, dst, amount);\n    }\n\n    // --- Approve by signature ---\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external\n    {\n        require(changeData != 1, \"Coin/can-still-change-namings\");\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     holder,\n                                     spender,\n                                     nonce,\n                                     expiry,\n                                     allowed))\n        ));\n\n        require(holder != address(0), \"Coin/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"Coin/invalid-permit\");\n        require(expiry == 0 || now <= expiry, \"Coin/permit-expired\");\n        require(nonce == nonces[holder]++, \"Coin/invalid-nonce\");\n        uint wad = allowed ? uint(-1) : 0;\n        allowance[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n}"}}}