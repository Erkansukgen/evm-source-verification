{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/SPImplementation.sol":{"content":"// SPDX-License-Identifier: No License (None)\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ninterface ISmartSwap {\n    function isSystem(address caller) external returns(bool);   // check if caller is system wallet.\n    function decimals(address token) external returns(uint256);   // token address => token decimals\n    function processingFee() external returns(uint256); // Processing fee\n    function companySPFee() external returns(uint256); // Company fee for SP\n    function reimburse(address user, uint256 amount) external; // reimburse user for SP payment\n    function swap(\n        address tokenA,\n        address tokenB, \n        address receiver,\n        uint256 amountA,\n        address licensee,\n        bool isInvestment,\n        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\n        uint128 limitPice,   // Do not match user if token A price less this limit\n        uint256 fee          // company + licensee fee amount\n    )\n        external\n        payable\n        returns (bool);\n\n    function cancel(\n        address tokenA,\n        address tokenB, \n        address receiver,\n        uint256 amountA    //amount of tokenA to cancel\n    )\n        external\n        payable\n        returns (bool);\n\n    function claimTokenBehalf(\n        address tokenA, // foreignToken\n        address tokenB, // nativeToken\n        address sender,\n        address receiver,\n        bool isInvestment,\n        uint128 amountA,    //amount of tokenA that has to be swapped\n        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\n        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\n    )   \n        external\n        returns (bool);\n}\n\ncontract SPImplementation{\n    struct Tokens {\n        address nativeToken;\n        address foreignToken;\n        uint8 nativeDecimals;\n        uint8 foreignDecimals;        \n    }\n    Tokens public tokensData;\n    address public nativeTokenReceiver;\n    address public foreignTokenReceiver;\n    address public owner;\n\n    ISmartSwap public smartSwap; // assign SmartSwap address here\n    uint256 private feeAmountLimit; // limit of amount that System withdraw for fee reimbursement\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event FeeTransfer(address indexed systemWallet, uint256 fee);\n    event Deposit(uint256 value);\n\n    // run only once from proxy\n    function initialize(\n        address _owner,     // contract owner\n        address _nativeToken, // native token that will be send to SmartSwap\n        address _foreignToken, // foreign token that has to be received from SmartSwap (on foreign chain)\n        address _nativeTokenReceiver, // address on Binance to deposit native token\n        address _foreignTokenReceiver, // address on Binance to deposit foreign token\n        uint256 _feeAmountLimit // limit of amount that System may withdraw for fee reimbursement\n    )\n        external\n    {\n        require(owner == address(0)); // run only once\n        require(\n            _nativeToken != address(0)\n            && _foreignToken != address(0)\n            && _nativeTokenReceiver != address(0)\n            && _foreignTokenReceiver != address(0)\n        );\n        tokensData.nativeToken = _nativeToken;\n        tokensData.foreignToken = _foreignToken;\n        nativeTokenReceiver = _nativeTokenReceiver;\n        foreignTokenReceiver = _foreignTokenReceiver;\n        feeAmountLimit = _feeAmountLimit;\n        smartSwap = ISmartSwap(msg.sender);\n        tokensData.nativeDecimals = uint8(smartSwap.decimals(tokensData.nativeToken));\n        tokensData.foreignDecimals = uint8(smartSwap.decimals(tokensData.foreignToken));\n        owner = _owner;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    receive() external payable {\n        emit Deposit(msg.value);\n    }\n\n    /**\n    * @dev Throws if called by any account other than the system.\n    */\n    modifier onlySystem() {\n        require(smartSwap.isSystem(msg.sender), \"Caller is not the system\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    // set limit of amount that System withdraw for fee reimbursement\n    function setFeeAmountLimit(uint256 amount) external onlyOwner {\n        feeAmountLimit = amount;\n    }\n\n    // get limit of amount that System withdraw for fee reimbursement\n    function getFeeAmountLimit() external view returns(uint256) {\n        return feeAmountLimit;\n    }\n\n    function cancel(uint256 amount) external onlySystem {\n        smartSwap.cancel(tokensData.nativeToken, tokensData.foreignToken, foreignTokenReceiver, amount);\n    }\n\n    // Allow owner withdraw tokens from contract\n    function withdraw(address token, uint256 amount) external onlyOwner {\n        if (token < address(9))\n            safeTransferETH(msg.sender, amount);\n        else\n            safeTransfer(token, msg.sender, amount);\n    }\n\n\n\n    // add liquidity to counterparty \n    function addLiquidityAndClaimBehalf(\n        uint256 feeAmount,   // processing fee amount to reimburse system wallet.\n        uint128 amount,    //amount of native token that has to be swapped (amount of provided liquidity)\n        uint128 currentRate,     // rate with 18 decimals: tokenB price / tokenA price\n        uint128[] memory claimAmount, // claim amount (in foreign tokens).\n        uint256[] memory foreignBalance,  // total tokens amount sent by user to pair on other chain\n        address[] memory senderCounterparty, // correspondent value from SwapRequest event\n        address[] memory receiverCounterparty,    // correspondent value from SwapRequest event\n        uint256[] memory reimbursement   // amount of reimbursement to user in native coin (BNB, ETH)\n    ) \n        external \n        onlySystem \n    {\n        require(feeAmountLimit >= feeAmount, \"Fee limit exceeded\");\n\n        feeAmountLimit -= feeAmount;\n        Tokens memory t = tokensData;\n        require(claimAmount.length == foreignBalance.length &&\n            senderCounterparty.length == receiverCounterparty.length &&\n            foreignBalance.length == senderCounterparty.length &&\n            foreignBalance.length == reimbursement.length, \n            \"Wrong length\"\n        );\n        // send swap request\n        swap(t, amount, feeAmount);\n        // claim tokens on users behalf\n        claimBehalf(t, currentRate, claimAmount, foreignBalance, senderCounterparty, receiverCounterparty);\n        // send reimbursement to users\n        for (uint256 i = 0; i < reimbursement.length; i++) {\n            if (reimbursement[i] != 0) {\n                smartSwap.reimburse(receiverCounterparty[i], reimbursement[i]);\n            }\n        }\n    }\n\n    function claimBehalf(\n        Tokens memory t, \n        uint128 currentRate,     // rate with 18 decimals: tokenB price / tokenA price\n        uint128[] memory claimAmount, // claim amount (in foreign tokens).\n        uint256[] memory foreignBalance,  // total tokens amount sent by user to pair on other chain\n        address[] memory senderCounterparty, // correspondent value from SwapRequest event\n        address[] memory receiverCounterparty    // correspondent value from SwapRequest event\n    ) \n        internal \n    {\n        uint256 totalAmount;\n        for (uint256 i = 0; i < claimAmount.length; i++) {\n            totalAmount += claimAmount[i];\n            smartSwap.claimTokenBehalf(\n                t.foreignToken,\n                t.nativeToken,\n                senderCounterparty[i],\n                receiverCounterparty[i],\n                false,\n                claimAmount[i],\n                currentRate, \n                foreignBalance[i]\n            );\n        }\n        //require(totalAmount * currentRate / (10**(18+t.foreignDecimals-t.nativeDecimals)) <= uint256(amount), \"Insuficiant amount\");\n    }\n\n    function swap(Tokens memory t, uint128 amount, uint256 feeAmount) internal {\n        uint256 processingFee = smartSwap.processingFee();\n        if (t.nativeToken > address(9)) {\n            // can't get company fee amount\n            IERC20(t.nativeToken).approve(address(smartSwap), uint256(amount));\n            smartSwap.swap{value: processingFee}(\n                t.nativeToken, \n                t.foreignToken,\n                foreignTokenReceiver, \n                amount, \n                address(0),\n                false, \n                0,\n                0,\n                0\n            );            \n        } else {    // native coin (ETH, BNB)\n            uint256 fee = uint256(amount)*smartSwap.companySPFee()/10000;  // company fee\n            processingFee = fee + processingFee;\n            smartSwap.swap{value: uint256(amount) + processingFee}(\n                t.nativeToken, \n                t.foreignToken,\n                foreignTokenReceiver, \n                amount, \n                address(0),\n                false, \n                0,\n                0,\n                fee\n            );\n        }\n        require(processingFee <= feeAmount, \"Insuficiant fee\");\n        feeAmount -= processingFee; // we already paid processing fee to SmartSwap contract\n        if (feeAmount != 0) {\n            payable(msg.sender).transfer(feeAmount);\n            smartSwap.reimburse(owner, feeAmount);\n            emit FeeTransfer(msg.sender, feeAmount);\n        }        \n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n}"}}}