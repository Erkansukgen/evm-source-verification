{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/arbitrum/IBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IBridge {\n  event MessageDelivered(\n    uint256 indexed messageIndex,\n    bytes32 indexed beforeInboxAcc,\n    address inbox,\n    uint8 kind,\n    address sender,\n    bytes32 messageDataHash\n  );\n\n  event BridgeCallTriggered(\n    address indexed outbox,\n    address indexed destAddr,\n    uint256 amount,\n    bytes data\n  );\n\n  event InboxToggle(address indexed inbox, bool enabled);\n\n  event OutboxToggle(address indexed outbox, bool enabled);\n\n  function deliverMessageToInbox(\n    uint8 kind,\n    address sender,\n    bytes32 messageDataHash\n  ) external payable returns (uint256);\n\n  function executeCall(\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (bool success, bytes memory returnData);\n\n  // These are only callable by the admin\n  function setInbox(address inbox, bool enabled) external;\n\n  function setOutbox(address inbox, bool enabled) external;\n\n  // View functions\n\n  function activeOutbox() external view returns (address);\n\n  function allowedInboxes(address inbox) external view returns (bool);\n\n  function allowedOutboxes(address outbox) external view returns (bool);\n\n  function inboxAccs(uint256 index) external view returns (bytes32);\n\n  function messageCount() external view returns (uint256);\n}\n"
    },
    "contracts/arbitrum/IInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n  function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n  function sendUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (uint256);\n\n  function sendContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (uint256);\n\n  function sendL1FundedUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function sendL1FundedContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function createRetryableTicket(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function createRetryableTicketNoRefundAliasRewrite(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n\n  function bridge() external view returns (address);\n\n  function pauseCreateRetryables() external;\n\n  function unpauseCreateRetryables() external;\n\n  function startRewriteAddress() external;\n\n  function stopRewriteAddress() external;\n}\n"
    },
    "contracts/arbitrum/IMessageProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IMessageProvider {\n  event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n  event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "contracts/arbitrum/IOutbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.6.11;\n\ninterface IOutbox {\n  event OutboxEntryCreated(\n    uint256 indexed batchNum,\n    uint256 outboxEntryIndex,\n    bytes32 outputRoot,\n    uint256 numInBatch\n  );\n  event OutBoxTransactionExecuted(\n    address indexed destAddr,\n    address indexed l2Sender,\n    uint256 indexed outboxEntryIndex,\n    uint256 transactionIndex\n  );\n\n  function l2ToL1Sender() external view returns (address);\n\n  function l2ToL1Block() external view returns (uint256);\n\n  function l2ToL1EthBlock() external view returns (uint256);\n\n  function l2ToL1Timestamp() external view returns (uint256);\n\n  function l2ToL1BatchNum() external view returns (uint256);\n\n  function l2ToL1OutputId() external view returns (bytes32);\n\n  function processOutgoingMessages(bytes calldata sendsData, uint256[] calldata sendLengths)\n    external;\n\n  function outboxEntryExists(uint256 batchNum) external view returns (bool);\n}\n"
    },
    "contracts/l1/L1CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"../arbitrum/IBridge.sol\";\nimport \"../arbitrum/IInbox.sol\";\nimport \"../arbitrum/IOutbox.sol\";\n\nabstract contract L1CrossDomainEnabled {\n  IInbox public inbox;\n\n  event TxToL2(address indexed from, address indexed to, uint256 indexed seqNum, bytes data);\n\n  function __CrossDomainEnabled_init(address _inbox) internal {\n    inbox = IInbox(_inbox);\n  }\n\n  modifier onlyL2Counterpart(address l2Counterpart) {\n    // a message coming from the counterpart gateway was executed by the bridge\n    address bridge = inbox.bridge();\n    require(msg.sender == bridge, \"NOT_FROM_BRIDGE\");\n\n    // and the outbox reports that the L2 address of the sender is the counterpart gateway\n    address l2ToL1Sender = IOutbox(IBridge(bridge).activeOutbox()).l2ToL1Sender();\n    require(l2ToL1Sender == l2Counterpart, \"ONLY_COUNTERPART_GATEWAY\");\n    _;\n  }\n\n  function sendTxToL2(\n    address target,\n    address user,\n    uint256 maxSubmissionCost,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes memory data\n  ) internal returns (uint256) {\n    uint256 seqNum = inbox.createRetryableTicket{value: msg.value}(\n      target,\n      0, // we always assume that l2CallValue = 0\n      maxSubmissionCost,\n      user,\n      user,\n      maxGas,\n      gasPriceBid,\n      data\n    );\n    emit TxToL2(user, target, seqNum, data);\n    return seqNum;\n  }\n\n  function sendTxToL2NoAliasing(\n    address target,\n    address user,\n    uint256 l1CallValue,\n    uint256 maxSubmissionCost,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes memory data\n  ) internal returns (uint256) {\n    uint256 seqNum = inbox.createRetryableTicketNoRefundAliasRewrite{value: l1CallValue}(\n      target,\n      0, // we always assume that l2CallValue = 0\n      maxSubmissionCost,\n      user,\n      user,\n      maxGas,\n      gasPriceBid,\n      data\n    );\n    emit TxToL2(user, target, seqNum, data);\n    return seqNum;\n  }\n}\n"
    },
    "contracts/l1/L1ITokenGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\n// differences between L1 and L2 version of this interface:\n// - payable modifier on outboundTransfer\n// - events\ninterface L1ITokenGateway {\n  event DepositInitiated(\n    address l1Token,\n    address indexed from,\n    address indexed to,\n    uint256 indexed sequenceNumber,\n    uint256 amount\n  );\n\n  event WithdrawalFinalized(\n    address l1Token,\n    address indexed from,\n    address indexed to,\n    uint256 indexed exitNum,\n    uint256 amount\n  );\n\n  function outboundTransfer(\n    address token,\n    address to,\n    uint256 amount,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (bytes memory);\n\n  function finalizeInboundTransfer(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  // if token is not supported this should return 0x0 address\n  function calculateL2TokenAddress(address l1Token) external view returns (address);\n\n  // used by router\n  function counterpartGateway() external view returns (address);\n}\n"
    },
    "contracts/l1/L1USXGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\nimport \"./L1ITokenGateway.sol\";\nimport \"../l2/L2ITokenGateway.sol\";\nimport \"./L1CrossDomainEnabled.sol\";\nimport \"../library/Initializable.sol\";\n\ninterface TokenLike {\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool success);\n}\n\ncontract L1USXGateway is Initializable, L1CrossDomainEnabled, L1ITokenGateway {\n  // --- Auth ---\n  mapping(address => uint256) public wards;\n\n  function rely(address usr) external auth {\n    wards[usr] = 1;\n    emit Rely(usr);\n  }\n\n  function deny(address usr) external auth {\n    wards[usr] = 0;\n    emit Deny(usr);\n  }\n\n  modifier auth() {\n    require(wards[msg.sender] == 1, \"L1USXGateway/not-authorized\");\n    _;\n  }\n\n  event Rely(address indexed usr);\n  event Deny(address indexed usr);\n\n  address public l1USX;\n  address public l2USX;\n  address public l1Escrow;\n  address public l1Router;\n  address public l2Counterpart;\n  uint256 public isOpen;\n\n  event Closed();\n\n  constructor(\n    address _l2Counterpart,\n    address _l1Router,\n    address _inbox,\n    address _l1USX,\n    address _l2USX,\n    address _l1Escrow\n  ) public {\n    initialize(_l2Counterpart, _l1Router, _inbox, _l1USX, _l2USX, _l1Escrow);\n  }\n\n  function initialize(\n    address _l2Counterpart,\n    address _l1Router,\n    address _inbox,\n    address _l1USX,\n    address _l2USX,\n    address _l1Escrow\n  ) public initializer {\n    isOpen = 1;\n    wards[msg.sender] = 1;\n    emit Rely(msg.sender);\n\n    l1USX = _l1USX;\n    l2USX = _l2USX;\n    l1Escrow = _l1Escrow;\n    l1Router = _l1Router;\n    l2Counterpart = _l2Counterpart;\n\n    __CrossDomainEnabled_init(_inbox);\n  }\n\n  function close() external auth {\n    isOpen = 0;\n\n    emit Closed();\n  }\n\n  function outboundTransfer(\n    address l1Token,\n    address to,\n    uint256 amount,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable override returns (bytes memory) {\n    // do not allow initiating new xchain messages if bridge is closed\n    require(isOpen == 1, \"L1USXGateway/closed\");\n    require(l1Token == l1USX, \"L1USXGateway/token-not-USX\");\n\n    // we use nested scope to avoid stack too deep errors\n    address from;\n    uint256 seqNum;\n    bytes memory extraData;\n    {\n      uint256 maxSubmissionCost;\n      (from, maxSubmissionCost, extraData) = parseOutboundData(data);\n      // require(extraData.length == 0, \"L1USXGateway/call-hook-data-not-allowed\");\n\n      TokenLike(l1Token).transferFrom(from, l1Escrow, amount);\n\n      bytes memory outboundCalldata = getOutboundCalldata(l1Token, from, to, amount, extraData);\n      seqNum = sendTxToL2(\n        l2Counterpart,\n        from,\n        maxSubmissionCost,\n        maxGas,\n        gasPriceBid,\n        outboundCalldata\n      );\n    }\n\n    emit DepositInitiated(l1Token, from, to, seqNum, amount);\n\n    return abi.encode(seqNum);\n  }\n\n  function getOutboundCalldata(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes memory data\n  ) public pure returns (bytes memory outboundCalldata) {\n    bytes memory emptyBytes = \"\";\n\n    outboundCalldata = abi.encodeWithSelector(\n      L2ITokenGateway.finalizeInboundTransfer.selector,\n      l1Token,\n      from,\n      to,\n      amount,\n      abi.encode(emptyBytes, data)\n    );\n\n    return outboundCalldata;\n  }\n\n  function finalizeInboundTransfer(\n    address l1Token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external override onlyL2Counterpart(l2Counterpart) {\n    require(l1Token == l1USX, \"L1USXGateway/token-not-USX\");\n    (uint256 exitNum, ) = abi.decode(data, (uint256, bytes));\n\n    TokenLike(l1Token).transferFrom(l1Escrow, to, amount);\n\n    emit WithdrawalFinalized(l1Token, from, to, exitNum, amount);\n  }\n\n  function parseOutboundData(bytes memory data)\n    internal\n    view\n    returns (\n      address from,\n      uint256 maxSubmissionCost,\n      bytes memory extraData\n    )\n  {\n    if (msg.sender == l1Router) {\n      // router encoded\n      (from, extraData) = abi.decode(data, (address, bytes));\n    } else {\n      from = msg.sender;\n      extraData = data;\n    }\n    // user encoded\n    (maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n  }\n\n  function calculateL2TokenAddress(address l1Token) external view override returns (address) {\n    if (l1Token != l1USX) {\n      return address(0);\n    }\n\n    return l2USX;\n  }\n\n  function counterpartGateway() external view override returns (address) {\n    return l2Counterpart;\n  }\n}\n"
    },
    "contracts/l2/L2ITokenGateway.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2021 Dai Foundation\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.11;\n\ninterface L2ITokenGateway {\n  event DepositFinalized(\n    address indexed l1Token,\n    address indexed from,\n    address indexed to,\n    uint256 amount\n  );\n\n  event WithdrawalInitiated(\n    address l1Token,\n    address indexed from,\n    address indexed to,\n    uint256 indexed l2ToL1Id,\n    uint256 exitNum,\n    uint256 amount\n  );\n\n  function outboundTransfer(\n    address token,\n    address to,\n    uint256 amount,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external returns (bytes memory);\n\n  function finalizeInboundTransfer(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  // if token is not supported this should return 0x0 address\n  function calculateL2TokenAddress(address l1Token) external view returns (address);\n\n  // used by router\n  function counterpartGateway() external view returns (address);\n}\n"
    },
    "contracts/library/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            !_initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        _;\n\n        _initialized = true;\n    }\n}\n"
    }
  }
}