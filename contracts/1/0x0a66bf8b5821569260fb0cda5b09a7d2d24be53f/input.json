{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Gum.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IERC20 {\n    function transfer(address _to, uint256 _amount) external returns (bool);\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n}\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ncontract VegetaInu{\n    string  private _name = 'Vegeta Inu';\n    string  private _symbol = 'VEGI';\n    uint256 private _totalSupply = 1000000000;\n    uint8   private _decimals = 18;\n    address private _uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; //0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; //Routerv2 Ethereum\n    \n    address public uniswapPair;\n    address public devWallet;\n    address public burnWallet = 0x000000000000000000000000000000000000dEaD;\n    uint256 public maxWalletLimit;\n    uint256 public maxTxLimit;\n    uint8   public buyBurnFee;\n    uint8   public buyDevFee;\n    uint8   public buyLiquidityFee;\n    uint8   public sellLiquidityFee;\n    uint256 public addLiquidityAmount;\n    \n    address private _owner;\n    bool    private _inSwap;\n    IUniswapV2Router02 private _uniswapV2Router;\n    \n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => uint256) private _balances;\n    mapping (address => bool) private _excludedMaxWallet;\n    mapping (address => bool) private _excludedMaxTransaction;\n    mapping (address => bool) private _excludedFees;\n    mapping (address => bool) private _blacklisted;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    receive () external payable {}\n    \n    modifier onlyOwner() {\n        require(_owner == msg.sender, 'Only the owner can call this function!');\n        _;\n    }\n    \n    constructor () {\n        emit OwnershipTransferred(_owner, msg.sender);\n        _owner = msg.sender;\n        _totalSupply = _totalSupply * 10**_decimals;\n        _balances[_owner] = _totalSupply;\n        \n        _uniswapV2Router = IUniswapV2Router02(_uniswapRouter);\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n        \n        devWallet = _owner;\n\n        maxWalletLimit = 30000000 * 10**_decimals;\n        maxTxLimit = 10000000 * 10**_decimals;\n        addLiquidityAmount = 20000000 * 10**_decimals;\n        \n        buyBurnFee = 1;\n        buyDevFee = 2;\n        buyLiquidityFee = 1;\n        sellLiquidityFee = 7;\n        \n        setExcludedAll(address(this));\n        setExcludedAll(_owner);\n        setExcludedAll(uniswapPair);\n        setExcludedAll(_uniswapRouter);\n    }\n    \n    function setExcludedAll(address user) public virtual onlyOwner {\n        setExcludedMaxTransaction(user, true);\n        setExcludedMaxWallet(user, true);\n        setExcludedFees(user, true);\n    }\n    \n    function setInSwap(bool status) public virtual onlyOwner {\n        _inSwap = status;\n    }\n    \n    function setAddresses(address _burnWallet, address _devWallet) public virtual onlyOwner {\n        burnWallet = _burnWallet;\n        devWallet = _devWallet;\n    }\n    \n    function setLimits(uint256 _maxWalletLimit, uint256 _maxTxLimit, uint256 _addLiquidityAmount) public virtual onlyOwner {\n        maxWalletLimit = _maxWalletLimit * 10**_decimals;\n        maxTxLimit = _maxTxLimit * 10**_decimals;\n        addLiquidityAmount = _addLiquidityAmount * 10**_decimals;\n    }\n    \n    function setFees(uint8 _buyBurnFee, uint8 _buyDevFee, uint8 _buyLiquidityFee, uint8 _sellLiquidityFee) public virtual onlyOwner {\n        buyBurnFee = _buyBurnFee;\n        buyDevFee = _buyDevFee;\n        buyLiquidityFee = _buyLiquidityFee;\n        sellLiquidityFee = _sellLiquidityFee;\n    }\n    \n    function setExcludedMaxTransaction(address user, bool status) public virtual onlyOwner {\n        _excludedMaxTransaction[user] = status;\n    }\n    \n    function setExcludedMaxWallet(address user, bool status) public virtual onlyOwner {\n        _excludedMaxWallet[user] = status;\n    }\n    \n    function setExcludedFees(address user, bool status) public virtual onlyOwner {\n        _excludedFees[user] = status;\n    }\n    \n    function setBlacklistWallet(address user, bool status) public virtual onlyOwner {\n        _blacklisted[user] = status;\n    }\n    \n    \n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    \n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function getOwner() public view returns (address) {\n        return _owner;\n    }\n    \n    function getInSwapStatus() public view returns (bool) {\n        return _inSwap;\n    }\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n    \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(!_blacklisted[sender] && !_blacklisted[recipient], 'Sender or recipient is blacklisted!');\n        \n        if(!_excludedMaxTransaction[sender]) {\n            require(amount <= maxTxLimit, 'Exceeds max transaction limit!');\n        }\n        \n        if(!_excludedMaxWallet[recipient]) {\n            require(balanceOf(recipient) + amount <= maxWalletLimit, 'Exceeds max wallet limit!');\n        }\n        \n        uint256 senderBalance = balanceOf(sender);\n        require(senderBalance >= amount, 'Amount exceeds sender\\'s balance!');\n        _balances[sender] = senderBalance - amount;\n        \n        \n        if(sender == uniswapPair && !_excludedFees[recipient]) {\n            uint256 burnAmount = amount * buyBurnFee / 100;\n            _balances[burnWallet] += burnAmount;\n            emit Transfer(sender, burnWallet, burnAmount);\n            \n            uint256 devAmount = amount * buyDevFee / 100;\n            _balances[devWallet] += devAmount;\n            emit Transfer(sender, devWallet, devAmount);\n            \n            uint256 liquidityAmount = amount * buyLiquidityFee / 100;\n            _balances[address(this)] += liquidityAmount;\n            emit Transfer(sender, address(this), liquidityAmount);\n            \n            amount -= burnAmount + devAmount + liquidityAmount;\n        }\n        \n        else if (recipient == uniswapPair && !_excludedFees[sender]) {\n            uint256 liquidityAmount = amount * sellLiquidityFee / 100;\n            _balances[address(this)] += liquidityAmount;\n            emit Transfer(recipient, address(this), liquidityAmount);\n            amount -= liquidityAmount;\n            \n            swapAddLiquidity();\n        }\n        \n        _balances[recipient] += amount;\n        \n        emit Transfer(sender, recipient, amount);\n    }\n    \n    function addLiquidity(uint256 tokenAmount, uint256 amount) internal virtual {\n        _approve(address(this), address(_uniswapRouter), tokenAmount);\n        _uniswapV2Router.addLiquidityETH{value: amount}(address(this), tokenAmount, 0, 0, address(this), block.timestamp);\n    }\n    \n    function swapTokensForEth(uint256 amount) internal virtual {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _uniswapV2Router.WETH();\n        _approve(address(this), _uniswapRouter, amount);\n        _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(amount, 0, path, address(this), block.timestamp);\n    }\n    \n    function swapAddLiquidity() internal virtual {\n        uint256 tokenBalance = balanceOf(address(this));\n        if(!_inSwap && tokenBalance >= addLiquidityAmount) {\n            _inSwap = true;\n            \n            uint256 sellAmount = tokenBalance;\n            \n            uint256 sellHalf = sellAmount / 2;\n\n            uint256 initialEth = address(this).balance;\n            swapTokensForEth(sellHalf);\n            \n            uint256 receivedEth = address(this).balance - initialEth;\n            addLiquidity(sellAmount - sellHalf, receivedEth);\n            \n            _inSwap = false;\n        }\n    }\n    \n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), 'Wallet address can not be the zero address!');\n        require(spender != address(0), 'Spender can not be the zero address!');\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, 'Amount exceeds allowance!');\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n    \n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    \n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n    \n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, 'Decreased allowance below zero!');\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), 'Owner can not be the zero address!');\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    \n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    \n    function withdraw(uint256 amount) public payable onlyOwner returns (bool) {\n        require(amount <= address(this).balance, 'Withdrawal amount exceeds balance!');\n        payable(msg.sender).transfer(amount);\n        return true;\n    }\n    \n    function withdrawToken(address tokenContract, uint256 amount) public virtual onlyOwner {\n        IERC20 _tokenContract = IERC20(tokenContract);\n        _tokenContract.transfer(msg.sender, amount);\n    }\n}"}}}