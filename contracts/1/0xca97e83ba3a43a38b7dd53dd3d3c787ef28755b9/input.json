{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/FlashLoan.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// The ABI encoder is necessary, but older Solidity versions should work\r\npragma solidity ^0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\";\r\n\r\n// These definitions are taken from across multiple dydx contracts, and are\r\n// limited to just the bare minimum necessary to make flash loans work.\r\nlibrary Types {\r\n    enum AssetDenomination { Wei, Par }\r\n    enum AssetReference { Delta, Target }\r\n    struct AssetAmount {\r\n        bool sign;\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary Account {\r\n    struct Info {\r\n        address owner;\r\n        uint256 number;\r\n    }\r\n}\r\n\r\nlibrary Actions {\r\n    enum ActionType {\r\n        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\r\n    }\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n}\r\n\r\ninterface ISoloMargin {\r\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\r\n}\r\n\r\n// The interface for a contract to be callable after receiving a flash loan\r\ninterface ICallee {\r\n    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) external;\r\n}\r\n\r\n// Standard ERC-20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Additional methods available for WETH\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\ncontract TendiesContract{\r\n    function grillPool() public{}\r\n}\r\ncontract TacosContract{\r\n    function crunchPool()public{}\r\n}\r\ncontract WingContract{\r\n    function bakePool()public{}\r\n}\r\ncontract FlashLoanTemplate is ICallee {\r\n    TendiesContract _TendiesContract;\r\n    TacosContract _TacosContract;\r\n    WingContract _WingContract;\r\n    using SafeMath for uint256;\r\n    address internal constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    IUniswapV2Router02 public uniswapRouter;\r\n    // The WETH token contract, since we're assuming we want a loan in WETH\r\n    IWETH private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    address TendiesAddress = 0x1453Dbb8A29551ADe11D89825CA812e05317EAEB;\r\n    address TacosAddress = 0x00D1793D7C3aAE506257Ba985b34C76AaF642557;\r\n    address WingAddress = 0xcB3df3108635932D912632ef7132d03EcFC39080;\r\n    // The dydx Solo Margin contract, as can be found here:\r\n    // https://github.com/dydxprotocol/solo/blob/master/migrations/deployed.json\r\n    ISoloMargin private soloMargin = ISoloMargin(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\r\n\r\n    constructor() {\r\n        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\r\n        // Give infinite approval to dydx to withdraw WETH on contract deployment,\r\n        // so we don't have to approve the loan repayment amount (+2 wei) on each call.\r\n        // The approval is used by the dydx contract to pay the loan back to itself.\r\n        IERC20(TendiesAddress).approve(UNISWAP_ROUTER_ADDRESS, uint(-1));\r\n        IERC20(TacosAddress).approve(UNISWAP_ROUTER_ADDRESS, uint(-1));\r\n        IERC20(WingAddress).approve(UNISWAP_ROUTER_ADDRESS, uint(-1));\r\n        WETH.approve(address(soloMargin), uint(-1));\r\n        WETH.approve(UNISWAP_ROUTER_ADDRESS, uint(-1));\r\n    }\r\n    \r\n    function RUN(address Token) internal{\r\n        uint deadline = block.timestamp + 60;\r\n        address[] memory path1 = new address[](2);\r\n        path1[0] = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n        path1[1] = Token;\r\n        uint[] memory swap1Amounts = uniswapRouter.swapExactTokensForTokens(\r\n            WETH.balanceOf(address(this)),\r\n            1, \r\n            path1,\r\n            address(this),\r\n            deadline\r\n        );\r\n        \r\n       if(Token == TendiesAddress){\r\n           _TendiesContract = TendiesContract(TendiesAddress);\r\n           _TendiesContract.grillPool(); // :D\r\n       }\r\n       else if (Token == TacosAddress){\r\n           _TacosContract = TacosContract(TacosAddress);\r\n           _TacosContract.crunchPool(); // :D\r\n       }\r\n       else if (Token == WingAddress){\r\n           _WingContract = WingContract(WingAddress);\r\n           _WingContract.bakePool(); // :D\r\n       }\r\n        \r\n        \r\n        address[] memory path2 = new address[](2);\r\n        path2[0] = Token;\r\n        path2[1] = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n        uint[] memory swap2Amounts = uniswapRouter.swapExactTokensForTokens(\r\n            IERC20(Token).balanceOf(address(this)),\r\n            1, \r\n            path2,\r\n            address(this),\r\n            deadline\r\n        );\r\n        \r\n        \r\n    }\r\n    // This is the function we call\r\n    function flashLoan(uint loanAmount,address Token) external {\r\n        /*\r\n        The flash loan functionality in dydx is predicated by their \"operate\" function,\r\n        which takes a list of operations to execute, and defers validating the state of\r\n        things until it's done executing them.\r\n        \r\n        We thus create three operations, a Withdraw (which loans us the funds), a Call\r\n        (which invokes the callFunction method on this contract), and a Deposit (which\r\n        repays the loan, plus the 2 wei fee), and pass them all to \"operate\".\r\n        \r\n        Note that the Deposit operation will invoke the transferFrom to pay the loan \r\n        (or whatever amount it was initialised with) back to itself, there is no need\r\n        to pay it back explicitly.\r\n        \r\n        The loan must be given as an ERC-20 token, so WETH is used instead of ETH. Other\r\n        currencies (DAI, USDC) are also available, their index can be looked up by\r\n        calling getMarketTokenAddress on the solo margin contract, and set as the \r\n        primaryMarketId in the Withdraw and Deposit definitions.\r\n        */\r\n        \r\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\r\n\r\n        operations[0] = Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Withdraw,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: false,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: loanAmount // Amount to borrow\r\n            }),\r\n            primaryMarketId: 0, // WETH\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n        \r\n        operations[1] = Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Call,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: 0\r\n                }),\r\n                primaryMarketId: 0,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: abi.encode(\r\n                    // Replace or add any additional variables that you want\r\n                    // to be available to the receiver function\r\n                    msg.sender,\r\n                    loanAmount,\r\n                    Token\r\n                )\r\n            });\r\n        \r\n        operations[2] = Actions.ActionArgs({\r\n            actionType: Actions.ActionType.Deposit,\r\n            accountId: 0,\r\n            amount: Types.AssetAmount({\r\n                sign: true,\r\n                denomination: Types.AssetDenomination.Wei,\r\n                ref: Types.AssetReference.Delta,\r\n                value: loanAmount + 2 // Repayment amount with 2 wei fee\r\n            }),\r\n            primaryMarketId: 0, // WETH\r\n            secondaryMarketId: 0,\r\n            otherAddress: address(this),\r\n            otherAccountId: 0,\r\n            data: \"\"\r\n        });\r\n\r\n        Account.Info[] memory accountInfos = new Account.Info[](1);\r\n        accountInfos[0] = Account.Info({owner: address(this), number: 1});\r\n\r\n        soloMargin.operate(accountInfos, operations);\r\n    }\r\n    \r\n    // This is the function called by dydx after giving us the loan\r\n    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) external override {\r\n        // Decode the passed variables from the data object\r\n        (\r\n            // This must match the variables defined in the Call object above\r\n            address payable actualSender,\r\n            uint loanAmount,\r\n            address Token\r\n        ) = abi.decode(data, (\r\n            address, uint,address\r\n        ));\r\n        \r\n        // We now have a WETH balance of loanAmount. The logic for what we\r\n        // want to do with it goes here. The code below is just there in case\r\n        // it's useful.\r\n        RUN(Token);\r\n        // It can be useful for debugging to have a verbose error message when\r\n        // the loan can't be paid, since dydx doesn't provide one\r\n        require(WETH.balanceOf(address(this)) > loanAmount + 2, \"CANNOT REPAY LOAN\");\r\n        // Leave just enough WETH to pay back the loan, and convert the rest to ETH\r\n        WETH.withdraw(WETH.balanceOf(address(this)) - loanAmount - 2);\r\n        // Send any profit in ETH to the account that invoked this transaction\r\n        actualSender.transfer(address(this).balance);\r\n    }\r\n    receive() external payable {}\r\n}"
    },
    "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    }
  }
}