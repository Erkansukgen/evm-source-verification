{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Gator.sol": {
      "content": "pragma solidity 0.4.24;\n\n// import \"./SafeMath.sol\";\n// import \"./Ownable.sol\";\n// import \"./ERC20Detailed.sol\";\n\n// import \"./SafeMathInt.sol\";\n\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\ncontract Context {\n    function _msgSender() internal constant returns (address ) {\n        return msg.sender;\n    }\n\n    function _msgData() internal constant returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    constructor () public {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        \n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public constant returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) << 255;\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\n\n    function mul(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 c = a * b;\n\n        // Detect overflow when multiplying MIN_INT256 with -1\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    function div(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        // Prevent overflow when dividing MIN_INT256 by -1\n        require(b != -1 || a != MIN_INT256);\n\n        // Solidity already throws when dividing by 0.\n        return a / b;\n    }\n\n    function sub(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n        return c;\n    }\n\n    function add(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    function abs(int256 a)\n        internal\n        pure\n        returns (int256)\n    {\n        require(a != MIN_INT256);\n        return a < 0 ? -a : a;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(from != address(0));\n        require(to != address(0));\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0));\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0), \"invalid to address\");\n        require(from != address(0), \"invalid from address\");\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    function _burnFrom(address account, uint256 value) internal {\n        require(account != address(0));\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n        _burn(account, value);\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\n    }\n}\n\ncontract ERC20Detailed is ERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    \n    constructor(string name, string symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string) {\n        return _name;\n    }\n\n    function symbol() public view returns (string) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\ncontract GatorToken is ERC20Detailed {\n\n    using SafeMath for uint256;\n    using SafeMathInt for int256;\n    address private _owner;\n\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\n    event LogMonetaryPolicyUpdated(address monetaryPolicy);\n\n    // Used for authentication\n    address public monetaryPolicy;\n\n    modifier onlyMonetaryPolicy() {\n        require(msg.sender == monetaryPolicy);\n        _;\n    }\n\n    modifier validRecipient(address to) {\n        require(to != address(0));\n        require(to != address(this));\n        _;\n    }\n\n    uint256 public constant DECIMALS = 18;\n    uint256 private constant MAX_UINT256 = ~uint256(0);\n    \n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 350000*10**DECIMALS;\n\n    // uint256 private constant MAX_SUPPLY = 300000*10**DECIMALS;  // (2^128) - 1\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\n    uint256 private _totalSupply;\n    uint256 private _gonsPerFragment;\n    mapping(address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowedFragments;\n\n    function owner() public constant returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    function renounceOwnership() public onlyOwner {\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _owner = newOwner;\n    }\n\n    function setMonetaryPolicy(address monetaryPolicy_)\n        external\n        onlyOwner\n    {\n        require(monetaryPolicy_ != address(0), \"empty monetaryPolicy address\");\n        \n        monetaryPolicy = monetaryPolicy_;\n        emit LogMonetaryPolicyUpdated(monetaryPolicy_);\n    }\n\n    function rebase(uint256 epoch, int256 supplyDelta)\n        external\n        onlyMonetaryPolicy\n        returns (uint256)\n    {   \n\n        if (supplyDelta == 0) {\n            emit LogRebase(epoch, _totalSupply);\n            return _totalSupply;\n        }\n        uint256 _supplyDelta = uint256(supplyDelta);\n\n        _totalSupply = _totalSupply.div(_gonsPerFragment);\n\n        if (supplyDelta >= 0) {\n            _totalSupply = _totalSupply.add(_supplyDelta);\n        }\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n\n        _totalSupply = _totalSupply.mul(_gonsPerFragment);\n\n        emit LogRebase(epoch, _totalSupply);\n        return _totalSupply;\n    }\n\n    constructor() ERC20Detailed(\"GATOR\", \"GATR\", uint8(DECIMALS))\n        public\n    {\n        _owner = msg.sender;\n        \n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY.mul(_gonsPerFragment);\n        _balances[_owner] = INITIAL_FRAGMENTS_SUPPLY.mul(_gonsPerFragment);\n\n        emit Transfer(address(0), _owner, _totalSupply);\n    }\n\n    function totalSupply()\n        public\n        view\n        returns (uint256)\n    {\n        return _totalSupply.div(_gonsPerFragment);\n    }\n\n    function balanceOf(address who)\n        public\n        view\n        returns (uint256)\n    {\n        return _balances[who].div(_gonsPerFragment);\n    }\n\n    function transfer(address to, uint256 value)\n        public\n        validRecipient(to)\n        returns (bool)\n    {\n        require(to != address(0));\n        uint256 gonValue = value.mul(_gonsPerFragment);\n        _balances[msg.sender] = _balances[msg.sender].sub(gonValue);\n        _balances[to] = _balances[to].add(gonValue);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner_, address spender)\n        public\n        view\n        returns (uint256)\n    {\n        return _allowedFragments[owner_][spender];\n    }\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        validRecipient(to)\n        returns (bool)\n    {\n        require(from != address(0));\n        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\n\n        uint256 gonValue = value.mul(_gonsPerFragment);\n        _balances[from] = _balances[from].sub(gonValue);\n        _balances[to] = _balances[to].add(gonValue);\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 value)\n        public\n        returns (bool)\n    {\n        require(spender != address(0));\n        _allowedFragments[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        returns (bool)\n    {\n        require(spender != address(0));\n        _allowedFragments[msg.sender][spender] =\n            _allowedFragments[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        returns (bool)\n    {\n        require(spender != address(0));\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\n        if (subtractedValue >= oldValue) {\n            _allowedFragments[msg.sender][spender] = 0;\n        } else {\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\n        }\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n        return true;\n    }\n    \n    /*\n    function mint(address account, uint256 amount)\n    public\n    onlyOwner\n    {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        amount = amount.mul(10**DECIMALS);\n        _totalSupply = _totalSupply.div(_gonsPerFragment);\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].div(_gonsPerFragment);\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\n\n        _totalSupply = _totalSupply.mul(_gonsPerFragment);\n\n        _balances[account] = _balances[account].add(amount);\n        _balances[account] = _balances[account].mul(_gonsPerFragment);\n\n        emit Transfer(address(0), account, amount);\n    }\n    */\n}"
    }
  }
}