{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        return _values(set._inner);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"
    },
    "contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\n\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.0.0/contracts/token/ERC20/IERC20.sol\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"
    },
    "contracts/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../contracts/IUniswapV3SwapCallback.sol\";\r\n\r\ninterface ISwapRouter is IUniswapV3SwapCallback {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n}"
    },
    "contracts/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}"
    },
    "contracts/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.2;\r\n\r\nimport '../contracts/IUniswapV2Router01.sol';\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"
    },
    "contracts/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/// @title Callback for IUniswapV3PoolActions#swap\r\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\r\ninterface IUniswapV3SwapCallback {\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external;\r\n}"
    },
    "contracts/MoneyPrinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../contracts/IUniswapV2Router02.sol\";\r\nimport \"../contracts/ISwapRouter.sol\";\r\nimport \"../contracts/IERC20.sol\";\r\nimport \"../contracts/EnumerableSet.sol\";\r\n\r\ncontract ArbBot {\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n  \r\n  address internal constant UNISWAP_V2_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n  address internal constant UNISWAP_V3_SWAP_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\r\n  address internal constant SUSHISWAP_ROUTER_ADDRESS = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\r\n  address payable owner;\r\n  \r\n  IUniswapV2Router02 public uniswapV2Router;\r\n  IUniswapV2Router02 public sushiswapRouter;\r\n  ISwapRouter public uniswapV3Router;\r\n\r\n    //APPROVED TOKENS ACROSS EXCHANGES\r\n    EnumerableSet.AddressSet uniV2Approved;\r\n    EnumerableSet.AddressSet uniV3Approved;\r\n    EnumerableSet.AddressSet sushiApproved;\r\n\r\n    event uniV2TokenAdded(address indexed token);\r\n    event uniV3TokenAdded(address indexed token);\r\n    event sushiTokenAdded(address indexed token);\r\n    \r\n    \r\n    constructor() {\r\n        uniswapV2Router = IUniswapV2Router02(UNISWAP_V2_ROUTER_ADDRESS);\r\n        uniswapV3Router = ISwapRouter(UNISWAP_V3_SWAP_ROUTER);\r\n        sushiswapRouter = IUniswapV2Router02(SUSHISWAP_ROUTER_ADDRESS);\r\n        owner = payable(msg.sender);\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function addUniV2Token(address token) internal {\r\n        uniV2Approved.add(token);\r\n        emit uniV2TokenAdded(token);\r\n    }    \r\n    \r\n      function addUniV3Token(address token) internal {\r\n        uniV3Approved.add(token);\r\n        emit uniV3TokenAdded(token);\r\n    }    \r\n    \r\n      function addSushiToken(address token) internal {\r\n        sushiApproved.add(token);\r\n        emit sushiTokenAdded(token);\r\n    }  \r\n    \r\n    function approveTokenUniV2(address token) internal {\r\n        IERC20 erc20 = IERC20(token);\r\n        erc20.approve(UNISWAP_V2_ROUTER_ADDRESS,  2**256 - 1);\r\n        addUniV2Token(token);\r\n    }\r\n    \r\n    function approveTokenUniV3(address token) internal {\r\n        IERC20 erc20 = IERC20(token);\r\n        erc20.approve(UNISWAP_V3_SWAP_ROUTER, 2**256 - 1); \r\n        addUniV3Token(token);\r\n    }\r\n    \r\n    function approveTokenSushi(address token) internal {\r\n        IERC20 erc20 = IERC20(token);\r\n        erc20.approve(SUSHISWAP_ROUTER_ADDRESS,  2**256 - 1);\r\n        addSushiToken(token);\r\n    }\r\n    \r\n    function uniV2ApprovedContains(address token) public view returns (bool) {\r\n        return uniV2Approved.contains(token);\r\n    }\r\n    \r\n    function uniV3ApprovedContains(address token) public view returns (bool) {\r\n        return uniV3Approved.contains(token);\r\n    }\r\n    \r\n    function sushiApprovedContains(address token) public view returns (bool) {\r\n        return sushiApproved.contains(token);\r\n    }\r\n\r\n    // RETURN LIST EXTERNALLY OF APPROVED TOKENS\r\n    function getUniV2ApprovedTokens() external view returns (address[] memory tokens) {\r\n        uint256 length = uniV2Approved.length();\r\n        tokens = new address[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tokens[i] = uniV2Approved.at(i);\r\n        }\r\n    }\r\n    \r\n    function getUniV3ApprovedTokens() external view returns (address[] memory tokens) {\r\n        uint256 length = uniV3Approved.length();\r\n        tokens = new address[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tokens[i] = uniV3Approved.at(i);\r\n        }\r\n    }    \r\n    \r\n    function getSushiApprovedTokens() external view returns (address[] memory tokens) {\r\n        uint256 length = sushiApproved.length();\r\n        tokens = new address[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            tokens[i] = sushiApproved.at(i);\r\n        }\r\n    }\r\n    \r\n  //Uni -> Sushiswap\r\n  function UniV2_to_Sushi_Arb(\r\n      uint256 _uniIn, \r\n      uint256 _uniOut, \r\n      address _uniTokenIn, \r\n      address _uniTokenOut, \r\n      address[] calldata _pathIn, \r\n      address[] calldata _pathOut, \r\n      uint _deadline\r\n      ) public payable{\r\n    \r\n    require(msg.sender == owner);\r\n    IERC20(_uniTokenIn).transferFrom(msg.sender, address(this), _uniIn);\r\n    \r\n  \r\n    if(!uniV2ApprovedContains(_uniTokenIn)){\r\n    approveTokenUniV2(_uniTokenIn);    \r\n    }\r\n    \r\n    //Leg one of TX UNI WETH Sell -> UNI Buy Token\r\n    uniswapV2Router.swapExactTokensForTokens(_uniIn, _uniOut, _pathIn, address(this), _deadline);\r\n\r\n    //Intermediate Logic, confirm amount of tokens received, approve next exchange to sell\r\n    uint256 sushiIn = IERC20(_uniTokenOut).balanceOf(address(this));\r\n    \r\n    if(!sushiApprovedContains(_uniTokenOut)){\r\n    approveTokenSushi(_uniTokenOut);   \r\n    }\r\n     \r\n    uint256 sushiOut = sushiswapRouter.getAmountsOut(sushiIn, _pathOut)[1];\r\n    sushiswapRouter.swapExactTokensForTokens(sushiIn, sushiOut, _pathOut, msg.sender, _deadline);\r\n  }\r\n  \r\n //Sushiswap -> Uni\r\n  function Sushi_to_Univ2_Arb(\r\n      uint256 _sushiIn, \r\n      uint256 _sushiOut, \r\n      address _sushiTokenIn, \r\n      address _sushiTokenOut, \r\n      address[] calldata _pathIn, \r\n      address[] calldata _pathOut, \r\n      uint _deadline\r\n      ) public payable{\r\n    \r\n    require(msg.sender == owner);\r\n    IERC20( _sushiTokenIn).transferFrom(msg.sender, address(this), _sushiIn);\r\n    \r\n    \r\n    if(!sushiApprovedContains(_sushiTokenIn)){\r\n    approveTokenSushi(_sushiTokenIn);    \r\n    //IERC20(_sushiTokenIn).approve(address(SUSHISWAP_ROUTER_ADDRESS), 2**256 - 1);\r\n    }\r\n    \r\n    //Leg one of TX UNI WETH Sell -> UNI Buy Token\r\n    sushiswapRouter.swapExactTokensForTokens(_sushiIn, _sushiOut, _pathIn, address(this), _deadline);\r\n\r\n    //Intermediate Logic, confirm amount of tokens received, approve next exchange to sell\r\n    uint256 uniIn = IERC20(_sushiTokenOut).balanceOf(address(this));\r\n    \r\n    if(!uniV2ApprovedContains(_sushiTokenOut)){\r\n    approveTokenUniV2(_sushiTokenOut);    \r\n    }\r\n     \r\n    uint256 uniOut = uniswapV2Router.getAmountsOut(uniIn, _pathOut)[1];\r\n    uniswapV2Router.swapExactTokensForTokens(uniIn, uniOut, _pathOut, msg.sender, _deadline);\r\n    }\r\n    \r\n     //UniV3 Fee Pool -> UniV3 Fee Pool (interexchange)\r\n    function UniV3_to_UniV3_Arb(\r\n        address _tokenIn,\r\n        bytes memory _path,\r\n        uint256 _deadline,\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMinimum\r\n        ) public payable{\r\n    \r\n    require(msg.sender == owner);\r\n    IERC20(_tokenIn).transferFrom(msg.sender, address(this), _amountIn);\r\n    \r\n    if(!uniV3ApprovedContains(_tokenIn)){\r\n    approveTokenUniV3(_tokenIn);  \r\n    }\r\n    \r\n    \r\n    uniswapV3Router.exactInput(\r\n      ISwapRouter.ExactInputParams({\r\n        path: _path,\r\n        recipient: msg.sender,\r\n        deadline: _deadline,\r\n        amountIn: _amountIn,\r\n        amountOutMinimum: _amountOutMinimum\r\n      })\r\n    );\r\n  }\r\n    receive() payable external {}\r\n}"
    }
  }
}