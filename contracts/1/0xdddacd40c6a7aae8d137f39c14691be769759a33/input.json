{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/BrandContest.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract BrandContest {\n\n    //The allowed Votes that can be transfered\n    mapping(uint256 => uint256) private _allowedVotingAmounts;\n\n    //Keeps track of the current ERC721 Token addresses allowed for this votation (ARTE/ETRA)\n    mapping(address => bool) private _allowedTokenAddresses;\n\n    //Takes notes of how many votes received for any token id, for both Tokens (ARTE/ETRA)\n    mapping(address => mapping(uint256 => uint256)) private _votes;\n\n    //Takes notes of how many ethers received for any token id, for both Tokens (ARTE/ETRA)\n    mapping(address => mapping(uint256 => uint256)) private _ethers;\n\n    //Il blocco di fine della votazione\n    uint256 private _surveyEndBlock;\n\n    //Event raised only the first time this NFT receives a vote\n    event FirstVote(address indexed tokenAddress, uint256 indexed tokenId);\n\n    //Event raised when someone votes for a specific NFT\n    event Vote(address indexed voter, address indexed tokenAddress, uint256 indexed tokenId, uint256 votes, uint256 amount);\n\n    //To let this Smart Contract work, you need to pass the ERC721 token addresses supported by this survey (ARTE/ETRA).\n    constructor(address[] memory allowedTokenAddresses, uint256 surveyEndBlock) public {\n        for(uint256 i = 0; i < allowedTokenAddresses.length; i++) {\n            _allowedTokenAddresses[allowedTokenAddresses[i]] = true;\n        }\n        _surveyEndBlock = surveyEndBlock;\n        _allowedVotingAmounts[4000000000000000] = 1;\n        _allowedVotingAmounts[30000000000000000] = 5;\n        _allowedVotingAmounts[100000000000000000] = 10;\n        _allowedVotingAmounts[300000000000000000] = 20;\n    }\n\n    //The concrete vote operation:\n    //You vote sending some ether to this call, specifing the ERC721 location and id you want to vote.\n    //The amount of ethers received will be registered as a vote for the chosen NFT and transfered to its owner\n    function vote(address tokenAddress, uint256 tokenId) public payable {\n\n        //Are you still able to vote?\n        require(block.number < _surveyEndBlock, \"Survey ended!\");\n\n        //To vote you must provide some ethers, with a maximum of 3 eth\n        require(_allowedVotingAmounts[msg.value] > 0, \"Vote must be 0.004, 0.03, 0.1 or 0.3 ethers\");\n\n        //You can just vote one of the allowed NFTs (ARTE/ETRA)\n        require(_allowedTokenAddresses[tokenAddress], \"Unallowed Token Address!\");\n\n        //Retrieve the NFT's owner\n        address payable owner = payable(IERC721(tokenAddress).ownerOf(tokenId));\n\n        //Check if tokenId and its owner are valid\n        require(owner != address(0), \"Owner is nobody, maybe wrong tokenId?\");\n\n        //If this is the first time this NFT receives a vote, the FirstVote event will be raised\n        if(_votes[tokenAddress][tokenId] == 0) {\n            emit FirstVote(tokenAddress, tokenId);\n        }\n\n        //Update the votes and ethers amount for this NFT\n        _votes[tokenAddress][tokenId] = _votes[tokenAddress][tokenId] + _allowedVotingAmounts[msg.value];\n        _ethers[tokenAddress][tokenId] = _ethers[tokenAddress][tokenId] + msg.value;\n\n        //Transfer the received ethers to the NFT's owner\n        owner.transfer(msg.value);\n\n        //Raise an event containing voting info, to let everyone grab this info off-chain\n        emit Vote(msg.sender, tokenAddress, tokenId, _allowedVotingAmounts[msg.value], msg.value);\n    }\n\n    //Utility function to let everyone know (both offchain and onchain) the current votes amount for every allowed NFT (ARTE/ETRA)\n    function votesOf(address tokenAddress, uint256 tokenId) public view returns(uint256, uint256) {\n        return (_votes[tokenAddress][tokenId], _ethers[tokenAddress][tokenId]);\n    }\n\n    function getSurveyEndBlock() public view returns(uint256) {\n        return _surveyEndBlock;\n    }\n}\n\ninterface IERC721 {\n    function ownerOf(uint256 _tokenId) external view returns (address);\n}"
    }
  }
}