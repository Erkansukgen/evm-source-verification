{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "cashier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.8.0;\n\n\ncontract owned {\n    address public owner;\n    address public auditor;\n\n    constructor() {\n        owner = msg.sender;\n        auditor = 0x241A280362b4ED2CE8627314FeFa75247fDC286B;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner || msg.sender == auditor);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n// library from openzeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol)\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n// library from openzeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol)\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    \n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\ncontract cashierV1 is owned {\n    using SafeERC20 for IERC20;\n    string public name;\n    bool public online = true;\n    address public bucks;\n    address public blcks;\n    uint256 public period;\n    address public mainWallet = msg.sender;\n    uint256 public APY = 14;\n\n    struct deposits{\n        uint256 amount;\n        bool payed;\n        uint256 date;\n    }\n\n    mapping (address => deposits[]) public investments;\n\n    event SwapToUSDT(address indexed beneficiary, uint256 value);\n    \n    event SwapToBLACKT(address indexed beneficiary, uint256 value);\n \n    event IsOnline(bool status);\n\n    \n    constructor(\n        string memory Name,\n        address initialBucks,\n        address initialBlcks,\n        uint256 initialPeriod\n    ) {           \n        name = Name;                                   \n        bucks = initialBucks;\n        blcks = initialBlcks;\n        period = initialPeriod;\n    }\n\n    \n    function USDtoBLACKT( uint256 value) public returns (bool success) {\n        BLACKT b0 = BLACKT(blcks);\n        IERC20 b1 = IERC20(bucks);\n        require(online);\n        b1.safeTransferFrom(msg.sender,mainWallet,value);\n        b0.transferFrom(mainWallet,msg.sender,value);\n        emit SwapToBLACKT(msg.sender,value);\n        return true;\n    }\n\n    function BLACKTtoUSD(uint256 value) public returns (bool success) {\n        BLACKT b0 = BLACKT(blcks);\n        IERC20 b1 = IERC20(bucks);\n        require(online);\n        b0.transferFrom(msg.sender,mainWallet,value);\n        b1.safeTransferFrom(mainWallet,msg.sender,value);\n        emit SwapToUSDT(msg.sender,value);\n        \n        return true;\n    }\n\n    function AutoInvestUSD(uint256 investment) public returns (bool success) {\n        BLACKT b0 = BLACKT(blcks);\n        IERC20 b1 = IERC20(bucks);\n        require(online);\n        b1.safeTransferFrom(msg.sender,mainWallet,investment);\n        b0.lockLiquidity(msg.sender, investment);   \n        investments[msg.sender].push(deposits(investment,false,block.timestamp));\n        return true;\n    }\n\n    function AutoUnlock() public returns (bool success) {\n        require(online);\n        BLACKT b = BLACKT(blcks);\n        for (uint256 j=0; j < investments[msg.sender].length; j++){\n            if (block.timestamp-investments[msg.sender][j].date>period && !investments[msg.sender][j].payed) {\n                if (b.unlockLiquidity(msg.sender, investments[msg.sender][j].amount)) {\n                    b.transferFrom(mainWallet,msg.sender,investments[msg.sender][j].amount*APY/100);\n                    investments[msg.sender][j].payed = true;\n                }\n            }\n        }\n        return true;\n    }\n\n    function zChangeAPY(uint256 newAPY) onlyOwner public returns (bool success) {\n        APY = newAPY;\n        return true;\n    }\n\n    function zChangePeriod(uint256 newPeriod) onlyOwner public returns (bool success) {\n        period = newPeriod;\n        return true;\n    }\n\n    function zChangeBucks(address newBucks) onlyOwner public returns (bool success) {\n        bucks = newBucks;\n        return true;\n    }\n\n    function zChangeBlcks(address newBlcks) onlyOwner public returns (bool success) {\n        blcks = newBlcks;\n        return true;\n    }\n\n    function zChangeOnlineState(bool state) onlyOwner public returns (bool success) {\n        online = state;\n        return true;\n    }\n\n    function zChangeMainWallet(address newWallet) onlyOwner public returns (bool success) {\n        mainWallet = newWallet;\n        return true;\n    }\n}\n\ninterface BLACKT {\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function lockLiquidity(address _beneficiary, uint256 _value) external returns (bool);\n    function unlockLiquidity(address _beneficiary, uint _value) external returns (bool);\n}\n\ninterface IERC20 {\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}"
    }
  }
}