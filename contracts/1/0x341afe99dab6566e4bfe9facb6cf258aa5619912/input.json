{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/StakingDatabase.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity 0.8.0;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\nstruct DemandFactor {\nuint value;\nuint timestamp;\n}\n\nstruct Stake {\nuint amount;\nuint createdOn;\nuint lastUpdatedOn;\nuint lastStakingAccumulatedWeight;\nuint totalUnclaimed;\nuint lastDemandFactor;\n}\n\nstruct Pool {\nuint currentAccumulatedWeight;\nuint totalStaked;\nuint lastUpdatedOn;\nuint lastDemandFactor;\nuint currentPoolWeight;\n}\n\ncontract StakingDatabase is Ownable{\n\nmapping(address => bool) public whitelists; // The accounts which can access this database\n\nmodifier onlyWhitelist() {\nrequire(whitelists[msg.sender], \"Not authoriused to access the database\");\n_;\n}\n\nmapping(address => Stake) public userStakes;\n\naddress[] stakers;\n\nDemandFactor[] public demandFactorHistory;\nPool private pool;\n\nuint MAX_DAFI; // The maximum DAFI allotment for reward distribution\nuint dDAFIBurned; // dDAFI already claimed by users\nuint feesDeposited;\nuint8 REWARD_FEE;\nuint minimumStakeAmount;\nuint minimumStakePeriod;\nuint stakingStartTime;\nuint programDuration;\nuint dDAFIDistributed; // It will hold the most recent value of dDAFI distributed\nuint distributePerSecond; // It will hold the most recent value of dDAFI to be distributed per second\nbool programEnded;\nuint programEndedAt;\n\nfunction setStakingParams(uint _minimumStakeDays, uint _minimumStakeAmount, uint _maxDAFI, uint8 _rewardFee, uint durationInDays) external onlyWhitelist {\nsetMinimumStakePeriod(_minimumStakeDays * 1 days);\nsetStakingStartTime();\nsetMinimumStakeAmount(_minimumStakeAmount);\nsetMaxDAFI(_maxDAFI);\nsetRewardFee(_rewardFee);\nsetProgramDuration(durationInDays * 1 days);\n}\n\nfunction markProgramEnded() external onlyWhitelist {\nprogramEnded = true;\nprogramEndedAt = block.timestamp;\n}\n\nfunction getProgramEndedAt() external view returns(uint) {\nreturn programEndedAt;\n}\n\nfunction isProgramEnded() external view onlyWhitelist returns(bool) {\nreturn programEnded;\n}\n\nfunction addDemandFactor(uint _value, uint _timestamp) external onlyWhitelist {\nDemandFactor memory df = DemandFactor(_value, _timestamp);\ndemandFactorHistory.push(df);\n}\n\nfunction addAccumulatedPoolWeight(uint _currentWeight) external onlyWhitelist {\npool.currentAccumulatedWeight = pool.currentAccumulatedWeight + _currentWeight;\npool.lastDemandFactor = getDemandFactorLastest().value;\npool.lastUpdatedOn = block.timestamp;\npool.currentPoolWeight = _currentWeight;\n}\n\nfunction getAccumulatedPoolWeight() external view onlyWhitelist returns (uint){\nreturn pool.currentAccumulatedWeight;\n}\n\nfunction getPoolLastUpdatedOn() external view onlyWhitelist returns (uint){\nreturn pool.lastUpdatedOn;\n}\n\nfunction setdDAFIDistributed(uint _distributed) external onlyWhitelist {\ndDAFIDistributed = _distributed;\n}\n\nfunction getdDAFIDistributed() external view returns(uint){\nreturn dDAFIDistributed;\n}\n\nfunction setDistributePerSecond(uint _distributePerSec) external onlyWhitelist {\ndistributePerSecond = _distributePerSec;\n}\n\nfunction getDistributePerSecond() external view returns (uint) {\nreturn distributePerSecond;\n}\n\nfunction addStake(address user, uint amount) external onlyWhitelist {\nStake storage stake = userStakes[user];\n\nif(stake.createdOn == 0) {\nstake.createdOn = block.timestamp;\nstakers.push(user);\n}\n\nstake.amount += amount;\n}\n\nfunction updateUserStake(address user, uint newReward, uint lastDemandFactor, uint currentAccumulatedWeight) external onlyWhitelist {\nStake storage stake = userStakes[user];\nstake.lastStakingAccumulatedWeight = currentAccumulatedWeight;\nstake.lastDemandFactor = lastDemandFactor;\nstake.totalUnclaimed += newReward;\nstake.lastUpdatedOn = block.timestamp;\n}\n\nfunction updateStakeAmount(address user, uint amount) external onlyWhitelist{\nStake storage stake = userStakes[user];\nstake.amount = amount;\n}\n\nfunction addPoolTotalStaked(uint amountToAdd) external onlyWhitelist{\npool.totalStaked = pool.totalStaked + amountToAdd;\n}\n\nfunction subPoolTotalStaked(uint amountToSub) external onlyWhitelist{\npool.totalStaked = pool.totalStaked - amountToSub;\n}\n\nfunction getPool() external view returns (Pool memory) {\nreturn pool;\n}\n\nfunction getUserStake(address user) external view returns(Stake memory){\nreturn userStakes[user];\n}\n\nfunction markRewardsClaimed(address user, uint rewardsBeingClaimed) external onlyWhitelist {\nStake storage stake = userStakes[user];\nstake.totalUnclaimed = stake.totalUnclaimed - rewardsBeingClaimed;\nstake.lastStakingAccumulatedWeight = pool.currentAccumulatedWeight;\n}\n\nfunction getDemandFactor(uint index) external view onlyWhitelist returns(DemandFactor memory) {\nreturn demandFactorHistory[index];\n}\n\nfunction setMaxDAFI(uint amount) public onlyWhitelist{\nMAX_DAFI = amount;\n}\n\nfunction getMaxDAFI() external view returns(uint){\nreturn MAX_DAFI;\n}\n\nfunction addTodDAFIBurned(uint amount) external onlyWhitelist {\ndDAFIBurned = dDAFIBurned + amount;\n}\n\nfunction getdDAFIBurned() external view returns(uint) {\nreturn dDAFIBurned;\n}\n\nfunction addToFeesDeposited(uint amount) external onlyWhitelist {\nfeesDeposited = feesDeposited + amount;\n}\n\nfunction getFeesDeposited() external view returns(uint) {\nreturn feesDeposited;\n}\n\nfunction setRewardFee(uint8 percentage) public onlyWhitelist {\nREWARD_FEE = percentage;\n}\n\nfunction getRewardFee() external view returns(uint8) {\nreturn REWARD_FEE;\n}\n\nfunction getDemandFactorLastest() public view returns(DemandFactor memory){\nreturn demandFactorHistory[demandFactorHistory.length -1];\n}\n\nfunction getUserCount() external view returns(uint) {\nreturn stakers.length;\n}\n\nfunction totalStakedFor(address addr) external view returns (uint256) {\nreturn userStakes[addr].amount;\n}\n\nfunction getTotalStaked() external view returns(uint) {\nreturn pool.totalStaked;\n}\n\nfunction addWhitelist(address account) external onlyOwner {\nrequire(account != address(0));\nwhitelists[account] = true;\n}\n\nfunction getMinimumStakeAmount() external view returns(uint) {\nreturn minimumStakeAmount;\n}\n\nfunction setMinimumStakeAmount(uint _minimumStakeAmount) onlyWhitelist public {\nminimumStakeAmount = _minimumStakeAmount;\n}\n\nfunction getMinimumStakePeriod() external view returns(uint) {\nreturn minimumStakePeriod;\n}\n\nfunction setMinimumStakePeriod(uint _minimumStakePeriod) onlyWhitelist public {\nminimumStakePeriod = _minimumStakePeriod;\n}\n\nfunction userExists(address user) external view returns(bool) {\nreturn userStakes[user].createdOn > 0 ? true : false;\n}\n\nfunction setStakingStartTime() public onlyWhitelist{\nstakingStartTime = block.timestamp;\n}\n\nfunction getStakingStartTime() external view returns(uint){\nreturn stakingStartTime;\n}\n\nfunction setProgramDuration(uint _duration) public onlyWhitelist{\nprogramDuration = _duration;\n}\n\nfunction getProgramDuration() external view returns (uint) {\nreturn programDuration;\n}\n\nfunction removeWhitelist(address account) external onlyOwner {\nrequire(account != address(0));\nrequire(whitelists[account], \"Account doesnt exist in whitelist\");\nwhitelists[account] = false;\n}\n}"
    },
    "contracts/interfaces/INetworkDemand.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity 0.8.0;\n\ninterface INetworkDemand {\n\n    function calculateNetworkDemand() external view returns (uint);\n}"
    },
    "contracts/interfaces/IRebaseEngine.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity 0.8.0;\n\ninterface IRebaseEngine {\n    function rebase(address user) external;\n    function rebasePool() external;\n}"
    },
    "contracts/rebase engine/RebaseEngine.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity 0.8.0;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"../interfaces/IRebaseEngine.sol\";\nimport \"../interfaces/INetworkDemand.sol\";\nimport \"../StakingDatabase.sol\";\n\ncontract RebaseEngine is IRebaseEngine, Ownable {\n\n    INetworkDemand public networkDemand;\n    StakingDatabase public database;\n\n    uint constant EIGHT_DECIMALS = 100000000;\n    bool INITIALIZED;\n\n    mapping(address => bool) public whitelists; // The accounts which can access this Rebase Engine\n\n    modifier onlyWhitelist() {\n        require(whitelists[msg.sender], \"Not authoriused to access the rebase engine\");\n        _;\n    }\n\n    function initialize(INetworkDemand _networkDemand, StakingDatabase _database) external onlyOwner{\n        require(!INITIALIZED, \"Rebase Engine already initialized\");\n        networkDemand = _networkDemand;\n        database = _database;\n        INITIALIZED = true;\n    }\n\n    function updateNetworkDemand(INetworkDemand _networkDemand) external onlyWhitelist{\n        networkDemand = _networkDemand;\n    }\n\n    function updateDatabase(StakingDatabase _database) external onlyWhitelist{\n        database = _database;\n    }\n\n    /*\n   * This method rebases the pool as well as the user's stake\n   */\n    function rebase(address user) external override onlyWhitelist {\n        _rebasePool();\n        _rebaseStake(user);\n    }\n\n    function rebasePool() external override onlyWhitelist {\n        _rebasePool();\n    }\n\n    /*\n    * This method calculates pool weight from the last time it got updated to the current time\n    */\n    function _rebasePool() internal {\n\n        Pool memory pool = database.getPool();\n        uint maxTimestampForCalc;\n\n        if(database.isProgramEnded() && pool.lastUpdatedOn > database.getProgramEndedAt()){\n            return;\n        } else if(database.isProgramEnded() && pool.lastUpdatedOn < database.getProgramEndedAt()) {\n            maxTimestampForCalc = database.getProgramEndedAt();\n        }else{\n            maxTimestampForCalc = block.timestamp;\n        }\n\n        uint demandFactorNew = networkDemand.calculateNetworkDemand();\n\n        database.addDemandFactor(demandFactorNew, maxTimestampForCalc);\n\n        uint MAX_DAFI = database.getMaxDAFI();\n\n        // It calcultes the rewards already distributed(claimed + unclaimed) since the start of staking program\n        uint dDAFIDistributed = (MAX_DAFI * (maxTimestampForCalc - database.getStakingStartTime())) / database.getProgramDuration();\n\n        database.setdDAFIDistributed(dDAFIDistributed);\n\n        //Neutralizing the demand factor which was multiplied to fees deposited while calculating the rewards\n        uint feesDeposited = database.getFeesDeposited() == 0 || pool.lastDemandFactor == 0 ? 0\n        : (database.getFeesDeposited() * EIGHT_DECIMALS) / pool.lastDemandFactor;\n\n        uint poolCurrent = ((MAX_DAFI - dDAFIDistributed + feesDeposited) * demandFactorNew);\n\n        uint distributePerSecond = poolCurrent / database.getProgramDuration();\n\n        database.setDistributePerSecond(distributePerSecond);\n\n        uint elapsedTime = pool.lastUpdatedOn == 0 ? 0 : maxTimestampForCalc - pool.lastUpdatedOn;\n\n        uint totalStaked = database.getTotalStaked();\n\n        uint currentPoolWeight = totalStaked > 0 ? (distributePerSecond * elapsedTime)/ totalStaked : 0;\n\n        database.addAccumulatedPoolWeight(currentPoolWeight);\n    }\n\n    /*\n    * This method calculates the user reward generated till now based on current accumulated pool weight and user staked amount\n    */\n    function _rebaseStake(address user) internal {\n\n        Stake memory stake = database.getUserStake(user);\n\n        uint currentAccumulatedWeight = database.getAccumulatedPoolWeight();\n        uint lastAccumulatedWeight = stake.lastStakingAccumulatedWeight;\n\n        uint256 distributedAmount = ((currentAccumulatedWeight - lastAccumulatedWeight) * (stake.amount)) / EIGHT_DECIMALS;\n\n        database.updateUserStake(user, distributedAmount, database.getDemandFactorLastest().value, currentAccumulatedWeight);\n    }\n\n    function addWhitelist(address account) external onlyOwner {\n        require(account != address(0));\n        whitelists[account] = true;\n    }\n\n    function removeWhitelist(address account) external onlyOwner {\n        require(account != address(0));\n        require(whitelists[account], \"Account doesnt exist in whitelist\");\n        whitelists[account] = false;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  }
}