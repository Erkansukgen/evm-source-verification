{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"teststs.sol":{"content":"interface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint256);\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IQuoter {\r\n    function getQuote(address who, address token) external returns (Structs.QuoteData memory);\r\n}\r\n\r\nlibrary Structs {\r\n    struct QuoteData {\r\n        TokenInfo base;\r\n        TokenInfo token;\r\n        address pairAddress;\r\n        address routerAddress;\r\n        address factoryAddress;\r\n        uint256 tokenBalance; // token balance of the user\r\n        uint256 quote; // value of the user's token balance in usd according to the pair price\r\n        uint256 nativeReserves; // balance of base token in the pair\r\n    }\r\n\r\n    struct TokenInfo {\r\n        string name;\r\n        string symbol;\r\n        uint256 decimals;\r\n        address addr;\r\n    }\r\n}\r\n\r\ncontract DataAggregator {\r\n    address UNI_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address UNI_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n    address ETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n    address DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\r\n    \r\n    // returns pair address if exists, and quote in $ of the token accoridng to the price.\r\n    function getQuote(address who, address token, address base) public view returns (Structs.QuoteData memory){\r\n        uint256 amountIn = 0;\r\n        try IERC20(token).balanceOf(who) returns (uint256 aIn) {\r\n            amountIn = aIn;\r\n        } catch {}\r\n\r\n        IPancakeRouter01 router = IPancakeRouter01(UNI_V2_ROUTER);\r\n        address pair = IPancakeFactory(UNI_V2_FACTORY).getPair(token, base);\r\n\r\n        Structs.QuoteData memory q;\r\n        q.routerAddress = UNI_V2_ROUTER;\r\n        q.factoryAddress = UNI_V2_FACTORY;\r\n        q.pairAddress = pair;\r\n        q.nativeReserves = IERC20(base).balanceOf(pair);\r\n        q.tokenBalance = amountIn;\r\n\r\n        if (base != USDC && base != DAI && base != USDT) {\r\n            // base is not a stable coin so compute [token, base, usdt]\r\n            address[] memory path = new address[](3);\r\n            path[0] = (token);\r\n            path[1] = (base);\r\n            path[2] = (USDT);\r\n\r\n            try router.getAmountsOut(amountIn, path) returns (uint256[] memory amounts){\r\n                q.quote = amounts[path.length - 1];\r\n            } catch{}\r\n\r\n        } else {\r\n            // base is a stable coin, so compute direct path [token, base]\r\n            address[] memory path = new address[](2);\r\n            path[0] = (token);\r\n            path[1] = (base);\r\n\r\n            try router.getAmountsOut(amountIn, path) returns (uint256[] memory amounts){\r\n                q.quote = amounts[path.length - 1];\r\n            } catch{}\r\n        }\r\n\r\n        return q;\r\n    }\r\n\r\n    // Gets the best price of the given token among the base tokens we check\r\n    // quoter can be used to dynamically check more base tokens and exchanges\r\n    function getBestQuote(address who, address token, address quoter) public returns (Structs.QuoteData memory){\r\n        address[] memory bases = new address[](4);\r\n        bases[0] = (ETH);\r\n        bases[1] = (USDT);\r\n        bases[2] = (USDC);\r\n        bases[3] = (DAI);\r\n\r\n        // Go over all bases and find the best quote for the token\r\n        Structs.QuoteData memory bestQuote;\r\n        address bestBase = USDT;\r\n\r\n        for (uint i = 0; i < bases.length; i++) {\r\n            Structs.QuoteData memory currentQuote = getQuote(who, token, bases[i]);\r\n            if (bestQuote.quote < currentQuote.quote) {\r\n                bestQuote = currentQuote;\r\n                bestBase = bases[i];\r\n            }\r\n        }\r\n        // Optionally use an external quoter to get other quotes\r\n        // This can be used to add uniswap v3 and other exchanges support, after the fact\r\n        if (quoter != address(0)) {\r\n            Structs.QuoteData memory q = IQuoter(quoter).getQuote(who, token);\r\n            if (bestQuote.quote < q.quote) {\r\n                bestQuote = q;\r\n                bestBase = q.base.addr;\r\n            }\r\n        }\r\n        bestQuote.base = getERC20Info(bestBase);\r\n        return bestQuote;\r\n    }\r\n\r\n    // Collects basic ERC20 info of the given token, safely\r\n    function getERC20Info(address token) public view returns (Structs.TokenInfo memory) {\r\n        Structs.TokenInfo memory tInfo;\r\n        try IERC20(token).name() returns (string memory name) {\r\n            tInfo.name = name;\r\n        } catch {tInfo.name = \"\";}\r\n        try IERC20(token).symbol() returns (string memory symbol) {\r\n            tInfo.symbol = symbol;\r\n        } catch {tInfo.symbol = \"\";}\r\n        try IERC20(token).decimals() returns (uint256 decimals) {\r\n            tInfo.decimals = decimals;\r\n        } catch {tInfo.decimals = 0;}\r\n        tInfo.addr = token;\r\n\r\n        return tInfo;\r\n    }\r\n\r\n    function getData(address [] memory tokens, address who, address quoter) external returns (Structs.QuoteData[] memory) {\r\n        Structs.QuoteData[] memory tokensData_ = new Structs.QuoteData[](tokens.length);\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            Structs.QuoteData memory q = getBestQuote(who, tokens[i], quoter);\r\n\r\n            q.token = getERC20Info(tokens[i]);\r\n            tokensData_[i] = q;\r\n        }\r\n\r\n        return tokensData_;\r\n    }\r\n}"}}}