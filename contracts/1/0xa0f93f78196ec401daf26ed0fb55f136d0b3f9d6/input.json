{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LosslessControllerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\n\r\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    function __Pausable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Pausable_init_unchained();\r\n    }\r\n\r\n    function __Pausable_init_unchained() internal initializer {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n    uint256[49] private __gap;\r\n}\r\n\r\ninterface ProtectionStrategy {\r\n    function isTransferAllowed(address token, address sender, address recipient, uint256 amount) external;\r\n}\r\n\r\ncontract LosslessControllerV2 is Initializable, ContextUpgradeable, PausableUpgradeable {\r\n    address public pauseAdmin;\r\n    address public admin;\r\n    address public recoveryAdmin;\r\n\r\n    // --- V2 VARIABLES ---\r\n\r\n    address public guardian;\r\n    mapping(address => Protections) private tokenProtections;\r\n\r\n    struct Protection {\r\n        bool isProtected;\r\n        ProtectionStrategy strategy;\r\n    }\r\n\r\n    struct Protections {\r\n        mapping(address => Protection) protections;\r\n    }\r\n\r\n    // --- EVENTS ---\r\n\r\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n    event RecoveryAdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n    event PauseAdminChanged(address indexed previousAdmin, address indexed newAdmin);\r\n\r\n\r\n    // --- V2 EVENTS ---\r\n\r\n    event GuardianSet(address indexed oldGuardian, address indexed newGuardian);\r\n    event ProtectedAddressSet(address indexed token, address indexed protectedAddress, address indexed strategy);\r\n    event RemovedProtectedAddress(address indexed token, address indexed protectedAddress);\r\n\r\n    // --- MODIFIERS ---\r\n\r\n    modifier onlyLosslessRecoveryAdmin() {\r\n        require(msg.sender == recoveryAdmin, \"LOSSLESS: Must be recoveryAdmin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyLosslessAdmin() {\r\n        require(admin == msg.sender, \"LOSSLESS: Must be admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPauseAdmin() {\r\n        require(msg.sender == pauseAdmin, \"LOSSLESS: Must be pauseAdmin\");\r\n        _;\r\n    }\r\n\r\n    // --- V2 MODIFIERS ---\r\n\r\n    modifier onlyGuardian() {\r\n        require(msg.sender == guardian, \"LOSSLESS: Must be Guardian\");\r\n        _;\r\n    }\r\n\r\n    // --- VIEWS ---\r\n\r\n    function getVersion() external pure returns (uint256) {\r\n        return 2;\r\n    }\r\n\r\n    // --- V2 VIEWS ---\r\n\r\n    function isAddressProtected(address token, address protectedAddress) external view returns (bool) {\r\n        return tokenProtections[token].protections[protectedAddress].isProtected;\r\n    }\r\n\r\n    function getProtectedAddressStrategy(address token, address protectedAddress) external view returns (address) {\r\n        return address(tokenProtections[token].protections[protectedAddress].strategy);\r\n    }\r\n\r\n    // --- ADMINISTRATION ---\r\n\r\n    function pause() external onlyPauseAdmin  {\r\n        _pause();\r\n    }    \r\n    \r\n    function unpause() external onlyPauseAdmin {\r\n        _unpause();\r\n    }\r\n\r\n    function setAdmin(address newAdmin) external onlyLosslessRecoveryAdmin {\r\n        require(newAdmin != address(0), \"LERC20: Cannot be zero address\");\r\n        emit AdminChanged(admin, newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    function setRecoveryAdmin(address newRecoveryAdmin) external onlyLosslessRecoveryAdmin {\r\n        require(newRecoveryAdmin != address(0), \"LERC20: Cannot be zero address\");\r\n        emit RecoveryAdminChanged(recoveryAdmin, newRecoveryAdmin);\r\n        recoveryAdmin = newRecoveryAdmin;\r\n    }\r\n\r\n    function setPauseAdmin(address newPauseAdmin) external onlyLosslessRecoveryAdmin {\r\n        require(newPauseAdmin != address(0), \"LERC20: Cannot be zero address\");\r\n        emit PauseAdminChanged(pauseAdmin, newPauseAdmin);\r\n        pauseAdmin = newPauseAdmin;\r\n    }\r\n\r\n    // --- GUARD ---\r\n\r\n    // @notice Set a guardian contract.\r\n    // @dev Guardian contract must be trusted as it has some access rights and can modify controller's state.\r\n    function setGuardian(address newGuardian) external onlyLosslessAdmin whenNotPaused {\r\n        require(newGuardian != address(0), \"LSS: Cannot be zero address\");\r\n        emit GuardianSet(guardian, newGuardian);\r\n        guardian = newGuardian;\r\n    }\r\n\r\n    // @notice Sets protection for an address with the choosen strategy.\r\n    // @dev Strategies are verified in the guardian contract.\r\n    // @dev This call is initiated from a strategy, but guardian proxies it.\r\n    function setProtectedAddress(address token, address protectedAddresss, ProtectionStrategy strategy) external onlyGuardian whenNotPaused {\r\n        Protection storage protection = tokenProtections[token].protections[protectedAddresss];\r\n        protection.isProtected = true;\r\n        protection.strategy = strategy;\r\n        emit ProtectedAddressSet(token, protectedAddresss, address(strategy));\r\n    }\r\n\r\n    // @notice Remove the protection from the address.\r\n    // @dev Strategies are verified in the guardian contract.\r\n    // @dev This call is initiated from a strategy, but guardian proxies it.\r\n    function removeProtectedAddress(address token, address protectedAddresss) external onlyGuardian whenNotPaused {\r\n        delete tokenProtections[token].protections[protectedAddresss];\r\n        emit RemovedProtectedAddress(token, protectedAddresss);\r\n    }\r\n\r\n    // --- BEFORE HOOKS ---\r\n\r\n    // @notice If address is protected, transfer validation rules have to be run inside the strategy.\r\n    // @dev isTransferAllowed reverts in case transfer can not be done by the defined rules.\r\n    function beforeTransfer(address sender, address recipient, uint256 amount) external {\r\n        if (tokenProtections[msg.sender].protections[sender].isProtected) {\r\n            tokenProtections[msg.sender].protections[sender].strategy.isTransferAllowed(msg.sender, sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    // @notice If address is protected, transfer validation rules have to be run inside the strategy.\r\n    // @dev isTransferAllowed reverts in case transfer can not be done by the defined rules.\r\n    function beforeTransferFrom(address sender, address recipient, uint256 amount) external {\r\n        if (tokenProtections[msg.sender].protections[sender].isProtected) {\r\n            tokenProtections[msg.sender].protections[sender].strategy.isTransferAllowed(msg.sender, sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    function beforeApprove(address sender, address spender, uint256 amount) external {}\r\n\r\n    function beforeIncreaseAllowance(address msgSender, address spender, uint256 addedValue) external {}\r\n\r\n    function beforeDecreaseAllowance(address msgSender, address spender, uint256 subtractedValue) external {}\r\n\r\n    // --- AFTER HOOKS ---\r\n    // * After hooks are deprecated in LERC20 but we have to keep them\r\n    //   here in order to support legacy LERC20.\r\n\r\n    function afterApprove(address sender, address spender, uint256 amount) external {}\r\n\r\n    function afterTransfer(address sender, address recipient, uint256 amount) external {}\r\n\r\n    function afterTransferFrom(address msgSender, address sender, address recipient, uint256 amount) external {}\r\n\r\n    function afterIncreaseAllowance(address sender, address spender, uint256 addedValue) external {}\r\n\r\n    function afterDecreaseAllowance(address sender, address spender, uint256 subtractedValue) external {}\r\n}"
    }
  }
}