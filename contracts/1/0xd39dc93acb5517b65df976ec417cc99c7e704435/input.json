{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/TattooMoneyPublicSaleI.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.6;\n\n// TattooMoney.io Public Sale Contract - via StableCoins, ETH and wBTC\n//\n// USE ONLY OWN WALLET (Metamask, TrustWallet, Trezor, Ledger...)\n// DO NOT SEND FROM EXCHANGES OR ANY SERVICES\n//\n// Use ONLY ETH network, ERC20 tokens (Not Binance/Tron/whatever!)\n//\n// Set approval to contract address or use USDC authorization first\n//\n// DO NOT SEND STABLE TOKENS DIRECTLY - IT WILL NOT COUNT THAT!\n//\n// send ONLY round number of USDT/USDC/DAI!\n// ie 20, 500, 2000 NOT 20.1, 500.5, 2000.3\n// contract will IGNORE decimals!\n//\n// Need 150k gas limit.\n// Use proper pay* function\n\ncontract TattooMoneyPublicSaleI {\n\n    uint256 private constant DECIMALS_TAT2 = 6;\n    uint256 private constant DECIMALS_DAI = 18;\n    uint256 private constant DECIMALS_USD = 6;\n    uint256 private constant DECIMALS_WBTC = 8;\n\n    /// max tokens per user is 1500000 as $15000 is AML limit\n    uint256 public constant maxTokens = 1500000 * (10**DECIMALS_TAT2);\n\n    /// contract starts accepting transfers\n    uint256 public  dateStart;\n\n    /// hard time limit\n    uint256 public  dateEnd;\n\n    /// total collected USD\n    uint256 public usdCollected;\n\n    /// sale is limited by tokens count\n    uint256 public tokensLimit;\n\n    /// tokens sold in this sale\n    uint256 public tokensSold;\n\n    uint256 public tokensforadolar;\n\n    // addresses of tokens\n    address public tat2 = 0x960773318c1AeaB5dA6605C49266165af56435fa;\n    address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address public wbtcoracle = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;\n    address public ethoracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n\n    address public owner;\n    address public newOwner;\n\n    bool public saleEnded;\n\n    // deposited USD tokens per token address\n    mapping(address => uint256) private _deposited;\n\n    /// Tokens bought by user\n    mapping(address => uint256) public tokensBoughtOf;\n\n    event AcceptedUSD(address indexed user, uint256 amount);\n    event AcceptedWBTC(address indexed user, uint256 amount);\n    event AcceptedETH(address indexed user, uint256 amount);\n\n    string constant ERR_TRANSFER = \"Token transfer failed\";\n    string constant ERR_SALE_LIMIT = \"Token sale limit reached\";\n    string constant ERR_AML = \"AML sale limit reached\";\n    string constant ERR_SOON = \"TOO SOON\";\n\n    /**\n    Contract constructor\n    @param _owner adddress of contract owner\n    @param _tokensLimit maximum tokens that can be sold (round, ie 320123)\n    @param _startDate sale start timestamp\n    @param _endDate sale end timestamp\n     */\n\n    constructor(\n        address _owner,\n        uint256 _tokensLimit, // 6666666\n        uint256 _startDate, // 6-06-2020 22:22:22 GMT (1628281342)\n        uint256 _endDate, // 16-08-2020  22:22:22 GMT (1629145342)\n        uint256 _tokensforadolar // Set the numer of tokens for $1 with decimals ( 100000000 )\n    ) {\n        owner = _owner;\n        tokensLimit = _tokensLimit * (10**DECIMALS_TAT2);\n        dateStart = _startDate;\n        dateEnd = _endDate;\n        tokensforadolar = _tokensforadolar;\n    }\n\n    /**\n    Pay in using USDC, use approve/transferFrom\n    @param amount number of USDC (with decimals)\n    */\n    function payUSDC(uint256 amount) external {\n        require(\n            INterfaces(usdc).transferFrom(msg.sender, address(this), amount),\n            ERR_TRANSFER\n        );\n        _pay(msg.sender, amount );\n        _deposited[usdc] += amount;\n    }\n\n    /**\n    Pay in using USDT, need set approval first\n    @param amount USDT amount (with decimals)\n    */\n    function payUSDT(uint256 amount) external {\n        INterfacesNoR(usdt).transferFrom(msg.sender, address(this), amount);\n        _pay(msg.sender, amount );\n        _deposited[usdt] += amount;\n    }\n\n    /**\n    Pay in using DAI, need set approval first\n    @param amount number of DAI (with 6 decimals)\n    */\n    function payDAI(uint256 amount) external {\n        require(\n            INterfaces(dai).transferFrom(msg.sender, address(this), amount),\n            ERR_TRANSFER\n        );\n        _pay(msg.sender, amount / (10**12));\n        _deposited[dai] += amount;\n    }\n\n    /**\n    Pay in using wBTC, need set approval first\n    @param amount number of wBTC (with decimals)\n    */\n    function paywBTC(uint256 amount) external {\n        require(\n            INterfaces(wbtc).transferFrom(msg.sender, address(this), amount),\n            ERR_TRANSFER\n        );\n        _paywBTC(msg.sender, amount );\n        _deposited[wbtc] += amount;\n    }\n\n    //\n    // accept ETH\n    //\n\n    // takes about 50k gas\n    receive() external payable {\n        _payEth(msg.sender, msg.value);\n    }\n\n    function payETH() external payable {\n        _payEth(msg.sender, msg.value);\n    }\n\n    /**\n    Get ETH price from Chainlink.\n    @return price for 1 ETH with 6 decimals\n    */\n    function tokensPerEth() public view returns (uint256) {\n        int256 answer;\n        (, answer, , , ) = INterfaces(ethoracle).latestRoundData();\n        // geting price with 6 decimals\n        return uint256((uint256(answer) * tokensforadolar)/10**8);\n    }\n\n    /**\n    Get BTC price from Chainlink.\n    @return price for 1 BTC with 6 decimals\n    */\n    function tokensPerwBTC() public view returns (uint256) {\n        int256 answer;\n        (, answer, , , ) = INterfaces(wbtcoracle).latestRoundData();\n        // geting price with 6 decimals\n        return uint256((uint256(answer) * tokensforadolar)/10**8);\n    }\n\n    /**\n    How much tokens left to sale\n    */\n    function tokensLeft() external view returns (uint256) {\n        return tokensLimit - tokensSold;\n    }\n\n    function _payEth(address user, uint256 amount) internal notEnded {\n        uint256 sold = (amount * tokensPerEth()) / (10**18);\n        tokensSold += sold;\n        require(tokensSold <= tokensLimit, ERR_SALE_LIMIT);\n        tokensBoughtOf[user] += sold;\n        require(tokensBoughtOf[user] <= maxTokens, ERR_AML);\n        _sendTokens(user, sold);\n        emit AcceptedETH(user, amount);\n    }\n\n    function _paywBTC(address user, uint256 amount) internal notEnded {\n        uint256 sold = (amount * tokensPerwBTC()) / (10**8);\n        tokensSold += sold;\n        require(tokensSold <= tokensLimit, ERR_SALE_LIMIT);\n        tokensBoughtOf[user] += sold;\n        require(tokensBoughtOf[user] <= maxTokens, ERR_AML);\n        _sendTokens(user, sold);\n        emit AcceptedETH(user, amount);\n    }\n\n    function _pay(address user, uint256 usd) internal notEnded {\n        uint256 sold = (usd * tokensforadolar) / (10**6);\n        tokensSold += sold;\n        require(tokensSold <= tokensLimit, ERR_SALE_LIMIT);\n        tokensBoughtOf[user] += sold;\n        require(tokensBoughtOf[user] <= maxTokens, ERR_AML);\n        _sendTokens(user, sold);\n        emit AcceptedUSD(user, usd);\n    }\n\n    function _sendTokens(address user, uint256 amount) internal notEnded {\n      require(\n          INterfaces(tat2).transfer(user, amount),\n          ERR_TRANSFER\n      );\n    }\n\n    //\n    // modifiers\n    //\n\n    modifier notEnded() {\n        require(!saleEnded, \"Sale ended\");\n        require(\n            block.timestamp > dateStart && block.timestamp < dateEnd,\n            \"Too soon or too late\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only for contract Owner\");\n        _;\n    }\n\n    /// Take out stables, wBTC  and ETH\n    function takeAll() external onlyOwner {\n        uint256 amt = INterfaces(usdt).balanceOf(address(this));\n        if (amt > 0) {\n            INterfacesNoR(usdt).transfer(owner, amt);\n        }\n        amt = INterfaces(usdc).balanceOf(address(this));\n        if (amt > 0) {\n            require(INterfaces(usdc).transfer(owner, amt), ERR_TRANSFER);\n        }\n        amt = INterfaces(dai).balanceOf(address(this));\n        if (amt > 0) {\n            require(INterfaces(dai).transfer(owner, amt), ERR_TRANSFER);\n        }\n        amt = INterfaces(wbtc).balanceOf(address(this));\n        if (amt > 0) {\n            require(INterfaces(wbtc).transfer(owner, amt), ERR_TRANSFER);\n        }\n        amt = INterfaces(tat2).balanceOf(address(this));\n        if (amt > 0) {\n            require(INterfaces(tat2).transfer(owner, amt), ERR_TRANSFER);\n        }\n        amt = address(this).balance;\n        if (amt > 0) {\n            payable(owner).transfer(amt);\n        }\n    }\n\n    /// we can recover any ERC20!\n    function recoverErc20(address token) external onlyOwner {\n        uint256 amt = INterfaces(token).balanceOf(address(this));\n        if (amt > 0) {\n            INterfacesNoR(token).transfer(owner, amt); // use broken ERC20 to ignore return value\n        }\n    }\n\n    /// just in case\n    function recoverEth() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    function EndSale() external onlyOwner {\n        saleEnded = true;\n    }\n\n    function changeOwner(address _newOwner) external onlyOwner {\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() external {\n        require(\n            msg.sender != address(0) && msg.sender == newOwner,\n            \"Only NewOwner\"\n        );\n        newOwner = address(0);\n        owner = msg.sender;\n    }\n}\n\n// Interfaces for contract interaction\ninterface INterfaces {\n    function balanceOf(address) external returns (uint256);\n\n    function transfer(address, uint256) external returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n\n    // chainlink ETH/USD, ethoracle\n    // answer|int256 :  229841000000 - 8 decimals\n\n    // chainlink BTC/USD wbtcoracle\n    // answer|int256 : 4006800000000 - 8 decimals\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n// For tokens that do not return true on transfers eg. USDT\ninterface INterfacesNoR {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\n// by Patrick\n"}}}