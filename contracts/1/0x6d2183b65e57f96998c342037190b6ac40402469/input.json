{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/bustedBot.sol":{"content":"pragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\nlibrary UniswapV2Library {\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'ZERO_ADDRESS');\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address tokenA, address tokenB, address pair) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pair).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn * 997;\n        uint numerator = amountInWithFee * reserveOut;\n        uint denominator = reserveIn*1000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n}\n\n\nlibrary TransferHelper {\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n}\n\n\n\ncontract AttackerBot {\n\n    struct stealth {\n        bytes32 nonces1;\n        bytes32 nonces2; \n        uint maxBlockGasLimit;\n    }\n\n    address private constant FACTORY = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f); // all netowrks\n    address public constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n        // weth mainnet: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n        // weth rinkeby/ropsten: 0xc778417E063141139Fce010982780140Aa0cD5Ab\n    address payable public _owner;\n    address public _maintainer;\n    \n    modifier onlyowner \n    {\n        _isOwner();\n        _;\n    }\n\n    function _isOwner() \n    internal \n    view \n    {\n        require(\n            _owner == msg.sender || \n            _maintainer == msg.sender, \n            \"not owner\");\n    }\n\n    constructor(address payable owner, address maintainer) //, address weth) \n    payable \n    {\n        _owner = owner;\n        _maintainer = maintainer;\n        // WETH = weth;\n    }\n\n    receive() external payable \n    {\n    }\n\n    function withdraw(uint256 etherAmount) \n    external \n    onlyowner \n    {\n        TransferHelper.safeTransferETH(msg.sender, etherAmount);\n    }\n\n    function withdrawToken(address token, uint256 amount) \n    external \n    onlyowner \n    {\n        TransferHelper.safeTransfer(token, msg.sender, amount);\n    }\n\n    function changeOwner(address payable newOwner, address newMaintainer) \n    external \n    onlyowner \n    {\n        if (newOwner != address(0)) _owner = newOwner;\n        if (newMaintainer != address(0)) _maintainer = newMaintainer;\n    }\n\n    // initiaate attack by buying a large amount of _tokenToBuy\n    // In --> the Uniswap pair\n    // Out --> from the Uniswap pair\n    function buyToken(address pair, address firstTokenInPair, address _tokenToBuy, uint _ethAmountIn, uint _minTokenAmountOut)\n    external\n    payable \n    onlyowner\n    {\n        require(address(this).balance >= _ethAmountIn, '_ethAmountIn > eth in contract');\n        uint ethAmountIn = _ethAmountIn == 0 ? address(this).balance : _ethAmountIn;\n        \n        (uint wethReserve, uint tokenReserve) = UniswapV2Library.getReserves(WETH, _tokenToBuy, pair);\n        uint256 tokenAmountOut = UniswapV2Library.getAmountOut(ethAmountIn, wethReserve, tokenReserve);\n        require(_minTokenAmountOut <= tokenAmountOut, 'tokenAmountOut < _minTokenAmountOut');\n        \n        IWETH(WETH).deposit{value: ethAmountIn}();\n        require(IWETH(WETH).transfer(pair, ethAmountIn), 'weth transfer err');\n        swap(firstTokenInPair, WETH, tokenAmountOut, pair, address(this));\n    }\n\n    // _minWethAmountOut should fail sellToken in case only the hook passes and no bated transactions are sent to frontrun it\n    function sellToken(address pair, address firstTokenInPair, address _tokenToSell, uint _tokenAmountIn, uint _minWethAmountOut, address _hook,\n        stealth calldata stealthData)\n    external\n    onlyowner\n    {\n        stealthMode(stealthData);\n\n        uint tokenAmountToPull = 0;\n        if (_hook != address(0))\n            tokenAmountToPull = IERC20(_tokenToSell).balanceOf(_hook); \n        \n        require(IERC20(_tokenToSell).balanceOf(address(this)) >= _tokenAmountIn, '_tokenAmountIn > token balance of contract');\n        uint tokenAmountIn = _tokenAmountIn == 0 ? IERC20(_tokenToSell).balanceOf(address(this)) : _tokenAmountIn;\n        tokenAmountIn = tokenAmountIn + tokenAmountToPull;\n        \n        (uint wethReserve, uint tokenReserve) = UniswapV2Library.getReserves(WETH, _tokenToSell, pair);\n        \n        // this won't work with transfer on fee tokens \n        uint wethAmountOut = UniswapV2Library.getAmountOut(tokenAmountIn, tokenReserve, wethReserve);\n        require(_minWethAmountOut <= wethAmountOut, 'wethAmountOut < _minWethAmountOut');\n\n        if (tokenAmountToPull > 0)\n            // prior: _hook needs to approve address(this) \n            TransferHelper.safeTransferFrom(_tokenToSell, _hook, address(this), tokenAmountToPull);\n\n        TransferHelper.safeTransfer(_tokenToSell, pair, tokenAmountIn);\n        \n        swap(firstTokenInPair, _tokenToSell, wethAmountOut, pair, address(this));\n        \n        IWETH(WETH).withdraw(wethAmountOut);\n    }\n\n    function swap(address token0, address tokenIn, uint amountOut, address pair, address to) \n    internal \n    {\n        (uint amount0Out, uint amount1Out) = tokenIn == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        \n        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n\n\n    function stealthMode(stealth calldata stealthData) internal {\n        uint16 coinbase = uint16(block.coinbase);\n        if (block.gaslimit > stealthData.maxBlockGasLimit)\n            revert('g');\n        if (stealthData.nonces1 != 0 && !isMiner(stealthData.nonces1, coinbase)) {\n            if (stealthData.nonces2 == 0 || !isMiner(stealthData.nonces2, coinbase))\n                revert('m');\n        }\n    }\n\n    function isMiner(bytes32 nonces, uint16 coinbase) internal pure returns(bool) {\n        bytes32 firstLimit = 0x08FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        bytes32 secondLimit = 0x0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        \n        return \n            (keccak256(abi.encodePacked(coinbase, uint32(uint(nonces)))) < firstLimit &&\n            keccak256(abi.encodePacked(coinbase, uint32(uint224(bytes28(nonces))))) < secondLimit) \n            ||\n            (keccak256(abi.encodePacked(coinbase, uint32(uint192(bytes24(nonces))))) < firstLimit &&\n            keccak256(abi.encodePacked(coinbase, uint32(uint160(bytes20(nonces))))) < secondLimit) \n            ||\n            (keccak256(abi.encodePacked(coinbase, uint32(uint128(bytes16(nonces))))) < firstLimit &&\n            keccak256(abi.encodePacked(coinbase, uint32(uint96(bytes12(nonces))))) < secondLimit) \n            ||\n            (keccak256(abi.encodePacked(coinbase, uint32(uint64(bytes8(nonces))))) < firstLimit &&\n            keccak256(abi.encodePacked(coinbase, uint32(bytes4(nonces)))) < secondLimit);\n    }\n}"}}}