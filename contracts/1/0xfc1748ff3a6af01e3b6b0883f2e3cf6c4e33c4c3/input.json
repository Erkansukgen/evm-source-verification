{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/DyDx.sol": {
      "content": "//https://github.com/peppersec/flashloan-tutorial/blob/master/contracts/dydx/DyDx.sol\npragma solidity >=0.6.2;\npragma experimental ABIEncoderV2;\n\ninterface Structs {\n    struct Val {\n        uint256 value;\n    }\n\n    enum ActionType {\n      Deposit,   // supply tokens\n      Withdraw,  // borrow tokens\n      Transfer,  // transfer balance between accounts\n      Buy,       // buy an amount of some token (externally)\n      Sell,      // sell an amount of some token (externally)\n      Trade,     // trade tokens against another account\n      Liquidate, // liquidate an undercollateralized or expiring account\n      Vaporize,  // use excess tokens to zero-out a completely negative account\n      Call       // send arbitrary data to an address\n    }\n\n    enum AssetDenomination {\n        Wei // the amount is denominated in wei\n    }\n\n    enum AssetReference {\n        Delta // the amount is given as a delta from the current value\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    struct Info {\n        address owner;  // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n}\n\nabstract contract DyDxPool is Structs {\n    function getAccountWei(Info memory account, uint256 marketId) public view virtual returns (Wei memory);\n    function operate(Info[] memory, ActionArgs[] memory) public virtual;\n}\n"
    },
    "browser/DyDxDDDx.sol": {
      "content": "pragma solidity >=0.6.2;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./DyDxFlashLoan.sol\";\r\nimport \"./ddex.sol\";\r\nimport \"./IWETH.sol\";\r\n\r\ncontract DyDxDDDx is DyDxFlashLoan, MyDDEX{\r\n  address payable owner;\r\n\r\n  constructor() public payable {\r\n    owner = msg.sender;\r\n\t\t/*\r\n    (bool success, ) = WETH.call{value:msg.value}(\"\");\r\n    require(success, \"fail to get weth\");\r\n\t\t*/\r\n  }\r\n\r\n  modifier onlyOwner () {\r\n    require(msg.sender == owner );\r\n    _;\r\n  }\r\n\r\n\treceive() payable external {}\r\n\r\n  function getFlashloan(\r\n    address _flashToken,\r\n    uint256 _flashAmount,\r\n\t\tuint8 aid\r\n  )\r\n    external\r\n  {\r\n      uint256 _balanceBefore = IERC20(_flashToken).balanceOf(address(this));\r\n      bytes memory _data = abi.encode(_flashToken, _flashAmount, _balanceBefore, aid);\r\n      flashloan(_flashToken, _flashAmount, _data);\r\n  }\r\n\r\n  function callFunction(\r\n    address, \r\n    Info calldata,\r\n    bytes calldata _data\r\n  )\r\n    external onlyPool\r\n  {\r\n    (address flashToken, uint256 flashAmount, uint256 balanceBefore, uint8 aid) = abi.decode(_data, (address, uint256, uint256, uint8));\r\n    uint256 balanceAfter = IERC20(flashToken).balanceOf(address(this));\r\n    require(balanceAfter - balanceBefore == flashAmount, \"contract did not get the loan\");\r\n\r\n\t\tif( flashToken == address(WETH)) {\r\n\t\t\tIWETH(WETH).withdraw(flashAmount);\r\n\t\t}\r\n\r\n\t\t// logic begin\r\n\t\t/*\r\n\t\t\taid: \r\n\t\t\t\t1 : rock ETH => borrow 30000 eth from dydx , marketID=0, tokenA = tokenB = dETHADDR    => loop:4.9+1=>5  run:1\r\n\t\t\t\t\t\tgetFlashloan(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,30000000000000000000000,1)  \r\n\r\n\t\t\t\t2 : rock USDT => borrow 30000 eth from dydx , marketID=0, tokenA=dETHADDR, tokenB=dUSDT => loop:5.1+1=>6 run:1\r\n\t\t\t\t\t\tgetFlashloan(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,30000000000000000000000,2)\r\n\t\t\t\t\r\n\t\t\t\t3 : rock USDC => borrow 500w USDC from dydx, marketID=4, tokenA=dUSDC, tokenB=dUSDC => => loop:1.59+1=>2 run:1\r\n\t\t\t\t\t\tgetFlashloan(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48,5000000000000,3)\r\n\r\n\t\t\t\t4 : rock DAI  => borrow 100w DAI from dydx, marketID=3, tokenA=DAI, tokenB=DAI => loop:57.7+1=>58=>10 run:6\r\n\t\t\t\t\t\tgetFlashloan(0x6B175474E89094C44Da98b954EedeAC495271d0F,1000000000000,4)\r\n\t\t*/\r\n\r\n\t\taddress tokenA;\r\n\t\taddress tokenB;\r\n\t\tif( aid == 1 ) {\r\n\t\t\tuint16 marketID = 0;\r\n\t\t\t(tokenA,) = getMarketPair(marketID);\r\n\t\t\t(, uint256 loop) = getAmountBAndloop(tokenA);\r\n\t\t\tlooprc(tokenA, flashAmount, tokenA, marketID, loop);\r\n\t\t}else if( aid == 2 ) {\r\n\t\t\tuint16 marketID = 0;\r\n\t\t\t(tokenA, tokenB) = getMarketPair(marketID);\r\n\t\t\t(, uint256 loop) = getAmountBAndloop(tokenB);\r\n\t\t\tlooprc(tokenA, flashAmount, tokenB, marketID, loop);\r\n\t\t}else if( aid == 3 ) {\r\n\t\t\tuint16 marketID = 4;\r\n\t\t\t(,tokenB) = getMarketPair(marketID);\r\n\t\t\t(, uint256 loop) = getAmountBAndloop(tokenB);\r\n\t\t\tlooprc(tokenB, flashAmount, tokenB, marketID, loop);\r\n\t\t}else if( aid == 4 ) {\r\n\t\t\tuint16 marketID = 3;\r\n\t\t\t(,tokenB) = getMarketPair(marketID);\r\n\t\t\t(, uint256 loop) = getAmountBAndloop(tokenB);\r\n\t\t\tlooprc(tokenB, flashAmount, tokenB, marketID, loop);\r\n\t\t}\t\r\n\t\t// end login\t\r\n\r\n\t\t// for dydx weth\r\n\t\tif( flashToken == address(WETH)){\r\n\t\t\tIWETH(WETH).deposit{value:flashAmount+200}();\r\n\t\t\tif( isDDEXETHAddr(tokenB) ){\r\n\t\t\t\twithdraw(address(0x0), balanceOf(address(0x0))-20000);\r\n\t\t\t}else{\r\n\t\t\t\twithdraw(tokenB, balanceOf(tokenB)-200);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif( isDDEXETHAddr(tokenB) ){\r\n\t\t\t\twithdraw(address(0x0), balanceOf(address(0x0)));\r\n\t\t\t}else{\r\n\t\t\t\twithdraw(tokenB, balanceOf(tokenB)-flashAmount-200);\t\r\n\t\t\t}\r\n\t\t}\r\n  }\r\n\t\r\n\tfunction balanceOf(address token) public view returns(uint256 balance){\r\n\t\tif( token != address(0x0) ) {\r\n\t\t\tbalance = IERC20(token).balanceOf(address(this));\r\n\t\t}else{\r\n\t\t\tbalance = address(this).balance;\r\n\t\t}\r\n\t}\r\n\r\n  function withdraw(address token, uint256 amount) public{\r\n\t\tif( token != address(0x0) ) {\r\n\t\t\tIERC20(token).transfer(owner, amount);\r\n\t\t}else{\r\n\t\t\towner.transfer(amount);\r\n\t\t}\r\n  }\r\n}\r\n"
    },
    "browser/DyDxFlashLoan.sol": {
      "content": "//https://github.com/peppersec/flashloan-tutorial/blob/master/contracts/dydx/DyDx.sol\npragma solidity >=0.6.2;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\nimport \"./DyDx.sol\";\n\ncontract DyDxFlashLoan is Structs {\n\t\t//MAINNET\n    DyDxPool pool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address public DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n\t\t//kovan\n\t\t//DyDxPool pool = DyDxPool(0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE);\n    //address public WETH = address(0xd0A1E359811322d97991E03f863a0C30C2cF029C);\n    //address public SAI= address(0x81f1fC45Fa9AEdb96F39C0aE2E77FA623aaA9a8c);\n    //address public USDC= address(0x5E49FF0960f8664CFA883506FC2a2e961b1956C0);\n\t\t//address public DAI = address(0xC4375B7De8af5a38a93548eb8453a498222C4fF2);\n\n    mapping(address => uint256) public currencies;\n\n    constructor() public {\n        currencies[WETH] = 1;\n        currencies[SAI] = 2;\n        currencies[USDC] = 3;\n        currencies[DAI] = 4;\n    }\n\n    modifier onlyPool() {\n        require(\n            msg.sender == address(pool),\n            \"FlashLoan: could be called by DyDx pool only\"\n        );\n        _;\n    }\n\n    function tokenToMarketId(address token) public view returns (uint256) {\n        uint256 marketId = currencies[token];\n        require(marketId != 0, \"FlashLoan: Unsupported token\");\n        return marketId - 1;\n    }\n\n    // the DyDx will call `callFunction(address sender, Info memory accountInfo, bytes memory data) public` after during `operate` call\n    // token: erc20 token for flashloan from dydx\n    function flashloan(\n      address token,\n      uint256 amount,\n      bytes memory data\n    )\n        internal\n    {\n        // approve dydx solo pool\n        IERC20(token).approve(address(pool), amount + 2);\n\n        Info[] memory _infos = new Info[](1);\n        ActionArgs[] memory _args = new ActionArgs[](3);\n\n        _infos[0] = Info(address(this), 0);\n\n        AssetAmount memory _withdrawAmt = AssetAmount(\n            false,\n            AssetDenomination.Wei,\n            AssetReference.Delta,\n            amount\n        );\n        ActionArgs memory _withdraw;\n        _withdraw.actionType = ActionType.Withdraw;\n        _withdraw.accountId = 0;\n        _withdraw.amount = _withdrawAmt;\n        _withdraw.primaryMarketId = tokenToMarketId(token);\n        _withdraw.otherAddress = address(this);\n\n        _args[0] = _withdraw;\n\n        ActionArgs memory _call;\n        _call.actionType = ActionType.Call;\n        _call.accountId = 0;\n        _call.otherAddress = address(this);\n        _call.data = data;\n\n        _args[1] = _call;\n\n        ActionArgs memory _deposit;\n        AssetAmount memory _depositAmt = AssetAmount(\n            true,\n            AssetDenomination.Wei,\n            AssetReference.Delta,\n            amount + 2\n        );\n        _deposit.actionType = ActionType.Deposit;\n        _deposit.accountId = 0;\n        _deposit.amount = _depositAmt;\n        _deposit.primaryMarketId = tokenToMarketId(token);\n        _deposit.otherAddress = address(this);\n\n        _args[2] = _deposit;\n\n        pool.operate(_infos, _args);\n    }\n}\n"
    },
    "browser/IERC20.sol": {
      "content": "// Original: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n\n//pragma solidity ^0.5.0;\npragma solidity >=0.6.2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "browser/IWETH.sol": {
      "content": "pragma solidity >=0.6.2;\npragma experimental ABIEncoderV2;\n\ninterface IWETH{\n\tfunction deposit() external payable;\n\tfunction withdraw(uint wad) external;\n}\n"
    },
    "browser/ddex.sol": {
      "content": "pragma solidity >=0.6.2;\npragma experimental ABIEncoderV2;\n\nimport \"./ddexInterface.sol\";\nimport \"./IERC20.sol\";\n//0xb8374934a63C80A8034912a49a5b97CaeE74E935\ncontract MyDDEX is DDEXStructs{\n\tDDEX ddex = DDEX(0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7);\t\t\t\t\t// getPoolCashableAmount => real => balanceInContract\n\taddress public dETHADDR = 0x000000000000000000000000000000000000000E; // 852473273494915222387 => 852 => 4,249\n\taddress public dUSDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\t// 132093737507 => 132093 => 675439\n\taddress public dSAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\t// 22266 => 22775\n\taddress public dWBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // 18372994 => 0.18372994 => 21.3\n\taddress public dDAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F; //  1097806904508773207127 => 1097 => 63368\n\taddress public dUSDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // 189428030341 => 189428 => 302023\n\taddress public dHBTC = 0x0316EB71485b0Ab14103307bf65a021042c6d380; // 0.001166 => 0\n\taddress public dBUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53; // 0.1 => 5247\n\n\tuint256 public maxLoop = 1;\n\t\n\n\t/*\n\t\tmarketid\n\t\t0 : ETH - USDT \n\t\t1 : ETH - SAI borrowEnabled false\n\t\t2 : WBTC - USDT\n\t\t3 : ETH - DAI\n\t\t4 : ETH - USDC\n\t\t5 : HBTC - USDT\n\t\t6 : ETH - dBUSD\n\t*/\n\tconstructor() public payable{\n\t}\n\n\tfunction isDDEXETHAddr(address token) public view returns(bool){\n\t\treturn token == dETHADDR;\n\t}\n\n\tfunction getMarketPair(uint16 marketID) public view returns(address tokenA, address tokenB){\n\t\tif( marketID == 0 ) return (dETHADDR, dUSDT);\n\t\telse if( marketID == 1) return (dETHADDR, dSAI);\n\t\telse if( marketID == 2) return (dWBTC, dUSDT);\n\t\telse if( marketID == 3) return (dETHADDR, dDAI);\n\t\telse if( marketID == 4) return (dETHADDR, dUSDC);\n\t\telse if( marketID == 5) return (dHBTC, dUSDT);\n\t\telse if( marketID == 6) return (dETHADDR, dBUSD);\n\t}\n\n\tfunction setMaxLoop(uint256 loop) public {\n\t\tmaxLoop = loop;\n\t\tif( maxLoop < 1 ) maxLoop = 1;\n\t}\n\n\tfunction getAmountBAndloop(address tokenB) public view returns(uint256 amountB, uint256 loop){\n\t\tuint256 poolCashable = ddex.getPoolCashableAmount(tokenB);\t\n\t\tuint256 leftTokenBalance = tokenB != dETHADDR ? IERC20(tokenB).balanceOf(address(ddex)) : address(ddex).balance;\n\t\tamountB = poolCashable;\n\t\tloop = leftTokenBalance/poolCashable + 1;\n\t\tif( loop >= maxLoop ) loop = maxLoop;\n\t}\n\n\tfunction looprc(address tokenA, uint256 amountA, address tokenB, uint16 marketID, uint256 loop) public{\n\t\tuint counter = 1;\n\t\twhile(counter <= loop){\n\t\t\tuint256 poolCashable = ddex.getPoolCashableAmount(tokenB);\n\t\t\tuint256 leftTokenBalance = tokenB != dETHADDR ? IERC20(tokenB).balanceOf(address(ddex)) : address(ddex).balance;\n\t\t\n\t\t\tuint256 amountB;\n\t\t\tif( leftTokenBalance >= poolCashable ){\n\t\t\t\tamountB = poolCashable*980/1000;\t\n\t\t\t}else{\n\t\t\t\tamountB = leftTokenBalance*980/1000;\n\t\t\t} \n\t\t\n\t\t\tif( amountB == 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tdAction[] memory actions = new dAction[](5);\n\n\t\t\t\t{\n\t\t\t\t\tdAction memory _deposit;\n\t\t\t\t\t_deposit.actionType = dActionType.Deposit;\n\t\t\t\t\t_deposit.encodedParams = abi.encode(tokenA, amountA);\n\t\t\t\t\tactions[0] = _deposit;\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tdAction memory _borrow;\n\t\t\t\t\t_borrow.actionType = dActionType.Borrow;\n\t\t\t\t\t_borrow.encodedParams = abi.encode(marketID, tokenB, amountB);\n\t\t\t\t\tactions[1] = _borrow;\t\n\t\t\t\t}\n\t\t\t\n\t\t\t\t{\n\t\t\t\t\tdAction memory _transfer;\n\t\t\t\t\tBalancePath memory fromPath;\n\t\t\t\t\tfromPath.category = BalanceCategory.CollateralAccount;\n\t\t\t\t\tfromPath.marketID = marketID;\n\t\t\t\t\tfromPath.user = address(this);\n\t\t\t\t\tBalancePath memory toPath;\n\t\t\t\t\ttoPath.category = BalanceCategory.Common;\n\t\t\t\t\ttoPath.marketID = 0;\n\t\t\t\t\ttoPath.user = address(this);\n\t\t\t\t\t_transfer.actionType = dActionType.Transfer;\n\t\t\t\t\t_transfer.encodedParams = abi.encode(tokenB, fromPath, toPath, amountB);\n\t\t\t\t\tactions[2] = _transfer;\t\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tdAction memory _withdrawB;\n\t\t\t\t\t_withdrawB.actionType = dActionType.Withdraw;\n\t\t\t\t\t_withdrawB.encodedParams = abi.encode(tokenB, amountB);\n\t\t\t\t\tactions[3] = _withdrawB;\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tdAction memory _withdrawA;\n\t\t\t\t\t_withdrawA.actionType = dActionType.Withdraw;\n\t\t\t\t\t_withdrawA.encodedParams = abi.encode(tokenA, amountA);\n\t\t\t\t\tactions[4] = _withdrawA;\n\t\t\t\t}\n\n\t\t\t\tuint256 ethValue = tokenA == dETHADDR ? amountA : 0;\n\t\t\t\tif( ethValue == 0 ) {\n\t\t\t\t\tIERC20(tokenA).approve(address(ddex), amountA);\n\t\t\t\t}\n\n\t\t\t\tddex.batch{value:ethValue}(actions);\n\t\t\t}\n\t\t\n\t\t\tcounter++;\n\t\t}\t\t\n\t}\n}\n"
    },
    "browser/ddexInterface.sol": {
      "content": "pragma solidity >=0.6.2;\npragma experimental ABIEncoderV2;\n\ninterface DDEXStructs{\n\t\tenum dActionType {\n        Deposit,   // Move asset from your wallet to tradeable balance\n        Withdraw,  // Move asset from your tradeable balance to wallet\n        Transfer,  // Move asset between tradeable balance and margin account\n        Borrow,    // Borrow asset from pool\n        Repay,     // Repay asset to pool\n        Supply,    // Move asset from tradeable balance to pool to earn interest\n        Unsupply   // Move asset from pool back to tradeable balance\n    } \n\t\n\t\tstruct dAction {\n        dActionType actionType;  // The action type\n        bytes encodedParams;    // Encoded params, it's different for each action\n    }\n\n\t\tenum BalanceCategory {\n        Common,\n        CollateralAccount\n    }\n\n\t\tstruct BalancePath {\n        BalanceCategory category;\n        uint16          marketID;\n        address         user;\n    }\t\n\n\t\t\n    struct Market {\n        address baseAsset;\n        address quoteAsset;\n\n        // If the collateralRate is below this rate, the account will be liquidated\n        uint256 liquidateRate;\n\n        // If the collateralRate is above this rate, the account asset balance can be withdrawed\n        uint256 withdrawRate;\n\n        uint256 auctionRatioStart;\n        uint256 auctionRatioPerBlock;\n\n        bool borrowEnable;\n    }\t\n}\n\nabstract contract DDEX is DDEXStructs {\n\tfunction batch(dAction[] memory actions) public payable virtual;\n\t//function getMarket(uint16 marketID) external view virtual returns(Market memory);\n\tfunction getPoolCashableAmount(address asset) external view virtual returns(uint256 cashableAmount);\n}\n"
    }
  }
}