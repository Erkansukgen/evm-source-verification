{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "FibExInvestStableToken.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20A.sol\";\r\nimport \"./ProgressiveTokenInterface.sol\";\r\n\r\ncontract FibExInvestStableToken is IERC20A {\r\n    using SafeMath for uint;\r\n    \r\n    string public constant name = \"FibEx Invest Stable token\";\r\n    string public constant symbol = \"FIns\";\r\n    uint8 public constant decimals = 6;\r\n    \r\n    address payable public owner;\r\n    address public progressiveFibExAdress;\r\n    uint public totalTokens; //текущее количество\r\n    uint public oneETHToDollarPrice; // текущий курс к доллару(Основная часть) в gwei(10^-9)\r\n    uint public boughtTokens;\r\n    bool private canTransfer = false;\r\n    uint public ajioPercent = 75;\r\n    \r\n    mapping (address => mapping (address => uint)) allowed;\r\n    mapping (address => uint) balances;\r\n    mapping (address => uint) pendingConversions;\r\n    mapping(uint => uint) deals;\r\n    \r\n    event Convert(uint countPro, uint countSta, uint initialTokenCt, uint comission,  uint tokensCt, address _address);\r\n    event ConversionReturn(address _address, uint count, uint comission, uint date);\r\n    event ConversionSuccess(address _address, uint count, uint date);\r\n    event AgioPayment(address _address, uint count, uint date);\r\n    event OwnerTransfer(address _address, uint count, uint date);\r\n    event DealActivation(address _address, uint dealId, uint totalEth, uint tokensCounts, uint ethTokenPayment, uint ajioPayment);\r\n    \r\n    //Конструктор выполняется один раз при публикации контракта\r\n    constructor () public payable {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner()\r\n    {\r\n        require(\r\n            msg.sender == owner,\r\n            \"access_denied\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    modifier onlyProgressive()\r\n    {\r\n        require(\r\n            msg.sender == progressiveFibExAdress,\r\n            \"access_denied\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    function setAjioToFull() public onlyOwner {\r\n        ajioPercent = 150;\r\n    }\r\n    \r\n    function setAjioToHalf() public onlyOwner {\r\n        ajioPercent = 75;\r\n    }\r\n    \r\n    function setAjioInUsd(uint dealId, uint usdPrice) public onlyOwner {\r\n        deals[dealId] = usdPrice;\r\n    }\r\n    \r\n\tfunction getAjioInUsd(uint dealId) public view returns(uint) {\r\n        return deals[dealId];\r\n    }\r\n\t\r\n    function activateDeal(uint dealId) payable public {\r\n        if(deals[dealId] == 0) revert('no_deal');\r\n        uint sentWei = msg.value;\r\n        if(sentWei == 0) revert('not_enough');\r\n        getRate();\r\n        uint oneUsdInWei = oneTokenCount();\r\n        uint ajioPayment = deals[dealId].mul(oneUsdInWei).mul(100);\r\n        if(ajioPayment > sentWei)  revert('not_enough');\r\n        uint tokensEth = sentWei.sub(ajioPayment);\r\n        uint resultTokens = (tokensEth.mul(1000000).div(oneUsdInWei)).div(10000);\r\n        if(resultTokens > balances[owner]) revert('not_enough_tokens_company');\r\n        balances[msg.sender] = balances[msg.sender].add(resultTokens);\r\n        balances[owner] = balances[owner].sub(resultTokens);\r\n        emit DealActivation(msg.sender, dealId, sentWei, resultTokens, tokensEth, ajioPayment);\r\n    }\r\n    \r\n    function setAdress(address contractItem) public onlyOwner {\r\n        progressiveFibExAdress = contractItem;\r\n    }\r\n    \r\n    function getRate() public {\r\n        if(progressiveFibExAdress == address(0)) revert('no_address_rate');\r\n        ProgressiveTokenInterface pro = ProgressiveTokenInterface(progressiveFibExAdress);\r\n        oneETHToDollarPrice = pro.oneDollarRate();\r\n    }\r\n    \r\n    function oneDollarRate() public view returns(uint) {\r\n        if(progressiveFibExAdress == address(0)) revert('no_address_rate');\r\n        if(oneETHToDollarPrice == 0) revert('rate_not_set');\r\n        return oneETHToDollarPrice;\r\n    }\r\n    \r\n    function convertToProgressive(uint value) public {\r\n        if(progressiveFibExAdress == address(0)) revert('no_address_rate');\r\n        if(value == 0) revert('no_tokens');\r\n        if(value > balances[msg.sender]) revert('not_enough_tokens');\r\n        ProgressiveTokenInterface pro = ProgressiveTokenInterface(progressiveFibExAdress);\r\n        getRate();\r\n        uint oneTokenStable = oneTokenCount();\r\n        uint comission = takeComission(value);\r\n        uint valueNoWithoutComission = value.sub(comission);\r\n        uint oneTokenProgressive = pro.oneTokenCount();\r\n        uint resultTokens = valueNoWithoutComission.mul(1000).div(oneTokenProgressive.mul(1000).div(oneTokenStable));\r\n        emit Convert(valueNoWithoutComission.mul(1000), (oneTokenProgressive.mul(1000).div(oneTokenStable)), comission, valueNoWithoutComission, resultTokens, msg.sender);\r\n        if(resultTokens == 0) revert('conversion_result');\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        pendingConversions[msg.sender] = resultTokens;\r\n        pro.addConvertedTokens(msg.sender);\r\n        emit Convert(oneTokenProgressive, oneTokenStable, comission, valueNoWithoutComission, resultTokens, msg.sender);\r\n    }\r\n    \r\n    function payReferal(address _address, uint count) public onlyOwner {\r\n        if(count == 0) revert('no_tokens');\r\n        if(_address == address(0)) revert('no_address');\r\n        if(count > totalTokens) revert('not_enough_tokens_company');\r\n        if(count > balances[owner]) revert('not_enough_tokens_payment');\r\n        balances[owner] = balances[owner].sub(count);\r\n        balances[_address] = balances[_address].add(count);\r\n        emit OwnerTransfer(_address, count, now);\r\n    }\r\n    \r\n    function takeComission(uint _value) private returns(uint){\r\n        if(_value == 0) revert('no_sum');\r\n        uint comission = _value.div(100);\r\n        balances[owner] = balances[owner].add(comission);\r\n        return comission;\r\n    }\r\n    \r\n    function getConvertValue(address _address) public view returns(uint) {\r\n        if(pendingConversions[_address] == 0) return 0;\r\n        return pendingConversions[_address];\r\n    }\r\n    \r\n    function returnComission(uint _value) private returns(uint) {\r\n        uint originalValue = _value.mul(100).div(99);\r\n        uint comission = originalValue.div(100);\r\n        balances[owner] = balances[owner].sub(comission);\r\n        return comission;\r\n    }\r\n    \r\n    function returnPendingTokens() public  {\r\n        if(pendingConversions[msg.sender] == 0) revert('action_incorrect');\r\n        uint comission = returnComission(pendingConversions[msg.sender]);\r\n        uint resultCount = pendingConversions[msg.sender].add(comission);\r\n        balances[msg.sender] = balances[msg.sender].add(resultCount);\r\n        delete pendingConversions[msg.sender];\r\n        emit ConversionReturn(msg.sender, resultCount, comission, now);\r\n\r\n    }\r\n    \r\n    function conversionSuccessfull(address _address) public onlyProgressive returns(bool) {\r\n        if(pendingConversions[_address] == 0) revert('action_incorrect');\r\n        delete pendingConversions[_address];\r\n        emit ConversionSuccess(_address, pendingConversions[_address], now);\r\n        return true;\r\n    }\r\n    \r\n    //Эмиссия - проверяем является ли тот кто запрашивает, владельцем контракта\r\n    // Проверяем сумму\r\n    // проверяем переполнение\r\n    // в случае успеха добавляем токены владельцу контракта и в общее количество\r\n    function emission(uint emissionCount) external onlyOwner {\r\n        require(emissionCount > 0, \"emission_not_null\");\r\n        \r\n        totalTokens = totalTokens.add(emissionCount);\r\n        balances[owner] = balances[owner].add(emissionCount);\r\n    }\r\n    \r\n    function buy() payable public {\r\n        uint sentWei = msg.value;\r\n        if(sentWei == 0) revert('not_enough');\r\n        getRate();\r\n\t\tuint tenThousand = 10000;\r\n        uint oneTokenInWei = oneTokenCount();\r\n        uint buyTokensCounts = (sentWei.mul(1000000).div(oneTokenInWei));\r\n        uint buyTokensCountsNoAjio = buyTokensCounts.mul(tenThousand).div(tenThousand.add(ajioPercent.mul(10)));\r\n        uint ajioPayment =  buyTokensCounts.sub(buyTokensCountsNoAjio);\r\n        uint resultTokens = (buyTokensCounts.sub(ajioPayment)).div(10000);\r\n        if(resultTokens > totalTokens) revert('not_enough_tokens_company');\r\n        if(resultTokens > balances[owner]) revert('not_enough_tokens_company');\r\n        balances[msg.sender] = balances[msg.sender].add(resultTokens);\r\n        balances[owner] = balances[owner].sub(resultTokens);\r\n        emit Transfer(owner, msg.sender, resultTokens, now);\r\n    }\r\n    \r\n    function toggleCanTransfer(bool enable) public onlyOwner {\r\n         canTransfer = enable;\r\n    }\r\n    \r\n    function transferEnabled() public view returns(bool) {\r\n        return canTransfer;\r\n    }\r\n    \r\n    function transfer(address _to, uint _value) public returns(bool) {\r\n        if(!canTransfer) revert('action_denied');\r\n        if(_to == msg.sender) revert('address_match');\r\n        if(_value == 0) revert('no_tokens');\r\n        if(_value > totalTokens) revert('not_enough_tokens_company');\r\n        if(balances[msg.sender] < _value) revert('not_enough_tokens');\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value, now);\r\n        return true;\r\n    }\r\n    \r\n    function oneTokenCount () public view returns(uint) {\r\n        uint oneEther = 1 ether;\r\n        return (oneEther.mul(10000000).div(oneETHToDollarPrice.mul(1000000000)));\r\n    }\r\n    \r\n    //Показываем общее количество токенов\r\n    function totalSupply() external view returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n    \r\n    function balanceOf(address _owner) view public returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n    \r\n    function checkAccountEthereum() external view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    function sendEtherToOwner(uint amountInWei) external onlyOwner returns(uint) {\r\n        if(address(this).balance < amountInWei) revert(\"not_enough\");\r\n        owner.transfer(amountInWei);\r\n    }\r\n    \r\n    function returnOwner() view public returns (address) {\r\n        return owner;\r\n    }\r\n    \r\n    function addToBalance() external payable onlyOwner{\r\n        \r\n    }\r\n    \r\n}"
    },
    "IERC20A.sol": {
      "content": "pragma solidity ^0.5.11;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20A {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value,\r\n    uint date\r\n  );\r\n}"
    },
    "ProgressiveTokenInterface.sol": {
      "content": "pragma solidity ^0.5.11;\r\ninterface ProgressiveTokenInterface {\r\n    function oneDollarRate() external view returns(uint);\r\n    function oneTokenCount() external view returns(uint);\r\n    function addConvertedTokens(address _address) external;\r\n}"
    },
    "SafeMath.sol": {
      "content": "pragma solidity >=0.4.22 <0.7.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}"
    }
  }
}