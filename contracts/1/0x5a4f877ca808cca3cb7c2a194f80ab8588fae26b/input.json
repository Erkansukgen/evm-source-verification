{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DSProxy.sol":{"content":"pragma solidity ^0.6.0; abstract contract DSGuard {\n    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function permit(address src, address dst, bytes32 sig) public virtual;\n\n    function forbid(address src, address dst, bytes32 sig) public virtual;\n}\n\n\nabstract contract DSGuardFactory {\n    function newGuard() public virtual returns (DSGuard guard);\n} abstract contract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\n} contract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n} contract ProxyPermission {\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n\n    /// @notice Called in the context of DSProxy to authorize an address\n    /// @param _contractAddr Address which will be authorized\n    function givePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n\n    /// @notice Called in the context of DSProxy to remove authority of an address\n    /// @param _contractAddr Auth address which will be removed from authority list\n    function removePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        \n        // if there is no authority, that means that contract doesn't have permission\n        if (currAuthority == address(0)) {\n            return;\n        }\n\n        DSGuard guard = DSGuard(currAuthority);\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n\n    function proxyOwner() internal returns(address) {\n        return DSAuth(address(this)).owner();\n    } \n}"}}}