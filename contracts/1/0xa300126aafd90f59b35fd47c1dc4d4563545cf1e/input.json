{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/example.sol": {
      "content": "pragma solidity ^0.6.2;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract Forwarder {\n  address public destination;\n \n  constructor() public {\n  }\n\n  function flushERC20(address tokenContractAddress) public {\n    IERC20 tokenContract = IERC20(tokenContractAddress);\n    uint256 forwarderBalance = tokenContract.balanceOf(address(this));\n    tokenContract.transfer(destination, forwarderBalance);\n  }\n  \n  function init(address _destination) public {\n      require(destination == address(0x0));\n      destination = _destination;\n  }\n}\n\ncontract ForwarderFactory {\n\n  constructor() public {}\n\n  function cloneForwarder(address forwarder, uint256 salt) public returns (Forwarder clonedForwarder) {\n    address clonedAddress = createClone(forwarder, salt);\n    clonedForwarder = Forwarder(clonedAddress);\n    clonedForwarder.init(Forwarder(forwarder).destination());\n  }\n\n  function createClone(address target, uint256 salt) private returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create2(0, clone, 0x37, salt)\n    }\n  }\n}\n\n\n// function buildCreate2Address(senderAddress, saltHex, bytecode) {\n//   return web3.utils.toChecksumAddress(`0x${web3.utils.sha3(`0x${[\n//     'ff',\n//     senderAddress,\n//     saltHex,\n//     web3.utils.sha3(bytecode)\n//   ].map(x => x.replace(/0x/, ''))\n//     .join('')}`).slice(-40)}`);\n// }"
    }
  }
}