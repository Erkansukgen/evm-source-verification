{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/bridge.sol": {
      "content": "pragma solidity ^0.8.0;\n\n\ninterface IERC721 {\n    function tokenURI(uint256) external view returns (string memory);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function mint(address, string calldata) external returns (uint256);\n\n    function transferFrom(address, address, uint256) external;\n}\n\ncontract BridgeContract {\n    address constant hotwallet = address(0xf2eC2fE12EDfeb03e6241bFC8A8E918B63da4F93);\n    address constant contr = address(0xC8F03267C300B429f79Ecb5Cb1885906cE936A79);\n\n    mapping(uint256 => bool) public withdrawals;\n    mapping(address => bool) public signers;\n\n    mapping(string => bool) public editions;\n\n    uint256 constant w = 0;\n\n    event Deposited(string tokendID, uint256 tokenID);\n    event Minted(string tokendID, string edition, uint256 tokenID, uint8 amount);\n    event Withdrawn(uint256 reqID, uint256 tokenID);\n\n    modifier isSigned(\n        uint256 _prefix,\n        uint256 _requestID,\n        uint256 _tokenID,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _v\n    ) {\n        bytes32 _hash = keccak256(abi.encodePacked(_prefix, msg.sender, _requestID, _tokenID));\n        address signer = ecrecover(_hash, _v, _r, _s);\n\n        require(hotwallet == signer, \"bad-signer\");\n        _;\n    }\n\n    function isSigners(address[] memory _signers) internal view returns (bool) {\n        for (uint8 i = 0; i < _signers.length; i++) {\n            if (!signers[_signers[i]]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function mint(\n        string memory tokendID,\n        string memory tokenURI\n    ) external {\n        uint256 tokenID = IERC721(contr).mint(hotwallet, tokenURI);\n        emit Minted(tokendID, \"\", tokenID, 1);\n    }\n\n    function batchMint(string memory tokendID, string memory tokenURI, uint8 amount) external {\n        uint256 startID = IERC721(contr).mint(hotwallet, tokenURI);\n\n        for (uint8 i = 1; i < amount; i++) {\n            IERC721(contr).mint(hotwallet, tokenURI);\n        }\n        emit Minted(tokendID, \"\", startID, amount);\n    }\n\n    function mintBySelf(string memory tokendID, string memory tokenURI) external {\n        uint256 tokenID = IERC721(contr).mint(msg.sender, tokenURI);\n        IERC721(contr).transferFrom(msg.sender, hotwallet, tokenID);\n        emit Minted(tokendID, \"\", tokenID, 1);\n    }\n\n    function batchMintBySelf(string memory tokendID, string memory tokenURI, string memory edition, uint8 amount) external {\n        require(!editions[edition], \"such-edition-already-exist\");\n        uint256 startID = IERC721(contr).mint(hotwallet, tokenURI);\n\n        for (uint8 i = 1; i < amount; i++) {\n            IERC721(contr).transferFrom(msg.sender, hotwallet, IERC721(contr).mint(msg.sender, tokenURI));\n        }\n\n        editions[edition] = true;\n        emit Minted(tokendID, edition, startID, amount);\n    }\n\n    function deposit(string memory tokendID, uint256 tokenID) external {\n        IERC721(contr).transferFrom(msg.sender, hotwallet, tokenID);\n        emit Deposited(tokendID, tokenID);\n    }\n\n    function withdraw(\n        uint256 withdrawID,\n        uint256 tokenID,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _v\n    ) external isSigned(w, withdrawID, tokenID, _r, _s, _v) {\n        require(!withdrawals[withdrawID], \"such-withdraw-already-used\");\n        IERC721(contr).transferFrom(hotwallet, msg.sender, tokenID);\n        emit Withdrawn(withdrawID, tokenID);\n    }\n\n    function lazyWithdraw(\n        uint256 withdrawID,\n        string memory tokenURI,\n        bytes32 _r,\n        bytes32 _s,\n        uint8 _v\n    ) external isSigned(w, withdrawID, 0, _r, _s, _v) {\n        require(!withdrawals[withdrawID], \"such-withdraw-already-used\");\n        uint256 tokenID = IERC721(contr).mint(hotwallet, tokenURI);\n        IERC721(contr).transferFrom(hotwallet, msg.sender, tokenID);\n        emit Withdrawn(withdrawID, tokenID);\n    }\n}"
    }
  }
}