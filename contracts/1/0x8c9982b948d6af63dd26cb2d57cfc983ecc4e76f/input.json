{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RoyaltyNFT10.sol":{"content":"// SPDX-License-Identifier: private\r\n//\r\n// Single NFToken\r\n\r\npragma solidity ^0.7.0;\r\npragma abicoder v2;\r\n\r\ncontract RoyaltyNFT {\r\n\r\n    address private _admin;\r\n\t\r\n    // Token long name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n\tstring private tagA;\r\n\tuint N = 10; // total NFTs\r\n//\tstring tag[10]; // owner's tag - requiremapping for strings\r\n\r\n    // Mapping from token ID to owner address\r\n    address [10] public _owner;\r\n\tuint256 [10] public _salePrice;\r\n\tuint [10]  public _royaltyPercent;\r\n\t\r\n\taddress [10] public _royaltyReceiver; // first owner of the tokenId\r\n\r\n\tstruct Sale {\r\n\t\taddress Seller;\r\n\t\tuint256 Price;\r\n\t\taddress Author; // royalty receiver\r\n\t\tuint256 RoyaltyAmount;\r\n\t}\r\n\t\r\n    // Mapping owner address to token count\r\n    mapping (address => uint256) private _balances;\r\n\r\n\t//Declare an Event\r\n\t//event TokenTransferred(address _from, address _to, address _by);\r\n\r\n//    constructor(string memory name_, string memory symbol_) \r\n    constructor () {\r\n\t\t_admin = msg.sender;\r\n        _name = \"Independence Day - July 4, 2021\";\r\n        _symbol = \"US21\";\r\n\r\n\t\ttagA= \"2021 US intelligence report on UFOs: No aliens\";\r\n        for (uint i=0; i<N; i++) { // initialize attributes of all NFTs\r\n\t\t\t_owner[i] = msg.sender;\r\n\t\t\t_royaltyReceiver[i] = msg.sender;\r\n\t\t\t_salePrice[i] = 0;\r\n\t\t\t_royaltyPercent[i] = 3;\r\n\t\t\t\r\n//\t\t\ttag[i] = \"User Tag\";\r\n\t\t}\r\n    }\r\n\r\n    function transferFrom( uint tokenId, address from, address to ) // \r\n    public virtual {\r\n\r\n\t\trequire(msg.sender == _admin, \"Only Admin\"); // only Admin can do first transfer\r\n\t\t\r\n\t\trequire(from == _owner[tokenId], \"no Token\");\r\n        _owner[tokenId] = to;\r\n\t\t_royaltyReceiver[tokenId] = to;\r\n\t\t\r\n        //_balances[from] -= 1;\r\n        //_balances[to] += 1;\r\n\r\n\t\t//emit TokenTransferred(from, to, msg.sender);\r\n    }\r\n\r\n\tfunction saleInfo(uint tokenId) public view returns(Sale memory) {\r\n\t\tSale memory s;\r\n\t\ts.Seller = _owner[tokenId];\r\n\t\ts.Price = _salePrice[tokenId];\r\n\t\ts.Author = _royaltyReceiver[tokenId];\r\n\t\ts.RoyaltyAmount = s.Price * _royaltyPercent[tokenId] / 100;\r\n\t\treturn s;\r\n\t}\r\n\r\n\tfunction setSale(uint tokenId, uint256 price) public returns(uint256 royalAmount) {\r\n\r\n\t\tif (msg.sender != _admin) { // Admin can do anyting\r\n\t\t\trequire(msg.sender == _owner[tokenId], \"Not yours\");\r\n\t\t\trequire(price > 100, \"Low Price\");\r\n\t\t}\r\n\t\t\r\n\t\t_salePrice[tokenId] = price;\r\n\t\t\r\n\t\treturn price * _royaltyPercent[tokenId] / 100;\r\n\t}\r\n\r\n    function payEther(address payable _to, uint _amount) public {  // pay ether in WEI from CONTRACT\r\n        // Note that \"to\" is declared as payable\r\n        (bool success, bytes memory data) = _to.call{value: _amount}(\"\");\r\n        require(success, \"Failed to send Ether\");\r\n    }\r\n\r\n\tfunction buyToken(uint tokenId) public payable { // get money, trnafer token, pay Royalty\r\n        uint payment = msg.value;\r\n        require(payment >= _salePrice[tokenId], \"insufficient funds\");\r\n        uint royalty = payment * _royaltyPercent[tokenId] / 100;\r\n        uint profit = _salePrice[tokenId] * (100 - _royaltyPercent[tokenId]) / 100;\r\n        payEther( payable(_owner[tokenId]), profit );\r\n        payEther( payable(_royaltyReceiver[tokenId]), royalty );\r\n         _owner[tokenId] = msg.sender;\r\n\t}\r\n\r\n    function saleFrom( uint tokenId, address from, address to ) public { // \r\n        _owner[tokenId] = to;\r\n\t}\r\n//\t\r\n\tfunction inspectSender() public view returns(address) {\r\n        return msg.sender;\r\n    }\r\n\tfunction inspectAdmin() public view returns(address) {\r\n        return _admin;\r\n    }\r\n//\r\n    function inspectOwner(uint tokenId) public view returns(address) { //\r\n        return _owner[tokenId];\r\n    }\r\n\tfunction inspectToken(uint tokenId) public view returns(string memory) {\r\n       return string(abi.encodePacked(_symbol,\" | \",_name));\r\n    }\r\n\r\n\tfunction inspectTagA() public view returns(string memory) {\r\n        return tagA;\r\n    }\r\n\tfunction modifyTagA(string calldata newTagA) public returns(string memory) {\r\n        require(msg.sender == _admin, \"Not allowed\");\r\n\t\ttagA = newTagA;\r\n        return tagA;\r\n    }\r\n\r\n//=====================================================================================    \r\n    // Function to receive Ether. msg.data must be empty\r\n    receive() external payable {}\r\n\r\n    // Fallback function is called when msg.data is not empty\r\n    fallback() external payable {}\r\n\r\n    function getBalance() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n} // end of Contract\r\n"}}}