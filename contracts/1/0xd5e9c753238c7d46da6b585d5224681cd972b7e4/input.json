{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/BuildBlockDemo.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2020-05-17\n*/\n\npragma solidity ^0.6.6;\n\n/**\n * @title Blockd Build Demo\n * \n * @dev This is Blockd's demo contract for Blockd Build.\n *      In this contract we have multiple functions with big vulnerabilities\n *      that emulate big contract hacks that have happened in the past.\n * \n *      If a user attempts to take advantage of these vulnerabilities,\n *      Blockd Build will race their transaction to blacklist them before\n *      their hack can execute.\n * \n *      Blacklisting is used instead of a contract-wide pause or something less \n *      centralized to make public testing less complicated. For the same reason,\n *      we pad the gas required for each function so as to not go broke when racing\n *      every person who attempts to hack the contract.\n * \n *      Enjoy testing Blockd Build and good luck hacking this contract!\n * \n *      P.S. This is not a honeypot! To attempt a hack, you need no Ether deposited.\n *      If you deposit Ether, you can withdraw that same amount just fine.\n * \n * @author Robert M.C. Forster, Blockd L.L.C.\n**/\ncontract BlockdBuildDemo {\n    \n    // Owner of the contract. For the purposes of this demo, despite making the contract\n    // somewhat centralized, this address is allowed to blacklist users.\n    address public owner;\n    \n    // Balances mapping. Users *should* never be able to withdraw more than is in here.\n    mapping (address => uint256) public balances;\n    \n    // Ether price set by oracle. Doesn't have much of a purpose in this demo besides an example.\n    uint256 public etherPrice;\n    \n    // Blacklist potential hackers on the contract. This centralizes things a bit and wouldn't\n    // normally be suggested for Blockd Build, but a contract-wide pause would complicate testing.\n    mapping (address => bool) public blacklist;\n    \n    // Arbitrary variable used to pad gas costs.\n    uint256 private padVar;\n    \n    /**\n     * @dev Set owner and Ether price..\n    **/\n    constructor()\n      public\n    {\n        owner       = msg.sender;\n        etherPrice  = 1;\n    }\n    \n    /**\n     * @dev Owner may transfer ownership of the contract.\n     * @param _newOwner The new address that will have power over blacklisting.\n     * @notice Uh-oh, this has no require! Anyone can call this successfully!\n    **/\n    function transferOwner( address _newOwner )\n      public\n      padGas\n      notBLorSC\n    {\n        owner = _newOwner;\n    }\n    \n    /**\n     * @dev Callback may be used by Oracle to set new Ether price.\n     *      API data is gotten from: \"https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD\"\n     *      Callback must equal USD value * 100\n     * @param _etherPrice The new price of Ether (should always be 1).\n     * @notice Uh-oh, this function does not check that sender is Oraclize!\n    **/\n    function callback( uint256 _etherPrice )\n      public\n      padGas\n      notBLorSC\n    {\n        etherPrice = _etherPrice;\n    }\n    \n    /**\n     * @dev Allows users to withdraw funds from their balances.\n     * @param _amount The amount of funds the user would like to withdraw.\n     * @notice Uh-oh, this doesn't check to make sure the user has enough balance!\n    **/\n    function withdraw( uint256 _amount )\n      public\n      padGas\n      notBLorSC\n    {\n        msg.sender.transfer( _amount );\n        \n        // Let's at least avoid underflows.\n        uint256 balance = balances[msg.sender];\n        if (balance - _amount < balance) balances[msg.sender] -= _amount;\n    }\n    \n    /**\n     * @dev Allows users to deposit funds into their balance.\n     * @notice Not a vulnerable function. Simply exists to allow other vectors to be tested\n     *         and to demonstrate that an allowed deposit/withdrawal will execute normally.\n    **/\n    function deposit()\n      public\n      payable\n      padGas\n      notBLorSC // Let's not let users deposit if they can't withdraw.\n    {\n        balances[ msg.sender ] += msg.value;    \n    }\n    \n    /**\n     * @dev Allows the owner to blacklist hackers from interacting with the contract.\n     * @param _user The address to be blacklisted.\n     * @param _blacklist True to blacklist user, false to take user off blacklist.\n     * @notice This function is made to not be vulnerable by requiring the sender to be owner.\n    **/\n    function blacklistUser( address _user, bool _blacklist )\n      public\n    {\n        require( msg.sender == owner );\n        blacklist[ _user ]  = _blacklist;\n    }\n    \n    /**\n     * @dev Make sure the sender has not been blacklisted for attempting to hack this contract.\n     *      Smart contracts are also blocked on this contract to simplify demo.\n    **/\n    modifier notBLorSC {\n        require( !blacklist[ msg.sender ] );\n        require( msg.sender == tx.origin );\n        _;\n    }\n    \n    /**\n     * @dev For this demo contract, we're going to pad function gas costs because,\n     *      with the amount of hacks we'll have to deal with, the low cost of these hacks,\n     *      and the fact that we don't do a pause but continually just block single hackers,\n     *      it would get very expensive for us to block everyone who would to race us.\n     *      This should add 200,000 to the gas cost, ensuring a successful race would require\n     *      around 10x the cost of a blacklist transaction.\n    **/\n    modifier padGas {\n        for ( uint256 i = 1; i < 200; i++ ) {\n            padVar = i;\n        }\n        _;\n    }\n    \n    function test() public returns (bool) {\n        return msg.sender == tx.origin;\n    }\n    \n}\n\ncontract Hackify {\n    event RIP (\n        string reason\n    );\n    \n    constructor(address target) public {\n        BlockdBuildDemo bbd = BlockdBuildDemo(target);\n        if (bbd.blacklist(msg.sender) || bbd.blacklist(address(this))) {\n            revert(\"Error\");\n        }\n\n        address owner = bbd.owner();\n        (bool success, bytes memory result) = target.delegatecall(abi.encodeWithSignature(\"transferOwner(address)\", msg.sender));\n        if (!success) {\n            emit RIP(\"Failure to launch.\");\n            return;\n        }\n\n        (bool success2, bytes memory result2) = target.delegatecall(abi.encodeWithSignature(\"blacklistUser(address,bool)\", owner, true));\n    }\n}"
    }
  }
}