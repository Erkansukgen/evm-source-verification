{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/ousdkeeper.sol": {
      "content": "pragma solidity 0.8.7;\n\ninterface KeeperCompatibleInterface {\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n    function performUpkeep(bytes calldata performData) external;\n}\n\n\ncontract OusdKeeper is KeeperCompatibleInterface {\n    struct Config {\n        uint24 windowStart;\n        uint24 windowEnd;\n    }\n    address constant vault = 0xE75D77B1865Ae93c7eaa3040B038D7aA7BC02F70;\n    uint24 immutable windowStart; // seconds after start of day\n    uint24 immutable windowEnd; // seconds after start of day\n    uint256 lastRunDay = 0;\n\n    constructor(\n        uint24 _windowStart,\n        uint24 _windowEnd\n    ) {\n        windowStart = _windowStart;\n        windowEnd = _windowEnd;\n    }\n\n    function checkUpkeep(bytes calldata checkData)\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        // If either can run, let's go!\n        (bool runRebase, bool runAllocate) = _shouldRun(checkData);\n        upkeepNeeded = (runRebase || runAllocate);\n        performData = checkData;\n    }\n\n    function performUpkeep(bytes calldata performData) external override {\n        (bool runRebase, bool runAllocate) = _shouldRun(performData);\n        if (runRebase || runAllocate) {\n            // write today, so that we only run once per day\n            lastRunDay = (block.timestamp / 86400);\n        }\n        \n        // Allocate before rebase, so the rebase picks up the harvested rewards.\n        // \n        // Both commands run and do not revert if they fail so that the last run\n        // day is still written the keepers do empty their gas running the\n        // failing method over and over again.\n\n        if (runAllocate) {\n            vault.call(abi.encodeWithSignature(\"allocate()\"));\n        }\n        if (runRebase) {\n            vault.call(abi.encodeWithSignature(\"rebase()\"));\n        }\n    }\n\n    function _shouldRun(bytes memory performData)\n        internal\n        view\n        returns (bool runRebase, bool runAllocate)\n    {\n        // Have we run today?\n        uint256 day = block.timestamp / 86400;\n        if (lastRunDay >= day) {\n            return (false, false);\n        }\n\n        // Are we in the window?\n        uint256 daySeconds = block.timestamp % 86400;\n        if (daySeconds < windowStart || daySeconds > windowEnd) {\n            return (false, false);\n        }\n\n        // Load schedule\n        require(performData.length == 2, \"Wrong schedule format\");\n        uint8 rebaseDays = uint8(performData[0]); // day of week bits\n        uint8 allocateDays = uint8(performData[1]); // day of week bits\n\n        // Weekday\n        uint8 weekday = uint8((day + 4) % 7);\n        // Need a rebase?\n        if (((rebaseDays >> weekday) & 1) != 0) {\n            runRebase = true;\n        }\n        // Need an allocate?\n        if (((allocateDays >> weekday) & 1) != 0) {\n            runAllocate = true;\n        }\n    }\n}\n"
    }
  }
}