{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DydxFL/aave.sol":{"content":"pragma solidity ^0.6.0;\n\n// import files from common directory\ninterface TokenInterface {\n    function allowance(address, address) external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n    function approve(address, uint) external;\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ninterface AaveInterface {\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external payable;\n    function redeemUnderlying(\n        address _reserve,\n        address payable _user,\n        uint256 _amount,\n        uint256 _aTokenBalanceAfterRedeem\n    ) external;\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external;\n    function getUserReserveData(address _reserve, address _user) external view returns (\n        uint256 currentATokenBalance,\n        uint256 currentBorrowBalance,\n        uint256 principalBorrowBalance,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint256 liquidityRate,\n        uint256 originationFee,\n        uint256 variableBorrowIndex,\n        uint256 lastUpdateTimestamp,\n        bool usageAsCollateralEnabled\n    );\n    function borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external;\n    function repay(address _reserve, uint256 _amount, address payable _onBehalfOf) external payable;\n}\n\ninterface AaveProviderInterface {\n    function getLendingPool() external view returns (address);\n    function getLendingPoolCore() external view returns (address);\n}\n\ninterface AaveCoreInterface {\n    function getReserveATokenAddress(address _reserve) external view returns (address);\n}\n\ninterface ATokenInterface {\n    function redeem(uint256 _amount) external;\n    function balanceOf(address _user) external view returns(uint256);\n    function principalBalanceOf(address _user) external view returns(uint256);\n}\n\ncontract DSMath {\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"math-not-safe\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"math-not-safe\");\n    }\n\n    uint constant WAD = 10 ** 18;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n}\n\n\ncontract Helpers is DSMath {\n    /**\n     * @dev Return ethereum address\n     */\n    function getAddressETH() internal pure returns (address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\n    }\n\n    function getAddressWETH() internal pure returns (address) {\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\n        // return 0xd0A1E359811322d97991E03f863a0C30C2cF029C; // kovan\n    }\n\n    function isETH(address token) internal pure returns(bool) {\n        return token == getAddressETH() || token == getAddressWETH();\n    }\n}\n\n\ncontract AaveHelpers is DSMath, Helpers {\n\n    /**\n     * @dev get Aave Provider\n    */\n    function getAaveProvider() internal pure returns (AaveProviderInterface) {\n        return AaveProviderInterface(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8); //mainnet\n        // return AaveProviderInterface(0x506B0B2CF20FAA8f38a4E2B524EE43e1f4458Cc5); //kovan\n    }\n\n    /**\n     * @dev get Referral Code\n    */\n    function getReferralCode() internal pure returns (uint16) {\n        return 3228;\n    }\n\n    function getIsColl(AaveInterface aave, address token) internal view returns (bool isCol) {\n        (, , , , , , , , , isCol) = aave.getUserReserveData(token, address(this));\n    }\n\n    function getWithdrawBalance(address token) internal view returns (uint bal) {\n        AaveInterface aave = AaveInterface(getAaveProvider().getLendingPool());\n        (bal, , , , , , , , , ) = aave.getUserReserveData(token, address(this));\n    }\n\n    function getPaybackBalance(AaveInterface aave, address token) internal view returns (uint bal, uint fee) {\n        (, bal, , , , , fee, , , ) = aave.getUserReserveData(token, address(this));\n    }\n}\n\n\ncontract BasicResolver is AaveHelpers {\n    event LogDeposit(address indexed token, uint256 tokenAmt);\n    event LogWithdraw(address indexed token);\n    event LogBorrow(address indexed token, uint256 tokenAmt);\n    event LogPayback(address indexed token, uint256 tokenAmt);\n\n    /**\n     * @dev Deposit ETH/ERC20_Token.\n     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amt token amount to deposit.\n    */\n    function deposit(address token, uint amt) external payable {\n        uint _amt = amt;\n        AaveInterface aave = AaveInterface(getAaveProvider().getLendingPool());\n\n        uint ethAmt;\n        if (isETH(token)) {\n            _amt = _amt == uint(-1) ? address(this).balance : _amt;\n            ethAmt = _amt;\n        } else {\n            TokenInterface tokenContract = TokenInterface(token);\n            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\n            tokenContract.approve(getAaveProvider().getLendingPoolCore(), _amt);\n        }\n\n        aave.deposit.value(ethAmt)(token, _amt, getReferralCode());\n\n        if (!getIsColl(aave, token)) aave.setUserUseReserveAsCollateral(token, true);\n\n        emit LogDeposit(token, _amt);\n    }\n\n    /**\n     * @dev Withdraw ETH/ERC20_Token.\n     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amt token amount to withdraw.\n    */\n    function withdraw(address token, uint amt) external payable {\n        AaveCoreInterface aaveCore = AaveCoreInterface(getAaveProvider().getLendingPoolCore());\n        ATokenInterface atoken = ATokenInterface(aaveCore.getReserveATokenAddress(token));\n\n        atoken.redeem(amt);\n\n        emit LogWithdraw(token);\n    }\n\n    /**\n     * @dev Borrow ETH/ERC20_Token.\n     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amt token amount to borrow.\n    */\n    function borrow(address token, uint amt) external payable {\n        uint _amt = amt;\n        AaveInterface aave = AaveInterface(getAaveProvider().getLendingPool());\n        aave.borrow(token, _amt, 2, getReferralCode());\n        \n\n        emit LogBorrow(token, _amt);\n    }\n\n    /**\n     * @dev Payback borrowed ETH/ERC20_Token.\n     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n     * @param amt token amount to payback.\n    */\n    function payback(address token, uint amt) external payable {\n        uint _amt = amt;\n        AaveInterface aave = AaveInterface(getAaveProvider().getLendingPool());\n\n        if (_amt == uint(-1)) {\n            uint fee;\n            (_amt, fee) = getPaybackBalance(aave, token);\n            _amt = add(_amt, fee);\n        }\n        uint ethAmt;\n        if (isETH(token)) {\n            ethAmt = _amt;\n        } else {\n            TokenInterface(token).approve(getAaveProvider().getLendingPoolCore(), _amt);\n        }\n\n        aave.repay.value(ethAmt)(token, _amt, payable(address(this)));\n\n        emit LogPayback(token, _amt);\n    }\n}\n\ncontract ConnectAave is BasicResolver {\n    string public name = \"flashloan-Aave-v1.0\";\n}"}}}