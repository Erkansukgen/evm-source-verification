{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"HoldAndFlashloan.sol":{"content":"pragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface ERC20 {\n    function decimals() external view returns (uint);\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n}\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'OB TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'OB TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'OB TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'OB TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\n\ninterface IFlashLoanCaller {\n    function borrow(address _token, uint256 _amount, bytes calldata _data) external;\n}\n\n\ncontract VirtualAddress {\n    \n    function safeTransfer(address token, address to, uint value) public {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'VA TransferHelper: TRANSFER_FAILED');\n    }\n    \n    function destory(address payable receipt) public {\n         selfdestruct(receipt);\n    }\n    \n}\n\ncontract TempContractCreator {\n    \n    VirtualAddress public virtualAddress;\n    \n    function createContract() external {\n        virtualAddress = new VirtualAddress();\n    }\n    \n    function createTempContract(uint factor) public returns (VirtualAddress) {\n        address createdAddress = _createTempContract(factor);\n        return VirtualAddress(createdAddress);\n    }\n    \n    function _createTempContract(uint factor) internal returns (address) {\n\n        address createdAddress;\n        \n        bytes memory bytecode = type(VirtualAddress).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(factor));\n        assembly {\n            createdAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        \n        return createdAddress;\n    }\n    \n    function getTempContract(uint a) public view returns (address) {\n        bytes32 salt = keccak256(abi.encodePacked(a));\n        bytes32 init_code = getInitCodeHash();\n        \n        address createdAddress;\n        createdAddress = address(uint(keccak256(abi.encodePacked(\n            hex'ff',\n            address(this),\n            salt,\n            init_code // init code hash\n        ))));\n        \n        return createdAddress;\n    } \n    \n    function getInitCodeHash() public pure returns (bytes32) {\n        bytes memory bytecode = type(VirtualAddress).creationCode;\n        bytes32 init_code = keccak256(bytecode);\n        return init_code;\n    }\n    \n}\n\ncontract PermissionGroups{\n    \n    address public admin = 0x143395428158A57d17Bcd8899770460656De98E4;\n    address public pendingAdmin;\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"onlyAdmin\");\n        _;\n    }\n\n    function transferAdmin(address newAdmin) external onlyAdmin {\n        pendingAdmin = newAdmin;\n    }\n\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender,\"pendingAdmin != msg.sender\");\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n}\n\n\ncontract AssetManager is PermissionGroups{\n    \n    receive() external payable{}\n    fallback() external payable{}\n    \n    function withdrawEth(address payable _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        _to.transfer(_value);\n    }\n    \n    function withdrawToken(address _token, address _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        TransferHelper.safeTransfer(_token,_to,_value);\n    }\n    \n    function approveIfZero(address token, address spender) internal {\n        uint tokenAllowance = ERC20(token).allowance(address(this), spender);\n        if (tokenAllowance == 0) {\n            TransferHelper.safeApprove(token, spender, uint256(-1));\n        }\n    }\n    \n    function doApprove(address token, address spender, uint value) external onlyAdmin {\n        TransferHelper.safeApprove(token, spender, value);\n    }\n\n}\n\ncontract HoldAndFlashloan is AssetManager,TempContractCreator{\n\n    address public flashloanCallerAddress = 0xAaE0633E15200bc9C50d45cD762477D268E126BD;\n    address payable public incomeReceipt = 0x2dFC0193868BA5789D14Dd335114fda677fc8830;\n    \n    function setIncomeReceipt(address payable _incomeReceipt) external onlyAdmin {\n        incomeReceipt = _incomeReceipt;\n    }\n\n    function setFlashloanCaller(address _flashloanCaller) external onlyAdmin {\n        flashloanCallerAddress = _flashloanCaller;\n    }\n\n    function flasnloanSwap(address token, uint256 amount, bytes calldata _data) external  {\n        IFlashLoanCaller(flashloanCallerAddress).borrow(token,amount,_data);\n    }\n\n    function repay(uint hedgeType, uint borrowAmount, address borrowToken, address hedgeToken, uint factor, address[] calldata callerList, bytes[] calldata _dataList) external {\n\n        // uint borrowAmount = ERC20(borrowToken).balanceOf(address(this));\n    \n        if (hedgeType == 1) {\n             // hedgeSwap (weth -> ht, uniswap: exactOut) -> 1inch, hold swap (ht -> weth)\n            hedgeSwap(borrowToken,callerList[0],_dataList[0]);\n            holdAndSwap(hedgeToken,borrowToken,factor,callerList[1],_dataList[1]);\n        }\n        else {\n            // 1inch, hold swap (weth -> ht)->  hedgeSwap (ht -> weth , uniswap: exactIn)  \n            holdAndSwap(borrowToken,hedgeToken,factor,callerList[0],_dataList[0]);\n            hedgeSwap(hedgeToken,callerList[1],_dataList[1]);\n        }\n        \n        TransferHelper.safeTransfer(borrowToken,flashloanCallerAddress,borrowAmount+1);\n        \n        claimIncome(borrowToken);\n        claimIncome(hedgeToken);\n    }\n    \n     function hedgeSwap(address token, address caller, bytes memory _data)  internal {\n        approveIfZero(token, caller); \n        (bool success,) = caller.call(_data);\n        require(success,\"hedgeSwap bridgeCall failed!\");\n     }\n\n    function holdAndSwap(address fromToken, address toToken, uint factor, address caller, bytes memory _data) public {\n        address _virtualAddress = _createTempContract(factor);\n        \n        approveIfZero(fromToken, caller); \n        (bool success,) = caller.call(_data);\n        require(success,\"holdAndSwap bridgeCall failed!\");\n\n        uint receivedAmount = ERC20(toToken).balanceOf(_virtualAddress);\n        VirtualAddress(_virtualAddress).safeTransfer(toToken,address(this),receivedAmount);\n        VirtualAddress(_virtualAddress).destory(incomeReceipt);\n    }\n\n    function claimIncome(address token) internal {\n        uint left = ERC20(token).balanceOf(address(this));\n        if (left > 0) {\n            TransferHelper.safeTransfer(token,incomeReceipt,left);\n        }\n    }\n    \n}\n\n"}}}