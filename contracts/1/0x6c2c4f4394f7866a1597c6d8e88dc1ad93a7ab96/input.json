{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/splink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() external virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    function transferOwnership(address newOwner) external virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n    \n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    // solhint-disable-next-line\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ninterface IUniswapV2Router is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {} // solhint-disable-line\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {} // solhint-disable-line\n}\n\ninterface ISPLINK is IERC20 {\n\n    event TaxAddressChanged(address newTaxAddress);\n    event TaxedTransferAddedFor(address[] addresses);\n    event TaxedTransferRemovedFor(address[] addresses);\n\n    event TaxTaken(uint256 teamFee);\n    event TaxChanged(Tax newFees);\n\n    struct Tax {\n        uint256 buyTax;\n        uint256 sellTax;\n    }\n\n    function currentFees() external view returns (Tax memory);\n\n\n    function taxedPair(address pair) external view returns (bool);\n}\n\nlibrary Utils {\n    /**\n     * @dev Calculates the percentage of a number\n     * @param number: The number to calculate the percentage of\n     * @param percentage: The percentage of the number to return\n     * @return The percentage of a number\n     */\n    function percentageOf(uint256 number, uint256 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (number * percentage) / 100;\n    }\n\n    /**\n     * @dev Swaps an amount of tokens for ETH\n     * @param uniswapV2Router: The uniswap router to trade through\n     * @param amount: The amount of tokens to swap\n     * @param to: The address to send the recieved tokens to\n     * @return The amount of ETH recieved\n     */\n    function swapForETH(\n        IUniswapV2Router uniswapV2Router,\n        uint256 amount,\n        address to\n    ) internal returns (uint256) {\n        uint256 startingBalance = to.balance;\n        address[] memory path = new address[](2);\n\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            amount,\n            0,\n            path,\n            to,\n            block.timestamp\n        );\n\n        return to.balance - startingBalance;\n    }\n\n    /**\n     * @dev Adds liquidity for the token in ETH\n     * @param uniswapV2Router: The uniswap router to add liquidity through\n     * @param amountToken: The amount of tokens to add liquidity with\n     * @param amountETH: The amount of ETH to add liquidity with\n     * @param to: The address to send the recieved LP tokens to\n     */\n    function addLiquidityETH(\n        IUniswapV2Router uniswapV2Router,\n        uint256 amountToken,\n        uint256 amountETH,\n        address to\n    ) internal {\n        uniswapV2Router.addLiquidityETH{value: amountETH}(\n            address(this),\n            amountToken,\n            0,\n            0,\n            to,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @param token: The address of the token to transfer\n     * @param from: The sender of the tokens\n     * @param to: The receiver of the tokens\n     * @param amount: The amount of tokens to transfer\n     */\n    function transferTokens(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        IERC20(token).transferFrom(from, to, amount);\n    }\n\n    /**\n     * @dev Returns the token for a Uniswap V2 Pair\n     */\n    function tokenFor(address pair) internal view returns (address) {\n        return IUniswapV2Pair(pair).token0();\n    }\n\n    /**\n    * @dev Checks if transaction amount is below max\n    * @param amount: The amount to be transferred\n    */\n    function isNotGreaterThanMaxTXLimit(uint256 amount) internal pure returns (bool) {\n      uint256 MAX_TX = 10000000000000 * 10**9; \n      return amount <= MAX_TX;\n    }\n\n    /**\n    * @dev Checks if wallet balance has reached max balance per wallet\n    * @param balanceOfWallet: the balance of wallet to be checked\n    */\n    function balanceIsLessThanMax(uint256 balanceOfWallet ) internal pure returns (bool) {\n      uint256 MAX_BALANCE = 15000000000000 * 10**9; \n      return balanceOfWallet <= MAX_BALANCE;\n    }\n}\n\ncontract SPLINK is ISPLINK, Ownable, ERC20 {\n   using SafeMath for uint256;\n\n    uint256 internal constant MAX = type(uint256).max;\n\n    uint256 private constant SUPPLY = 1000000000000000 * 10**9; \n    string internal constant NAME = \"Space Link\";\n    string internal constant SYMBOL = \"SPLINK\";\n    uint8 internal constant DECIMALS = 9;\n\n    mapping(address => address) internal _routerFor;\n    mapping(address => bool) private _isWhitelisted;\n    mapping(address => bool) private _isTaxExempted;\n    mapping (address => bool) private bots;\n    mapping (address => uint) private cooldown;\n\n    Tax private fees;\n\n    address payable internal _taxAddress;\n\n    IUniswapV2Router internal uniswapV2Router;\n    address internal uniswapV2Pair;\n\n    bool public tradingOpen;\n    bool public liquidityAdded;\n    bool private inSwap;\n    bool public swapEnabled;\n    bool private whiteListActive;\n    bool public cooldownEnabled;\n\n    modifier lockTheSwap() {\n        inSwap = true;\n        _;\n        inSwap = false;\n    }\n\n    constructor(address payable addr1) ERC20(NAME, SYMBOL) {\n        _taxAddress = addr1;\n        _mint(_msgSender(), SUPPLY);\n        fees = Tax(8,8);\n    }\n\n    function decimals() public pure virtual override returns (uint8) {\n        return DECIMALS;\n    }\n    \n    function taxedPair(address pair)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _routerFor[pair] != address(0);\n    }\n\n    // Transfer, no events for fees\n    function transferFee(address from, uint256 amount) internal {\n        _balances[from] -= amount;\n        _balances[address(this)] += amount;\n    }\n\n    function takeFee(\n        address from,\n        uint256 amount,\n        uint256 teamFee\n    ) internal returns (uint256) {\n        if (teamFee == 0) return 0;\n        uint256 tTeam = Utils.percentageOf(amount, teamFee);\n        transferFee(from, tTeam);\n        emit TaxTaken(tTeam);\n        return tTeam;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        // If no fee, 0\n        uint256 _teamFee;\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to], \"SPLINK: Currrently tagged as a bot\");\n            \n            \n            if (liquidityAdded) {\n                require(tradingOpen, \"SPLINK: Trading is not Open\");\n           \n            \n                if (whiteListActive) {\n                     require(_isWhitelisted[to],  \"SPLINK: Address must be whitelisted\");\n                }\n\n                if (swapEnabled && !inSwap) {\n     \n                     if (taxedPair(from) && !taxedPair(to)) {\n                       uint256 walletBalance = balanceOf(to).add(amount);\n                      // buying transfer\n                        require(Utils.isNotGreaterThanMaxTXLimit(amount), \"SPLINK: Max tx exceeded\");\n                        require(Utils.balanceIsLessThanMax(walletBalance), \"SPLINK: Max holding exceeded\");\n    \n                        if (cooldownEnabled) {\n                          require(cooldown[to] < block.timestamp);\n                          cooldown[to] = block.timestamp + (30 seconds);\n                        }\n                        \n                        _teamFee = _isTaxExempted[to] ? 0 : fees.buyTax;\n                    }  else if (taxedPair(to)) {\n                      // selling transfer\n                        swapTokensForEth(balanceOf(address(this)));\n                        sendETHToFee(address(this).balance);\n                        _teamFee = _isTaxExempted[from] ? 0 : fees.sellTax;\n                    }\n                  \n                } else {\n                    require(swapEnabled, \"SPLINK: Swap must be enabled\");\n                }\n            }\n        }\n\n        uint256 fee = takeFee(from, amount, _teamFee);\n        super._transfer(from, to, amount - fee);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) internal lockTheSwap {\n        Utils.swapForETH(uniswapV2Router, tokenAmount, address(this));\n    }\n\n    function sendETHToFee(uint256 amount) internal {\n        _taxAddress.transfer(amount);\n    }\n\n    function openTrading() external virtual onlyOwner {\n        require(liquidityAdded);\n        tradingOpen = true;\n        cooldownEnabled = true;\n        swapEnabled = true;\n    }\n    \n    function toggleWhiteList(bool onOff) external virtual onlyOwner {\n       whiteListActive = onOff;\n    }\n\n    function addDEX(address pair, address router) public virtual onlyOwner {\n        require(!taxedPair(pair), \"DEX already exists\");\n        address tokenFor = Utils.tokenFor(pair);\n        _routerFor[pair] = router;\n        _approve(address(this), router, MAX);\n        IERC20(tokenFor).approve(router, MAX);\n        IERC20(pair).approve(router, MAX);\n    }\n\n    function removeDEX(address pair) external virtual onlyOwner {\n        require(taxedPair(pair), \"DEX does not exist\");\n        address tokenFor = Utils.tokenFor(pair);\n        address router = _routerFor[pair];\n        delete _routerFor[pair];\n        _approve(address(this), router, 0);\n        IERC20(tokenFor).approve(router, 0);\n        IERC20(pair).approve(router, 0);\n    }\n\n    function addLiquidity() external virtual onlyOwner lockTheSwap {\n        IUniswapV2Router _uniswapV2Router = IUniswapV2Router(\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n        );\n        uniswapV2Router = _uniswapV2Router;\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n        addDEX(uniswapV2Pair, address(_uniswapV2Router));\n        Utils.addLiquidityETH(\n            uniswapV2Router,\n            balanceOf(address(this)),\n            address(this).balance,\n            owner()\n        );\n        liquidityAdded = true;\n    }\n\n    function setBots(address[] calldata bots_) public onlyOwner {\n        for (uint i = 0; i < bots_.length; i++) {\n            bots[bots_[i]] = true;\n        }\n    }\n    \n    function delBot(address notbot) public onlyOwner {\n        bots[notbot] = false;\n    }\n\n    function addToWhiteList(address[] calldata addresses)\n        external\n        virtual\n        onlyOwner\n    {\n        for (uint256 i; i < addresses.length; i++) {\n            _isWhitelisted[addresses[i]] = true;\n        }\n    }\n    \n    \n    function removeFromWhiteList(address[] calldata addresses)\n        external\n        virtual\n        onlyOwner\n    {\n        for (uint256 i; i < addresses.length; i++) {\n            _isWhitelisted[addresses[i]] = false;\n        }\n    }\n\n    function addToTaxExempted(address[] calldata addresses)\n        external\n        virtual\n        onlyOwner\n    {\n        for (uint256 i; i < addresses.length; i++) {\n            _isTaxExempted[addresses[i]] = true;\n        }\n    }\n    \n    function removeFromTaxExemption(address[] calldata addresses)\n        external\n        virtual\n        onlyOwner\n    {\n        for (uint256 i; i < addresses.length; i++) {\n            _isTaxExempted[addresses[i]] = false;\n        }\n    }\n\n    \n    function setTaxAddress(address payable newTaxAddress) external onlyOwner {\n        _taxAddress = newTaxAddress;\n        emit TaxAddressChanged(newTaxAddress);\n    }\n\n    function manualswap() external onlyOwner {\n        swapTokensForEth(balanceOf(address(this)));\n    }\n\n    function manualsend() external onlyOwner {\n        sendETHToFee(address(this).balance);\n    }\n\n    function setSwapRouter(IUniswapV2Router newRouter) external onlyOwner {\n        require(liquidityAdded, \"Add liquidity before doing this\");\n\n        address weth = uniswapV2Router.WETH();\n        address newPair = IUniswapV2Factory(newRouter.factory()).getPair(\n            address(this),\n            weth\n        );\n        require(\n            newPair != address(0),\n            \"WETH Pair does not exist for that router\"\n        );\n        require(taxedPair(newPair), \"The pair must be a taxed pair\");\n\n        (uint256 reservesOld, , ) = IUniswapV2Pair(uniswapV2Pair).getReserves();\n        (uint256 reservesNew, , ) = IUniswapV2Pair(newPair).getReserves();\n        require(\n            reservesNew > reservesOld,\n            \"New pair must have more WETH Reserves\"\n        );\n\n        uniswapV2Router = newRouter;\n        uniswapV2Pair = newPair;\n    }\n\n    function setBuyTax(uint256 newBuyTax) public onlyOwner {\n      require(newBuyTax <= 8, \"SPLINK: Buy Tax must be less than or eqaul to 8\");\n      fees = Tax(newBuyTax, fees.sellTax);\n\n      emit TaxChanged(fees);\n    }\n\n    function setSellTax(uint256 newSellTax) public onlyOwner {\n      require(newSellTax <= 8, \"SPLINK: Sell Tax must be less than or eqaul to 8\");\n      fees = Tax(fees.buyTax, newSellTax);\n\n      emit TaxChanged(fees);\n    }\n\n    function setCooldownEnabled(bool onoff) external onlyOwner() {\n        cooldownEnabled = onoff;\n    }\n\n    function currentFees() external view override returns (Tax memory) {\n        return fees;\n    }\n\n    // solhint-disable-next-line\n    receive() external payable virtual {}\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  }
}