{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/RateWrapper.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2020-07-28\n*/\n\n// File: contracts/sol6/IERC20.sol\n\npragma solidity 0.6.6;\n\n\ninterface IERC20 {\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function decimals() external view returns (uint8 digits);\n\n    function totalSupply() external view returns (uint256 supply);\n}\n\n// File: contracts/sol6/wrappers/IKyberRateHelper.sol\n\npragma solidity 0.6.6;\n\n\n\ninterface IKyberRateHelper {\n    function getRatesForToken(\n        IERC20 token,\n        uint256 optionalBuyAmountWei,\n        uint256 optionalSellAmountTwei\n    )\n        external\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        );\n\n    function getPricesForToken(\n        IERC20 token,\n        uint256 optionalBuyAmountWei,\n        uint256 optionalSellAmountTwei\n    )\n        external\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        );\n\n    function getRatesForTokenWithCustomFee(\n        IERC20 token,\n        uint256 optionalBuyAmountWei,\n        uint256 optionalSellAmountTwei,\n        uint256 networkFeeBps\n    )\n        external\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        );\n\n    function getReservesRates(IERC20 token, uint256 optionalAmountWei)\n        external\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        );\n\n    function getSpreadInfo(IERC20 token, uint256 optionalAmountWei)\n        external\n        view\n        returns (bytes32[] memory reserves, int256[] memory spreads);\n\n    function getSlippageRateInfo(\n        IERC20 token,\n        uint256 optionalAmountWei,\n        uint256 optionalSlippageAmountWei\n    )\n        external\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            int256[] memory buySlippageRateBps,\n            bytes32[] memory sellReserves,\n            int256[] memory sellSlippageRateBps\n        );\n}\n\npragma solidity 0.6.6;\n\n\ncontract PermissionGroups {\n    address public admin;\n    address public pendingAdmin;\n\n    event AdminClaimed(address newAdmin, address previousAdmin);\n    event TransferAdminPending(address pendingAdmin);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n    constructor(address _admin) public {\n        require(_admin != address(0), \"admin 0\");\n        admin = _admin;\n    }\n\n    /// @dev Allows the pendingAdmin address to finalize the change admin process.\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender, \"not pending\");\n        emit AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    \n    /// @dev Allows the current admin to set the pendingAdmin address\n    /// @param newAdmin The address to transfer ownership to\n    function transferAdmin(address newAdmin) onlyAdmin external {\n        require(newAdmin != address(0), \"new admin 0\");\n        emit TransferAdminPending(newAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /// @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n    /// @param newAdmin The address to transfer ownership to.\n    function transferAdminQuickly(address newAdmin) onlyAdmin external {\n        require(newAdmin != address(0), \"admin 0\");\n        emit TransferAdminPending(newAdmin);\n        emit AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n}\n\npragma solidity 0.6.6;\n\n\n\n\ncontract Withdrawable is PermissionGroups {\n    constructor(address _admin) public PermissionGroups(_admin) {}\n\n    event EtherWithdraw(uint256 amount, address sendTo);\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\n\n    /// @dev Withdraw Ethers\n    function withdrawEther(uint256 amount, address payable sendTo) onlyAdmin external {\n        (bool success, ) = sendTo.call{value: amount}(\"\");\n        require(success);\n        emit EtherWithdraw(amount, sendTo);\n    }\n\n    /// @dev Withdraw all IERC20 compatible tokens\n    /// @param token IERC20 The address of the token contract\n    function withdrawToken(\n        IERC20 token,\n        uint256 amount,\n        address sendTo\n    ) onlyAdmin external {\n        token.transfer(sendTo, amount);\n        emit TokenWithdraw(token, amount, sendTo);\n    }\n}\n\n// File: contracts/sol6/IKyberDao.sol\n\npragma solidity 0.6.6;\n\n\n\ninterface IKyberDao {\n\n    function getLatestNetworkFeeData()\n        external\n        view\n        returns (uint256 feeInBps, uint256 expiryTimestamp);\n\n}\n\n// File: contracts/sol6/wrappers/KyberRateHelper.sol\n\npragma solidity 0.6.6;\n\n\ncontract WrapKyberRateHelper is Withdrawable {\n\n    constructor() public Withdrawable(msg.sender) {}\n\n    /// @dev function to cover backward compatible with old network interface\n    /// @dev get rate from eth to token, use the best token amount to get rate from token to eth\n    /// @param tokens Token to get rate\n    /// @param optionalAmountWeis Eth amount to get rate (default: 0)\n    function getReservesRates(IKyberRateHelper rateHelper, IERC20[] calldata tokens, uint256[] calldata optionalAmountWeis)\n        external\n        view\n        returns (\n            uint256[] memory buyLengths,\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            uint256[] memory sellLengths,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        )\n    {\n        buyLengths = new uint256[](tokens.length);\n        sellLengths = new uint256[](tokens.length);\n\n        uint256 buyCounter = 0;\n        uint256 sellCounter = 0;\n        for(uint256 i = 0; i < tokens.length; i++) {\n            (buyReserves, , sellReserves,) = rateHelper.getReservesRates(tokens[i], optionalAmountWeis[i]);\n            buyCounter += buyReserves.length;\n            sellCounter += sellReserves.length;\n            buyLengths[i] = buyReserves.length;\n            sellLengths[i] = sellReserves.length;\n        }\n\n        (buyReserves, buyRates, sellReserves, sellRates) = getFinalReservesRates(\n            rateHelper,\n            tokens,\n            optionalAmountWeis,\n            buyCounter,\n            sellCounter\n        );\n    }\n\n    function getBestReservesRates(IKyberRateHelper rateHelper, IERC20[] calldata tokens, uint256[] calldata optionalAmountWeis)\n        external\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        )\n    {\n        buyReserves = new bytes32[](tokens.length);\n        buyRates = new uint256[](tokens.length);\n        sellReserves = new bytes32[](tokens.length);\n        sellRates = new uint256[](tokens.length);\n\n        bytes32[] memory _buyReserves;\n        uint256[] memory _buyRates;\n        bytes32[] memory _sellReserves;\n        uint256[] memory _sellRates;\n\n        for(uint256 i = 0; i < tokens.length; i++) {\n            (_buyReserves, _buyRates, _sellReserves, _sellRates) = rateHelper.getReservesRates(tokens[i], optionalAmountWeis[i]);\n            for(uint256 j = 0; j < _buyReserves.length; j++) {\n                if (_buyRates[j] > buyRates[i]) {\n                    buyRates[i] = _buyRates[j];\n                    buyReserves[i] = _buyReserves[j];\n                }   \n            }\n            for(uint256 j = 0; j < _sellReserves.length; j++) {\n                if (_sellRates[j] > sellRates[i]) {\n                    sellRates[i] = _sellRates[j];\n                    sellReserves[i] = _sellReserves[j];\n                }   \n            }\n        }\n    }\n\n    function getRatesForTokens(\n        IKyberRateHelper rateHelper,\n        IERC20[] calldata tokens,\n        uint256[] calldata optionalBuyAmountWeis,\n        uint256[] calldata optionalSellAmountTweis\n    )\n        external\n        view\n        returns (\n            uint256[] memory buyLengths,\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            uint256[] memory sellLengths,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        )\n    {\n        buyLengths = new uint256[](tokens.length);\n        sellLengths = new uint256[](tokens.length);\n\n        uint256 buyCounter;\n        uint256 sellCounter;\n        (buyLengths, sellLengths, buyCounter, sellCounter) = getRatesForTokensLengths(\n            rateHelper,\n            tokens,\n            optionalBuyAmountWeis,\n            optionalSellAmountTweis\n        );\n\n        (buyReserves, buyRates, sellReserves, sellRates) = getRatesForTokensData(\n            rateHelper,\n            tokens,\n            optionalBuyAmountWeis,\n            optionalSellAmountTweis,\n            buyCounter,\n            sellCounter\n        );\n    }\n\n    function getBestReservesRates2(\n        IKyberRateHelper rateHelper,\n        IERC20[] calldata tokens,\n        uint256[] calldata optionalBuyAmountWeis,\n        uint256[] calldata optionalSellAmountTweis\n    )\n        external\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        )\n    {\n        buyReserves = new bytes32[](tokens.length);\n        buyRates = new uint256[](tokens.length);\n        sellReserves = new bytes32[](tokens.length);\n        sellRates = new uint256[](tokens.length);\n\n        for(uint256 i = 0; i < tokens.length; i++) {\n            (\n                buyReserves[i],\n                buyRates[i],\n                sellReserves[i],\n                sellRates[i]\n            ) = getBestReserveRateHelp(\n                rateHelper,\n                tokens[i],\n                optionalBuyAmountWeis[i],\n                optionalSellAmountTweis[i]\n            );\n        }\n    }\n\n    // avoid stake too deep\n    function getBestReserveRateHelp(\n        IKyberRateHelper rateHelper,\n        IERC20 token,\n        uint256 buyAmount,\n        uint256 sellAmount\n    )\n        internal\n        view\n        returns (\n            bytes32 buyReserve,\n            uint256 buyRate,\n            bytes32 sellReserve,\n            uint256 sellRate\n        )\n    {\n        bytes32[] memory _buyReserves;\n        uint256[] memory _buyRates;\n        bytes32[] memory _sellReserves;\n        uint256[] memory _sellRates;\n\n        (_buyReserves, _buyRates, _sellReserves, _sellRates) = rateHelper.getRatesForToken(\n            token,\n            buyAmount,\n            sellAmount\n        );\n        for(uint256 i = 0; i < _buyReserves.length; i++) {\n            if (_buyRates[i] > buyRate) {\n                buyRate = _buyRates[i];\n                buyReserve = _buyReserves[i];\n            }   \n        }\n        for(uint256 i = 0; i < _sellReserves.length; i++) {\n            if (_sellRates[i] > sellRate) {\n                sellRate = _sellRates[i];\n                sellReserve = _sellReserves[i];\n            }   \n        }\n    }\n\n    function getFinalReservesRates(\n        IKyberRateHelper rateHelper,\n        IERC20[] memory tokens,\n        uint256[] memory optionalAmountWeis,\n        uint256 buyCounter,\n        uint256 sellCounter\n    )\n        internal\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        )\n    {\n        buyReserves = new bytes32[](buyCounter);\n        buyRates = new uint256[](buyCounter);\n        sellReserves = new bytes32[](sellCounter);\n        sellRates = new uint256[](sellCounter);\n\n        bytes32[] memory bReserves;\n        uint256[] memory bRates;\n        bytes32[] memory sReserves;\n        uint256[] memory sRates;\n\n        buyCounter = 0;\n        sellCounter = 0;\n\n        for(uint256 i = 0; i < tokens.length; i++) {\n            (bReserves, bRates, sReserves, sRates) = rateHelper.getReservesRates(tokens[i], optionalAmountWeis[i]);\n            for(uint256 j = buyCounter; j < buyCounter + bReserves.length; j++) {\n                buyReserves[j] = bReserves[j - buyCounter];\n                buyRates[j] = bRates[j - buyCounter];\n            }\n            for(uint256 j = sellCounter; j < sellCounter + sReserves.length; j++) {\n                sellReserves[j] = sReserves[j - sellCounter];\n                sellRates[j] = sRates[j - sellCounter];\n            }\n            buyCounter += bReserves.length;\n            sellCounter += sReserves.length;\n        }\n    }\n\n    function getRatesForTokensLengths(\n        IKyberRateHelper rateHelper,\n        IERC20[] memory tokens,\n        uint256[] memory optionalBuyAmountWeis,\n        uint256[] memory optionalSellAmountTweis\n    )\n        internal\n        view\n        returns (\n            uint256[] memory buyLengths,\n            uint256[] memory sellLengths,\n            uint256 buyCounter,\n            uint256 sellCounter\n        )\n    {\n        buyLengths = new uint256[](tokens.length);\n        sellLengths = new uint256[](tokens.length);\n\n        bytes32[] memory buyReserves;\n        bytes32[] memory sellReserves;\n        for(uint256 i = 0; i < tokens.length; i++) {\n            (buyReserves, , sellReserves,) = rateHelper.getRatesForToken(\n                tokens[i],\n                optionalBuyAmountWeis[i],\n                optionalSellAmountTweis[i]\n            );\n            buyCounter += buyReserves.length;\n            sellCounter += sellReserves.length;\n            buyLengths[i] = buyReserves.length;\n            sellLengths[i] = sellReserves.length;\n        }\n    }\n\n    function getRatesForTokensData(\n        IKyberRateHelper rateHelper,\n        IERC20[] memory tokens,\n        uint256[] memory optionalBuyAmountWeis,\n        uint256[] memory optionalSellAmountTweis,\n        uint256 buyCounter,\n        uint256 sellCounter\n    )\n        internal\n        view\n        returns (\n            bytes32[] memory buyReserves,\n            uint256[] memory buyRates,\n            bytes32[] memory sellReserves,\n            uint256[] memory sellRates\n        )\n    {\n        buyReserves = new bytes32[](buyCounter);\n        buyRates = new uint256[](buyCounter);\n        sellReserves = new bytes32[](sellCounter);\n        sellRates = new uint256[](sellCounter);\n\n        bytes32[] memory bReserves;\n        uint256[] memory bRates;\n        bytes32[] memory sReserves;\n        uint256[] memory sRates;\n\n        buyCounter = 0;\n        sellCounter = 0;\n\n        for(uint256 i = 0; i < tokens.length; i++) {\n            (bReserves, bRates, sReserves, sRates) = rateHelper.getRatesForToken(\n                tokens[i],\n                optionalBuyAmountWeis[i],\n                optionalSellAmountTweis[i]\n            );\n            for(uint256 j = buyCounter; j < buyCounter + bReserves.length; j++) {\n                buyReserves[j] = bReserves[j - buyCounter];\n                buyRates[j] = bRates[j - buyCounter];\n            }\n            for(uint256 j = sellCounter; j < sellCounter + sReserves.length; j++) {\n                sellReserves[j] = sReserves[j - sellCounter];\n                sellRates[j] = sRates[j - sellCounter];\n            }\n            buyCounter += bReserves.length;\n            sellCounter += sReserves.length;\n        }\n    }\n}"}}}