{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "multiswap.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n// import the WETH interface\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\r\n}\r\n\r\n// import the ERC20 interface\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n// import the uniswap V2 router interface\r\ninterface IUniswapV2Router02 {\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function WETH() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n}\r\n\r\n// import the uniswap V2 pair interface\r\ninterface IUniswapV2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(\r\n    uint256 amount0Out,\r\n    uint256 amount1Out,\r\n    address to,\r\n    bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// import the uniswap V2 pair interface\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\ncontract multiSwap {\r\n\r\n    using SafeMath for uint;\r\n\r\n    IUniswapV2Router02 uniswapRouter;\r\n    IUniswapV2Factory uniswapFactory;\r\n\r\n    // to save the owner of the contract in construction\r\n    address private owner;\r\n    \r\n    // to save the amount of ethers in the smart-contract\r\n    uint total_value;   \r\n\r\n    //address of the uniswap v2 router\r\n    address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    //address of the uniswap v2 factory\r\n    address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n\r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n        /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n\r\n    constructor() payable{\r\n        uniswapRouter = IUniswapV2Router02(UNISWAP_V2_ROUTER);\r\n        uniswapFactory = IUniswapV2Factory(UNISWAP_V2_FACTORY);\r\n\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n        \r\n        total_value = msg.value;  // msg.value is the ethers of the transaction\r\n    }\r\n    \r\n    // modifier to check if the caller is owner\r\n    modifier isOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n    \r\n    // the owner of the smart-contract can chage its owner to whoever \r\n    // he/she wants\r\n    function changeOwner(address newOwner) public isOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner; \r\n    }\r\n\r\n    // charge enable the owner to store ether in the smart-contract\r\n    function charge() payable public isOwner {\r\n        // adding the message value to the smart contract\r\n        total_value += msg.value;\r\n    }\r\n    \r\n    function withdraw(address payable receiverAddr, uint amount) public isOwner {\r\n        receiverAddr.transfer(amount);\r\n    }\r\n\r\n    function buyer(address _token, uint256 _amountOut, address payable [] calldata _wallets) payable public isOwner {\r\n\r\n        // exchange the entire bet (msg.value) to WETH\r\n        IWETH(uniswapRouter.WETH()).deposit{value: msg.value}();\r\n\r\n        // defining the path for which the trade is going to take ( from WETH to token)\r\n        address[] memory path = new address[](2);\r\n        path[0] = uniswapRouter.WETH();\r\n        path[1] = _token;\r\n\r\n        // getting the pair\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapFactory.getPair(path[0], path[1]));\r\n\r\n        uint total_deposit = 0;\r\n\r\n        for (uint i = 0; i < _wallets.length; i++) {\r\n            // getting the amounts for this trade\r\n            uint[] memory amounts = uniswapRouter.getAmountsIn(_amountOut, path);        \r\n\r\n            // transfer WETH from this contract to the pair\r\n            IWETH(uniswapRouter.WETH()).transferFrom(address(this), address(pair), amounts[0]);\r\n\r\n            // assigning the path as in and out token\r\n            (address input, address output) = (path[0], path[1]);\r\n\r\n            // sorting tokens\r\n            (address token0, address token1) = input < output ? (input, output) : (output, input);\r\n\r\n            // specifying amounts\r\n            uint amountOut = amounts[1];\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\r\n\r\n            // setting to which address the tokens is going to be transferred during the swap\r\n            address to = _wallets[i];\r\n\r\n            // performing the actual swap\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n\r\n            // ackumulating total deposit\r\n            total_deposit = total_deposit + amounts[0];\r\n        }\r\n\r\n        // refund leftover WETH to caller, if any\r\n        if (msg.value > total_deposit)\r\n            IWETH(uniswapRouter.WETH()).transferFrom(address(this), msg.sender, msg.value - total_deposit);\r\n    \r\n    }\r\n\r\n    function seller(uint _tokenAmount, uint _minimumOutput, address _token, address payable[] calldata _wallets) payable public {\r\n\r\n        // defining the path for which the trade is going to take (from token to WETH)\r\n        address[] memory path = new address[](2);\r\n        path[0] = _token;\r\n        path[1] = uniswapRouter.WETH();\r\n\r\n        // getting the pair\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapFactory.getPair(path[0], path[1]));\r\n\r\n        for (uint i = 0; i < _wallets.length; i++) {\r\n            // transfer tokens from current wallet to the pair\r\n            TransferHelper.safeTransferFrom(path[0], _wallets[i], address(pair), _tokenAmount);\r\n\r\n            // assigning the path as in and out token\r\n            (address input, address output) = (path[0], path[1]);\r\n\r\n            // sorting tokens\r\n            (address token0, address token1) = input < output ? (input, output) : (output, input);\r\n            uint amountInput;\r\n            uint amountOutput;\r\n\r\n            { // scope to avoid stack too deep errors\r\n            (uint reserve0, uint reserve1,) = pair.getReserves();\r\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n            amountOutput = uniswapRouter.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n\r\n            // setting to which address the ETH is going to be transferred during the swap\r\n            address to = address(_wallets[i]);\r\n\r\n            // performing the actual swap\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n\r\n            // checking if the actual amount out is sufficient\r\n            uint amountOut = IERC20(uniswapRouter.WETH()).balanceOf(address(this));\r\n            \r\n            //require(amountOut >= _minimumOutput, 'INSUFFICIENT_OUTPUT_AMOUNT');\r\n\r\n            // exchange amount out from WETH to ETH\r\n            IWETH(uniswapRouter.WETH()).withdraw(amountOut);\r\n            TransferHelper.safeTransferETH(to, amountOut);\r\n        }\r\n\r\n    }\r\n\r\n    // important to receive ETH\r\n    receive() payable external {}\r\n\r\n}\r\n\r\n"
    }
  }
}