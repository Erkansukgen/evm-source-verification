{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "inariHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n▄▄█    ▄   ██   █▄▄▄▄ ▄█ \n██     █  █ █  █  ▄▀ ██ \n██ ██   █ █▄▄█ █▀▀▌  ██ \n▐█ █ █  █ █  █ █  █  ▐█ \n ▐ █  █ █    █   █    ▐ \n   █   ██   █   ▀   \n           ▀          */\n/// 🦊🌾 Special thanks to Keno / Boring / Gonpachi / Karbon for review and continued inspiration.\npragma solidity 0.8.6;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n// solhint-disable avoid-low-level-calls\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n        if (data.length >= 64) {\n            return abi.decode(data, (string));\n        } else if (data.length == 32) {\n            uint8 i = 0;\n            while(i < 32 && data[i] != 0) {\n                i++;\n            }\n            bytes memory bytesArray = new bytes(i);\n            for (i = 0; i < 32 && data[i] != 0; i++) {\n                bytesArray[i] = data[i];\n            }\n            return string(bytesArray);\n        } else {\n            return \"???\";\n        }\n    }\n\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token symbol.\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (string) Token name.\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n        return success ? returnDataToString(data) : \"???\";\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n\ninterface IBentoHelper {\n    function balanceOf(IERC20, address) external view returns (uint256);\n    \n    function toAmount(\n        IERC20 token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    function toShare(\n        IERC20 token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n}\n\ninterface ICompoundHelper {\n    function underlying() external view returns (address);\n    function getCash() external view returns (uint256);\n    function totalBorrows() external view returns (uint256);\n    function totalReserves() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function exchangeRateStored() external view returns (uint256);\n}\n\ninterface IKashiHelper {\n    function asset() external view returns (IERC20);\n    function totalAsset() external view returns (Rebase memory);\n    function totalBorrow() external view returns (Rebase memory);\n    struct Rebase {\n        uint128 elastic;\n        uint128 base;\n    }\n}\n\ncontract InariHelper {\n    using BoringERC20 for IERC20;\n    \n    IBentoHelper constant bento = IBentoHelper(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966); // BENTO vault contract\n    \n    // **** BENTO \n    function toBento(IERC20 token, uint256 amount) external view returns (uint256 share) {\n        share = bento.toShare(token, amount, false);\n    }\n    \n    function fromBento(IERC20 token, uint256 share) external view returns (uint256 amount) {\n        amount = bento.toAmount(token, share, false);\n    }\n    \n    // **** COMPOUND/CREAM\n    function toCompound(ICompoundHelper cToken, uint256 underlyingAmount) external view returns (uint256 result) { \n        result = cToken.exchangeRateStored() / underlyingAmount;\n    }\n    \n    function fromCompound(ICompoundHelper cToken, uint256 cTokenAmount) external view returns (uint256 result) {\n        result = cTokenAmount * cToken.exchangeRateStored() / 10**18;\n    }\n    \n    // **** KASHI ASSET\n    function toKashi(IKashiHelper kashiPair, uint256 amount) external view returns (uint256 fraction) {\n        IERC20 token = kashiPair.asset();\n        uint256 share = bento.toShare(token, amount, false);\n        uint256 allShare = kashiPair.totalAsset().elastic + bento.toShare(token, kashiPair.totalBorrow().elastic, true);\n        fraction = allShare == 0 ? share : share * kashiPair.totalAsset().base / allShare;\n    }\n    \n    function fromKashi(IKashiHelper kashiPair, uint256 amount) external view returns (uint256 share) {\n        uint256 allShare = kashiPair.totalAsset().elastic + bento.toShare(kashiPair.asset(), kashiPair.totalBorrow().elastic, true);\n        share = amount * allShare / kashiPair.totalAsset().base;\n    }\n}"
    }
  }
}