{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contract/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n  \n\n\t/**\n\t* @dev Returns true if `account` is a contract.\n\t*\n\t* [IMPORTANT]\n\t* ====\n\t* It is unsafe to assume that an address for which this function returns\n\t* false is an externally-owned account (EOA) and not a contract.\n\t*\n\t* Among others, `isContract` will return false for the following\n\t* types of addresses:\n\t*\n\t*  - an externally-owned account\n\t*  - a contract in construction\n\t*  - an address where a contract will be created\n\t*  - an address where a contract lived, but was destroyed\n\t* ====\n\t*/\n\tfunction isContract(address account) internal view returns (bool) {\n\t// This method relies on extcodesize, which returns 0 for contracts in\n\t// construction, since the code is only stored at the end of the\n\t// constructor execution.\n\n\tuint256 size;\n\t// solhint-disable-next-line no-inline-assembly\n\tassembly { size := extcodesize(account) }\n\treturn size > 0;\n\t}\n\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\n\t}\n\n\t/**\n\t\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n\t\t* `errorMessage` as a fallback revert reason when `target` reverts.\n\t\t*\n\t\t* _Available since v3.1._\n\t\t*/\n\tfunction functionCall(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\n\t}\n\n\t/**\n\t\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n\t\t* but also transferring `value` wei to `target`.\n\t\t*\n\t\t* Requirements:\n\t\t*\n\t\t* - the calling contract must have an ETH balance of at least `value`.\n\t\t* - the called Solidity function must be `payable`.\n\t\t*\n\t\t* _Available since v3.1._\n\t\t*/\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint256 value\n\t) internal returns (bytes memory) {\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n\t}\n\n\n\t/**\n\t\t* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n\t\t* with `errorMessage` as a fallback revert reason when `target` reverts.\n\t\t*\n\t\t* _Available since v3.1._\n\t\t*/\n\tfunction functionCallWithValue(\n\t\taddress target,\n\t\tbytes memory data,\n\t\tuint256 value,\n\t\tstring memory errorMessage\n\t) internal returns (bytes memory) {\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\n\t\trequire(isContract(target), \"Address: call to non-contract\");\n\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\n\t\treturn verifyCallResult(success, returndata, errorMessage);\n\t}\n\n\n\t/**\n\t\t* @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n\t\t* revert reason using the provided one.\n\t\t*\n\t\t* _Available since v4.3._\n\t\t*/\n\tfunction verifyCallResult(\n\t\tbool success,\n\t\tbytes memory returndata,\n\t\tstring memory errorMessage\n\t) internal pure returns (bytes memory) {\n\t\tif (success) {\n\t\t\treturn returndata;\n\t\t} else {\n\t\t\t// Look for revert reason and bubble it up if present\n\t\t\tif (returndata.length > 0) {\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(returndata)\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert(errorMessage);\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    "contract/BaseERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./ERC721Token.sol\";\nimport \"./IERC20.sol\";\n\n/**\n * @title Base ERC721 token\n * This contract implements basic ERC721 token functionality with bulk functionalities\n */\ncontract BaseERC721 is ERC721Token {\n\n  constructor(string memory name, string memory symbol, string memory _baseTokenURI)  ERC721Token(name, symbol){\n    baseTokenURI = _baseTokenURI;\n  }\n\n  /**\n   * @dev Updates the base URL of token\n   * Reverts if the sender is not owner\n   * @param _newURI New base URL\n   */\n  function updateBaseTokenURI(string memory _newURI)\n    public\n    onlyOwner\n  {\n    baseTokenURI = _newURI;\n  }\n\n  /**\n   * @dev Mints new token on blockchain\n   * Reverts if the sender is not operator with level 1\n   * @param _id Id of NFT to be minted\n   * @dev URI is not provided because URI will be deducted based on baseURL\n   */\n  function _mint(address _to, uint256 _id,  string memory _uri)\n    internal\n    returns (bool)\n  {\n    super._mint(_to, _id);\n    _setTokenURI(_id, _uri);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens (similar to ERC-20 transfer)\n   * Reverts if the sender is not owner of the NFT or approved\n   * @param _to address to which token is transferred\n   * @param _tokenId Id of NFT being transferred\n   */\n  function transfer(address _to, uint256 _tokenId)\n    public\n    noEmergencyFreeze\n    returns (bool)\n  {\n    safeTransferFrom(msg.sender, _to, _tokenId);\n    return true;\n  }\n\n  /**\n   * @dev Burn an existing NFT\n   * @param _id Id of NFT to be burned\n   */\n  function burn(address user, uint _id)\n    internal\n    returns (bool)\n  {\n    super._burn(user, _id);\n    _clearTokenURI(_id);\n    return true;\n  }\n\n  //////////////////////////////////////////\n  // PUBLICLY ACCESSIBLE METHODS (CONSTANT)\n  //////////////////////////////////////////\n\n}"
    },
    "contract/CustomNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./BaseERC721.sol\";\nimport \"./SecondaryMarketFee.sol\";\n\n/**\n * @title CustomNFT Contract\n * This contract inherits all basic ERC-721 functionality and extens that by adding more methods\n */\ncontract CustomNFT is BaseERC721, SecondaryMarketFee {\n\n  constructor(string memory name, string memory symbol, string memory baseURI) BaseERC721(name, symbol, baseURI) {\n    _registerInterface(_INTERFACE_ID_FEES);\n  }\n\n\n  /**\n   * @dev Mint tokens by user. Users can call this function and pay for \"gas\" for token minting\n   * Owner needs to sign the tokenId\n   * Reverts if tokenId already exists\n   * Reverts if owner has not signed tokenId\n   * @param tokenId Id of NFT to be minted\n   * @param r signature\n   * @param s signature\n   * @param v recovery id of signature\n   * @param _fees Fees to be used in secondary market\n   */ \n  function mint(\n    uint256 tokenId,\n    address to,\n    uint8 v, bytes32 r, bytes32 s,\n    Fee[] memory _fees,\n    string memory uri\n  )\n    public\n    noEmergencyFreeze\n    returns (bool)\n  {\n    bytes32 message = getMessageForMint(tokenId, to, _fees);\n    require(isAdmin(getSigner(message,r,s,v)), \"admin signature is required\");\n    super._mint(to, tokenId, uri);\n    super.addFees(tokenId, _fees);\n    return true;\n  }\n\n  /**\n   * @dev Mint tokens by admin. Admin can call mint tokem on behalf of user and can pay the fees\n   * Reverts if tokenId already exists\n   * @param tokenId Id of NFT to be minted\n   * @param to address to which NFT is to be minted\n   * @param _fees Fees to be used in secondary market\n   */\n  function directMint(uint256 tokenId, address to, Fee[] memory _fees, string memory uri)\n    public\n    onlyAdmin\n    noEmergencyFreeze\n    returns (bool)\n  {\n    super._mint(to, tokenId, uri);\n    super.addFees(tokenId, _fees);\n    return true;\n  }\n\n  /**\n   * @dev Bulk Mint tokens by admin. Admin can call mint tokem on behalf of user and can pay the fees.\n   * @notice Fess can recipient should be same for all NFTs\n   * Reverts if any tokenId already exists\n   * @param tokenIds Id of NFT to be minted\n   * @param to address to which NFT is to be minted\n   * @param _fees Fees to be used in secondary market for each NFT\n   */\n  function bulkDirectMint(uint[] memory tokenIds, address to, Fee[] memory _fees, string[] memory uris)\n    public\n    onlyAdmin\n    noEmergencyFreeze\n    returns (bool)\n  {\n    for(uint i=0; i<tokenIds.length; i++) {\n      super._mint(to, tokenIds[i], uris[i]);\n      super.addFees(tokenIds[i], _fees);\n    }\n    return true;\n  }\n\n  /**\n   * @dev Bulk Mint tokens by user. Users can call this function and pay for \"gas\" for token minting\n   * Owner needs to sign the all tokenIds\n   * Reverts if tokenId already exists\n   * Reverts if owner has not signed tokenId\n   * @param tokenIds Ids of NFTs to be minted\n   * @param r signature\n   * @param s signature\n   * @param v recovery id of signature\n   * @param _fees Fees to be used in secondary market\n  */\n  function bulkMint(uint[] memory tokenIds, address to, uint8 v, bytes32 r, bytes32 s, Fee[] memory _fees, string[] memory uris)\n    public\n    noEmergencyFreeze\n    returns (bool)\n  {\n    bytes32 message = getMessageForBulkMint(tokenIds, to, _fees);\n    require(isAdmin(getSigner(message,r,s,v)), \"admin should sign tokenId\");\n    for(uint i=0; i<tokenIds.length; i++) {\n      super._mint(msg.sender, tokenIds[i], uris[i]);\n      super.addFees(tokenIds[i], _fees);\n    }\n    return true;\n  }\n\n  function setTokenUri(uint256 tokenId, string memory uri, uint8 v, bytes32 r, bytes32 s) public {\n    bytes32 message = keccak256(abi.encode(\n      address(this),\n      tokenId,\n      uri\n    ));\n    require(isAdmin(getSigner(message,r,s,v)), \"admin signature is required\");\n    _setTokenURI(tokenId, uri);\n  }\n\n  function burn(uint _id)\n    public\n    noEmergencyFreeze\n    returns (bool)\n  {\n    removeFees(_id);\n    return super.burn(msg.sender, _id);\n  }\n\n  \n\n  /**\n   * @dev Owner can transfer out any accidentally sent ERC20 tokens\n   * @param contractAddress ERC20 contract address\n   * @param to withdrawal address\n   * @param value no of tokens to be withdrawan\n   */\n  function transferAnyERC20Token(address contractAddress, address to,  uint value) external onlyOwner {\n    IERC20(contractAddress).transfer(to, value);\n  }\n\n  /**\n   * @dev Owner can transfer out any accidentally sent ERC721 tokens\n   * @param contractAddress ERC721 contract address\n   * @param to withdrawal address\n   * @param tokenId Id of 721 token\n   */\n  function withdrawAnyERC721Token(address contractAddress, address to, uint tokenId) external onlyOwner {\n    ERC721Basic(contractAddress).safeTransferFrom(address(this), to, tokenId);\n  }\n\n  /**\n   * @dev Owner kill the smart contract\n   * @param message Confirmation message to prevent accidebtal calling\n   * @notice BE VERY CAREFULL BEFORE CALLING THIS FUNCTION\n   * Better pause the contract\n   * DO CALL \"transferAnyERC20Token\" before TO WITHDRAW ANY ERC-2O's FROM CONTRACT\n   */\n  function kill(uint message) external onlyOwner {\n    require (message == 123456789987654321, \"Invalid code\");\n    // Transfer Eth to owner and terminate contract\n    selfdestruct(payable(msg.sender));\n  }\n\n  /**\n   * @dev Check signer of a message\n   * @param message signed message by user\n   * @param r signature\n   * @param s signature\n   * @param v recovery id of signature\n   * @return signer of message\n   */\n  function getSigner(bytes32 message, bytes32 r, bytes32 s, uint8 v) public pure returns (address){\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    return ecrecover(keccak256(abi.encodePacked(prefix, message)),v,r,s);\n  }\n\n  function getMessageForMint(uint256 tokenId, address to, Fee[] memory _fees)\n    public view returns(bytes32)\n    {\n    return keccak256(abi.encode(\n      getChainID(),\n      address(this),\n      tokenId,\n      to,\n      _fees\n    ));\n  }\n\n  function getMessageForBulkMint(\n    uint256[] memory tokenIds,\n    address to,\n    Fee[] memory _fees\n  )\n    public view returns(bytes32)\n  {\n    return keccak256(abi.encode(\n      getChainID(),\n      address(this),\n      tokenIds,\n      to,\n      _fees\n    ));\n  }\n\n  function getChainID() public view returns (uint256) {\n    uint256 id;\n    assembly {\n        id := chainid()\n    }\n    return id;\n  }\n\n}"
    },
    "contract/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface ERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165.\n   */\n  function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool);\n}\n"
    },
    "contract/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./ERC721Basic.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\nabstract contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n\n}"
    },
    "contract/ERC721Basic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\nabstract contract ERC721Basic is ERC165 {\n  event Transfer(\n    address indexed _from,\n    address indexed _to,\n    uint256 indexed _tokenId\n  );\n  event Approval(\n    address indexed _owner,\n    address indexed _approved,\n    uint256 indexed _tokenId\n  );\n  event ApprovalForAll(\n    address indexed _owner,\n    address indexed _operator,\n    bool _approved\n  );\n\n  function balanceOf(address _owner) public virtual view returns (uint256 _balance);\n  function ownerOf(uint256 _tokenId) public virtual view returns (address _owner);\n  function exists(uint256 _tokenId) public virtual view returns (bool _exists);\n\n  function approve(address _to, uint256 _tokenId) virtual public;\n  function getApproved(uint256 _tokenId)\n    public virtual view returns (address _operator);\n\n  function setApprovalForAll(address _operator, bool _approved) virtual public;\n  function isApprovedForAll(address _owner, address _operator)\n    public virtual view returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) virtual public;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n    virtual public;\n\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    virtual public;\n}"
    },
    "contract/ERC721BasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./SupportsInterfaceWithLookup.sol\";\nimport \"./ERC721Basic.sol\";\nimport \"./ERC721Receiver.sol\";\nimport \"./Freezable.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic, Freezable {\n\n  bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79;\n  /*\n   * 0x4f558e79 ===\n   *   bytes4(keccak256('exists(uint256)'))\n   */\n\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant ERC721_RECEIVED = 0xf0b9e5ba;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) internal tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) internal tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) internal ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) internal operatorApprovals;\n\n  /**\n   * @dev Guarantees msg.sender is owner of the given token\n   * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n   */\n  modifier onlyOwnerOf(uint256 _tokenId) {\n    require(ownerOf(_tokenId) == msg.sender, \"Only asset owner is allowed\");\n    _;\n  }\n\n  /**\n   * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n   * @param _tokenId uint256 ID of the token to validate\n   */\n  modifier canTransfer(uint256 _tokenId) {\n    require(isApprovedOrOwner(msg.sender, _tokenId), \"Can not transfer\");\n    _;\n  }\n\n  constructor()\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721);\n    _registerInterface(InterfaceId_ERC721Exists);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param _owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address _owner) public override view returns (uint256) {\n    require(_owner != address(0), \"Zero address not allowed\");\n    return ownedTokensCount[_owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param _tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 _tokenId) public override view returns (address) {\n    address owner = tokenOwner[_tokenId];\n    require(owner != address(0), \"Zero address not allowed\");\n    return owner;\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param _tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function exists(uint256 _tokenId) public override view returns (bool) {\n    address owner = tokenOwner[_tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param _to address to be approved for the given token ID\n   * @param _tokenId uint256 ID of the token to be approved\n   */\n  function approve(address _to, uint256 _tokenId) public override {\n    address owner = ownerOf(_tokenId);\n    require(_to != owner, \"Can not approve to self\");\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"Not allowed to update approvals\");\n\n    tokenApprovals[_tokenId] = _to;\n    emit Approval(owner, _to, _tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * @param _tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 _tokenId) public override view returns (address) {\n    return tokenApprovals[_tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param _to operator address to set the approval\n   * @param _approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address _to, bool _approved) public override {\n    require(_to != msg.sender, \"Can not approve to self\");\n    operatorApprovals[msg.sender][_to] = _approved;\n    emit ApprovalForAll(msg.sender, _to, _approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param _owner owner address which you want to query the approval of\n   * @param _operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  )\n    public\n    override\n    view\n    returns (bool)\n  {\n    return operatorApprovals[_owner][_operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param _from current owner of the token\n   * @param _to address to receive the ownership of the given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    public\n    override\n    noEmergencyFreeze\n    canTransfer(_tokenId)\n  {\n    require(_from != address(0), \"Zero address not allowed\");\n    require(_to != address(0), \"Zero address not allowed\");\n\n    clearApproval(_from, _tokenId);\n    removeTokenFrom(_from, _tokenId);\n    addTokenTo(_to, _tokenId);\n\n    emit Transfer(_from, _to, _tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param _from current owner of the token\n   * @param _to address to receive the ownership of the given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    public\n    override\n    noEmergencyFreeze\n    canTransfer(_tokenId)\n  \n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(_from, _to, _tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param _from current owner of the token\n   * @param _to address to receive the ownership of the given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    public\n    override\n    noEmergencyFreeze\n    canTransfer(_tokenId)\n  {\n    transferFrom(_from, _to, _tokenId);\n    // solium-disable-next-line arg-overflow\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data), \"Safe Transfer failed\");\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param _spender address of the spender to query\n   * @param _tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function isApprovedOrOwner(\n    address _spender,\n    uint256 _tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(_tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      _spender == owner ||\n      getApproved(_tokenId) == _spender ||\n      isApprovedForAll(owner, _spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param _to The address that will own the minted token\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address _to, uint256 _tokenId) internal virtual {\n    require(_to != address(0), \"Zero address not allowed\");\n    addTokenTo(_to, _tokenId);\n    emit Transfer(address(0), _to, _tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address _owner, uint256 _tokenId) internal virtual {\n    clearApproval(_owner, _tokenId);\n    removeTokenFrom(_owner, _tokenId);\n    emit Transfer(_owner, address(0), _tokenId);\n  }\n\n  /**\n   * @dev Internal function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param _owner owner of the token\n   * @param _tokenId uint256 ID of the token to be transferred\n   */\n  function clearApproval(address _owner, uint256 _tokenId) internal {\n    require(ownerOf(_tokenId) == _owner, \"Asset does not belong to given owmer\");\n    if (tokenApprovals[_tokenId] != address(0)) {\n      tokenApprovals[_tokenId] = address(0);\n      emit Approval(_owner, address(0), _tokenId);\n    }\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * @param _to address representing the new owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function addTokenTo(address _to, uint256 _tokenId) internal virtual {\n    require(tokenOwner[_tokenId] == address(0), \"Asset already exists\");\n    tokenOwner[_tokenId] = _to;\n    ownedTokensCount[_to] = ownedTokensCount[_to] + 1;\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * @param _from address representing the previous owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function removeTokenFrom(address _from, uint256 _tokenId) internal virtual {\n    require(ownerOf(_tokenId) == _from, \"Asset does not belong to given owner\");\n    ownedTokensCount[_from] = ownedTokensCount[_from] - 1;\n    tokenOwner[_tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param _from address representing the previous owner of the given token ID\n   * @param _to target address that will receive the tokens\n   * @param _tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function checkAndCallSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!_to.isContract()) {\n      return true;\n    }\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(\n      _from, _tokenId, _data);\n    return (retval == ERC721_RECEIVED);\n  }\n}"
    },
    "contract/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./ERC721Basic.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\nabstract  contract ERC721Enumerable is ERC721Basic {\n  function totalSupply() public virtual view returns (uint256);\n  function tokenOfOwnerByIndex(\n    address _owner,\n    uint256 _index\n  )\n    public\n    virtual\n    view\n    returns (uint256 _tokenId);\n\n  function tokenByIndex(uint256 _index) public virtual view returns (uint256);\n}"
    },
    "contract/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./ERC721Basic.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata \n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\nabstract contract ERC721Metadata is ERC721Basic {\n  function name() external virtual view returns (string memory _name);\n  function symbol() external virtual view returns (string memory _symbol);\n  function tokenURI(uint256 _tokenId) public virtual view returns (string memory);\n}"
    },
    "contract/ERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\nabstract contract ERC721Receiver {\n  /**\n   * @dev Magic value to be returned upon successful reception of an NFT\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n   */\n  bytes4 internal constant ERC721_RECEIVED = 0xf0b9e5ba;\n\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a `safetransfer`. This function MAY throw to revert and reject the\n   * transfer. This function MUST use 50,000 gas or less. Return of other\n   * than the magic value MUST result in the transaction being reverted.\n   * Note: the contract address is always the message sender.\n   * @param _from The sending address\n   * @param _tokenId The NFT identifier which is being transfered\n   * @param _data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address _from,\n    uint256 _tokenId,\n    bytes memory _data\n  )\n    public\n    virtual\n    returns(bytes4);\n}"
    },
    "contract/ERC721Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721BasicToken.sol\";\nimport \"./SupportsInterfaceWithLookup.sol\";\nimport \"./Strings.sol\";\n\n\n/**\n * @title Full ERC721 Token\n * @author Prashant Prabhakar Singh [prashantprabhakar123@gmail.com]\n * This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\n\n  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\n \n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n \n\n  // Token name\n  string internal name_;\n\n  // Token symbol\n  string internal symbol_;\n\n  // to store base URL\n  string internal baseTokenURI;\n\n  // Mapping from owner to list of owned token IDs\n  mapping(address => uint256[]) internal ownedTokens;\n\n  // Mapping from token ID to index of the owner tokens list\n  mapping(uint256 => uint256) internal ownedTokensIndex;\n\n  // Array with all token ids, used for enumeration\n  uint256[] internal allTokens;\n\n  // Mapping from token id to position in the allTokens array\n  mapping(uint256 => uint256) internal allTokensIndex;\n\n  mapping(uint256 => string) private _tokenURIs;\n  \n  /**\n   * @dev Constructor function\n   */\n  constructor(string memory _name, string memory _symbol) {\n    name_ = _name;\n    symbol_ = _symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Enumerable);\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external override view returns (string memory) {\n    return name_;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external  override view returns (string memory) {\n    return symbol_;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param _tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 _tokenId) public override view returns (string memory) {\n    require(exists(_tokenId), \"Asset does not exist\");\n    return string(abi.encodePacked(baseTokenURI, _tokenURIs[_tokenId]));\n  }\n\n  /**\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\n   * @param _owner address owning the tokens list to be accessed\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\n   */\n  function tokenOfOwnerByIndex(\n    address _owner,\n    uint256 _index\n  )\n    public\n    override\n    view\n    returns (uint256)\n  {\n    require(_index < balanceOf(_owner), \"Invalid index\");\n    return ownedTokens[_owner][_index];\n  }\n\n  /**\n   * @dev Gets the total amount of tokens stored by the contract\n   * @return uint256 representing the total amount of tokens\n   */\n  function totalSupply() public override view returns (uint256) {\n    return allTokens.length;\n  }\n\n  /**\n   * @dev Gets the token ID at a given index of all the tokens in this contract\n   * Reverts if the index is greater or equal to the total number of tokens\n   * @param _index uint256 representing the index to be accessed of the tokens list\n   * @return uint256 token ID at the given index of the tokens list\n   */\n  function tokenByIndex(uint256 _index) public  override view returns (uint256) {\n    require(_index < totalSupply(), \"Invalid index\");\n    return allTokens[_index];\n  }\n\n  // /**\n  //  * @dev Internal function to set the token URI for a given token\n  //  * Reverts if the token ID does not exist\n  //  * @param _tokenId uint256 ID of the token to set its URI\n  //  * @param _uri string URI to assign\n  //  */\n  function _setTokenURI(uint256 _tokenId, string memory _uri) internal {\n    require(exists(_tokenId), \"ERC721: Token does not exist\");\n    _tokenURIs[_tokenId] = _uri;\n  }\n\n  function _clearTokenURI(uint256 tokenId) internal {\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * @param _to address representing the new owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function addTokenTo(address _to, uint256 _tokenId) internal override {\n    super.addTokenTo(_to, _tokenId);\n    uint256 length = ownedTokens[_to].length;\n    ownedTokens[_to].push(_tokenId);\n    ownedTokensIndex[_tokenId] = length;\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * @param _from address representing the previous owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n   function removeTokenFrom(address _from, uint256 _tokenId) internal override {\n     super.removeTokenFrom(_from, _tokenId);\n\n     uint256 tokenIndex = ownedTokensIndex[_tokenId];\n     uint256 lastTokenIndex = ownedTokens[_from].length -1;\n     uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n     ownedTokens[_from][tokenIndex] = lastToken;\n     ownedTokens[_from][lastTokenIndex] = 0;\n     // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n     // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n     // the lastToken to the first position, and then dropping the element placed in the last position of the list\n\n     ownedTokens[_from].pop();\n    \n     ownedTokensIndex[_tokenId] = 0;\n     ownedTokensIndex[lastToken] = tokenIndex;\n   }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param _to address the beneficiary that will own the minted token\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address _to, uint256 _tokenId) internal  override {\n    super._mint(_to, _tokenId);\n\n    allTokensIndex[_tokenId] = allTokens.length;\n    allTokens.push(_tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param _owner owner of the token to burn\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address _owner, uint256 _tokenId) internal override {\n    super._burn(_owner, _tokenId);\n\n    uint256 tokenIndex = allTokensIndex[_tokenId];\n    uint256 lastTokenIndex = allTokens.length - 1;\n    uint256 lastToken = allTokens[lastTokenIndex];\n\n    allTokens[tokenIndex] = lastToken;\n    allTokensIndex[lastToken] = tokenIndex;\n\n    delete allTokensIndex[_tokenId];\n    allTokens.pop();\n  }\n}"
    },
    "contract/Freezable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./Ownership.sol\";\n\n/**\n * @title Freezable Contract\n * This contract allows the inherited contract to be freezed.\n * Most state update actions should be prohibted when contract is freezed.\n * Only admin can perform some actions including \"unfreezing\".\n * Use of Freezable modifiers entirely depends on parent contract\n */\ncontract Freezable is Ownership {\n    \n    bool public emergencyFreeze = false;\n\n    event EmerygencyFreezed(bool emergencyFreezeStatus);\n\n    modifier noEmergencyFreeze() { \n        require(!emergencyFreeze, \"Contract is freezed\");\n        _; \n    }\n\n    /**\n     * @dev Admin can freeze/unfreeze the contract\n     * Reverts if sender is not the owner of contract\n     * @param _freeze Boolean valaue; true is used to freeze and false for unfreeze\n     */ \n    function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool) {\n        emergencyFreeze = _freeze;\n        emit EmerygencyFreezed(_freeze);\n        return true;\n    }\n\n}"
    },
    "contract/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nabstract contract IERC20 {\n  function transfer(address to, uint tokens) public virtual returns (bool success);\n  function balanceOf(address _sender) public virtual view returns (uint _bal);\n  function allowance(address tokenOwner, address spender) public virtual view returns (uint remaining);\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\n}"
    },
    "contract/ISecondaryMarketFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\ninterface ISecondaryMarketFees {\n\n  struct Fee {\n    address recipient;\n    uint256 value;\n  }\n  \n  function getFeeRecipients(uint256 tokenId) external view returns(address[] memory);\n\n  function getFeeBps(uint256 tokenId) external view returns(uint256[] memory);\n\n\n}"
    },
    "contract/Ownership.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\ncontract Ownership {\n\n  address public owner;\n  address[] private deputyOwners;\n\n  mapping(address => bool) public isDeputyOwner;\n\n\n  event OwnershipUpdated(address oldOwner, address newOwner);\n  event DeputyOwnerUpdated(address _do, bool _isAdded);\n\n  constructor() {\n    owner = msg.sender;\n    deputyOwners = [msg.sender];\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only owner is allowed\");\n    _;\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(msg.sender), \"Only owner or deputy owner is allowed\");\n    _;\n  }\n\n  function isAdmin(address user) internal view returns(bool) {\n    return user == owner || isDeputyOwner[user];\n  }\n\n\n  /**\n   * @dev Transfer the ownership to some other address.\n   * new owner can not be a zero address.\n   * Only owner can call this function\n   * @param _newOwner Address to which ownership is being transferred\n   */\n  function updateOwner(address _newOwner)\n    public\n    onlyOwner\n  {\n    require(_newOwner != address(0x0), \"Invalid address\");\n    owner = _newOwner;\n    emit OwnershipUpdated(msg.sender, owner);\n  }\n\n  /**\n    * @dev Add new deputy owner.\n    * Only Owner can call this function\n    * New Deputy should not be zero address\n    * New Deputy should not be be already exisitng\n    * emit DeputyOwnerUdpatd event\n    * @param _newDO Address of new deputy owner\n   */\n  function addDeputyOwner(address _newDO)\n    public\n    onlyOwner\n  {\n    require(!isDeputyOwner[_newDO], \"Deputy Owner already exists\");\n    require(_newDO != address(0), \"Zero address not allowed\");\n    deputyOwners.push(_newDO);\n    isDeputyOwner[_newDO] = true;\n    emit DeputyOwnerUpdated(_newDO, true);\n  }\n\n  /**\n    * @dev Remove an existing deputy owner.\n    * Only Owner can call this function\n    * Given address should be a deputy owner\n    * emit DeputyOwnerUdpatd event\n    * @param _existingDO Address of existing deputy owner\n   */\n  function removeDeputyOwner(address _existingDO)\n    public\n    onlyOwner\n  {\n    require(isDeputyOwner[_existingDO], \"Deputy Owner does not exits\");\n    uint existingId;\n    for(uint i=0; i<deputyOwners.length; i++) {\n      if(deputyOwners[i] == _existingDO) existingId=i;\n    }\n\n    // swap this with last element\n    deputyOwners[existingId] = deputyOwners[deputyOwners.length-1];\n    deputyOwners.pop();\n    isDeputyOwner[_existingDO] = false;\n    emit DeputyOwnerUpdated(_existingDO, false);\n  }\n\n  /**\n   * @dev Renounce the ownership.\n   * This will leave the contract without any owner.\n   * Only owner can call this function\n   * @param _validationCode A code to prevent aaccidental calling of this function\n   */\n  function renounceOwnership(uint _validationCode)\n    public\n    onlyOwner\n  {\n    require(_validationCode == 123456789, \"Invalid code\");\n    owner = address(0);\n    emit OwnershipUpdated(msg.sender, owner);\n  }\n  \n  /**\n   * @dev Get deputy owner at given index\n   * @param index Index at which deputy owner is fetched from list of deputy owners\n   * @return returns deputy owner at provided index\n   */\n  function getDeputyOwners(uint index) public view returns (address) {\n    return deputyOwners[index];\n  }\n\n}"
    },
    "contract/SecondaryMarketFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./ISecondaryMarketFee.sol\";\nimport \"./Ownership.sol\";\n\n\ncontract SecondaryMarketFee is ISecondaryMarketFees, Ownership {\n\n  address public ownerContract;\n  uint256 public decimals;\n\n  mapping (uint256 => Fee[]) public fees;\n\n  /*\n    * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\n    * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n    *\n    * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\n    */\n  bytes4 public constant _INTERFACE_ID_FEES = 0xb7799584;\n\n  event SecondarySaleFees(uint256 tokenId, Fee[] _fees);\n\n  constructor() {\n    decimals = 3; // this makes min fee to be 0.001% for any recipient\n  }\n\n\n  /**\n   * @dev Get fee recipients when asset is sold in secondary market\n   * @param tokenId Id of NFT for which fee recipients are to be fetched\n   * @return array of addresses that'll recieve the commission when sold in secondary market\n   */\n  function getFeeRecipients(uint256 tokenId) public override view returns(address[] memory) {\n    Fee[] memory _fees = fees[tokenId];\n    address[] memory _recipients = new address[](_fees.length);\n    for(uint256 i=0;  i<_fees.length; i++) {\n      _recipients[i] = _fees[i].recipient;\n    }\n    return _recipients;\n  }\n\n\n  /**\n   * @dev Get fee values when asset is sold in secondary market\n   * @param tokenId Id of NFT for which fee values are to be fetched\n   * @return array of fees percentages that'll the recipients wil get when sold in secondary market\n   */\n  function getFeeBps(uint256 tokenId) public override view returns(uint256[] memory) {\n    Fee[] memory _fees = fees[tokenId];\n    uint256[] memory _values = new uint256[](_fees.length);\n    for(uint256 i=0;  i<_fees.length; i++) {\n      _values[i] = _fees[i].value;\n    }\n    return _values;\n  }\n\n  /**\n   * @dev Add fees (address and percentage) for a tokenId\n   * @param tokenId Id of NFT for which fee values are to be added\n   * @param _fees Fee struct (with address and fee percentage) for given `tokenId`\n   * @dev array of fees percentages that'll the recipients wil get when sold in secondary market\n   */\n  function addFees(uint256 tokenId, Fee[] memory _fees) internal {\n    uint256 totalPercentage = 0;\n    for (uint256 i = 0; i < _fees.length; i++) {\n      require(_fees[i].recipient != address(0x0), \"Recipient should be present\");\n      require(_fees[i].value != 0, \"Fee value should not be zero\");\n      totalPercentage += _fees[i].value;\n      fees[tokenId].push(_fees[i]);\n    }\n    require(totalPercentage < 100 * 10 ** decimals, \"percentage should be max 100\");\n    emit SecondarySaleFees(tokenId, _fees);\n  }\n\n  function removeFees(uint256 tokenId) internal {\n    delete(fees[tokenId]);\n  }\n\n\n}"
    },
    "contract/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n   \n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}"
    },
    "contract/SupportsInterfaceWithLookup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @title SupportsInterfaceWithLookup\n * @dev Implements ERC165 using a lookup table.\n */\ncontract SupportsInterfaceWithLookup is ERC165 {\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it's supported\n   */\n  mapping(bytes4 => bool) internal supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n  {\n    _registerInterface(InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 _interfaceId)\n    external\n    override\n    view\n    returns (bool)\n  {\n    return supportedInterfaces[_interfaceId];\n  }\n\n  /**\n   * @dev private method for registering an interface\n   */\n  function _registerInterface(bytes4 _interfaceId)\n    internal\n  {\n    require(_interfaceId != 0xffffffff);\n    supportedInterfaces[_interfaceId] = true;\n  }\n}"
    }
  }
}