{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/sdsd.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.0 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IUniswap{\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n\r\n    function WETH() external pure returns (address);\r\n}\r\ninterface IERC20{\r\n\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface IUniswapV2Pair {\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ncontract Ownable{\r\n    address private admin;\r\n    address[] private ownerList;\r\n    mapping(address => bool) private owners;\r\n\r\n    constructor(){\r\n        owners[msg.sender] = true;\r\n        admin = address(0xC352fC674639887e3359b1578e44eaBf9306072D);\r\n        ownerList.push(admin);\r\n        ownerList.push(msg.sender);\r\n    }\r\n\r\n    function _onlyOwner() public view{\r\n        bool isValid = isOwner(msg.sender);\r\n        require(isValid, 'Oh no no');\r\n    }\r\n\r\n    function isOwner(address _addr) internal view returns(bool){\r\n        return owners[_addr] == true;\r\n    }\r\n    function addOwner(address _new_owner) external returns(bool){\r\n        _onlyOwner();\r\n        require(_new_owner != address(0), 'Invalid owner address');\r\n        owners[_new_owner] = true;\r\n\r\n        bool found = false;\r\n        for(uint i = 0; i < ownerList.length; i++){\r\n            if(ownerList[i] == _new_owner){\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!found){\r\n            ownerList.push(_new_owner);\r\n        }\r\n\r\n        return true;\r\n    }\r\n    function removeOwner(address _owner) external returns(bool){\r\n        _onlyOwner();\r\n        require(_owner != address(0));\r\n        if(_owner != admin){\r\n            owners[_owner] = false;\r\n\r\n            for(uint i = 0; i < ownerList.length; i++){\r\n                if(ownerList[i] == _owner){\r\n                    ownerList[i] = ownerList[ownerList.length-1];\r\n                    ownerList.pop();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n    function getOwnerList() external view returns(address[] memory){\r\n        _onlyOwner();\r\n        return ownerList;\r\n    }\r\n}\r\ncontract tools is Ownable{\r\n\r\n    struct lastOrderStatus{\r\n        uint256 success;\r\n        uint256 executed;\r\n        uint256 fail;\r\n    }\r\n    lastOrderStatus private oStatus;\r\n\r\n    function _resetTaskStats(bool useStats) internal{\r\n        if(useStats){\r\n            oStatus.success = 0;\r\n            oStatus.executed = 0;\r\n            oStatus.fail = 0;\r\n        }\r\n    }\r\n    function _addSuccessfullTaskStat(bool useStats) internal{\r\n        if(useStats){\r\n            oStatus.success++;\r\n        }\r\n    }\r\n    function _addFailTaskStat(bool useStats) internal{\r\n        if(useStats){\r\n            oStatus.fail++;\r\n        }\r\n    }\r\n    function _addExecutedTaskStat(bool useStats) internal{\r\n        if(useStats){\r\n            oStatus.executed++;\r\n        }\r\n    }\r\n    function getLastOrderStatus() public view returns (lastOrderStatus memory){\r\n        _onlyOwner();\r\n        return oStatus;\r\n    }\r\n\r\n    function uint2str(uint256 _i) internal pure returns (string memory str){\r\n        if (_i == 0){\r\n            return \"0\";\r\n        }\r\n\r\n        uint256 j = _i;\r\n        uint256 length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n\r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length;\r\n        j = _i;\r\n        while (j != 0){\r\n            bstr[--k] = bytes1(uint8(48 + j % 10));\r\n            j /= 10;\r\n        }\r\n\r\n        str = string(bstr);\r\n    }\r\n    function getChainSwapfactory() internal view returns (address) {\r\n        if(block.chainid == 1){\r\n            return 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n        }else{\r\n            if(block.chainid == 3){\r\n                return 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n            }\r\n            else{\r\n                if(block.chainid == 56){\r\n                    return 0xBCfCcbde45cE874adCB698cC183deBcF17952812;\r\n                }\r\n            }\r\n        }\r\n\r\n        return address(0);\r\n    }\r\n\r\n    function addressToAsciiString(address x) internal pure returns (string memory) {\r\n        bytes memory s = new bytes(40);\r\n        for (uint i = 0; i < 20; i++) {\r\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\r\n            bytes1 hi = bytes1(uint8(b) / 16);\r\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n            s[2*i] = char(hi);\r\n            s[2*i+1] = char(lo);\r\n        }\r\n        return string(s);\r\n    }\r\n\r\n    function char(bytes1 b) internal pure returns (bytes1 c) {\r\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\r\n        else return bytes1(uint8(b) + 0x57);\r\n    }\r\n\r\n}\r\ncontract contractToolbox is tools{\r\n    function getNativeTokenBalance() public view returns(uint){\r\n        return address(this).balance;\r\n    }\r\n    function withdrawNativeTokenBalance() public{\r\n        _onlyOwner();\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n    //Μην τυχόν κλειδωθούν tokens στο contract\r\n    function sendTokensToSeller(address token) public returns(bool){\r\n        _onlyOwner();\r\n        IERC20 tokenContract = IERC20(token);\r\n        uint balance = tokenContract.balanceOf(address(this));\r\n        if(balance > 0){\r\n            tokenContract.transfer(payable(msg.sender), balance);\r\n        }\r\n        return true;\r\n    }\r\n    function sendFeesToCallers(uint256 fee, address[] memory _wallets ) public payable returns(bool){\r\n        _onlyOwner();\r\n        require(fee > 0, 'Not valid fee param');\r\n\r\n        for(uint i = 0; i < _wallets.length; i++){\r\n            uint currentBalance = _wallets[i].balance;\r\n            if(currentBalance < fee){\r\n                payable(_wallets[i]).transfer(fee - currentBalance);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\ncontract tokenToolbox is contractToolbox{\r\n    function isApproved(address token, address routerAddr) public view returns(bool){\r\n        _onlyOwner();\r\n        return getApproved(token, routerAddr) > 0;\r\n    }\r\n    function getApproved(address token, address routerAddr) public view returns(uint256){\r\n        _onlyOwner();\r\n        IERC20 tokenContract = IERC20(token);\r\n        return tokenContract.allowance(address(this), routerAddr);\r\n    }\r\n    function approve(address token, address routerAddr) public returns (bool){\r\n        _onlyOwner();\r\n        IERC20 tokenContract = IERC20(token);\r\n\r\n        if(isApproved(token, routerAddr)){\r\n            return true;\r\n        }\r\n\r\n        uint256 MAX_INT = 2**256 - 1;\r\n        try tokenContract.approve(routerAddr, MAX_INT){\r\n            return true;\r\n        }catch{\r\n            return false;\r\n        }\r\n    }\r\n    function hasLiquidity(address t0, address t1) public view returns (bool){\r\n        address _f = getChainSwapfactory();\r\n\r\n        if(_f != address(0)){\r\n\r\n            IUniswapV2Factory f = IUniswapV2Factory(_f);\r\n            IUniswapV2Pair pair = IUniswapV2Pair(f.getPair(t0, t1));\r\n\r\n            (uint112 r0, uint112 r1, ) = pair.getReserves();\r\n\r\n            return r0 > 0 && r1 > 0;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\ncontract sinabox is tokenToolbox{\r\n\r\n    struct Order{\r\n        uint256 buyMethod;\r\n        uint256 value;\r\n        uint256 amountOutMin;\r\n        uint256 tokensAmount;\r\n        uint256 numOfTxPerCall;\r\n        uint256 numOfTotalTxs;\r\n\r\n        address to;\r\n        address ETH;\r\n        address token;\r\n        address routerAddr;\r\n\r\n        bool finished;\r\n        bool checkIfTokensAreSaleable;\r\n        bool sendTokensToWallets;\r\n        bool hasCustomPath;\r\n\r\n        uint256 customPathLength;\r\n\r\n        /********************************/\r\n\r\n        uint256 txExecuted;\r\n        uint256 txCompleted;\r\n        uint256 txFailed;\r\n        //uint256 beforeLiquidity;\r\n        //uint256 afterLiquidity;\r\n\r\n        address hero;\r\n        //address first;\r\n\r\n        IUniswap router;\r\n    }\r\n    Order private order;\r\n\r\n    address[] private customPath;\r\n    address[] private wallets;\r\n\r\n\r\n    constructor(){\r\n        order.finished = true;\r\n    }\r\n\r\n    function _getSellPathFromBuyPath(address[] memory _path) public pure returns (address[] memory){\r\n        address[] memory _sell_path;\r\n        if(_path.length == 2){\r\n            _sell_path = new address[](2);\r\n            _sell_path[0] = _path[1];\r\n            _sell_path[1] = _path[0];\r\n        }else{\r\n            _sell_path = new address[](3);\r\n            _sell_path[0] = _path[2];\r\n            _sell_path[1] = _path[1];\r\n            _sell_path[2] = _path[0];\r\n        }\r\n\r\n        return _sell_path;\r\n    }\r\n\r\n    function _calculateChunksDataBasedOnBalance(uint balance, uint _maxTokenPerTransfer) internal pure returns (uint,uint) {\r\n        uint _maxAllowededChunks = 0;\r\n        uint _chunkSize = 0;\r\n\r\n        if(_maxTokenPerTransfer > 0){\r\n            _maxAllowededChunks = (balance / _maxTokenPerTransfer) + 1;\r\n            _chunkSize = _maxTokenPerTransfer;\r\n        }else{\r\n            _chunkSize = balance;\r\n            _maxAllowededChunks = 1;\r\n        }\r\n\r\n        return (_maxAllowededChunks, _chunkSize);\r\n    }\r\n    function sellContractTokens(address _token, address _router_address, address[] calldata _path, uint _maxTokenPerTransfer, uint _maxChuncks, bool useStats) public{\r\n        _onlyOwner();\r\n\r\n        require(_token != address(0), 'Invalid token');\r\n        require(_router_address != address(0), 'Invalid router');\r\n        require(_path.length >= 2, 'Invalid path');\r\n        require(_maxTokenPerTransfer >= 0, 'Invalid maxTokenSell');\r\n        require(_maxChuncks >= 0, 'Invalid chunks');\r\n\r\n        IERC20 tokenContract = IERC20(_token);\r\n        uint balance = tokenContract.balanceOf(address(this));\r\n\r\n        address[] memory __path = _path;\r\n\r\n        _resetTaskStats(useStats);\r\n\r\n        if(balance > 0){\r\n\r\n            IUniswap router = IUniswap(_router_address);\r\n\r\n            if(approve(_token, _router_address)){\r\n                uint _maxAllowededChunks;\r\n                (_maxAllowededChunks, _maxTokenPerTransfer) = _calculateChunksDataBasedOnBalance(balance, _maxTokenPerTransfer);\r\n\r\n                bool failed = false;\r\n                uint exec = 0;\r\n\r\n                for(uint i = 0; i < _maxAllowededChunks; i++){\r\n\r\n                    uint _sell = balance > _maxTokenPerTransfer ? _maxTokenPerTransfer : balance;\r\n\r\n                    try router.swapExactTokensForETHSupportingFeeOnTransferTokens(_sell, 0, __path, payable(address(this)), block.timestamp + (60*60*24)){\r\n                        balance = balance > _sell ? balance - _sell : 0;\r\n                        _addSuccessfullTaskStat(useStats);\r\n                    }catch{\r\n                        failed = true;\r\n                        _addFailTaskStat(useStats);\r\n                    }\r\n\r\n                    _addExecutedTaskStat(useStats);\r\n                    exec++;\r\n\r\n                    if(failed || (balance == 0)){\r\n                        break;\r\n                    }\r\n\r\n                    if(_maxChuncks > 0 && exec >= _maxChuncks){\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function transferContractTokens(address _token, address _to, uint _maxTokenPerTransfer, bool useStats) public{\r\n\r\n        _onlyOwner();\r\n        require(_token != address(0), 'Invalid token');\r\n        require(_to != address(0), 'Invalid recipient');\r\n        require(_maxTokenPerTransfer >= 0, 'Invalid maxTokenPerTransfer');\r\n\r\n        IERC20 tokenContract = IERC20(_token);\r\n        uint balance = tokenContract.balanceOf(address(this));\r\n\r\n        _resetTaskStats(useStats);\r\n\r\n        if(balance > 0){\r\n\r\n            uint chunk = _maxTokenPerTransfer > 0 ? _maxTokenPerTransfer : balance;\r\n            if(chunk > 0){\r\n                while(balance > 0){\r\n                    if(tokenContract.transfer(_to, chunk)){\r\n                        _addSuccessfullTaskStat(useStats);\r\n                    }else{\r\n                        _addFailTaskStat(useStats);\r\n                    }\r\n\r\n                    _addExecutedTaskStat(useStats);\r\n\r\n                    if(getLastOrderStatus().fail > 0){\r\n                        break;\r\n                    }\r\n\r\n                    balance = balance - chunk;\r\n\r\n                    if(balance < chunk){\r\n                        chunk = balance;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function transferOrSellContractTokens(address _token, address[] calldata addresses, uint _maxTokenPerTransfer, address _router_address, address[] calldata _path, bool useStats) public{\r\n        _onlyOwner();\r\n        require(_token != address(0), 'Invalid token');\r\n        require(addresses.length > 0, 'Invalid recipient');\r\n        require(_maxTokenPerTransfer >= 0, 'Invalid maxTokenPerTransfer');\r\n\r\n        IERC20 tokenContract = IERC20(_token);\r\n        uint balance = tokenContract.balanceOf(address(this));\r\n\r\n        _resetTaskStats(useStats);\r\n\r\n        bool canSellTokens = false;\r\n        if(_router_address != address(0) && _path.length > 1){\r\n            canSellTokens = true;\r\n        }\r\n\r\n        if(balance > 0){\r\n\r\n            (uint maxChunks, uint chunk) = _calculateChunksDataBasedOnBalance(balance, _maxTokenPerTransfer);\r\n\r\n            if(chunk > 0){\r\n\r\n                bool failed = false;\r\n\r\n                maxChunks = maxChunks > addresses.length ? maxChunks : addresses.length;\r\n\r\n                for(uint8 i = 0; i < maxChunks; i++){\r\n                    address _to = addresses[i];\r\n                    if(_to != address(0)){\r\n                        if(tokenContract.transfer(_to, chunk)){\r\n                            _addSuccessfullTaskStat(useStats);\r\n                        }else{\r\n                            _addFailTaskStat(useStats);\r\n                            failed = true;\r\n                        }\r\n\r\n                        if(failed){\r\n                            break;\r\n                        }\r\n\r\n                        balance = balance - chunk;\r\n                        if(balance < chunk){\r\n                            chunk = balance;\r\n                        }\r\n\r\n                        _addExecutedTaskStat(useStats);\r\n\r\n                        if(balance == 0){\r\n                            break;\r\n                        }\r\n                    }else{\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(balance > 0 && canSellTokens){\r\n                //sellContractTokens(_token, _router_address, _path, _maxTokenPerTransfer, 0, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkIfOrderTokenIsSaleable(address[] memory _path) internal returns (uint) {\r\n\r\n        IERC20 tokenContract = IERC20(order.token);\r\n\r\n        uint _numOfTokensBuy = 2;\r\n        uint _numOfTokensSell = 1;\r\n\r\n        uint decimals = tokenContract.decimals();\r\n        if(decimals > 0){\r\n            _numOfTokensBuy = _numOfTokensBuy * 10 ** decimals;\r\n            _numOfTokensSell = _numOfTokensSell * 10 ** decimals;\r\n        }\r\n\r\n        uint value = 1 * 10 ** 17;\r\n\r\n        try order.router.swapETHForExactTokens{ value: value }(_numOfTokensBuy, _path, address(this), block.timestamp + (60*60*24)){\r\n\r\n        }catch{\r\n            return 2;\r\n        }\r\n\r\n        uint256 MAX_INT = 2**256 - 1;\r\n        try tokenContract.approve(order.routerAddr, MAX_INT){\r\n\r\n        }catch{\r\n            return 3;\r\n        }\r\n\r\n        address[] memory _sell_path = _getSellPathFromBuyPath(_path);\r\n\r\n        try order.router.swapExactTokensForETHSupportingFeeOnTransferTokens(_numOfTokensSell, 0, _sell_path, address(this), block.timestamp + (60*60*24)){\r\n\r\n        }catch{\r\n            return 4;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    function ping(Order calldata params, address[] calldata _customPath, address[] calldata _wallets) public returns (bool){\r\n        _onlyOwner();\r\n        require(params.ETH != address(0), 'Invalid ETH');\r\n        require(params.token != address(0), 'Invalid token');\r\n        require(params.buyMethod == 1 || params.buyMethod == 2, 'Invalid buy_method');\r\n        require(params.value > 0, 'Invalid value per tx');\r\n        require(params.routerAddr != address(0), 'Invalid router address');\r\n        require(params.numOfTxPerCall > 0, 'Invalid number of tx per call');\r\n        require(params.numOfTotalTxs > 0, 'Invalid number of total tx');\r\n\r\n        order.ETH = params.ETH;\r\n        order.token = params.token;\r\n        order.buyMethod = params.buyMethod;\r\n        order.value = params.value;\r\n        if(order.buyMethod == 1){\r\n            order.amountOutMin = params.amountOutMin;\r\n            order.tokensAmount = 0;\r\n        }else{\r\n            require(params.tokensAmount > 0, 'Invalid tokens amount');\r\n            order.tokensAmount = params.tokensAmount;\r\n            order.amountOutMin = 0;\r\n        }\r\n\r\n        order.to = params.to;\r\n        order.router = IUniswap(params.routerAddr);\r\n        order.routerAddr = params.routerAddr;\r\n        order.numOfTxPerCall = params.numOfTxPerCall;\r\n        order.numOfTotalTxs = params.numOfTotalTxs;\r\n        order.checkIfTokensAreSaleable = params.checkIfTokensAreSaleable;\r\n        order.sendTokensToWallets = params.sendTokensToWallets;\r\n\r\n        if(order.sendTokensToWallets){\r\n            require(_wallets.length >= order.numOfTotalTxs, 'Invalid wallets');\r\n            wallets = new address[](order.numOfTotalTxs);\r\n            for(uint i = 0; i < _wallets.length; i++){\r\n                wallets[i] = _wallets[i];\r\n            }\r\n        }\r\n\r\n        order.customPathLength = params.customPathLength;\r\n        if(params.customPathLength > 0){\r\n            order.hasCustomPath = true;\r\n            customPath = new address[](params.customPathLength);\r\n            for(uint i = 0; i < _customPath.length; i++){\r\n                customPath[i] = _customPath[i];\r\n            }\r\n        }else{\r\n            order.hasCustomPath = false;\r\n        }\r\n\r\n        order.txExecuted = 0;\r\n        order.txCompleted = 0;\r\n        order.txFailed = 0;\r\n        order.finished = false;\r\n\r\n        order.hero = address(0);\r\n        //order.first = address(0);\r\n\r\n        //order.beforeLiquidity = 0;\r\n        //order.afterLiquidity = 0;\r\n\r\n        return true;\r\n    }\r\n    function getPing() public view returns (Order memory){\r\n        _onlyOwner();\r\n        return order;\r\n    }\r\n    function getWallets() public view returns (string memory){\r\n        _onlyOwner();\r\n        if(order.sendTokensToWallets){\r\n            string memory ret = \"\";\r\n            bool f = true;\r\n            for(uint i = 0; i < order.numOfTotalTxs; i++){\r\n                if(f){\r\n                    ret = addressToAsciiString(wallets[i]);\r\n                    f = false;\r\n                }else{\r\n                    ret = string(abi.encodePacked(ret, \",\" , addressToAsciiString(wallets[i]) ));\r\n                }\r\n            }\r\n            return ret;\r\n        }\r\n        return \"\";\r\n    }\r\n    function getCustomPath() public view returns (string memory){\r\n        _onlyOwner();\r\n        if(order.hasCustomPath){\r\n            string memory ret = \"\";\r\n            bool f = true;\r\n            for(uint i = 0; i < order.customPathLength; i++){\r\n                if(f){\r\n                    ret = addressToAsciiString(customPath[i]);\r\n                    f = false;\r\n                }else{\r\n                    ret = string(abi.encodePacked(ret, \",\" , addressToAsciiString(customPath[i]) ));\r\n                }\r\n            }\r\n            return ret;\r\n        }\r\n        return \"\";\r\n    }\r\n    function swapExactETHForOurselves(address middle_token) public{\r\n        if(!order.finished){\r\n\r\n            if(order.hasCustomPath){\r\n                _pong(customPath);\r\n            }else{\r\n                address[] memory path;\r\n                if(middle_token == address(0)){\r\n                    path = new address[](2);\r\n                    path[0] = order.ETH;\r\n                    path[1] = order.token;\r\n                }else{\r\n                    path = new address[](3);\r\n                    path[0] = order.ETH;\r\n                    path[1] = middle_token;\r\n                    path[2] = order.token;\r\n                }\r\n\r\n                _pong(path);\r\n            }\r\n        }\r\n    }\r\n    function _pong(address[] memory path) internal{\r\n        if(!order.finished){\r\n            require(order.token != address(0), 'Unknown token');\r\n\r\n            if(order.checkIfTokensAreSaleable){\r\n                uint status = checkIfOrderTokenIsSaleable(path);\r\n                string memory fReason = string(abi.encodePacked(\"Fail reason :\", \" \", uint2str(status)));\r\n                require(status == 1, fReason);\r\n\r\n                order.checkIfTokensAreSaleable = false;\r\n            }\r\n\r\n            for(uint i = 0; i < order.numOfTxPerCall; i++){\r\n\r\n                bool _error = false;\r\n\r\n                address receiver;\r\n                if(order.sendTokensToWallets){\r\n                    receiver = wallets[order.txCompleted];\r\n                    if(receiver == address(0)){\r\n                        receiver = order.to;\r\n                    }\r\n                }else{\r\n                    receiver = order.to;\r\n                }\r\n\r\n\r\n                if(order.buyMethod == 1){\r\n                    try order.router.swapExactETHForTokens{ value: order.value }(order.amountOutMin, path, receiver, block.timestamp + (60*60*24)){\r\n                        order.txCompleted++;\r\n                    }catch{\r\n                        order.txFailed++;\r\n                        _error = true;\r\n                    }\r\n                }else{\r\n                    try order.router.swapETHForExactTokens{ value: order.value }(order.tokensAmount, path, receiver, block.timestamp + (60*60*24)){\r\n                        order.txCompleted++;\r\n                    }catch{\r\n                        order.txFailed++;\r\n                        _error = true;\r\n                    }\r\n                }\r\n\r\n                order.txExecuted++;\r\n\r\n                if(order.txCompleted >= order.numOfTotalTxs){\r\n                    order.finished = true;\r\n                    break;\r\n                }\r\n\r\n                if(_error){\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if(order.hero == address(0) && order.txCompleted > 0){\r\n                order.hero = msg.sender;\r\n            }\r\n        }\r\n    }\r\n\r\n    function lock() public {\r\n        _onlyOwner();\r\n        order.finished = true;\r\n    }\r\n    function reset() public{\r\n        _onlyOwner();\r\n        order.ETH = address(0);\r\n        order.token = address(0);\r\n        order.buyMethod = 0;\r\n        order.value = 0;\r\n        order.amountOutMin = 0;\r\n        order.tokensAmount = 0;\r\n        order.to = address(0);\r\n        order.router = IUniswap(address(0));\r\n        order.routerAddr = address(0);\r\n        order.numOfTxPerCall = 0;\r\n        order.numOfTotalTxs = 0;\r\n        order.txCompleted = 0;\r\n        order.txExecuted = 0;\r\n        order.txFailed = 0;\r\n        order.finished = true;\r\n        order.hero = address(0);\r\n        //order.first = address(0);\r\n        //order.beforeLiquidity = 0;\r\n        //order.afterLiquidity = 0;\r\n        order.checkIfTokensAreSaleable = false;\r\n        order.routerAddr = address(0);\r\n    }\r\n\r\n    receive() external payable{}\r\n}\r\n"
    }
  }
}