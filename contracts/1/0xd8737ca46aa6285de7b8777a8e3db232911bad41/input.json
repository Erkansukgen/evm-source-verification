{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "localhost/contracts/StafiBase.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"./interfaces/storage/IStafiStorage.sol\";\n\nabstract contract StafiBase {\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    IStafiStorage stafiStorage = IStafiStorage(0);\n\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.trusted\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered staking pool\n    */\n    modifier onlyRegisteredStakingPool(address _stakingPoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"stakingpool.exists\", _stakingPoolAddress))), \"Invalid staking pool\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(roleHas(\"owner\", msg.sender), \"Account is not the owner\");\n        _;\n    }\n\n\n    /**\n    * @dev Modifier to scope access to admins\n    */\n    modifier onlyAdmin() {\n        require(roleHas(\"admin\", msg.sender), \"Account is not an admin\");\n        _;\n    }\n\n\n    /**\n    * @dev Modifier to scope access to admins\n    */\n    modifier onlySuperUser() {\n        require(roleHas(\"owner\", msg.sender) || roleHas(\"admin\", msg.sender), \"Account is not a super user\");\n        _;\n    }\n\n\n    /**\n    * @dev Reverts if the address doesn't have this role\n    */\n    modifier onlyRole(string memory _role) {\n        require(roleHas(_role, msg.sender), \"Account does not match the specified role\");\n        _;\n    }\n\n\n    /// @dev Set the main Storage address\n    constructor(address _stafiStorageAddress) public {\n        // Update the contract address\n        stafiStorage = IStafiStorage(_stafiStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(keccak256(abi.encodePacked(contractName)) != keccak256(abi.encodePacked(\"\")), \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return stafiStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint256) { return stafiStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return stafiStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return stafiStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return stafiStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int256) { return stafiStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return stafiStorage.getBytes32(_key); }\n    function getAddressS(string memory _key) internal view returns (address) { return stafiStorage.getAddress(keccak256(abi.encodePacked(_key))); }\n    function getUintS(string memory _key) internal view returns (uint256) { return stafiStorage.getUint(keccak256(abi.encodePacked(_key))); }\n    function getStringS(string memory _key) internal view returns (string memory) { return stafiStorage.getString(keccak256(abi.encodePacked(_key))); }\n    function getBytesS(string memory _key) internal view returns (bytes memory) { return stafiStorage.getBytes(keccak256(abi.encodePacked(_key))); }\n    function getBoolS(string memory _key) internal view returns (bool) { return stafiStorage.getBool(keccak256(abi.encodePacked(_key))); }\n    function getIntS(string memory _key) internal view returns (int256) { return stafiStorage.getInt(keccak256(abi.encodePacked(_key))); }\n    function getBytes32S(string memory _key) internal view returns (bytes32) { return stafiStorage.getBytes32(keccak256(abi.encodePacked(_key))); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { stafiStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint256 _value) internal { stafiStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { stafiStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { stafiStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { stafiStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int256 _value) internal { stafiStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { stafiStorage.setBytes32(_key, _value); }\n    function setAddressS(string memory _key, address _value) internal { stafiStorage.setAddress(keccak256(abi.encodePacked(_key)), _value); }\n    function setUintS(string memory _key, uint256 _value) internal { stafiStorage.setUint(keccak256(abi.encodePacked(_key)), _value); }\n    function setStringS(string memory _key, string memory _value) internal { stafiStorage.setString(keccak256(abi.encodePacked(_key)), _value); }\n    function setBytesS(string memory _key, bytes memory _value) internal { stafiStorage.setBytes(keccak256(abi.encodePacked(_key)), _value); }\n    function setBoolS(string memory _key, bool _value) internal { stafiStorage.setBool(keccak256(abi.encodePacked(_key)), _value); }\n    function setIntS(string memory _key, int256 _value) internal { stafiStorage.setInt(keccak256(abi.encodePacked(_key)), _value); }\n    function setBytes32S(string memory _key, bytes32 _value) internal { stafiStorage.setBytes32(keccak256(abi.encodePacked(_key)), _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { stafiStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { stafiStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { stafiStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { stafiStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { stafiStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { stafiStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { stafiStorage.deleteBytes32(_key); }\n    function deleteAddressS(string memory _key) internal { stafiStorage.deleteAddress(keccak256(abi.encodePacked(_key))); }\n    function deleteUintS(string memory _key) internal { stafiStorage.deleteUint(keccak256(abi.encodePacked(_key))); }\n    function deleteStringS(string memory _key) internal { stafiStorage.deleteString(keccak256(abi.encodePacked(_key))); }\n    function deleteBytesS(string memory _key) internal { stafiStorage.deleteBytes(keccak256(abi.encodePacked(_key))); }\n    function deleteBoolS(string memory _key) internal { stafiStorage.deleteBool(keccak256(abi.encodePacked(_key))); }\n    function deleteIntS(string memory _key) internal { stafiStorage.deleteInt(keccak256(abi.encodePacked(_key))); }\n    function deleteBytes32S(string memory _key) internal { stafiStorage.deleteBytes32(keccak256(abi.encodePacked(_key))); }\n\n\n    /**\n    * @dev Check if an address has this role\n    */\n    function roleHas(string memory _role, address _address) internal view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"access.role\", _role, _address)));\n    }\n\n}\n"
    },
    "localhost/contracts/StafiUpgrade.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"./StafiBase.sol\";\nimport \"./interfaces/IStafiUpgrade.sol\";\n\n// Handles contract upgrades\ncontract StafiUpgrade is StafiBase, IStafiUpgrade {\n\n    // Events\n    event ContractUpgraded(bytes32 indexed name, address indexed oldAddress, address indexed newAddress, uint256 time);\n    event ContractAdded(bytes32 indexed name, address indexed newAddress, uint256 time);\n\n    // Construct\n    constructor(address _stafiStorageAddress) StafiBase(_stafiStorageAddress) public {\n        version = 1;\n    }\n\n    // Upgrade contract\n    function upgradeContract(string memory _name, address _contractAddress) override external onlyLatestContract(\"stafiUpgrade\", address(this)) onlySuperUser {\n        // Check contract being upgraded\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\n        require(nameHash != keccak256(abi.encodePacked(\"stafiEther\")), \"Cannot upgrade the stafi ether contract\");\n        require(nameHash != keccak256(abi.encodePacked(\"rETHToken\")), \"Cannot upgrade token contracts\");\n        require(nameHash != keccak256(abi.encodePacked(\"ethDeposit\")), \"Cannot upgrade the eth deposit contract\");\n        // Get old contract address & check contract exists\n        address oldContractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _name)));\n        require(oldContractAddress != address(0x0), \"Contract does not exist\");\n        // Check new contract address\n        require(_contractAddress != address(0x0), \"Invalid contract address\");\n        require(_contractAddress != oldContractAddress, \"The contract address cannot be set to its current address\");\n        // Register new contract\n        setBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress)), true);\n        setString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)), _name);\n        setAddress(keccak256(abi.encodePacked(\"contract.address\", _name)), _contractAddress);\n        // Deregister old contract\n        deleteString(keccak256(abi.encodePacked(\"contract.name\", oldContractAddress)));\n        deleteBool(keccak256(abi.encodePacked(\"contract.exists\", oldContractAddress)));\n        // Emit contract upgraded event\n        emit ContractUpgraded(nameHash, oldContractAddress, _contractAddress, now);\n    }\n\n    // Add a new network contract\n    function addContract(string memory _name, address _contractAddress) override external onlyLatestContract(\"stafiUpgrade\", address(this)) onlySuperUser {\n        // Check contract name\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\n        require(nameHash != keccak256(abi.encodePacked(\"\")), \"Invalid contract name\");\n        require(getAddress(keccak256(abi.encodePacked(\"contract.address\", _name))) == address(0x0), \"Contract name is already in use\");\n        // Check contract address\n        require(_contractAddress != address(0x0), \"Invalid contract address\");\n        require(!getBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress))), \"Contract address is already in use\");\n        // Register contract\n        setBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress)), true);\n        setString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)), _name);\n        setAddress(keccak256(abi.encodePacked(\"contract.address\", _name)), _contractAddress);\n        // Emit contract added event\n        emit ContractAdded(nameHash, _contractAddress, now);\n    }\n\n    // Init stafi storage contract\n    function initStorage(bool _value) external onlySuperUser {\n        setBool(keccak256(abi.encodePacked(\"contract.storage.initialised\")), _value);\n    }\n\n    // Init stafi upgrade contract\n    function initThisContract() external onlySuperUser {\n        addStafiUpgradeContract(address(this));\n    }\n\n    // Upgrade stafi upgrade contract\n    function upgradeThisContract(address _contractAddress) external onlySuperUser {\n        addStafiUpgradeContract(_contractAddress);\n    }\n\n    // Add stafi upgrade contract\n    function addStafiUpgradeContract(address _contractAddress) private {\n        string memory name = \"stafiUpgrade\";\n        bytes32 nameHash = keccak256(abi.encodePacked(name));\n        address oldContractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", name)));\n        if (oldContractAddress != address(0x0)) {\n            deleteBool(keccak256(abi.encodePacked(\"contract.exists\", oldContractAddress)));\n            deleteString(keccak256(abi.encodePacked(\"contract.name\", oldContractAddress)));\n        }\n        setBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress)), true);\n        setString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)), name);\n        setAddress(keccak256(abi.encodePacked(\"contract.address\", name)), _contractAddress);\n        // Emit contract added event\n        emit ContractAdded(nameHash, _contractAddress, now);\n    }\n\n}\n"
    },
    "localhost/contracts/interfaces/IStafiUpgrade.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiUpgrade {\n    function upgradeContract(string calldata _name, address _contractAddress) external;\n    function addContract(string calldata _name, address _contractAddress) external;\n}\n"
    },
    "localhost/contracts/interfaces/storage/IStafiStorage.sol": {
      "content": "pragma solidity 0.6.12;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiStorage {\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n}\n"
    }
  }
}