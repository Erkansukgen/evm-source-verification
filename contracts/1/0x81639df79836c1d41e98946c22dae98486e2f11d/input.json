{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/trader.sol":{"content":"pragma solidity ^0.6.6;\npragma experimental ABIEncoderV2;\n\ninterface ERC20 {\n    function transfer(address _to, uint _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function approve(address _spender, uint _value) external returns (bool success);\n}\n\ninterface IGasToken {\n    function freeFrom(address from, uint256 value) external returns (bool success);\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n}\n\ninterface ITradeAsset {\n    function bridgeCall(address _to, uint _value, bytes calldata _payload) external returns (bool,bytes memory);\n}\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to,uint deadline) \n        external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external payable returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external returns (uint[] memory amounts);\n}\n\ninterface IDoDoPair {\n    function buyBaseToken(uint256 amount, uint256 maxPayQuote, bytes calldata data) external returns (uint256 payQuote);\n    function sellBaseToken(uint256 amount, uint256 minReceiveQuote, bytes calldata data) external returns (uint256 receiveQuote);\n}\n\ninterface IZeroExchangeCore {\n    function cancelOrder(LibOrder.Order calldata order) external;\n    function batchCancelOrders(LibOrder.Order[] calldata orders) external;\n} \n\ncontract LibOrder\n{\n    // solhint-disable max-line-length\n    struct Order {\n        address makerAddress;           // Address that created the order.      \n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          \n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      \n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        \n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        \n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          \n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     \n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n    }\n    // solhint-enable max-line-length\n}\n\ncontract PermissionGroups{\n    \n    address public admin;\n    address public pendingAdmin;\n    mapping(address=>bool) public operatorAllowed;\n    address[] internal operatorsGroup;\n    uint constant internal MAX_GROUP_SIZE = 50;\n    \n    constructor() public {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"onlyAdmin\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operatorAllowed[msg.sender],\"onlyOperator\");\n        _;\n    }\n    \n    function transferAdmin(address newAdmin) external onlyAdmin {\n        require(newAdmin != address(0),\"newAdmin == address(0)\");\n        pendingAdmin = newAdmin;\n    }\n\n    function claimAdmin() external {\n        require(pendingAdmin == msg.sender,\"pendingAdmin != msg.sender\");\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    function addOperator(address newOperator) external onlyAdmin {\n        require(!operatorAllowed[newOperator],\"duplicated newOperator\"); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE,\"operatorsGroup.length >= MAX_GROUP_SIZE.\");\n\n        emit OperatorAdded(newOperator, true);\n        operatorAllowed[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator (address operator) external onlyAdmin {\n        require(operatorAllowed[operator],\"operator is not in the operatorsGroup.\");\n        operatorAllowed[operator] = false;\n\n        for (uint i = 0; i < operatorsGroup.length; i++) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.pop();\n                emit OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n    \n    function getOperators() external view returns(address[] memory) {\n        return operatorsGroup;\n    }\n\n}\n\ncontract AssetManager is PermissionGroups{\n    \n    receive() external payable{}\n    fallback() external payable{}\n    \n    function withdrawEth(address payable _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        _to.transfer(_value);\n    }\n    \n    function withdrawToken(address _token, address _to, uint _value) external onlyAdmin{\n        require(_to != address(0),\"_to == address(0)\");\n        (bool success,bytes memory _data) = _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector,_to,_value));\n        require(success,\"ERC20(_token).transfer failed.\");\n        if(_data.length > 0){\n            require(abi.decode(_data,(bool)),\"ERC20(_token).transfer return data is false.\");\n        }\n    }\n\n}\n\ncontract Trader is AssetManager{\n    \n    address public assetAddress;\n    address public gasToken;\n    address public gasTokenPayer;\n    mapping(address=>bool) public tokenAllowed;\n    address[] internal tokensGroup;\n    \n    function setAssetAddress(address newAssetAddress) external onlyAdmin{\n        assetAddress = newAssetAddress;\n    }\n    \n    function setGasToken(address newGasToken) external onlyAdmin{\n        gasToken = newGasToken;\n    }\n    \n    function setGasTokenPayer(address newGasTokenPayer) external onlyAdmin{\n        gasTokenPayer = newGasTokenPayer;\n    }\n    \n    event TokenAdded(address newToken, bool isAdd);\n\n    function addTokens(address[] calldata newTokens) external onlyAdmin {\n        for(uint i=0; i<newTokens.length; i++){\n            addToken(newTokens[i]);\n        }\n    }\n    \n    function removeTokens (address[] calldata _tokens) external onlyAdmin {\n        for(uint i=0; i<_tokens.length; i++){\n            removeToken(_tokens[i]);\n        }\n    }\n    \n    function getTokensGroup() external view returns (address[] memory){\n        return tokensGroup;\n    }\n    \n    function addToken(address newToken) private {\n        require(!tokenAllowed[newToken],\"duplicated token\"); // prevent duplicates.\n\n        emit TokenAdded(newToken, true);\n        tokenAllowed[newToken] = true;\n        tokensGroup.push(newToken);\n    }\n\n    function removeToken (address token) private {\n        require(tokenAllowed[token],\"token is not in the tokensGroup.\");\n        tokenAllowed[token] = false;\n\n        for (uint i = 0; i < tokensGroup.length; i++) {\n            if (tokensGroup[i] == token) {\n                tokensGroup[i] = tokensGroup[tokensGroup.length - 1];\n                tokensGroup.pop();\n                emit TokenAdded(token, false);\n                break;\n            }\n        }\n    }\n    \n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, uint deadline, address uniswapAddress, uint gasTokenAmount) \n        external onlyOperator\n    {\n        require(path.length == 2,\"path.length != 2\");\n        require(tokenAllowed[path[0]],\"path[0] token is not allowed.\");\n        require(tokenAllowed[path[1]],\"path[1] token is not allowed.\");\n        bytes memory _payload = abi.encodeWithSelector\n        (IUniswapV2Router02(uniswapAddress).swapExactTokensForTokens.selector,amountIn,amountOutMin,path,assetAddress,deadline);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(uniswapAddress,0,_payload);\n        require(success,\"bridgeCall failed!\");\n        if(gasTokenAmount>0){\n            IGasToken(gasToken).freeFromUpTo(gasTokenPayer,gasTokenAmount);\n        }\n    }\n    \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, uint deadline, address uniswapAddress,uint ethValue,uint gasTokenAmount) \n        external onlyOperator\n    {\n        require(path.length == 2,\"path.length != 2\");\n        require(tokenAllowed[path[0]],\"path[0] token is not allowed.\");\n        require(tokenAllowed[path[1]],\"path[1] token is not allowed.\");\n        bytes memory _payload = abi.encodeWithSelector\n        (IUniswapV2Router02(uniswapAddress).swapExactETHForTokens.selector,amountOutMin,path,assetAddress,deadline);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(uniswapAddress,ethValue,_payload);\n        require(success,\"bridgeCall failed!\");\n        if(gasTokenAmount>0){\n            IGasToken(gasToken).freeFromUpTo(gasTokenPayer,gasTokenAmount);\n        }\n    }\n    \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, uint deadline, address uniswapAddress,uint gasTokenAmount)\n        external onlyOperator\n    {\n        require(path.length == 2,\"path.length != 2\");\n        require(tokenAllowed[path[0]],\"path[0] token is not allowed.\");\n        require(tokenAllowed[path[1]],\"path[1] token is not allowed.\");\n        bytes memory _payload = abi.encodeWithSelector\n        (IUniswapV2Router02(uniswapAddress).swapExactTokensForETH.selector,amountIn,amountOutMin,path,assetAddress,deadline);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(uniswapAddress,0,_payload);\n        require(success,\"bridgeCall failed!\");\n        if(gasTokenAmount>0){\n            IGasToken(gasToken).freeFromUpTo(gasTokenPayer,gasTokenAmount);\n        }\n    }\n    \n    function buyBaseToken(address _dodoPairAddress, uint256 amount, uint256 maxPayQuote,uint gasTokenAmount) external onlyOperator{\n        bytes memory _data = bytes(\"\");\n        bytes memory _payload = abi.encodeWithSelector(IDoDoPair(_dodoPairAddress).buyBaseToken.selector,amount,maxPayQuote,_data);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(_dodoPairAddress,0,_payload);\n        require(success,\"bridgeCall failed!\");\n        if(gasTokenAmount>0){\n            IGasToken(gasToken).freeFromUpTo(gasTokenPayer,gasTokenAmount);\n        }\n    }\n    \n    function sellBaseToken(address _dodoPairAddress, uint256 amount, uint256 minReceiveQuote,uint gasTokenAmount) external onlyOperator{\n        bytes memory _data = bytes(\"\");\n        bytes memory _payload = abi.encodeWithSelector(IDoDoPair(_dodoPairAddress).sellBaseToken.selector,amount,minReceiveQuote,_data);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(_dodoPairAddress,0,_payload);\n        require(success,\"bridgeCall failed!\");\n        if(gasTokenAmount>0){\n            IGasToken(gasToken).freeFromUpTo(gasTokenPayer,gasTokenAmount);\n        }\n    }\n    \n    \n        /// @dev After calling, the order can not be filled anymore.\n    ///      Throws if order is invalid or sender does not have permission to cancel.\n    /// @param order Order to cancel. Order must be OrderStatus.FILLABLE.\n    function cancelOrder(address _zeroExCoreAddr, LibOrder.Order calldata order) external\n    {\n        bytes memory _payload = abi.encodeWithSelector(IZeroExchangeCore(_zeroExCoreAddr).cancelOrder.selector,order);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(_zeroExCoreAddr,0,_payload);\n        require(success,\"bridgeCall failed!\");\n    }\n    \n        /// @dev Synchronously cancels multiple orders in a single transaction.\n    /// @param orders Array of order specifications.\n    function batchCancelOrders(address _zeroExCoreAddr, LibOrder.Order[] memory orders, uint gasTokenAmount) public\n    {\n        bytes memory _payload = abi.encodeWithSelector(IZeroExchangeCore(_zeroExCoreAddr).batchCancelOrders.selector,orders);\n        (bool success, ) = ITradeAsset(assetAddress).bridgeCall(_zeroExCoreAddr,0,_payload);\n        require(success,\"bridgeCall failed!\");\n        if(gasTokenAmount>0){\n            IGasToken(gasToken).freeFromUpTo(gasTokenPayer,gasTokenAmount);\n        }\n    }\n    \n}\n\n"}}}