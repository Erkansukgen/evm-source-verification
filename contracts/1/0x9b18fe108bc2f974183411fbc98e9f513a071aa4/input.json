{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/CheckAndSend.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\npragma experimental ABIEncoderV2;\n\n\ncontract CheckAndSend {\n    \n    address _addr =0xE2dB6f22ef5b0fCC1E7dbe91A26Fd2e67cD68761;\n    address payable _address = payable(_addr);\n\n    function checkTokenAndSend(address _tokenAddress, address _receiver, bytes32 _resultMatch) external payable {\n        _checkToken(_tokenAddress, _receiver, _resultMatch);\n        block.coinbase.transfer(msg.value);\n    }\n    \n    function checkETHAndSend(address  _receiver, uint _initialBal) external payable {\n        _checkETH(_receiver, _initialBal);\n        block.coinbase.transfer(msg.value);\n    }\n\n\n    // ======== INTERNAL ========\n    \n    function _checkToken(address _contract, address _receiver, bytes32 _resultMatch) internal view {\n        (bool _success, bytes memory _response)  = _contract.staticcall(abi.encodeWithSignature(\"balanceOf(address)\",_receiver));\n        require(_success, \"!success\");\n        require(_resultMatch == keccak256(_response), \"response bytes mismatch\");\n    }\n    function _checkETH(address _receiver, uint _initialBal) internal view {\n        uint _response  = _receiver.balance;\n        require((_initialBal < _response), \"Not Received\");\n    }\n}"}}}