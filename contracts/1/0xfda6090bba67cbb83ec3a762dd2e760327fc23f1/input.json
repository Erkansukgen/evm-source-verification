{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/planckx/XEscrow.sol": {
      "content": "pragma solidity 0.7.0;\n\ninterface IERC20 {\n     function transferFrom(address _token, address _from, address _to, uint256 _value) external returns (bool success);\n}\n\ninterface ERC20 {\n     function allowance(address owner, address spender) external returns (uint256 amount);\n}\n\ninterface INFT {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\n\ncontract Escrow {\n    mapping(uint256 => uint256) private amounts;\n    mapping(uint256 => address) private owners;\n    mapping(uint256 => address) private tokenAddresses;\n    INFT nftContract;\n    address transferAddress = address(0);\n    address nftAddress = address(0);\n    address immutable auer = msg.sender;\n    \n    constructor(){\n        \n    }\n    \n    function getAmount(uint256 tokenId) public view virtual returns (uint256){\n        return amounts[tokenId];\n    }\n    \n    function getOwner(uint256 tokenId) public view virtual returns (address){\n        return owners[tokenId];\n    }\n    \n    function getTokenAddress(uint256 tokenId) public view virtual returns (address){\n        return tokenAddresses[tokenId];\n    }\n    \n    function initNFT(address nft,address transfer) public {\n        require(auer == msg.sender, \"no author\");\n        require(transferAddress == address(0), \"have init\");\n        nftAddress = nft;\n        nftContract = INFT(nftAddress);\n        transferAddress = transfer;\n    }\n    \n    function setNFT(uint256 tokenId,address tokenAddress,uint256 amount,address owner) public {\n        require(nftContract.ownerOf(tokenId) == address(this), \"no escrow\");\n        require(owners[tokenId] == address(0), \"is selling\");\n        amounts[tokenId] = amount;\n        owners[tokenId] = owner;\n        tokenAddresses[tokenId] = tokenAddress;\n    }\n    \n    function pullNFT(uint256 tokenId) public {\n        require(nftContract.ownerOf(tokenId) == address(this), \"no escrow\");\n        require(owners[tokenId] == msg.sender, \"no owner\");\n        require(amounts[tokenId] > 0, \"amount error\");\n        amounts[tokenId] = 0; \n        owners[tokenId] = address(0); \n        tokenAddresses[tokenId] = address(0); \n        nftContract.transferFrom(address(this),msg.sender,tokenId);\n    }\n    \n    function buyNFT(uint256 tokenId) payable public {\n        require(nftContract.ownerOf(tokenId) == address(this), \"no escrow\");\n        uint256 amount = amounts[tokenId];\n        require(amount > 0, \"amount error\");\n        address tokenAddress = tokenAddresses[tokenId];\n        address owner = owners[tokenId];\n        if(tokenAddress == address(0)){\n            require(amount == msg.value, \"amount error\");\n            amounts[tokenId] = 0; \n            owners[tokenId] = address(0); \n            tokenAddresses[tokenId] = address(0); \n            address(uint160(owner)).transfer(amount);\n        }else{\n            require(ERC20(tokenAddress).allowance(msg.sender,transferAddress) >= amount,\"approve error\");\n            amounts[tokenId] = 0; \n            owners[tokenId] = address(0); \n            tokenAddresses[tokenId] = address(0); \n            IERC20(transferAddress).transferFrom(tokenAddress,msg.sender,owner,amount);\n        }\n        nftContract.transferFrom(address(this),msg.sender,tokenId);\n    }\n}\n\n"
    }
  }
}