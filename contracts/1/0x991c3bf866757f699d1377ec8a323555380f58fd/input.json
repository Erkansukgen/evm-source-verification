{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/myswap2.sol":{"content":"pragma solidity =0.6.6;\r\n\r\ninterface IFreeFromUpTo {\r\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function WETH() external pure returns (address);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path,address to, uint deadline) external returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract MyRouter {\r\n    \r\n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\r\n    modifier onlyTrader {\r\n        require((msg.sender == 0x58bE8DF2DDDDdBE9aEBeA4d4fd501739D69eB925) || (msg.sender == 0x520Db7C2161aA43fB7eB1BD87C40A084de2c5008) || (msg.sender == 0xf529Aeb37f7Ddf8f2d32fC12F984936Bf0c0afF7) || (msg.sender == 0x4Cb9b406D430eE2065556C0f73668bc435116822) || (msg.sender == 0xd38BF71470e636CE554D65453075e1A8A31A2ce7), \"not trader\");\r\n        _;\r\n    }\r\n    \r\n    modifier discountCHI {\r\n        uint256 gasStart = gasleft();\r\n        _;\r\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\r\n        chi.freeFromUpTo(address(this), (gasSpent + 14154) / 41130);\r\n    }\r\n\r\n    constructor() public{\r\n    }\r\n    \r\n    function withdrawETH() public onlyTrader{\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    function withdrawToken(address tokenAddress, uint amount) public onlyTrader{\r\n        IERC20 token = IERC20(tokenAddress);\r\n        uint256 currentTokenBalance = token.balanceOf(address(this));\r\n        require(amount<=currentTokenBalance);\r\n        token.transfer(msg.sender, amount);\r\n    }\r\n    \r\n    function withdrawTokens(address[] memory path) public onlyTrader{\r\n        for (uint i; i < path.length; i++) {\r\n            IERC20 token = IERC20(path[i]);\r\n            uint256 currentTokenBalance = token.balanceOf(address(this));\r\n            token.transfer(msg.sender, currentTokenBalance);\r\n        }\r\n    }\r\n    \r\n    function setAllowanceOne(\r\n        address tokenAddress,\r\n        address spender\r\n    ) public onlyTrader{\r\n        IERC20 token = IERC20(tokenAddress);\r\n        token.approve(spender, 1606938044258990275541962092341162602522202993782792835301376);\r\n    }\r\n    \r\n    function setAllowanceMass(\r\n        address[] memory path,\r\n        address spender\r\n    ) public onlyTrader{\r\n        for (uint i; i < path.length; i++) {\r\n            IERC20 token = IERC20(path[i]);\r\n            token.approve(spender, 1606938044258990275541962092341162602522202993782792835301376);\r\n        }\r\n    }\r\n    \r\n    function swap(\r\n        address[] memory path,\r\n        uint amount,\r\n        uint tokenMin,\r\n        uint amountMin,\r\n        address pairOwner,\r\n        bool isUniswap\r\n    ) public onlyTrader{\r\n        IUniswapV2Router uniRouter;\r\n        if (isUniswap) {\r\n            uniRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        } else {\r\n            uniRouter = IUniswapV2Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n        }\r\n        IERC20 ownerERC20 = IERC20(pairOwner);\r\n        uint reserveToken = ownerERC20.balanceOf(path[0]);\r\n        uint amountTradeToken = reserveToken - tokenMin;\r\n        require(amountTradeToken>amountMin,'lowp');\r\n        if (amountTradeToken>amount) {\r\n            uniRouter.swapExactTokensForTokens(amount, 0, path, address(this), block.timestamp+1000000);\r\n        } else {\r\n            uniRouter.swapExactTokensForTokens(amountTradeToken, 0, path, address(this), block.timestamp+1000000);\r\n        }\r\n        \r\n    }    \r\n    \r\n    function swapChi(\r\n        address[] memory path,\r\n        uint amount,\r\n        uint tokenMin,\r\n        uint amountMin,\r\n        address pairOwner,\r\n        bool isUniswap\r\n    ) public onlyTrader discountCHI{\r\n        IUniswapV2Router uniRouter;\r\n        if (isUniswap) {\r\n            uniRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        } else {\r\n            uniRouter = IUniswapV2Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n        }\r\n        IERC20 ownerERC20 = IERC20(pairOwner);\r\n        uint reserveToken = ownerERC20.balanceOf(path[0]);\r\n        uint amountTradeToken = reserveToken - tokenMin;\r\n        require(amountTradeToken>amountMin,'lowp');\r\n        if (amountTradeToken>amount) {\r\n            uniRouter.swapExactTokensForTokens(amount, 0, path, address(this), block.timestamp+1000000);\r\n        } else {\r\n            uniRouter.swapExactTokensForTokens(amountTradeToken, 0, path, address(this), block.timestamp+1000000);\r\n        }\r\n        \r\n    }    \r\n    \r\n    function swapBackAll(\r\n        address[] memory path,\r\n        bool isUniswap\r\n    ) public onlyTrader {\r\n        IUniswapV2Router uniRouter;\r\n        if (isUniswap) {\r\n            uniRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        } else {\r\n            uniRouter = IUniswapV2Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n        }\r\n        IERC20 tokenERC20 = IERC20(path[0]);\r\n        uint myToken = tokenERC20.balanceOf(address(this));\r\n        uniRouter.swapExactTokensForTokens(myToken, 0, path, address(this), block.timestamp+1000000);\r\n    }\r\n    \r\n    function swapBackToExactAmount(\r\n        uint amount,\r\n        address[] memory path,\r\n        bool isUniswap\r\n    ) public onlyTrader{\r\n        IUniswapV2Router uniRouter;\r\n        if (isUniswap) {\r\n            uniRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        } else {\r\n            uniRouter = IUniswapV2Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\r\n        }\r\n        \r\n        IERC20 tokenOutERC20 = IERC20(path[1]);\r\n        uint myTokenOut = tokenOutERC20.balanceOf(address(this));\r\n        require(amount  > myTokenOut, 'no need');\r\n        IERC20 tokenInERC20 = IERC20(path[0]);\r\n        uint myTokenIn = tokenInERC20.balanceOf(address(this));\r\n        try uniRouter.swapTokensForExactTokens(amount-myTokenOut, myTokenIn, path, address(this), block.timestamp+1000000) {}\r\n        catch {\r\n            uniRouter.swapExactTokensForTokens(myTokenIn, 0, path, address(this), block.timestamp+1000000);\r\n        }\r\n\r\n    }\r\n}\r\n\r\n"}}}