{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"EtheremonToken.sol":{"content":"pragma solidity ^0.4.16;\r\n\r\n// copyright contact@Etheremon.com\r\n\r\ncontract SafeMath {\r\n\r\n    /* function assert(bool assertion) internal { */\r\n    /*   if (!assertion) { */\r\n    /*     throw; */\r\n    /*   } */\r\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\r\n\r\n    function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) pure internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract BasicAccessControl {\r\n    address public owner;\r\n    // address[] public moderators;\r\n    uint16 public totalModerators = 0;\r\n    mapping (address => bool) public moderators;\r\n    bool public isMaintaining = true;\r\n\r\n    function BasicAccessControl() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address _newOwner) onlyOwner public {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n\r\n    function AddModerator(address _newModerator) onlyOwner public {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }\r\n    \r\n    function RemoveModerator(address _oldModerator) onlyOwner public {\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }\r\n\r\n    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\r\n        isMaintaining = _isMaintaining;\r\n    }\r\n}\r\n\r\ninterface TokenRecipient { \r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; \r\n}\r\n\r\ncontract TokenERC20 {\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0);\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public {\r\n        _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true; \r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        TokenRecipient spender = TokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        balanceOf[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        balanceOf[_from] -= _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract PaymentInterface {\r\n    function createCastle(address _trainer, uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) public returns(uint);\r\n    function catchMonster(address _trainer, uint _tokens, uint32 _classId, string _name) public returns(uint);\r\n    function payService(address _trainer, uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3, uint64 _param4, uint64 _param5, uint64 _param6) public returns(uint);\r\n}\r\n\r\ncontract EtheremonToken is BasicAccessControl, TokenERC20 {\r\n    // metadata\r\n    string public constant name = \"EtheremonToken\";\r\n    string public constant symbol = \"EMONT\";\r\n    uint256 public constant decimals = 8;\r\n    string public version = \"1.0\";\r\n    \r\n    // deposit address\r\n    address public inGameRewardAddress;\r\n    address public userGrowPoolAddress;\r\n    address public developerAddress;\r\n    \r\n    // Etheremon payment\r\n    address public paymentContract;\r\n    \r\n    // for future feature\r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n    bool public trading = false;\r\n    mapping (address => bool) public frozenAccount;\r\n    event FrozenFunds(address target, bool frozen);\r\n    \r\n    modifier isTrading {\r\n        require(trading == true || msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier requirePaymentContract {\r\n        require(paymentContract != address(0));\r\n        _;        \r\n    }\r\n    \r\n    function () payable public {}\r\n\r\n    // constructor    \r\n    function EtheremonToken(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract) public {\r\n        require(_inGameRewardAddress != address(0));\r\n        require(_userGrowPoolAddress != address(0));\r\n        require(_developerAddress != address(0));\r\n        inGameRewardAddress = _inGameRewardAddress;\r\n        userGrowPoolAddress = _userGrowPoolAddress;\r\n        developerAddress = _developerAddress;\r\n\r\n        balanceOf[inGameRewardAddress] = 14000000 * 10**uint(decimals);\r\n        balanceOf[userGrowPoolAddress] = 5000000 * 10**uint(decimals);\r\n        balanceOf[developerAddress] = 1000000 * 10**uint(decimals);\r\n        totalSupply = balanceOf[inGameRewardAddress] + balanceOf[userGrowPoolAddress] + balanceOf[developerAddress];\r\n        paymentContract = _paymentContract;\r\n    }\r\n    \r\n    // moderators\r\n    function setAddress(address _inGameRewardAddress, address _userGrowPoolAddress, address _developerAddress, address _paymentContract) onlyModerators external {\r\n        inGameRewardAddress = _inGameRewardAddress;\r\n        userGrowPoolAddress = _userGrowPoolAddress;\r\n        developerAddress = _developerAddress;\r\n        paymentContract = _paymentContract;\r\n    }\r\n    \r\n    // public\r\n    function withdrawEther(address _sendTo, uint _amount) onlyModerators external {\r\n        if (_amount > this.balance) {\r\n            revert();\r\n        }\r\n        _sendTo.transfer(_amount);\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require (_to != 0x0);\r\n        require (balanceOf[_from] >= _value);\r\n        require (balanceOf[_to] + _value > balanceOf[_to]);\r\n        require(!frozenAccount[_from]);\r\n        require(!frozenAccount[_to]);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(_from, _to, _value);\r\n    }\r\n    \r\n    function freezeAccount(address _target, bool _freeze) onlyOwner public {\r\n        frozenAccount[_target] = _freeze;\r\n        FrozenFunds(_target, _freeze);\r\n    }\r\n    \r\n    function buy() payable isTrading public {\r\n        uint amount = msg.value / buyPrice;\r\n        _transfer(this, msg.sender, amount);\r\n    }\r\n\r\n    function sell(uint256 amount) isTrading public {\r\n        require(this.balance >= amount * sellPrice);\r\n        _transfer(msg.sender, this, amount);\r\n        msg.sender.transfer(amount * sellPrice);\r\n    }\r\n    \r\n    // Etheremon \r\n    function createCastle(uint _tokens, string _name, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.createCastle(msg.sender, _tokens, _name, _a1, _a2, _a3, _s1, _s2, _s3);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }\r\n    \r\n    function catchMonster(uint _tokens, uint32 _classId, string _name) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.catchMonster(msg.sender, _tokens, _classId, _name);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }\r\n    \r\n    function payService(uint _tokens, uint32 _type, string _text, uint64 _param1, uint64 _param2, uint64 _param3, uint64 _param4, uint64 _param5, uint64 _param6) isActive requirePaymentContract external {\r\n        if (_tokens > balanceOf[msg.sender])\r\n            revert();\r\n        PaymentInterface payment = PaymentInterface(paymentContract);\r\n        uint deductedTokens = payment.payService(msg.sender, _tokens, _type, _text, _param1, _param2, _param3, _param4, _param5, _param6);\r\n        if (deductedTokens == 0 || deductedTokens > _tokens)\r\n            revert();\r\n        _transfer(msg.sender, inGameRewardAddress, deductedTokens);\r\n    }\r\n}"}}}