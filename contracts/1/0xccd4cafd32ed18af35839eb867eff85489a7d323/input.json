{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/degen.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nabstract contract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(),\"Not Owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0),\"Zero address not allowed\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ninterface ISwapFactory {\n    function swap(address tokenA, address tokenB, uint256 amount, address user, uint256 OrderType, uint256 dexId, uint256[] memory distribution, uint256 deadline) \n    external payable returns (bool);\n}\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    \n    function mint(address to, uint256 amount) external returns(bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n\ninterface I1inch {\n\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 minReturn, uint256[] calldata distribution, uint256 flags)\n    external payable returns(uint256);\n    \n    function getExpectedReturn(IERC20 fromToken, IERC20 toToken, uint256 amount, uint256 parts, uint256 featureFlags) \n    external view returns(uint256, uint256[] calldata);\n\n}\n\ninterface IUni {\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external payable\n    returns (uint[] memory amounts);\n    \n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) \n    external \n    returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n    external\n    returns (uint[] memory amounts);\n\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n    function WETH() external pure returns (address);\n\n}\n\n\ninterface IGatewayVault {\n    function vaultTransfer(address token, address recipient, uint256 amount) external returns (bool);\n    function vaultApprove(address token, address spender, uint256 amount) external returns (bool);\n}\n\nlibrary DisableFlags {\n    function enabled(uint256 disableFlags, uint256 flag) internal pure returns(bool) {\n        return (disableFlags & flag) == 0;\n    }\n\n    function disabledReserve(uint256 disableFlags, uint256 flag) internal pure returns(bool) {\n        // For flag disabled by default (Kyber reserves)\n        return enabled(disableFlags, flag);\n    }\n\n    function disabled(uint256 disableFlags, uint256 flag) internal pure returns(bool) {\n        return (disableFlags & flag) != 0;\n    }\n}\n\ninterface IReimbursement {\n    function getLicenseeFee(address licenseeVault, address projectContract) external view returns(uint256); // return fee percentage with 2 decimals\n    function getVaultOwner(address vault) external view returns(address);\n    // returns address of fee receiver or address(0) if licensee can't receive the fee (fee should be returns to user)\n    function requestReimbursement(address user, uint256 feeAmount, address licenseeVault) external returns(address);\n}\n\n\nabstract contract Router {\n    using DisableFlags for uint256;\n     \n    uint256 public constant FLAG_UNISWAP = 0x01;\n    uint256 public constant FLAG_SUSHI = 0x02;\n    uint256 public constant FLAG_1INCH = 0x04;\n\n    uint256 public constant totalDEX = 3;            // Total no of DEX aggregators or exchanges used\n    \n    mapping (address => uint256) _disabledDEX;\n    enum OrderType {EthForTokens, TokensForEth, TokensForTokens}\n\n    event Received(address, uint);\n    event Error(address);\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n\n    fallback() external payable {\n        revert();\n    }\n    \n    event Caught(string stringFailure,uint index,uint256 amount);\n\n    I1inch OneSplit;\n    IUni Uni;\n    IUni Sushi;\n    IUni public uniV2Router;            // uniswap compatible router where we have to feed company token pair\n    \n    address constant ETH = address(0);\n\n    // add these variables into contract and initialize it in constructor.\n    // also, create setter functions for it with onlyOwner restriction.\n\n    constructor(address _Uni, address _sushi, address _oneSplit) payable {\n        // owner = payable(msg.sender);\n        OneSplit = I1inch(_oneSplit);\n        Uni = IUni(_Uni);\n        Sushi = IUni(_sushi);\n    }\n    \n    function setDisabledDEX(uint256 _disableFlag) external returns(bool) {\n        _disabledDEX[msg.sender] = _disableFlag;\n        return true;\n    }\n    \n    function getDisabledDEX(address account) public view returns(uint256) {\n        return _disabledDEX[account];\n    }\n    \n    function calculateUniswapReturn( uint256 amountIn, address[] memory path, OrderType orderType,uint256 /*disableFlags*/) public view returns(uint256, uint256[] memory) {\n        uint256[] memory uniAmounts =new uint[](path.length);\n        uint256[] memory distribution;\n\n        uniAmounts[path.length-1] = uint256(0);\n        \n        if(orderType == OrderType.EthForTokens){\n            path[0] = Uni.WETH();\n            try Uni.getAmountsOut(amountIn, path)returns(uint256[] memory _amounts) {\n                uniAmounts = _amounts;\n            }\n            catch{}\n        } \n        else if(orderType == OrderType.TokensForEth){\n            path[path.length-1] = Uni.WETH();\n            try Uni.getAmountsOut(amountIn, path)returns(uint256[] memory _amounts) {\n                uniAmounts = _amounts;\n            }catch{}\n        } \n        else{\n            try Uni.getAmountsOut(amountIn, path)returns(uint256[] memory _amounts) {\n                uniAmounts = _amounts;\n            }catch{}\n        }\n        \n        return (uniAmounts[path.length-1],distribution);\n\n    }\n    \n    function calculateSushiReturn( uint256 amountIn, address[] memory path, OrderType orderType,uint256 /*disableFlags*/) public view returns(uint256, uint256[] memory) {\n        uint256[] memory sushiAmounts =new uint[](path.length);\n        uint256[] memory distribution;\n\n        sushiAmounts[path.length-1] = uint256(0);\n        \n        if(orderType == OrderType.EthForTokens){\n            try Sushi.getAmountsOut(amountIn, path) returns(uint256[] memory _amounts) {\n                sushiAmounts = _amounts;\n            }catch{}\n        } \n        else if(orderType == OrderType.TokensForEth){\n            try Sushi.getAmountsOut(amountIn, path) returns(uint256[] memory _amounts) {\n                sushiAmounts = _amounts;\n            }catch{}\n        } \n        else{\n            try Sushi.getAmountsOut(amountIn, path) returns(uint256[] memory _amounts) {\n                sushiAmounts = _amounts;\n            }catch{}\n        }\n        \n        return (sushiAmounts[path.length-1],distribution);\n\n    }\n    \n    function calculate1InchReturn( uint256 amountIn, address[] memory path, OrderType orderType,uint256 /*disableFlags*/) public view returns(uint256,uint256[] memory) {\n        uint256 returnAmount;\n        uint256[] memory distribution;\n\n        if(orderType == OrderType.EthForTokens){\n            path[0] = ETH;\n            try OneSplit.getExpectedReturn(IERC20(path[0]), IERC20(path[path.length-1]), amountIn, 100, 0) returns(uint256 _amount, uint256[] memory _distribution){\n                returnAmount = _amount;\n                distribution = _distribution;\n            }catch{}\n        }\n        else if(orderType == OrderType.TokensForEth){\n            path[path.length-1] = ETH;\n            try OneSplit.getExpectedReturn(IERC20(path[0]), IERC20(path[path.length-1]), amountIn, 100, 0) returns(uint256 _amount, uint256[] memory _distribution){\n                returnAmount = _amount;\n                distribution = _distribution;\n            }catch{}\n        } \n        else{\n            try OneSplit.getExpectedReturn(IERC20(path[0]), IERC20(path[path.length-1]), amountIn, 100, 0) returns(uint256 _amount, uint256[] memory _distribution){\n                returnAmount = _amount;\n                distribution = _distribution;\n            }catch{}\n        }\n        \n        return (returnAmount,distribution);\n\n    }\n\n    function _calculateNoReturn( uint256/* amountIn*/, address[] memory /*path*/, OrderType /*orderType*/,uint256 /*disableFlags*/) internal pure returns(uint256, uint256[] memory) {\n        uint256[] memory distribution;\n        return (uint256(0), distribution);\n    }\n    \n    // returns : \n    // dexId ->  which dex gives highest amountOut 0-> 1inch 1-> uniswap 2-> sushiswap\n    // minAmountExpected ->  how much tokens you will get after swap\n    // distribution -> the route of swappping\n    function getBestQuote(address[] memory path, uint256 amountIn, OrderType orderType, uint256 disableFlags) public view returns (uint256, uint256,uint256[] memory) {\n        \n        function(uint256, address[] memory, OrderType ,uint256 ) view returns(uint256,uint256[]memory)[3] memory reserves = [\n            disableFlags.disabled(FLAG_1INCH)    ? _calculateNoReturn : _calculateNoReturn,\n            disableFlags.disabled(FLAG_UNISWAP)  ? _calculateNoReturn : calculateUniswapReturn,\n            disableFlags.disabled(FLAG_SUSHI)    ? _calculateNoReturn : calculateSushiReturn\n        ];\n        \n        uint256[3] memory rates;\n        uint256[][3] memory distribution;\n        \n        for (uint256 i = 0; i < rates.length; i++) {\n            (rates[i],distribution[i]) = reserves[i](amountIn,path,orderType,disableFlags);\n        }\n        \n        uint256 temp = 0;\n        for(uint256 i = 1; i < rates.length; i++) {\n            if(rates[i] > rates[temp]) {\n                temp = i;\n            }\n        }\n        return(temp, rates[temp], distribution[temp]);   \n    \n    }\n \n    function oneInchSwap(address _fromToken, address _toToken, uint256 amountIn, uint256 minReturn, uint256[] memory distribution, uint256 flags)\n    internal {\n        if (_fromToken == ETH) {\n            try OneSplit.swap{value: amountIn}(IERC20(ETH), IERC20(_toToken), amountIn, minReturn, distribution, flags)\n             returns (uint256 amountOut){\n                 TransferHelper.safeTransferFrom(_toToken, address(this), msg.sender, amountOut);\n            } catch {\n                emit Error(msg.sender);\n                revert(\"Error\");\n            }\n        } else {\n             try OneSplit.swap(IERC20(_fromToken), IERC20(_toToken), amountIn, minReturn, distribution, flags)\n              returns (uint256 amountOut){\n                  if(_toToken == ETH){\n                      payable(msg.sender).transfer(amountOut);\n                  } else {\n                      TransferHelper.safeTransferFrom(_toToken, address(this), msg.sender, amountOut);\n                  }\n             } catch {\n                emit Error(msg.sender);\n                revert(\"Error\");\n            }\n        }\n    }\n}\n\n \ncontract Degen is Router, Ownable {\n    using DisableFlags for uint256;\n    \n    address public _Uni = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //mainnet network address for uniswap (valid for Ropsten as well)\n    address public _oneSplit = address(0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E); //INCORRECT! mainnet network address for oneInch\n    address public _sushi = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Mainnet network address for sushiswap\n    //address public _sushi = address(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506); // Ropsten network address for sushiswap\n    //address public USDT = address(0x47A530f3Fa882502344DC491549cA9c058dbC7Da); // Ropsten test net USDT test token\n    address public USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7); // USDT Token Address\n    address public system;\n    address public gatewayVault;\n    uint256 public proccessingFee = 0 ;\n    \n    uint256 private deadlineLimit = 20*60;      // 20 minutes by default \n    \n    uint256 private collectedFees = 1; // amount of collected fee (starts from 1 to avoid additional gas usage)\n    address public feeReceiver; // address which receive the fee (by default is validator)\n\n\n    IReimbursement public reimbursementContract;      // reimbursement contract address\n\n    address public companyToken;        // company reimbursement token (BSWAP, DEGEN, SMART)\n    address public companyVault;    // the vault address of our company registered in reimbursement contract\n\n    ISwapFactory public swapFactory;\n   \n   modifier onlySystem() {\n        require(msg.sender == system || owner() == msg.sender,\"Caller is not the system\");\n        _;\n    }\n    \n    \n    constructor(address _companyToken, address _swapFactory, address _system, address _gatewayVault /*, address _companyVault, address _reimbursementContract*/) \n    Router( _Uni, _sushi, _oneSplit) {\n        companyToken = _companyToken;\n        // companyVault = _companyVault;\n        // reimbursementContract = IReimbursement(_reimbursementContract);\n        swapFactory = ISwapFactory(_swapFactory);\n        system = _system;\n        gatewayVault = _gatewayVault;\n    }\n    \n    \n    // function degenPrice() public view returns (uint256){\n    //     (uint112 reserve0, uint112 reserve1,) = poolContract.getReserves();\n    //     if(poolContract.token0() == Uni.WETH()){\n    //         return ((reserve1 * (10**18)) /(reserve0));\n    //     } else {\n    //         return ((reserve0 * (10**18)) /(reserve1));\n    //     }\n    // }\n\n    function setCompanyToken(address _companyToken) external onlyOwner {\n        companyToken = _companyToken;\n    }\n\n    function setCompanyVault(address _comapnyVault) external onlyOwner returns(bool){\n        companyVault = _comapnyVault;\n        return true;\n    }\n\n    function setReimbursementContract(address _reimbursementContarct) external onlyOwner returns(bool){\n        reimbursementContract = IReimbursement(_reimbursementContarct);\n        return true;\n    }\n\n    function setProccessingFee(uint256 _processingFees) external onlySystem {\n        proccessingFee = _processingFees;\n    }\n\n    function setSwapFactory(address _swapFactory) external onlyOwner {\n        swapFactory = ISwapFactory(_swapFactory);\n\n    }\n    \n    function setGatewayVault(address _gatewayVault) external onlyOwner returns(bool) {\n        gatewayVault = _gatewayVault;\n        return true;\n    }\n    \n    function setSystem (address _system) external onlyOwner returns(bool) {\n        system = _system;\n        return true;\n    }\n    \n    function setFeeReceiver(address _addr) external onlyOwner returns(bool) {\n        feeReceiver = _addr;\n        return true;\n    }\n    \n    function getDeadlineLimit() public view returns(uint256) {\n        return deadlineLimit;\n    }\n    \n    function setDeadlineLimit(uint256 limit) external onlyOwner returns(bool) {\n        deadlineLimit = limit;\n        return true;\n    }\n\n    // get amount of collected fees that can be claimed\n    function getColletedFees() external view returns (uint256) {\n        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\n        return collectedFees - 1;\n    }\n\n    // claim fees by feeReceiver\n    function claimFee() external returns (uint256 feeAmount) {\n        require(msg.sender == feeReceiver, \"This fee can be claimed only by fee receiver!!\");\n        feeAmount = collectedFees - 1;\n        collectedFees = 1;        \n        TransferHelper.safeTransferETH(msg.sender, feeAmount);\n    }\n    \n    \n    // Call function processFee() at the end of main function for correct gas usage calculation.\n    // txGas - is gasleft() on start of calling contract. Put `uint256 txGas = gasleft();` as a first command in function\n    // feeAmount - fee amount that user paid\n    // processing - processing fee (for cross-chain swaping)\n    // licenseeVault - address that licensee received on registration and should provide when users comes from their site\n    // user - address of user who has to get reimbursement (usually msg.sender)\n\n    function processFee(uint256 txGas, uint256 feeAmount, uint256 processing, address licenseeVault, address user) internal {\n        if (address(reimbursementContract) == address(0)) {\n            payable(user).transfer(feeAmount); // return fee to sender if no reimbursement contract\n            return;\n        }\n        \n        uint256 licenseeFeeAmount;\n        if (licenseeVault != address(0)) {\n            uint256 companyFeeRate = reimbursementContract.getLicenseeFee(companyVault, address(this));\n            uint256 licenseeFeeRate = reimbursementContract.getLicenseeFee(licenseeVault, address(this));\n            if (licenseeFeeRate != 0)\n                licenseeFeeAmount = (feeAmount * licenseeFeeRate)/(licenseeFeeRate + companyFeeRate);\n            if (licenseeFeeAmount != 0) {\n                address licenseeFeeTo = reimbursementContract.requestReimbursement(user, licenseeFeeAmount, licenseeVault);\n                if (licenseeFeeTo == address(0)) {\n                    payable(user).transfer(licenseeFeeAmount);    // refund to user\n                } else {\n                    payable(licenseeFeeTo).transfer(licenseeFeeAmount);  // transfer to fee receiver\n                }\n            }\n        }\n        feeAmount -= licenseeFeeAmount; // company's part of fee\n        collectedFees += feeAmount; \n        \n        if (processing != 0) \n            payable(system).transfer(processing);  // transfer to fee receiver\n        \n        txGas -= gasleft(); // get gas amount that was spent on Licensee fee\n        txGas = txGas * tx.gasprice;\n        // request reimbursement for user\n        reimbursementContract.requestReimbursement(user, feeAmount+txGas+processing, companyVault);\n    }\n    \n    \n    function _swap( \n        OrderType orderType, \n        address[] memory path, \n        uint256 assetInOffered,\n        uint256 minExpectedAmount, \n        address user,\n        address to,\n        uint256 dexId,\n        uint256[] memory distribution,\n        uint256 deadline\n    ) internal returns(uint256) {\n         \n        require(dexId < totalDEX, \"Invalid DEX Id!\");\n        require(deadline >= block.timestamp, \"EXPIRED: Deadline for transaction already passed.\");\n        \n        uint256 disableFlags = getDisabledDEX(user);\n         \n        // check conditions for disableFlags and return response accordingly. if disabled then minExpectedAmount will be uint(0)\n        if( disableFlags.disabled(FLAG_1INCH) || disableFlags.disabled(FLAG_UNISWAP) || disableFlags.disabled(FLAG_SUSHI) ) {\n            minExpectedAmount = uint256(0);\n        }\n        \n        if(dexId == 0){\n            if(orderType == OrderType.EthForTokens) {\n                 path[0] = ETH;\n            }\n            else if (orderType == OrderType.TokensForEth) {\n                path[path.length-1] = ETH;\n            }\n            oneInchSwap(path[0], path[path.length-1], assetInOffered, 0, distribution, 0);\n        }\n\n        \n        else if(dexId == 1){\n            uint[] memory swapResult;\n            if(orderType == OrderType.EthForTokens) {\n                 path[0] = Uni.WETH();\n                 swapResult = Uni.swapExactETHForTokens{value:assetInOffered}(0, path, to,block.timestamp);\n            }\n            else if (orderType == OrderType.TokensForEth) {\n                path[path.length-1] = Uni.WETH();\n                TransferHelper.safeApprove(path[0], address(_Uni), assetInOffered);\n                swapResult = Uni.swapExactTokensForETH(assetInOffered, 0, path,to, block.timestamp);\n            }\n            else if (orderType == OrderType.TokensForTokens) {\n                TransferHelper.safeApprove(path[0], address(_Uni), assetInOffered);\n                swapResult = Uni.swapExactTokensForTokens(assetInOffered, minExpectedAmount, path, to, block.timestamp);\n            }\n        } \n        \n        else if(dexId == 2){\n            uint[] memory swapResult;\n            if(orderType == OrderType.EthForTokens) {\n                 path[0] = Sushi.WETH();\n                 swapResult = Sushi.swapExactETHForTokens{value:assetInOffered}(minExpectedAmount, path, to, block.timestamp);\n            }\n            else if (orderType == OrderType.TokensForEth) {\n                path[path.length-1] = Sushi.WETH();\n                TransferHelper.safeApprove(path[0], address(_sushi), assetInOffered);\n                swapResult = Sushi.swapExactTokensForETH(assetInOffered, minExpectedAmount, path, to, block.timestamp);\n            }\n            else if (orderType == OrderType.TokensForTokens) {\n                TransferHelper.safeApprove(path[0], address(_sushi), assetInOffered);\n                swapResult = Sushi.swapExactTokensForTokens(assetInOffered, minExpectedAmount, path, to, block.timestamp);\n            }\n        }\n\n        return minExpectedAmount;\n    }\n    \n    \n    function executeSwap(\n        OrderType orderType, \n        address[] memory path, \n        uint256 assetInOffered, \n        uint256 fees, \n        uint256 minExpectedAmount,\n        address licenseeVault,\n        uint256 dexId,\n        uint256[] memory distribution,\n        uint256 deadline\n    ) external payable {\n        uint256 gasA = gasleft();\n        uint256 receivedFees = 0;\n        if(deadline == 0) {\n            deadline = block.timestamp + deadlineLimit;\n        }\n        \n        if(orderType == OrderType.EthForTokens){\n            require(msg.value >= (assetInOffered + fees), \"Payment = assetInOffered + fees\");\n            receivedFees = receivedFees + msg.value - assetInOffered;\n        } else {\n            require(msg.value >= fees, \"fees not received\");\n            receivedFees = receivedFees + msg.value;\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\n        }\n        \n        _swap(orderType, path, assetInOffered, minExpectedAmount, msg.sender, msg.sender, dexId, distribution, deadline);\n   \n        processFee(gasA, receivedFees, 0, licenseeVault, msg.sender);\n    }\n    \n    \n    function executeCrossExchange(\n        address[] memory path, \n        OrderType orderType,\n        uint256 crossOrderType,\n        uint256 assetInOffered,\n        uint256 fees, \n        uint256 minExpectedAmount,\n        address licenseeVault,\n        uint256[3] memory dexId_deadline, // dexId_deadline[0] - native swap dexId, dexId_deadline[1] - foreign swap dexId, dexId_deadline[2] - deadline\n        uint256[] memory distribution\n    ) external payable {\n        uint256[2] memory feesPrice; \n        feesPrice[0] = gasleft();       // equivalent to gasA\n        feesPrice[1] = 0;               // processing fees\n        \n        if (dexId_deadline[2] == 0) {   // if deadline == 0, set deadline to deadlineLimit\n            dexId_deadline[2] = block.timestamp + deadlineLimit;\n        }\n\n        if(orderType == OrderType.EthForTokens){\n            require(msg.value >= (assetInOffered + fees + proccessingFee), \"Payment = assetInOffered + fees + proccessingFee\");\n            feesPrice[1] = msg.value - assetInOffered - fees;\n        } else {\n            require(msg.value >= (fees + proccessingFee), \"fees not received\");\n            feesPrice[1] = msg.value - fees;\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\n        }\n        \n        if(path[0] == USDT) {\n            IERC20(USDT).approve(address(swapFactory), assetInOffered);\n            swapFactory.swap(USDT, path[path.length-1], assetInOffered, msg.sender, crossOrderType, dexId_deadline[1], distribution, dexId_deadline[2]);\n        }\n        else {\n            address tokenB = path[path.length-1];\n            path[path.length-1] = USDT;\n            uint256 minAmountExpected = _swap(orderType, path, assetInOffered, minExpectedAmount, msg.sender, address(this), dexId_deadline[0], distribution, dexId_deadline[2]);\n                \n            IERC20(USDT).approve(address(swapFactory),minAmountExpected);\n            swapFactory.swap(USDT, tokenB, minAmountExpected, msg.sender, crossOrderType, dexId_deadline[1], distribution, dexId_deadline[2]);\n        }        \n\n        processFee(feesPrice[0], fees, feesPrice[1], licenseeVault, msg.sender);\n    }\n\n    function callbackCrossExchange( \n        OrderType orderType, \n        address[] memory path, \n        uint256 assetInOffered, \n        address user,\n        uint256 dexId,\n        uint256[] memory distribution,\n        uint256 deadline\n    ) external returns(bool) {\n        require(msg.sender == address(swapFactory) , \"Degen : caller is not SwapFactory\");\n        if(deadline==0) {\n            deadline = block.timestamp + deadlineLimit;\n        }\n        _swap(orderType, path, assetInOffered, uint256(0), user, user, dexId, distribution, deadline);\n        return true;\n    }\n\n}"
    }
  }
}