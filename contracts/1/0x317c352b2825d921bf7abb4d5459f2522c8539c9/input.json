{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/SmartContactForUser.sol": {
      "content": "pragma solidity ^0.5.16;\ncontract SmartContactForUser {\n    event PersonRemoval(address indexed removed, address indexed attachedTo, Role indexed role);\n    event HolderAdd(address indexed added);\n    mapping(address => mapping(address => uint256)) _allowed; //mapping of accounts allowed to withdraw from a given account and their balances\n    address[] _holders; //all token holders\n    address _owner;\n    enum Role {Holder, Appointee, Owner}\n    constructor() public payable {\n        _holders.push(msg.sender);\n        _owner = msg.sender;\n    }\n    function holderExist(address accountToCheck) public view returns (bool){\n        for(uint i = 0; i<_holders.length; i++){\n            if(_holders[i] == accountToCheck)\n                return true;\n        }\n        return false;\n    }\n    function signContact(address accountToAdd) public returns (bool){\n        require(!holderExist(accountToAdd), \"Contact already exists.\");\n        require(checkHolderPermission(msg.sender), \"Not authorized\");\n        _holders.push(accountToAdd);\n        assert(holderExist(accountToAdd));\n        emit HolderAdd(accountToAdd);\n        return true;\n    }\n    /*Only contract's owner can remove a holder.\n    */\n    function removeContact(address toRemove) public returns (bool){\n        require(checkOwnerPermission(msg.sender), \"Not authorized.\");\n        require(holderExist(toRemove), \"Contact not exist.\");\n        uint index;\n        for(uint i = 0; i<_holders.length; i++){\n            if(_holders[i] == toRemove){\n                index = i;\n            }\n        }\n        uint256 arrlen = _holders.length;\n        delete _holders[index];\n        _holders[index] = _holders[arrlen - 1];\n        _holders.length--;\n        \n        emit PersonRemoval(toRemove, address(0), Role.Holder);\n        return true;\n    }\n    function checkHolderPermission(address toCheck) public view returns (bool){\n        return (holderExist(toCheck));\n        return true;\n    }\n    function checkOwnerPermission(address toCheck) public view returns (bool){\n        return (toCheck == _owner);\n    }\n    function checkAppointeePermission(address toCheck, address mapToOwner) public view returns (bool){\n        return (_allowed[mapToOwner][toCheck] != 0);\n    }\n    function getOwner() public view returns(address owner){\n        return _owner;\n    }\n}"
    }
  }
}