{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/RTC.sol": {
      "content": "//\r// Hello World,\r//\r// Who needs a website when you have a contract? Welcome to Read This Contract (RTC).\r// Lets embrace the blockchain. We dont need the old web anymore.\r// Can you imagine what this can do? Get ready for the brave new world.\r// \r// The rules are simple:\r//\r// 0. First, I will pool RTC with ETH on Uniswap, so you can get your share in RTC.\r//    Uniswap pool will open with 2,400 RTC and 2.4 ETH; plus 900 RTC in reserve.\r//    This means 3,300 RTC initial supply. Minting cap is at 33,000 RTC.   \r//\r// 1. Next, I will pool several new tokens on Uniswap, all marked \"RTC\" in the name.\r//    Take note! My tokens will always be created using the same address as RTC:\r//    > 0xf4D73A15d2377B274b567D24a040167c2530C546\r//\r// 2. Each time, I will airdrop 10% of the new token initial supply to RTC holders!\r//\r// 3. Each time, I will announce the new token & pool on Telegram!\r//    > https://t.me/ReadThisContract\r//\r// 4. Each time, I will explain the mechanics of the new token inside its own contract.\r//    Read That Contract!\r//\r// Get ready & good luck!\r//\r// Veronika\r//\r\r// //////////////////////////////////////////////////////////////////////////////// //\r//                                                                                  //\r//                               ////   //////   /////                              //\r//                              //        //     //                                 //\r//                              //        //     /////                              //\r//                                                                                  //\r//                              Never break the chain.                              //\r//                                                                                  //\r// //////////////////////////////////////////////////////////////////////////////// //\r\rpragma solidity ^0.6.0;\r\rcontract Context {\r    constructor () internal { }\r\r    function _msgSender() internal view virtual returns (address payable) {\r        return msg.sender;\r    }\r\r    function _msgData() internal view virtual returns (bytes memory) {\r        this;\r        return msg.data;\r    }\r}\r\rpragma solidity ^0.6.0;\r\rlibrary SafeMath {\r    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r        uint256 c = a + b;\r        require(c >= a, \"SafeMath: addition overflow\");\r\r        return c;\r    }\r\r    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r        return sub(a, b, \"SafeMath: subtraction overflow\");\r    }\r\r    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r        require(b <= a, errorMessage);\r        uint256 c = a - b;\r\r        return c;\r    }\r\r    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r        if (a == 0) {\r            return 0;\r        }\r\r        uint256 c = a * b;\r        require(c / a == b, \"SafeMath: multiplication overflow\");\r\r        return c;\r    }\r\r    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r        return div(a, b, \"SafeMath: division by zero\");\r    }\r\r    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r        require(b > 0, errorMessage);\r        uint256 c = a / b;\r\r        return c;\r    }\r\r    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r        return mod(a, b, \"SafeMath: modulo by zero\");\r    }\r\r    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r        require(b != 0, errorMessage);\r        return a % b;\r    }\r}\r\rpragma solidity ^0.6.0;\r\rcontract Ownable is Context {\r    address private _owner;\r\r    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\r    constructor () internal {\r        address msgSender = _msgSender();\r        _owner = msgSender;\r        emit OwnershipTransferred(address(0), msgSender);\r    }\r\r    function owner() public view returns (address) {\r        return _owner;\r    }\r\r    modifier onlyOwner() {\r        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r        _;\r    }\r\r    function renounceOwnership() public virtual onlyOwner {\r        emit OwnershipTransferred(_owner, address(0));\r        _owner = address(0);\r    }\r\r    function transferOwnership(address newOwner) public virtual onlyOwner {\r        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r        emit OwnershipTransferred(_owner, newOwner);\r        _owner = newOwner;\r    }\r}\r\rpragma solidity ^0.6.2;\r\rlibrary Address {\r    function isContract(address account) internal view returns (bool) {\r        bytes32 codehash;\r        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r        assembly { codehash := extcodehash(account) }\r        return (codehash != accountHash && codehash != 0x0);\r    }\r\r    function sendValue(address payable recipient, uint256 amount) internal {\r        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\r        (bool success, ) = recipient.call{ value: amount }(\"\");\r        require(success, \"Address: unable to send value, recipient may have reverted\");\r    }\r}\r\rpragma solidity ^0.6.0;\r\rinterface IERC20 {\r    function totalSupply() external view returns (uint256);\r\r    function balanceOf(address account) external view returns (uint256);\r\r    function transfer(address recipient, uint256 amount) external returns (bool);\r\r    function allowance(address owner, address spender) external view returns (uint256);\r\r    function approve(address spender, uint256 amount) external returns (bool);\r\r    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\r    event Transfer(address indexed from, address indexed to, uint256 value);\r\r    event Approval(address indexed owner, address indexed spender, uint256 value);\r}\r\rpragma solidity ^0.6.0;\r\rcontract ERC20 is Context, IERC20 {\r    using SafeMath for uint256;\r    using Address for address;\r\r    mapping (address => uint256) private _balances;\r\r    mapping (address => mapping (address => uint256)) private _allowances;\r\r    uint256 private _totalSupply;\r\r    string private _name;\r    string private _symbol;\r    uint8 private _decimals;\r\r    constructor (string memory name, string memory symbol) public {\r        _name = name;\r        _symbol = symbol;\r        _decimals = 18;\r    }\r\r    function name() public view returns (string memory) {\r        return _name;\r    }\r\r    function symbol() public view returns (string memory) {\r        return _symbol;\r    }\r\r    function decimals() public view returns (uint8) {\r        return _decimals;\r    }\r\r    function totalSupply() public view override returns (uint256) {\r        return _totalSupply;\r    }\r\r    function balanceOf(address account) public view override returns (uint256) {\r        return _balances[account];\r    }\r\r    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r        _transfer(_msgSender(), recipient, amount);\r        return true;\r    }\r\r    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r        return _allowances[owner][spender];\r    }\r\r    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r        _approve(_msgSender(), spender, amount);\r        return true;\r    }\r\r    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r        _transfer(sender, recipient, amount);\r        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r        return true;\r    }\r\r    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r        return true;\r    }\r\r    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r        return true;\r    }\r\r    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r        require(sender != address(0), \"ERC20: transfer from the zero address\");\r        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\r        _beforeTokenTransfer(sender, recipient, amount);\r\r        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r        _balances[recipient] = _balances[recipient].add(amount);\r        emit Transfer(sender, recipient, amount);\r    }\r\r    function _mint(address account, uint256 amount) internal virtual {\r        require(account != address(0), \"ERC20: mint to the zero address\");\r\r        _beforeTokenTransfer(address(0), account, amount);\r\r        _totalSupply = _totalSupply.add(amount);\r        _balances[account] = _balances[account].add(amount);\r        emit Transfer(address(0), account, amount);\r    }\r\r    function _burn(address account, uint256 amount) internal virtual {\r        require(account != address(0), \"ERC20: burn from the zero address\");\r\r        _beforeTokenTransfer(account, address(0), amount);\r\r        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r        _totalSupply = _totalSupply.sub(amount);\r        emit Transfer(account, address(0), amount);\r    }\r\r    function _approve(address owner, address spender, uint256 amount) internal virtual {\r        require(owner != address(0), \"ERC20: approve from the zero address\");\r        require(spender != address(0), \"ERC20: approve to the zero address\");\r\r        _allowances[owner][spender] = amount;\r        emit Approval(owner, spender, amount);\r    }\r\r    function _setupDecimals(uint8 decimals_) internal {\r        _decimals = decimals_;\r    }\r\r    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r}\r\rpragma solidity ^0.6.0;\r\rabstract contract ERC20Capped is ERC20 {\r    uint256 private _cap;\r\r    constructor (uint256 cap) public {\r        require(cap > 0, \"ERC20Capped: cap is 0\");\r        _cap = cap;\r    }\r\r    function cap() public view returns (uint256) {\r        return _cap;\r    }\r\r    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\r        super._beforeTokenTransfer(from, to, amount);\r\r        if (from == address(0)) {\r            require(totalSupply().add(amount) <= _cap, \"ERC20Capped: cap exceeded\");\r        }\r    }\r}\r\rpragma solidity ^0.6.0;\r\rabstract contract ERC20Burnable is Context, ERC20 {\r\r    function burn(uint256 amount) public virtual {\r        _burn(_msgSender(), amount);\r    }\r\r    function burnFrom(address account, uint256 amount) public virtual {\r        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\r\r        _approve(account, _msgSender(), decreasedAllowance);\r        _burn(account, amount);\r    }\r}\r\rpragma solidity ^0.6.0;\r\rinterface IERC165 {\r    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r}\r\rpragma solidity ^0.6.2;\r\rlibrary ERC165Checker {\r    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\r\r    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\r    function supportsERC165(address account) internal view returns (bool) {\r        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&\r            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\r    }\r\r    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\r        return supportsERC165(account) &&\r            _supportsERC165Interface(account, interfaceId);\r    }\r\r\r    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\r        if (!supportsERC165(account)) {\r            return false;\r        }\r\r        for (uint256 i = 0; i < interfaceIds.length; i++) {\r            if (!_supportsERC165Interface(account, interfaceIds[i])) {\r                return false;\r            }\r        }\r\r        return true;\r    }\r\r\r    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\r        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\r\r        return (success && result);\r    }\r\r\r    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\r        private\r        view\r        returns (bool, bool)\r    {\r        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\r        (bool success, bytes memory result) = account.staticcall{ gas: 30000 }(encodedParams);\r        if (result.length < 32) return (false, false);\r        return (success, abi.decode(result, (bool)));\r    }\r}\r\rpragma solidity ^0.6.0;\r\rcontract ERC165 is IERC165 {\r\r    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\r\r    mapping(bytes4 => bool) private _supportedInterfaces;\r\r    constructor () internal {\r        _registerInterface(_INTERFACE_ID_ERC165);\r    }\r\r\r    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r        return _supportedInterfaces[interfaceId];\r    }\r\r\r    function _registerInterface(bytes4 interfaceId) internal virtual {\r        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r        _supportedInterfaces[interfaceId] = true;\r    }\r}\r\rpragma solidity ^0.6.0;\r\rcontract TokenRecover is Ownable {\r\r\r    function recoverERC20(address tokenAddress, uint256 tokenAmount) public onlyOwner {\r        IERC20(tokenAddress).transfer(owner(), tokenAmount);\r    }\r}\r\rpragma solidity ^0.6.0;\r\rlibrary EnumerableSet {\r\r    struct Set {\r        bytes32[] _values;\r\r        mapping (bytes32 => uint256) _indexes;\r    }\r\r\r    function _add(Set storage set, bytes32 value) private returns (bool) {\r        if (!_contains(set, value)) {\r            set._values.push(value);\r            set._indexes[value] = set._values.length;\r            return true;\r        } else {\r            return false;\r        }\r    }\r\r\r    function _remove(Set storage set, bytes32 value) private returns (bool) {\r        uint256 valueIndex = set._indexes[value];\r\r        if (valueIndex != 0) {\r            uint256 toDeleteIndex = valueIndex - 1;\r            uint256 lastIndex = set._values.length - 1;\r\r            bytes32 lastvalue = set._values[lastIndex];\r\r            set._values[toDeleteIndex] = lastvalue;\r            set._indexes[lastvalue] = toDeleteIndex + 1;\r            set._values.pop();\r\r            delete set._indexes[value];\r\r            return true;\r        } else {\r            return false;\r        }\r    }\r\r\r    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r        return set._indexes[value] != 0;\r    }\r\r\r    function _length(Set storage set) private view returns (uint256) {\r        return set._values.length;\r    }\r\r    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r        return set._values[index];\r    }\r\r    struct AddressSet {\r        Set _inner;\r    }\r\r\r    function add(AddressSet storage set, address value) internal returns (bool) {\r        return _add(set._inner, bytes32(uint256(value)));\r    }\r\r\r    function remove(AddressSet storage set, address value) internal returns (bool) {\r        return _remove(set._inner, bytes32(uint256(value)));\r    }\r\r\r    function contains(AddressSet storage set, address value) internal view returns (bool) {\r        return _contains(set._inner, bytes32(uint256(value)));\r    }\r\r\r    function length(AddressSet storage set) internal view returns (uint256) {\r        return _length(set._inner);\r    }\r\r    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r        return address(uint256(_at(set._inner, index)));\r    }\r\r\r    struct UintSet {\r        Set _inner;\r    }\r\r\r    function add(UintSet storage set, uint256 value) internal returns (bool) {\r        return _add(set._inner, bytes32(value));\r    }\r\r\r    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r        return _remove(set._inner, bytes32(value));\r    }\r\r\r    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r        return _contains(set._inner, bytes32(value));\r    }\r\r\r    function length(UintSet storage set) internal view returns (uint256) {\r        return _length(set._inner);\r    }\r\r    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r        return uint256(_at(set._inner, index));\r    }\r}\r\rpragma solidity ^0.6.0;\r\rabstract contract AccessControl is Context {\r    using EnumerableSet for EnumerableSet.AddressSet;\r    using Address for address;\r\r    struct RoleData {\r        EnumerableSet.AddressSet members;\r        bytes32 adminRole;\r    }\r\r    mapping (bytes32 => RoleData) private _roles;\r\r    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\r\r    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\r\r    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\r\r    function hasRole(bytes32 role, address account) public view returns (bool) {\r        return _roles[role].members.contains(account);\r    }\r\r\r    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\r        return _roles[role].members.length();\r    }\r\r\r    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\r        return _roles[role].members.at(index);\r    }\r\r\r    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\r        return _roles[role].adminRole;\r    }\r\r\r    function grantRole(bytes32 role, address account) public virtual {\r        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\r\r        _grantRole(role, account);\r    }\r\r\r    function revokeRole(bytes32 role, address account) public virtual {\r        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\r\r        _revokeRole(role, account);\r    }\r\r\r    function renounceRole(bytes32 role, address account) public virtual {\r        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\r        _revokeRole(role, account);\r    }\r\r\r    function _setupRole(bytes32 role, address account) internal virtual {\r        _grantRole(role, account);\r    }\r\r\r    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r        _roles[role].adminRole = adminRole;\r    }\r\r    function _grantRole(bytes32 role, address account) private {\r        if (_roles[role].members.add(account)) {\r            emit RoleGranted(role, account, _msgSender());\r        }\r    }\r\r    function _revokeRole(bytes32 role, address account) private {\r        if (_roles[role].members.remove(account)) {\r            emit RoleRevoked(role, account, _msgSender());\r        }\r    }\r}\r\rpragma solidity ^0.6.0;\r\rcontract Roles is AccessControl {\r\r    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\");\r    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR\");\r\r    constructor () public {\r        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r        _setupRole(MINTER_ROLE, _msgSender());\r        _setupRole(OPERATOR_ROLE, _msgSender());\r    }\r\r    modifier onlyMinter() {\r        require(hasRole(MINTER_ROLE, _msgSender()), \"Roles: caller does not have the MINTER role\");\r        _;\r    }\r\r    modifier onlyOperator() {\r        require(hasRole(OPERATOR_ROLE, _msgSender()), \"Roles: caller does not have the OPERATOR role\");\r        _;\r    }\r}\r\rpragma solidity ^0.6.0;\r\rcontract RTC is ERC20Capped, ERC20Burnable, Roles, TokenRecover {\r\r    bool private _mintingFinished = false;\r\r    bool private _transferEnabled = false;\r\r\r    event MintFinished();\r\r\r    event TransferEnabled();\r\r\r    modifier canMint() {\r        require(!_mintingFinished, \"RTC: minting is finished\");\r        _;\r    }\r\r\r    modifier canTransfer(address from) {\r        require(\r            _transferEnabled || hasRole(OPERATOR_ROLE, from),\r            \"RTC: transfer is not enabled or from does not have the OPERATOR role\"\r        );\r        _;\r    }\r\r\r    constructor(\r        string memory name,\r        string memory symbol,\r        uint8 decimals,\r        uint256 cap,\r        uint256 initialSupply,\r        bool transferEnabled,\r        bool mintingFinished\r    )\r        public\r        ERC20Capped(cap)\r        ERC20(name, symbol)\r    {\r        require(\r            mintingFinished == false || cap == initialSupply,\r            \"RTC: if finish minting, cap must be equal to initialSupply\"\r        );\r\r        _setupDecimals(decimals);\r\r        if (initialSupply > 0) {\r            _mint(owner(), initialSupply);\r        }\r\r        if (mintingFinished) {\r            finishMinting();\r        }\r\r        if (transferEnabled) {\r            enableTransfer();\r        }\r    }\r\r\r    function mintingFinished() public view returns (bool) {\r        return _mintingFinished;\r    }\r\r\r    function transferEnabled() public view returns (bool) {\r        return _transferEnabled;\r    }\r\r\r    function mint(address to, uint256 value) public canMint onlyMinter {\r        _mint(to, value);\r    }\r\r\r    function transfer(address to, uint256 value) public virtual override(ERC20) canTransfer(_msgSender()) returns (bool) {\r        return super.transfer(to, value);\r    }\r\r\r    function transferFrom(address from, address to, uint256 value) public virtual override(ERC20) canTransfer(from) returns (bool) {\r        return super.transferFrom(from, to, value);\r    }\r\r\r    function finishMinting() public canMint onlyOwner {\r        _mintingFinished = true;\r\r        emit MintFinished();\r    }\r\r\r    function enableTransfer() public onlyOwner {\r        _transferEnabled = true;\r\r        emit TransferEnabled();\r    }\r\r\r    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Capped) {\r        super._beforeTokenTransfer(from, to, amount);\r    }\r}"
    }
  }
}