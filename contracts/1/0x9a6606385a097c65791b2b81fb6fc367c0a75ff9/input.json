{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/miner_v2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^ 0.7 .0;\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns(uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns(uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b *c + a % b);\t// There is no case in which this doesn't hold\n\n    return c;\n  }\n  \n}\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns(address payable) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns(bytes memory) {\n    this;\n    return msg.data;\n  }\n}\n\ncontract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  function owner() public view returns(address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n\nabstract contract OldVersionMiner {\n  function getPivot() external view virtual returns(uint lastPivot);\n  function getAddressFromId(uint id) external view virtual returns(address minerAddress);\n  function showReward(address minerAddress) public view virtual returns(uint reward);\n}\n\nabstract contract Token {\n  function balanceOf(address account) external view virtual returns(uint256 data);\n}\n\nabstract contract Router {\n  function extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n}\n\n//===============================================================\n//MAIN CONTRACT\n//===============================================================\ncontract SoloMiner_v2 is Ownable {\n  using SafeMath\n  for uint;\n\n  Token private token;\n  Router private router;\n  OldVersionMiner private oldVersionMiner;\n\n  //Contract addresses\n  address private tokenContract;\n  address private routerContract;\n\n  //Global\n  uint private rewardConstant = 100000000000000000000;\n  uint private difficultyConstant = 69444444444444; //starts with 1% earning per day, decreases to 190258751902 in 20 years, 1317612 per block\n  uint private decreaseDifficultyConstant = 1317621; // decreases countdownConstant per block\n  uint private mintDecreaseConstant = 500000; //decreases countdownConstant per token mint function\n  uint private creationBlock = 0;\n\n  //Miner specific\n  uint private pivot = 0;\n  mapping(address => uint) private userBlocks;\n  mapping(address => uint) private miners;\n  mapping(uint => address) private addressFromId;\n  mapping(address => uint) private depositedTokens;\n  mapping(address => uint) private userDifficultyConstant;\n  mapping(address => uint) private userFlag;\n\n  \n  //Statistics\n  uint private totalMinted = 0;\n  uint private totalBurned = 0;\n  uint private circulatingTokens = 0;\n  mapping(address => uint) private userTotalMinted;\n  mapping(address => uint) private userTotalBurned;\n  mapping(address => uint) private userNumOfDeposits;\n  mapping(address => uint) private userNumOfWithdrawals;\n\n\n  constructor() {\n    oldVersionMiner = OldVersionMiner(address(0xE91c47806D720a8C0A8A87473E6788d30EB1D8F0));\n    uint oldPivot = oldVersionMiner.getPivot();\n    uint currentBlockNumber = getCurrentBlockNumber();\n    creationBlock = currentBlockNumber;\n    for (uint i = 1; i <= oldPivot; i++) {\n      address oldAddress = oldVersionMiner.getAddressFromId(i);\n      uint tokens = oldVersionMiner.showReward(oldAddress);\n      addMiner(oldAddress, tokens,i);    \n\n    }\n    pivot = oldPivot;\n  }\n  \n  //constructor helper\n  function addMiner(address minerAddress, uint amount, uint i) private returns(bool success) {\n    miners[minerAddress] = i;\n    addressFromId[i] = minerAddress;\n    depositedTokens[minerAddress] = amount;\n    userBlocks[minerAddress] = getCurrentBlockNumber();\n      \n    totalBurned = totalBurned.add(amount);\n    userTotalBurned[minerAddress] = userTotalBurned[minerAddress].add(amount);\n    userNumOfDeposits[minerAddress] = userNumOfDeposits[minerAddress].add(1);\n    \n    depositedTokens[minerAddress] = amount;\n    userBlocks[minerAddress] = getCurrentBlockNumber();\n    updateDifficulty(minerAddress);\n      \n    return true;\n  }\n  \n  \n\n  //+++++++++++VIEWS++++++++++++++++\n  //----------GETTERS---------------\n\n  //Contract addresses\n  function getRouterContract() external view virtual returns(address routerAddress) {\n    return routerContract;\n  }\n\n  function getTokenContract() external view virtual returns(address tokenAddress) {\n    return tokenContract;\n  }\n\n  //Global\n  function getRewardConstant() external view virtual returns(uint returnConstant) {\n    return rewardConstant;\n  }\n\n  function getDifficultyConstant() public view returns(uint256 returnConstant) {\n    return difficultyConstant;\n  }\n\n  function getDecreaseDifficultyConstant() public view returns(uint256 returnConstant) {\n    return decreaseDifficultyConstant;\n  }\n\n  function getMintDecreaseConstant() public view returns(uint256 returnConstant) {\n    return mintDecreaseConstant;\n  }\n\n  function getCreationBlock() public view returns(uint256 blockNumber) {\n    return creationBlock;\n  }\n\n  //Miner specific\n  function getPivot() external view virtual returns(uint lastPivot) {\n    return pivot;\n  }\n\n  function getLastBlockNumber(address minerAddress) public view virtual returns(uint lastBlock) {\n    return userBlocks[minerAddress];\n  }\n\n  function getIdFromAddress(address minerAddress) public view returns(uint256 id) {\n    return miners[minerAddress];\n  }\n\n  function getAddressFromId(uint id) external view virtual returns(address minerAddress) {\n    return addressFromId[id];\n  }\n\n  function getDepositedTokens(address minerAddress) public view returns(uint256 tokens) {\n    return depositedTokens[minerAddress];\n  }\n\n  function getUserDifficultyConstant(address minerAddress) public view returns(uint256 returnConstant) {\n    return userDifficultyConstant[minerAddress];\n  }\n  \n  //Statistics\n  function getTotalMinted() public view returns(uint256 minted) {\n    return totalMinted;\n  }\n  \n  function getTotalBurned() public view returns(uint256 burned) {\n    return totalBurned;\n  }\n  \n  function getCirculatingTokens() public view returns(uint256 burned) {\n    return circulatingTokens;\n  }\n  \n  function getUserTotalMinted(address minerAddress) public view returns(uint256 minted) {\n    return userTotalMinted[minerAddress];\n  }\n  \n  function getUserTotalBurned(address minerAddress) public view returns(uint256 burned) {\n    return userTotalBurned[minerAddress];\n  } \n  \n  function getUserNumOfDeposits(address minerAddress) public view returns(uint256 deposits) {\n    return userNumOfDeposits[minerAddress];\n  } \n    \n  function getUserNumOfWithdrawals(address minerAddress) public view returns(uint256 withdrawals) {\n    return userNumOfWithdrawals[minerAddress];\n  } \n\n  //Other\n  function getCurrentBlockNumber() public view returns(uint256 blockNumber) {\n    return block.number;\n  }\n\n  function showEarned(address minerAddress) public view virtual returns(uint tokensEarned) {\n    require(userFlag[minerAddress]!=1,\"solo_miner:showEarned:User Blocked\");\n    uint previousBlock = getLastBlockNumber(minerAddress);\n    uint currentBlock = getCurrentBlockNumber();\n    require(previousBlock <= currentBlock, \"solo_miner:showEarned:bad block numbers\");\n    uint diff = currentBlock.sub(previousBlock);\n    uint deposited = depositedTokens[minerAddress];\n\n    if (rewardConstant == 0) {\n      return 0;\n    }\n    uint earned = ((deposited.mul(diff)).mul(userDifficultyConstant[minerAddress])).div(rewardConstant);\n    return earned;\n\n  }\n\n  function showReward(address minerAddress) public view virtual returns(uint reward) {\n    require(userFlag[minerAddress]!=1,\"solo_miner:showReward:User Blocked\");\n    uint earned = showEarned(minerAddress);\n    uint ret = depositedTokens[minerAddress].add(earned);\n    return ret;\n  }\n\n  //+++++++++++EXTERNAL++++++++++++++++\n  function mine(uint depositAmount) external virtual returns(bool success) {\n    require(userFlag[msg.sender]!=1,\"solo_miner:mine:User Blocked\");\n    require(depositAmount > 0, \"solo_miner:mine:No zero deposits\");\n    registerMiner();\n    \n    burn(depositAmount);\n    \n    uint reward = showReward(msg.sender);\n    uint deposit = reward.add(depositAmount);\n\n    totalBurned = totalBurned.add(depositAmount);\n    userTotalBurned[msg.sender] = userTotalBurned[msg.sender].add(depositAmount);\n    userNumOfDeposits[msg.sender] = userNumOfDeposits[msg.sender].add(1);\n    if(circulatingTokens>=depositAmount){circulatingTokens = circulatingTokens.sub(depositAmount);}\n    else{circulatingTokens=0;}\n    \n    \n    depositedTokens[msg.sender] = deposit;\n    userBlocks[msg.sender] = getCurrentBlockNumber();\n    updateDifficulty(msg.sender);\n\n    return true;\n  }\n\n  function getReward(uint withdrawalAmount) public virtual returns(bool success) {\n    require(userFlag[msg.sender]!=1,\"solo_miner:getReward:User Blocked\");\n    require(getLastBlockNumber(msg.sender) > 0, \"solo_miner:getReward:Must mine first\");\n    require(mintDecreaseConstant <= difficultyConstant, \"solo_miner:getReward:difficulty constants error\");\n\n    uint reward = showReward(msg.sender);\n    require(withdrawalAmount <= reward, \"solo_miner:getReward:Amount too big\");\n    registerMiner();\n    \n    mint(withdrawalAmount);\n\n    uint balance = reward.sub(withdrawalAmount);\n\n    depositedTokens[msg.sender] = balance;\n    userBlocks[msg.sender] = getCurrentBlockNumber();\n\n    totalMinted = totalMinted.add(withdrawalAmount);\n    userTotalMinted[msg.sender] = userTotalMinted[msg.sender].add(withdrawalAmount);\n    userNumOfWithdrawals[msg.sender] = userNumOfWithdrawals[msg.sender].add(1);\n    circulatingTokens = circulatingTokens.add(withdrawalAmount);\n    \n    difficultyConstant = difficultyConstant.sub(mintDecreaseConstant);\n    updateDifficulty(msg.sender);\n\n    return true;\n  }\n\n  function withdrawAll() public virtual returns(bool success) {\n    uint amt = showReward(msg.sender);\n    getReward(amt);\n    return true;\n  }\n\n  //+++++++++++ONLY OWNER++++++++++++++++\n  //----------SETTERS--------------------\n\n  //Contract addresses\n  function setNewTokenContract(address newTokenAddress) onlyOwner public virtual returns(bool success) {\n    tokenContract = newTokenAddress;\n    token = Token(newTokenAddress);\n    return true;\n  }\n\n  function setNewRouterContract(address newRouterAddress) onlyOwner public virtual returns(bool success) {\n    routerContract = newRouterAddress;\n    router = Router(newRouterAddress);\n    return true;\n  }\n\n  //Global\n  function setRewardConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\n    rewardConstant = newConstant;\n    return true;\n  }\n\n  function setDifficultyConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\n    difficultyConstant = newConstant;\n    return true;\n  }\n\n  function setDecreaseDifficultyConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\n    decreaseDifficultyConstant = newConstant;\n    return true;\n  }\n\n  function setMintDecreaseConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\n    mintDecreaseConstant = newConstant;\n    return true;\n  }\n  \n  //Miner specific\n  function setUserFlag(address minerAddress, uint flag) onlyOwner public virtual returns(bool success) {\n    userFlag[minerAddress] = flag;\n    return true;\n  }\n  \n  //+++++++++++PRIVATE++++++++++++++++++++   \n  function registerMiner() private {\n    if (miners[msg.sender] == 0) {\n      pivot = pivot.add(1);\n      miners[msg.sender] = pivot;\n      addressFromId[pivot] = msg.sender;\n    }\n  }\n\n  function updateDifficulty(address minerAddress) private {\n    uint currentBlock = getCurrentBlockNumber();\n    require(creationBlock <= currentBlock, \"solo_miner:updateDifficulty:bad block numbers\");\n    uint diff = currentBlock.sub(creationBlock);\n    uint decreaseBy = decreaseDifficultyConstant.mul(diff);\n\n    if (decreaseBy > difficultyConstant) {\n      userDifficultyConstant[minerAddress] = 1;\n    } else {\n      userDifficultyConstant[minerAddress] = difficultyConstant.sub(decreaseBy);\n    }\n  }\n\n  function burn(uint burnAmount) private returns(bool success) {\n    require(burnAmount <= token.balanceOf(msg.sender), \"solo_miner:burn:You are trying to burn more than you own\");\n\n    address toAddress = address(0);\n    address[2] memory addresseArr = [msg.sender, toAddress];\n    uint[2] memory uintArr = [burnAmount, 0];\n\n    router.extrenalRouterCall(\"burn_miner\", addresseArr, uintArr);\n\n    return true;\n  }\n\n  function mint(uint mintAmount) private returns(bool success) {\n    address fromAddress = address(0);\n    address[2] memory addresseArr = [fromAddress, msg.sender];\n    uint[2] memory uintArr = [mintAmount, 0];\n\n    router.extrenalRouterCall(\"mint_miner\", addresseArr, uintArr);\n\n    return true;\n  }\n}\n"
    }
  }
}