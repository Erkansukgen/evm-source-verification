{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/TokenLoader.sol": {
      "content": "// SPDX-License-Identifier: ISC\n\npragma solidity ^0.7.5;\npragma experimental ABIEncoderV2;\n\n// target contract interface - selection of used ERC20 and ERC721 methods\nabstract contract Target {\n    function name() public virtual view returns (string memory);\n\n    function symbol() public virtual view returns (string memory);\n\n    function decimals() public virtual view returns (uint8);\n\n    function totalSupply() public virtual view returns (uint256);\n\n    // Method from ERC165 interface used to check whether the contract is ERC721\n    function supportsInterface(bytes4 interfaceID)\n        external\n        virtual\n        view\n        returns (bool);\n}\n\ncontract TokenLoader {\n    struct TokenInfo {\n        address addr; // address of the token contract\n        bool definitelyIsERC721; // can be resolved only when the token implements ERC165\n        string name; // mandatory in ERC20, voluntary in ERC721 (ERC721Metadata interface)\n        string symbol; // mandatory in ERC20, voluntary in ERC721 (ERC721Metadata interface)\n        uint8 decimals; // mandatory in ERC20\n        uint256 totalSupply; // mandatory in ERC20, voluntary in ERC721 (ERC721Enumerable interface)\n    }\n\n    function loadTokens(address[] calldata tokens)\n        external\n        view\n        returns (TokenInfo[] memory tokenInfo)\n    {\n        tokenInfo = new TokenInfo[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (!isContract(tokens[i])) {\n                continue;\n            }\n            Target target = Target(tokens[i]);\n\n            tokenInfo[i].addr = tokens[i];\n\n            tokenInfo[i].definitelyIsERC721 = definitelyIsERC721(target);\n\n            (bool success, bytes memory returnData) = address(target)\n                .staticcall(abi.encodeWithSelector(target.name.selector));\n            if (success) {\n                tokenInfo[i].name = abi.decode(returnData, (string));\n            } else {\n                tokenInfo[i].name = '';\n            }\n\n            (success, returnData) = address(target).staticcall(\n                abi.encodeWithSelector(target.symbol.selector)\n            );\n            if (success) {\n                tokenInfo[i].symbol = abi.decode(returnData, (string));\n            } else {\n                tokenInfo[i].symbol = '';\n            }\n\n            (success, returnData) = address(target).staticcall(\n                abi.encodeWithSelector(target.decimals.selector)\n            );\n            if (success) {\n                tokenInfo[i].decimals = abi.decode(returnData, (uint8));\n            } else {\n                tokenInfo[i].decimals = 0;\n            }\n\n            (success, returnData) = address(target).staticcall(\n                abi.encodeWithSelector(target.totalSupply.selector)\n            );\n            if (success) {\n                tokenInfo[i].totalSupply = abi.decode(returnData, (uint256));\n            } else {\n                tokenInfo[i].totalSupply = 0;\n            }\n        }\n\n        return tokenInfo;\n    }\n\n    function isContract(address _addr) private view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    function definitelyIsERC721(Target target) private view returns (bool) {\n        // 0x80ac58cd - ERC721 ID\n        (bool success, bytes memory returnData) = address(target).staticcall(\n            abi.encodeWithSelector(\n                target.supportsInterface.selector,\n                0x80ac58cd\n            )\n        );\n        return success && abi.decode(returnData, (bool));\n    }\n}\n"
    }
  }
}