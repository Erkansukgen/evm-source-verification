{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/interactiveAdapters/1split/OneSplitInteractiveAdapter.sol":{"content":"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\n\ninterface ERC20 {\n    function approve(address, uint256) external returns (bool);\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n}\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract\n * returns false). Tokens that return no value (and instead revert or throw on failure)\n * are also supported, non-reverting calls are assumed to be successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.transfer.selector,\n                to,\n                value\n            ),\n            \"transfer\",\n            location\n        );\n    }\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.transferFrom.selector,\n                from,\n                to,\n                value\n            ),\n            \"transferFrom\",\n            location\n        );\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address spender,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: wrong approve call\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                value\n            ),\n            \"approve\",\n            location\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\n     * relaxing the requirement on the return value: the return value is optional\n     * (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param location Location of the call (for debug).\n     */\n    function callOptionalReturn(\n        ERC20 token,\n        bytes memory data,\n        string memory functionName,\n        string memory location\n    )\n        private\n    {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\n        // mechanism, since we're implementing it ourselves.\n\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\n        //  1. The call itself is made, and success asserted\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(\n            success,\n            string(\n                abi.encodePacked(\n                    \"SafeERC20: \",\n                    functionName,\n                    \" failed in \",\n                    location\n                )\n            )\n        );\n\n        if (returndata.length > 0) { // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: false returned\");\n        }\n    }\n}\n\n\nstruct Action {\n    ActionType actionType;\n    bytes32 protocolName;\n    uint256 adapterIndex;\n    address[] tokens;\n    uint256[] amounts;\n    AmountType[] amountTypes;\n    bytes data;\n}\n\nenum ActionType { None, Deposit, Withdraw }\n\n\nenum AmountType { None, Relative, Absolute }\n\n\n/**\n * @title Protocol adapter interface.\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract ProtocolAdapter {\n\n    /**\n     * @dev MUST return \"Asset\" or \"Debt\".\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function adapterType() external pure virtual returns (bytes32);\n\n    /**\n     * @dev MUST return token type (default is \"ERC20\").\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function tokenType() external pure virtual returns (bytes32);\n\n    /**\n     * @dev MUST return amount of the given token locked on the protocol by the given account.\n     */\n    function getBalance(address token, address account) public view virtual returns (uint256);\n}\n\n\n/**\n * @title Adapter for OneSplit exchange.\n * @dev Implementation of ProtocolAdapter interface.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\ncontract OneSplitAdapter is ProtocolAdapter {\n\n    bytes32 public constant override adapterType = \"Exchange\";\n\n    bytes32 public constant override tokenType = \"\";\n\n    /**\n     * @return Amount of Uniswap pool tokens held by the given account.\n     * @dev Implementation of ProtocolAdapter interface function.\n     */\n    function getBalance(address, address) public view override returns (uint256) {\n        revert(\"OSA: no balance!\");\n    }\n}\n\n\n/**\n * @title Base contract for interactive protocol adapters.\n * @dev deposit() and withdraw() functions MUST be implemented\n * as well as all the functions from ProtocolAdapter interface.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract InteractiveAdapter is ProtocolAdapter {\n\n    uint256 internal constant RELATIVE_AMOUNT_BASE = 1e18;\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /**\n     * @dev The function must deposit assets to the protocol.\n     * @return MUST return assets to be sent back to the `msg.sender`.\n     */\n    function deposit(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory data\n    )\n        public\n        payable\n        virtual\n        returns (address[] memory);\n\n    /**\n     * @dev The function must withdraw assets from the protocol.\n     * @return MUST return assets to be sent back to the `msg.sender`.\n     */\n    function withdraw(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory data\n    )\n        public\n        payable\n        virtual\n        returns (address[] memory);\n\n    function getAbsoluteAmountDeposit(\n        address token,\n        uint256 amount,\n        AmountType amountType\n    )\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (amountType == AmountType.Relative) {\n            require(amount <= RELATIVE_AMOUNT_BASE, \"L: wrong relative value!\");\n\n            uint256 totalAmount;\n            if (token == ETH) {\n                totalAmount = address(this).balance;\n            } else {\n                totalAmount = ERC20(token).balanceOf(address(this));\n            }\n\n            if (amount == RELATIVE_AMOUNT_BASE) {\n                return totalAmount;\n            } else {\n                return totalAmount * amount / RELATIVE_AMOUNT_BASE; // TODO overflow check\n            }\n        } else {\n            return amount;\n        }\n    }\n\n    function getAbsoluteAmountWithdraw(\n        address token,\n        uint256 amount,\n        AmountType amountType\n    )\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (amountType == AmountType.Relative) {\n            require(amount <= RELATIVE_AMOUNT_BASE, \"L: wrong relative value!\");\n\n            if (amount == RELATIVE_AMOUNT_BASE) {\n                return getBalance(token, address(this));\n            } else {\n                return getBalance(token, address(this)) * amount / RELATIVE_AMOUNT_BASE; // TODO overflow check\n            }\n        } else {\n            return amount;\n        }\n    }\n}\n\n\n/**\n * @dev OneSplit contract interface.\n * Only the functions required for OneSplitInteractiveAdapter contract are added.\n * The OneSplit contract is available here\n * github.com/CryptoManiacsZone/1split/blob/master/contracts/OneSplit.sol.\n */\ninterface OneSplit {\n    function swap(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256[] calldata,\n        uint256\n    )\n        external\n        payable;\n    function getExpectedReturn(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256\n    )\n        external\n        view\n        returns (uint256, uint256[] memory);\n}\n\n\n/**\n * @title Interactive adapter for OneSplit exchange.\n * @dev Implementation of InteractiveAdapter abstract contract.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\ncontract OneSplitInteractiveAdapter is InteractiveAdapter, OneSplitAdapter {\n\n    using SafeERC20 for ERC20;\n\n    address internal constant ONE_SPLIT = 0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E;\n\n    /**\n     * @notice Exchanges tokens using OneSplit contract.\n     * @param tokens Array with one element - `fromToken` address.\n     * @param amounts Array with one element - token amount to be exchanged.\n     * @param amountTypes Array with one element - amount type.\n     * @param data Bytes array with ABI-encoded `toToken` address.\n     * @return Asset sent back to the msg.sender.\n     * @dev Implementation of InteractiveAdapter function.\n     */\n    function deposit(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory data\n    )\n        public\n        payable\n        override\n        returns (address[] memory)\n    {\n        require(tokens.length == 1, \"OSIA: should be 1 token/amount/type!\");\n\n        uint256 amount = getAbsoluteAmountDeposit(tokens[0], amounts[0], amountTypes[0]);\n\n        address fromToken = tokens[0];\n        if (fromToken == ETH) {\n            fromToken = address(0);\n        } else {\n            ERC20(fromToken).safeApprove(ONE_SPLIT, amount, \"OSIA!\");\n        }\n\n        address[] memory tokensToBeWithdrawn;\n\n        address toToken = abi.decode(data, (address));\n        if (toToken == ETH) {\n            tokensToBeWithdrawn = new address[](0);\n            toToken = address(0);\n        } else {\n            tokensToBeWithdrawn = new address[](1);\n            tokensToBeWithdrawn[0] = toToken;\n        }\n\n        swap(fromToken, toToken, amount);\n\n        return tokensToBeWithdrawn;\n    }\n\n    /**\n     * @notice This function is unavailable in Exchange type adapters.\n     * @dev Implementation of InteractiveAdapter function.\n     */\n    function withdraw(\n        address[] memory,\n        uint256[] memory,\n        AmountType[] memory,\n        bytes memory\n    )\n        public\n        payable\n        override\n        returns (address[] memory)\n    {\n        revert(\"OSIA: no withdraw!\");\n    }\n\n    function swap(address fromToken, address toToken, uint256 amount) internal {\n        uint256[] memory distribution;\n\n        try OneSplit(ONE_SPLIT).getExpectedReturn(\n            fromToken,\n            toToken,\n            amount,\n            uint256(1),\n            uint256(0x040df0) // 0x040dfc to enable curve; 0x04fdf0 to enable base exchanges;\n        ) returns (uint256, uint256[] memory result) {\n            distribution = result;\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory) {\n            revert(\"OSIA: 1split fail![1]\");\n        }\n\n        uint256 value = fromToken == address(0) ? amount : 0;\n        try OneSplit(ONE_SPLIT).swap.value(value)(\n            fromToken,\n            toToken,\n            amount,\n            uint256(1),\n            distribution,\n            uint256(0x040df0) // 0x040dfc to enable curve; 0x04fdf0 to enable base exchanges;\n        ) {} catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory) {\n            revert(\"OSIA: 1split fail![2]\");\n        }\n    }\n}\n"}}}