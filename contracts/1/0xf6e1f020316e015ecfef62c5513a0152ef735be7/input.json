{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"RewardXUnicPeriodically.sol":{"content":"\n// File: @chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n// File: gist-62587a7f0885c4cbdbd587ca0dc74a12/Counter.sol\n\npragma solidity ^0.6.7;\n\n\ninterface KeeperCompatibleInterface {\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n    function performUpkeep(bytes calldata performData) external;\n}\n\ncontract ProxyFarmer {\n    function rewardXUNIC() public {}\n}\n\ncontract RewardXUnicPeriodically is KeeperCompatibleInterface {\n\n    /**\n    * Use an interval in seconds and a timestamp to slow execution of Upkeep\n    */\n    uint public interval;\n    uint public lastTimeStamp;\n    ProxyFarmer farmer;\n    address owner;\n\n    \n    constructor(uint updateInterval, address _t) public {\n      interval = updateInterval;\n      lastTimeStamp = block.timestamp;\n      farmer = ProxyFarmer(_t);\n      owner = msg.sender;\n    }\n    \n    function changeInterval(uint updateInterval) public {\n      require(owner == msg.sender, \"Only the owner can change the update interval.\");\n      interval = updateInterval;\n      lastTimeStamp = block.timestamp;\n    }\n\n    function checkUpkeep(bytes calldata checkData) external override returns (bool upkeepNeeded, bytes memory performData) {\n        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;\n\n        // We don't use the checkData in this example\n        // checkData was defined when the Upkeep was registered\n        performData = checkData;\n    }\n\n    function performUpkeep(bytes calldata performData) external override {\n        lastTimeStamp = block.timestamp;\n\n        // We don't use the performData in this example\n        // performData is generated by the Keeper's call to your `checkUpkeep` function\n        performData;\n        farmer.rewardXUNIC();\n        \n    }\n    \n}"}}}