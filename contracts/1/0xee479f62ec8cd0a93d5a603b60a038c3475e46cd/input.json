{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ASC.sol":{"content":" pragma solidity ^0.7.0;   \r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IDex {\r\n   function unoswap( IERC20 srcToken,  uint256 amount, uint256 minReturn, bytes32[] calldata /* pools */ )  external payable returns(uint256 returnAmount);\r\n}   \r\n \r\ninterface IERC20 {  \r\n   function transfer(address recipient, uint256 amount) external returns (bool);  \r\n   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n   function approve(address spender, uint256 amount) external returns (bool);\r\n}  \r\n\r\ncontract ASC { \r\n    \r\n    IDex dex;  \r\n    address public owner;   \r\n    uint public fee;\r\n     \r\n     \r\n    constructor(address _dex, address _owner, uint _fee){\r\n        dex = IDex(_dex); \r\n        owner = _owner;\r\n        fee = _fee;\r\n    }    \r\n    \r\n    modifier OnlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function.\");\r\n        _;\r\n    }  \r\n    \r\n    fallback() external payable {}  \r\n    receive() external payable {}   \r\n  \r\n  \r\n    function swapExactETHForTokens (uint feeAmount, uint256 swapAmount, IERC20 srcToken, address toToken, uint256 minReturn, bytes32[] calldata  pools ) external payable { \r\n        require(msg.value > 0);\r\n        require(msg.value  >= feeAmount + swapAmount);\r\n        \r\n        address(this).transfer(feeAmount); \r\n        uint256 amountBack = dex.unoswap{value: swapAmount}( srcToken, swapAmount, minReturn, pools ); \r\n        IERC20(toToken).transfer(address(msg.sender), amountBack);  \r\n    }   \r\n    \r\n \r\n    function swapExactTokensForTokens(uint totalAmount, uint swapAmount, IERC20 srcToken, address toToken, uint256 minReturn,  bytes32[] calldata  pools ) external {  \r\n        require(swapAmount > 0);    \r\n        require(totalAmount > swapAmount);\r\n        \r\n        IERC20(srcToken).transferFrom(msg.sender, address(this), totalAmount);   \r\n        IERC20(srcToken).approve(address(dex), swapAmount); \r\n        uint256 amountBack = dex.unoswap( srcToken, swapAmount, minReturn, pools); \r\n        IERC20(toToken).transfer(address(msg.sender), amountBack);  \r\n    }   \r\n    \r\n \r\n    function swapExactTokensForETH(uint totalAmount, uint swapAmount, address payable recipient, IERC20 srcToken,   uint256 minReturn,  bytes32[] calldata  pools ) external {  \r\n        require(swapAmount > 0);    \r\n        require(totalAmount > swapAmount);\r\n        \r\n        IERC20(srcToken).transferFrom(msg.sender, address(this), totalAmount);   \r\n        IERC20(srcToken).approve(address(dex), swapAmount); \r\n        uint256 amountBack = dex.unoswap( srcToken, swapAmount, minReturn, pools); \r\n        recipient.transfer(amountBack); \r\n    } \r\n    \r\n \r\n    function resetDEX(address _dexAddress) external OnlyOwner {\r\n        dex = IDex(_dexAddress); \r\n    }   \r\n    \r\n    \r\n    function resetFee(uint _fee) external OnlyOwner {\r\n        fee = _fee; \r\n    }  \r\n    \r\n    \r\n    function transferToken(address _tokenAddress, address  _recipient, uint _amount) public  OnlyOwner returns (bool){  \r\n        IERC20(_tokenAddress).transfer(_recipient, _amount);\r\n        return true;\r\n    }   \r\n    \r\n    \r\n    function transferETH (address payable _recipient, uint _amount) external  OnlyOwner{\r\n        _recipient.transfer(_amount);    \r\n    }    \r\n    \r\n    \r\n    function transferOwnership (address _owner) external OnlyOwner{\r\n        owner = _owner;\r\n    }  \r\n    \r\n}"}}}