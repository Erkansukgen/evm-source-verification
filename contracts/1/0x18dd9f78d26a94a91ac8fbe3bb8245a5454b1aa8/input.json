{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "AdvancedWithdrawerMainnet.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2021-09-17\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2021-09-17\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2021-06-20\n*/\n\n// SPDX-License-Identifier: MIXED\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.2\n// License-Identifier: MIT\npragma solidity 0.8.4;\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.1\ninterface IERC20 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\n// File @sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol@v1.0.2\n\ninterface IBentoBoxV1 {\n    function balanceOf(IERC20 token, address user) external view returns (uint256 share);\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    function toAmount(\n        IERC20 token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n    \n    function toShare(\n        IERC20 token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n    \n    function transfer(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n}\n\n// License-Identifier: MIT\n\ninterface Cauldron {\n    function accrue() external;\n    function withdrawFees() external;\n    function accrueInfo() external view returns(uint64, uint128, uint64);\n    function bentoBox() external returns (address);\n}\n\ninterface CauldronV1 {\n    function accrue() external;\n    function withdrawFees() external;\n    function accrueInfo() external view returns(uint64, uint128);\n}\n\ncontract AdvancedWithdrawer is BoringOwnable {\n    \n    Cauldron[] public cauldrons;\n    CauldronV1[] public cauldronsv1;\n    Cauldron[] public degens;\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    IBentoBoxV1 public constant degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    \n    constructor(Cauldron[] memory pools, CauldronV1[] memory poolsv1, Cauldron[] memory degens_) {\n        cauldrons = pools;\n        cauldronsv1 = poolsv1;\n        degens = degens_;\n    }\n    \n    function withdraw() external {\n        uint256 length = cauldrons.length;\n        for(uint256 i = 0; i < length; i++) {\n            cauldrons[i].accrue();\n            (, uint256 feesEarned, ) = cauldrons[i].accrueInfo();\n            if(feesEarned > (bentoBox.toAmount(MIM, bentoBox.balanceOf(MIM, address(cauldrons[i])), false))) {\n                MIM.transferFrom(msg.sender, address(bentoBox), feesEarned);\n                bentoBox.deposit(MIM, address(bentoBox), address(cauldrons[i]), feesEarned, 0);\n            }\n            cauldrons[i].withdrawFees();\n        }\n        \n        length = cauldronsv1.length;\n        for(uint256 i = 0; i < length; i++) {\n            cauldronsv1[i].accrue();\n            (, uint256 feesEarned) = cauldronsv1[i].accrueInfo();\n            if(feesEarned > (bentoBox.toAmount(MIM, bentoBox.balanceOf(MIM, address(cauldronsv1[i])), false))) {\n                MIM.transferFrom(msg.sender, address(bentoBox), feesEarned);\n                bentoBox.deposit(MIM, address(bentoBox), address(cauldronsv1[i]), feesEarned, 0);\n            }\n            cauldronsv1[i].withdrawFees();\n\n        }\n        \n        length = degens.length;\n        for(uint256 i = 0; i < length; i++) {\n            degens[i].accrue();\n            (, uint256 feesEarned, ) = degens[i].accrueInfo();\n            if(feesEarned > (degenBox.toAmount(MIM, degenBox.balanceOf(MIM, address(degens[i])), false))) {\n                MIM.transferFrom(msg.sender, address(degenBox), feesEarned);\n                degenBox.deposit(MIM, address(degenBox), address(degens[i]), feesEarned, 0);\n            }\n            degens[i].withdrawFees();\n        }\n        \n    }\n    \n    function addPool(Cauldron pool) external onlyOwner {\n        _addPool(pool);\n    }\n    \n    function _addPool(Cauldron pool) internal onlyOwner {\n        //allow settings and changing cauldrons that receive staking rewards.\n        require(address(pool) != address(0), \"invalid cauldron\");\n        \n        if(pool.bentoBox() == address(bentoBox)){\n            //do not allow doubles\n            for(uint256 i = 0; i < cauldrons.length; i++){\n                require(cauldrons[i] != pool, \"already added\");\n            }\n            cauldrons.push(pool);\n        } else if (pool.bentoBox() == address(degenBox)) {\n            for(uint256 i = 0; i < degens.length; i++){\n                require(degens[i] != pool, \"already added\");\n            }\n            degens.push(pool);\n        }\n        \n    }\n    \n    function addPoolv1(CauldronV1 pool) external onlyOwner {\n        cauldronsv1.push(pool);\n    }\n    \n    \n    function addPools(Cauldron[] memory pools) external onlyOwner {\n        for(uint256 i = 0; i < pools.length; i++) {\n            _addPool(pools[i]);\n        }\n    }\n    \n}"
    }
  }
}