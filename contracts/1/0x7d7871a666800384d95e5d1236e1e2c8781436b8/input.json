{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Stats.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface CTokenInterface {\n    function exchangeRateStored() external view returns (uint);\n    function borrowBalanceStored(address) external view returns (uint);\n\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface ListInterface {\n    function accounts() external view returns (uint);\n    function accountID(address) external view returns (uint64);\n    function accountAddr(uint64) external view returns (address);\n}\n\ncontract Helpers {\n\n    struct CompData {\n        uint balanceOfUser;\n        uint borrowBalanceStoredUser;\n    }\n    struct data {\n        address user;\n        CompData[] tokensData;\n    }\n    \n     struct datas {\n        CompData[] tokensData;\n    }\n}\n\n\ncontract Resolver is Helpers {\n    \n    function getDSAWallets(uint len) public view returns(address[] memory) {\n        address[] memory wallets = new address[](len);\n        ListInterface list = ListInterface(0x4c8a1BEb8a87765788946D6B19C6C6355194AbEb);\n        uint _len = len == 0 ? list.accounts() : len;\n        for (uint i = 0; i < _len; i++) {\n            wallets[i] = list.accountAddr(uint64(i+1));\n        }\n        return wallets;\n    }\n\n    function getCompoundData(address owner, address[] memory cAddress) public view returns (CompData[] memory) {\n        CompData[] memory tokensData = new CompData[](cAddress.length);\n        for (uint i = 0; i < cAddress.length; i++) {\n            CTokenInterface cToken = CTokenInterface(cAddress[i]);\n            tokensData[i] = CompData(\n                cToken.balanceOf(owner),\n                cToken.borrowBalanceStored(owner)\n            );\n        }\n\n        return tokensData;\n    }\n    \n    function getCompoundDataByToken(address[] memory owners, address cAddress) public view returns (CompData[] memory) {\n        CompData[] memory tokensData = new CompData[](owners.length);\n        CTokenInterface cToken = CTokenInterface(cAddress);\n        for (uint i = 0; i < owners.length; i++) {\n            tokensData[i] = CompData(\n                cToken.balanceOf(owners[i]),\n                cToken.borrowBalanceStored(owners[i])\n            );\n        }\n\n        return tokensData;\n    }\n\n    function getPosition(\n        address[] memory owners,\n        address[] memory cAddress\n    )\n        public\n        view\n        returns (datas[] memory)\n    {\n        datas[] memory _data = new datas[](cAddress.length);\n        for (uint i = 0; i < cAddress.length; i++) {\n            _data[i] = datas(\n                getCompoundDataByToken(owners, cAddress[i])\n            );\n        }\n        return _data;\n    }\n\n}\n"}}}