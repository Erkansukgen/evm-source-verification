{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/distribution.sol":{"content":"pragma solidity 0.6.7;\n\ncontract Ownable {\n\n    address internal _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_isOwner(msg.sender), \"Caller is not the owner\");\n        _;\n    }\n\n    function _isOwner(address account) internal view returns (bool) {\n        return account == _owner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n}\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address who) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Distribution is Ownable {\n\n    event ExceedGasLimit();\n    event Total(address tokenAddress, uint256 arrayLength, uint256 totalAmount, uint256 totalValue);\n\n    function transferToken1(address tokenAddr, address[] memory recipients, uint256[] memory values, uint256 startIndex) public onlyOwner returns(uint256) {\n        uint256 amount = recipients.length;\n        uint256 totalValue = getSum(values);\n\n        IERC20 token = IERC20(tokenAddr);\n\n        require(getBalanceOf(tokenAddr, address(this)) >= totalValue, 'Send tokens to this contract first');\n        require(values.length == amount, 'Arrays are not equal');\n\n        uint256 i;\n        for (i = startIndex; i < amount; i++) {\n            require(recipients[i] != address(0), 'Zero address was met');\n            token.transfer(recipients[i], values[i]);\n\n            if (gasleft() < 50000 && i+1 < amount) {\n                i++;\n                emit ExceedGasLimit();\n                break;\n            }\n\n        }\n\n        emit Total(tokenAddr, amount, i, totalValue);\n        return i;\n    }\n\n    function transferToken2(address tokenAddr, address[] memory recipients, uint256 value, uint256 startIndex) public onlyOwner returns(uint256) {\n        uint256 amount = recipients.length;\n        uint256 totalValue = value * amount;\n\n        IERC20 token = IERC20(tokenAddr);\n\n        require(getBalanceOf(tokenAddr, address(this)) >= totalValue, 'Send tokens to this contract first');\n\n        uint256 i;\n        for (i = startIndex; i < amount; i++) {\n            require(recipients[i] != address(0), 'Zero address was met');\n            token.transfer(recipients[i], value);\n\n            if (gasleft() < 50000 && i+1 < amount) {\n                i++;\n                emit ExceedGasLimit();\n                break;\n            }\n\n        }\n\n        emit Total(tokenAddr, amount, i, totalValue);\n        return i;\n    }\n\n    function getSum(uint256[] memory values) public pure returns(uint256) {\n        uint256 totalValue;\n        for (uint256 i = 0; i < values.length; i++) {\n            totalValue += values[i];\n        }\n        return totalValue;\n    }\n\n    function getContractBalanceOf(address tokenAddr) public view returns(uint256) {\n        return IERC20(tokenAddr).balanceOf(address(this));\n    }\n\n    function getBalanceOf(address tokenAddr, address account) public view returns(uint256) {\n        return IERC20(tokenAddr).balanceOf(account);\n    }\n\n}\n"}}}