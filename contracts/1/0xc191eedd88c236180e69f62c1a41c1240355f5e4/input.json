{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/1_Storage.sol": {
      "content": "/**\n *Submitted for verification at Etherscan.io on 2019-10-09\n*/\n\npragma solidity >=0.4.0 <0.6.0;\n\n/* taking ideas from FirstBlood token */\ncontract SafeMath {\n\n    /* function assert(bool assertion) internal { */\n    /*   if (!assertion) { */\n    /*     throw; */\n    /*   } */\n    /* }      // assert no longer needed once solidity is on 0.4.10 */\n\n    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal pure  returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal pure  returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n}\n\ncontract Token {\n    uint256 public totalSupply;\n    function balanceOf(address _owner) public view  returns (uint256 balance);\n    function transfer(address _to, uint256 _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n    function approve(address _spender, uint256 _value) public returns (bool success);\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n/*  ERC 20 token */\ncontract StandardToken is Token {\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n      if (balances[msg.sender] >= _value && _value > 0) {\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract ERC1132 {\n    /**\n     * @dev Reasons why a user's tokens have been locked\n     */\n    mapping(address => string[]) public lockReason;\n\n    /**\n     * @dev locked token structure\n     */\n    struct lockToken {\n        uint256 amount;\n        uint256 validity;\n        bool claimed;\n    }\n\n    /**\n     * @dev Holds number & validity of tokens locked for a given reason for\n     *      a specified address\n     */\n    mapping(address => mapping(string => lockToken)) public locked;\n\n    /**\n     * @dev Records data of all the tokens Locked\n     */\n    event Locked(\n        address indexed _of,\n        string indexed _reason,\n        uint256 _amount,\n        uint256 _validity\n    );\n\n    /**\n     * @dev Records data of all the tokens unlocked\n     */\n    event Unlocked(\n        address indexed _of,\n        string indexed _reason,\n        uint256 _amount\n    );\n\n    /**\n     * @dev Locks a specified amount of tokens against an address,\n     *      for a specified reason and time\n     * @param _reason The reason to lock tokens\n     * @param _amount Number of tokens to be locked\n     * @param _time Lock time in seconds\n     */\n    function lock(string memory _reason, uint256 _amount, uint256 _time)\n        public returns (bool);\n    /**\n     * @dev Returns tokens locked for a specified address for a\n     *      specified reason\n     *\n     * @param _of The address whose tokens are locked\n     * @param _reason The reason to query the lock tokens for\n     */\n    function tokensLocked(address _of, string memory _reason)\n        public view returns (uint256 amount);\n    /**\n     * @dev Returns tokens locked for a specified address for a\n     *      specified reason at a specific time\n     *\n     * @param _of The address whose tokens are locked\n     * @param _reason The reason to query the lock tokens for\n     * @param _time The timestamp to query the lock tokens for\n     */\n    function tokensLockedAtTime(address _of, string memory _reason, uint256 _time)\n        public view returns (uint256 amount);\n    /**\n     * @dev Returns total tokens held by an address (locked + transferable)\n     * @param _of The address to query the total balance of\n     */\n    function totalBalanceOf(address _of)\n        public view returns (uint256 amount);\n    /**\n     * @dev Extends lock for a specified reason and time\n     * @param _reason The reason to lock tokens\n     * @param _time Lock extension time in seconds\n     */\n    function extendLock(string memory _reason, uint256 _time)\n        public returns (bool);\n    /**\n     * @dev Increase number of tokens locked for a specified reason\n     * @param _reason The reason to lock tokens\n     * @param _amount Number of tokens to be increased\n     */\n    function increaseLockAmount(string memory _reason, uint256 _amount)\n        public returns (bool);\n\n    /**\n     * @dev Returns unlockable tokens for a specified address for a specified reason\n     * @param _of The address to query the the unlockable token count of\n     * @param _reason The reason to query the unlockable tokens for\n     */\n    function tokensUnlockable(address _of, string memory _reason)\n        public view returns (uint256 amount);\n    /**\n     * @dev Unlocks the unlockable tokens of a specified address\n     * @param _of Address of user, claiming back unlockable tokens\n     */\n    function unlock(address _of)\n        public returns (uint256 unlockableTokens);\n\n    /**\n     * @dev Gets the unlockable tokens of a specified address\n     * @param _of The address to query the the unlockable token count of\n     */\n    function getUnlockableTokens(address _of)\n        public view returns (uint256 unlockableTokens);\n\n}\n\ncontract Lockable is ERC1132,StandardToken {\n\n    string internal constant ALREADY_LOCKED = 'Tokens already locked';\n    string internal constant NOT_LOCKED = 'No tokens locked';\n    string internal constant AMOUNT_ZERO = 'Amount can not be 0';\n    /**\n     * @dev Locks a specified amount of tokens against an address,\n     *      for a specified reason and time\n     * @param _reason The reason to lock tokens\n     * @param _amount Number of tokens to be locked\n     * @param _time Lock time in days\n     */\n    function lock(string memory _reason, uint256 _amount, uint256 _time)\n        public\n        returns (bool)\n    {\n        uint256 validUntil = now + (_time * 1 days); //solhint-disable-line\n\n        // If tokens are already locked, then functions extendLock or\n        // increaseLockAmount should be used to make any changes\n        require(tokensLocked(msg.sender, _reason) == 0, ALREADY_LOCKED);\n        require(_amount != 0, AMOUNT_ZERO);\n\n        if (locked[msg.sender][_reason].amount == 0)\n            lockReason[msg.sender].push(_reason);\n\n        transfer(address(this), _amount);\n\n        locked[msg.sender][_reason] = lockToken(_amount, validUntil, false);\n\n        emit Locked(msg.sender, _reason, _amount, validUntil);\n        return true;\n    }\n    /**\n     * @dev Transfers and Locks a specified amount of tokens,\n     *      for a specified reason and time\n     * @param _to adress to which tokens are to be transfered\n     * @param _reason The reason to lock tokens\n     * @param _amount Number of tokens to be transfered and locked\n     * @param _time Lock time in seconds\n     */\n    function transferWithLock(address _to, string memory _reason, uint256 _amount, uint256 _time)\n        public\n        returns (bool)\n    {\n        uint256 validUntil = now + (_time * 1 days); //solhint-disable-line\n\n        require(tokensLocked(_to, _reason) == 0, ALREADY_LOCKED);\n        require(_amount != 0, AMOUNT_ZERO);\n\n        if (locked[_to][_reason].amount == 0)\n            lockReason[_to].push(_reason);\n\n        transfer(address(this), _amount);\n\n        locked[_to][_reason] = lockToken(_amount, validUntil, false);\n        emit Locked(_to, _reason, _amount, validUntil);\n        return true;\n    }\n\n    /**\n     * @dev Returns tokens locked for a specified address for a\n     *      specified reason\n     *\n     * @param _of The address whose tokens are locked\n     * @param _reason The reason to query the lock tokens for\n     */\n    function tokensLocked(address _of, string memory _reason)\n        public\n        view\n        returns (uint256 amount)\n    {\n        if (!locked[_of][_reason].claimed)\n            amount = locked[_of][_reason].amount;\n    }\n    /**\n     * @dev Returns tokens locked for a specified address for a\n     *      specified reason at a specific time\n     *\n     * @param _of The address whose tokens are locked\n     * @param _reason The reason to query the lock tokens for\n     * @param _time The timestamp to query the lock tokens for\n     */\n    function tokensLockedAtTime(address _of, string memory _reason, uint256 _time)\n        public\n        view\n        returns (uint256 amount)\n    {\n        if (locked[_of][_reason].validity > _time)\n            amount = locked[_of][_reason].amount;\n    }\n\n    /**\n     * @dev Returns total tokens held by an address (locked + transferable)\n     * @param _of The address to query the total balance of\n     */\n    function totalBalanceOf(address _of)\n        public\n        view\n        returns (uint256 amount)\n    {\n        amount = balanceOf(_of);\n\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n            amount = amount + (tokensLocked(_of, lockReason[_of][i]));\n        }\n    }\n    /**\n     * @dev Extends lock for a specified reason and time\n     * @param _reason The reason to lock tokens\n     * @param _time Lock extension time in seconds\n     */\n    function extendLock(string memory _reason, uint256 _time)\n        public\n        returns (bool)\n    {\n        require(tokensLocked(msg.sender, _reason) > 0, NOT_LOCKED);\n\n        locked[msg.sender][_reason].validity = locked[msg.sender][_reason].validity + (_time);\n\n        emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\n        return true;\n    }\n    /**\n     * @dev Increase number of tokens locked for a specified reason\n     * @param _reason The reason to lock tokens\n     * @param _amount Number of tokens to be increased\n     */\n    function increaseLockAmount(string memory _reason, uint256 _amount)\n        public\n        returns (bool)\n    {\n        require(tokensLocked(msg.sender, _reason) > 0, NOT_LOCKED);\n        transfer(address(this), _amount);\n\n        locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount + (_amount);\n\n        emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\n        return true;\n    }\n\n    /**\n     * @dev Returns unlockable tokens for a specified address for a specified reason\n     * @param _of The address to query the the unlockable token count of\n     * @param _reason The reason to query the unlockable tokens for\n     */\n    function tokensUnlockable(address _of, string memory _reason)\n        public\n        view\n        returns (uint256 amount)\n    {\n        if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) //solhint-disable-line\n            amount = locked[_of][_reason].amount;\n    }\n\n    /**\n     * @dev Unlocks the unlockable tokens of a specified address\n     * @param _of Address of user, claiming back unlockable tokens\n     */\n    function unlock(address _of)\n        public\n        returns (uint256 unlockableTokens)\n    {\n        uint256 lockedTokens;\n\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n            lockedTokens = tokensUnlockable(_of, lockReason[_of][i]);\n            if (lockedTokens > 0) {\n                unlockableTokens = unlockableTokens + (lockedTokens);\n                locked[_of][lockReason[_of][i]].claimed = true;\n                emit Unlocked(_of, lockReason[_of][i], lockedTokens);\n            }\n        }\n\n        if (unlockableTokens > 0)\n            this.transfer(_of, unlockableTokens);\n    }\n\n    /**\n     * @dev Gets the unlockable tokens of a specified address\n     * @param _of The address to query the the unlockable token count of\n     */\n    function getUnlockableTokens(address _of)\n        public\n        view\n        returns (uint256 unlockableTokens)\n    {\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n            unlockableTokens = unlockableTokens + (tokensUnlockable(_of, lockReason[_of][i]));\n        }\n    }\n}\n\n\ncontract AGToken is Lockable, SafeMath {\n\n    // metadata\n    string public constant name = \"Agri10x Token\";\n    string public constant symbol = \"AG10\";\n    uint256 public constant decimals = 18;\n    string public version = \"1.0\";\n    string internal constant PUBLIC_LOCKED = 'Public sale of token is locked';\n    address owner;\n    // contracts\n    address payable ethFundDeposit;      // deposit address for ETH for Agri10x International\n    address payable agtFundDeposit;      // deposit address for Agri10x International use and AGT User Fund\n\n    // crowdsale parameters\n    bool public isFinalized;              // switched to true in operational state\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n    uint256 public constant agtFund = 45 * (10**6) * 10**decimals;   // 500m AGT reserved for Agri10x Intl use\n    uint256 public constant tokenExchangeRate = 1995; // 6400 AGT tokens per 1 ETH\n    uint256 public constant tokenCreationCap =  200 * (10**6) * 10**decimals;\n    uint256 public constant tokenCreationMin = 1 * (10**6) * 10**decimals;\n    uint256 public publicSaleDate;\n\n\n    // events\n    event LogRefund(address indexed _to, uint256 _value);\n    event CreateAGT(address indexed _to, uint256 _value);\n    event SoldAGT(address indexed _to, uint256 _value);\n\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n    }\n\n    // constructor\n    constructor(\n        address payable _ethFundDeposit,\n        address payable _agtFundDeposit,\n        uint256 _fundingStartBlock,\n        uint256 _fundingEndBlock) public\n    {\n      owner = msg.sender;\n      publicSaleDate = now + (120 * 1 days);\n      isFinalized = false;                   //controls pre through crowdsale state\n      ethFundDeposit = _ethFundDeposit;\n      agtFundDeposit = _agtFundDeposit;\n      fundingStartBlock = _fundingStartBlock;\n      fundingEndBlock = _fundingEndBlock;\n      totalSupply = agtFund;\n      balances[agtFundDeposit] = agtFund;    // Deposit Agri10x Intl share\n      emit CreateAGT(agtFundDeposit, agtFund);  // logs Agri10x Intl fund\n    }\n\n    /// @dev Accepts ether and creates new AGT tokens.\n    function customRatecreateTokens(uint256 customtokenExchangeRate) external payable  onlyOwner{\n      if (isFinalized) revert();\n      if (block.number < fundingStartBlock) revert();\n      if (block.number > fundingEndBlock) revert();\n      if (msg.value == 0) revert();\n\n      uint256 tokens = safeMult(msg.value, customtokenExchangeRate); // check that we're not over totals\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\n\n      // return money if something goes wrong\n      if (tokenCreationCap < checkedSupply) revert();  // odd fractions won't be found\n\n      totalSupply = checkedSupply;\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\n      emit CreateAGT(msg.sender, tokens);  // logs token creation\n    }\n\n    function createTokens() external payable  onlyOwner{\n      if (isFinalized) revert();\n      if (block.number < fundingStartBlock) revert();\n      if (block.number > fundingEndBlock) revert();\n      if (msg.value == 0) revert();\n\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\n\n      // return money if something goes wrong\n      if (tokenCreationCap < checkedSupply) revert();  // odd fractions won't be found\n\n      totalSupply = checkedSupply;\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\n      emit CreateAGT(msg.sender, tokens);  // logs token creation\n    }\n\n    function publicSale() external payable {\n      require(publicSaleDate < now, PUBLIC_LOCKED);\n      if (msg.value == 0) revert();\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\n\n      // return money if something goes wrong\n      if (tokenCreationCap < checkedSupply) revert();  // odd fractions won't be found\n\n      totalSupply = checkedSupply;\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\n      emit SoldAGT(msg.sender, tokens);  // logs token creation\n    }\n\n    function changeSaleDate(uint256 _time) external onlyOwner{\n        publicSaleDate = now + (_time * 1 days);\n    }\n\n    function createFreeTokens(uint256 numberOfTokens) external payable  onlyOwner{\n      uint256 tokens = safeMult(1, numberOfTokens); // check that we're not over totals\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\n\n      // return money if something goes wrong\n      if (tokenCreationCap < checkedSupply) revert();  // odd fractions won't be found\n\n      totalSupply = checkedSupply;\n      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\n      emit CreateAGT(msg.sender, tokens);  // logs token creation\n    }\n\n    /// @dev Ends the funding period and sends the ETH home\n    function finalize() external onlyOwner{\n      if (isFinalized) revert();\n      if (msg.sender != ethFundDeposit) revert(); // locks finalize to the ultimate ETH owner\n      if(totalSupply < tokenCreationMin) revert();      // have to sell minimum to move to operational\n      if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) revert();\n      // move to operational\n      isFinalized = true;\n      if(!ethFundDeposit.send(address(this).balance)) revert();  // send the eth to Agri10x International\n    }\n\n    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n    function refund() external onlyOwner{\n      if(isFinalized) revert();                       // prevents refund if operational\n      if (block.number <= fundingEndBlock) revert(); // prevents refund until sale period is over\n      if(totalSupply >= tokenCreationMin) revert();  // no refunds if we sold enough\n      if(msg.sender == agtFundDeposit) revert();    // Agri10x Intl not entitled to a refund\n      uint256 agtVal = balances[msg.sender];\n      if (agtVal == 0) revert();\n      balances[msg.sender] = 0;\n      totalSupply = safeSubtract(totalSupply, agtVal); // extra safe\n      uint256 ethVal = agtVal / tokenExchangeRate;     // should be safe; previous throws covers edges\n      emit LogRefund(msg.sender, ethVal);               // log it\n      if (!msg.sender.send(ethVal)) revert();       // if you're using a contract; make sure it works with .send gas limits\n    }\n\n    function() external payable {}\n\n}"
    }
  }
}