{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.0;\n\ninterface IERC20 {\n\n  function totalSupply() external view returns (uint);\n  function balanceOf(address tokenOwner) external view returns (uint balance);\n  function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n  function transfer(address to, uint tokens) external returns (bool success);\n  function approve(address spender, uint tokens) external returns (bool success);\n  function transferFrom(address from, address to, uint tokens) external returns (bool success);\n\n  event Transfer(address indexed from, address indexed to, uint tokens);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n\n}"
    },
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.0;\n\ncontract Ownable {\n\n  address public owner;\n  address public feeAddress;\n  address public reserveAddress;\n\n  event OwnershipTransferred(address newOwner);\n  event FeeAddressTransferred(address newFeeAddress);\n  event ReserveAddressTransferred(address newReserveAddress);\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, 'You are not the owner!');\n    _;\n  }\n\n  function transferOwnership(address newOwner) onlyOwner internal {\n    owner = newOwner;\n  }\n\n  function transferFeeAddress(address newFeeAddress) onlyOwner internal {\n    feeAddress = newFeeAddress;\n  }\n\n  function transferReserveAddress(address newReserveAddress) onlyOwner internal {\n    reserveAddress = newReserveAddress;\n  }\n\n}"
    },
    "SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.0;\n\nlibrary SafeMath {\n\n  function add(uint a, uint b) internal pure returns(uint) {\n    uint c = a + b;\n    require(c >= a, \"Sum overflow!\");\n    return c;\n  }\n\n  function sub(uint a, uint b) internal pure returns(uint) {\n    uint c = a - b;\n    require(c <= a, \"Sub underflow!\");\n    return c;\n  }\n\n  function mul(uint a, uint b) internal pure returns(uint) {\n    if(a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    require(c / a == b, \"Mul overflow!\");\n    return c;\n  }\n  \n  function div(uint a, uint b) internal pure returns(uint) {\n    uint c = a / b;\n    return c;\n  }\n\n}"
    },
    "TreasuryBondsPlus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.0;\npragma experimental ABIEncoderV2;\nimport './IERC20.sol';\nimport './Ownable.sol';\nimport './SafeMathLib.sol';\n\ncontract TreasuryBondsPlus is Ownable, IERC20 {\n\n  using SafeMath for uint;\n\n  string public constant name = 'Treasury Bonds Plus';\n  string public constant symbol = 'TB+';\n  uint8 public constant decimals = 8;\n\n  uint private _totalSupply;\n\n  mapping(address => uint) private _balances;\n  mapping(address => mapping(address => uint)) private _allowed;\n\n  event Mint(address indexed to, uint tokens);\n  event Burn(address indexed account, uint tokens);\n  event BuyBack(address indexed tokenOwner, uint tokens);\n\n  constructor(address _feeAddress, address _reserveAddress) {\n    _totalSupply = 50000000 * 10 **uint(decimals);\n    feeAddress = _feeAddress;\n    reserveAddress = _reserveAddress;\n\n    _balances[owner] = _totalSupply;\n    emit Transfer(address(0), owner, _totalSupply);\n  }\n\n  function totalSupply() public override view returns (uint) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address tokenOwner) public override view returns (uint balance) {\n    return _balances[tokenOwner];\n  }\n\n  function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n    return _allowed[tokenOwner][spender];\n  }\n\n  function transfer(address to, uint tokens) public override returns (bool success) {\n    require(tokens >= 1000000, 'The minimum amount of tokens that can be transferred is 0.01.');\n\n    uint tax = 0;\n    if (msg.sender != owner) tax = _setTax(tokens);\n\n    _transfer(msg.sender, to, tokens, tax);\n    return true;\n  }\n\n  function approve(address spender, uint tokens) public override returns (bool success) {\n    require(msg.sender != address(0), 'Invalid address!');\n    require(spender != address(0), 'Invalid address!');\n\n    _allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n    require(tokens >= 1000000, 'The minimum amount of tokens that can be transferred is 0.01.');\n    require(_allowed[from][msg.sender] >= tokens, 'Quantity of tokens allowed is insufficient!');\n    require(to == msg.sender, 'The receiving address must be the same as the one calling the function!');\n\n    uint tax = _setTax(tokens);\n    _transfer(from, to, tokens, tax);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\n    return true;\n  }\n\n  function mint(address to, uint tokens) public onlyOwner {\n    require(to != address(0), 'Invalid address!');\n\n    _balances[to] = _balances[to].add(tokens);\n    _totalSupply = _totalSupply.add(tokens);\n    emit Mint(to, tokens);\n  }\n\n  function burn(address account, uint tokens) public onlyOwner {\n    require(account != address(0), 'Invalid address!');\n    require(_balances[account] >= tokens, 'Account balance is less than the number of tokens');\n\n    _balances[account] = _balances[account].sub(tokens);\n    _totalSupply = _totalSupply.sub(tokens);\n    emit Burn(account, tokens);\n  }\n\n  function buyBack(address tokenOwner, uint tokens) public onlyOwner returns (bool success) {\n    require(_balances[tokenOwner] >= tokens, 'Insufficient tokens!');\n\n    _balances[tokenOwner] = _balances[tokenOwner].sub(tokens);\n    _balances[reserveAddress] = _balances[reserveAddress].add(tokens);\n    \n    emit BuyBack(tokenOwner, tokens);\n    return true;\n  }\n\n  function newOwner(address account) public onlyOwner returns (bool success) {\n    require(account != owner, 'The address of the new owner must be different from the current one.');\n\n    address oldOwner = owner;\n    transferOwnership(account);\n    _balances[account] = _balances[oldOwner];\n    _balances[oldOwner] = 0;\n    OwnershipTransferred(account);\n    return true;\n  }\n\n  function newFeeAddress(address account) public onlyOwner returns (bool success) {\n    require(account != feeAddress, 'The new feeAddress must be different from the current one.');\n\n    address oldFeeAddress = feeAddress;\n    transferFeeAddress(account);\n    _balances[account] = _balances[oldFeeAddress];\n    _balances[oldFeeAddress] = 0;\n    FeeAddressTransferred(account);\n    return true;\n  }\n\n  function newReserveAddress(address account) public onlyOwner returns (bool success) {\n    require(account != reserveAddress, 'The new reserveAddress must be different from the current one.');\n\n    address oldReserveAddress = reserveAddress;\n    transferReserveAddress(account);\n    _balances[account] = _balances[oldReserveAddress];\n    _balances[oldReserveAddress] = 0;\n    ReserveAddressTransferred(account);\n    return true;\n  }\n\n  function close() public onlyOwner {\n    selfdestruct(payable(owner));\n  }\n\n  function _setTax(uint tokens) private pure returns (uint) {\n    uint tokensInPercentage = tokens / 100;\n    uint tax;\n\n    if (tokens <= 10000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 2; // 0,50%\n    else if (tokens <= 50000 * 10 **uint(decimals)) tax = tokensInPercentage * 7 / 20; // 0,35%\n    else if (tokens <= 100000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 4; // 0,25%\n    else if (tokens <= 1000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 5; // 0,20%\n    else if (tokens <= 10000000 * 10 **uint(decimals)) tax = tokensInPercentage * 9 / 50; // 0,18%\n    else if (tokens <= 50000000 * 10 **uint(decimals)) tax = tokensInPercentage * 3 / 20; // 0,15%\n    else if (tokens <= 100000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 10; // 0,10%\n    else if (tokens <= 300000000 * 10 **uint(decimals)) tax = tokensInPercentage * 7 / 100; // 0,07%\n    else if (tokens <= 500000000 * 10 **uint(decimals)) tax = tokensInPercentage * 3 / 50; // 0,06%\n    else if (tokens <= 1000000000 * 10 **uint(decimals)) tax = tokensInPercentage * 1 / 20; // 0,05%\n    else tax = tokensInPercentage * 1 / 25; // 0,04%\n\n    return tax;\n  }\n\n  function _transfer(address sender, address recipient, uint tokens, uint tax) private {\n    require(sender != address(0), 'Invalid address!');\n    require(recipient != address(0), 'Invalid address!');\n    require(sender != recipient, 'Addresses must be different!');\n    require(_balances[sender] >= tokens, 'Insufficient tokens!');\n\n    uint tokensWithTax = tokens;\n    if (tax > 0) {\n      tokensWithTax = tokens - tax;\n      _balances[feeAddress] = _balances[feeAddress].add(tax);\n    }\n    \n    _balances[sender] = _balances[sender].sub(tokens);\n    _balances[recipient] = _balances[recipient].add(tokensWithTax);\n\n    emit Transfer(sender, recipient, tokens);\n  }\n\n}"
    }
  }
}