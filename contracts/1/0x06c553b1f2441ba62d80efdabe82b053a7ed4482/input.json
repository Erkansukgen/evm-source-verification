{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/daiTest.sol":{"content":"pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract UniV2Sniper {\n    // config:\n    Token constant sourceToken = Token(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n    Token constant targetToken = Token(0x6B175474E89094C44Da98b954EedeAC495271d0F); // DAI\n    \n    uint constant minSourceTokenLiquidity = 50000000000000000000; // 50 WETH\n    // (200000 / 0.05) / (200000 / 1664) = 33280\n    uint constant maxTargetTokenRate      = 1600; // poolTargetTokenBalance / poolSourceTokenBalance\n    \n    bool maxApePoolBalance = true;\n    \n    using UniswapV2ExchangeLib for IUniswapV2Exchange;\n    IUniswapV2Factory uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n    \n    fallback() external {\n        // get pair address\n        IUniswapV2Exchange pair = IUniswapV2Exchange(uniswapFactory.getPair(address(sourceToken), address(targetToken)));\n        \n        // pair doesnt exist yet\n        if (address(pair) == address(0)) {\n            revert(\"p\");\n        }\n        \n        // get own token balance\n        uint input = sourceToken.balanceOf(address(this));\n        if (input == 0){\n            revert(\"i\");\n        }\n        \n        // check if liquidity is suffienent\n        uint poolSourceBalance = sourceToken.balanceOf(address(pair));\n        if (poolSourceBalance < minSourceTokenLiquidity) {\n            revert(\"s\");\n        }\n        \n        // cap aping amount\n        if (maxApePoolBalance && input > poolSourceBalance) {\n            input = poolSourceBalance;\n        }\n        \n        // check token rate\n        if (maxTargetTokenRate > 0) {\n            uint poolTargetBalance = targetToken.balanceOf(address(pair));\n            \n            // check if rate is suffienent\n            if (poolTargetBalance / poolSourceBalance > maxTargetTokenRate){\n                revert(\"r\");\n            }\n        }\n        \n        // calculate output\n        uint output = pair.getReserveReturn(address(sourceToken), address(targetToken), input);\n\n        // swap\n        Token(sourceToken).transfer(address(pair), input);\n        if (uint256(address(sourceToken)) < uint256(address(targetToken))) {\n            pair.swap(0, output, address(this), \"\");\n        } else {\n            pair.swap(output, 0, address(this), \"\");\n        }\n    }\n    \n    \n\n    // Management functions:\n    address payable owner;\n\n    // constructor\n    constructor() public payable {\n        // set Owner\n        owner = msg.sender;\n    }\n\n    /** @notice Allows the owner to nominate a new owner (giving up his priviledges)\n        * @param  newOwner The new owner address\n        */\n    function changeOwnerSnipe(address payable newOwner) public {\n        require(msg.sender == owner);\n\n        owner = newOwner;\n    }\n\n    /** @notice Allows the owner to make a call from the contract\n        */\n    function ownerCallSnipe(address target, bytes memory data, uint value) public payable returns (bytes memory){\n        require(msg.sender == owner);\n\n        (bool success, bytes memory returnData) = target.call.value(\n            value\n        )(\n            data\n        );\n        require(success);\n\n        return returnData;\n    }\n\n    /** @notice Allows the owner to make a call from the contract\n        */\n    function ownerDelegatecallSnipe(address target, bytes memory data) public payable returns (bytes memory){\n        require(msg.sender == owner);\n\n        (bool success, bytes memory returnData) = target.delegatecall(\n            data\n        );\n        require(success);\n\n        return returnData;\n    }\n\n    /** @notice Allows the owner to approve a token to be spent by another address\n        * @param  token   The token\n        * @param  spender The spender\n        * @param  amount  The amount spender should be able to spend\n        */\n    function approveTokenForSnipe(address token, address spender, uint256 amount) public {\n        require(msg.sender == owner);\n\n        Token(token).approve(spender, amount);\n    }\n\n    /** @notice Allows the owner to withdraw tokens from this contract\n        * @param  token   The token to withdraw\n        * @param  amount  The amount to withdraw\n        */\n    function withdrawTokenSnipe(address token, uint256 amount) public {\n        require(msg.sender == owner);\n\n        Token(token).transfer(owner, amount);\n    }\n\n    /** @notice Allows the owner to withdraw ether from this contract\n        * @param  amount  The amount to withdraw\n        */\n    function withdrawEtherSnipe(uint256 amount) public {\n        require(msg.sender == owner);\n\n        require(\n            owner.send(amount),\n            \"Sending of ETH failed.\"\n        );\n    }\n}\n\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ninterface IUniswapV2Exchange {\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n    // force balances to match reserves\n    function skim(address to) external;\n\n    // force reserves to match balances\n    function sync() external;\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n}\n\nlibrary UniswapV2ExchangeLib {\n    using SafeMath for uint256;\n\n    function getReserveReturn(\n        IUniswapV2Exchange exchange,\n        address fromToken,\n        address toToken,\n        uint amountIn\n    ) internal view returns (uint256) {\n        address token0 = exchange.token0();\n\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = exchange.getReserves();\n\n        uint256 reserveIn;\n        uint256 reserveOut;\n        if (token0 == fromToken) {\n            reserveIn = uint256(_reserve0);\n            reserveOut = uint256(_reserve1);\n        } else {\n            reserveIn = uint256(_reserve1);\n            reserveOut = uint256(_reserve0);\n        }\n\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        return (denominator == 0) ? 0 : numerator.div(denominator);\n    }\n}\n\n\n\ncontract Token {\n    function totalSupply() view public returns (uint256 supply) {}\n\n    function balanceOf(address _owner) view public returns (uint256 balance) {}\n\n    function transfer(address _to, uint256 _value) public {}\n\n    function transferFrom(address _from, address _to, uint256 _value)  public {}\n\n    function approve(address _spender, uint256 _value) public {}\n\n    function allowance(address _owner, address _spender) view public returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    uint256 public decimals;\n    string public name;\n}\n\n\n\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n"}}}