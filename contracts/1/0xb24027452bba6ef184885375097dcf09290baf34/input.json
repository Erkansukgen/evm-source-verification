{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "locker.sol": {
      "content": "pragma solidity 0.8.4;\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\nlibrary SafeERC20 {\n    using Address for address;\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(\n                oldAllowance >= value,\n                \"SafeERC20: decreased allowance below zero\"\n            );\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(\n                token,\n                abi.encodeWithSelector(\n                    token.approve.selector,\n                    spender,\n                    newAllowance\n                )\n            );\n        }\n    }\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\nabstract contract LockerTypes {\n    enum LockType {\n        ERC20,\n        LP\n    }\n    struct LockStorageRecord {\n        LockType ltype;\n        address token;\n        uint256 amount;\n        VestingRecord[] vestings;\n    }\n    struct VestingRecord {\n        uint256 unlockTime;\n        uint256 amountUnlock;\n        bool isNFT;\n    }\n    struct RegistryShare {\n        uint256 lockIndex;\n        uint256 sharePercent;\n        uint256 claimedAmount;\n    }\n}\ncontract PicipoLocker is LockerTypes {\n    using SafeERC20 for IERC20;\n    string constant name = \"Lock & Registry v0.0.2\";\n    uint256 constant MAX_VESTING_RECORDS_PER_LOCK = 250;\n    uint256 constant TOTAL_IN_PERCENT = 10000;\n    LockStorageRecord[] lockerStorage;\n    mapping(address => RegistryShare[]) public registry;\n    mapping(uint256 => address[]) beneficiariesInLock;\n    event NewLock(\n        address indexed erc20,\n        address indexed who,\n        uint256 lockedAmount,\n        uint256 lockId\n    );\n    function lockTokens(\n        address _ERC20,\n        uint256 _amount,\n        uint256[] memory _unlockedFrom,\n        uint256[] memory _unlockAmount,\n        address[] memory _beneficiaries,\n        uint256[] memory _beneficiariesShares\n    ) external {\n        require(_amount > 0, \"Cant lock 0 amount\");\n        require(\n            IERC20(_ERC20).allowance(msg.sender, address(this)) >= _amount,\n            \"Please approve first\"\n        );\n        require(\n            _getArraySum(_unlockAmount) == _amount,\n            \"Sum vesting records must be equal lock amount\"\n        );\n        require(\n            _unlockedFrom.length == _unlockAmount.length,\n            \"Length of periods and amounts arrays must be equal\"\n        );\n        require(\n            _beneficiaries.length == _beneficiariesShares.length,\n            \"Length of beneficiaries and shares arrays must be equal\"\n        );\n        require(\n            _getArraySum(_beneficiariesShares) == TOTAL_IN_PERCENT,\n            \"Sum of shares array must be equal to 100%\"\n        );\n        VestingRecord[] memory v = new VestingRecord[](_unlockedFrom.length);\n        for (uint256 i = 0; i < _unlockedFrom.length; i++) {\n            v[i].unlockTime = _unlockedFrom[i];\n            v[i].amountUnlock = _unlockAmount[i];\n        }\n        LockStorageRecord storage lock = lockerStorage.push();\n        lock.ltype = LockType.ERC20;\n        lock.token = _ERC20;\n        lock.amount = _amount;\n        for (uint256 i = 0; i < _unlockedFrom.length; i++) {\n            lock.vestings.push(v[i]);\n        }\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n            RegistryShare[] storage shares = registry[_beneficiaries[i]];\n            shares.push(\n                RegistryShare({\n                    lockIndex: lockerStorage.length - 1,\n                    sharePercent: _beneficiariesShares[i],\n                    claimedAmount: 0\n                })\n            );\n            beneficiariesInLock[lockerStorage.length - 1].push(\n                _beneficiaries[i]\n            );\n        }\n        IERC20 token = IERC20(_ERC20);\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        emit NewLock(_ERC20, msg.sender, _amount, lockerStorage.length - 1);\n    }\n    function claimTokens(uint256 _lockIndex, uint256 _desiredAmount) external {\n        require(_lockIndex < lockerStorage.length, \"Lock record not saved yet\");\n        require(_desiredAmount > 0, \"Cant claim zero\");\n        LockStorageRecord memory lock = lockerStorage[_lockIndex];\n        (\n            uint256 percentShares,\n            uint256 wasClaimed\n        ) = _getUserSharePercentAndClaimedAmount(msg.sender, _lockIndex);\n        uint256 availableAmount = (_getAvailableAmountByLockIndex(_lockIndex) *\n            percentShares) /\n            TOTAL_IN_PERCENT -\n            wasClaimed;\n        require(_desiredAmount <= availableAmount, \"Insufficient for now\");\n        availableAmount = _desiredAmount;\n        _decreaseAvailableAmount(msg.sender, _lockIndex, availableAmount);\n        IERC20 token = IERC20(lock.token);\n        token.safeTransfer(msg.sender, availableAmount);\n    }\n    function getUserShares(address _user)\n        external\n        view\n        returns (RegistryShare[] memory)\n    {\n        return _getUsersShares(_user);\n    }\n    function getUserBalances(address _user, uint256 _lockIndex)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return _getUserBalances(_user, _lockIndex);\n    }\n    function getLockRecordByIndex(uint256 _index)\n        external\n        view\n        returns (LockStorageRecord memory)\n    {\n        return _getLockRecordByIndex(_index);\n    }\n    function getLockCount() external view returns (uint256) {\n        return lockerStorage.length;\n    }\n    function getArraySum(uint256[] memory _array)\n        external\n        pure\n        returns (uint256)\n    {\n        return _getArraySum(_array);\n    }\n    function _decreaseAvailableAmount(\n        address user,\n        uint256 _lockIndex,\n        uint256 _amount\n    ) internal {\n        RegistryShare[] storage shares = registry[user];\n        for (uint256 i = 0; i < shares.length; i++) {\n            if (shares[i].lockIndex == _lockIndex) {\n                shares[i].claimedAmount += _amount;\n                break;\n            }\n        }\n    }\n    function _getArraySum(uint256[] memory _array)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 res = 0;\n        for (uint256 i = 0; i < _array.length; i++) {\n            res += _array[i];\n        }\n        return res;\n    }\n    function _getAvailableAmountByLockIndex(uint256 _lockIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        VestingRecord[] memory v = lockerStorage[_lockIndex].vestings;\n        uint256 res = 0;\n        for (uint256 i = 0; i < v.length; i++) {\n            if (v[i].unlockTime <= block.timestamp && !v[i].isNFT) {\n                res += v[i].amountUnlock;\n            }\n        }\n        return res;\n    }\n    function _getUserSharePercentAndClaimedAmount(\n        address _user,\n        uint256 _lockIndex\n    ) internal view returns (uint256 percent, uint256 claimed) {\n        RegistryShare[] memory shares = registry[_user];\n        for (uint256 i = 0; i < shares.length; i++) {\n            if (shares[i].lockIndex == _lockIndex) {\n                percent += shares[i].sharePercent;\n                claimed += shares[i].claimedAmount;\n            }\n        }\n        return (percent, claimed);\n    }\n    function _getUsersShares(address _user)\n        internal\n        view\n        returns (RegistryShare[] memory)\n    {\n        return registry[_user];\n    }\n    function _getUserBalances(address _user, uint256 _lockIndex)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        (\n            uint256 percentShares,\n            uint256 wasClaimed\n        ) = _getUserSharePercentAndClaimedAmount(_user, _lockIndex);\n        uint256 totalBalance = (lockerStorage[_lockIndex].amount *\n            percentShares) /\n            TOTAL_IN_PERCENT -\n            wasClaimed;\n        uint256 available = (_getAvailableAmountByLockIndex(_lockIndex) *\n            percentShares) /\n            TOTAL_IN_PERCENT -\n            wasClaimed;\n        return (totalBalance, available);\n    }\n    function _getVestingsByLockIndex(uint256 _index)\n        internal\n        view\n        returns (VestingRecord[] memory)\n    {\n        VestingRecord[] memory v = _getLockRecordByIndex(_index).vestings;\n        return v;\n    }\n    function _getLockRecordByIndex(uint256 _index)\n        internal\n        view\n        returns (LockStorageRecord memory)\n    {\n        return lockerStorage[_index];\n    }\n}\n"
    }
  }
}