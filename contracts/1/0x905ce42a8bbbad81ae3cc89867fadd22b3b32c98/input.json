{"language":"Solidity","settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":20000},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/WNS.sol":{"content":"pragma solidity 0.7.5;\n\n/**\n* @dev Worldwide OpenBazaar Resource Finder Naming Service(WorfNS)\n* A simple naming service to register handles on FCFS basis\n*/\ncontract WNS {\n\n    event NewHandle(string handle, bytes data, address indexed owner);\n\n    event NewDisplayName(string handle, string displayName);\n\n    event NewImageLocation(string handle, string imageLocation);\n\n    event NewPeerId(string handle, bytes data);\n\n    event OwnershipTransferred(string handle, address indexed newOwner);\n\n    event HandleRemoved(string handle);\n\n    struct Handle{\n        address handleOwner;//Owner of the handle\n        string handleName;//This should be unqiue in nature\n        string displayName;//Need not to be unqiue\n        string imageLocation;//Can be an URI or IPNS address\n        bytes data;//extra data\n    }\n\n    //Unique handle hash versus Handle\n    mapping(bytes32=>Handle) handleNameHashVsHandle;\n\n    //addresses who are allowed to handles on other user's behalf\n    mapping(address=>bool) public superUsers;\n\n    modifier onlyHandleOwner(string memory handle){\n        require(\n            handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].handleOwner == msg.sender,\n            \"Unauthorized access to Handle\"\n        );\n        _;\n    }\n\n    modifier handleExists(string memory handle){\n        require(\n            handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].handleOwner != address(0),\n            \"Handle does not exists\"\n        );\n        _;\n    }\n\n    modifier handleAvailable(string memory handle){\n        require(\n            handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].handleOwner == address(0),\n            \"Handle is already taken\"\n        );\n        _;\n    }\n\n    modifier nonZeroAddress(address _address){\n        require(_address != address(0), \"0 address sent\");\n        _;\n    }\n\n    modifier onlySuperUser(){\n        require(superUsers[msg.sender], \"Not a super user\");\n        _;\n    }\n\n    constructor(address[] memory _superUsers)public {\n\n        for(uint i = 0;i<_superUsers.length;i++){\n\n            superUsers[_superUsers[i]] = true;\n\n        }\n    }\n\n    /**\n    * @dev Allows super user to add handle on other user's behalf\n    * @param owner The address of the owner\n    * @param handle Unique Handle\n    * @param _displayName Display name of the entity\n    * @param _imageLocation URI or IPNS of the image\n    * @param _data Extra data\n    */\n    function addHandle(\n        address owner,\n        string calldata handle,\n        string calldata _displayName,\n        string calldata _imageLocation,\n        bytes calldata _data\n    )\n        external\n        onlySuperUser\n        nonZeroAddress(owner)\n    {\n\n        _createHandle(\n            owner,\n            handle,\n            _displayName,\n            _imageLocation,\n            _data\n        );\n    }\n\n    /**\n    * @dev Method to create new handle\n    * @param handle Unique Handle\n    * @param _displayName Display name of the entity\n    * @param _imageLocation URI or IPNS of the image\n    * @param _data Extra data\n    */\n    function createHandle(\n        string calldata handle,\n        string calldata _displayName,\n        string calldata _imageLocation,\n        bytes calldata _data\n    )\n        external\n    {\n\n        _createHandle(\n            msg.sender,\n            handle,\n            _displayName,\n            _imageLocation,\n            _data\n        );\n       \n    }\n\n    //helper method to add/create new handle in the contract\n    function _createHandle(\n        address owner,\n        string memory handle,\n        string memory _displayName,\n        string memory _imageLocation,\n        bytes memory data\n    )\n        private\n        handleAvailable(handle)\n    {\n\n        require(bytes(handle).length>0, \"Empty handle name provided\");\n\n        bytes32 handleHash = keccak256(abi.encodePacked(handle));\n\n        handleNameHashVsHandle[handleHash] = Handle({\n            handleOwner:owner,\n            handleName:handle,\n            displayName:_displayName,\n            imageLocation:_imageLocation,\n            data:data\n        });\n\n        emit NewHandle(handle, data, owner);\n    }\n\n    /**\n    * @dev Transfer handle ownership to new address\n    * @param handle Handle whose ownership has to be changed\n    * @param newOwner Address of the new owner\n    */\n    function transferOwnership(\n        string calldata handle,\n        address newOwner\n    )\n        external\n        handleExists(handle)\n        onlyHandleOwner(handle)\n        nonZeroAddress(newOwner)\n    {\n\n        bytes32 handleHash = keccak256(abi.encodePacked(handle));\n\n        require(\n            newOwner != handleNameHashVsHandle[handleHash].handleOwner,\n            \"New owner is same as previous owner\"\n        );\n\n        handleNameHashVsHandle[handleHash].handleOwner = newOwner;\n\n        emit OwnershipTransferred(handle, newOwner);\n\n    }\n\n    /**\n    * @dev Method to change display name of the entity\n    * @param handle Handle whose display name has to be changed\n    * @param newName New Display Name\n    */\n    function changeDisplayName(\n        string calldata handle,\n        string calldata newName\n    )\n        external\n        handleExists(handle)\n        onlyHandleOwner(handle)\n    {\n\n        require(bytes(newName).length>0, \"Empyt names not allowed\");\n\n        handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].displayName = newName;\n\n        emit NewDisplayName(handle, newName);\n    }\n\n    /**\n    * @dev Method to change Location of Image\n    * @param handle Handle whose image location has to be changed\n    * @param newImageLocation New Image Location\n    */\n    function changeImageLocation(\n        string calldata handle,\n        string calldata newImageLocation\n    )\n        external\n        handleExists(handle)\n        onlyHandleOwner(handle)\n    {\n\n        handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].imageLocation = newImageLocation;\n\n        emit NewImageLocation(handle, newImageLocation);\n    }\n\n    /**\n    * @dev Method to extra data\n    * @param handle Handle whose extra data has to be changed\n    * @param data change extra data\n    */\n    function changePeerId(\n        string calldata handle,\n        bytes calldata data\n    )\n        external\n        handleExists(handle)\n        onlyHandleOwner(handle)\n    {\n\n        handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].data = data;\n\n        emit NewPeerId(handle, data);\n    }\n\n    /**\n    * @dev Method to get handle info about specific handle\n    * @param handleName The handle whose info has to be fetched\n    */\n    function getHandleInfo(\n        string calldata handleName\n    )\n        external\n        view\n        returns(\n            address owner,\n            string memory handle,\n            string memory displayName,\n            string memory imageLocation,\n            bytes memory data\n        )\n    {\n\n        bytes32 handleBytes = keccak256(abi.encodePacked(handleName));\n\n        owner = handleNameHashVsHandle[handleBytes].handleOwner;\n        handle = handleNameHashVsHandle[handleBytes].handleName;\n        displayName = handleNameHashVsHandle[handleBytes].displayName;\n        imageLocation = handleNameHashVsHandle[handleBytes].imageLocation;\n        data = handleNameHashVsHandle[handleBytes].data;\n    }\n\n    /**\n    * @dev Method to check availability of the handle\n    * @param handle Handle whose availability has to be checked\n    */\n    function isHandleAvailable(string calldata handle)external view returns(bool){\n        \n        return handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].handleOwner == address(0);\n    }\n    \n    /** \n    * @dev Method to remove handleS\n    * @param handle Handle to be removed\n    */\n    function removeHandle(\n        string calldata handle\n    )\n        external\n        handleExists(handle)\n        onlyHandleOwner(handle)\n    {\n        \n        delete handleNameHashVsHandle[keccak256(abi.encodePacked(handle))];        \n        emit HandleRemoved(handle);\n    }\n}"}}}