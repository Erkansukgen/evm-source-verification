{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "LiquidQueue/LiquidQueue.sol": {
      "content": "// File: contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n// File: contracts/openzeppelin/Ownable.sol\n\n// : MIT\npragma solidity ^0.7.6;\n\n\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    \n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n// File: contracts/openzeppelin/IERC20.sol\n\n// : MIT\npragma solidity ^0.7.6;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function decimals() external returns (uint8);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// File: contracts/facades/RewardLike.sol\n\n// : MIT\npragma solidity ^0.7.6;\n\nabstract contract RewardLike {\n    function requestReward(address token, uint256 value) public virtual;\n\n    function requestSlowQueueReward(address token, uint256 value)\n        public\n        virtual\n        returns (bool);\n}\n\n// File: contracts/phase1/LiquidQueue.sol\n\n// : MIT\npragma solidity ^0.7.6;\n\n\n\n\n\n/*\nRULES:\n1. A queue that has been stagnant for a set period of time starts rewarding EYE per queue place. Will use Nimrodel logic for this\n2. We measure queue velocity by taking a moving average. If it exceeds a threshold, new LP entrants are burnt. The burn increases for each entrant under which it exceeds the threshold\n3. The queue is fixed in length but can be resized by admin. This is likely just a temporary measure. \n*/\ncontract LiquidQueue is Ownable {\n    address public mintingModule;\n    bool public paused; // only for alpha queue.\n    event queued(address indexed lp, uint256 amount, address holder);\n    event popped(address indexed lp, uint256 amount, address holder);\n    RewardLike rewardContract;\n\n    modifier onlyMintingModule {\n        require(\n            msg.sender == mintingModule,\n            \"LIQUID QUEUE: restricted function\"\n        );\n        _;\n    }\n\n    modifier mustBeUnpaused {\n        require(!paused, \"LIQUID QUEUE: currently paused\");\n        _;\n    }\n\n    modifier mustBePaused {\n        require(paused, \"LIQUID QUEUE: currently unpaused\");\n        _;\n    }\n\n    struct Batch {\n        address recipient;\n        address LP;\n        uint256 amount;\n        uint256 joinTimeStamp;\n        uint256 durationSinceLast;\n        uint256 eyeHeightAtJoin;\n    }\n\n    struct QueueState {\n        uint256 velocity; //joins per week\n        uint256 burnRatio;\n        uint256 eyeHeight;\n        bool eyeActive;\n        uint256 criticalVelocityStart;\n        uint256 lastIndex; //old batches pop off the queue from here\n        uint256 entryIndex; //new batches go here\n        Batch[] queue;\n        uint256 eyeStagnantDuration;\n    }\n\n    struct QueueConfig {\n        uint24 targetVelocity;\n        uint8 size;\n        address eye;\n        uint256 stagnationRewardTimeout;\n        uint256 eyeReward;\n        bool LPburnDisabled; // if behodler's listing of LPs is enough incentive to not unwind then no need for LP burning\n    }\n\n    QueueConfig queueConfig;\n    QueueState queueState;\n\n    constructor() {\n        queueState.eyeActive = true;\n        queueConfig.LPburnDisabled = true;\n    }\n\n    function setReward(address r) public onlyOwner {\n        rewardContract = RewardLike(r);\n    }\n\n    function pause() public onlyOwner {\n        paused = true;\n    }\n\n    function unpause() public onlyOwner {\n        paused = false;\n    }\n\n    function setMintingModule(address m) public onlyOwner {\n        mintingModule = m;\n    }\n\n    function configure(\n        uint24 targetVelocity,\n        uint8 size,\n        address eye,\n        uint256 stagnationRewardTimeout,\n        uint256 eyeReward,\n        bool LPburnDisabled\n    ) public onlyOwner {\n        require(\n            size >= queueState.queue.length,\n            \"LIQUID QUEUE: pop queue to resize.\"\n        );\n        queueConfig.size = size;\n        queueConfig.targetVelocity = targetVelocity;\n        if (queueConfig.eye != address(0)) {\n            require(\n                (queueConfig.eye == eye && queueState.queue.length == 0) ||\n                    paused,\n                \"LIQUID QUEUE: Eye address currently locked\"\n            );\n            uint256 durationSinceLast =\n                queueState.queue.length > 0\n                    ? block.timestamp -\n                        queueState.queue[queueState.entryIndex].joinTimeStamp\n                    : 0;\n            queueState.eyeHeight += durationSinceLast * queueConfig.eyeReward;\n        }\n        queueConfig.eye = eye;\n        queueConfig.stagnationRewardTimeout = stagnationRewardTimeout;\n        queueConfig.eyeReward = eyeReward;\n        queueConfig.LPburnDisabled = LPburnDisabled;\n    }\n\n    //take reward, advance queue structure, pop out end of queue. External users must enter through MintingModule.purchaseLP\n    function join(address LP, address recipient)\n        public\n        onlyMintingModule\n        mustBeUnpaused\n    {\n        //pull in the minted LP from the minting module\n        IUniswapV2Pair pair = IUniswapV2Pair(LP);\n        uint256 balance = pair.balanceOf(mintingModule);\n        pair.transferFrom(mintingModule, address(this), balance);\n\n        //calculate current velocity. If it is high, turn off LP burn.\n        uint256 newEntryTimeStamp = block.timestamp;\n        uint256 durationSinceLast = 0;\n        if (queueState.queue.length > 0) {\n            durationSinceLast =\n                newEntryTimeStamp -\n                queueState.queue[queueState.entryIndex].joinTimeStamp;\n            queueState.velocity +=\n                ((1 weeks) / (durationSinceLast + 1)) /\n                queueConfig.size;\n            if (queueState.queue.length == queueConfig.size) {\n                uint256 leavingVelocity =\n                    ((1 weeks) /\n                        (queueState.queue[queueState.lastIndex]\n                            .durationSinceLast + 1)) / queueConfig.size;\n                uint256 existingVelocity = queueState.velocity;\n                queueState.velocity = existingVelocity < leavingVelocity\n                    ? 0 //avoid underflow\n                    : existingVelocity - leavingVelocity;\n            }\n\n            //set LP burn ratio for next preson to leave\n            if (\n                !queueConfig.LPburnDisabled &&\n                queueState.velocity > queueConfig.targetVelocity &&\n                queueState.queue.length == queueConfig.size\n            ) {\n                queueState.burnRatio = queueState.burnRatio < 49\n                    ? queueState.burnRatio + 1\n                    : 49;\n            } else {\n                queueState.burnRatio = 0;\n            }\n        }\n\n        //if eye rewards are active but velocity picks up, disable eye rewards\n        if (queueState.eyeActive) {\n            queueState.eyeHeight += durationSinceLast * queueConfig.eyeReward;\n            if (queueState.velocity > queueConfig.targetVelocity) {\n                queueState.eyeActive = false;\n                queueState.criticalVelocityStart = 0;\n            }\n        }\n\n        //if velocity falls below target, after timeout set eye rewards to active\n        if (\n            queueState.velocity < queueConfig.targetVelocity &&\n            !queueState.eyeActive &&\n            queueState.queue.length > 0\n        ) {\n            if (queueState.criticalVelocityStart == 0)\n                queueState.criticalVelocityStart = block.timestamp;\n            else if (\n                block.timestamp - queueState.criticalVelocityStart >\n                queueConfig.stagnationRewardTimeout\n            ) {\n                queueState.eyeActive = true;\n            }\n        }\n\n        if (queueState.queue.length == queueConfig.size) {\n            Batch memory leaver = queueState.queue[queueState.lastIndex];\n            payLeaver(leaver);\n        }\n\n        Batch memory joiner =\n            Batch({\n                recipient: recipient,\n                LP: LP,\n                amount: balance - ((balance * queueState.burnRatio) / 100),\n                joinTimeStamp: block.timestamp,\n                durationSinceLast: queueState.queue.length == 0\n                    ? (1 weeks)\n                    : durationSinceLast,\n                eyeHeightAtJoin: queueState.eyeHeight\n            });\n\n        emit queued(joiner.LP, joiner.amount, joiner.recipient);\n        if (queueState.queue.length < queueConfig.size) {\n            queueState.queue.push(joiner);\n            queueState.entryIndex = queueState.queue.length - 1;\n        } else {\n            queueState.entryIndex = circleIncrement(\n                queueState.entryIndex,\n                queueConfig.size\n            );\n            queueState.lastIndex = circleIncrement(\n                queueState.lastIndex,\n                queueConfig.size\n            );\n            queueState.queue[queueState.entryIndex] = joiner;\n        }\n    }\n\n    //Only use this if you're planning on destroying or resetting the queue entirely\n    //Note: to save gas, pop removes the latest batch in the queue, not the oldest batch\n    function pop() public onlyOwner mustBePaused {\n        payLeaver(queueState.queue[queueState.entryIndex]);\n        queueState.queue.pop();\n        uint256 newLength = queueState.queue.length;\n        queueState.entryIndex = queueState.entryIndex % newLength;\n        queueState.lastIndex = queueState.lastIndex % newLength;\n    }\n\n    //Only in BETA\n    function removeLP(address lp) public onlyOwner mustBePaused {\n        uint256 balance = IERC20(lp).balanceOf(address(this));\n        IERC20(lp).transfer(msg.sender, balance);\n    }\n\n    function getQueueData()\n        public\n        view\n        returns (\n            uint256 length,\n            uint256 last,\n            uint256 entryIndex,\n            uint256 velocity,\n            uint256 burnRatio,\n            bool eyeActive,\n            uint256 eyeReward,\n            uint256 eyeHeight\n        )\n    {\n        return (\n            queueState.queue.length,\n            queueState.lastIndex,\n            queueState.entryIndex,\n            queueState.velocity,\n            queueState.burnRatio,\n            queueState.eyeActive,\n            queueConfig.eyeReward,\n            queueState.eyeHeight\n        );\n    }\n\n    function getBatch(uint256 index)\n        external\n        view\n        returns (\n            address recipient,\n            address LP,\n            uint256 amount,\n            uint256 joinTimeStamp,\n            uint256 durationSinceLast,\n            uint256 eyeHeightAtJoin,\n            bool validIndex\n        )\n    {\n        Batch memory batch;\n        if (queueState.queue.length > index) {\n            batch = queueState.queue[index];\n            recipient = batch.recipient;\n            LP = batch.LP;\n            amount = batch.amount;\n            joinTimeStamp = batch.joinTimeStamp;\n            durationSinceLast = batch.durationSinceLast;\n            eyeHeightAtJoin = batch.eyeHeightAtJoin;\n            validIndex = true;\n        }\n    }\n\n    function payLeaver(Batch memory leaver) internal {\n        IERC20(leaver.LP).transfer(leaver.recipient, leaver.amount);\n        uint256 eyeReward = (queueState.eyeHeight - leaver.eyeHeightAtJoin); //no need for overflow check. eyeHeightAtJoin can't be greater than eyeHeight\n        if (eyeReward > 0) {\n            //don't fail if unable to pay staking reward.\n            if (\n                rewardContract.requestSlowQueueReward(\n                    queueConfig.eye,\n                    eyeReward\n                )\n            ) IERC20(queueConfig.eye).transfer(leaver.recipient, eyeReward);\n        }\n        emit popped(leaver.LP, leaver.amount, leaver.recipient);\n    }\n\n    function circleIncrement(uint256 value, uint256 max)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (value + 1) % max;\n    }\n}\n"
    }
  }
}