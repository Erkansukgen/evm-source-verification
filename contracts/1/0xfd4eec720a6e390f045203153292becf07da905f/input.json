{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"FlashAMM.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, 'SafeMath: addition overflow');\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, 'SafeMath: subtraction overflow');\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, 'SafeMath: multiplication overflow');\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, 'SafeMath: division by zero');\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, 'SafeMath: modulo by zero');\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IUniswapV3Pool{\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n    \n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n\ninterface IWeth is IERC20 {\n    function deposit() external payable;\n}\n\ninterface IWstEth is IERC20{\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n    function stETH() external view returns (IERC20);\n}\n\ninterface ICurvePool {\n\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256); \n    // i = 1 to send, j = 0 to receive, \n}\n\ncontract FlashAMM {\n    using SafeMath for uint256;\n    using SafeCast for uint256;\n    address public owner;\n    IWstEth public wsteth = IWstEth(address(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0));\n    IWeth public weth = IWeth(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    ICurvePool public curvePool = ICurvePool(address(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022));\n    IUniswapV3Pool public uniPool = IUniswapV3Pool(address(0xD340B57AAcDD10F96FC1CF10e15921936F41E29c));\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n\n    constructor () public {\n        owner = msg.sender;\n        wsteth.stETH().approve(address(curvePool), uint256(-1));\n    }\n\n    receive () payable external {\n\n    }\n\n    fallback () payable external {\n\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata _data\n    ) external {\n        (uint256 uniAmountOut) = abi.decode(_data, (uint256));\n        require(wsteth.balanceOf(address(this)) >= uniAmountOut, \"Not enough transferred\");\n        require(IERC20(uniPool.token1()).transfer(address(uniPool), uint256(amount1Delta)), \"Error: transferring amountIn\");\n    }\n    \n    // 0 => WstETH 1 => WETH\n    // zeroForOne => \n    \n    function uniswapV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external {\n        (uint256 amountIn, uint256 uniAmountOut) = abi.decode(data, (uint256, uint256));\n        bool zeroForOne = false;\n\n        uniPool.swap(\n            address(this), \n            zeroForOne,\n            amountIn.toInt256(),\n            zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n            abi.encode(uniAmountOut)\n        );\n        \n        // unwraps wsteth\n        uint256 stethBalance = wsteth.unwrap(wsteth.balanceOf(address(this)));\n        // get amountOut for steth on curve\n        uint256 amountOut = curvePool.get_dy(1, 0, stethBalance);\n        // swap steth for eth on curve\n        curvePool.exchange(1, 0, stethBalance, amountOut);\n\n        uint256 amountOwing = amountIn.add(fee1);\n        weth.deposit{value: amountOwing}();\n        require(IERC20(uniPool.token1()).transfer(msg.sender, amountOwing),\"Error: Transferring fees back\");\n\n        payable(owner).transfer(address(this).balance);\n        \n    }\n    \n    function flashLoanFor(uint256 amount, uint256 uniAmountOut) external {\n        require(msg.sender == owner, \"!owner\");\n        bytes memory params = abi.encode(amount,uniAmountOut);\n        IUniswapV3Pool(address(0x8ad599c3A0ff1De082011EFDDc58f1908eb6e6D8)).flash(address(this), 0, amount, params);\n    }\n}"}}}