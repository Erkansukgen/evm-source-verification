{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/eatsuperpie/eatsuperpie.sol":{"content":"pragma solidity ^0.7.0;\n\nimport \"./interface/IToken.sol\";\nimport \"./interface/IEntrance.sol\";\nimport \"./interface/IBalancer.sol\";\nimport \"./interface/IWETH.sol\";\nimport \"./interface/IPie.sol\";\nimport \"./interface/IFreeFromUpTo.sol\";\n\ncontract EatSuperPie {\n    constructor() payable {\n        _trader[msg.sender] = true;\n        _owner = msg.sender;\n    }\n    \n    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n    mapping (address => bool) private _trader;\n    address payable _owner;\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    IWETH wethContract = IWETH(weth);\n    IEntrance entrance = IEntrance(0xca9aF520706A57CeCDE6f596852eaBb5a0e6bB0E);\n    uint256 maxPrice = 1000000000000000000000000000;\n    \n    modifier discountCHI {\n        uint256 gasStart = gasleft();\n        _;\n        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n        chi.freeFromUpTo(address(this), (gasSpent + 14154) / 41130);\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"onlyOwner: msg.sender not owner\");\n        _;\n    }\n    \n    modifier onlyTrader() {\n        require(_trader[msg.sender], \"onlyTrader: msg.sender not trader\");\n        _;\n    }\n\n    function setTrader(address newTrader) public onlyOwner {\n        _trader[newTrader] = true;\n    }\n    \n    receive() external payable {}\n    \n    function approve(address[] calldata tokens, address spender, uint256 amount) public onlyOwner {\n        for(uint256 i = 0; i < tokens.length; i++) {\n            IToken ercToken = IToken(tokens[i]);\n            ercToken.approve(spender, amount);\n        }\n    }\n\n    function transfer(address token, address spender, uint256 amount) public onlyOwner {\n        IToken ercToken = IToken(token);\n        ercToken.transfer(spender, amount);\n    }\n\n    function withdrawETH() public onlyOwner {\n        if(address(this).balance != 0) {\n            _owner.transfer(address(this).balance);\n        }\n    }\n\n    function sellOnBalancerBasic(\n        address _balancer,\n        address _pie,\n        uint256 _pieAmount\n    ) public onlyTrader {\n        IBalancer balancer = IBalancer(_balancer);\n        uint256 ethIn = entrance.calcToPie(_pie, _pieAmount);\n        uint256 ethOut = balancer.calcOutGivenIn(\n            balancer.getBalance(_pie),\n            balancer.getNormalizedWeight(_pie),\n            balancer.getBalance(weth),\n            balancer.getNormalizedWeight(weth),\n            _pieAmount,\n            balancer.getSwapFee()\n        );\n        if (ethIn > ethOut) {\n            return;\n        }\n\n        uint256 wethBefore = wethContract.balanceOf(address(this));\n        // 加5%的eth保证滑点要求\n        wethContract.withdraw(ethIn * 105 / 100);\n        entrance.toPie{value: address(this).balance}(_pie, _pieAmount);\n        IToken pieToken = IToken(_pie);\n        uint256 pieAmount = pieToken.balanceOf(address(this));\n        balancer.swapExactAmountIn(_pie, pieAmount, weth, ethIn, maxPrice);\n\n        require(wethContract.balanceOf(address(this)) >= wethBefore, \"limit out\");\n    }\n\n    function buyFromBalancerBasic(\n        address _balancer,\n        address _pie,\n        uint256 _pieAmount\n    ) public onlyTrader {\n        IBalancer balancer = IBalancer(_balancer); \n        uint256 ethIn = balancer.calcInGivenOut(\n            balancer.getBalance(weth),\n            balancer.getNormalizedWeight(weth),\n            balancer.getBalance(_pie),\n            balancer.getNormalizedWeight(_pie),\n            _pieAmount,\n            balancer.getSwapFee()\n        );\n        uint256 ethOut = entrance.calcToEth(_pie, _pieAmount);\n        if (ethIn > ethOut) {\n            return;\n        }\n\n        uint256 wethBefore = wethContract.balanceOf(address(this));\n        balancer.swapExactAmountOut(weth, ethIn, _pie, _pieAmount, maxPrice);\n        IToken pieToken = IToken(_pie);\n        uint256 pieAmount = pieToken.balanceOf(address(this));\n        entrance.toEth(_pie, pieAmount, ethIn);\n        wethContract.deposit{value: address(this).balance}(); \n        require(wethContract.balanceOf(address(this)) >= wethBefore, \"limit out\");\n    }\n    \n    struct localvars {\n        IPie piepp;\n        address[] tokens;\n        uint256[] amounts;\n        uint256 ethIn;\n        uint256 ethOut;\n        uint256[] ethIns;\n        uint256[] ethOuts;\n    }\n\n    // 其中 method 为 0 时走 entrance, 为 1 时走 balancer, 数组顺序是 0 为 defiL，1 为 defiS.\n    function sellOnBalancerPlus(\n        address _pieppbalancer,\n        address _piepp,\n        uint256 _pieppAmount,\n        address[] calldata _piebalancer,\n        uint16[] calldata _methods\n    ) public onlyTrader {\n        localvars memory lv;\n        lv.piepp = IPie(_piepp);\n        (lv.tokens, lv.amounts) = lv.piepp.calcTokensForAmount(_pieppAmount);\n        lv.ethIns = new uint256[](2);\n        for (uint i = 0; i <= 1; i++) {\n            if (_methods[i] == 0) {\n                lv.ethIns[i] += entrance.calcToPie(lv.tokens[i], lv.amounts[i]);\n            } else {\n                IBalancer piebalancer = IBalancer(_piebalancer[i]);\n                lv.ethIns[i] = piebalancer.calcInGivenOut(\n                    piebalancer.getBalance(weth),\n                    piebalancer.getNormalizedWeight(weth),\n                    piebalancer.getBalance(lv.tokens[i]),\n                    piebalancer.getNormalizedWeight(lv.tokens[i]),\n                    lv.amounts[i],\n                    piebalancer.getSwapFee()\n                );\n            }\n        }\n        IBalancer pieppBalancer = IBalancer(_pieppbalancer);\n        lv.ethOut = pieppBalancer.calcOutGivenIn(\n            pieppBalancer.getBalance(_piepp),\n            pieppBalancer.getNormalizedWeight(_piepp),\n            pieppBalancer.getBalance(weth),\n            pieppBalancer.getNormalizedWeight(weth),\n            _pieppAmount,\n            pieppBalancer.getSwapFee()\n        );\n        if (lv.ethIns[0] + lv.ethIns[1] > lv.ethOut) {\n            return;\n        }\n\n        uint256 wethBefore = wethContract.balanceOf(address(this)); \n        for (uint i = 0; i <= 1; i++) {\n            if (_methods[i] == 0) {\n                entrance.toPie(lv.tokens[i], lv.amounts[i]);\n            } else {\n               IBalancer piebalancer = IBalancer(_piebalancer[i]);\n               piebalancer.swapExactAmountOut(\n                    weth,\n                    lv.ethIns[i],\n                    lv.tokens[i],\n                    lv.amounts[i],\n                    maxPrice\n               );\n            }\n        }\n        lv.piepp.joinPool(_pieppAmount);\n        pieppBalancer.swapExactAmountIn(\n            _piepp,\n            lv.piepp.balanceOf(address(this)),\n            weth,\n            lv.ethIns[0] + lv.ethIns[1],\n            maxPrice\n        );\n        require(wethContract.balanceOf(address(this)) >= wethBefore, \"limit out\");\n    }\n\n    // 其中 method 为 0 时走 entrance, 为 1 时走 balancer, 数组顺序是 0 为 defiL，1 为 defiS.\n    function buyFromBalancerPlus(\n        address _pieppbalancer,\n        address _piepp,\n        uint256 _pieppAmount,\n        address[] calldata _piebalancer,\n        uint16[] calldata _methods\n    ) public onlyTrader {\n        localvars memory lv;\n        lv.piepp = IPie(_piepp);\n        (lv.tokens, lv.amounts) = lv.piepp.calcTokensForAmount(_pieppAmount); \n        IBalancer pieppBalancer = IBalancer(_pieppbalancer);\n        lv.ethIn = pieppBalancer.calcInGivenOut(\n            pieppBalancer.getBalance(weth),\n            pieppBalancer.getNormalizedWeight(weth),\n            pieppBalancer.getBalance(_piepp),\n            pieppBalancer.getNormalizedWeight(_piepp),\n            _pieppAmount,\n            pieppBalancer.getSwapFee()\n        );\n        lv.ethOuts = new uint256[](2);\n        for (uint i = 0; i <= 1; i++) {\n            if (_methods[i] == 0) {\n                lv.ethOuts[i] += entrance.calcToEth(lv.tokens[i], lv.amounts[i]);\n            } else {\n                IBalancer piebalancer = IBalancer(_piebalancer[i]);\n                lv.ethOuts[i] = piebalancer.calcOutGivenIn(\n                    piebalancer.getBalance(lv.tokens[i]),\n                    piebalancer.getNormalizedWeight(lv.tokens[i]),\n                    piebalancer.getBalance(weth),\n                    piebalancer.getNormalizedWeight(weth),\n                    lv.amounts[i],\n                    piebalancer.getSwapFee()\n                );\n            }\n        }\n        if (lv.ethIn > lv.ethOuts[0] + lv.ethOuts[1]) {\n            return;\n        }\n\n        uint256 wethBefore = wethContract.balanceOf(address(this)); \n        pieppBalancer.swapExactAmountOut(\n            weth,\n            lv.ethIn,\n            _piepp,\n            _pieppAmount,\n            maxPrice\n        );\n        lv.piepp.exitPool(lv.piepp.balanceOf(address(this)));\n        for (uint i = 0; i <= 1; i++) {\n            if (_methods[i] == 0) {\n                entrance.toEth(lv.tokens[i], lv.amounts[i], lv.ethOuts[i]);\n            } else {\n               IBalancer piebalancer = IBalancer(_piebalancer[i]);\n               piebalancer.swapExactAmountIn(\n                    lv.tokens[i],\n                    lv.amounts[i],\n                    weth,\n                    lv.ethOuts[i],\n                    maxPrice\n               );\n            }\n        }\n        wethContract.deposit{value: address(this).balance}();\n        require(wethContract.balanceOf(address(this)) >= wethBefore, \"limit out\");\n    }\n    \n    function sd() public onlyOwner {\n        selfdestruct(_owner);\n    }\n}"},"localhost/eatsuperpie/interface/IBalancer.sol":{"content":"pragma solidity ^0.7.0;\n\ninterface IBalancer {\n    function swapExactAmountIn(\n        address tokenIn,\n        uint tokenAmountIn,\n        address tokenOut,\n        uint minAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountOut, uint spotPriceAfter);\n\n    function getNormalizedWeight(address token) external view returns (uint);\n\n    function getBalance(address token) external view returns (uint);\n\n    function getSwapFee() external view returns (uint);\n\n    function calcOutGivenIn(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountIn,\n        uint swapFee\n    ) external pure returns (uint tokenAmountOut);\n\n    function calcInGivenOut(\n        uint tokenBalanceIn,\n        uint tokenWeightIn,\n        uint tokenBalanceOut,\n        uint tokenWeightOut,\n        uint tokenAmountOut,\n        uint swapFee\n    ) external pure returns (uint tokenAmountIn);\n    \n    function swapExactAmountOut(\n        address tokenIn,\n        uint maxAmountIn,\n        address tokenOut,\n        uint tokenAmountOut,\n        uint maxPrice\n    ) external returns (uint tokenAmountIn, uint spotPriceAfter);\n}"},"localhost/eatsuperpie/interface/IEntrance.sol":{"content":"pragma solidity ^0.7.0;\n\ninterface IEntrance {\n    function toEth(address _pie, uint256 _poolAmount, uint256 _minEthAmount) external;\n    function toPie(address _pie, uint256 _poolAmount) external payable;\n    function calcToEth(address _pie, uint256 _poolAmountOut) external view returns(uint256);\n    function calcToPie(address _pie, uint256 _poolAmount) external view returns(uint256);\n}"},"localhost/eatsuperpie/interface/IFreeFromUpTo.sol":{"content":"pragma solidity ^0.7.0;\n\ninterface IFreeFromUpTo {\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n}"},"localhost/eatsuperpie/interface/IPie.sol":{"content":"pragma solidity ^0.7.0;\n\ninterface IPie {\n    function joinPool(uint256 _amount) external;\n    function exitPool(uint256 _amount) external;\n    function getTokens() external view returns(address[] memory);\n    function calcTokensForAmount(uint256 _amount) external view  returns(address[] memory tokens, uint256[] memory amounts);\n    function balanceOf(address account) external view returns (uint256);\n}"},"localhost/eatsuperpie/interface/IToken.sol":{"content":"pragma solidity ^0.7.0;\n\ninterface IToken {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}"},"localhost/eatsuperpie/interface/IWETH.sol":{"content":"pragma solidity ^0.7.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n    function balanceOf(address account) external view returns (uint256);\n}"}}}