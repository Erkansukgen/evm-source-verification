{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "browser/BehodlerLike.sol": {
      "content": "pragma solidity ^0.6.1;\n\n\nabstract contract BehodlerLike {\n    function tokenScarcityObligations(address token) public virtual returns (uint);\n\n    function buyScarcityDelegate(\n        address sender,\n        address tokenAddress,\n        uint256 value,\n        uint256 minPrice\n    ) external virtual returns (uint256);\n\n    function sellScarcityDelegate(\n        address sender,\n        address tokenAddress,\n        uint256 value,\n        uint256 maxPrice\n    ) external virtual returns (uint256);\n}\n"
    },
    "browser/ERC20Like.sol": {
      "content": "pragma solidity ^0.6.1;\n\nabstract contract ERC20Like\n{\n\tfunction totalSupply() external virtual view returns (uint256);\n\tfunction balanceOf(address account) external virtual view returns (uint256);\n\tfunction transfer(address recipient, uint256 amount) external virtual returns (bool);\n\tfunction allowance(address owner, address spender) external virtual view returns (uint256);\n\tfunction approve(address spender, uint256 amount) external virtual returns (bool);\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external virtual returns (bool);\n}"
    },
    "browser/Janus.sol": {
      "content": "pragma solidity ^0.6.1;\nimport \"./Secondary.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ERC20Like.sol\";\nimport \"./BehodlerLike.sol\";\nimport \"./WethLike.sol\";\n\n\n/*\n\tJanus will be used by the front end to execute a token to token swap without requiring the user know about scarcity.\n\tIf trading pair involves scarcity then only one arm of the Behodler need be invoked.\n\tIf either of the token is Eth, Janus first wraps (or unwraps) it before swapping the weth. Behodler doesn't deal in Eth.\n\tDevelopers building on top of Behodler trading functionality should treat Janus as their portal.\n */\n\ncontract Janus is Secondary {\n    BehodlerLike public behodler;\n    address public scarcityAddress;\n    WethLike public weth;\n    using SafeMath for uint256;\n    address self;\n\n    constructor() public {\n        self = address(this);\n    }\n\n    receive() external payable {}\n\n    function seed(\n        address scx,\n        address wet,\n        address beh\n    ) external onlyPrimary {\n        weth = WethLike(wet);\n        scarcityAddress = scx;\n        behodler = BehodlerLike(beh);\n    }\n\n    function addLiquidityTokens(\n        address sender,\n        address token1,\n        address token2,\n        uint256 v1,\n        uint256 v2\n    ) private returns (uint256 bought) {\n        bought = behodler.buyScarcityDelegate(sender, token1, v1, 0);\n        bought += behodler.buyScarcityDelegate(sender, token2, v2, 0);\n    }\n\n    function addLiquidityTokens(\n        address token1,\n        address token2,\n        uint256 v1,\n        uint256 v2\n    ) external returns (uint256 bought) {\n        bought = addLiquidityTokens(msg.sender, token1, token2, v1, v2);\n    }\n\n    //user must authorize weth for Janus\n    function addLiquidityTokenAndEth(address token, uint256 v1)\n        external\n        payable\n        returns (uint256 bought)\n    {\n        require(msg.value > 0, \"no eth sent\");\n        weth.deposit.value(msg.value)();\n        weth.transfer(msg.sender, msg.value);\n        bought = addLiquidityTokens(\n            msg.sender,\n            token,\n            address(weth),\n            msg.value,\n            v1\n        );\n    }\n\n    //user must authorize behodler to take input token\n    function tokenToToken(\n        address input,\n        address output,\n        uint256 value,\n        uint256 minPrice,\n        uint256 maxPrice\n    ) external returns (uint256 bought) {\n        return\n            tokenToToken(msg.sender, input, output, value, minPrice, maxPrice);\n    }\n\n    function tokenToToken(\n        address sender,\n        address input,\n        address output,\n        uint256 value,\n        uint256 minPrice,\n        uint256 maxPrice\n    ) private returns (uint256 bought) {\n        require(\n            input != output,\n            \"input token must be different to output token\"\n        );\n        if (input == scarcityAddress) {\n            bought = behodler.sellScarcityDelegate(\n                sender,\n                output,\n                value,\n                maxPrice\n            );\n        } else if (output == scarcityAddress) {\n            bought = behodler.buyScarcityDelegate(\n                sender,\n                input,\n                value,\n                minPrice\n            );\n        } else {\n            uint256 scx = behodler.buyScarcityDelegate(\n                sender,\n                input,\n                value,\n                minPrice\n            );\n            uint256 max = behodler.tokenScarcityObligations(output);\n            uint256 scxToSend = scx > max ? max : scx;\n            bought = behodler.sellScarcityDelegate(\n                sender,\n                output,\n                scxToSend,\n                maxPrice\n            );\n        }\n    }\n\n    function ethToToken(\n        address output,\n        uint256 minPrice,\n        uint256 maxPrice\n    ) external payable returns (uint256 bought) {\n        // user needs to enable eth for behodler\n        require(msg.value > 0, \"no eth sent\");\n        weth.deposit.value(msg.value)();\n        weth.transfer(msg.sender, msg.value);\n        bought = tokenToToken(\n            msg.sender,\n            address(weth),\n            output,\n            msg.value,\n            minPrice,\n            maxPrice\n        );\n    }\n\n    function tokenToEth(\n        address input,\n        uint256 value,\n        uint256 minPrice,\n        uint256 maxPrice\n    ) external returns (uint256 bought) {\n        //user must authorize weth for Janus\n        bought = tokenToToken(\n            msg.sender,\n            input,\n            address(weth),\n            value,\n            minPrice,\n            maxPrice\n        );\n        weth.transferFrom(msg.sender, self, bought);\n        weth.withdraw(bought);\n        (bool success, ) = msg.sender.call.value(bought)(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}\n"
    },
    "browser/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "browser/Secondary.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev A Secondary contract can only be used by its primary account (the one that created it).\n */\ncontract Secondary {\n    address private _primary;\n\n    /**\n     * @dev Emitted when the primary contract changes.\n     */\n    event PrimaryTransferred(\n        address recipient\n    );\n\n    /**\n     * @dev Sets the primary account to the one that is creating the Secondary contract.\n     */\n    constructor () internal {\n        _primary = msg.sender;\n        emit PrimaryTransferred(_primary);\n    }\n\n    /**\n     * @dev Reverts if called from any account other than the primary.\n     */\n    modifier onlyPrimary() {\n        require(msg.sender == _primary, \"Secondary: caller is not the primary account\");\n        _;\n    }\n\n    /**\n     * @return the address of the primary.\n     */\n    function primary() public view returns (address) {\n        return _primary;\n    }\n\n    /**\n     * @dev Transfers contract to a new primary.\n     * @param recipient The address of new primary.\n     */\n    function transferPrimary(address recipient) public onlyPrimary {\n        require(recipient != address(0), \"Secondary: new primary is the zero address\");\n        _primary = recipient;\n        emit PrimaryTransferred(_primary);\n    }\n}\n"
    },
    "browser/WethLike.sol": {
      "content": "pragma solidity ^0.6.1;\nimport \"./ERC20Like.sol\";\n\nabstract contract WethLike is ERC20Like\n{\n\tfunction deposit () external payable virtual;\n\tfunction withdraw(uint value) external virtual;\n}"
    }
  }
}