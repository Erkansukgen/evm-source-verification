{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/delance. sol": {
      "content": "pragma solidity ^0.6.0;\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\r\n*/\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint a, uint m) internal pure returns (uint256) {\r\n    return (a + m - 1) / m * m;\r\n  }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Not an owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"Invalid new owner address\");\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract Delance is Owned{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    struct User{\r\n        uint256 id;\r\n        address wallet;\r\n        Category category; \r\n    }\r\n    \r\n    struct Order{\r\n        uint256 payment;\r\n        uint256 lastUpdated;\r\n        address tokenAddress; // if its ether then token address is address(0)\r\n        address buyer;\r\n        address seller;\r\n        string description;\r\n        Status status;\r\n    }\r\n    \r\n    mapping(address => User) public users;\r\n    mapping(address => bool) public supportedTokens;\r\n    mapping(uint256 => Order) public orders;\r\n    \r\n    uint256 usersCount;\r\n    uint256 orderNo;\r\n    \r\n    enum Category{None, Buyer, Seller, Both}\r\n    enum Status{DoesNotExist, Initiated, Completed, Disputed}\r\n    \r\n    event Registered(address _wallet, Category _category, uint256 _identifier);\r\n    event NewOrder(uint256 _orderNo, address _buyer, address _seller, uint256 _amount, address _tokenAddress);\r\n    event NewOrder(uint256 _orderNo, address _buyer, address _seller, uint256 _amount);\r\n    event Completed(uint256 _orderNo);\r\n    event FundsReleased(uint256 _orderNo, address _to,uint256 amount);\r\n    event DelancePaymentReleased(uint256 orderNo, uint256 amount);\r\n    event DisputeOpened(uint256 _orderNo, address _by, string _message);\r\n    \r\n    constructor() public {\r\n        supportedTokens[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = true; //USDC\r\n        supportedTokens[0xdAC17F958D2ee523a2206206994597C13D831ec7] = true; //USDT\r\n        supportedTokens[0x4Fabb145d64652a948d72533023f6E7A623C7C53] = true; //BUSD\r\n        supportedTokens[0x6B175474E89094C44Da98b954EedeAC495271d0F] = true; //DAI\r\n    }\r\n    \r\n    receive() external payable{\r\n        revert();\r\n    }\r\n    \r\n    function Register_as_Buyer(address _wallet) external{\r\n        register(_wallet, Category.Buyer);\r\n    }\r\n    \r\n    function Register_as_Seller(address _wallet) external{\r\n        register(_wallet, Category.Seller);\r\n    }\r\n    \r\n    function BuyviaEther(address _seller, uint256 _payment, string calldata _orderDescription) \r\n    external payable \r\n    isBuyer isSeller(_seller) sufficientPayment(_payment) {\r\n        _buy(_seller, _payment, _orderDescription);\r\n        orders[orderNo].tokenAddress = address(0);\r\n        // payment will be added to escrow at this time\r\n        emit NewOrder(orderNo, msg.sender, _seller, _payment);\r\n    }\r\n    \r\n    // @param _payment = this must specify payment with decimals included according to token used\r\n    function BuyviaToken(address _seller, uint256 _payment, string calldata _orderDescription, address _tokenAddress) \r\n    external  \r\n    isBuyer isSeller(_seller) supportedToken(_tokenAddress){\r\n        _buy(_seller, _payment, _orderDescription);\r\n        orders[orderNo].tokenAddress = _tokenAddress;\r\n        // get tokens from the client to escrow\r\n        IERC20(_tokenAddress).transferFrom(msg.sender, address(this), _payment);\r\n        // payment will be added to escrow at this time\r\n        emit NewOrder(orderNo, msg.sender, _seller, _payment, _tokenAddress);\r\n    }\r\n    \r\n    function _buy(address _seller, uint256 _payment, string memory _orderDescription) private {\r\n        orderNo += 1;\r\n        orders[orderNo].buyer = msg.sender;\r\n        orders[orderNo].seller = _seller;\r\n        orders[orderNo].lastUpdated = block.timestamp;\r\n        orders[orderNo].payment = _payment;\r\n        orders[orderNo].description = _orderDescription;\r\n        orders[orderNo].status = Status.Initiated;\r\n    }\r\n\r\n    function CompleteOrder(uint256 _orderNo) external validBuyer(_orderNo) validOrder(_orderNo) notCompleted(_orderNo) /* notCancelled(_orderNo) */ notDisputed(_orderNo) {\r\n        orders[_orderNo].status = Status.Completed;\r\n        orders[_orderNo].lastUpdated = block.timestamp;\r\n        \r\n        uint256 delancePayment = (onePercent(orders[_orderNo].payment).mul(5)).div(10); // 0.5%\r\n        \r\n        if(orders[_orderNo].tokenAddress == address(0)){\r\n            owner.transfer(delancePayment);\r\n            // release payment\r\n            payable(orders[_orderNo].seller).transfer(orders[_orderNo].payment.sub(delancePayment));\r\n        }\r\n        else{\r\n            IERC20(orders[_orderNo].tokenAddress).transfer(owner, delancePayment);\r\n            IERC20(orders[_orderNo].tokenAddress).transfer(orders[_orderNo].seller, orders[_orderNo].payment.sub(delancePayment));\r\n        }\r\n            \r\n        emit Completed(_orderNo);\r\n        emit FundsReleased(_orderNo, orders[_orderNo].seller, orders[_orderNo].payment.sub(delancePayment));\r\n        emit DelancePaymentReleased(_orderNo, delancePayment);\r\n    }\r\n    \r\n    function OpenDispute(uint256 _orderNo, string calldata _description) external notDisputed(_orderNo) notCompleted(_orderNo) {\r\n        require(orders[_orderNo].seller == msg.sender || orders[_orderNo].buyer == msg.sender, \"Un-authorized\");\r\n        orders[_orderNo].description = _description;\r\n        orders[_orderNo].status = Status.Disputed;\r\n        \r\n        emit DisputeOpened(orderNo, msg.sender, _description);\r\n    }\r\n    \r\n    function ResolveDispute(address _releasePaymentTo, uint256 _orderNo) external onlyOwner notCompleted(_orderNo) {\r\n        require(orders[_orderNo].status == Status.Disputed, \"Order is not in dispute\");\r\n        // recheck the receiver is either buyer or seller\r\n        require(orders[_orderNo].buyer == _releasePaymentTo || \r\n        orders[_orderNo].seller == _releasePaymentTo , \"Receiver is not buyer or seller\");\r\n        \r\n        uint256 delancePayment = (onePercent(orders[_orderNo].payment).mul(5)).div(10); // 0.5%\r\n\r\n        if(orders[_orderNo].tokenAddress == address(0)){\r\n             if(_releasePaymentTo == orders[_orderNo].seller) { // releasing to freelancer\r\n                owner.transfer(delancePayment); // send to owner - 0.5% of total amt\r\n            } else{\r\n                delancePayment = 0;\r\n            }\r\n            // release payment to buyer/seller\r\n            payable(_releasePaymentTo).transfer(orders[_orderNo].payment.sub(delancePayment));\r\n        }\r\n        else{\r\n            if(_releasePaymentTo == orders[_orderNo].seller) { // releasing to freelancer\r\n               \r\n               IERC20(orders[_orderNo].tokenAddress).transfer(owner, delancePayment);\r\n            } else {\r\n                delancePayment = 0;\r\n            }\r\n            IERC20(orders[_orderNo].tokenAddress).transfer(_releasePaymentTo, orders[_orderNo].payment.sub(delancePayment));\r\n        }\r\n    }\r\n    \r\n    function register(address _wallet, Category _category) internal {\r\n        require(_wallet == msg.sender, \"Register your wallet\");\r\n        \r\n        // check if already registered in same category\r\n        require(users[msg.sender].category != _category, \"User is already registered\");\r\n        \r\n        // increment the users count\r\n        usersCount += 1;\r\n        \r\n        // check if already registered but in different category\r\n        if(users[msg.sender].category != Category.None && users[msg.sender].category != _category){\r\n            _category = Category.Both;\r\n            usersCount -= 1;\r\n        }\r\n        \r\n        users[msg.sender].category = _category;\r\n        users[msg.sender].wallet = _wallet;\r\n        users[msg.sender].id = usersCount;\r\n        \r\n        emit Registered(_wallet, _category, usersCount);\r\n    }\r\n    \r\n    modifier validSeller(uint256 _orderNo){\r\n        require(orders[_orderNo].seller == msg.sender, \"Un-authorized\");\r\n        _;\r\n    }\r\n    \r\n    modifier validBuyer(uint256 _orderNo){\r\n        require(orders[_orderNo].buyer == msg.sender, \"Un-authorized\");\r\n        _;\r\n    }\r\n    \r\n    modifier validOrder(uint256 _orderNo){\r\n        require(orders[_orderNo].status != Status.DoesNotExist, \"Invalid Order No\");\r\n        _;\r\n    }\r\n        \r\n    modifier isBuyer{\r\n        require(users[msg.sender].category == Category.Buyer || users[msg.sender].category == Category.Both, \"Un-registered buyer.\");\r\n        _;\r\n    }\r\n    \r\n    modifier isSeller(address _seller){\r\n        require(users[_seller].category == Category.Seller || users[_seller].category == Category.Both, \"Un-registered seller.\");\r\n        _;\r\n    }\r\n    \r\n    modifier sufficientPayment(uint256 _payment){\r\n        require(_payment <= msg.value, \"Insufficient funds for payment.\");\r\n        _;\r\n    }\r\n    \r\n    modifier supportedToken(address _tokenAddress){\r\n        require(supportedTokens[_tokenAddress], \"Unsupported token.\");\r\n        require(_tokenAddress != address(0), \"Invalid token address.\");\r\n        _;\r\n    }\r\n    \r\n    modifier notDisputed(uint256 _orderNo){\r\n        require(orders[_orderNo].status != Status.Disputed, \"Order is in dispute.\");\r\n        _;\r\n    }\r\n    \r\n    modifier notCompleted(uint256 _orderNo){\r\n        require(orders[_orderNo].status != Status.Completed, \"Order is completed.\");\r\n        _;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Private function to calculate 1% percentage\r\n    // ------------------------------------------------------------------------\r\n    function onePercent(uint256 _tokens) private pure returns (uint256){\r\n        uint256 roundValue = _tokens.ceil(100);\r\n        uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2));\r\n        return onePercentofTokens;\r\n    }\r\n}"
    }
  }
}