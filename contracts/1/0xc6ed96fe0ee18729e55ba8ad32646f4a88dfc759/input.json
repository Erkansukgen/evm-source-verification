{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/TomiFunding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport \"./libraries/TransferHelper.sol\";\nimport \"./modules/Ownable.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract TomiFunding is Ownable {\n    address public tomi;\n\n    mapping(address => bool) included;\n    \n    event ClaimableGranted(address _userAddress);\n    event ClaimableRevoked(address _userAddress);\n    event Claimed(address _userAddress, uint256 _amount);\n    event FundingTokenSettled(address tokenAddress);\n    \n    constructor(address _tomi) public {\n        tomi = _tomi;\n    }\n    \n    modifier inClaimable(address _userAddress) {\n        require(included[_userAddress], \"TomiFunding::User not in claimable list!\");\n        _;\n    }\n\n    modifier notInClaimable(address _userAddress) {\n        require(!included[_userAddress], \"TomiFunding::User already in claimable list!\");\n        _;\n    }\n    \n    function setTomi(address _tomi) public onlyOwner {\n        tomi = _tomi;\n        emit FundingTokenSettled(_tomi);\n    }\n    \n    function grantClaimable(address _userAddress) public onlyOwner notInClaimable(_userAddress) {\n        require(_userAddress != address(0), \"TomiFunding::User address is not legit!\");\n        \n        included[_userAddress] = true;\n        emit ClaimableGranted(_userAddress);\n    }\n    \n    function revokeClaimable(address _userAddress) public onlyOwner inClaimable(_userAddress) {\n        require(_userAddress != address(0), \"TomiFunding::User address is not legit!\");\n        \n        included[_userAddress] = false;\n        emit ClaimableRevoked(_userAddress);\n    }\n    \n    function claim(uint256 _amount) public inClaimable(msg.sender) {\n        uint256 remainBalance = IERC20(tomi).balanceOf(address(this));\n        require(remainBalance >= _amount, \"TomiFunding::Remain balance is not enough to claim!\");\n        \n        TransferHelper.safeTransfer(address(tomi), msg.sender, _amount); \n        emit Claimed(msg.sender, _amount);\n    }\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/modules/Ownable.sol": {
      "content": "pragma solidity >=0.5.16;\n\ncontract Ownable {\n    address public owner;\n\n    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, 'Ownable: FORBIDDEN');\n        _;\n    }\n\n    function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), 'Ownable: INVALID_ADDRESS');\n        emit OwnerChanged(owner, _newOwner);\n        owner = _newOwner;\n    }\n\n}"
    }
  }
}