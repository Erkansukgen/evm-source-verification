{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"DUNKBuying.sol":{"content":"/**\r\n *Submitted for verification at BscScan.com on 2021-02-20\r\n*/\r\n\r\npragma solidity ^0.5.9;\r\n\r\ninterface MU_DANK {\r\n    function balanceOf(address _owner) view external  returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) external  returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external  returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  \r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n\r\n\r\ncontract DUNKBuying{\r\n    \r\n    using SafeMath for uint256;\r\n    AggregatorV3Interface internal priceFeed;\r\n    MU_DANK dunk;\r\n     \r\n    mapping(address=>uint256)public _balances;\r\n    \r\n    address payable public owner;\r\n\r\n     uint256 public softcap=1500000;\r\n     uint256 public hardcap=4000000;\r\n     uint256 public tokensold;\r\n     uint256 public starttime;\r\n    bool public buying = true;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender==owner);\r\n        _;\r\n    }\r\n    \r\n    modifier toBuy(){\r\n        require(buying == true,\"bfiToken buying paused by owner.\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address payable _owner) public{\r\n        owner = _owner;\r\n        dunk = MU_DANK(0x9Ea1Ae46C15a4164B74463Bc26f8aA3b0EeA2e6E); \r\n        priceFeed = AggregatorV3Interface(0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46);\r\n        starttime=block.timestamp;\r\n    }\r\n    \r\n    function changeOwner(address payable _newOwner) public onlyOwner returns(bool) {\r\n        owner = _newOwner;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    function () payable external {\r\n        \r\n    }\r\n    \r\n    function getContractBalance() public view returns(uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    \r\n    function getLatestPrice(uint256 amount) public view returns (uint256) {\r\n        (,int price,,,) = priceFeed.latestRoundData();\r\n        \r\n        return (uint256(price).div(10).mul(amount));\r\n    }\r\n    \r\n    function buy(uint256 _amount) public payable toBuy returns(bool){\r\n        require(_amount > 0 , \"Amount can not be zero.\");\r\n        require(msg.value==getLatestPrice(_amount),\"incorrect value\");\r\n        _balances[msg.sender]=_balances[msg.sender].add(_amount*1e18);\r\n        tokensold=tokensold.add(_amount);\r\n        return true;\r\n    }\r\n    function claim()public returns(bool){\r\n        require(_balances[msg.sender]>0);\r\n        require(block.timestamp>starttime.add(6 days),\"you cannot sell under the selling time\");\r\n        dunk.transferFrom(owner, msg.sender, _balances[msg.sender]);\r\n        _balances[msg.sender]=0;\r\n        return true;\r\n    }\r\n    \r\n    function sellback(uint256 _amount)public returns(bool){\r\n        require(block.timestamp>starttime.add(6 days),\"you cannot sell under the selling time\");\r\n        require(tokensold<softcap,\"sale hits the hardcap so you cannot sellback it\");\r\n        dunk.transferFrom(msg.sender, owner, _amount*1e18);\r\n        msg.sender.transfer(_balances[msg.sender].mul(10));\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function transferFunds(uint256 _amount) external onlyOwner returns(bool){\r\n        require(_amount <= getContractBalance(),\"not enough balance in the contract.\");\r\n        owner.transfer(_amount);       \r\n        return true;\r\n        \r\n    }\r\n    \r\n     \r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}"}}}