{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"localhost/interactiveAdapters/tokenSets/TokenSetsInteractiveAdapter.sol":{"content":"// Copyright (C) 2020 Zerion Inc. <https://zerion.io>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.6;\npragma experimental ABIEncoderV2;\n\n\ninterface ERC20 {\n    function approve(address, uint256) external returns (bool);\n    function transfer(address, uint256) external returns (bool);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n}\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract\n * returns false). Tokens that return no value (and instead revert or throw on failure)\n * are also supported, non-reverting calls are assumed to be successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.transfer.selector,\n                to,\n                value\n            ),\n            \"transfer\",\n            location\n        );\n    }\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.transferFrom.selector,\n                from,\n                to,\n                value\n            ),\n            \"transferFrom\",\n            location\n        );\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address spender,\n        uint256 value,\n        string memory location\n    )\n        internal\n    {\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: wrong approve call\"\n        );\n        callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                value\n            ),\n            \"approve\",\n            location\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract),\n     * relaxing the requirement on the return value: the return value is optional\n     * (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     * @param location Location of the call (for debug).\n     */\n    function callOptionalReturn(\n        ERC20 token,\n        bytes memory data,\n        string memory functionName,\n        string memory location\n    )\n        private\n    {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking\n        // mechanism, since we're implementing it ourselves.\n\n        // We implement two-steps call as callee is a contract is a responsibility of a caller.\n        //  1. The call itself is made, and success asserted\n        //  2. The return value is decoded, which in turn checks the size of the returned data.\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(\n            success,\n            string(\n                abi.encodePacked(\n                    \"SafeERC20: \",\n                    functionName,\n                    \" failed in \",\n                    location\n                )\n            )\n        );\n\n        if (returndata.length > 0) { // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: false returned\");\n        }\n    }\n}\n\n\nstruct Action {\n    ActionType actionType;\n    bytes32 protocolName;\n    uint256 adapterIndex;\n    address[] tokens;\n    uint256[] amounts;\n    AmountType[] amountTypes;\n    bytes data;\n}\n\nenum ActionType { None, Deposit, Withdraw }\n\n\nenum AmountType { None, Relative, Absolute }\n\n\n/**\n * @title Protocol adapter interface.\n * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract ProtocolAdapter {\n\n    /**\n     * @dev MUST return \"Asset\" or \"Debt\".\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function adapterType() external pure virtual returns (bytes32);\n\n    /**\n     * @dev MUST return token type (default is \"ERC20\").\n     * SHOULD be implemented by the public constant state variable.\n     */\n    function tokenType() external pure virtual returns (bytes32);\n\n    /**\n     * @dev MUST return amount of the given token locked on the protocol by the given account.\n     */\n    function getBalance(address token, address account) public view virtual returns (uint256);\n}\n\n\n/**\n * @title Adapter for TokenSets.\n * @dev Implementation of ProtocolAdapter interface.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\ncontract TokenSetsAdapter is ProtocolAdapter {\n\n    bytes32 public constant override adapterType = \"Asset\";\n\n    bytes32 public constant override tokenType = \"SetToken\";\n\n    /**\n     * @return Amount of SetTokens held by the given account.\n     * @param token Address of the SetToken contract.\n     * @dev Implementation of ProtocolAdapter interface function.\n     */\n    function getBalance(address token, address account) public view override returns (uint256) {\n        return ERC20(token).balanceOf(account);\n    }\n}\n\n\n/**\n * @title Base contract for interactive protocol adapters.\n * @dev deposit() and withdraw() functions MUST be implemented\n * as well as all the functions from ProtocolAdapter interface.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\nabstract contract InteractiveAdapter is ProtocolAdapter {\n\n    uint256 internal constant RELATIVE_AMOUNT_BASE = 1e18;\n    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /**\n     * @dev The function must deposit assets to the protocol.\n     * @return MUST return assets to be sent back to the `msg.sender`.\n     */\n    function deposit(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory data\n    )\n        public\n        payable\n        virtual\n        returns (address[] memory);\n\n    /**\n     * @dev The function must withdraw assets from the protocol.\n     * @return MUST return assets to be sent back to the `msg.sender`.\n     */\n    function withdraw(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory data\n    )\n        public\n        payable\n        virtual\n        returns (address[] memory);\n\n    function getAbsoluteAmountDeposit(\n        address token,\n        uint256 amount,\n        AmountType amountType\n    )\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (amountType == AmountType.Relative) {\n            require(amount <= RELATIVE_AMOUNT_BASE, \"L: wrong relative value!\");\n\n            uint256 totalAmount;\n            if (token == ETH) {\n                totalAmount = address(this).balance;\n            } else {\n                totalAmount = ERC20(token).balanceOf(address(this));\n            }\n\n            if (amount == RELATIVE_AMOUNT_BASE) {\n                return totalAmount;\n            } else {\n                return totalAmount * amount / RELATIVE_AMOUNT_BASE; // TODO overflow check\n            }\n        } else {\n            return amount;\n        }\n    }\n\n    function getAbsoluteAmountWithdraw(\n        address token,\n        uint256 amount,\n        AmountType amountType\n    )\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        if (amountType == AmountType.Relative) {\n            require(amount <= RELATIVE_AMOUNT_BASE, \"L: wrong relative value!\");\n\n            if (amount == RELATIVE_AMOUNT_BASE) {\n                return getBalance(token, address(this));\n            } else {\n                return getBalance(token, address(this)) * amount / RELATIVE_AMOUNT_BASE; // TODO overflow check\n            }\n        } else {\n            return amount;\n        }\n    }\n}\n\n\n/**\n * @dev RebalancingSetIssuanceModule contract interface.\n * Only the functions required for TokenSetsInteractiveAdapter contract are added.\n * The RebalancingSetIssuanceModule contract is available here\n * github.com/SetProtocol/set-protocol-contracts/blob/master/contracts/core/modules/RebalancingSetIssuanceModule.sol.\n */\ninterface RebalancingSetIssuanceModule {\n    function issueRebalancingSet(address, uint256, bool) external;\n    function issueRebalancingSetWrappingEther(address, uint256, bool) external payable;\n    function redeemRebalancingSet(address, uint256, bool) external;\n    function redeemRebalancingSetUnwrappingEther(address, uint256, bool) external;\n}\n\n\n/**\n * @dev SetToken contract interface.\n * Only the functions required for TokenSetsInteractiveAdapter contract are added.\n * The SetToken contract is available here\n * github.com/SetProtocol/set-protocol-contracts/blob/master/contracts/core/tokens/SetToken.sol.\n */\ninterface SetToken {\n    function getComponents() external view returns(address[] memory);\n}\n\n\n/**\n * @dev RebalancingSetToken contract interface.\n * Only the functions required for TokenSetsInteractiveAdapter contract are added.\n * The RebalancingSetToken contract is available here\n * github.com/SetProtocol/set-protocol-contracts/blob/master/contracts/core/tokens/RebalancingSetTokenV3.sol.\n */\ninterface RebalancingSetToken {\n    function currentSet() external view returns (SetToken);\n}\n\n\n/**\n * @title Interactive adapter for TokenSets.\n * @dev Implementation of InteractiveAdapter abstract contract.\n * @author Igor Sobolev <sobolev@zerion.io>\n */\ncontract TokenSetsInteractiveAdapter is InteractiveAdapter, TokenSetsAdapter {\n\n    using SafeERC20 for ERC20;\n\n    address internal constant TRANSFER_PROXY = 0x882d80D3a191859d64477eb78Cca46599307ec1C;\n    address internal constant ISSUANCE_MODULE = 0xDA6786379FF88729264d31d472FA917f5E561443;\n\n    /**\n     * @notice Deposits tokens to the TokenSet.\n     * @param tokens Array with one element - payment token address.\n     * @param amounts Array with one element - payment token amount to be deposited.\n     * @param amountTypes Array with one element - amount type.\n     * @param data ABI-encoded additional parameters:\n     *     - rebalancingSetAddress - rebalancing set address;\n     *     - rebalancingSetQuantity - rebalancing set amount to be minted;\n     * @return Asset sent back to the msg.sender.\n     * @dev Implementation of InteractiveAdapter function.\n     */\n    function deposit(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory data\n    )\n        public\n        payable\n        override\n        returns (address[] memory)\n    {\n        uint256 absoluteAmount;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            absoluteAmount = getAbsoluteAmountDeposit(tokens[i], amounts[i], amountTypes[i]);\n            ERC20(tokens[i]).safeApprove(TRANSFER_PROXY, absoluteAmount, \"TSIA![1]\");\n        }\n\n        (address setAddress, uint256 setQuantity) = abi.decode(data, (address, uint256));\n\n        address[] memory tokensToBeWithdrawn = new address[](1);\n        tokensToBeWithdrawn[0] = setAddress;\n\n        try RebalancingSetIssuanceModule(ISSUANCE_MODULE).issueRebalancingSet(\n            setAddress,\n            setQuantity,\n            false\n        ) {} catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory) {\n            revert(\"TSIA: tokenSet fail!\");\n        }\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            ERC20(tokens[i]).safeApprove(TRANSFER_PROXY, 0, \"TSIA![2]\");\n        }\n\n        return tokensToBeWithdrawn;\n    }\n\n    /**\n     * @notice Withdraws tokens from the TokenSet.\n     * @param tokens Array with one element - rebalancing set address.\n     * @param amounts Array with one element - rebalancing set amount to be burned.\n     * @param amountTypes Array with one element - amount type.\n     * @return Asset sent back to the msg.sender.\n     * @dev Implementation of InteractiveAdapter function.\n     */\n    function withdraw(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        AmountType[] memory amountTypes,\n        bytes memory\n    )\n        public\n        payable\n        override\n        returns (address[] memory)\n    {\n        require(tokens.length == 1, \"TSIA: should be 1 token/amount/type!\");\n\n        uint256 amount = getAbsoluteAmountWithdraw(tokens[0], amounts[0], amountTypes[0]);\n        RebalancingSetIssuanceModule issuanceModule = RebalancingSetIssuanceModule(ISSUANCE_MODULE);\n        RebalancingSetToken rebalancingSetToken = RebalancingSetToken(tokens[0]);\n        SetToken setToken = rebalancingSetToken.currentSet();\n        address[] memory tokensToBeWithdrawn = setToken.getComponents();\n\n        try issuanceModule.redeemRebalancingSet(\n            tokens[0],\n            amount,\n            false\n        ) {} catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory) {\n            revert(\"TSIA: tokenSet fail!\");\n        }\n\n        return tokensToBeWithdrawn;\n    }\n}\n"}}}