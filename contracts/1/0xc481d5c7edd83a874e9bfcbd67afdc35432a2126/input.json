{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/DaoTest.sol":{"content":"pragma solidity ^0.7.0;\nimport \"./Erc20.sol\";\nimport \"./SafeMathTyped.sol\";\n\ncontract VoterContract\n{\n    Erc20 tokens;\n    mapping(address => uint256) public staked;\n    mapping(address => uint256) public voters;\n    uint256 public totalStake;\n    address public activeProposalTo;\n    bytes public activeProposalData;\n    uint256 public activeProposalInFavorCount;\n    uint256 public activeProposalAgainstCount;\n    uint256 public activeProposalSubmittedDate;\n    mapping(address => uint256) public lastTimeVoted;\n    \n    constructor(Erc20 _tokens, address _activeProposalTo)\n    {\n        tokens = _tokens;\n        _activeProposalTo = activeProposalTo;\n        staked[0x2881353f7Aa9f25874Cb579b84e5EE1910fF8D21] = 1; // FdC\n        staked[0x1aA7959449783bf8977c6B229D1B2c7Dd58407Fe] = 1; // CG\n        staked[0xCd4034644FAeBEC6F59602207A70766E08590ae2] = 1; // HC\n        staked[0x0e6Ac99011F6fD9855BE52813fDe75CBBc8C49E7] = 1; // EJ\n        staked[0x88270d154b1037A1713c83f0De5f6BbEACFE0Afb] = 1; // SD\n        totalStake = 5;\n        \n    }\n    \n    function stake(uint256 _amount, address _to)\n        external\n    {\n        bool couldTransfer = tokens.transferFrom(msg.sender, address(this), _amount);\n        require(couldTransfer, \"could not transfer\");\n        staked[msg.sender] = SafeMathTyped.add256(_amount, staked[msg.sender]);\n        voters[_to] = SafeMathTyped.add256(_amount, voters[_to]);\n        totalStake = SafeMathTyped.add256(_amount, totalStake);\n    }\n    \n    function vote(address _activeProposalTo, bool _isInFavor)\n        external\n    {\n        require (activeProposalTo == _activeProposalTo, \"mismatch\");\n        require (voters[msg.sender] > 0, \"no stake to vote with\");\n        require (lastTimeVoted[msg.sender] < activeProposalSubmittedDate, \"already voted\");\n        lastTimeVoted[msg.sender] = block.timestamp;\n        if (_isInFavor) \n        {\n            activeProposalInFavorCount = SafeMathTyped.add256(activeProposalInFavorCount, voters[msg.sender]);\n        }\n        else\n        {\n            activeProposalAgainstCount = SafeMathTyped.add256(activeProposalAgainstCount, voters[msg.sender]);\n        }\n    }\n    \n    function execute()\n        external\n    {\n        require(activeProposalInFavorCount > totalStake / 2);\n        activeProposalTo.delegatecall(activeProposalData);\n        activeProposalTo = address(0);\n    }\n}\n\ncontract Echo\n{\n    event LogEcho(address _from);\n    fallback()\n        external\n    {\n        emit LogEcho(address(this));\n    }\n}\n\nstruct Bid\n{\n    uint128 pricePerToken;\n    uint128 amountOfTokens;\n    address bidder;\n}\n\nstruct LeafNode\n{\n    uint256 amountOfTokens;\n    uint256 startIndex;\n    Bid[] bids;\n}\n\ncontract RollingAuction\n{\n    uint128 public firstTokenAmountToAllocate;\n    uint128 constant public minAmount = 100;\n    uint128 constant public maxAmount = 999;\n    uint128 constant public minTokensPerBid = 100;\n    uint128 public tokensPerTimeslice;\n    uint256 constant public bidAssetScaling = 10000000000000000;\n    uint256 constant public allocatingAssetDecimalsScaling = 1000000000000000000;\n    uint128 public tokensLeftForCurrentTimeslice = 0;\n    uint128 public amountLeft;\n    uint128 public amountUnallocated = 0;\n    Erc20 public allocationAsset;\n    Erc20 public bidAsset;\n    address public fundAddress;\n    address public unclaimedAddress;\n    uint256 public startDate;\n    uint256 public timeWindow;\n    uint256 public lastAllocatedTimeslice;\n    bool hasMovedUnclaimed = false;\n    uint256 constant public outrightBuyId = type(uint256).max;\n    \n\n    mapping(address => uint128) public allocations;\n    mapping(uint256 => uint256) public level1;  // X.00\n    mapping(uint256 => mapping(uint256 => uint256)) public level2;  // 0.X0\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => LeafNode))) public level3; // 0.0X\n\n    constructor(\n        uint128 _amountLeft, \n        Erc20 _allocationAsset, \n        Erc20 _bidAsset, \n        address _fundAddress, \n        address _unclaimedAddress, \n        uint256 _startDate, \n        uint256 _timeWindow, \n        uint128 _firstTokenAmountToAllocate, \n        uint128 _tokensPerTimeslice)\n    {\n        amountLeft = _amountLeft;\n        allocationAsset = _allocationAsset;\n        bidAsset = _bidAsset;\n        fundAddress = _fundAddress;\n        unclaimedAddress = _unclaimedAddress;\n        startDate = _startDate;\n        timeWindow = _timeWindow;\n        firstTokenAmountToAllocate = _firstTokenAmountToAllocate;\n        tokensPerTimeslice = _tokensPerTimeslice;\n    }\n\n    function topBid()\n        external\n        view\n        returns (uint128 _pricePerToken)\n    {\n        for (uint128 level1Index = 9; level1Index < 10; level1Index -= 1)\n        {\n            uint256 level1Amount = level1[level1Index];\n            if (level1Amount > 0)\n            {\n                for (uint128 level2Index = 9; level2Index < 10; level2Index -= 1)\n                {\n                    uint256 level2Amount = level2[level1Index][level2Index];\n                    if (level2Amount > 0)\n                    {\n                        for (uint128 level3Index = 9; level3Index < 10; level3Index -= 1)\n                        {\n                            LeafNode storage node = level3[level1Index][level2Index][level3Index];\n                            if (node.amountOfTokens > 0)\n                            {\n                                return uint128((level1Index * 100) + (level2Index * 10) + level3Index);\n                            }\n\n                            if (level3Index == 0)\n                            {\n                                break;\n                            }\n                        }\n                    }\n\n                    if (level2Index == 0)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            if (level1Index == 0)\n            {\n                break;\n            }\n        }\n    }\n\n    function getTokensAmountForBid(uint128 _pricePerToken)\n        external\n        view\n        returns (uint256 _amountOfTokens)\n    {\n        uint256 level1Index = getLevel1Index(_pricePerToken);\n        uint256 level2Index = getLevel2Index(_pricePerToken);\n        uint256 level3Index = getLevel3Index(_pricePerToken);\n        \n        LeafNode storage node = level3[level1Index][level2Index][level3Index];\n        return node.amountOfTokens;\n    }\n\n    function getBidForTokenDepth(uint128 _amountOfTokens)\n        external\n        view\n        returns (uint128 _pricePerToken)\n    {\n        for (uint256 level1Index = 9; level1Index < 10; level1Index -= 1)\n        {\n            uint256 level1Amount = level1[level1Index];\n            if (level1Amount > 0 && level1Amount >= _amountOfTokens)\n            {\n                for (uint256 level2Index = 9; level2Index < 10; level2Index -= 1)\n                {\n                    uint256 level2Amount = level2[level1Index][level2Index];\n                    if (level2Amount > 0 && level2Amount >= _amountOfTokens)\n                    {\n                        for (uint256 level3Index = 9; level3Index < 10; level3Index -= 1)\n                        {\n                            LeafNode storage node = level3[level1Index][level2Index][level3Index];\n                            if (node.amountOfTokens > 0 && node.amountOfTokens >= _amountOfTokens)\n                            {\n                                _pricePerToken = uint128((level1Index * 100) + (level2Index * 10) + level3Index);\n                                _amountOfTokens = 0;\n                            }\n                            else\n                            {\n                                _amountOfTokens = _amountOfTokens - uint128(node.amountOfTokens);\n                            }\n\n                            if (level3Index == 0 || _amountOfTokens == 0)\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        _amountOfTokens = _amountOfTokens - uint128(level2Amount);\n                    }\n\n                    if (level2Index == 0 || _amountOfTokens == 0)\n                    {\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                _amountOfTokens = _amountOfTokens - uint128(level1Amount);\n            }\n\n            if (level1Index == 0 || _amountOfTokens == 0)\n            {\n                break;\n            }\n        }\n    }\n\n    function claimAll()\n        public\n    {\n        uint256 allocation = SafeMathTyped.mul256(allocations[msg.sender], allocatingAssetDecimalsScaling);\n        allocations[msg.sender] = 0;\n        bool wasTransfered = allocationAsset.transfer(msg.sender, allocation);\n        require(wasTransfered, \"ABQDAO/could-not-transfer-allocatoin\");\n    }\n\n    function refund(uint256 _bidId, uint128 _pricePerToken)\n        external\n    {\n        require(amountLeft == 0, \"auction not yet completed\");\n        uint128 level1Index = _pricePerToken / 100;\n        uint128 level2Index = (_pricePerToken % 100) / 10;\n        uint128 level3Index = (_pricePerToken % 10) / 10;\n        \n        LeafNode storage node = level3[level1Index][level2Index][level3Index];\n        Bid storage bid = node.bids[_bidId];\n        require(bid.bidder == msg.sender, \"only bidder may request refund\");\n\n        if (bid.amountOfTokens > 0)\n        {\n            uint256 refundTotal = SafeMathTyped.mul256(SafeMathTyped.mul256(bid.pricePerToken, bid.amountOfTokens), bidAssetScaling);\n            bid.amountOfTokens = 0;\n            bool couldTransfer = bidAsset.transfer(msg.sender, refundTotal);\n            require(couldTransfer, \"could not trasfer\");\n        }\n    }\n\n    event BidPlaced(address indexed bidder, uint128 pricePerToken, uint128 amountOfTokens, uint256 bidId, bool isIncrease);\n    function placeBid(uint128 _pricePerToken, uint128 _amountOfTokens)\n        external\n        returns (uint256 _bidId)\n    {\n        require(amountLeft > 0, \"already concluded distribution\");\n        require(_amountOfTokens >= minTokensPerBid, \"ABQDAO/too-few-tokens\");\n        require(_pricePerToken >= minAmount, \"ABQDAO/bid-too-small\");\n\n        if (_pricePerToken > maxAmount)\n        {\n            (_bidId, ) = outrightBuy(uint128(0), _pricePerToken, _amountOfTokens);\n            return _bidId;\n        }\n\n        uint256 totalToTransfer = SafeMathTyped.mul256(SafeMathTyped.mul256(_pricePerToken, _amountOfTokens), bidAssetScaling);\n        bool couldClaimFunds = bidAsset.transferFrom(msg.sender, address(this), totalToTransfer);\n        require(couldClaimFunds, \"ABQDAO/could-not-claim-bid-funds\");\n\n        uint256 level1Index = getLevel1Index(_pricePerToken);\n        uint256 level2Index = getLevel2Index(_pricePerToken);\n        uint256 level3Index = getLevel3Index(_pricePerToken);\n\n        level1[level1Index] = SafeMathTyped.add256(level1[level1Index], _amountOfTokens);\n        level2[level1Index][level2Index] = SafeMathTyped.add256(level2[level1Index][level2Index], _amountOfTokens);\n        LeafNode storage node = level3[level1Index][level2Index][level3Index];\n        node.amountOfTokens = SafeMathTyped.add256(node.amountOfTokens, _amountOfTokens);\n\n        _bidId = node.bids.length;\n        node.bids.push(Bid(_pricePerToken, _amountOfTokens, msg.sender));\n        emit BidPlaced(msg.sender, _pricePerToken, _amountOfTokens, _bidId, false);\n    }\n\n    function getLevel1Index(uint128 _pricePerToken)\n        public\n        pure\n        returns (uint256 _index)\n    {\n        return _pricePerToken / 100;\n    }\n\n    function getLevel2Index(uint128 _pricePerToken)\n        public\n        pure\n        returns (uint256 _index)\n    {\n        return (_pricePerToken % 100) / 10;\n    }\n\n    function getLevel3Index(uint128 _pricePerToken)\n        public\n        pure\n        returns (uint256 _index)\n    {\n        return _pricePerToken % 10;\n    }\n\n    function getBid(uint256 _bidId, uint128 _pricePerToken)\n        external\n        view\n        returns (address _bidder, uint128 _amountOfTokensOutstanding)\n    {\n        uint256 level1Index = getLevel1Index(_pricePerToken);\n        uint256 level2Index = getLevel2Index(_pricePerToken);\n        uint256 level3Index = getLevel3Index(_pricePerToken);\n        \n        LeafNode storage node = level3[level1Index][level2Index][level3Index];\n        Bid storage bid = node.bids[_bidId];\n\n        _bidder = bid.bidder;\n        _amountOfTokensOutstanding = bid.amountOfTokens;\n    }\n\n    function increaseBid(uint256 _bidId, uint128 _oldPricePerToken, uint128 _newPricePerToken)\n        external\n        returns (uint256 _newBidId)\n    {\n        require(amountLeft > 0, \"already concluded distribution\");\n        require(_newPricePerToken >= minAmount, \"bid too small\");\n        require(_newPricePerToken > _oldPricePerToken);\n\n        uint256 level1Index = getLevel1Index(_oldPricePerToken);\n        uint256 level2Index = getLevel2Index(_oldPricePerToken);\n        uint256 level3Index = getLevel3Index(_oldPricePerToken);\n\n        LeafNode storage oldNode = level3[level1Index][level2Index][level3Index];\n        Bid storage oldBid = oldNode.bids[_bidId];\n        require(oldBid.bidder == msg.sender, \"not the bidder\");\n        require(oldBid.amountOfTokens > 0, \"bid already fully processed\");\n\n        // remove old token bids\n        uint128 tokenAmount = oldBid.amountOfTokens;\n        level1[level1Index] = SafeMathTyped.sub256(level1[level1Index], tokenAmount);\n        level2[level1Index][level2Index] = SafeMathTyped.sub256(level2[level1Index][level2Index], tokenAmount);\n        oldNode.amountOfTokens == SafeMathTyped.sub256(oldNode.amountOfTokens, tokenAmount);\n        oldBid.amountOfTokens = 0;\n\n        if (_newPricePerToken > maxAmount)\n        {\n            uint128 actualAmountBought = 0;\n            (_newBidId, actualAmountBought) = outrightBuy(_oldPricePerToken, _newPricePerToken, tokenAmount);\n            oldBid.amountOfTokens = uint128(SafeMathTyped.sub256(tokenAmount, actualAmountBought));\n            return _newBidId;\n        }\n\n        // transfer the increase bid ballance\n        uint256 fundsToAddTotal = SafeMathTyped.mul256(SafeMathTyped.mul256(SafeMathTyped.sub256(_newPricePerToken, _oldPricePerToken), tokenAmount), bidAssetScaling);\n        bool couldTransfer = bidAsset.transferFrom(msg.sender, address(this), fundsToAddTotal);\n        require(couldTransfer, \"could not trasfer funds\");\n\n        // add new bid\n        level1Index = getLevel1Index(_newPricePerToken);\n        level2Index = getLevel2Index(_newPricePerToken);\n        level3Index = getLevel3Index(_newPricePerToken);\n        LeafNode storage node = level3[level1Index][level2Index][level3Index];\n\n        level1[level1Index] = SafeMathTyped.add256(level1[level1Index], tokenAmount);\n        level2[level1Index][level2Index] = SafeMathTyped.add256(level2[level1Index][level2Index], tokenAmount);\n        node.amountOfTokens = SafeMathTyped.add256(node.amountOfTokens, tokenAmount);\n\n        _newBidId = node.bids.length;\n        node.bids.push(Bid(_newPricePerToken, tokenAmount, msg.sender));\n        emit BidPlaced(msg.sender, _newPricePerToken, tokenAmount, _newBidId, true);\n    }\n\n    function outrightBuy(uint128 _oldPricePerToken, uint128 _pricePerToken, uint128 _amount)\n        private\n        returns (uint256 _bidId, uint128 _actualAmount)\n    {\n        if (_amount > amountLeft)\n        {\n            _amount = amountLeft;\n        }\n\n        uint256 bidFundsAdded = SafeMathTyped.mul256(SafeMathTyped.mul256(SafeMathTyped.sub256(_pricePerToken, _oldPricePerToken), _amount), bidAssetScaling);\n        bool couldTransfer = bidAsset.transferFrom(msg.sender, address(this), bidFundsAdded);\n        require(couldTransfer, \"could not pay bid\");\n        uint256 bidFundsTotal = SafeMathTyped.mul256(SafeMathTyped.mul256(_pricePerToken, _amount), bidAssetScaling);\n        couldTransfer = bidAsset.transfer(fundAddress, bidFundsTotal);\n        require(couldTransfer, \"could not transfer to fund\");\n\n        emit BidPlaced(msg.sender, _pricePerToken, _amount, outrightBuyId, false);\n        emit TokensAwarded(msg.sender, _amount);\n        allocations[msg.sender] = allocations[msg.sender] + _amount;\n        _bidId = outrightBuyId;\n        _actualAmount = _amount;\n        amountLeft = uint128(SafeMathTyped.sub256(amountLeft, _amount));\n    }\n\n    function distributeTimeslice(uint128 _maxNodesCount)\n        external\n    {\n        require(_maxNodesCount > 0, \"ABQDAO/max-nodes-count-may-not-be-zero\");\n        require(amountLeft > 0, \"ABQDAO/auction-concluded\");\n        require(startDate <= block.timestamp, \"ABQDAO/not-started-yet\");\n\n        if (tokensLeftForCurrentTimeslice == 0)\n        {\n            if (lastAllocatedTimeslice == 0)\n            {\n                lastAllocatedTimeslice = startDate;\n                tokensLeftForCurrentTimeslice = firstTokenAmountToAllocate;\n            }\n            else\n            {\n                lastAllocatedTimeslice = SafeMathTyped.add256(lastAllocatedTimeslice, timeWindow);\n                if (amountLeft > tokensPerTimeslice)\n                {\n                    tokensLeftForCurrentTimeslice = tokensPerTimeslice;\n                }\n                else\n                {\n                    tokensLeftForCurrentTimeslice = tokensPerTimeslice;\n                }\n            }\n        }\n\n        if (tokensLeftForCurrentTimeslice > amountLeft)\n        {\n            tokensLeftForCurrentTimeslice = amountLeft;\n        }\n\n        require(block.timestamp >= lastAllocatedTimeslice, \"ABQDAO/cannot-distribute-timeslice-yet\");\n        require(tokensLeftForCurrentTimeslice > 0, \"ABQDAO/no-tokens-to-distribute\");\n\n        uint256 amountDistributed = 0;\n        uint256 priceTotal = 0;\n        uint128 maxAmountToDistribute = tokensLeftForCurrentTimeslice;\n        bool hasValue = false;\n        for (uint128 level1Index = 9; level1Index < 10; level1Index -= 1)\n        {\n            uint256 level1Amount = level1[level1Index];\n            if (level1Amount > 0)\n            {\n                hasValue = true;\n                uint128 nodeAmountDistributed;\n                uint256 priceAllocated;\n                (_maxNodesCount, nodeAmountDistributed, priceAllocated) = distributeTimesliceForLevel1(level1Index, _maxNodesCount, maxAmountToDistribute);\n                maxAmountToDistribute = uint128(SafeMathTyped.sub256(maxAmountToDistribute, nodeAmountDistributed));\n                amountDistributed = amountDistributed + nodeAmountDistributed;\n                priceTotal = SafeMathTyped.add256(priceTotal, priceAllocated);\n            }\n\n            if (level1Index == 0 || _maxNodesCount == 0 || maxAmountToDistribute == 0)\n            {\n                break;\n            }\n        }\n\n        if (!hasValue)\n        {\n            // No bids to fill the timeslice\n\n            amountLeft = uint128(SafeMathTyped.sub256(amountLeft, maxAmountToDistribute));\n            amountUnallocated = amountUnallocated + maxAmountToDistribute;\n            bool wasTransfered = allocationAsset.transfer(unclaimedAddress, SafeMathTyped.mul256(maxAmountToDistribute, allocatingAssetDecimalsScaling));\n            require(wasTransfered, \"ABQDAO/could-not-transfer-unclaimed\");\n            tokensLeftForCurrentTimeslice = 0;\n        }\n        else\n        {\n            amountLeft = uint128(SafeMathTyped.sub256(amountLeft, amountDistributed));\n            tokensLeftForCurrentTimeslice = maxAmountToDistribute;\n            priceTotal = SafeMathTyped.mul256(priceTotal, bidAssetScaling);\n            bool wasTransfered = bidAsset.transfer(fundAddress, priceTotal);\n            require(wasTransfered, \"ABQDAO/could-not-transfer-funds\");\n        }\n    }\n\n    function distributeTimesliceForLevel1(uint128 _level1Index, uint128 _nodesCount, uint128 _maxAmountToDistribute)\n        private\n        returns (uint128 _nodesCountLeft, uint128 _amountDistributed, uint256 _priceTotal)\n    {\n        _nodesCountLeft = _nodesCount;\n        for (uint128 level2Index = 9; level2Index < 10; level2Index -= 1)\n        {\n            uint256 level2Amount = level2[_level1Index][level2Index];\n            if (level2Amount > 0)\n            {\n                uint128 nodeAmountDistributed;\n                uint256 priceAllocated;\n                (_nodesCountLeft, nodeAmountDistributed, priceAllocated) = distributeTimesliceForLevel2(_level1Index, level2Index, _nodesCountLeft, _maxAmountToDistribute);\n                _maxAmountToDistribute = uint128(SafeMathTyped.sub256(_maxAmountToDistribute, nodeAmountDistributed));\n                _amountDistributed = _amountDistributed + nodeAmountDistributed;\n                _priceTotal = SafeMathTyped.add256(_priceTotal, priceAllocated);\n            }\n\n            if (level2Index == 0 || _nodesCountLeft == 0 || _maxAmountToDistribute == 0)\n            {\n                break;\n            }\n        }\n\n        level1[_level1Index] = SafeMathTyped.sub256(level1[_level1Index], _amountDistributed);\n    }\n\n    function distributeTimesliceForLevel2(uint128 _level1Index, uint128 _level2Index, uint128 _nodesCount, uint128 _maxAmountToDistribute)\n        private\n        returns (uint128 _nodesCountLeft, uint128 _amountDistributed, uint256 _priceTotal)\n    {\n        _nodesCountLeft = _nodesCount;\n        for (uint128 level3Index = 9; level3Index < 10; level3Index -= 1)\n        {\n            LeafNode storage node = level3[_level1Index][_level2Index][level3Index];\n            if (node.amountOfTokens > 0)\n            {\n                uint128 nodeAmountDistributed;\n                uint256 priceAllocated;\n                (_nodesCountLeft, nodeAmountDistributed, priceAllocated) = distributeTimesliceForLevel3(node, _nodesCountLeft, _maxAmountToDistribute);\n                _maxAmountToDistribute = uint128(SafeMathTyped.sub256(_maxAmountToDistribute, nodeAmountDistributed));\n                _amountDistributed = _amountDistributed + nodeAmountDistributed;\n                _priceTotal = SafeMathTyped.add256(_priceTotal, priceAllocated);\n            }\n\n            if (level3Index == 0 || _nodesCountLeft == 0 || _maxAmountToDistribute == 0)\n            {\n                break;\n            }\n        }\n\n        level2[_level1Index][_level2Index] = SafeMathTyped.sub256(level2[_level1Index][_level2Index], _amountDistributed);\n    }\n\n    function distributeTimesliceForLevel3(LeafNode storage _node, uint128 _nodesCount, uint128 _maxAmountToDistribute)\n        private\n        returns (uint128 _nodesCountLeft, uint128 _amountDistributed, uint256 _priceTotal)\n    {\n        _nodesCountLeft = _nodesCount;\n        if (_node.amountOfTokens > 0)\n        {\n            uint256 currentIndex = _node.startIndex;\n            while (_nodesCountLeft > 0 && currentIndex < _node.bids.length)\n            {\n                // CG: a uint128 minus a uint128 will always fit into a uint128 if overflow checking was done; overflow checking is done in SafeMathTyped.sub.\n                uint128 distributionLeft = uint128(SafeMathTyped.sub256(uint256(_maxAmountToDistribute), uint256(_amountDistributed)));\n                Bid storage currentBid = _node.bids[currentIndex];\n                if (currentBid.amountOfTokens == 0)\n                {\n                    // no bid changes for zero bids just advance index\n\n                    currentIndex = SafeMathTyped.add256(currentIndex, 1);\n                    // CG: the while does check if _nodesCountLeft is greater than zero, so it is safe to subtract one here\n                    _nodesCountLeft = _nodesCountLeft - 1;\n                }\n                else if (currentBid.amountOfTokens < distributionLeft)\n                {\n                    // Consume the full bid since the bid is less than the amount of distribution left.\n\n                    // CG: this will fit into uint128 since _amountDistributed plus distributionLeft will be less than or equal to _maxAmountToDistribute, \n                    // which is a uint128. currentBid.amountOfTokens is capped by the if to be less than distributionLeft.\n                    _amountDistributed = uint128(_amountDistributed + currentBid.amountOfTokens);\n                    _priceTotal = SafeMathTyped.add256(_priceTotal, SafeMathTyped.mul256(currentBid.pricePerToken, currentBid.amountOfTokens));\n                    allocateToBid(currentBid, currentBid.amountOfTokens);\n                    \n                    currentIndex = SafeMathTyped.add256(currentIndex, 1);\n                    // CG: the while does check if _nodesCountLeft is greater than zero, so it is safe to subtract one here\n                    _nodesCountLeft = _nodesCountLeft - 1;\n                }\n                else if (currentBid.amountOfTokens == distributionLeft)\n                {\n                    // Consume the full bid since the bid is the exact amount for the distributionLeft.\n\n                    // CG: this will fit into uint128 since _amountDistributed plus distributionLeft will be less than or equal to _maxAmountToDistribute, \n                    // which is a uint128. currentBid.amountOfTokens is capped by the if to be equal to distributionLeft.\n                    _amountDistributed = uint128(_amountDistributed + currentBid.amountOfTokens);\n                    _priceTotal = SafeMathTyped.add256(_priceTotal, SafeMathTyped.mul256(currentBid.pricePerToken, currentBid.amountOfTokens));\n                    allocateToBid(currentBid, currentBid.amountOfTokens);\n\n                    currentIndex = SafeMathTyped.add256(currentIndex, 1);\n                    // CG: the full allocation amount will be consumed so set nodesCountLeft to zero.\n                    _nodesCountLeft = 0;\n                }\n                else if (currentBid.amountOfTokens > distributionLeft)\n                {\n                    // Consume part of the bid since it is more that the distributionLeft.\n                    _amountDistributed = uint128(SafeMathTyped.add256(_amountDistributed, distributionLeft));\n                    _priceTotal = SafeMathTyped.add256(_priceTotal, SafeMathTyped.mul256(currentBid.pricePerToken, distributionLeft));\n                    allocateToBid(currentBid, distributionLeft);\n\n                    // CG: there is not enough left to allocate to fill the whole bid, so currentIndex doesn't move on.\n                    // CG: the full allocation amount will be consumed so set nodesCountLeft to zero.\n                    _nodesCountLeft = 0;\n                }\n            }\n            _node.startIndex = currentIndex;\n            _node.amountOfTokens = SafeMathTyped.sub256(_node.amountOfTokens, uint256(_amountDistributed));\n        }\n    }\n\n    event TokensAwarded(address indexed bidder, uint128 amountOfTokens);\n    function allocateToBid(Bid storage _bid, uint128 _amount)\n        private\n    {\n        emit TokensAwarded(_bid.bidder, _amount);\n        _bid.amountOfTokens = uint128(SafeMathTyped.sub256(_bid.amountOfTokens, _amount));\n        allocations[_bid.bidder] = allocations[_bid.bidder] + _amount;\n    }\n\n    function totalTokensBiddedOn()\n        public\n        view\n        returns (uint256 _total)\n    {\n        _total = level1[0];\n        _total = SafeMathTyped.add256(_total, level1[1]);\n        _total = SafeMathTyped.add256(_total, level1[2]);\n        _total = SafeMathTyped.add256(_total, level1[3]);\n        _total = SafeMathTyped.add256(_total, level1[4]);\n        _total = SafeMathTyped.add256(_total, level1[5]);\n        _total = SafeMathTyped.add256(_total, level1[6]);\n        _total = SafeMathTyped.add256(_total, level1[7]);\n_total = SafeMathTyped.add256(_total, level1[8]);   \n        _total = SafeMathTyped.add256(_total, level1[9]);\n    }\n\n    function moveUnclaimed()\n        external\n    {\n        require(amountLeft == 0, \"distribution round not done\");\n        require(!hasMovedUnclaimed, \"already move unclaimed funds\");\n        bool couldMoveFunds = allocationAsset.transfer(unclaimedAddress, SafeMathTyped.mul256(amountUnallocated, allocatingAssetDecimalsScaling));\n        require(couldMoveFunds, \"could not move funds\");\n        hasMovedUnclaimed = true;\n    }\n}"},"browser/Erc20.sol":{"content":"pragma solidity ^0.7.0;\n\ninterface Erc20\n{\n    function symbol() view external returns (string memory _symbol);\n    function decimals() view external returns (uint8 _decimals);\n    \n    function balanceOf(address _owner) \n        view\n        external\n        returns (uint256 balance);\n        \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function transfer(address _to, uint256 _amount) \n        external\n        returns (bool _success);\n    function transferFrom(address _from, address _to, uint256 _amount)\n        external\n        returns (bool _success);\n}"},"browser/SafeMathTyped.sol":{"content":"pragma solidity ^0.7.0;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMathTyped {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul256(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"uint256 overflow\");\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div256(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"Can't divide by 0\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"uint256 underflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"uint256 overflow\");\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod256(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Can't mod by 0\");\n        return a % b;\n    }\n\n    /**\n    * @dev returns the greater of two numbers\n    */\n    function max256(uint256 a, uint256 b) internal pure returns (uint) {\n        return a > b ? a : b;\n    }\n\n    /**\n    * @dev returns the lesser of two numbers\n    */\n    function min256(uint256 a, uint256 b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n}"}}}