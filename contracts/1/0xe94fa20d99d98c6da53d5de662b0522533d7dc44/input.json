{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/ALF.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.7.0 <0.9.0;\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address owner) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n}\n\ninterface ILendingPool {\n     function liquidationCall(address collateralAsset, address debtAsset, address user, uint256 debtToCover, bool receiveAToken) external;\n}\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n\ninterface IUniswapV2Pair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}\n\n\ncontract ALF is IUniswapV2Callee {\n    using SafeMath for uint;\n\n    address payable internal immutable owner;\n    address internal immutable uniFactory;\n\n    constructor() {\n        owner = payable(msg.sender);\n        uniFactory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n    }\n    \n    modifier onlyOwner {\n      require(msg.sender == owner, \"E015\");\n      _;\n    }\n    \n    function recover(address token, uint amount) external {\n        IERC20 tokenInt = IERC20(token);\n        require(tokenInt.transfer(owner, amount), \"E001\");\n    }\n\n    function destroy() external onlyOwner {\n        selfdestruct(owner);\n    }\n\n    \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"E002\");\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"E003\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address tokenA, address tokenB) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n                hex'ff',\n                uniFactory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            )))));\n    }\n    \n    // fetches and sorts the reserves for a pair\n    function getReserves(address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n    \n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, \"E004\");\n        require(reserveIn > 0 && reserveOut > 0, \"E005\");\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n    \n    \n    function start(address borrowAddress, uint blockDeadline, uint amount0Out, uint amount1Out, address lendingPoolAddress, address borrowerAddress, uint amountOutMin) external onlyOwner returns (bool) {\n        require(block.number <= blockDeadline, \"E006\");\n        IUniswapV2Pair(borrowAddress).swap(amount0Out, amount1Out, address(this), abi.encode(lendingPoolAddress, borrowerAddress, amountOutMin));\n        return true;\n    }\n\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external override {\n        // Check for initial conditions.\n        require(sender == owner, \"E007\");\n        require(amount0 == 0 || amount1 == 0, \"E008\");\n        \n        // Prepare variables.\n        uint amount = amount0 == 0 ? amount1 : amount0;\n        (IERC20 collateral, IERC20 debt) = getTokens(amount0);\n        (address lendingPoolAddress, address borrowerAddress, uint amountOutMin) = abi.decode(data, (address, address, uint));\n        \n        // Pay Aave.\n        payAave(lendingPoolAddress, address(collateral), address(debt), borrowerAddress, amount);\n\n        // Repay Uniswap.\n        repayUniswap(debt, collateral, amount);\n\n        // Pay owner remainder.\n        uint256 remaining = collateral.balanceOf(address(this));\n        require(remaining >= amountOutMin, \"E010\");\n        require(collateral.transfer(owner, remaining), \"E011\");\n    }\n    \n    function payAave(address lendingPoolAddress, address collateralAddress, address debtAddress, address borrowerAddress, uint amount) internal {\n        ILendingPool lendingPool = ILendingPool(lendingPoolAddress);\n        require(IERC20(debtAddress).approve(lendingPoolAddress, amount), \"E012\");\n        lendingPool.liquidationCall(collateralAddress, debtAddress, borrowerAddress, amount, false);\n    }\n    \n    function getTokens(uint amount0) internal view returns (IERC20 collateral, IERC20 debt) {\n        address token0 = IUniswapV2Pair(msg.sender).token0();\n        address token1 = IUniswapV2Pair(msg.sender).token1();\n        require(msg.sender == pairFor(token0, token1), \"E013\"); // ensure that msg.sender is actually a V2 pair\n        debt = IERC20(amount0 == 0 ? token1 : token0);\n        collateral = IERC20(amount0 == 0 ? token0 : token1);\n        return (collateral, debt);\n    }\n    \n    function repayUniswap(IERC20 debt, IERC20 collateral, uint amount) internal {\n        (uint reserveIn, uint reserveOut) = getReserves(address(debt), address(collateral));\n        uint256 repayAmount = getAmountIn(amount, reserveIn, reserveOut);\n        require(collateral.transfer(msg.sender, repayAmount), \"E009\");\n    }\n}"}}}