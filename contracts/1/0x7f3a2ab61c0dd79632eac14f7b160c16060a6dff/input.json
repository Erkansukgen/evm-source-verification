{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/WorkerAuthManager.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerAuthManager\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\ninterface WorkerAuthManager {\n    /// @notice Gives worker permission to act on a DApp\n    /// @param _workerAddress address of the worker node to given permission\n    /// @param _dappAddress address of the dapp that permission will be given to\n    function authorize(address _workerAddress, address _dappAddress) external;\n\n    /// @notice Removes worker's permission to act on a DApp\n    /// @param _workerAddress address of the proxy that will lose permission\n    /// @param _dappAddresses addresses of dapps that will lose permission\n    function deauthorize(address _workerAddress, address _dappAddresses)\n        external;\n\n    /// @notice Returns is the dapp is authorized to be called by that worker\n    /// @param _workerAddress address of the worker\n    /// @param _dappAddress address of the DApp\n    function isAuthorized(address _workerAddress, address _dappAddress)\n        external\n        view\n        returns (bool);\n\n    /// @notice Get the owner of the worker node\n    /// @param workerAddress address of the worker node\n    function getOwner(address workerAddress) external view returns (address);\n\n    /// @notice A DApp has been authorized by a user for a worker\n    event Authorization(\n        address indexed user,\n        address indexed worker,\n        address indexed dapp\n    );\n\n    /// @notice A DApp has been deauthorized by a user for a worker\n    event Deauthorization(\n        address indexed user,\n        address indexed worker,\n        address indexed dapp\n    );\n}\n"
    },
    "contracts/WorkerAuthManagerImpl.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerAuthManagerImpl\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\nimport \"./WorkerManager.sol\";\nimport \"./WorkerAuthManager.sol\";\n\ncontract WorkerAuthManagerImpl is WorkerAuthManager {\n    WorkerManager workerManager;\n\n    /// @dev permissions keyed by hash(user, worker, dapp)\n    mapping(bytes32 => bool) private permissions;\n\n    constructor(address _workerManager) {\n        workerManager = WorkerManager(_workerManager);\n    }\n\n    modifier onlyByOwner(address _workerAddress) {\n        require(\n            workerManager.getOwner(_workerAddress) == msg.sender,\n            \"worker not hired by sender\"\n        );\n        _;\n    }\n\n    function getAuthorizationKey(\n        address _user,\n        address _worker,\n        address _dapp\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_user, _worker, _dapp));\n    }\n\n    function authorize(address _workerAddress, address _dappAddress)\n        public\n        override\n        onlyByOwner(_workerAddress)\n    {\n        bytes32 key = getAuthorizationKey(\n            msg.sender,\n            _workerAddress,\n            _dappAddress\n        );\n        require(permissions[key] == false, \"dapp already authorized\");\n\n        // record authorization from that user\n        permissions[key] = true;\n\n        // emit event\n        emit Authorization(msg.sender, _workerAddress, _dappAddress);\n    }\n\n    function deauthorize(address _workerAddress, address _dappAddress)\n        public\n        override\n        onlyByOwner(_workerAddress)\n    {\n        bytes32 key = getAuthorizationKey(\n            msg.sender,\n            _workerAddress,\n            _dappAddress\n        );\n        require(permissions[key] == true, \"dapp not authorized\");\n\n        // record deauthorization from that user\n        permissions[key] = false;\n\n        // emit event\n        emit Deauthorization(msg.sender, _workerAddress, _dappAddress);\n    }\n\n    function isAuthorized(address _workerAddress, address _dappAddress)\n        public\n        override\n        view\n        returns (bool)\n    {\n        return\n            permissions[getAuthorizationKey(\n                workerManager.getOwner(_workerAddress),\n                _workerAddress,\n                _dappAddress\n            )];\n    }\n\n    function getOwner(address _workerAddress)\n        public\n        override\n        view\n        returns (address)\n    {\n        return workerManager.getOwner(_workerAddress);\n    }\n\n    /*\n    // XXX: we can't do this because the worker need to accept the job before receiving an authorization\n    function hireAndAuthorize(\n        address payable _workerAddress,\n        address _dappAddress\n    ) public override payable {\n        workerManager.hire(_workerAddress);\n        authorize(_workerAddress, _dappAddress);\n    }\n    */\n}\n"
    },
    "contracts/WorkerManager.sol": {
      "content": "// Copyright 2010 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title WorkerManager\n/// @author Danilo Tuler\npragma solidity ^0.7.0;\n\ninterface WorkerManager {\n    /// @notice Returns true if worker node is available\n    /// @param workerAddress address of the worker node\n    function isAvailable(address workerAddress) external view returns (bool);\n\n    /// @notice Returns true if worker node is pending\n    /// @param workerAddress address of the worker node\n    function isPending(address workerAddress) external view returns (bool);\n\n    /// @notice Get the owner of the worker node\n    /// @param workerAddress address of the worker node\n    function getOwner(address workerAddress) external view returns (address);\n\n    /// @notice Get the user of the worker node, which may not be the owner yet, or how was the previous owner of a retired node\n    function getUser(address workerAddress) external view returns (address);\n\n    /// @notice Returns true if worker node is owned by some user\n    function isOwned(address workerAddress) external view returns (bool);\n\n    /// @notice Asks the worker to work for the sender. Sender needs to pay something.\n    /// @param workerAddress address of the worker\n    function hire(address payable workerAddress) external payable;\n\n    /// @notice Called by the worker to accept the job\n    function acceptJob() external;\n\n    /// @notice Called by the worker to reject a job offer\n    function rejectJob() external payable;\n\n    /// @notice Called by the user to cancel a job offer\n    /// @param workerAddress address of the worker node\n    function cancelHire(address workerAddress) external;\n\n    /// @notice Called by the user to retire his worker.\n    /// @param workerAddress address of the worker to be retired\n    /// @dev this also removes all authorizations in place\n    function retire(address payable workerAddress) external;\n\n    /// @notice Returns true if worker node was retired by its owner\n    function isRetired(address workerAddress) external view returns (bool);\n\n    /// @notice Events signalling every state transition\n    event JobOffer(address indexed worker, address indexed user);\n    event JobAccepted(address indexed worker, address indexed user);\n    event JobRejected(address indexed worker, address indexed user);\n    event Retired(address indexed worker, address indexed user);\n}\n"
    }
  }
}