{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"Ownable.sol":{"content":"// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.6.9;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(),\"Not Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0),\"Zero address not allowed\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.6.9;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n"},"SwapPair.sol":{"content":"// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.6.9;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./TransferHelper.sol\";\r\n\r\n// TODO: balance + 1, to avoid Zero balance\r\n\r\ninterface ISwapFactory {\r\n    function newFactory() external view returns(address);\r\n    function auction() external view returns(address);\r\n    function validator() external view returns(address);\r\n    function investAuction(address payable _whom) external payable returns (bool);\r\n}\r\n\r\ncontract SwapPair {\r\n    using SafeMath for uint256;\r\n\r\n    //uint256 constant chain = 97;  // ETH mainnet = 1, Ropsten = 2, BSC_TESTNET = 97, BSC_MAINNET = 56\r\n    uint256 constant MAX_AMOUNT = 2**192;\r\n    uint256 constant INVESTMENT_FLAG = 2**224;\r\n    uint256 constant NOMINATOR = 10**18;\r\n    uint256 constant PRICE_NOMINATOR = 10**9;     // rate nominator\r\n    address constant NATIVE = address(-1);  // address which holds native token ballance that was spent\r\n    address constant FOREIGN = address(-2); // address which holds foreign token encoded ballance that was spent\r\n    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 0 - BNB, 1 - ETH, 2 - BTC\r\n\r\n    address public token;               // token address\r\n    address public tokenForeign;        // Foreign token address\r\n    address public foreignSwapPair;     // foreign SwapPair contract address (on other blockchain)\r\n    address public factory;             // factory address\r\n    uint256 public decimalsNative;\r\n    uint256 public decimalsForeign;\r\n    uint256 public totalSupply;\r\n\r\n    // balanceOf contain two types of balance:\r\n    // 1. balanceOf[user] - balance of tokens on native chain\r\n    // 2. balanceOf[user+1] - swapped balance of foreign tokens. I.e. on BSC chain it contain amount of ETH that was swapped.\r\n    // 3. balanceOf[user-1] - swapped balance of foreign tokens for investment. I.e. on BSC chain it contain amount of ETH that was swapped.\r\n    mapping (address => uint256) public balanceOf;\r\n    //mapping (address => uint256) public cancelAmount;\r\n    //mapping (address => uint256) public swapAmount;\r\n\r\n    event CancelRequest(address indexed user, address token, uint256 amount);\r\n    event CancelApprove(address indexed user, address token, uint256 amount);\r\n    event ClaimRequest(address indexed user, address foreignToken, uint256 foreignAmount);\r\n    event ClaimApprove(address indexed user, address foreignToken, uint256 foreignAmount, address token, uint256 amount);\r\n\r\n    modifier onlyFactory() {\r\n        require(msg.sender == factory, \"Caller is not the factory\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    function initialize(address _foreignPair, address tokenA, uint8 decimalsA, address tokenB, uint8 decimalsB) public onlyFactory {\r\n        foreignSwapPair = _foreignPair;\r\n        token = tokenA;\r\n        tokenForeign = tokenB;\r\n        decimalsNative = 10**uint256(decimalsA);\r\n        decimalsForeign = 10**uint256(decimalsB);\r\n    }\r\n\r\n    function update() public returns(bool) {\r\n        factory = ISwapFactory(factory).newFactory();\r\n        return true;\r\n    }\r\n\r\n    function getTokens() external view returns(address tokenA, address tokenB) {\r\n        tokenA = token;\r\n        tokenB = tokenForeign;\r\n    }\r\n    \r\n    // encode 64 bits of rate (decimal = 9). and 192 bits of amount \r\n    // into uint256 where high 64 bits is rate and low 192 bit is amount\r\n    // rate = foreign token price / native token price\r\n    function _encode(uint256 rate, uint256 amount) internal pure returns(uint256 encodedBalance) {\r\n        require(amount < MAX_AMOUNT, \"Amount overflow\");\r\n        require(rate < 2**64, \"Rate overflow\");\r\n        encodedBalance = rate * MAX_AMOUNT + amount;\r\n    }\r\n\r\n    // decode from uint256 where high 64 bits is rate and low 192 bit is amount\r\n    // rate = foreign token price / native token price\r\n    function _decode(uint256 encodedBalance) internal pure returns(uint256 rate, uint256 amount) {\r\n        rate = encodedBalance / MAX_AMOUNT;\r\n        amount = uint192(encodedBalance);\r\n    }\r\n\r\n    // swapAddress = user address + 1.\r\n    // balanceOf contain two types of balance:\r\n    // 1. balanceOf[user] - balance of tokens on native chain\r\n    // 2. balanceOf[user+1] - swapped balance of foreign tokens. I.e. on BSC chain it contain amount of ETH that was swapped.\r\n    function _swapAddress(address user) internal pure returns(address swapAddress) {\r\n        swapAddress = address(uint160(user)+1);\r\n    }\r\n    // 3. balanceOf[user-1] - investment to auction total balance.\r\n    function _investAddress(address user) internal pure returns(address investAddress) {\r\n        investAddress = address(uint160(user)-1);\r\n    }\r\n\r\n    // call appropriate transfer function\r\n    function _transfer(address to, uint value) internal {\r\n        if (token < NATIVE_COINS) \r\n            TransferHelper.safeTransferETH(to, value);\r\n        else\r\n            TransferHelper.safeTransfer(token, to, value);\r\n    }\r\n\r\n    // user's deposit to the pool, waiting for swap\r\n    function deposit(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\r\n        if (isInvestment) {\r\n            address investAddress = _investAddress(user);   // on Ethereum side only\r\n            balanceOf[investAddress] = (balanceOf[investAddress].add(amount)) | INVESTMENT_FLAG;\r\n        }\r\n        else {\r\n            balanceOf[user] = balanceOf[user].add(amount);\r\n        }\r\n        totalSupply = totalSupply.add(amount);\r\n        return true;\r\n    }\r\n\r\n    // cancel swap order request\r\n    function cancel(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\r\n        if (isInvestment) {\r\n            address investAddress = _investAddress(user);   // on Ethereum side only\r\n            uint256 balance = uint192(balanceOf[investAddress]);\r\n            balance = balance.sub(amount,\"Not enough tokens on the balance\");\r\n            balanceOf[investAddress] = balance | INVESTMENT_FLAG;\r\n        }\r\n        else {\r\n            balanceOf[user] = balanceOf[user].sub(amount,\"Not enough tokens on the balance\");\r\n        }\r\n        totalSupply = totalSupply.sub(amount,\"Not enough Total Supply\");\r\n        return true;\r\n    }\r\n    // approve cancel swap order and withdraw token from pool or discard cancel request\r\n    // if isInvestment then user = investAddress (user - 1)\r\n    function cancelApprove(address user, uint256 amount, bool approve, bool isInvestment) external onlyFactory returns(address, address) {\r\n        if (approve) {    //approve cancel\r\n            _transfer(user, amount);\r\n        }\r\n        else {  // discard cancel request.\r\n            if (isInvestment)\r\n                user = _investAddress(user);   // on Ethereum side only\r\n            balanceOf[user] = balanceOf[user].add(amount);\r\n            totalSupply = totalSupply.add(amount);\r\n        }\r\n        return (token, tokenForeign);\r\n    }\r\n\r\n    // request to claim token after swap\r\n    function claim(address user, uint256 amount, bool isInvestment) external onlyFactory returns(bool) {\r\n        address userBalance;\r\n        if (isInvestment)\r\n            userBalance = _investAddress(user); // on BSC side only\r\n        else\r\n            userBalance = _swapAddress(user);\r\n        balanceOf[userBalance] = balanceOf[userBalance].add(amount);\r\n        return true;\r\n    }\r\n\r\n    // approve / discard claim request\r\n    function claimApprove(\r\n            address user,\r\n            uint256 amount, // foreign token amount to swap\r\n            uint256 nativeEncoded,\r\n            uint256 foreignSpent,\r\n            uint256 rate,\r\n            bool approve,\r\n            bool isInvestment\r\n        ) external onlyFactory returns(address, address, uint256 nativeAmount, uint256 rest) {\r\n        address userSwap;\r\n        if (isInvestment) {   //claim investment only on BSC side\r\n            userSwap = _investAddress(user);    // invest address (real user address - 1)\r\n        }\r\n        else {\r\n            userSwap = _swapAddress(user);  // swap address = real user address + 1\r\n        }\r\n\r\n        if(approve) { // approve claim\r\n            (nativeAmount, rest) = calculateAmount(amount,nativeEncoded,foreignSpent,rate);\r\n            if (rest != 0) {\r\n                balanceOf[userSwap] = balanceOf[userSwap].sub(rest);    // not all amount swapped\r\n            }\r\n            totalSupply = totalSupply.sub(nativeAmount,\"Not enough Total Supply\");\r\n            if (isInvestment)\r\n                ISwapFactory(factory).investAuction{value: nativeAmount}(payable(user));\r\n            else\r\n                _transfer(user, nativeAmount);\r\n        }\r\n        else {  // discard claim\r\n            balanceOf[userSwap] = balanceOf[userSwap].sub(amount);\r\n        }\r\n        return (token, tokenForeign, nativeAmount, rest);\r\n    }\r\n\r\n    function calculateAmount(\r\n        uint256 foreignAmount,\r\n        uint256 nativeEncoded,\r\n        uint256 foreignSpent,\r\n        uint256 rate    // Foreign token price / Native token price = (Native amount / Foreign amount)\r\n    ) internal returns(uint256 nativeAmount, uint256 rest) {\r\n        uint256 nativeDecimals = decimalsNative;\r\n        uint256 foreignDecimals = decimalsForeign;\r\n        \r\n        // step 1. Check is it enough unspent native tokens\r\n        {\r\n            (uint256 rate1, uint256 amount1) = _decode(nativeEncoded);  // rate1 = Native token price / Foreign token price\r\n            rate1 = rate1*NOMINATOR*foreignDecimals/nativeDecimals;\r\n            amount1 = amount1.sub(balanceOf[NATIVE], \"NativeSpent balance higher then remote\");\r\n            // rate1, amount1 - rate and amount ready to spend native tokens\r\n            if (amount1 != 0) {\r\n                uint256 requireAmount = foreignAmount.mul(PRICE_NOMINATOR*NOMINATOR).div(rate1);\r\n                if (requireAmount <= amount1) {\r\n                    nativeAmount = requireAmount;\r\n                    foreignAmount = 0;\r\n                }\r\n                else {\r\n                    nativeAmount = amount1;\r\n                    foreignAmount = (requireAmount - amount1).mul(rate1) / (PRICE_NOMINATOR*NOMINATOR);\r\n                }\r\n                balanceOf[NATIVE] = balanceOf[NATIVE].add(nativeAmount);\r\n            }\r\n        }\r\n        require(totalSupply >= nativeAmount,\"ERR: Not enough Total Supply\");\r\n        // step 2. recalculate rate for swapped tokens\r\n        if (foreignAmount != 0) {\r\n            uint256 rate2 = rate.mul(NOMINATOR).mul(nativeDecimals).div(foreignDecimals);\r\n            uint256 requireAmount = foreignAmount.mul(rate2) / (PRICE_NOMINATOR*NOMINATOR);\r\n            if (totalSupply < nativeAmount.add(requireAmount)) {\r\n                requireAmount = totalSupply.sub(nativeAmount);\r\n                rest = foreignAmount.sub(requireAmount.mul(PRICE_NOMINATOR*NOMINATOR).div(rate2));\r\n                foreignAmount = foreignAmount.sub(rest);\r\n            }\r\n            nativeAmount = nativeAmount.add(requireAmount);\r\n            uint256 amount;\r\n            (rate2, amount) = _decode(balanceOf[FOREIGN]);\r\n            rate2 = rate2.mul(NOMINATOR).mul(nativeDecimals).div(foreignDecimals);\r\n            uint256 amount2 = amount.sub(foreignSpent, \"ForeignSpent balance higher then local\");\r\n            // rate2, amount2 - rate and amount swapped foreign tokens\r\n\r\n            if (amount2 != 0) { // recalculate avarage rate (native amount / foreign amount)\r\n                rate =  ((amount2.mul(rate2)/(PRICE_NOMINATOR*NOMINATOR)).add(requireAmount)).mul(PRICE_NOMINATOR*foreignDecimals).div((amount2.add(foreignAmount)).mul(nativeDecimals));\r\n            }\r\n            balanceOf[FOREIGN] = _encode(rate, amount.add(foreignAmount));\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        require(msg.sender == factory, \"Not a factory\");\r\n    }\r\n}\r\n"},"TransferHelper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"}}}