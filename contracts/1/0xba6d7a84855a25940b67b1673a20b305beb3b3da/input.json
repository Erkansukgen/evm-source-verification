{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Sandwich.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n}\n\ninterface IWETH {\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface Gastoken {\n    function free(uint256 value) external returns (bool success);\n    function freeUpTo(uint256 value) external returns (uint256 freed);\n    function freeFrom(address from, uint256 value) external returns (bool success);\n    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n    function mint(uint256 value) external;\n}\n\ncontract Sandwich {\n\n    address owner = address(0x8C14877fe86b23FCF669350d056cDc3F2fC27029);\n    IWETH weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    constructor() {}\n    receive() external payable {}\n    fallback() external payable {}\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function mintGastoken(address gasTokenAddress, uint _amount) external {\n        Gastoken(gasTokenAddress).mint(_amount);\n    }\n\n    function withdrawERC20(address _token, uint _amount) external onlyOwner {\n        IERC20(_token).transfer(msg.sender, _amount);\n    }\n\n    function approveMax(address router, address token) external onlyOwner {\n        IERC20(token).approve(router, type(uint).max);\n    }\n\n    function _swapExactTokensToTokens(\n        address gasTokenAddress,\n        uint amountToFree,\n        address inputToken,\n        uint256 inputAmount,\n        uint256 minOutAmount,\n        address recipient,\n        // IUniswapV2Pair[] calldata pairs,\n        IUniswapV2Pair p,\n        // bool[] calldata whichToken\n        bool whichToken\n    ) external onlyOwner {\n        require(Gastoken(gasTokenAddress).free(amountToFree));\n        // Last trade, check for slippage here\n        if (whichToken) { // Check what token are we buying, 0 or 1 ?\n            // 1\n            (uint256 reserveIn, uint256 reserveOut,) = p.getReserves();\n            require(IERC20(inputToken).transfer(address(p), inputAmount), \"Transfer to pair failed\");\n\n            inputAmount = inputAmount * 997; // Calculate after fee\n            inputAmount = (inputAmount * reserveOut)/(reserveIn * 1000 + inputAmount); // Calculate outputNeeded\n            // require(inputAmount >= minOutAmount, \"JRouter: not enough out tokens\"); // Checking output amount\n            p.swap(0, inputAmount, recipient, \"\"); // Swapping\n        } else {\n            // 0\n            (uint256 reserveOut, uint256 reserveIn,) = p.getReserves();\n            require(IERC20(inputToken).transfer(address(p), inputAmount), \"Transfer to pair failed\");\n\n            inputAmount = inputAmount * 997; // Calculate after fee\n            inputAmount = (inputAmount * reserveOut)/(reserveIn * 1000 + inputAmount); // Calculate outputNeeded\n            require(inputAmount >= minOutAmount, \"JRouter: not enough out tokens\"); // Checking output amount\n            p.swap(inputAmount, 0, recipient, \"\"); // Swapping\n        }\n    }\n\n    function _swapExactTokensToWETHAndBribe(\n        address gasTokenAddress,\n        uint amountToFree,\n        address inputToken,\n        uint256 minOutAmount,\n        address recipient,\n        IUniswapV2Pair p,\n        bool whichToken,\n        uint bribeAmount,\n        uint bribePercentage\n    ) external onlyOwner {\n        uint startBalance = weth.balanceOf(address(this));\n        require(Gastoken(gasTokenAddress).free(amountToFree));\n        // Last trade, check for slippage here\n        uint inputAmount = IERC20(inputToken).balanceOf(address(this));\n        if (whichToken) { // Check what token are we buying, 0 or 1 ?\n            // 1\n            (uint256 reserveIn, uint256 reserveOut,) = p.getReserves();\n            require(IERC20(inputToken).transfer(address(p), inputAmount), \"Transfer to pair failed\");\n\n            inputAmount = inputAmount * 997; // Calculate after fee\n            inputAmount = (inputAmount * reserveOut)/(reserveIn * 1000 + inputAmount); // Calculate outputNeeded\n            // require(inputAmount >= minOutAmount, \"JRouter: not enough out tokens\"); // Checking output amount\n            p.swap(0, inputAmount, recipient, \"\"); // Swapping\n        } else {\n            // 0\n            (uint256 reserveOut, uint256 reserveIn,) = p.getReserves();\n            require(IERC20(inputToken).transfer(address(p), inputAmount), \"Transfer to pair failed\"); // Breaks on Tether\n            // IERC20(inputToken).transfer(address(p), inputAmount);\n\n            inputAmount = inputAmount * 997; // Calculate after fee\n            inputAmount = (inputAmount * reserveOut)/(reserveIn * 1000 + inputAmount); // Calculate outputNeeded\n            // require(inputAmount >= minOutAmount, \"JRouter: not enough out tokens\"); // Checking output amount\n            p.swap(inputAmount, 0, recipient, \"\"); // Swapping\n        }\n\n        uint balance = weth.balanceOf(address(this));\n        uint profit = balance - startBalance - minOutAmount; // This reverts if not profitable\n        if (bribeAmount == 0) {\n            bribeAmount = profit * bribePercentage / 100;\n        }\n\n        require(profit > bribeAmount, \"Not enough money to pay bribe\"); // however, we may not have enough for the bribe\n        weth.withdraw(bribeAmount);\n        block.coinbase.call{value: bribeAmount}(new bytes(0));\n    }\n}"}}}