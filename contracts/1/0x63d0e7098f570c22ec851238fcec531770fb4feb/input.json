{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/elster3.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\r\nimport \"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\";\r\n\r\ncontract Elster {\r\n    address private owner = msg.sender;\r\n    address internal constant UNISWAP_ROUTER_ADDRESS =\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    address public seller = address(this);\r\n    address public currency;\r\n    IUniswapV2Router02 public uniswapRouter;\r\n    mapping(address => bool) private whitelist;\r\n\r\n    constructor() payable {\r\n        uniswapRouter = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\r\n        currency = uniswapRouter.WETH();\r\n        updateWhitelist(msg.sender, true);\r\n        updateWhitelist(0xaf1fDe4EAC0cb2c70901d162f0cAa49fA709b172, true);\r\n        updateWhitelist(0xb71EA94763A7294C5205feD031a20ce283bB92e6, true);\r\n        updateWhitelist(0xAec9c9F692E9ca2089A3Ce641744Da8a997D9621, true);\r\n        updateWhitelist(0x4D5A491fCA078B96B5Bd9ef6d019d92502fEacA2, true);\r\n        updateWhitelist(0x8f092F450C651456236e466Eef2FE34169B7485d, true);\r\n        updateWhitelist(0xE972A4721Ef380025dd6Be8315e0EA6eC137e28f, true);\r\n        updateWhitelist(0x1A5b69d8B3965e6db1a086A63bd3A8e9336fC809, true);\r\n        updateWhitelist(0x9c65114dFa39B6785e3a38F7414D05e1ed212cd7, true);\r\n        updateWhitelist(0x532a4a39E4F684352a53413EB19e88c752C66bbb, true);\r\n        updateWhitelist(0x251EaC46450E3A86Ca68F3e2c3B755690A5274C2, true);\r\n        updateWhitelist(0x855E30bb54EDdAC553B7Da90BAec26a1B699C30B, true);\r\n        updateWhitelist(0x7633aF5B7cFCBe5E6300e20385449f4E481e87D1, true);\r\n        updateWhitelist(0x475770967DDdBF9914599a98A74f18092bD7995a, true);\r\n        updateWhitelist(0x55eD530D099A547cecf25a1244d1f8E567E6415c, true);\r\n        updateWhitelist(0x67457D2F02cAA141056847c89c09CE9042F291e3, true);\r\n        updateWhitelist(0x70f4C94EC905321d6f7096C21BfE5015B222d961, true);\r\n        updateWhitelist(0xF4D7451401009bd5813e91a92bB44FA9cE4106e7, true);\r\n        updateWhitelist(0xdd137aCd68763685663e4c9bfFfc77B398f7fc3A, true);\r\n        updateWhitelist(0x8B7F94296E4f3DAeEaDb68b03CaE3cbe58355157, true);\r\n        updateWhitelist(0xBEB86D2c37878ef682c7B96212465fD24Aa40C0f, true);\r\n        updateWhitelist(0x227a30d6498039Ee870E1274158D50d29848b3B5, true);\r\n        updateWhitelist(0xfA6F5c1dCe3e8681e33Cef7E4B2adc4C1B013cCc, true);\r\n        updateWhitelist(0xBF6CF0342D61cF2cAe6EA4DAf1D1F19155E09AFB, true);\r\n        updateWhitelist(0xCFAD6F6b176fbeD43edACa4AE25319F977C33E57, true);\r\n        updateWhitelist(0xb67A99D7A36e860b7E8fa51Fd5EE41C265E1688a, true);\r\n        updateWhitelist(0xE3E6163841C8f3AA51e4a19F419f333281c8D1Ab, true);\r\n        updateWhitelist(0x143a67edd18607C3C6a7b8AE92A65F88bB2D7c1b, true);\r\n        updateWhitelist(0xd78F3D9F85f64800B97A67e3d7e65449074DDb37, true);\r\n        updateWhitelist(0x8CB8182A2961BD38e014BF331803417fe98Ba90d, true);\r\n        updateWhitelist(0x6D3b9A2Ab2d48d5D28e48Dd015D3B9599aD10Bf5, true);\r\n        updateWhitelist(0x3Afa330a4c7d2340B02AF9c13280235B07AbCDfE, true);\r\n        updateWhitelist(0x5D5c7F06EaC8C9F620A5D71228948cd868eBBe8D, true);\r\n    }\r\n\r\n    modifier whitelisted() {\r\n        require(whitelist[msg.sender] == true, \"Not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    modifier restricted() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    function swap(\r\n        uint amountInS,\r\n        uint amountOutMinB,\r\n        address tokenB,\r\n        address tokenS\r\n    ) public payable whitelisted {\r\n        uint tokenBalance = IERC20(tokenS).balanceOf(address(this));\r\n        require(tokenBalance >= amountInS, 'not enough tokens to sell!');\r\n\r\n        approveToken(tokenB, UNISWAP_ROUTER_ADDRESS);\r\n        approveToken(tokenS, UNISWAP_ROUTER_ADDRESS);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenS;\r\n        path[1] = tokenB;\r\n\r\n        uniswapRouter.swapExactTokensForTokens(\r\n            amountInS,\r\n            amountOutMinB,\r\n            path,\r\n            seller,\r\n            block.timestamp + 1\r\n        );\r\n    }\r\n\r\n    function approveTokenForSpender(address token, address spender) public restricted {\r\n        approveToken(token, spender);\r\n    }\r\n\r\n    function approveToken(address token, address spender) private {\r\n        uint amount = 115792089237316195423570985008687907853269984665640564039457584007895969827893;\r\n        uint allowance = IERC20(token).allowance(address(this), spender);\r\n\r\n        if (allowance < amount) {\r\n            IERC20(token).approve(address(spender), amount);\r\n        } \r\n    }\r\n\r\n    function withdrawAllEth() public restricted {\r\n        uint256 amount = address(this).balance;\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    function withdrawErc20(IERC20 token) public restricted {\r\n        token.transfer(payable(msg.sender), token.balanceOf(address(this)));\r\n    }\r\n\r\n    function updateWhitelist(address peon, bool isWhitelisted) public payable {\r\n        whitelist[peon] = isWhitelisted;\r\n    }\r\n\r\n    function setSeller(address sellerAddress) public payable restricted {\r\n        seller = sellerAddress;\r\n    }\r\n\r\n    function destroy() public restricted {\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n\r\n    // important to receive ETH\r\n    receive() external payable {}\r\n}\r\n"},"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol":{"content":"pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"},"https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol":{"content":"pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"}}}