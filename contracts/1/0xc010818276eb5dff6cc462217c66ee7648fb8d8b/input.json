{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/1_Storage.sol": {
      "content": "pragma solidity ^0.6.12;\n\ninterface IStarknetCore {\n    /**\n      Sends a message to an L2 contract.\n\n      Returns the hash of the message.\n    */\n    function sendMessageToL2(\n        uint256 to_address,\n        uint256 selector,\n        uint256[] calldata payload\n    ) external returns (bytes32);\n\n    /**\n      Consumes a message that was sent from an L2 contract.\n\n      Returns the hash of the message.\n    */\n    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)\n        external\n        returns (bytes32);\n}\n\n/**\n  Demo contract for L1 <-> L2 interaction between an L2 StarkNet contract and this L1 solidity\n  contract.\n*/\ncontract StarkNetGraffiti {\n    // The StarkNet core contract.\n    IStarknetCore public starknetCore;\n\n    // The selector of the \"graffOnStarkNetFromMainnet\" l1_handler.\n    uint256 public GRAFF_SELECTOR; \n    // The address of the L2 graff contract\n    uint256 public l2MessengerContractAddress;\n\n    // An owner who can modify the graff contract\n    address public owner;\n\n    event messageReceivedFromStarkNet(string stringMessage);\n    event messageSentToStarkNet(string stringMessage);\n\n    constructor() public \n    {   \n      owner = msg.sender;\n    }\n\n\n    function graffFromStarknetOnMainnet(bytes32 messageToGraff) \n    public \n    {\n        // Construct the withdrawal message's payload.\n        uint256[] memory payload = new uint256[](1);\n        payload[0] = uint256(messageToGraff);\n\n        // Consume the message from the StarkNet core contract.\n        // This will revert the (Ethereum) transaction if the message does not exist.\n        starknetCore.consumeMessageFromL2(l2MessengerContractAddress, payload);\n        emit messageReceivedFromStarkNet(customizedBytes32ToString(messageToGraff));\n    }\n\n    function graffFromMainnetOnStarknet(bytes32 messageToGraff) \n    public \n    {\n       \n        // Construct the deposit message's payload.\n        uint256[] memory payload = new uint256[](1);\n        payload[0] = uint256(messageToGraff);\n\n        // Send the message to the StarkNet core contract.\n        starknetCore.sendMessageToL2(l2MessengerContractAddress, GRAFF_SELECTOR, payload);\n        emit messageSentToStarkNet(customizedBytes32ToString(messageToGraff));\n    }\n\n    function multiGraffs(bytes32[] memory messageToGraff)\n    external\n    {\n        for (uint i = 0; i < messageToGraff.length; i++)\n        {\n            graffFromStarknetOnMainnet(messageToGraff[i]);\n        }\n    }\n\n    // Setup, permissions and utility\n\n    function setL2Graffer(IStarknetCore starknetCore_, uint256 l2MessengerContractAddress_, uint256 GRAFF_SELECTOR_)\n    public\n    onlyOwner\n    {\n        starknetCore = starknetCore_;   \n        l2MessengerContractAddress = l2MessengerContractAddress_;\n        GRAFF_SELECTOR = GRAFF_SELECTOR_;\n    }\n\n    modifier onlyOwner() \n    {\n\n        require(msg.sender == owner);\n        _;\n    }\n\n    function customizedBytes32ToString(bytes32 _bytes32) \n    public \n    pure \n    returns (string memory) \n    {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        uint offset = i;\n        bytes memory bytesArray = new bytes(32-offset);\n        for (i = 0; i < 32-offset; i++) {\n            bytesArray[i] = _bytes32[i+offset];\n        }\n        return string(bytesArray);\n    }\n    \n\n\n\n}"
    }
  }
}