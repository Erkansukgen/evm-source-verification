{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"browser/Trader.sol":{"content":"pragma solidity ^0.6.6;\r\n\r\nimport \"https://github.com/aave/flashloan-box/blob/Remix/contracts/aave/ILendingPoolAddressesProvider.sol\";\r\nimport \"https://github.com/aave/flashloan-box/blob/Remix/contracts/aave/ILendingPool.sol\";\r\n\r\n\r\ncontract RopstenAddresses {\r\n    address payable internal constant KYBER = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n    address payable internal constant UNISWAP = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;\r\n    address internal constant PBTC = 0xEB770B1883Dcce11781649E8c4F1ac5F4B40C978;\r\n    address internal constant DAI = 0xaD6D458402F60fD3Bd25163575031ACDce07538D;\r\n    address internal constant MANA = 0x72fd6C7C1397040A66F33C2ecC83A0F71Ee46D5c;\r\n    address internal constant BAT = 0xDb0040451F373949A4Be60dcd7b6B8D6E42658B6;\r\n    //Uniswap WETH 0xc778417e063141139fce010982780140aa0cd5ab\r\n}\r\n\r\ncontract Ownable {\r\n    address payable private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address payable) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Withdrawable is Ownable {\r\n    function withdrawEther() external onlyOwner {\r\n        this.owner().transfer(address(this).balance);\r\n    }\r\n    \r\n    function withdrawToken(ERC20 token) external onlyOwner {\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n    \r\n    function etherBalance() external view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n    function tokenBalance(ERC20 token) external view returns (uint) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Payable {\r\n    receive() external payable { }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() external view returns(uint);\r\n    function getUserCapInWei(address user) external view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) external view returns(uint);\r\n    function enabled() external view returns(bool);\r\n    function info(bytes32 id) external view returns(uint);\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,uint minConversionRate, address walletId, bytes calldata hint) external payable returns(uint);\r\n    function swapEtherToToken(ERC20 token, uint minRate) external payable returns (uint);\r\n    function swapTokenToEther(ERC20 token, uint tokenQty, uint minRate) external returns (uint);\r\n}\r\n\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\r\n}\r\n\r\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver, Payable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address constant ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    ILendingPoolAddressesProvider public addressesProvider;\r\n\r\n    constructor(address _addressProvider) public {\r\n        addressesProvider = ILendingPoolAddressesProvider(_addressProvider);\r\n    }\r\n\r\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {\r\n        address payable core = addressesProvider.getLendingPoolCore();\r\n        transferInternal(core, _reserve, _amount);\r\n    }\r\n\r\n    function transferInternal(address payable _destination, address _reserve, uint256 _amount) internal {\r\n        if(_reserve == ethAddress) {\r\n            (bool success, ) = _destination.call{value: _amount}(\"\");\r\n            require(success == true, \"Couldn't transfer ETH\");\r\n            return;\r\n        }\r\n        ERC20(_reserve).transfer(_destination, _amount);\r\n    }\r\n\r\n    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {\r\n        if(_reserve == ethAddress) {\r\n            return _target.balance;\r\n        }\r\n        return ERC20(_reserve).balanceOf(_target);\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n  function WETH() external pure returns (address);\r\n\r\n//   function addLiquidity(\r\n//       address tokenA,\r\n//       address tokenB,\r\n//       uint amountADesired,\r\n//       uint amountBDesired,\r\n//       uint amountAMin,\r\n//       uint amountBMin,\r\n//       address to,\r\n//       uint deadline\r\n//   ) external returns (uint amountA, uint amountB, uint liquidity);\r\n//   function addLiquidityETH(\r\n//       address token,\r\n//       uint amountTokenDesired,\r\n//       uint amountTokenMin,\r\n//       uint amountETHMin,\r\n//       address to,\r\n//       uint deadline\r\n//   ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n//   function removeLiquidity(\r\n//       address tokenA,\r\n//       address tokenB,\r\n//       uint liquidity,\r\n//       uint amountAMin,\r\n//       uint amountBMin,\r\n//       address to,\r\n//       uint deadline\r\n//   ) external returns (uint amountA, uint amountB);\r\n//   function removeLiquidityETH(\r\n//       address token,\r\n//       uint liquidity,\r\n//       uint amountTokenMin,\r\n//       uint amountETHMin,\r\n//       address to,\r\n//       uint deadline\r\n//   ) external returns (uint amountToken, uint amountETH);\r\n//   function removeLiquidityWithPermit(\r\n//       address tokenA,\r\n//       address tokenB,\r\n//       uint liquidity,\r\n//       uint amountAMin,\r\n//       uint amountBMin,\r\n//       address to,\r\n//       uint deadline,\r\n//       bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n//   ) external returns (uint amountA, uint amountB);\r\n//   function removeLiquidityETHWithPermit(\r\n//       address token,\r\n//       uint liquidity,\r\n//       uint amountTokenMin,\r\n//       uint amountETHMin,\r\n//       address to,\r\n//       uint deadline,\r\n//       bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n//   ) external returns (uint amountToken, uint amountETH);\r\n  function swapExactTokensForTokens(\r\n      uint amountIn,\r\n      uint amountOutMin,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapTokensForExactTokens(\r\n      uint amountOut,\r\n      uint amountInMax,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n  ) external returns (uint[] memory amounts);\r\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n      external\r\n      returns (uint[] memory amounts);\r\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n      external\r\n      payable\r\n      returns (uint[] memory amounts);\r\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\nabstract contract Exchange is Withdrawable, Payable {\r\n    address public exchangeAddress;\r\n    \r\n    function setupExchange(address payable _address) virtual external;\r\n    function swapEtherToToken(ERC20 token, uint price) virtual external payable returns (uint amount);\r\n    function swapTokenToEther(ERC20 token, uint quantity, uint price) virtual external returns (uint amount);\r\n    function rate(ERC20 source, ERC20 destination, uint quantity) virtual external view returns (uint price, uint slippageRate);\r\n    function swap(ERC20 source, ERC20 destination, uint quantity,uint price) virtual external payable returns(uint amount);\r\n}\r\n\r\ncontract KyberExchange is Exchange {\r\n    KyberNetworkProxyInterface internal exchange;\r\n    \r\n    constructor() public {\r\n        exchangeAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\r\n        exchange = KyberNetworkProxyInterface(exchangeAddress);\r\n    }\r\n    \r\n    function setupExchange(address payable _address) override onlyOwner external {\r\n        exchangeAddress = _address;\r\n        exchange = KyberNetworkProxyInterface(_address);\r\n    }\r\n    \r\n    function swapEtherToToken(ERC20 token, uint price) override public payable returns (uint){\r\n        uint qty = exchange.swapEtherToToken{value:msg.value}(token, price);\r\n        require(token.transfer(msg.sender, qty));\r\n        return qty;\r\n    }\r\n\r\n    function swapTokenToEther(ERC20 token, uint quantity, uint price) override external returns (uint){\r\n        token.approve(exchangeAddress, quantity);\r\n        uint qty = exchange.swapTokenToEther(token, quantity, price);\r\n        (msg.sender).transfer(qty);\r\n        return qty;\r\n    }\r\n\r\n    function rate(ERC20 source, ERC20 destination, uint quantity) override external view returns (uint expectedRate, uint slippageRate){\r\n        return exchange.getExpectedRate(source, destination, quantity);\r\n    }\r\n    \r\n    function swap(ERC20 source, ERC20 destination, uint quantity,uint price) override external payable returns(uint){\r\n        source.approve(exchangeAddress, quantity);\r\n        return exchange.tradeWithHint(source, quantity, destination, msg.sender, 100000000000000000000000000000000000 , price, 0x0000000000000000000000000000000000000000,'');\r\n    }\r\n}\r\n\r\ncontract UniswapExchange is Exchange {\r\n    IUniswapV2Router01 private exchange;\r\n    address WETH; \r\n    constructor() public {\r\n        exchangeAddress = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;\r\n        exchange = IUniswapV2Router01(exchangeAddress);\r\n        WETH = exchange.WETH();\r\n    }\r\n    \r\n    function setupExchange(address payable _address) override onlyOwner external {\r\n        exchangeAddress = _address;\r\n        exchange = IUniswapV2Router01(_address);\r\n    }\r\n    \r\n    function getPath(address a1, address a2) private pure returns (address[] memory amounts) {\r\n        //return [a1,a2];\r\n        \r\n        //for testing \r\n        // if (a1 == WETH || a2 == WETH){\r\n        //     address[] memory array = new address[](2);\r\n        //     array[0] = a1;\r\n        //     array[1] = a2;\r\n        //     return array;\r\n        // } else {\r\n        //     address[] memory array = new address[](3);\r\n        //     array[0] = a1;\r\n        //     array[1] = WETH;//swap tokens via WETH because for testing most pairs dont exist\r\n        //     array[2] = a2;\r\n        //     return array;\r\n        // }\r\n        \r\n        address[] memory array = new address[](2);\r\n        array[0] = a1;\r\n        array[1] = a2;\r\n        return array;\r\n    }\r\n    \r\n    function swapEtherToToken(ERC20 token, uint price) override external payable returns (uint){\r\n        address[] memory path = getPath(WETH, address(token));\r\n        uint amountOut = (msg.value*price)/10**18;\r\n        uint[] memory amounts = exchange.swapExactETHForTokens{value:msg.value}(amountOut, path, msg.sender, now + 60*5);\r\n        return amounts[amounts.length-1];\r\n    }\r\n\r\n    function swapTokenToEther(ERC20 token, uint quantity, uint price) override external returns (uint){\r\n        token.approve(exchangeAddress, quantity);\r\n        address[] memory path = getPath(address(token), WETH);\r\n        uint amountOutMin = (quantity*price)/10**18;\r\n        uint[] memory amounts = exchange.swapExactTokensForETH(quantity, amountOutMin,path, msg.sender, now + 60*5);\r\n        return amounts[amounts.length-1];\r\n    }\r\n    \r\n    function swap(ERC20 source, ERC20 destination, uint quantity,uint price) override external payable returns(uint) {\r\n        source.approve(exchangeAddress, quantity);\r\n        address[] memory path = getPath(address(source), address(destination));\r\n        uint amountOutMin = (quantity*price)/10**18;\r\n        uint[] memory amounts = exchange.swapExactTokensForTokens(quantity, amountOutMin, path, msg.sender,now + 60*5);\r\n        return amounts[amounts.length-1];\r\n    }\r\n    \r\n    //\"0x6b175474e89094c44da98b954eedeac495271d0f\",\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\",\"1000000000000\" mainnet\r\n    function rate(ERC20 source, ERC20 destination, uint quantity) override external view returns (uint expectedRate, uint slippageRate){\r\n        address[] memory path = getPath(address(source), address(destination));\r\n        uint[] memory amounts = exchange.getAmountsOut(quantity,path);\r\n        //this is wrong should not be dividing by 10*18 but by the number of decimals places of the source token\r\n        return ((amounts[amounts.length-1]*10**18)/quantity, 0);\r\n    }\r\n}\r\n\r\ncontract Trader is Payable, Withdrawable {\r\n    \r\n    constructor() public {}\r\n    \r\n    function depositEtherToToken(Exchange exchange, ERC20 token, uint rate) external payable returns (uint) {\r\n        return exchange.swapEtherToToken{value:msg.value}(token, rate);//{value : msg.value}\r\n    }\r\n    \r\n    function swapTokenToEther(Exchange exchange, ERC20 token, uint quantity, uint rate) external returns (uint) {\r\n        uint qty = this.tokenBalance(token);\r\n        require(token.transfer(address(exchange), qty));\r\n        return exchange.swapTokenToEther(token, quantity, rate);\r\n    }\r\n    \r\n    //\"0x90b1aE35202A2a1b41194139FEe4DaF49B10f9F4\",\"0x4A301331fb544BCa887050476fa4eAEEfd5B82E2\",\"0xDb0040451F373949A4Be60dcd7b6B8D6E42658B6\",\"0xaD6D458402F60fD3Bd25163575031ACDce07538D\",\"1061100215235000000\",\"1\",\"1\"\r\n    function arb(Exchange exchange1, Exchange exchange2, ERC20 source, ERC20 destination, uint quantity, uint buyPrice, uint sellPrice) external returns (uint) {\r\n        //swap source to destination on exchange1\r\n        require(source.transfer(address(exchange1), quantity));\r\n        uint sellQuantity = exchange1.swap(source, destination, quantity, buyPrice);\r\n        //swap destination back to source on exchange2\r\n        require(destination.transfer(address(exchange2), sellQuantity));\r\n        uint endQuantity = exchange2.swap(destination, source, sellQuantity, sellPrice);\r\n        //as long as we have more than we started with trade is a success\r\n        require(endQuantity >= quantity);\r\n        return endQuantity;\r\n    }\r\n    \r\n    function rate(Exchange exchange, ERC20 src, ERC20 dest, uint qty) external view returns (uint) {\r\n        (uint exchangeRate,) = exchange.rate(src, dest, qty);\r\n        return exchangeRate;\r\n    }\r\n    \r\n    function allRates(Exchange[] calldata exchanges, ERC20[] calldata sources, ERC20[] calldata destinations, uint[] calldata quantities) external view returns (uint[] memory) {\r\n        uint[] memory prices = new uint[](2);\r\n        for (uint i = 0; i < exchanges.length; i++) {\r\n            prices[i] = this.rate(exchanges[i], sources[i], destinations[i], quantities[i]);\r\n        }\r\n        return prices;\r\n    }\r\n}\r\n\r\ncontract FlashLoanTrader is Trader, FlashLoanReceiverBase {\r\n\r\n    constructor(address _addressProvider) FlashLoanReceiverBase(_addressProvider) public {}\r\n\r\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external override {\r\n        require(_amount <= getBalanceInternal(address(this), _reserve), \"Invalid balance, was the flashLoan successful?\");\r\n\r\n        //\r\n        // Your logic goes here.\r\n        // !! Ensure that *this contract* has enough of `_reserve` funds to payback the `_fee` !!\r\n        //\r\n\r\n        uint totalDebt = _amount.add(_fee);\r\n        transferFundsBackToPoolInternal(_reserve, totalDebt);\r\n    }\r\n\r\n    //Flash loan 1000000000000000000 wei (1 ether) worth of `_asset`\r\n    function flashloan(address _asset) public onlyOwner {\r\n        bytes memory data = \"\";\r\n        uint amount = 1 ether;\r\n\r\n        ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());\r\n        lendingPool.flashLoan(address(this), _asset, amount, data);\r\n    }\r\n}\r\n\r\ncontract HasExchangesAndTokens {\r\n    Exchange internal exchange1;\r\n    Exchange internal exchange2;\r\n    ERC20 internal token1;\r\n    ERC20 internal token2;\r\n    \r\n    function setExchange1(address payable _address) external{\r\n        exchange1 = Exchange(_address);\r\n    }\r\n    \r\n    function setExchange2(address payable _address) external{\r\n        exchange2 = Exchange(_address);\r\n    }\r\n    \r\n    function setToken1(address _address) external{\r\n        token1 = ERC20(_address);\r\n    }\r\n    \r\n    function setToken2(address _address) external{\r\n        token2 = ERC20(_address);\r\n    }\r\n    \r\n    function exchanges() external view  returns (address, address) {\r\n        return (address(exchange1), address(exchange2));\r\n    }\r\n    \r\n    function tokens() external view  returns (address, address) {\r\n        return (address(token1), address(token2));\r\n    }\r\n    \r\n    function swapExchanges() external {\r\n        Exchange temp = exchange1;\r\n        exchange1 = exchange2;\r\n        exchange2 = temp;\r\n    }\r\n    \r\n    function tokensBalance() external view returns (uint, uint) {\r\n        return (token1.balanceOf(address(this)), token2.balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract ExchangeTester is Trader, HasExchangesAndTokens, RopstenAddresses {\r\n    constructor() public {\r\n        //Kyber\r\n        exchange1 = Exchange(0xDb0040451F373949A4Be60dcd7b6B8D6E42658B6);\r\n        //Uniswap\r\n        exchange2 = Exchange(0x90b1aE35202A2a1b41194139FEe4DaF49B10f9F4);\r\n        token1 = ERC20(DAI);\r\n        token2 = ERC20(BAT);\r\n    }\r\n    \r\n    function testAll() external payable returns (uint,uint,uint) {\r\n        uint token1 = this.testETHtoToken1{value:msg.value}();\r\n        uint token2 = this.testToken1toToken2();\r\n        uint eth = this.testToken2toETH();\r\n        return (token1,token2,eth);\r\n    }\r\n    //swapEtherToToken\r\n    function testETHtoToken1() external payable returns (uint) {\r\n        return this.depositEtherToToken{value:msg.value}(exchange1, token1, 1);\r\n    }\r\n    //swapTokenToToken\r\n    function testToken1toToken2() external returns (uint) {\r\n        uint qty = this.tokenBalance(token1);\r\n        require(token1.transfer(address(exchange1), qty));\r\n        return exchange1.swap(token1, token2, qty, 1);\r\n    }\r\n    function testToken1toToken2Exchange2() internal returns (uint) {\r\n        uint qty = this.tokenBalance(token1);\r\n        require(token1.transfer(address(exchange2), qty));\r\n        return exchange2.swap(token1, token2, qty, 1);\r\n    }\r\n    //swapTokenToEther\r\n    function testToken2toETH() external returns (uint) {\r\n        uint qty = this.tokenBalance(token2);\r\n        require(token2.transfer(address(exchange1), qty));\r\n        return exchange1.swapTokenToEther(token2, qty, 1);\r\n    }\r\n    \r\n    function testTransToken1toExch1() external returns (uint) {\r\n        uint qty = this.tokenBalance(token1);\r\n        require(token1.transfer(address(exchange1), qty));\r\n        return qty;\r\n    }\r\n    \r\n    function testArbBetweenExchanges() external payable returns (uint) {\r\n        this.testETHtoToken1{value:msg.value}();\r\n        testToken1toToken2Exchange2();\r\n        return this.testToken2toETH();\r\n    }\r\n    \r\n    function rateToken1ToToken2(uint srcQty) external view returns (uint expectedRate, uint slippageRate){\r\n        return exchange1.rate(token1, token2, srcQty);\r\n    }\r\n    \r\n    function testAllRates() external view returns (uint[] memory) {\r\n        Exchange[] memory exchanges = new Exchange[](2);\r\n        ERC20[] memory sources = new ERC20[](2);\r\n        ERC20[] memory destinations = new ERC20[](2);\r\n        uint[] memory quantities = new uint[](2);\r\n        exchanges[1] = exchange1;\r\n        exchanges[2] = exchange2;\r\n        sources[1] = token1;\r\n        sources[2] = token2;\r\n        destinations[1] = token2;\r\n        destinations[2] = token1;\r\n        quantities[1] = 1000000000000;\r\n        quantities[2] = 1000000000000;\r\n        \r\n        return this.allRates(exchanges, sources, destinations, quantities);\r\n    }\r\n}\r\n"},"https://github.com/aave/flashloan-box/blob/Remix/contracts/aave/ILendingPool.sol":{"content":"pragma solidity ^0.6.6;\n\ninterface ILendingPool {\n  function addressesProvider () external view returns ( address );\n  function deposit ( address _reserve, uint256 _amount, uint16 _referralCode ) external payable;\n  function redeemUnderlying ( address _reserve, address _user, uint256 _amount ) external;\n  function borrow ( address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode ) external;\n  function repay ( address _reserve, uint256 _amount, address _onBehalfOf ) external payable;\n  function swapBorrowRateMode ( address _reserve ) external;\n  function rebalanceFixedBorrowRate ( address _reserve, address _user ) external;\n  function setUserUseReserveAsCollateral ( address _reserve, bool _useAsCollateral ) external;\n  function liquidationCall ( address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveAToken ) external payable;\n  function flashLoan ( address _receiver, address _reserve, uint256 _amount, bytes calldata _params ) external;\n  function getReserveConfigurationData ( address _reserve ) external view returns ( uint256 ltv, uint256 liquidationThreshold, uint256 liquidationDiscount, address interestRateStrategyAddress, bool usageAsCollateralEnabled, bool borrowingEnabled, bool fixedBorrowRateEnabled, bool isActive );\n  function getReserveData ( address _reserve ) external view returns ( uint256 totalLiquidity, uint256 availableLiquidity, uint256 totalBorrowsFixed, uint256 totalBorrowsVariable, uint256 liquidityRate, uint256 variableBorrowRate, uint256 fixedBorrowRate, uint256 averageFixedBorrowRate, uint256 utilizationRate, uint256 liquidityIndex, uint256 variableBorrowIndex, address aTokenAddress, uint40 lastUpdateTimestamp );\n  function getUserAccountData ( address _user ) external view returns ( uint256 totalLiquidityETH, uint256 totalCollateralETH, uint256 totalBorrowsETH, uint256 availableBorrowsETH, uint256 currentLiquidationThreshold, uint256 ltv, uint256 healthFactor );\n  function getUserReserveData ( address _reserve, address _user ) external view returns ( uint256 currentATokenBalance, uint256 currentUnderlyingBalance, uint256 currentBorrowBalance, uint256 principalBorrowBalance, uint256 borrowRateMode, uint256 borrowRate, uint256 liquidityRate, uint256 originationFee, uint256 variableBorrowIndex, uint256 lastUpdateTimestamp, bool usageAsCollateralEnabled );\n  function getReserves () external view;\n}"},"https://github.com/aave/flashloan-box/blob/Remix/contracts/aave/ILendingPoolAddressesProvider.sol":{"content":"pragma solidity ^0.6.6;\n\n/**\n    @title ILendingPoolAddressesProvider interface\n    @notice provides the interface to fetch the LendingPoolCore address\n */\n\ninterface ILendingPoolAddressesProvider {\n    function getLendingPoolCore() external view returns (address payable);\n    function getLendingPool() external view returns (address);\n}"}}}