{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/MultiSend.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract SendETH {\r\n    \r\n    constructor () {}\r\n    function multiTokenTranser(address token, address[] memory  addrs, uint256[] memory amounts) public returns (bool) {\r\n\t    require(addrs.length == amounts.length, \"size isn't same\");\r\n\t    uint total = 0;\r\n\t    uint i;\r\n\t    uint n = amounts.length;\r\n\t    \r\n\t    \r\n\t    for (i = 0; i < n; i++) total += amounts[i];\r\n\t    require(IERC20(token).allowance(msg.sender, address(this)) >= total, \"allowance is not enough\");\r\n        \r\n        for (i = 0; i < n; i++) \r\n            if (amounts[i] > 0)\r\n            {\r\n                IERC20(token).transferFrom(msg.sender, addrs[i], amounts[i]);\r\n            }\r\n        \r\n\t\treturn true;\r\n    }\r\n\tfunction multiSend(address payable[] memory  addrs, uint256[] memory amounts) public payable returns (bool) {\r\n\t    require(addrs.length == amounts.length, \"size isn't same\");\r\n\t    uint total = 0;\r\n\t    uint i;\r\n\t    uint n = amounts.length;\r\n\t    \r\n\t    for (i = 0; i < n; i++) total += amounts[i];\r\n\t    require(address(this).balance >= total, \"eth is not enough\");\r\n        \r\n        for (i = 0; i < n; i++) \r\n            if (amounts[i] > 0)\r\n            {\r\n                addrs[i].transfer(amounts[i]);\r\n            }\r\n        \r\n\t\treturn true;\r\n    }\r\n    \r\n    \r\n}"}}}