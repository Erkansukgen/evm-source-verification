{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/Context.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor()  {}\n\n    function _msgSender() internal view returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n"},"contracts/GainToken.sol":{"content":"//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport \"./Context.sol\";\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IERC20.sol\";\n\ncontract GainToken is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    uint8 private _decimals;\n    string private _symbol;\n    string private _name;\n    uint256 public _decimalFactor;\n\n    constructor() public payable {\n        _name = \"Gain Token\";\n        _symbol = \"GAIN\";\n        _decimals = 5;\n        _decimalFactor = 10**5;\n        _totalSupply = 2000000 * _decimalFactor;\n    }\n\n    function getOwner() external view returns (address) {\n        return owner();\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function decimalFactor() external view returns (uint256) {\n        return _decimalFactor;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        external override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        external\n        view override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(\n            sender != address(0),\n            \"ERC2020: transfer from the zero address\"\n        );\n        require(\n            recipient != address(0),\n            \"ERC2020: transfer to the zero address\"\n        );\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal returns (bool) {\n        require(account != address(0), \"ERC2020: mint to the zero address\");\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n        return true;\n    }\n\n    function _burn(address account, uint256 amount) internal returns (bool) {\n        require(account != address(0), \"ERC2020: burn from the zero address\");\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC2020: burn amount exceeds balance\"\n        );\n        emit Transfer(account, address(0), amount);\n        return true;\n    }\n}\n\n"},"contracts/IERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"contracts/Ownable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor()  {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n"},"contracts/SafeMath.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n"},"contracts/Staking.sol":{"content":"// SPDX-Lincese-Identifier: UNLICENSED\npragma solidity ^0.8.6;\n\nimport \"./GainToken.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./Context.sol\";\n\ncontract Staking is Context, Ownable, GainToken {\n    using SafeMath for uint256;\n\n    mapping(address => bool) public isStakeholder;\n\n    GainToken private GAIN;\n\n    struct stakeHolder {\n        uint256 amount;\n        uint256 stakeTime;\n    }\n    uint256 public constant tokenPrice = 100000000000000000;\n\n    uint256 public APY = 530; // 5.3%\n    mapping(address => stakeHolder) public stakes;\n\n    mapping(address => uint256) internal rewards;\n\n    uint256 public totalTokenStaked;\n\n    constructor(GainToken _address) public payable {\n        GAIN = _address;\n    }\n\n    //create stake\n    function createStake(uint256 _numberOfTokens)\n        public\n        payable\n        returns (bool)\n    {\n        require(\n            msg.value == _numberOfTokens.mul(tokenPrice),\n            \"Please provide an exact amount with respect to number of tokens\"\n        );\n        require(\n            GAIN.totalSupply() >=\n                (\n                    _numberOfTokens.mul(\n                        GAIN.decimalFactor().add(totalTokenStaked)\n                    )\n                ),\n            \"addition error\"\n        );\n        require(\n            _mint(_msgSender(), _numberOfTokens.mul(GAIN.decimalFactor())),\n            \"mint error\"\n        );\n        isStakeholder[_msgSender()] = true;\n        totalTokenStaked = totalTokenStaked.add(\n            _numberOfTokens.mul(GAIN.decimalFactor())\n        );\n        uint256 previousStaked = stakes[_msgSender()].amount;\n        uint256 finalStaked = previousStaked.add(msg.value);\n        stakes[_msgSender()] = stakeHolder(finalStaked, block.timestamp);\n        return true;\n    }\n\n    //remove stake\n    function removeStake(uint256 _numberOfTokens)\n        public\n        payable\n        returns (bool)\n    {\n        require(\n            (stakes[_msgSender()].stakeTime + 3 days) <= block.timestamp,\n            \"You have to stake for minimum 3 days.\"\n        );\n        require(\n            stakes[_msgSender()].amount >= _numberOfTokens.mul(tokenPrice),\n            \"You donot have enough tokens to unstake.\"\n        );\n        uint256 stake = _numberOfTokens.mul(tokenPrice);\n        uint remainingStake = stakes[_msgSender()].amount.sub(_numberOfTokens.mul(tokenPrice));\n        //calculate reward\n        uint256 rew = calculateReward(_msgSender());\n        uint256 totalAmount = stake.add(rew);\n        _msgSender().transfer(totalAmount);\n        totalTokenStaked = totalTokenStaked.sub(\n            _numberOfTokens.mul(GAIN.decimalFactor())\n        );\n        stakes[_msgSender()].amount = remainingStake;\n        _burn(_msgSender(), _numberOfTokens.mul(GAIN.decimalFactor()));\n        return true;\n    }\n\n    //get stake\n    function stakeOf(address _stakeholder) public view returns (uint256) {\n        return stakes[_stakeholder].amount;\n    }\n\n    //reward of\n    function rewardOf(address _stakeholder) public view returns (uint256) {\n        return rewards[_stakeholder];\n    }\n\n    // calculate stake\n    function calculateReward(address _stakeholder)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 reward;\n        if ((stakes[_stakeholder].stakeTime + 3 days) <= block.timestamp) {\n            reward = ((stakes[_stakeholder].amount).mul(APY)).div(\n                uint256(10000)\n            );\n        } else {\n            reward = 0;\n        }\n        return reward;\n    }\n\n    function viewReward(address _stakeholder) public view returns (uint256) {\n        uint256 reward;\n\n        reward = ((stakes[_stakeholder].amount).mul(APY)).div(uint256(10000));\n        return reward;\n    }\n    \n    function changeAPY(uint256 _apy) public onlyOwner returns(bool){\n        require(_apy > 0, \"APY must be greater than 0\");\n        APY = _apy;\n        return true;\n        \n    }\n\n}\n\n"}}}