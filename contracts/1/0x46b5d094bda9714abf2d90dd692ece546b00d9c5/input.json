{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"BalanceChecker.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.7.4;\r\n\r\ninterface IBalanceOf {\r\n  function balanceOf(address) external view returns (uint256);\r\n}\r\n\r\ncontract BalanceChecker {\r\n    // treat the null address as ether\r\n    address internal ETHER_ADDRESS = address(0);\r\n    \r\n    function balances(\r\n        address[] calldata users,\r\n        address[] calldata tokens\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory addrBalances = new uint256[](tokens.length * users.length);\r\n        for(uint256 i = 0; i < users.length; i++) {\r\n            for (uint256 j = 0; j < tokens.length; j++) {\r\n                uint256 addrIdx = j + tokens.length * i;\r\n                if (tokens[j] == ETHER_ADDRESS) {\r\n                    addrBalances[addrIdx] = users[i].balance;\r\n                } else {\r\n                    try IBalanceOf(tokens[j]).balanceOf(users[i])\r\n                    returns (uint256 balance)\r\n                {\r\n                    addrBalances[addrIdx] = balance;\r\n                } catch {}\r\n                }\r\n            }\r\n        }\r\n        return addrBalances;\r\n    }\r\n}"}}}