{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/test.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\n\ncontract CrashCoin {\n\n    string public constant name = \"CrashCoin\";\n    string public constant symbol = \"CRASC\";\n    uint8 public constant decimals = 18;  \n\n    AggregatorV3Interface internal priceFeed;\n\n    bool under50ktrigger = false;\n    bool under40ktrigger = false;\n    bool under30ktrigger = false;\n    bool under20ktrigger = false;\n    bool under10ktrigger = false;\n    mapping(address => bool) x50kreg;\n    mapping(address => bool) x40kreg;\n    mapping(address => bool) x30kreg;\n    mapping(address => bool) x20kreg;\n    mapping(address => bool) x10kreg;\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n\n    mapping(address => uint256) balances;\n\n    mapping(address => mapping (address => uint256)) allowed;\n    \n    uint256 totalSupply_;\n\n    using SafeMath for uint256;\n\n\n   constructor(uint256 total) public {  \n    totalSupply_ = total;\n    balances[msg.sender] = totalSupply_;\n    priceFeed = AggregatorV3Interface(0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c); // BTCUSD\n    }  \n\n    function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n    }\n    \n    function balanceOf(address tokenOwner) public view returns (uint) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint numTokens) public returns (bool) {\n        require(numTokens <= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        int price = getLatestPrice();\n        if(price<5000000000000) {\n            under50ktrigger = true;\n        }\n        if(price<4000000000000) {\n            under40ktrigger = true;\n        }\n        if(price<3000000000000) {\n            under30ktrigger = true;\n        }\n        if(price<2000000000000) {\n            under20ktrigger = true;\n        }\n        if(price<1000000000000) {\n            under10ktrigger = true;\n        }\n        if(under50ktrigger && !x50kreg[msg.sender]){\n            totalSupply_.add(balances[msg.sender]);\n            emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, balances[msg.sender]);\n            balances[msg.sender] = balances[msg.sender].add(balances[msg.sender]);\n            x50kreg[msg.sender] = true;\n        }\n        if(under40ktrigger && !x40kreg[msg.sender]){\n            totalSupply_.add(balances[msg.sender]);\n            emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, balances[msg.sender]);\n            balances[msg.sender] = balances[msg.sender].add(balances[msg.sender]);\n            x40kreg[msg.sender] = true;\n        }\n        if(under30ktrigger && !x30kreg[msg.sender]){\n            totalSupply_.add(balances[msg.sender]);\n            emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, balances[msg.sender]);\n            balances[msg.sender] = balances[msg.sender].add(balances[msg.sender]);\n            x30kreg[msg.sender] = true;\n        }\n        if(under20ktrigger && !x20kreg[msg.sender]){\n            totalSupply_.add(balances[msg.sender]);\n            emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, balances[msg.sender]);\n            balances[msg.sender] = balances[msg.sender].add(balances[msg.sender]);\n            x20kreg[msg.sender] = true;\n        }\n        if(under10ktrigger && !x10kreg[msg.sender]){\n            totalSupply_.add(balances[msg.sender]);\n            emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, balances[msg.sender]);\n            balances[msg.sender] = balances[msg.sender].add(balances[msg.sender]);\n            x10kreg[msg.sender] = true;\n        }\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n\n    function approve(address delegate, uint numTokens) public returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public view returns (uint) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {\n        require(numTokens <= balances[owner]);    \n        require(numTokens <= allowed[owner][msg.sender]);\n    \n        balances[owner] = balances[owner].sub(numTokens);\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n        balances[buyer] = balances[buyer].add(numTokens);\n\n        emit Transfer(owner, buyer, numTokens);\n        return true;\n    }\n\n     function getLatestPrice() private view returns (int) {\n        (\n            uint80 roundID, \n            int price,\n            uint startedAt,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        return price;\n    }\n}\n\nlibrary SafeMath { \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      assert(b <= a);\n      return a - b;\n    }\n    \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n    }\n}"
    }
  }
}