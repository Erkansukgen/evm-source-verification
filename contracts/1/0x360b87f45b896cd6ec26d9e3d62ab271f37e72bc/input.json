{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/BalancerUniswapArbitrageMinerProductionV3.sol": {
      "content": "pragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary SafeMath\r\n{\r\n    function add(uint x, uint y) internal pure returns (uint z)\r\n    {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z)\r\n    {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z)\r\n    {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair\r\n{\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface PoolInterface {\r\n    function getBalance(address token) external view returns (uint);\r\n\r\n    function getDenormalizedWeight(address token) external view returns (uint);\r\n\r\n    function swapExactAmountIn(address, uint, address, uint, uint) external returns (uint, uint);\r\n\r\n    function swapExactAmountOut(address, uint, address, uint, uint) external returns (uint, uint);\r\n\r\n    function calcOutGivenIn(uint tokenBalanceIn, uint tokenWeightIn, uint tokenBalanceOut, uint tokenWeightOut, uint tokenAmountIn, uint swapFee) external pure returns (uint tokenAmountOut);\r\n\r\n    function getSwapFee() external view returns (uint);\r\n}\r\n\r\ninterface IContractRegistry {\r\n    function addressOf(\r\n        bytes32 contractName\r\n    ) external returns (address);\r\n}\r\n\r\ninterface IBancorNetwork {\r\n    function convertByPath(\r\n        address[] memory _path,\r\n        uint256 _amount,\r\n        uint256 _minReturn,\r\n        address _beneficiary,\r\n        address _affiliateAccount,\r\n        uint256 _affiliateFee\r\n    ) external payable returns (uint256);\r\n\r\n    function conversionPath(\r\n        IERC20 _sourceToken,\r\n        IERC20 _targetToken\r\n    ) external view returns (address[] memory);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n}\r\n\r\ncontract BalancerUniswapArbitrage {\r\n    using SafeMath for uint;\r\n    uint private constant WETH_MIN = 1e15; //l 10^15 0.001WETH\r\n    uint private constant MINER_BRIBE_DEFAULT = 2e15; //l 2*10^15 0.02WETH\r\n    uint private constant BRIBE_PERCENT_100 = 1e3;//l 100% 10^3\r\n    uint private constant DEFL_PERCENT_100 = 1e6;//l 100% 10^6\r\n    bytes4 private constant ERC20_TRANSFER_SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address private constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    ISwapRouter private  constant UNIV3_ROUTER = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\r\n\r\n    IContractRegistry contractRegistry = IContractRegistry(0x52Ae12ABe5D8BD778BD5397F99cA900624CfADD4);\r\n    bytes32 private constant BANCOR_NETWORK_NAME = 0x42616E636F724E6574776F726B00000000000000000000000000000000000000; //l \"BancorNetwork\"\r\n\r\n    address public owner;\r\n    mapping(address => bool) public allow_list;\r\n\r\n    modifier onlyOwner\r\n    {\r\n        require(msg.sender == owner, \"OOW\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyWorker\r\n    {\r\n        require(allow_list[msg.sender], \"OWR\");\r\n        _;\r\n    }\r\n\r\n    constructor() public\r\n    {\r\n        owner = msg.sender;\r\n        allow_list[owner] = true;\r\n    }\r\n\r\n    receive() external payable\r\n    {\r\n\r\n    }\r\n\r\n    function set_owner_x666x(address new_owner) public onlyOwner\r\n    {\r\n        owner = new_owner;\r\n        allow_list[owner] = true;\r\n    }\r\n\r\n    function allow_addresses(address[] memory array) public onlyOwner\r\n    {\r\n        for (uint256 i = 0; i < array.length; i++) allow_list[array[i]] = true;\r\n    }\r\n\r\n    function cancel_addresses(address[] memory array) public onlyOwner\r\n    {\r\n        for (uint256 i = 0; i < array.length; i++) delete allow_list[array[i]];\r\n    }\r\n\r\n    function do_direct_call(uint256 _value, address _target, bytes memory _data) public payable onlyWorker returns (bytes memory response)\r\n    {\r\n        (bool success, bytes memory ret) = _target.call{value : _value}(_data);\r\n        require(success);\r\n        response = ret;\r\n    }\r\n\r\n    function pickup_eth_76550374(address payable receiver, uint256 value) public onlyOwner\r\n    {\r\n        receiver.transfer(value);\r\n    }\r\n\r\n    function pickup_tok_18796546(address receiver, address token, uint256 value) public onlyOwner\r\n    {\r\n        _safeTransfer(token, receiver, value);\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(ERC20_TRANSFER_SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    function charge_addresses(uint256 limit, address[] memory array) public payable onlyOwner\r\n    {\r\n        uint256 avail = msg.value;\r\n\r\n        for (uint256 i = 0; i < array.length; i++)\r\n        {\r\n            if (avail == 0) break;\r\n\r\n            address payable worker = payable(array[i]);\r\n            if (worker.balance < limit)\r\n            {\r\n                uint256 need = limit - worker.balance;\r\n                if (need > avail) need = avail;\r\n\r\n                worker.transfer(need);\r\n\r\n                avail -= need;\r\n            }\r\n        }\r\n\r\n        if (avail > 0) msg.sender.transfer(avail);\r\n    }\r\n\r\n    function charge_addresses_weth(uint256 limit, address[] memory array) public payable onlyOwner\r\n    {\r\n        uint256 need = 0;\r\n        for (uint256 i = 0; i < array.length; i++)\r\n        {\r\n            if (array[i].balance < limit) need += limit - array[i].balance;\r\n        }\r\n\r\n        uint256 avail = IERC20(WETH).balanceOf(address(this));\r\n        require(avail >= need, \"low weth balance\");\r\n\r\n        IWETH(WETH).withdraw(need);\r\n\r\n        for (uint256 i = 0; i < array.length; i++)\r\n        {\r\n            address payable worker = payable(array[i]);\r\n            if (worker.balance < limit) worker.transfer(limit - worker.balance);\r\n        }\r\n    }\r\n\r\n    //l Uniswap: WETH->token0 (detected), Balancer: WETH->token0 (own), Uniswap: token0->WETH (own)\r\n    function ubswap_weth_token0(uint weiAmount, address uswapPair, address bPool, address token0, uint bribe) external onlyWorker {\r\n        ubswap_weth_token0_(weiAmount, uswapPair, bPool, token0, bribe);\r\n    }\r\n\r\n    //l Uniswap: WETH->token0 (detected), Balancer: WETH->token0 (own), Uniswap: token0->WETH (own)\r\n    function ubswap_weth_token0_(uint weiAmount, address uswapPair, address bPool, address token0, uint bribe) private {\r\n        uint ethBalance = IERC20(WETH).balanceOf(address(this));\r\n\r\n        if (weiAmount <= ethBalance) {\r\n            //l (WethReserve,token0Reserve)\r\n            (uint112 reserve1, uint112 reserve2) = getReserves(IUniswapV2Pair(uswapPair), WETH);\r\n\r\n            uint wethBefore = IERC20(WETH).balanceOf(address(this));\r\n\r\n            swapPump(weiAmount, uswapPair, bPool, token0, [reserve1, reserve2]);\r\n\r\n            uint wethAfter = IERC20(WETH).balanceOf(address(this));\r\n\r\n            require(wethAfter > wethBefore, \"NP\");\r\n\r\n            uint pnl = wethAfter - wethBefore;\r\n\r\n            //l перевод награды майнеру\r\n            uint minerBribe = bribe * pnl / BRIBE_PERCENT_100;\r\n\r\n            if (minerBribe > 0) {\r\n                IWETH(WETH).withdraw(minerBribe);\r\n                address payable coinbaseAddr = payable(block.coinbase);\r\n                coinbaseAddr.transfer(minerBribe);\r\n            }\r\n        }\r\n    }\r\n\r\n    //l Balancer: WETH->token0, Uniswap: token0->WETH\r\n    function swapPump(uint weiAmount, address uswapPair, address bPool, address token0, uint112[2] memory reserves) private {\r\n        uint e0_before = IERC20(token0).balanceOf(address(this));\r\n\r\n        IERC20(WETH).approve(address(bPool), weiAmount);\r\n\r\n        //l 1. Balancer: WETH->token0\r\n        PoolInterface(bPool).swapExactAmountIn(\r\n            address(WETH),\r\n            weiAmount, //l tokenAmountIn\r\n            address(token0),\r\n            uint(1),\r\n            type(uint).max //l maxPrice, set to max -> accept any swap prices\r\n        );\r\n\r\n        uint e0_after = IERC20(token0).balanceOf(address(this));\r\n\r\n        uint t0 = e0_after - e0_before;\r\n\r\n        //l 2. Uniswap: token0->WETH\r\n        _safeTransfer(token0, uswapPair, t0);\r\n\r\n        uint e0 = calcUniswapSwapTokens(t0, reserves[1], reserves[0]);\r\n\r\n        if (IUniswapV2Pair(uswapPair).token0() == token0) IUniswapV2Pair(uswapPair).swap(0, e0, address(this), \"\");\r\n        else IUniswapV2Pair(uswapPair).swap(e0, 0, address(this), \"\");\r\n    }\r\n\r\n    //l DUMP Uniswap: token0->WETH (detected), Uniswap: WETH->token0 (own), Balancer: token0->WETH (own)\r\n    function ubswap_token0_weth(uint weiAmount, address uswapPair, address bPool, address token0, uint bribe) external onlyWorker {\r\n        ubswap_token0_weth_(weiAmount, uswapPair, bPool, token0, bribe);\r\n    }\r\n\r\n    //l DUMP Uniswap: token0->WETH (detected), Uniswap: WETH->token0 (own), Balancer: token0->WETH (own)\r\n    function ubswap_token0_weth_(uint weiAmount, address uswapPair, address bPool, address token0, uint bribe) private {\r\n        uint ethBalance = IERC20(WETH).balanceOf(address(this));\r\n\r\n        if (weiAmount <= ethBalance) {\r\n            //l (WethReserve,token0Reserve)\r\n            (uint112 reserve1, uint112 reserve2) = getReserves(IUniswapV2Pair(uswapPair), WETH);\r\n\r\n            uint wethBefore = IERC20(WETH).balanceOf(address(this));\r\n\r\n            swapDump(weiAmount, uswapPair, bPool, token0, [reserve1, reserve2]);\r\n\r\n            uint wethAfter = IERC20(WETH).balanceOf(address(this));\r\n\r\n            require(wethAfter > wethBefore, \"NP\");\r\n\r\n            uint pnl = wethAfter - wethBefore;\r\n\r\n            //l перевод награды майнеру\r\n            uint minerBribe = bribe * pnl / BRIBE_PERCENT_100;\r\n\r\n            if (minerBribe > 0) {\r\n                IWETH(WETH).withdraw(minerBribe);\r\n                address payable coinbaseAddr = payable(block.coinbase);\r\n                coinbaseAddr.transfer(minerBribe);\r\n            }\r\n        }\r\n    }\r\n\r\n    //l Uniswap: WETH->token0, Balancer: token0->WETH\r\n    function swapDump(uint weiAmount, address uswapPair, address bPool, address token0, uint112[2] memory reserves) private {\r\n        //l 1. Uniswap: WETH->token0,  reserves[0] is WETH reserve, reserve[1] is token0 reserve\r\n        _safeTransfer(WETH, uswapPair, weiAmount);\r\n\r\n        uint e0 = calcUniswapSwapTokens(weiAmount, reserves[0], reserves[1]);\r\n\r\n        uint e0_before = IERC20(token0).balanceOf(address(this));\r\n\r\n        if (IUniswapV2Pair(uswapPair).token0() == WETH) IUniswapV2Pair(uswapPair).swap(0, e0, address(this), \"\");\r\n        else IUniswapV2Pair(uswapPair).swap(e0, 0, address(this), \"\");\r\n\r\n        uint e0_after = IERC20(token0).balanceOf(address(this));\r\n\r\n        uint token0Amount = e0_after - e0_before;\r\n\r\n        //l 2. Balancer: token0 -> WETH\r\n        IERC20(token0).approve(address(bPool), token0Amount);\r\n\r\n        PoolInterface(bPool).swapExactAmountIn(\r\n            address(token0),\r\n            token0Amount, //l tokenAmountIn\r\n            address(WETH),\r\n            uint(1),\r\n            type(uint).max //l maxPrice, set to max -> accept any swap prices\r\n        );\r\n    }\r\n\r\n    //l sushiuniswap swap\r\n    //l WETH->token0->WETH\r\n    function suswap(uint weiAmount, address pair1, address pair2, address token0, uint bribe) external onlyWorker {\r\n        suswap_(weiAmount, pair1, pair2, token0, bribe);\r\n    }\r\n\r\n    //l WETH->token0->WETH\r\n    function suswap_(uint weiAmount, address pair1, address pair2, address token0, uint bribe) private {\r\n        uint ethBalance = IERC20(WETH).balanceOf(address(this));\r\n\r\n        if (weiAmount <= ethBalance) {\r\n            //l (WethReserve, token0Reserve) exchange1\r\n            (uint112 reserve1, uint112 reserve2) = getReserves(IUniswapV2Pair(pair1), WETH);\r\n            //l (token0Reserve, WethReserve) exchange2\r\n            (uint112 reserve3, uint112 reserve4) = getReserves(IUniswapV2Pair(pair2), token0);\r\n\r\n            uint wethBefore = IERC20(WETH).balanceOf(address(this));\r\n\r\n            swapPairs2(weiAmount, [pair1, pair2], token0, [reserve1, reserve2, reserve3, reserve4]);\r\n\r\n            uint wethAfter = IERC20(WETH).balanceOf(address(this));\r\n\r\n            require(wethAfter > wethBefore, \"NP\");\r\n\r\n            uint pnl = wethAfter - wethBefore;\r\n\r\n            //l перевод награды майнеру\r\n            uint minerBribe = bribe * pnl / BRIBE_PERCENT_100;\r\n\r\n            if (minerBribe > 0) {\r\n                IWETH(WETH).withdraw(minerBribe);\r\n                address payable coinbaseAddr = payable(block.coinbase);\r\n                coinbaseAddr.transfer(minerBribe);\r\n            }\r\n        }\r\n    }\r\n\r\n    //l WETH->token0->WETH\r\n    function swapPairs2(uint weiAmount, address[2] memory pairs, address token0, uint112[4] memory reserves) private /*returns (uint wethAfter)*/ {\r\n        //l 1. WETH->token0\r\n        uint t0 = swapPair([pairs[0], pairs[1]], [reserves[0], reserves[1]], [WETH, token0], weiAmount, true);\r\n        //l 2. token0->WETH\r\n        /*wethAfter=*/ swapPair([pairs[1], address(this)], [reserves[2], reserves[3]], [token0, WETH], t0, false);\r\n        //return wethAfter;\r\n    }\r\n\r\n    //l mix sushi uniswap balancer swap\r\n    //l WETH->token1->token0->WETH\r\n    //l swapSequence: 0 - Sushi/Uniswap, 1 - Balancer examples: {0,1,1}  Sushi/Uniswap-Balancer-Balancer, {0,0,0} - sushi-sushi-sushi (us-us-us, us - uniswap or sushi)\r\n    function mixSUBtaswap(uint weiAmount, address pair1, address pair2, address pair3, address token0, address token1, uint bribe, uint[3] memory swapSequence) external onlyWorker {\r\n        mixSUBtaswap_(weiAmount, pair1, pair2, pair3, token0, token1, bribe, swapSequence);\r\n    }\r\n\r\n    //l mix sushi uniswap balancer swap\r\n    //l WETH->token1->token0->WETH\r\n    //l 0 - Sushi/Uniswap, 1 - Balancer\r\n    function mixSUBtaswap_(uint weiAmount, address pair1, address pair2, address pair3, address token0, address token1, uint bribe, uint[3] memory swapSequence) private {\r\n        uint ethBalance = IERC20(WETH).balanceOf(address(this));\r\n\r\n        if (weiAmount <= ethBalance) {\r\n            //l swapSequence[index] != 0  - needTransferToken0 from address(this) to pairX\r\n            //l WETH->token1\r\n            uint t0 = mixswap0(weiAmount, [pair1, swapSequence[1] == 0 ? pair2 : address(this)], [WETH, token1], swapSequence[0], true);\r\n            //l token1 -> token0\r\n            uint t1 = mixswap0(t0, [pair2, swapSequence[2] == 0 ? pair3 : address(this)], [token1, token0], swapSequence[1], swapSequence[0] != 0);\r\n            //l  token0 -> WETH\r\n            /* uint t2 = */mixswap0(t1, [pair3, address(this)], [token0, WETH], swapSequence[2], swapSequence[1] != 0);\r\n\r\n            uint wethAfter = IERC20(WETH).balanceOf(address(this));\r\n\r\n            require(wethAfter > ethBalance, \"NP\");\r\n\r\n            uint pnl = wethAfter - ethBalance;\r\n\r\n            //l перевод награды майнеру\r\n            uint minerBribe = bribe * pnl / BRIBE_PERCENT_100;\r\n\r\n            if (minerBribe > 0) {\r\n                IWETH(WETH).withdraw(minerBribe);\r\n                address payable coinbaseAddr = payable(block.coinbase);\r\n                coinbaseAddr.transfer(minerBribe);\r\n            }\r\n        }\r\n    }\r\n\r\n    function mixswap0(uint amount, address[2] memory pairs, address[2] memory tokens, uint swapType, bool needTransferToken0) private returns (uint t0) {\r\n        if (swapType == 0) {\r\n            (uint112 reserve1, uint112 reserve2) = getReserves(IUniswapV2Pair(pairs[0]), tokens[0]);\r\n            t0 = swapPair([pairs[0], pairs[1]], [reserve1, reserve2], [tokens[0], tokens[1]], amount, needTransferToken0);\r\n        } else {\r\n            IERC20(tokens[0]).approve(address(pairs[0]), amount);\r\n\r\n            //l 1. Balancer: WETH->token0\r\n            (t0,) = PoolInterface(pairs[0]).swapExactAmountIn(\r\n                address(tokens[0]),\r\n                amount, //l tokenAmountIn\r\n                address(tokens[1]),\r\n                uint(1),\r\n                type(uint).max //l maxPrice, set to max -> accept any swap prices\r\n            );\r\n        }\r\n    }\r\n\r\n    //l mix sushi uniswap balancer bancor swap\r\n    //l path[] - swaps path\r\n    //l swapSequence: 0 - Sushi/Uniswap, 1 - Balancer, 2 - BANCOR\r\n    //l examples:\r\n    //l {0,1,1} - Sushi/Uniswap-Balancer-Balancer, {0,0,0} - sushi-sushi-sushi (us-us-us, us - uniswap or sushi)\r\n    //l {2,1,0} - bancor-balancer-us, {2,0,2} - bancor-sushi-bancor\r\n    function mixSwapV3(uint weiAmount, uint bribe, address[] memory path, uint[] memory swapSequence, address tkn0, uint24[] memory v3Fees) external onlyWorker {\r\n        mixSwapV3_(weiAmount, bribe, path, swapSequence, tkn0, v3Fees);\r\n    }\r\n\r\n    //l mix sushi uniswap balancer bancor swap\r\n    //l path[] - swaps path\r\n    //l 0 - Sushi/Uniswap, 1 - Balancer, 2 - BANCOR\r\n    function mixSwapV3_(uint weiAmount, uint bribe, address[] memory path, uint[] memory swapSequence, address tkn0, uint24[] memory v3Fees) private {\r\n        uint ethBalance = IERC20(WETH).balanceOf(address(this));\r\n\r\n        if (weiAmount <= ethBalance) {\r\n            uint index = 0;\r\n            uint v3FeesIndex = 0;\r\n            uint targetAmount = weiAmount;\r\n            for (uint i = 0; i < swapSequence.length; i++) {\r\n                if (swapSequence[i] == 0) {//l uni/sushi\r\n                    address pair = path[index++];\r\n                    //l path[0], index==1\r\n                    address[2] memory tokens = [path[index], path[index + 1]];\r\n                    //l [path[1],path[2]]\r\n                    index += 2;\r\n                    //l index==3\r\n                    //l подряд идущие uni/sushi перекидываем targetAmount на след пару\r\n                    address beneficiary = (i < swapSequence.length - 1) && swapSequence[i + 1] == 0 ? path[index] : address(this);\r\n                    //l i==0, swapSequence[1]==0, path[3]\r\n                    //l если это первый своп или предыдущи не UNI/SUSHI и не BANCOR и не UNISWAP_V3 (они сразу на пару загоняют, если рядом в цепочке)\r\n                    bool needTransferToken0 = i == 0 || (i > 0 && swapSequence[i - 1] != 0 && swapSequence[i - 1] != 2 && swapSequence[i - 1] != 3);\r\n\r\n                    (uint112 reserve1, uint112 reserve2) = getReserves(IUniswapV2Pair(pair), tokens[0]);\r\n                    targetAmount = swapPair([pair, beneficiary], [reserve1, reserve2], [tokens[0], tokens[1]], targetAmount, needTransferToken0);\r\n                } else if (swapSequence[i] == 1) {//l Balancer\r\n                    address pair = path[index++];\r\n                    //l path[0], index==1\r\n                    address token0 = path[index++];\r\n                    //l path[1], index==2\r\n\r\n                    IERC20(token0).approve(address(pair), targetAmount);\r\n\r\n                    (targetAmount,) = PoolInterface(pair).swapExactAmountIn(\r\n                        address(token0), //l tokenIn\r\n                        targetAmount, //l tokenAmountIn\r\n                        address(path[index++]), //l tokenOut, path[2], index==3\r\n                        uint(1), //l minAmountOut\r\n                        type(uint).max //l maxPrice, set to max -> accept any swap prices\r\n                    );\r\n                } else if (swapSequence[i] == 2) {//l BANCOR\r\n                    //l достаём каждый раз адрес контракта BancorNetwork, т.к. он может меняться\r\n                    IBancorNetwork bancorNetwork = IBancorNetwork(contractRegistry.addressOf(BANCOR_NETWORK_NAME));\r\n\r\n                    address tokenSource = path[index++];\r\n                    //l path[0], index==1\r\n                    address tokenTarget = path[index++];\r\n                    //l path[1], index==2\r\n\r\n                    address[] memory swapPath = bancorNetwork.conversionPath(IERC20(tokenSource), IERC20(tokenTarget));\r\n                    //uint minReturn = bancorNetwork.rateByPath(path,_amount);\r\n\r\n                    uint msgValue = 0;\r\n                    if (tokenSource == ETH_RESERVE_ADDRESS) {\r\n                        IWETH(WETH).withdraw(targetAmount);\r\n                        msgValue = targetAmount;\r\n                    } else {\r\n                        //l только если это не первый обмен с ефиром (ефир через msgValue отдаём),\r\n                        //l мы должны заапрувить (разрешить контракту bancorNetwork-а снять с нас amount токена tokenSource) сумму передаваемого на обмен токена\r\n                        IERC20(tokenSource).approve(address(bancorNetwork), targetAmount);\r\n                    }\r\n\r\n                    //l @param _beneficiary account that will receive the conversion result or 0x0 to send the result to the sender account\r\n                    //l если след UNI/SUSHI, то в качестве получателя назначаем пару, иначе address(0), тогда результат вернётся sender-у (контракту)\r\n                    address beneficiary = (i < swapSequence.length - 1) && swapSequence[i + 1] == 0 ? path[index] : address(0);\r\n\r\n                    //l path[2], index=2\r\n\r\n                    //targetAmount = bancorNetwork.convertByPath.value(msgValue)(\r\n                    //l convertByPath(address[],uint256,uint256,address,address,uint256)\r\n                    targetAmount = bancorNetwork.convertByPath{value : msgValue}(\r\n                        swapPath,\r\n                        targetAmount,\r\n                        uint(1), //l minReturn,\r\n                        beneficiary, //l _beneficiary\r\n                        address(0), //l _affiliateAccount\r\n                        0//l _affiliateFee\r\n                    );\r\n                    //if (tokenTarget == ETH_RESERVE_ADDRESS) IWETH(WETH).deposit.value(targetAmount)();\r\n                    if (tokenTarget == ETH_RESERVE_ADDRESS) IWETH(WETH).deposit{value : targetAmount}();\r\n                } else if (swapSequence[i] == 3) {//l UNISWAP_V3\r\n                    address tokenIn = path[index++];\r\n                    address tokenOut = path[index++];\r\n                    address recipient = i < swapSequence.length - 1 && swapSequence[i + 1] == 0 ? path[index] : address(this);\r\n\r\n                    IERC20(tokenIn).approve(address(UNIV3_ROUTER), targetAmount);\r\n\r\n                    UNIV3_ROUTER.exactInputSingle(ISwapRouter.ExactInputSingleParams({\r\n                    tokenIn : tokenIn,\r\n                    tokenOut : tokenOut,\r\n                    fee : v3Fees[v3FeesIndex++],\r\n                    //recipient : address(this),\r\n                    recipient : recipient,\r\n                    deadline : block.timestamp + 1 hours,\r\n                    amountIn : targetAmount,\r\n                    amountOutMinimum : 0,\r\n                    sqrtPriceLimitX96 : 0\r\n                    }));\r\n                }\r\n            }\r\n\r\n            uint wethAfter = IERC20(WETH).balanceOf(address(this));\r\n\r\n            require(wethAfter > ethBalance, \"NP\");\r\n\r\n            uint pnl = wethAfter - ethBalance;\r\n\r\n            //l перевод награды майнеру\r\n            uint minerBribe = bribe * pnl / BRIBE_PERCENT_100;\r\n\r\n            if (minerBribe > 0) {\r\n                IWETH(WETH).withdraw(minerBribe);\r\n                address payable coinbaseAddr = payable(block.coinbase);\r\n                coinbaseAddr.transfer(minerBribe);\r\n            }\r\n        }\r\n    }\r\n\r\n    //l token0->token1\r\n    function swapPair(address[2] memory pairs, uint112[2] memory reserves, address[2] memory tokens, uint amount, bool isFirstSwap) private returns (uint) {\r\n        if (isFirstSwap) _safeTransfer(tokens[0], pairs[0], amount);\r\n\r\n        uint e0 = calcUniswapSwapTokens(amount, reserves[0], reserves[1]);\r\n\r\n        uint e0_before = IERC20(tokens[1]).balanceOf(pairs[1]);\r\n\r\n        if (IUniswapV2Pair(pairs[0]).token0() == tokens[0]) IUniswapV2Pair(pairs[0]).swap(0, e0, pairs[1], \"\");\r\n        else IUniswapV2Pair(pairs[0]).swap(e0, 0, pairs[1], \"\");\r\n\r\n        uint e0_after = IERC20(tokens[1]).balanceOf(pairs[1]);\r\n\r\n        uint amount_res = e0_after - e0_before;\r\n\r\n        //        return amount_res > 0 ? amount_res - 1 : amount_res;\r\n        return amount_res;\r\n    }\r\n\r\n    function getReserves(IUniswapV2Pair pair, address token0) private view returns (uint112 r1, uint112 r2) {\r\n        (uint112 reserve1, uint112 reserve2,) = IUniswapV2Pair(pair).getReserves();\r\n        if (pair.token0() != token0) (reserve1, reserve2) = (reserve2, reserve1);\r\n        return (reserve1, reserve2);\r\n    }\r\n\r\n    //l r1*amount*997/(r0*1000 + amount*997)\r\n    function calcUniswapSwapTokens(uint amount, uint reserve0, uint reserve1) private pure returns (uint)\r\n    {\r\n        uint eth_with_fee = amount.mul(997);\r\n        uint numerator = eth_with_fee.mul(reserve1);\r\n        uint denominator = reserve0.mul(1000).add(eth_with_fee);\r\n        return numerator / denominator;\r\n    }\r\n\r\n    function getBalance(address pool, address token) external view returns (uint blockNumber, uint balance){\r\n        return (block.number, PoolInterface(pool).getBalance(token));\r\n    }\r\n}"
    }
  }
}