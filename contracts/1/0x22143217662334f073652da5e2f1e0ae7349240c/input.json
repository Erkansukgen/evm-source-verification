{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"CROWN.sol":{"content":"pragma solidity ^0.8.0 ; //SPDX-License-Identifier: UNLICENSED\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint value) external;\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this;\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override {\n        _transfer(_msgSender(), recipient, amount);\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\ncontract CROWN is Ownable, ERC20 {\n    \n    using SafeERC20 for IERC20;\n    \n    constructor(address _usdt, address _usdc) ERC20(\"CROWN\", \"CWT\") {\n        _mint(msg.sender, 140000000 * 10 ** decimals());\n        usdt = _usdt;\n        usdc = _usdc;\n        stableCoinAddress = _usdt; //set default dividend token as USDT\n        decimalOfStableCoin = IERC20Metadata(stableCoinAddress).decimals();\n    }\n    \n    //---------------------ERC20 extended functions---------------------\n    function transferTokenFrom(address sender, address recipient, uint256 amount) public onlyOwnerOrContract returns (bool) {\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n    \n    function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\n        for (uint256 i = 0; i < receivers.length; i++) {\n            require(receivers[i] == address(receivers[i]));\n            transfer(receivers[i], amounts[i]);\n        }\n    }\n    \n    //----------------------------Staking Part-------------------------------\n    mapping(address => bool) public isStaking;\n    mapping(address => StakeInfo) public stakeInfo;\n    address[] internal stakeholders;\n    uint256 public crownPrice = 1e18; // CROWN token initial price $1 US Dollar.\n    uint256 public dividendRate = 4e18; // Initial dividend rate 4% of stake amount.\n    uint256 public decimalOfStableCoin = 1e6; // Default decimals point of USDT/USDC token\n    uint256 public startDate;\n    uint256 public endDate;\n    address public usdt;\n    address public usdc;\n    address public stableCoinAddress; // Current dividend token address.\n    \n    struct StakeInfo {\n        uint256 amount;\n        uint256 crownReward;\n        uint256 dividendUSDT;\n        uint256 dividendUSDC;\n    }\n    \n    //---------------------Staking Events---------------------\n    event DepositStake(address indexed stakeholder, uint256 amount, uint256 timestamp);\n    event WithdrawStake(address indexed stakeholder, uint256 amount, uint256 timestamp);\n    event DividendWithdrawal(address indexed from, address indexed to, uint256 amount, string symbol, uint256 timestamp);\n    \n    //---------------------Modifier functions---------------------\n    modifier validAddress(address account){    \n        require(account == address(account),\"Invalid address\");\n        require(account != address(0));\n        _;\n    }\n    \n    modifier onlyOwnerOrContract() {\n        require(msg.sender == owner() || msg.sender == address(this), \"Ownable: caller is not an owner or contract!\");\n        _;\n    }\n    \n    modifier onlyWithinStakePeriod() {    \n        require(startDate > 0 && endDate > 0, \"Invalid stake date!\");\n        require(block.timestamp >= startDate && block.timestamp <= endDate, \"Please stake in the staking period!\");\n        _;\n    }\n    \n    modifier onlyAfterPeriod() {    \n        require(startDate > 0 && endDate > 0, \"Invalid stake end date!\");\n        require(block.timestamp >= endDate, \"Please wait until the stake removal date!\");\n        _;\n    }\n    \n    //---------------------Getter functions---------------------\n\n    function totalStakes() public view returns (uint256) {\n       uint256 _totalStakes = 0;\n       for (uint256 i = 0; i < stakeholders.length; i += 1) {\n           _totalStakes += (stakeInfo[stakeholders[i]].amount);\n       }\n       return _totalStakes;\n    }\n   \n    function getDividendSupply() public view returns (uint256) {\n       if (address(stableCoinAddress) == address(usdc)) {\n           return IERC20(usdc).balanceOf(address(this));\n       } else {\n           return IERC20(usdt).balanceOf(address(this));\n       }\n    }\n    \n    function getUSDTBalance() external view returns (uint256) {\n        return IERC20(usdt).balanceOf(address(this));\n    }\n    \n    function getUSDCBalance() external view returns (uint256) {\n        return IERC20(usdc).balanceOf(address(this));\n    }\n   \n    function stakeOf(address stakeHolder) external view returns (uint256) {\n       return stakeInfo[stakeHolder].amount;\n    }\n   \n    function dividendUSDTOf(address stakeHolder) external view returns (uint256) {\n       return stakeInfo[stakeHolder].dividendUSDT;\n    }\n    \n    function dividendUSDCOf(address stakeHolder) external view returns (uint256) {\n       return stakeInfo[stakeHolder].dividendUSDC;\n    }\n    \n    //---------------------Setter functions---------------------\n    \n    function updateDividendRate(uint256 _newDividendRate) public onlyOwnerOrContract {\n        require(_newDividendRate > 0, \"Dividend rate can not be zero!\");\n        dividendRate = _newDividendRate;\n        massUpdateDividend();\n    }\n    \n    function massUpdateDividend() internal {\n        for (uint256 i; i < stakeholders.length; i+=1){\n            address stakeholder = stakeholders[i];\n            updateDividend(stakeholder);\n        }\n    }\n    \n    function updateCrownPrice(uint256 _crownPrice) public onlyOwnerOrContract {\n       require(_crownPrice > 0, \"Price must be more than 0!\");\n       crownPrice = _crownPrice;\n    }\n    \n    function updateUSDTAddress(address addressOfUSDT) public validAddress(addressOfUSDT) onlyOwner returns (bool){\n        usdt = addressOfUSDT;\n        decimalOfStableCoin = IERC20Metadata(usdt).decimals();\n        return true;\n    }\n    \n    function updateUSDCAddress(address addressOfUSDC) public validAddress(addressOfUSDC) onlyOwner returns (bool){\n        usdc = addressOfUSDC;\n        decimalOfStableCoin = IERC20Metadata(usdc).decimals();\n        return true;\n    }\n    \n    function updateDividend(address stakeHolder) internal {\n       uint256 reward = stakeInfo[stakeHolder].crownReward;\n       uint256 crownReward = ((reward * dividendRate) / 1e2) / 1e18;\n       require(crownPrice > 0, \"CROWN price can not be zero!\");\n       if (crownReward > 0) { \n           uint256 dividendAmount = ((crownReward * crownPrice) / 1e18) / (1e18 / 10 ** decimalOfStableCoin);\n           if (address(stableCoinAddress) == address(usdc)) {\n               stakeInfo[stakeHolder].dividendUSDC += dividendAmount; \n           } else {\n               stakeInfo[stakeHolder].dividendUSDT += dividendAmount;\n           }\n           stakeInfo[stakeHolder].crownReward -= reward;\n       }\n    }\n   \n    function updateStableCoin(string memory currency) internal {\n       if (keccak256(abi.encodePacked(currency)) == keccak256(abi.encodePacked(\"USDC\"))) {\n            stableCoinAddress = address(usdc);\n       } else {\n            stableCoinAddress = address(usdt);\n       }\n    }\n    \n    function setStakingPeriod (uint256 periodInDay) public onlyOwner returns(bool) {\n        startDate = block.timestamp;\n        endDate = startDate + (periodInDay * 1 days);\n        return true;\n    } \n\n    function addStakeholder(address stakeHolder) internal validAddress(stakeHolder) {\n        bool _isStaking = isStaking[stakeHolder];\n        if(!_isStaking) {\n           stakeholders.push(stakeHolder);\n           isStaking[stakeHolder] = true;\n       }\n    }\n\n    function removeStakeholder(address stakeHolder) internal validAddress(stakeHolder) {\n        bool _isStaking = isStaking[stakeHolder];\n        if(_isStaking){\n           isStaking[stakeHolder] = false;\n        }\n    }\n    \n    function massWithdrawStake() public onlyOwner onlyAfterPeriod {\n        for (uint256 i; i < stakeholders.length; i+=1){\n            address stakeholder = stakeholders[i];\n            uint256 amount = stakeInfo[stakeholders[i]].amount;\n            if (amount > 0) {\n                withdrawStake(stakeholder, amount);\n            } \n        }\n    }\n    \n//-------------------------------- Main Staking Functions ---------------------------------------------\n\n   function depositStake(address stakeHolder, uint256 amount) public validAddress(stakeHolder) onlyWithinStakePeriod {\n       uint256 crownBalance = balanceOf(stakeHolder);\n       if (amount > 0) {\n           require(crownBalance >= amount,\"Not enough token to stake!\");\n           require(msg.sender == owner() || msg.sender == stakeHolder, \"Just an admin & stakeHolder can remove stake!\");\n           transferTokenFrom(stakeHolder, address(this), amount);\n           if (stakeInfo[stakeHolder].amount == 0) {\n               addStakeholder(stakeHolder);\n           }\n           stakeInfo[stakeHolder].amount += amount;\n           stakeInfo[stakeHolder].crownReward += amount;\n           emit DepositStake(stakeHolder, amount, block.timestamp);\n       }\n   }\n\n   function withdrawStake(address stakeHolder, uint256 amount) public validAddress(stakeHolder) onlyAfterPeriod {\n       if (amount > 0) { \n           require(stakeInfo[stakeHolder].amount >= amount, \"Not enough staking to be removed!\");\n           require(msg.sender == owner() || msg.sender == stakeHolder, \"Just an admin & stakeHolder can remove stake!\");\n           SafeERC20.safeTransfer(IERC20(address(this)), stakeHolder, amount); \n           stakeInfo[stakeHolder].amount -= amount;\n           if (stakeInfo[stakeHolder].amount == 0) { \n               removeStakeholder(stakeHolder);\n           }\n           emit WithdrawStake(stakeHolder, amount, block.timestamp);\n       }\n   }\n   \n   function distributeDividend(string memory currency, uint256 _dividendRate, uint256 _crownUSDPrice) public onlyOwner {\n       assert(keccak256(abi.encodePacked(currency)) == keccak256(abi.encodePacked(\"USDC\")) || keccak256(abi.encodePacked(currency)) == keccak256(abi.encodePacked(\"USDT\")));\n       updateStableCoin(currency);\n       uint256 dividendSupply = getDividendSupply();\n       require(dividendSupply > 0, \"Insufficient dividend supply!\");\n       require(_dividendRate > 0, \"Dividend rate can not be zero!\");\n       require(_crownUSDPrice > 0, \"Crown token price can not be zero!\");\n       updateCrownPrice(_crownUSDPrice);\n       updateDividendRate(_dividendRate);\n   }\n   \n   function withdrawDividend(address stakeHolder, address toAddress, string memory currency, uint256 amount) public validAddress(stakeHolder) {\n       assert(keccak256(abi.encodePacked(currency)) == keccak256(abi.encodePacked(\"USDC\")) || keccak256(abi.encodePacked(currency)) == keccak256(abi.encodePacked(\"USDT\")));\n       uint256 dividendAmount = 0;\n       uint256 dividendSupply = getDividendSupply();\n       require(dividendSupply >= amount && dividendSupply > 0, \"Withdraw amount exceed dividend supply!\");\n       require(msg.sender == owner() || msg.sender == stakeHolder, \"Just an admin & stakeHolder can remove stake!\");\n       if (amount > 0) {\n           if (keccak256(abi.encodePacked(currency)) == keccak256(abi.encodePacked(\"USDC\"))) {\n               dividendAmount = stakeInfo[stakeHolder].dividendUSDC;\n               require(dividendAmount >= amount && dividendAmount > 0, \"Withdraw amount exceed dividend balance!\");\n               SafeERC20.safeTransfer(IERC20(usdc), toAddress, amount);\n               stakeInfo[stakeHolder].dividendUSDC -= amount;\n           } else {\n               dividendAmount = stakeInfo[stakeHolder].dividendUSDT;\n               require(dividendAmount >= amount && dividendAmount > 0, \"Withdraw amount exceed dividend balance!\");\n               SafeERC20.safeTransfer(IERC20(usdt), toAddress, amount);\n               stakeInfo[stakeHolder].dividendUSDT -= amount;\n           }\n       } else {\n           revert(\"Withdraw amount can not be zero!\");\n       }\n       emit DividendWithdrawal(stakeHolder, toAddress, amount, currency, block.timestamp);\n   }\n}\n"}}}