{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"ZodiacNFT.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n     \r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n \r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs in `owner`'s account.\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the NFT specified by `tokenId`.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n} \r\n\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\r\n        return owner;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner);\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\ncontract ZodiacNFT is ERC721{\r\n    constructor(address[] memory _ownerAddress, uint256[] memory _number) public {\r\n        owner = msg.sender;\r\n\r\n        animals[1] = animalSTR; // STR\r\n        animals[2] = animalAGI; // AGI\r\n        animals[3] = animalINT; // INT\r\n        \r\n        for (uint i = 0; i< _ownerAddress.length; i++) {\r\n            whiteListed[_ownerAddress[i]] = _number[i];\r\n        }\r\n    }\r\n\r\n    struct Zodiac {\r\n        uint8 animalID;\r\n        uint8 special;\r\n        Stat stat;\r\n        Appearance appearance;\r\n    }\r\n    \r\n    struct Appearance {\r\n        uint64 color;\r\n        uint8 size;\r\n        uint8 pattern; \r\n        uint8 model;\r\n    }\r\n    \r\n    struct Stat {\r\n        uint256 agility;\r\n        uint256 strength;\r\n        uint256 intelligence;\r\n        uint256 mental;\r\n    }\r\n    \r\n    Zodiac[] zodiacs;\r\n    mapping(uint256 => uint256[]) animals;\r\n    mapping(address => uint256) public whiteListed;\r\n    uint8[12] valueAnimal = [2, 5, 5, 2, 5, 4, 4, 4, 3, 2, 3, 3];\r\n    uint8[4] animalSTR = [2, 8, 10, 12];\r\n    uint8[4] animalAGI = [1, 3, 7, 9];\r\n    uint8[4] animalINT = [4, 5, 6, 11];\r\n    address public owner;\r\n    uint256 private nonce = 0;\r\n\r\n    // Functions with this modifier can only be executed by the owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function createZodiac() external {\r\n        require(whiteListed[msg.sender] > 0, \"You do not have permission to create\");\r\n        Zodiac memory newZodiac;\r\n        \r\n        newZodiac.special = uint8(_random() % 9 + 1);\r\n        newZodiac.appearance.color = uint64(_random() % 216 + 1);\r\n        newZodiac.appearance.size = uint8(_random() % 5 + 1);\r\n        newZodiac.appearance.pattern = uint8(_random() % 4 + 1);\r\n        newZodiac.appearance.model = uint8(_random() % 3 + 1);\r\n        (newZodiac.stat.strength, newZodiac.stat.agility, newZodiac.stat.intelligence, newZodiac.animalID) = _randomStat();\r\n        newZodiac.stat.mental = 0;\r\n\r\n        uint256 newZodiacId = zodiacs.push(newZodiac) - 1;\r\n        super._mint(msg.sender, newZodiacId);\r\n        whiteListed[msg.sender] -= 1;\r\n    }\r\n    \r\n    // Function to retrieve a specific zodiacs's details.\r\n    function getZodiacDetails(uint256 _zodiacID) public view returns (\r\n        uint8, \r\n        uint8,\r\n        uint64,\r\n        uint8,\r\n        uint8,\r\n        uint8,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n        ) {\r\n        Zodiac storage zodiac = zodiacs[_zodiacID];\r\n\r\n        return(\r\n               zodiac.animalID,\r\n               zodiac.special,\r\n               zodiac.appearance.color,\r\n               zodiac.appearance.size,\r\n               zodiac.appearance.pattern,\r\n               zodiac.appearance.model,\r\n               zodiac.stat.agility,\r\n               zodiac.stat.strength,\r\n               zodiac.stat.intelligence,\r\n               zodiac.stat.mental);\r\n    }\r\n    \r\n    /** @dev Function to get a list of owned zodiacs' IDs\r\n      * @return A uint array which contains IDs of all owned zodiacss\r\n    */\r\n    function ownedZodiac() public view returns(uint256[] memory) {\r\n        uint256 zodiacCount = balanceOf(msg.sender);\r\n        if (zodiacCount == 0) {\r\n            return new uint256[](0);\r\n        }\r\n        \r\n        uint256[] memory result = new uint256[](zodiacCount);\r\n        uint256 totalZodiacs = zodiacs.length;\r\n        uint256 resultIndex = 0;\r\n        uint256 zodiacID = 0;\r\n        while (zodiacID < totalZodiacs) {\r\n            if (ownerOf(zodiacID) == msg.sender) {\r\n                result[resultIndex] = zodiacID;\r\n                resultIndex = resultIndex + 1;\r\n            }\r\n            zodiacID = zodiacID + 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function _randomGacha() private returns(uint256) {\r\n        uint256 gacha = _random() % 10000 + 1;\r\n        if (gacha <= 50) {\r\n            return 30;\r\n        }\r\n        if (gacha <= 150) {\r\n            return 24;\r\n        } \r\n        if (gacha <= 625) {\r\n            return 15;\r\n        } \r\n        if (gacha <= 2100) {\r\n            return 9;\r\n        } \r\n        return 0;\r\n    }\r\n    \r\n    function _randomStat() private returns(uint256, uint256, uint256, uint8) {\r\n        (uint8 animalID, uint256 initSTR, uint256 initAGI, uint256 initINT, uint8 group) = _randomElement();\r\n\r\n        uint256 gacha = _randomGacha();\r\n        uint256 b = 0;\r\n        if (gacha > 0) {\r\n            b = _random() % (gacha / 3) + 1;\r\n        } \r\n        \r\n        return (\r\n                _caculateSTR(group, animalID, initSTR) + b,\r\n                _caculateAGI(group, animalID, initAGI) + b,\r\n                _caculateINT(group, animalID, initINT) + b, \r\n                uint8(animalID)\r\n                );\r\n    }\r\n    \r\n    function _caculateSTR(uint8 _group, uint8 _animalID, uint256 _initSTR) private returns (uint256) {\r\n        if (_group == 1) {\r\n            return _random() % (valueAnimal[_animalID - 1] * 2) + _initSTR;\r\n        } \r\n        \r\n        return _random() % (valueAnimal[_animalID - 1]) + _initSTR;\r\n    }\r\n    \r\n    function _caculateAGI(uint8 _group, uint8 _animalID, uint256 _initAGI) private returns (uint256) {\r\n        if (_group == 2) {\r\n            return _random() % (valueAnimal[_animalID - 1] * 2) + _initAGI;\r\n        } \r\n        \r\n        return _random() % (valueAnimal[_animalID - 1]) + _initAGI;\r\n    }\r\n    \r\n    function _caculateINT(uint8 _group, uint8 _animalID, uint256 _initINT) private returns (uint256) {\r\n        if (_group == 3) {\r\n            return  _random() % (valueAnimal[_animalID - 1] * 2) + _initINT;\r\n        } \r\n        \r\n        return _random() % (valueAnimal[_animalID - 1]) + _initINT;\r\n    }\r\n    \r\n    // Random animal element\r\n    function _randomElement() private returns(uint8, uint256, uint256, uint256, uint8) {\r\n        uint8 element = uint8(_random() % 9 + 1);\r\n        if (element <= 3) { // STR\r\n            return (uint8(_randomAnimal(1)), 50, 30, 20, 1);\r\n        } \r\n        if (element <= 6) { // AGI\r\n            return (uint8(_randomAnimal(2)), 25, 50, 25, 2);\r\n        } \r\n        return (uint8(_randomAnimal(3)), 30, 30, 40, 3);\r\n    }\r\n    \r\n    function _randomAnimal(uint8 _animalGroup) private returns(uint256){\r\n        uint256 animal = _random() % 3 + 1;\r\n        return animals[_animalGroup][animal];\r\n    }\r\n    \r\n    function _random() private returns(uint256) {\r\n        nonce += 1;\r\n        return uint256(keccak256(abi.encodePacked(now, nonce)));\r\n    }\r\n    \r\n    function whiteListAddr(address _addr, uint256 _setCount) public onlyOwner {\r\n        whiteListed[_addr] = _setCount;\r\n    }\r\n    \r\n    // Below two emergency functions will be never used in normal situations.\r\n    // These function is only prepared for emergency case such as smart contract hacking Vulnerability or smart contract abolishment\r\n    // Withdrawn fund by these function cannot belong to any operators or owners.\r\n    // Withdrawn fund should be distributed to individual accounts having original ownership of withdrawn fund.\r\n    function emergencyWithdrawalETH(uint256 amount) public onlyOwner {\r\n        require(msg.sender.send(amount));\r\n    }\r\n    \r\n    // Fallback function\r\n    function() external payable {\r\n    }\r\n}"}}}