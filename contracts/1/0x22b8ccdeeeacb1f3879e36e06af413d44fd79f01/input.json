{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "EmiRouter.Full.sol": {
      "content": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: @openzeppelin/contracts/math/SafeMath.sol\n\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/interfaces/IEmiswap.sol\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.0;\n\n\ninterface IEmiswapRegistry {\n    function pools(IERC20 token1, IERC20 token2)\n        external\n        view\n        returns (IEmiswap);\n\n    function isPool(address addr) external view returns (bool);\n\n    function deploy(IERC20 tokenA, IERC20 tokenB) external returns (IEmiswap);\n    function getAllPools() external view returns (IEmiswap[] memory);\n}\n\ninterface IEmiswap {\n    function fee() external view returns (uint256);\n\n    function tokens(uint256 i) external view returns (IERC20);\n\n    function deposit(\n        uint256[] calldata amounts,\n        uint256[] calldata minAmounts,\n        address referral\n    ) external payable returns (uint256 fairSupply);\n\n    function withdraw(uint256 amount, uint256[] calldata minReturns) external;\n\n    function getBalanceForAddition(IERC20 token)\n        external\n        view\n        returns (uint256);\n\n    function getBalanceForRemoval(IERC20 token) external view returns (uint256);\n\n    function getReturn(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount\n    ) external view returns (uint256, uint256);\n\n    function swap(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount,\n        uint256 minReturn,\n        address to,\n        address referral\n    ) external payable returns (uint256 returnAmount);\n\n    function initialize(IERC20[] calldata assets) external;\n}\n\n// File: contracts/libraries/EmiswapLib.sol\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.0;\n\n\n\n\nlibrary EmiswapLib {\n    using SafeMath for uint256;\n    uint256 public constant FEE_DENOMINATOR = 1e18;\n\n    function previewSwapExactTokenForToken(\n        address factory,\n        address tokenFrom,\n        address tokenTo,\n        uint256 ammountFrom\n    ) internal view returns (uint256 ammountTo) {\n        IEmiswap pairContract =\n            IEmiswapRegistry(factory).pools(IERC20(tokenFrom), IERC20(tokenTo));\n\n        if (pairContract != IEmiswap(0)) {\n            (,ammountTo) = pairContract.getReturn(\n                IERC20(tokenFrom),\n                IERC20(tokenTo),\n                ammountFrom\n            );\n        }\n    }\n\n    /**************************************************************************************\n     * get preview result of virtual swap by route of tokens\n     **************************************************************************************/\n    function previewSwapbyRoute(\n        address factory,\n        address[] memory path,\n        uint256 ammountFrom\n    ) internal view returns (uint256 ammountTo) {\n        for (uint256 i = 0; i < path.length - 1; i++) {\n            if (path.length >= 2) {\n                ammountTo = previewSwapExactTokenForToken(\n                    factory,\n                    path[i],\n                    path[i + 1],\n                    ammountFrom\n                );\n\n                if (i == (path.length - 2)) {\n                    return (ammountTo);\n                } else {\n                    ammountFrom = ammountTo;\n                }\n            }\n        }\n    }\n\n    function fee(address factory) internal view returns (uint256) {\n        return IEmiswap(factory).fee();\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        address factory,\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal view returns (uint256 amountIn) {\n        require(amountOut > 0, \"EmiswapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"EmiswapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator =\n            reserveOut.sub(amountOut).mul(\n                uint256(1000000000000000000).sub(fee(factory)).div(1e15)\n            ); // 997\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        address factory,\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal view returns (uint256 amountOut) {\n        if (amountIn == 0 || reserveIn == 0 || reserveOut == 0) {\n            return (0);\n        }\n\n        uint256 amountInWithFee =\n            amountIn.mul(\n                uint256(1000000000000000000).sub(fee(factory)).div(1e15)\n            ); //997\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = (denominator == 0 ? 0 : amountOut =\n            numerator /\n            denominator);\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"EmiswapLibrary: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            IEmiswap pairContract =\n                IEmiswapRegistry(factory).pools(\n                    IERC20(IERC20(path[i])),\n                    IERC20(path[i - 1])\n                );\n\n            uint256 reserveIn;\n            uint256 reserveOut;\n\n            if (address(pairContract) != address(0)) {\n                reserveIn = IEmiswap(pairContract).getBalanceForAddition(\n                    IERC20(path[i - 1])\n                );\n                reserveOut = IEmiswap(pairContract).getBalanceForRemoval(\n                    IERC20(path[i])\n                );\n            }\n\n            amounts[i - 1] = getAmountIn(\n                factory,\n                amounts[i],\n                reserveIn,\n                reserveOut\n            );\n        }\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"EmiswapLibrary: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i = 0; i < path.length - 1; i++) {\n            IEmiswap pairContract =\n                IEmiswapRegistry(factory).pools(\n                    IERC20(IERC20(path[i])),\n                    IERC20(path[i + 1])\n                );\n\n            uint256 reserveIn;\n            uint256 reserveOut;\n\n            if (address(pairContract) != address(0)) {\n                reserveIn = IEmiswap(pairContract).getBalanceForAddition(\n                    IERC20(path[i])\n                );\n                reserveOut = IEmiswap(pairContract).getBalanceForRemoval(\n                    IERC20(path[i + 1])\n                );\n            }\n\n            amounts[i + 1] = getAmountOut(\n                factory,\n                amounts[i],\n                reserveIn,\n                reserveOut\n            );\n        }\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"EmiswapLibrary: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"EmiswapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n}\n\n// File: contracts/libraries/TransferHelper.sol\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n\n// File: contracts/interfaces/IWETH.sol\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.0;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n\n// File: contracts/EmiRouter.sol\n\n// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.6.2;\npragma experimental ABIEncoderV2;\n\n\n\n\n\n\n\ncontract EmiRouter {\n    using SafeMath for uint256;\n\n    address public factory;\n    address public WETH;\n\n    struct PoolData {\n        IEmiswap pool;\n        uint256 balanceA;\n        uint256 balanceB;\n    }\n\n    event Log(uint256 a, uint256 b);\n\n    constructor(address _factory, address _wEth) public {\n        factory = _factory;\n        WETH = _wEth;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** Pool Info ****\n\n    function tokenToIERC(IERC20 _token) public view returns (IERC20) {\n        return (address(_token) == address(0) ? IERC20(WETH) : _token);\n    }\n\n    function getPoolDataList(\n        IERC20[] memory tokenAList,\n        IERC20[] memory tokenBList\n    ) public view returns (PoolData[] memory dataList) {\n        if (tokenAList.length > 0 && tokenAList.length == tokenBList.length) {\n            dataList = new PoolData[](tokenAList.length);\n            for (uint256 i = 0; i < tokenAList.length; i++) {\n                if (\n                    address(\n                        IEmiswapRegistry(address(factory)).pools(\n                            tokenToIERC(tokenAList[i]),\n                            tokenToIERC(tokenBList[i])\n                        )\n                    ) != address(0)\n                ) {\n                    dataList[i].pool = IEmiswapRegistry(address(factory)).pools(\n                        tokenToIERC(tokenAList[i]),\n                        tokenToIERC(tokenBList[i])\n                    );\n                    dataList[i].balanceA = IEmiswap(address(dataList[i].pool))\n                        .getBalanceForAddition(tokenToIERC(tokenAList[i]));\n                    dataList[i].balanceB = IEmiswap(address(dataList[i].pool))\n                        .getBalanceForAddition(tokenToIERC(tokenBList[i]));\n                }\n            }\n        } else {\n            dataList = new PoolData[](1);\n        }\n    }\n\n    function getReservesByPool(address pool)\n        public\n        view\n        returns (uint256 _reserve0, uint256 _reserve1)\n    {\n        _reserve0 = IEmiswap(pool).getBalanceForAddition(\n            IEmiswap(pool).tokens(0)\n        );\n        _reserve1 = IEmiswap(pool).getBalanceForAddition(\n            IEmiswap(pool).tokens(1)\n        );\n    }\n\n    function getReserves(IERC20 token0, IERC20 token1)\n        public\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            address poolAddresss\n        )\n    {\n        if (\n            address(\n                IEmiswapRegistry(address(factory)).pools(\n                    tokenToIERC(token0),\n                    tokenToIERC(token1)\n                )\n            ) != address(0)\n        ) {\n            _reserve0 = IEmiswapRegistry(address(factory))\n                .pools(tokenToIERC(token0), tokenToIERC(token1))\n                .getBalanceForAddition(tokenToIERC(token0));\n            _reserve1 = IEmiswapRegistry(address(factory))\n                .pools(tokenToIERC(token0), tokenToIERC(token1))\n                .getBalanceForAddition(tokenToIERC(token1));\n            poolAddresss = address(\n                IEmiswapRegistry(address(factory)).pools(\n                    tokenToIERC(token0),\n                    tokenToIERC(token1)\n                )\n            );\n        }\n    }\n\n    function getExpectedReturn(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount\n    )\n        public\n        view\n        returns (uint256 returnAmount, uint256[] memory distribution)\n    {\n        address[] memory path;\n        path = new address[](2);\n        path[0] = address(tokenToIERC(fromToken));\n        path[1] = address(tokenToIERC(destToken));\n\n        returnAmount = getAmountsOut(amount, path)[1];\n        uint256[] memory _distribution;\n        _distribution = new uint256[](34);\n        _distribution[12] = 1;\n        distribution = _distribution;\n    }\n\n    function resetAllowance(address token, address pairContract) public {\n        if (IERC20(token).allowance(address(this), pairContract) > 0) {\n            TransferHelper.safeApprove(token, pairContract, 0);\n        }\n    }\n\n\n    // **** Liquidity ****\n    /**\n     * @param tokenA address of first token in pair\n     * @param tokenB address of second token in pair\n     * @return LP balance\n     */\n    function getLiquidity(address tokenA, address tokenB)\n        external\n        view\n        returns (uint256)\n    {\n        return (\n            IERC20(\n                address(\n                    IEmiswapRegistry(factory).pools(\n                        IERC20(tokenA),\n                        IERC20(tokenB)\n                    )\n                )\n            )\n                .balanceOf(msg.sender)\n        );\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) internal returns (uint256 amountA, uint256 amountB) {\n        IERC20 ERC20tokenA = IERC20(tokenA);\n        IERC20 ERC20tokenB = IERC20(tokenB);\n        IEmiswap pairContract =\n            IEmiswapRegistry(factory).pools(ERC20tokenA, ERC20tokenB);\n        // create the pair if it doesn't exist yet\n        if (pairContract == IEmiswap(0)) {\n            pairContract = IEmiswapRegistry(factory).deploy(\n                ERC20tokenA,\n                ERC20tokenB\n            );\n        }\n\n        uint256 reserveA = pairContract.getBalanceForAddition(ERC20tokenA);\n        uint256 reserveB = pairContract.getBalanceForRemoval(ERC20tokenB);\n\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint256 amountBOptimal =\n                EmiswapLib.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(\n                    amountBOptimal >= amountBMin,\n                    \"EmiRouter:INSUFFICIENT_B_AMOUNT\"\n                );\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal =\n                    EmiswapLib.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(\n                    amountAOptimal >= amountAMin,\n                    \"EmiRouter:INSUFFICIENT_A_AMOUNT\"\n                );\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n\n    /**\n     * @param tokenA address of first token in pair\n     * @param tokenB address of second token in pair\n     * @param amountADesired desired amount of first token\n     * @param amountBDesired desired amount of second token\n     * @param amountAMin minimum amount of first token\n     * @param amountBMin minimum amount of second token\n     * @param ref referral address\n     * @return amountA added liquidity of first token\n     * @return amountB added liquidity of second token\n     * @return liquidity\n     */\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address ref\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        (amountA, amountB) = _addLiquidity(\n            tokenA,\n            tokenB,\n            amountADesired,\n            amountBDesired,\n            amountAMin,\n            amountBMin\n        );\n        IEmiswap pairContract =\n            IEmiswapRegistry(factory).pools(IERC20(tokenA), IERC20(tokenB));\n\n        TransferHelper.safeTransferFrom(\n            tokenA,\n            msg.sender,\n            address(this),\n            amountA\n        );\n        TransferHelper.safeTransferFrom(\n            tokenB,\n            msg.sender,\n            address(this),\n            amountB\n        );\n\n        resetAllowance(tokenA, address(pairContract));\n        resetAllowance(tokenB, address(pairContract));\n        TransferHelper.safeApprove(tokenA, address(pairContract), amountA);\n        TransferHelper.safeApprove(tokenB, address(pairContract), amountB);\n\n        uint256[] memory amounts;\n        amounts = new uint256[](2);\n        uint256[] memory minAmounts;\n        minAmounts = new uint256[](2);\n\n        if (tokenA < tokenB) {\n            amounts[0] = amountA;\n            amounts[1] = amountB;\n            minAmounts[0] = amountAMin;\n            minAmounts[1] = amountBMin;\n        } else {\n            amounts[0] = amountB;\n            amounts[1] = amountA;\n            minAmounts[0] = amountBMin;\n            minAmounts[1] = amountAMin;\n        }\n\n        //emit Log(amounts[0], amounts[1]);\n        liquidity = IEmiswap(pairContract).deposit(amounts, minAmounts, ref);\n\n        TransferHelper.safeTransfer(\n            address(pairContract),\n            msg.sender,\n            liquidity\n        );\n    }\n\n    /**\n     * @param token address of token\n     * @param amountTokenDesired desired amount of token\n     * @param amountTokenMin minimum amount of token\n     * @param amountETHMin minimum amount of ETH\n     * @param ref referral address\n     * @return amountToken added liquidity of token\n     * @return amountETH added liquidity of ETH\n     * @return liquidity\n     */\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address ref\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        )\n    {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        IEmiswap pairContract =\n            IEmiswapRegistry(factory).pools(IERC20(token), IERC20(WETH));\n        TransferHelper.safeTransferFrom(\n            token,\n            msg.sender,\n            address(this),\n            amountToken\n        );\n        // set allowance to 0\n        resetAllowance(token, address(pairContract));        \n        TransferHelper.safeApprove(token, address(pairContract), amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        resetAllowance(WETH, address(pairContract));\n        TransferHelper.safeApprove(WETH, address(pairContract), amountETH);\n\n        uint256[] memory amounts;\n        amounts = new uint256[](2);\n        uint256[] memory minAmounts;\n        minAmounts = new uint256[](2);\n\n        if (token < WETH) {\n            amounts[0] = amountToken;\n            amounts[1] = amountETH;\n            minAmounts[0] = amountTokenMin;\n            minAmounts[1] = amountETHMin;\n        } else {\n            amounts[0] = amountETH;\n            amounts[1] = amountToken;\n            minAmounts[0] = amountETHMin;\n            minAmounts[1] = amountTokenMin;\n        }\n        liquidity = IEmiswap(pairContract).deposit(amounts, minAmounts, ref);\n        TransferHelper.safeTransfer(\n            address(pairContract),\n            msg.sender,\n            liquidity\n        );\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    /**\n     * @param tokenA address of first token in pair\n     * @param tokenB address of second token in pair\n     * @param liquidity LP token\n     * @param amountAMin minimum amount of first token\n     * @param amountBMin minimum amount of second token\n     */\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin\n    ) public {\n        IEmiswap pairContract =\n            IEmiswapRegistry(factory).pools(IERC20(tokenA), IERC20(tokenB));\n        TransferHelper.safeTransferFrom(\n            address(pairContract),\n            msg.sender,\n            address(this),\n            liquidity\n        ); // send liquidity to this\n\n        uint256[] memory minReturns;\n        minReturns = new uint256[](2);\n\n        if (tokenA < tokenB) {\n            minReturns[0] = amountAMin;\n            minReturns[1] = amountBMin;\n        } else {\n            minReturns[0] = amountBMin;\n            minReturns[1] = amountAMin;\n        }\n        uint256 tokenAbalance = IERC20(tokenA).balanceOf(address(this));\n        uint256 tokenBbalance = IERC20(tokenB).balanceOf(address(this));\n\n        pairContract.withdraw(liquidity, minReturns);\n\n        tokenAbalance = IERC20(tokenA).balanceOf(address(this)).sub(\n            tokenAbalance\n        );\n        tokenBbalance = IERC20(tokenB).balanceOf(address(this)).sub(\n            tokenBbalance\n        );\n\n        TransferHelper.safeTransfer(tokenA, msg.sender, tokenAbalance);\n        TransferHelper.safeTransfer(tokenB, msg.sender, tokenBbalance);\n    }\n\n    /**\n     * @param token address of token\n     * @param liquidity LP token amount\n     * @param amountTokenMin minimum amount of token\n     * @param amountETHMin minimum amount of ETH\n     */\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin\n    ) public {\n        IEmiswap pairContract =\n            IEmiswapRegistry(factory).pools(IERC20(token), IERC20(WETH));\n        TransferHelper.safeTransferFrom(\n            address(pairContract),\n            msg.sender,\n            address(this),\n            liquidity\n        ); // send liquidity to this\n\n        uint256[] memory minReturns;\n        minReturns = new uint256[](2);\n\n        if (token < WETH) {\n            minReturns[0] = amountTokenMin;\n            minReturns[1] = amountETHMin;\n        } else {\n            minReturns[0] = amountETHMin;\n            minReturns[1] = amountTokenMin;\n        }\n\n        uint256 tokenbalance = IERC20(token).balanceOf(address(this));\n        uint256 WETHbalance = IERC20(WETH).balanceOf(address(this));\n\n        pairContract.withdraw(liquidity, minReturns);\n\n        tokenbalance = IERC20(token).balanceOf(address(this)).sub(tokenbalance);\n        WETHbalance = IERC20(WETH).balanceOf(address(this)).sub(WETHbalance);\n\n        TransferHelper.safeTransfer(token, msg.sender, tokenbalance);\n\n        // convert WETH and send back raw ETH\n        IWETH(WETH).withdraw(WETHbalance);\n        TransferHelper.safeTransferETH(msg.sender, WETHbalance);\n    }\n\n    // **** SWAP ****\n\n    function _swap_(\n        address tokenFrom,\n        address tokenTo,\n        uint256 ammountFrom,\n        address to,\n        address ref\n    ) internal returns (uint256 ammountTo) {\n        IEmiswap pairContract =\n            IEmiswapRegistry(factory).pools(IERC20(tokenFrom), IERC20(tokenTo));\n\n        (, uint256 amt1) = pairContract.getReturn(\n                IERC20(tokenFrom),\n                IERC20(tokenTo),\n                ammountFrom\n            );\n        if (amt1 > 0) {\n            resetAllowance(tokenFrom, address(pairContract));\n            TransferHelper.safeApprove(\n                tokenFrom,\n                address(pairContract),\n                ammountFrom\n            );            \n            ammountTo = pairContract.swap(\n                IERC20(tokenFrom),\n                IERC20(tokenTo),\n                ammountFrom,\n                0,\n                to,\n                ref\n            );\n        }\n    }\n\n    function _swapbyRoute(\n        address[] memory path,\n        uint256 ammountFrom,\n        address to,\n        address ref\n    ) internal returns (uint256 ammountTo) {\n        for (uint256 i = 0; i < path.length - 1; i++) {\n            if (path.length >= 2) {\n                uint256 _ammountTo =\n                    _swap_(\n                        path[i],\n                        path[i + 1],\n                        ammountFrom,\n                        (i == (path.length - 2) ? to : address(this)),\n                        ref\n                    );\n                if (i == (path.length - 2)) {\n                    return (_ammountTo);\n                } else {\n                    ammountFrom = _ammountTo;\n                }\n            }\n        }\n    }\n\n    /**\n     * @param amountIn exact in value of source token\n     * @param amountOutMin minimum amount value of result token\n     * @param path array of token addresses, represent the path for swaps\n     * @param to send result token to\n     * @param ref referral\n     * @return amounts result amount\n     */\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        address ref\n    ) external returns (uint256[] memory amounts) {\n        amounts = getAmountsOut(amountIn, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"EmiRouter:INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            address(this),\n            amountIn\n        );\n        _swapbyRoute(path, amountIn, to, ref);\n    }\n\n    /**\n     * @param amountOut exact in value of result token\n     * @param amountInMax maximum amount value of source token\n     * @param path array of token addresses, represent the path for swaps\n     * @param to send result token to\n     * @param ref referral\n     * @return amounts result amount values\n     */\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        address ref\n    ) external returns (uint256[] memory amounts) {\n        amounts = getAmountsIn(amountOut, path);\n        require(\n            amounts[0] <= amountInMax,\n            \"EmiRouter:EXCESSIVE_INPUT_AMOUNT\"\n        );\n\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            address(this),\n            amounts[0]\n        );\n        _swapbyRoute(path, amounts[0], to, ref);\n    }\n\n    /**\n     * @param amountOutMin minimum amount value of result token\n     * @param path array of token addresses, represent the path for swaps\n     * @param to send result token to\n     * @param ref referral\n     * @return amounts result token amount values\n     */\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        address ref\n    ) external payable returns (uint256[] memory amounts) {\n        require(path[0] == WETH, \"EmiRouter:INVALID_PATH\");\n        amounts = getAmountsOut(msg.value, path);\n        require(\n            amounts[amounts.length - 1] >= amountOutMin,\n            \"EmiRouter:INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IWETH(WETH).deposit{value: amounts[0]}();\n        _swapbyRoute(path, amounts[0], to, ref);\n    }\n\n    /**\n     * @param amountOut amount value of result ETH\n     * @param amountInMax maximum amount of source token\n     * @param path array of token addresses, represent the path for swaps, (WETH for ETH)\n     * @param to send result token to\n     * @param ref referral\n     * @return amounts result token amount values\n     */\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        address ref\n    ) external returns (uint256[] memory amounts) {\n        require(path[path.length - 1] == WETH, \"EmiRouter:INVALID_PATH\");\n        amounts = getAmountsIn(amountOut, path);\n        require(amounts[0] <= amountInMax, \"EmiRouter:EXCESSIVE_AMOUNT\");\n\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            address(this),\n            amounts[0]\n        );\n\n        uint256 result = _swapbyRoute(path, amounts[0], address(this), ref);\n\n        IWETH(WETH).withdraw(result);\n        TransferHelper.safeTransferETH(to, result);\n    }\n\n    /**\n     * @param amountIn amount value of source token\n     * @param path array of token addresses, represent the path for swaps, (WETH for ETH)\n     * @param to send result token to\n     * @param ref referral\n     */\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        address[] calldata path,\n        address to,\n        address ref\n    ) external {\n        require(path[path.length - 1] == WETH, \"EmiRouter:INVALID_PATH\");\n        TransferHelper.safeTransferFrom(\n            path[0],\n            msg.sender,\n            address(this),\n            amountIn\n        );\n\n        uint256 result = _swapbyRoute(path, amountIn, address(this), ref);\n\n        IWETH(WETH).withdraw(result);\n        TransferHelper.safeTransferETH(to, result);\n    }\n\n    /**\n     * @param amountOut amount of result tokens\n     * @param path array of token addresses, represent the path for swaps, (WETH for ETH)\n     * @param to send result token to\n     * @param ref referral\n     * @return amounts result token amount values\n     */\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        address ref\n    ) external payable returns (uint256[] memory amounts) {\n        require(path[0] == WETH, \"EmiRouter:INVALID_PATH\");\n        amounts = getAmountsIn(amountOut, path);\n        require(\n            amounts[0] <= msg.value,\n            \"EmiRouter:EXCESSIVE_INPUT_AMOUNT\"\n        );\n\n        IWETH(WETH).deposit{value: amounts[0]}();\n\n        _swapbyRoute(path, amounts[0], to, ref);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    /**\n     * @param amountIn amount of source token\n     * @param path array of token addresses, represent the path for swaps, (WETH for ETH)\n     * @return amounts result token amount values\n     */\n    function getAmountsOut(uint256 amountIn, address[] memory path)\n        public\n        view\n        returns (uint256[] memory amounts)\n    {\n        return EmiswapLib.getAmountsOut(factory, amountIn, path);\n    }\n\n    /**\n     * @param amountOut amount of result token\n     * @param path array of token addresses, represent the path for swaps, (WETH for ETH)\n     * @return amounts result token amount values\n     */\n    function getAmountsIn(uint256 amountOut, address[] memory path)\n        public\n        view\n        returns (uint256[] memory amounts)\n    {\n        return EmiswapLib.getAmountsIn(factory, amountOut, path);\n    }\n}\n"
    }
  }
}