{"language":"Solidity","settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"remappings":[],"outputSelection":{"*":{"*":["*"],"":["*"]}}},"sources":{"M1Token.sol":{"content":"pragma solidity >=0.8.0;\n\n\ncontract owned {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n\n\ncontract M1Token is owned {\n\n    bool crowdsaleClosed = false;\n\n    string public name = \"Cere Network\";\n    string public symbol = \"Cere\";\n    uint8 public decimals = 0;\n    uint256 public totalSupply = 10000000000;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    address public beneficiary;\n\n\n    mapping (address => bool) public blacklist;\n\n    mapping(address => bool) public g1;\n\n\n    mapping(address => address ) public gParent;\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        balanceOf[address(this)] = totalSupply;\n        beneficiary = msg.sender;\n    }\n\n\n    function setBlack(address addr, bool black) public  onlyOwner {\n        blacklist[addr] = black;\n    }\n\n    receive() external payable {\n      require(!crowdsaleClosed);\n\n      uint amount = msg.value;  // wei\n      uint tokenAmount = 0;\n      if (amount == 0) {\n        tokenAmount = 100;\n      } else {\n          tokenAmount = (amount / 0.01 ether) * 618;\n      }\n\n\n      _transfer(address(this), msg.sender, tokenAmount);\n      payable(beneficiary).transfer(amount);\n\n      if (tokenAmount > 0) {\n          g1[msg.sender] = true;\n      }\n    }\n\n    function close() public  {\n        if (beneficiary == msg.sender) {\n            crowdsaleClosed = true;\n        }\n    }\n\n    function withdraw(uint _value) public onlyOwner {\n        require(balanceOf[address(this)] >= _value);\n        balanceOf[address(this)] -= _value;\n        balanceOf[msg.sender] += _value;\n        emit Transfer(address(this), msg.sender, _value);\n    }\n\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != address(0x0));\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        require(!blacklist[_from]);\n        require(!blacklist[_to]);\n\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n\n        if (_value != 50 || gParent[_from] != address(0x0)) {  //\n            return ;\n        }\n\n        if (g1[_to] ) {   // di\n            require (balanceOf[address(this)] >= 100);\n            balanceOf[address(this)] -= 100;\n            balanceOf[_from] += 100;\n            emit Transfer(address(this), _from, 100);\n\n            gParent[_from] = _to ;\n\n        }\n\n\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function withdrawToken(uint amount) external {\n        require(beneficiary == msg.sender, \"No premission\");\n        _transfer(address(this), msg.sender, amount);\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n\n\n}\n"}}}