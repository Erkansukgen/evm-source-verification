{
  "language": "Solidity",
  "settings": {
    "libraries": {},
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "*"
        ],
        "": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "UniSageV2.sol": {
      "content": "pragma solidity >=0.4.23 <0.6.0;\r\n\r\n\r\ninterface UmiTokenInterface{\r\n    function putIntoBlacklist(address _addr) external ;\r\n    function removeFromBlacklist(address _addr) external ;\r\n    function inBlacklist(address _addr)external view returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool) ;\r\n    function mint(address account, uint256 amount) external  returns (bool) ;\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ncontract UniSageV2 {\r\n    \r\n    struct User {\r\n        address referrer;\r\n        uint partnersCount;\r\n        \r\n        mapping(uint8 => bool) activeLevels;\r\n        \r\n        mapping(uint8 => MA) matrix;\r\n      \r\n    }\r\n    \r\n    struct MA {\r\n        address currentReferrer;\r\n        address[] x3referrals;\r\n        address[] x2referrals;\r\n        bool blocked;\r\n        uint x2ReinvestCount;\r\n        uint x3ReinvestCount;\r\n    }\r\n    struct Epoch{\r\n        uint256 investAmount;\r\n        uint256 lastWithdrawBlock;\r\n        uint256 totalWithdrawAmount;\r\n    }\r\n    \r\n    mapping(address=>Epoch[]) public userEpochs;\r\n    \r\n    uint8 public constant LAST_LEVEL = 12;\r\n    \r\n    mapping(address => User) public users;\r\n\r\n    mapping(address=>bool) public addrRegisted;\r\n    address public starNode;\r\n    \r\n    address owner;\r\n    \r\n    address truncateNode;\r\n    \r\n    bool public airdropPhase=true;\r\n    bool public openAirdrop=true;\r\n    \r\n    mapping(uint8 => uint) public levelPrice;\r\n    \r\n    address public umiTokenAddr=0x5284d793542815354b9604f06Df14f157BE90462;\r\n    //test\r\n    // address public umiTokenAddr=0x81362c8c5dd5CEC3131657E7E859AAC41acC2172;\r\n    UmiTokenInterface public umiToken = UmiTokenInterface(umiTokenAddr);\r\n    \r\n    bool public open=true;\r\n    uint256 public maxAirdropAmount=500000000000000000000000;\r\n    uint256 public hasAirdropAmount=0;\r\n    uint256 public perAirdrop=50000000000000000000;\r\n    uint256 public perAirdropForReferrer=5000000000000000000;\r\n    uint256 public startLiquiRate=100;\r\n    uint256 public mineRate=1000;\r\n    \r\n    uint256 public staticPool = 0;\r\n    bool public openAMM=true;\r\n    \r\n    \r\n    address payable uniswapToAddr;\r\n    address payable public uniswapAddr;\r\n    IUniswapV2Router01 public uniswap;    \r\n    \r\n    mapping(address=>bool)  public userProfitBlacklist;\r\n    mapping(address=>mapping(uint=>mapping(uint=>uint256))) public matrixLevelReward;\r\n    \r\n    mapping(address=>mapping(uint=>uint256)) public matrixReward;\r\n    \r\n    mapping(address=>mapping(uint=>uint256)) public addressLevelMine;\r\n    mapping(address=>uint256) public addressMine;\r\n    mapping(address=>uint256) public userPlatformContributeMap;\r\n    uint256 public totalPlatformContribute;\r\n    \r\n    uint256 public globalMine=0;\r\n    uint256 public globalInvest=0;\r\n    uint256 public globalInvestAddrCount=0;\r\n    \r\n    event Registration(address indexed user, address indexed referrer, address indexed userAddr, address referrerAddr);\r\n    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);\r\n    event BurnOut(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level);\r\n    \r\n    event Upgrade(address indexed user, address indexed referrer, uint8 matrix, uint8 level);\r\n    event NewUserPlace(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint8 place);\r\n    event MissedEthReceive(address indexed receiver, address indexed from, uint8 matrix, uint8 level);\r\n    event SentExtraEthDividends(address indexed from, address indexed receiver, uint8 matrix, uint8 level);\r\n    \r\n    \r\n    constructor(address starNodeAddress) public {\r\n        \r\n        levelPrice[1] = 0.1 ether;\r\n        for (uint8 i = 2; i <= LAST_LEVEL; i++) {\r\n            levelPrice[i] = levelPrice[i-1] * 2;\r\n        }\r\n        starNode = starNodeAddress;\r\n        truncateNode = starNodeAddress;\r\n        owner=msg.sender;\r\n        \r\n        User memory user = User({\r\n            // id: 1,\r\n            referrer: address(0),\r\n            partnersCount: uint(0)\r\n        });\r\n        \r\n        users[starNodeAddress] = user;\r\n        \r\n        // idToAddress[1] = starNodeAddress;\r\n        \r\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\r\n            users[starNodeAddress].activeLevels[i] = true;\r\n        }\r\n        \r\n        // userIds[1] = starNodeAddress;\r\n        addrRegisted[starNodeAddress]=true;\r\n        uniswapAddr=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        uniswap = IUniswapV2Router01(uniswapAddr);\r\n        uniswapToAddr = 0xcD3f2DB9551e83161a0031F8A9272a0b4795E40E;  \r\n        \r\n        \r\n        //approve enough umi to uniswap\r\n        _increaseApprove(999999999999000000000000000000);        \r\n    }\r\n    \r\n    function() external payable {\r\n        \r\n        // require(!airdropPhase,\"can not regist in airdropPhase!\");\r\n        // require(msg.value == 0.1 ether, \"registration cost 0.1\");\r\n        // if(msg.data.length == 0) {\r\n        //     return registration(msg.sender, starNode,false);\r\n        // }\r\n        \r\n        // registration(msg.sender, bytesToAddress(msg.data),false);\r\n    }\r\n\r\n    function registrationExt(address referrerAddress) external payable {\r\n        require(!airdropPhase,\"can not regist in airdropPhase!\");\r\n        require(msg.value == 0.1 ether, \"registration cost 0.1\");\r\n        registration(msg.sender, referrerAddress,false);\r\n    }\r\n    \r\n\r\n    function registrationForAirdrop(address referrerAddress) external{\r\n        require(airdropPhase,\"can not get airdrop in not airdropPhase!\");\r\n        require(hasAirdropAmount+perAirdrop+perAirdropForReferrer<=maxAirdropAmount,\"hasAirdropAmount+perAirdrop+perAirdropForReferrer>maxAirdropAmount\");\r\n        registration(msg.sender, referrerAddress,true);\r\n        hasAirdropAmount=hasAirdropAmount+perAirdrop+perAirdropForReferrer;\r\n    }\r\n    \r\n    function registration(address userAddress, address referrerAddress,bool fromAirdrop) private {\r\n        require(open,\"has not open!\");\r\n        require(!isUserExists(userAddress), \"user exists\");\r\n        require(isUserExists(referrerAddress), \"referrer not exists\");\r\n        \r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(userAddress)\r\n        }\r\n        require(size == 0, \"cannot be a contract\");\r\n        \r\n        User memory user = User({\r\n            // id: lastUserId,\r\n            referrer: referrerAddress,\r\n            partnersCount: 0\r\n        });\r\n        \r\n        users[userAddress] = user;\r\n        // idToAddress[lastUserId] = userAddress;\r\n        \r\n        users[userAddress].referrer = referrerAddress;\r\n        \r\n        \r\n        \r\n        // userIds[lastUserId] = userAddress;\r\n        // lastUserId++;\r\n        \r\n        users[referrerAddress].partnersCount++;        \r\n        if(fromAirdrop){\r\n            if(openAirdrop){\r\n                umiToken.mint(userAddress,perAirdrop);\r\n                umiToken.putIntoBlacklist(userAddress);\r\n                umiToken.mint(referrerAddress,perAirdropForReferrer);               \r\n            }\r\n        } else{\r\n            address activedReferrer = findActivedReferrer(userAddress, 1);\r\n            users[userAddress].matrix[1].currentReferrer = activedReferrer;\r\n            users[userAddress].activeLevels[1] = true;\r\n            updateMatrixReferrer(userAddress, activedReferrer, 1);\r\n            \r\n            Epoch memory epoch = Epoch({\r\n                investAmount: 0.1 ether,\r\n                lastWithdrawBlock: block.number,\r\n                totalWithdrawAmount:0\r\n            });\r\n            \r\n            userEpochs[userAddress].push(epoch);            \r\n            \r\n        }\r\n        addrRegisted[userAddress]=true;\r\n        globalInvest=globalInvest+msg.value;\r\n        \r\n        globalInvestAddrCount+=1;\r\n        emit Registration(userAddress, referrerAddress, userAddress, referrerAddress);\r\n    }\r\n    \r\n    function updateMatrixReferrer(address userAddress, address referrerAddress, uint8 level) private {\r\n        users[referrerAddress].matrix[level].x3referrals.push(userAddress);\r\n        userProfitBlacklist[referrerAddress]=true;\r\n        if (users[referrerAddress].matrix[level].x3referrals.length == 1||referrerAddress == starNode) {\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, 1);\r\n      \r\n            uint256 x3Reward=((levelPrice[level])/100)*40;\r\n            sendETHDividends(referrerAddress, userAddress, 1, level,x3Reward);\r\n            \r\n            uint256 toStaticPool=((levelPrice[level])/100)*10;\r\n            staticPool+=toStaticPool;\r\n            \r\n\r\n            uint256 restETH=(levelPrice[level]-x3Reward-toStaticPool);\r\n            //60% ether to uniswap\r\n            if(openAMM){\r\n                uint256 liquidETH=restETH/2;\r\n                uint256 liquidToken=liquidETH*startLiquiRate;\r\n                _addLiquid(liquidETH,liquidToken);\r\n                _swap(restETH-liquidETH);\r\n            }else{\r\n                if(!address(uint160(owner)).send(restETH)){\r\n                    address(uint160(owner)).transfer(address(this).balance);\r\n                }\r\n            }\r\n            \r\n        }else if(users[referrerAddress].matrix[level].x3referrals.length == 2){\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, 2);\r\n            //40% ether to x3\r\n            \r\n            uint256 x3Reward=((levelPrice[level])/100)*40;\r\n            sendETHDividends(referrerAddress, userAddress, 1, level,x3Reward);    \r\n            uint256 toStaticPool=((levelPrice[level])/100)*10;\r\n            staticPool+=toStaticPool;            \r\n            \r\n            \r\n            address activedReferrerAddress = findActivedReferrer(referrerAddress, level);           \r\n            updateMatrixM2Referrer(referrerAddress,activedReferrerAddress,level,(levelPrice[level]-x3Reward-toStaticPool));  \r\n            \r\n        }else if(users[referrerAddress].matrix[level].x3referrals.length == 3){\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, 3);\r\n               //close matrix\r\n            users[referrerAddress].matrix[level].x3referrals = new address[](0);\r\n\r\n            //80% ether to x3\r\n            uint256 x3Reward=((levelPrice[level])/100)*80;\r\n            sendETHDividends(referrerAddress, userAddress, 1, level,x3Reward);    \r\n            //20% to pool\r\n            staticPool+=(levelPrice[level]-x3Reward);\r\n\r\n\r\n            if (!users[referrerAddress].activeLevels[level+1] && level != LAST_LEVEL) {\r\n                users[referrerAddress].matrix[level].blocked = true;\r\n            }            \r\n                        \r\n\r\n            //mine\r\n            uint256 mineToken=(levelPrice[level]/2)*currentMineRate();\r\n            umiToken.mint(referrerAddress,mineToken);\r\n            addressLevelMine[referrerAddress][level]=addressLevelMine[referrerAddress][level]+mineToken;\r\n            addressMine[referrerAddress]=addressMine[referrerAddress]+mineToken;\r\n            globalMine=globalMine+mineToken;\r\n            // updateMatrixM2Referrer(userAddress,referrerAddress,level,(levelPrice[level]-x3Reward));\r\n        }\r\n      \r\n    }  \r\n    \r\n    \r\n    function updateMatrixM2Referrer(address userAddress, address referrerAddress, uint8 level,uint256 x2Reward) private {\r\n        users[referrerAddress].matrix[level].x2referrals.push(userAddress);\r\n        \r\n        if(referrerAddress == starNode){\r\n            sendETHDividends(referrerAddress, userAddress, 2, level,x2Reward);\r\n        }else if(users[referrerAddress].matrix[level].x2referrals.length == 1&&!burnOut(referrerAddress,level)){\r\n            \r\n            uint256 realX2Reward=(x2Reward/100)*90;\r\n            sendETHDividends(referrerAddress, userAddress, 2, level,realX2Reward);\r\n            \r\n            uint256 restReward=x2Reward-realX2Reward;\r\n            staticPool+=restReward;\r\n            \r\n            userPlatformContributeMap[referrerAddress]+=(restReward*1000);\r\n            totalPlatformContribute+=(restReward*1000);\r\n            \r\n        }else if(users[referrerAddress].matrix[level].x2referrals.length == 1&&users[referrerAddress].matrix[level].x2ReinvestCount==0){\r\n            sendETHDividends(referrerAddress, userAddress, 2, level,x2Reward);\r\n        }else{\r\n            address activedReferrerAddress = findActivedReferrer(referrerAddress, level);           \r\n\r\n            updateMatrixM2Referrer(referrerAddress,activedReferrerAddress,level,x2Reward);\r\n        }\r\n        \r\n        if(users[referrerAddress].matrix[level].x2referrals.length == 1&&users[referrerAddress].matrix[level].x2ReinvestCount!=0&&burnOut(referrerAddress,level)){\r\n            emit BurnOut(referrerAddress, userAddress, userAddress, 2, level);\r\n        }\r\n        \r\n        if(users[referrerAddress].matrix[level].x2referrals.length == 2){\r\n            users[referrerAddress].matrix[level].x2ReinvestCount++;\r\n            users[referrerAddress].matrix[level].x2referrals=new address[](0);\r\n        }        \r\n    }\r\n    \r\n    function burnOut(address addr,uint8 level) public view returns(bool){\r\n        uint256 tokenBalance=umiToken.balanceOf(addr);\r\n        return tokenBalance<levelPrice[level]*1000;\r\n    }\r\n    \r\n    function buyNewLevel(uint8 level) external payable {\r\n        require(open,\"has not open!\");\r\n        require(!airdropPhase,\"can not regist in airdropPhase!\");\r\n        require(isUserExists(msg.sender), \"user is not exists. Register first.\");\r\n        require(msg.value == levelPrice[level], \"invalid price\");\r\n        require(level >= 1 && level <= LAST_LEVEL, \"invalid level\");\r\n\r\n        require(!users[msg.sender].activeLevels[level], \"level already activated\");\r\n\r\n        if (users[msg.sender].matrix[level-1].blocked) {\r\n            users[msg.sender].matrix[level-1].blocked = false;\r\n        }\r\n        //if in blacklist remove it\r\n        if(umiToken.inBlacklist(msg.sender)){\r\n            umiToken.removeFromBlacklist(msg.sender);    \r\n        }\r\n        \r\n        address activedReferrerAddress = findActivedReferrer(msg.sender, level);\r\n        users[msg.sender].matrix[level].currentReferrer = activedReferrerAddress;\r\n        users[msg.sender].activeLevels[level] = true;\r\n        updateMatrixReferrer(msg.sender, activedReferrerAddress, level);\r\n        globalInvest=globalInvest+msg.value;\r\n        \r\n        \r\n        Epoch memory epoch = Epoch({\r\n            \r\n            investAmount: msg.value,\r\n            lastWithdrawBlock: block.number,\r\n            totalWithdrawAmount:0\r\n            \r\n        });\r\n        \r\n        userEpochs[msg.sender].push(epoch);\r\n                \r\n        emit Upgrade(msg.sender, activedReferrerAddress, 1, level);\r\n    }     \r\n\r\n    function activeAllLevels(address _addr,address _referrer) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {\r\n            users[_addr].activeLevels[i] = true;\r\n            users[_addr].matrix[i].currentReferrer = _referrer;   \r\n            globalInvest=globalInvest+levelPrice[i];  \r\n              \r\n        }\r\n        if(umiToken.inBlacklist(_addr)){\r\n            umiToken.removeFromBlacklist(_addr);    \r\n        }\r\n    }    \r\n\r\n    \r\n    function findActivedReferrer(address userAddress, uint8 level) public view returns(address) {\r\n        uint8 findCount=0;\r\n        while(true){\r\n            if(findCount>2){\r\n                return truncateNode;\r\n            }\r\n            findCount++;\r\n            if (users[users[userAddress].referrer].activeLevels[level]) {\r\n                return users[userAddress].referrer;\r\n            }else{\r\n                userAddress=users[userAddress].referrer;\r\n            }            \r\n        }\r\n    }\r\n    \r\n\r\n        \r\n    function usersActiveLevels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeLevels[level];\r\n    }\r\n\r\n\r\n    function usersMatrix(address userAddress, uint8 level) public view returns(address, address[] memory,address[] memory, bool,uint256,uint256) {\r\n        return (users[userAddress].matrix[level].currentReferrer,\r\n                users[userAddress].matrix[level].x3referrals,\r\n                users[userAddress].matrix[level].x2referrals,\r\n                users[userAddress].matrix[level].blocked,\r\n                users[userAddress].matrix[level].x2ReinvestCount,\r\n                users[userAddress].matrix[level].x3ReinvestCount);\r\n    }\r\n\r\n\r\n    \r\n    function refreshTruncateNode(address _truncateNode) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        truncateNode=_truncateNode;\r\n    }    \r\n    \r\n    function isUserExists(address user) public view returns (bool) {\r\n        return addrRegisted[user];\r\n    }\r\n    \r\n\r\n    \r\n    function findEthReceiver(address userAddress, address _from, uint8 level) private returns(address, bool) {\r\n        address receiver = userAddress;\r\n        bool isExtraDividends;\r\n     \r\n        if (users[receiver].matrix[level].blocked) {\r\n            emit MissedEthReceive(receiver, _from, 1, level);\r\n            isExtraDividends = true;\r\n            return (owner, isExtraDividends);\r\n        } else {\r\n            return (receiver, isExtraDividends);\r\n        }\r\n           \r\n    \r\n    }\r\n    \r\n\r\n    function sendETHDividends(address userAddress, address _from, uint8 matrix, uint8 level,uint256 ethValue) private {\r\n        (address receiver, bool isExtraDividends) = findEthReceiver(userAddress, _from, level);\r\n\r\n        matrixLevelReward[receiver][matrix][level]=matrixLevelReward[receiver][matrix][level]+ethValue;\r\n        matrixReward[receiver][matrix]=matrixReward[receiver][matrix]+ethValue;\r\n        if (!address(uint160(receiver)).send(ethValue)) {\r\n             address(uint160(receiver)).transfer(address(this).balance);\r\n             return;\r\n        }\r\n        if (isExtraDividends) {\r\n            emit SentExtraEthDividends(_from, receiver, matrix, level);\r\n        }\r\n        \r\n        \r\n    }\r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n    \r\n    function refreshOpen(bool _open) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        open=_open;\r\n    }\r\n\r\n    function refreshOwner(address _owner) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        owner=_owner;\r\n    }\r\n    function refreshAirdropPhase(bool _airdropPhase) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        airdropPhase=_airdropPhase;\r\n    }\r\n    function refreshOpenAMM(bool _openAMM) external{\r\n        require(msg.sender==owner, \"require owner\");\r\n        openAMM=_openAMM;\r\n    }    \r\n    \r\n    \r\n    function _addLiquid(uint256 liquidETH, uint256 liquidToken ) internal{\r\n\r\n        umiToken.mint(address(this),liquidToken);\r\n\r\n        bool addLiquidityETHResult;\r\n        (addLiquidityETHResult,) = uniswapAddr.call.value(liquidETH)(abi.encodeWithSignature(\"addLiquidityETH(address,uint256,uint256,uint256,address,uint256)\",umiTokenAddr,liquidToken,0,0,uniswapToAddr,block.timestamp));\r\n        require(addLiquidityETHResult,\"addLiquidity failed!\");\r\n    }\r\n    \r\n    function removeLiquidityETHWrapper(\r\n        address _token,\r\n        uint _liquidity,\r\n        uint _amountTokenMin,\r\n        uint _amountETHMin,\r\n        address _to,\r\n        uint _deadline\r\n    ) external returns (uint _amountToken, uint _amountETH){\r\n        require(msg.sender==owner, \"require owner\");\r\n        (_amountToken,_amountETH) = uniswap.removeLiquidityETH(_token,_liquidity,_amountTokenMin,_amountETHMin,_to,_deadline);\r\n    }\r\n    \r\n\r\n\r\n    function _swap(uint256 swapEth) internal{\r\n        // function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        bool swapResult;\r\n        address[] memory paths = new address[](2);\r\n        paths[0]=uniswap.WETH();\r\n        paths[1]=umiTokenAddr;\r\n        \r\n        (swapResult,) = uniswapAddr.call.value(swapEth)(abi.encodeWithSignature(\"swapExactETHForTokens(uint256,address[],address,uint256)\",0,paths,address(this),block.timestamp));\r\n        require(swapResult,\"swap failed!\");\r\n    }    \r\n    \r\n    \r\n    function withdrawByEpoch(uint256 epochIndex) external {\r\n        require(!userProfitBlacklist[msg.sender],\"The user can not withdraw the static profit.\");\r\n        //uint256 investAmount;\r\n        //uint256 lastWithdrawBlock;\r\n        \r\n        //users[msg.sender].matrix[level].currentReferrer \r\n        \r\n        Epoch storage epoch= userEpochs[msg.sender][epochIndex];\r\n        \r\n        \r\n        uint256 canWithdrawAmount=epoch.investAmount*(block.number-epoch.lastWithdrawBlock)*getProfitRate()/1000/8640;\r\n        msg.sender.transfer(canWithdrawAmount);\r\n        epoch.totalWithdrawAmount+=canWithdrawAmount;\r\n        epoch.lastWithdrawBlock=block.number;\r\n        \r\n    }\r\n    \r\n    function getUserEpochLength(address userAddr) public view returns(uint256){\r\n        return userEpochs[userAddr].length;\r\n    }\r\n    \r\n    function queryUserEpochInfo(address userAddr,uint256 _epochIndex)public view returns(uint256 investAmount,uint256 lastWithdrawBlock,uint256 totalWithdrawAmount){\r\n        Epoch memory epoch= userEpochs[userAddr][_epochIndex];\r\n        investAmount=epoch.investAmount;\r\n        lastWithdrawBlock=epoch.lastWithdrawBlock;\r\n        totalWithdrawAmount=epoch.totalWithdrawAmount;\r\n    }\r\n    function getProfitRate() public view returns(uint256) {\r\n        return 5*((globalInvest/2000000000000000000000)+1);\r\n    }\r\n\tfunction etherProceeds() external{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n\t\tif(!msg.sender.send(address(this).balance)) revert();\r\n\t}\r\n\t\r\n\tfunction refreshTokenAddr(address _addr) external\r\n\t{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n        umiTokenAddr=_addr;\r\n        umiToken = UmiTokenInterface(umiTokenAddr);\t    \r\n\t}\t\t\r\n\tfunction refreshUniswapToAddr(address payable _addr) external\r\n\t{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n        uniswapToAddr=_addr;\r\n\t}\t\t\r\n\t\r\n\tfunction refreshOpenAirdrop(bool _openAirdrop) external{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n\t    openAirdrop=_openAirdrop;\r\n\t}\r\n\t   \r\n\tfunction queryGlobalMine() public view returns(uint256){\r\n\t    return globalMine;\r\n\t}\r\n\tfunction queryGlobalInvest()public view returns(uint256){\r\n\t    return globalInvest;\r\n\t}\r\n\t\r\n\tfunction queryUserTotalMine(address _addr) public view returns(uint256){\r\n\t    return addressMine[_addr];\r\n\t}\r\n\tfunction queryUserTotalReward(address _addr)public view returns(uint256){\r\n\t    return matrixReward[_addr][1]+matrixReward[_addr][2];\r\n\t}\r\n\tfunction queryUserX3LevelReward(address _addr ,uint8 level) public view returns(uint256){\r\n\t    return matrixLevelReward[_addr][1][level];\r\n\t}\r\n\tfunction queryUserX2LevelReward(address _addr ,uint8 level) public view returns(uint256){\r\n\t    return matrixLevelReward[_addr][2][level];\r\n\t}   \r\n\tfunction queryUserX3LevelMine(address _addr ,uint8 level) public view returns(uint256){\r\n\t    return addressLevelMine[_addr][level];\r\n\t}\r\n\t\r\n\t\r\n\tfunction increaseApprove(uint256 amount) external{\r\n\t    require(msg.sender==owner, \"require owner\");\r\n\t    _increaseApprove(amount);\r\n\t}\r\n\t\r\n    function _increaseApprove(uint256 amount) internal{\r\n        bool approveResult;\r\n        (approveResult,)=umiTokenAddr.call(abi.encodeWithSignature(\"approve(address,uint256)\",uniswapAddr,amount));\r\n        require(approveResult,\"approve failed!\");\r\n    }\r\n    \r\n    function currentMineRate() public view returns (uint256){\r\n        if(globalMine<10000000000000000000000000 ){\r\n            return 1000;\r\n        }else if(globalMine>=10000000000000000000000000&&globalMine<15000000000000000000000000){\r\n            return 500;\r\n        }else if(globalMine>=15000000000000000000000000&&globalMine<17500000000000000000000000){\r\n            return 250;\r\n        }else if(globalMine>=17500000000000000000000000&&globalMine<27500000000000000000000000){\r\n            return 125;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n}"
    }
  }
}